{"dependencies":{"<&'a T as value::index::Index>::index_into":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<&'a T as value::index::Index>::index_into_mut":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<&'a T as value::index::Index>::index_or_insert":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"<&'a mut R as read::Read<'de>>::byte_offset":[],"<&'a mut R as read::Read<'de>>::decode_hex_escape":["std::marker::Sized","std::result::Result"],"<&'a mut R as read::Read<'de>>::discard":[],"<&'a mut R as read::Read<'de>>::ignore_str":["std::marker::Sized","std::result::Result"],"<&'a mut R as read::Read<'de>>::next":["std::marker::Sized","std::result::Result"],"<&'a mut R as read::Read<'de>>::parse_str":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut R as read::Read<'de>>::parse_str_raw":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut R as read::Read<'de>>::peek":["std::marker::Sized","std::result::Result"],"<&'a mut R as read::Read<'de>>::peek_position":["read::Position"],"<&'a mut R as read::Read<'de>>::position":["read::Position"],"<&'a mut R as read::Read<'de>>::set_failed":[],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bool":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_byte_buf":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bytes":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_char":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_enum":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_identifier":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_ignored_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_newtype_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_option":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_seq":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_str":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_string":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str":["error::Error","ser::Serializer","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter":["<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter","std::marker::Sized","std::option::Option"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bool":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bytes":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_char":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f32":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f64":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i128":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i16":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i32":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i64":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i8":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_map":["ser::Serializer","std::marker::Sized","std::option::Option","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_struct":["error::Category","map::Map","ser::Serializer","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_variant":["error::Category","map::Map","ser::Serializer","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_none":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_seq":["ser::Serializer","std::marker::Sized","std::option::Option","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_some":["error::Category","map::Map","ser::Serializer","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_str":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct_variant":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_struct":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_variant":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u128":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u16":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u32":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u64":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u8":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_struct":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_variant":["ser::Serializer","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_bool":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_byte_buf":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_bytes":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_char":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_enum":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_f32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_f64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_identifier":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_ignored_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_option":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_seq":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_str":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_string":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F> as std::fmt::Write>::write_str":["<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter","std::marker::Sized","std::option::Option","std::result::Result"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapAccess","serde::de::MapAccess","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Error","serde::de::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::expecting":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_f64":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","error::Error","serde::de::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result"],"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i64":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","std::marker::Sized","std::result::Result"],"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u64":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","std::marker::Sized","std::result::Result"],"<<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::flush":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::write":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed":["de::Deserializer","de::MapAccess","serde::de::DeserializeSeed","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::de::KeyClassifier"],"<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_value_seed":["de::Deserializer","de::MapAccess","serde::de::DeserializeSeed","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::de::KeyClassifier"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bool":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_byte_buf":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bytes":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_char":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_enum":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_identifier":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_ignored_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_newtype_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_option":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_seq":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_str":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_string":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::MapKey","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed":["de::Deserializer","de::SeqAccess","serde::de::DeserializeSeed","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::de::KeyClassifier"],"<de::StreamDeserializer<'de, R, T> as std::iter::Iterator>::next":["de::Deserializer","de::StreamDeserializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::vec::Vec"],"<de::UnitVariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed":["de::Deserializer","de::UnitVariantAccess","serde::de::DeserializeSeed","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::de::KeyClassifier"],"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed":["de::Deserializer","de::UnitVariantAccess","serde::de::DeserializeSeed","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::de::KeyClassifier"],"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::UnitVariantAccess","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::UnitVariantAccess","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant":["de::Deserializer","de::UnitVariantAccess","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::VariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed":["de::Deserializer","de::VariantAccess","serde::de::DeserializeSeed","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::de::KeyClassifier"],"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed":["de::Deserializer","de::VariantAccess","serde::de::DeserializeSeed","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::de::KeyClassifier"],"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::VariantAccess","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","de::VariantAccess","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant":["de::Deserializer","de::VariantAccess","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<error::Category as std::clone::Clone>::clone":["error::Category"],"<error::Category as std::cmp::Eq>::assert_receiver_is_total_eq":["error::Category"],"<error::Category as std::cmp::PartialEq>::eq":["error::Category"],"<error::Category as std::fmt::Debug>::fmt":["error::Category","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Error as serde::de::Error>::custom":["error::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::marker::Sized"],"<error::Error as serde::de::Error>::invalid_type":["error::Error","serde::de::Unexpected","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<error::Error as serde::ser::Error>::custom":["error::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::marker::Sized"],"<error::Error as std::error::Error>::source":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<error::Error as std::fmt::Debug>::fmt":["error::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Error as std::fmt::Display>::fmt":["error::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::ErrorCode as std::fmt::Display>::fmt":["error::ErrorCode","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result"],"<error::ErrorImpl as std::fmt::Display>::fmt":["error::ErrorCode","error::ErrorImpl","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::result::Result"],"<iter::LineColIterator<I> as std::iter::Iterator>::next":["iter::LineColIterator","std::marker::Sized","std::option::Option"],"<map::IntoIter as std::iter::DoubleEndedIterator>::next_back":["error::Category","map::IntoIter","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::IntoIter","std::marker::Sized","std::option::Option"],"<map::IntoIter as std::iter::ExactSizeIterator>::len":["error::Category","map::IntoIter","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::IntoIter","std::marker::Sized"],"<map::IntoIter as std::iter::Iterator>::next":["error::Category","map::IntoIter","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::IntoIter","std::marker::Sized","std::option::Option"],"<map::IntoIter as std::iter::Iterator>::size_hint":["error::Category","map::IntoIter","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::IntoIter","std::marker::Sized","std::option::Option"],"<map::Iter<'a> as std::iter::DoubleEndedIterator>::next_back":["map::Iter","std::collections::btree_map::Iter","std::marker::Sized","std::option::Option"],"<map::Iter<'a> as std::iter::ExactSizeIterator>::len":["map::Iter","std::collections::btree_map::Iter","std::marker::Sized"],"<map::Iter<'a> as std::iter::Iterator>::next":["map::Iter","std::collections::btree_map::Iter","std::marker::Sized","std::option::Option"],"<map::Iter<'a> as std::iter::Iterator>::size_hint":["map::Iter","std::collections::btree_map::Iter","std::marker::Sized","std::option::Option"],"<map::IterMut<'a> as std::iter::DoubleEndedIterator>::next_back":["map::IterMut","std::collections::btree_map::IterMut","std::marker::Sized","std::option::Option"],"<map::IterMut<'a> as std::iter::ExactSizeIterator>::len":["map::IterMut","std::collections::btree_map::IterMut","std::marker::Sized"],"<map::IterMut<'a> as std::iter::Iterator>::next":["map::IterMut","std::collections::btree_map::IterMut","std::marker::Sized","std::option::Option"],"<map::IterMut<'a> as std::iter::Iterator>::size_hint":["map::IterMut","std::collections::btree_map::IterMut","std::marker::Sized","std::option::Option"],"<map::Keys<'a> as std::iter::DoubleEndedIterator>::next_back":["map::Keys","std::collections::btree_map::Keys","std::marker::Sized","std::option::Option"],"<map::Keys<'a> as std::iter::ExactSizeIterator>::len":["map::Keys","std::collections::btree_map::Keys","std::marker::Sized"],"<map::Keys<'a> as std::iter::Iterator>::next":["map::Keys","std::collections::btree_map::Keys","std::marker::Sized","std::option::Option"],"<map::Keys<'a> as std::iter::Iterator>::size_hint":["map::Keys","std::collections::btree_map::Keys","std::marker::Sized","std::option::Option"],"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize":["de::Deserializer","de::MapKey","serde::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"],"<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize":["error::Category","map::Map","ser::MapKeySerializer","ser::Serializer","serde::Serializer","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone_from":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"<map::Map<std::string::String, value::Value> as std::cmp::PartialEq>::eq":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"<map::Map<std::string::String, value::Value> as std::default::Default>::default":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"<map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::iter::IntoIterator","std::marker::Sized"],"<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::iter::IntoIterator","std::marker::Sized"],"<map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"<map::Values<'a> as std::iter::DoubleEndedIterator>::next_back":["map::Values","std::collections::btree_map::Values","std::marker::Sized","std::option::Option"],"<map::Values<'a> as std::iter::ExactSizeIterator>::len":["map::Values","std::collections::btree_map::Values","std::marker::Sized"],"<map::Values<'a> as std::iter::Iterator>::next":["map::Values","std::collections::btree_map::Values","std::marker::Sized","std::option::Option"],"<map::Values<'a> as std::iter::Iterator>::size_hint":["map::Values","std::collections::btree_map::Values","std::marker::Sized","std::option::Option"],"<map::ValuesMut<'a> as std::iter::DoubleEndedIterator>::next_back":["map::ValuesMut","std::collections::btree_map::ValuesMut","std::marker::Sized","std::option::Option"],"<map::ValuesMut<'a> as std::iter::ExactSizeIterator>::len":["map::ValuesMut","std::collections::btree_map::ValuesMut","std::marker::Sized"],"<map::ValuesMut<'a> as std::iter::Iterator>::next":["map::ValuesMut","std::collections::btree_map::ValuesMut","std::marker::Sized","std::option::Option"],"<map::ValuesMut<'a> as std::iter::Iterator>::size_hint":["map::ValuesMut","std::collections::btree_map::ValuesMut","std::marker::Sized","std::option::Option"],"<number::N as std::clone::Clone>::clone":["number::N"],"<number::N as std::cmp::PartialEq>::eq":["number::N"],"<number::N as std::hash::Hash>::hash":["number::N","std::hash::Hasher","std::marker::Sized"],"<number::Number as serde::Deserialize<'de>>::deserialize":["de::Deserializer","de::MapKey","serde::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"],"<number::Number as serde::Deserializer<'de>>::deserialize_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_bool":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_byte_buf":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_bytes":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_char":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_enum":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_f32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_f64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_i128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_i16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_i32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_i64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_i8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_identifier":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_ignored_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_option":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_seq":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_str":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_string":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_tuple":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_u128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_u16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_u32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_u64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_u8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Deserializer<'de>>::deserialize_unit_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","number::N","number::Number","serde::de::Visitor","std::marker::Sized","std::result::Result"],"<number::Number as serde::Serialize>::serialize":["number::N","number::Number","ser::MapKeySerializer","ser::Serializer","serde::Serializer","std::marker::Sized","std::result::Result"],"<number::Number as std::clone::Clone>::clone":["number::N","number::Number"],"<number::Number as std::cmp::Eq>::assert_receiver_is_total_eq":["number::N","number::Number"],"<number::Number as std::cmp::PartialEq>::eq":["number::N","number::Number"],"<number::Number as std::convert::From<de::ParserNumber>>::from":["de::ParserNumber","number::N","number::Number"],"<number::Number as std::convert::From<i16>>::from":["number::N","number::Number"],"<number::Number as std::convert::From<i32>>::from":["number::N","number::Number"],"<number::Number as std::convert::From<i64>>::from":["number::N","number::Number"],"<number::Number as std::convert::From<i8>>::from":["number::N","number::Number"],"<number::Number as std::convert::From<isize>>::from":["number::N","number::Number"],"<number::Number as std::convert::From<u16>>::from":["number::N","number::Number"],"<number::Number as std::convert::From<u32>>::from":["number::N","number::Number"],"<number::Number as std::convert::From<u64>>::from":["number::N","number::Number"],"<number::Number as std::convert::From<u8>>::from":["number::N","number::Number"],"<number::Number as std::convert::From<usize>>::from":["number::N","number::Number"],"<number::Number as std::fmt::Debug>::fmt":["number::N","number::Number","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<number::Number as std::fmt::Display>::fmt":["number::N","number::Number","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<number::Number as std::hash::Hash>::hash":["number::N","number::Number","std::hash::Hasher","std::marker::Sized"],"<read::IoRead<R> as read::Read<'de>>::byte_offset":["iter::LineColIterator","read::IoRead","std::io::Read","std::marker::Sized","std::option::Option"],"<read::IoRead<R> as read::Read<'de>>::decode_hex_escape":["iter::LineColIterator","read::IoRead","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result"],"<read::IoRead<R> as read::Read<'de>>::discard":["iter::LineColIterator","read::IoRead","std::io::Read","std::marker::Sized","std::option::Option"],"<read::IoRead<R> as read::Read<'de>>::ignore_str":["iter::LineColIterator","read::IoRead","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result"],"<read::IoRead<R> as read::Read<'de>>::next":["iter::LineColIterator","read::IoRead","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result"],"<read::IoRead<R> as read::Read<'de>>::parse_str":["iter::LineColIterator","read::IoRead","std::alloc::Allocator","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<read::IoRead<R> as read::Read<'de>>::parse_str_raw":["iter::LineColIterator","read::IoRead","std::alloc::Allocator","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<read::IoRead<R> as read::Read<'de>>::peek":["iter::LineColIterator","read::IoRead","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result"],"<read::IoRead<R> as read::Read<'de>>::peek_position":["iter::LineColIterator","read::IoRead","read::Position","std::io::Read","std::marker::Sized","std::option::Option"],"<read::IoRead<R> as read::Read<'de>>::position":["iter::LineColIterator","read::IoRead","read::Position","std::io::Read","std::marker::Sized","std::option::Option"],"<read::IoRead<R> as read::Read<'de>>::set_failed":["iter::LineColIterator","read::IoRead","std::io::Read","std::marker::Sized","std::option::Option"],"<read::Reference<'b, 'c, T> as std::ops::Deref>::deref":["read::Reference"],"<read::SliceRead<'a> as read::Read<'a>>::byte_offset":["read::SliceRead"],"<read::SliceRead<'a> as read::Read<'a>>::decode_hex_escape":["read::SliceRead","std::marker::Sized","std::result::Result"],"<read::SliceRead<'a> as read::Read<'a>>::discard":["read::SliceRead"],"<read::SliceRead<'a> as read::Read<'a>>::ignore_str":["read::SliceRead","std::marker::Sized","std::result::Result"],"<read::SliceRead<'a> as read::Read<'a>>::next":["read::SliceRead","std::marker::Sized","std::result::Result"],"<read::SliceRead<'a> as read::Read<'a>>::parse_str":["read::SliceRead","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<read::SliceRead<'a> as read::Read<'a>>::parse_str_raw":["read::SliceRead","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<read::SliceRead<'a> as read::Read<'a>>::peek":["read::SliceRead","std::marker::Sized","std::result::Result"],"<read::SliceRead<'a> as read::Read<'a>>::peek_position":["read::Position","read::SliceRead"],"<read::SliceRead<'a> as read::Read<'a>>::position":["read::Position","read::SliceRead"],"<read::SliceRead<'a> as read::Read<'a>>::set_failed":["read::SliceRead"],"<read::StrRead<'a> as read::Read<'a>>::byte_offset":["read::SliceRead","read::StrRead"],"<read::StrRead<'a> as read::Read<'a>>::decode_hex_escape":["read::SliceRead","read::StrRead","std::marker::Sized","std::result::Result"],"<read::StrRead<'a> as read::Read<'a>>::discard":["read::SliceRead","read::StrRead"],"<read::StrRead<'a> as read::Read<'a>>::ignore_str":["read::SliceRead","read::StrRead","std::marker::Sized","std::result::Result"],"<read::StrRead<'a> as read::Read<'a>>::next":["read::SliceRead","read::StrRead","std::marker::Sized","std::result::Result"],"<read::StrRead<'a> as read::Read<'a>>::parse_str":["read::SliceRead","read::StrRead","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<read::StrRead<'a> as read::Read<'a>>::parse_str_raw":["read::SliceRead","read::StrRead","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"<read::StrRead<'a> as read::Read<'a>>::peek":["read::SliceRead","read::StrRead","std::marker::Sized","std::result::Result"],"<read::StrRead<'a> as read::Read<'a>>::peek_position":["read::Position","read::SliceRead","read::StrRead"],"<read::StrRead<'a> as read::Read<'a>>::position":["read::Position","read::SliceRead","read::StrRead"],"<read::StrRead<'a> as read::Read<'a>>::set_failed":["read::SliceRead","read::StrRead"],"<ser::CompactFormatter as std::clone::Clone>::clone":["ser::CompactFormatter"],"<ser::CompactFormatter as std::fmt::Debug>::fmt":["ser::CompactFormatter","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::end":["ser::Compound","ser::Serializer","ser::State","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_key":["error::Category","map::Map","ser::Compound","ser::Serializer","ser::State","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_value":["error::Category","map::Map","ser::Compound","ser::Serializer","ser::State","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::end":["ser::Compound","ser::Serializer","ser::State","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::serialize_element":["error::Category","map::Map","ser::Compound","ser::Serializer","ser::State","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::end":["ser::Compound","ser::Serializer","ser::State","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::serialize_field":["error::Category","map::Map","ser::Compound","ser::Serializer","ser::State","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::end":["ser::Compound","ser::Serializer","ser::State","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::serialize_field":["error::Category","map::Map","ser::Compound","ser::Serializer","ser::State","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::end":["ser::Compound","ser::Serializer","ser::State","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::serialize_element":["error::Category","map::Map","ser::Compound","ser::Serializer","ser::State","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::end":["ser::Compound","ser::Serializer","ser::State","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::serialize_field":["error::Category","map::Map","ser::Compound","ser::Serializer","ser::State","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::end":["ser::Compound","ser::Serializer","ser::State","std::marker::Sized","std::result::Result"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::serialize_field":["error::Category","map::Map","ser::Compound","ser::Serializer","ser::State","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::collect_str":["error::Error","ser::MapKeySerializer","ser::Serializer","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bool":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bytes":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_char":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f32":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f64":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i128":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i16":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i32":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i64":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i8":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_map":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::option::Option","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_struct":["error::Category","map::Map","ser::MapKeySerializer","ser::Serializer","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_variant":["error::Category","map::Map","ser::MapKeySerializer","ser::Serializer","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_none":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_seq":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::option::Option","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_some":["error::Category","map::Map","ser::MapKeySerializer","ser::Serializer","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_str":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct_variant":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_struct":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_variant":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u128":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u16":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u32":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u64":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u8":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_struct":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_variant":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized","std::result::Result"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","ser::PrettyFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array_value":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","ser::PrettyFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","ser::PrettyFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_key":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","ser::PrettyFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_value":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","ser::PrettyFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"<ser::PrettyFormatter<'a> as ser::Formatter>::end_array":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","ser::PrettyFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"<ser::PrettyFormatter<'a> as ser::Formatter>::end_array_value":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","ser::PrettyFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"<ser::PrettyFormatter<'a> as ser::Formatter>::end_object":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","ser::PrettyFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"<ser::PrettyFormatter<'a> as ser::Formatter>::end_object_value":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","ser::PrettyFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"<ser::PrettyFormatter<'a> as std::clone::Clone>::clone":["ser::PrettyFormatter"],"<ser::PrettyFormatter<'a> as std::default::Default>::default":["ser::PrettyFormatter"],"<ser::PrettyFormatter<'a> as std::fmt::Debug>::fmt":["ser::PrettyFormatter","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<ser::State as std::cmp::Eq>::assert_receiver_is_total_eq":["ser::State"],"<ser::State as std::cmp::PartialEq>::eq":["ser::State"],"<std::string::String as value::index::Index>::index_into":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<std::string::String as value::index::Index>::index_into_mut":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<std::string::String as value::index::Index>::index_or_insert":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"<str as value::index::Index>::index_into":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<str as value::index::Index>::index_into_mut":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<str as value::index::Index>::index_or_insert":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"<usize as value::index::Index>::index_into":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<usize as value::index::Index>::index_into_mut":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"<usize as value::index::Index>::index_or_insert":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::clone::Clone>::clone":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::cmp::Eq>::assert_receiver_is_total_eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::cmp::PartialEq>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::default::Default>::default":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::fmt::Debug>::fmt":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::fmt::Display>::fmt":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"<value::Value as std::fmt::Display>::fmt::WriterFormatter":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter"],"<value::Value as std::fmt::Display>::fmt::io_error":["std::fmt::Error","std::io::Error"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::marker::Sized","std::result::Result","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool":["std::marker::Sized","std::result::Result","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64":["std::marker::Sized","std::result::Result","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64":["std::marker::Sized","std::result::Result","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map":["de::Deserializer","de::MapAccess","serde::de::MapAccess","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_none":["std::marker::Sized","std::result::Result","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq":["de::Deserializer","de::SeqAccess","serde::de::SeqAccess","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some":["de::Deserializer","de::MapKey","serde::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str":["error::Error","serde::de::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string":["std::marker::Sized","std::result::Result","std::string::String","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64":["std::marker::Sized","std::result::Result","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_unit":["std::marker::Sized","std::result::Result","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed":["serde::de::DeserializeSeed","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::BorrowedCowStrDeserializer","value::de::KeyClassifier"],"<value::de::EnumDeserializer as serde::de::EnumAccess<'de>>::variant_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::option::Option","std::result::Result","std::string::String","value::de::EnumDeserializer","value::de::KeyClassifier"],"<value::de::EnumRefDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::option::Option","std::result::Result","value::de::EnumRefDeserializer","value::de::KeyClassifier"],"<value::de::KeyClassifier as serde::de::DeserializeSeed<'de>>::deserialize":["de::Deserializer","de::MapKey","serde::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::de::KeyClassifier"],"<value::de::KeyClassifier as serde::de::Visitor<'de>>::expecting":["std::fmt::Formatter","std::marker::Sized","std::result::Result","value::de::KeyClassifier"],"<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_str":["error::Error","serde::de::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","value::de::KeyClassifier"],"<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_string":["error::Error","serde::de::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","std::string::String","value::de::KeyClassifier"],"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::option::Option","std::result::Result","value::de::KeyClassifier","value::de::MapDeserializer"],"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::option::Option","std::result::Result","value::de::KeyClassifier","value::de::MapDeserializer"],"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::size_hint":["std::marker::Sized","std::option::Option","value::de::MapDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::result::Result","value::de::MapKeyDeserializer"],"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_key_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::option::Option","std::result::Result","value::de::KeyClassifier","value::de::MapRefDeserializer"],"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_value_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::option::Option","std::result::Result","value::de::KeyClassifier","value::de::MapRefDeserializer"],"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::size_hint":["std::marker::Sized","std::option::Option","value::de::MapRefDeserializer"],"<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed":["serde::de::DeserializeSeed","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::IntoIter","value::de::KeyClassifier","value::de::SeqDeserializer"],"<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::IntoIter","value::de::SeqDeserializer"],"<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::next_element_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::result::Result","std::slice::Iter","value::de::KeyClassifier","value::de::SeqRefDeserializer"],"<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::size_hint":["std::marker::Sized","std::option::Option","std::slice::Iter","value::de::SeqRefDeserializer"],"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::newtype_variant_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::result::Result","value::de::KeyClassifier","value::de::UnitOnly"],"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::struct_variant":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::marker::Sized","std::result::Result","value::de::UnitOnly"],"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::tuple_variant":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::marker::Sized","std::result::Result","value::de::UnitOnly"],"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::unit_variant":["std::marker::Sized","std::result::Result","value::de::UnitOnly"],"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::option::Option","std::result::Result","value::de::KeyClassifier","value::de::VariantDeserializer"],"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::struct_variant":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::marker::Sized","std::option::Option","std::result::Result","value::de::VariantDeserializer"],"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::tuple_variant":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::marker::Sized","std::option::Option","std::result::Result","value::de::VariantDeserializer"],"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::unit_variant":["std::marker::Sized","std::option::Option","std::result::Result","value::de::VariantDeserializer"],"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::newtype_variant_seed":["serde::de::DeserializeSeed","std::marker::Sized","std::option::Option","std::result::Result","value::de::KeyClassifier","value::de::VariantRefDeserializer"],"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::struct_variant":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::marker::Sized","std::option::Option","std::result::Result","value::de::VariantRefDeserializer"],"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::tuple_variant":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::marker::Sized","std::option::Option","std::result::Result","value::de::VariantRefDeserializer"],"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::unit_variant":["std::marker::Sized","std::option::Option","std::result::Result","value::de::VariantRefDeserializer"],"<value::index::Type<'a> as std::fmt::Display>::fmt":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value","value::index::Type"],"<value::ser::MapKeySerializer as serde::Serializer>::collect_str":["error::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_bool":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_bytes":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_char":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_f32":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_f64":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_i16":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_i32":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_i64":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_i8":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_map":["std::marker::Sized","std::option::Option","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_struct":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_variant":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_none":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_seq":["std::marker::Sized","std::option::Option","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_some":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_str":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct_variant":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_struct":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_variant":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_u16":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_u32":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_u64":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_u8":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_struct":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_variant":["std::marker::Sized","std::result::Result","value::ser::MapKeySerializer"],"<value::ser::SerializeMap as serde::ser::SerializeMap>::end":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","value::ser::SerializeMap"],"<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_key":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","value::ser::SerializeMap"],"<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_value":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","value::ser::SerializeMap"],"<value::ser::SerializeMap as serde::ser::SerializeStruct>::end":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","value::ser::SerializeMap"],"<value::ser::SerializeMap as serde::ser::SerializeStruct>::serialize_field":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::result::Result","value::ser::SerializeMap"],"<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::end":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","value::ser::SerializeStructVariant"],"<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::serialize_field":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","value::ser::SerializeStructVariant"],"<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::end":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::ser::SerializeTupleVariant"],"<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::serialize_field":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::ser::SerializeTupleVariant"],"<value::ser::SerializeVec as serde::ser::SerializeSeq>::end":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::ser::SerializeVec"],"<value::ser::SerializeVec as serde::ser::SerializeSeq>::serialize_element":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::vec::Vec","value::ser::SerializeVec"],"<value::ser::SerializeVec as serde::ser::SerializeTuple>::end":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::ser::SerializeVec"],"<value::ser::SerializeVec as serde::ser::SerializeTuple>::serialize_element":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::vec::Vec","value::ser::SerializeVec"],"<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::end":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec","value::ser::SerializeVec"],"<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::serialize_field":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::vec::Vec","value::ser::SerializeVec"],"<value::ser::Serializer as serde::Serializer>::collect_str":["error::Error","std::alloc::Allocator","std::boxed::Box","std::fmt::Display","std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_bool":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_bytes":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_char":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_f32":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_f64":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_i128":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_i16":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_i32":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_i64":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_i8":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_map":["std::marker::Sized","std::option::Option","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_newtype_struct":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_newtype_variant":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_none":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_seq":["std::marker::Sized","std::option::Option","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_some":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_str":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_struct":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_struct_variant":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_tuple":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_tuple_struct":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_tuple_variant":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_u128":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_u16":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_u32":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_u64":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_u8":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_unit":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_unit_struct":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_unit_variant":["std::marker::Sized","std::result::Result","value::ser::Serializer"],"de::<impl std::str::FromStr for number::Number>::from_str":["std::marker::Sized","std::result::Result"],"de::Deserializer":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::Deserializer::<R>::deserialize_number":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::Deserializer","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::eat_char":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::Deserializer::<R>::end":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::end_map":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::end_seq":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::error":["de::Deserializer","error::Error","error::ErrorCode","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::marker::Sized","std::vec::Vec"],"de::Deserializer::<R>::f64_from_parts":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::fix_position":["de::Deserializer","error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"de::Deserializer::<R>::ignore_decimal":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::ignore_exponent":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::ignore_integer":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::ignore_value":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::into_iter":["de::Deserializer","de::StreamDeserializer","error::Category","map::Map","serde::Deserialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"de::Deserializer::<R>::new":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::Deserializer::<R>::next_char":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::next_char_or_null":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::parse_any_number":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::parse_any_signed_number":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::parse_decimal":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::parse_decimal_overflow":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::parse_exponent":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::parse_exponent_overflow":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::parse_ident":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::parse_integer":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::parse_long_integer":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::parse_number":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::parse_object_colon":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::parse_whitespace":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::peek":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::peek_error":["de::Deserializer","error::Error","error::ErrorCode","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::marker::Sized","std::vec::Vec"],"de::Deserializer::<R>::peek_invalid_type":["de::Deserializer","error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"de::Deserializer::<R>::peek_or_null":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::Deserializer::<R>::scan_integer128":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec"],"de::Deserializer::<read::IoRead<R>>::from_reader":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::Deserializer::<read::SliceRead<'a>>::from_slice":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::Deserializer::<read::StrRead<'a>>::from_str":["de::Deserializer","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::MapAccess":["de::Deserializer","de::MapAccess","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::MapAccess::<'a, R>::new":["de::Deserializer","de::MapAccess","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::MapKey":["de::Deserializer","de::MapKey","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::ParserNumber":["de::ParserNumber"],"de::ParserNumber::invalid_type":["de::ParserNumber","error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"de::ParserNumber::visit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","de::ParserNumber","serde::de::Visitor","std::marker::Sized","std::result::Result"],"de::SeqAccess":["de::Deserializer","de::SeqAccess","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::SeqAccess::<'a, R>::new":["de::Deserializer","de::SeqAccess","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::StreamDeserializer":["de::Deserializer","de::StreamDeserializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"de::StreamDeserializer::<'de, R, T>::byte_offset":["de::Deserializer","de::StreamDeserializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"de::StreamDeserializer::<'de, R, T>::new":["de::Deserializer","de::StreamDeserializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::vec::Vec"],"de::StreamDeserializer::<'de, R, T>::peek_end_of_value":["de::Deserializer","de::StreamDeserializer","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::result::Result","std::vec::Vec"],"de::UnitVariantAccess":["de::Deserializer","de::UnitVariantAccess","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::UnitVariantAccess::<'a, R>::new":["de::Deserializer","de::UnitVariantAccess","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::VariantAccess":["de::Deserializer","de::VariantAccess","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::VariantAccess::<'a, R>::new":["de::Deserializer","de::VariantAccess","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"de::from_reader":["serde::de::DeserializeOwned","std::io::Read","std::marker::Sized","std::result::Result"],"de::from_slice":["error::Category","map::Map","serde::Deserialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"de::from_str":["error::Category","map::Map","serde::Deserialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"de::from_trait":["error::Category","iter::LineColIterator","map::Map","read::IoRead","read::Read","serde::Deserialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result"],"error::<impl std::convert::From<error::Error> for std::io::Error>::from":["error::Error","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::marker::Sized"],"error::Category":["error::Category"],"error::Error":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::Error::classify":["error::Category","error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::Error::column":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::Error::fix_position":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::ops::FnOnce"],"error::Error::io":["error::Error","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::marker::Sized"],"error::Error::is_data":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::Error::is_eof":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::Error::is_io":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::Error::is_syntax":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::Error::line":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"error::Error::syntax":["error::Error","error::ErrorCode","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::marker::Sized"],"error::ErrorCode":["error::ErrorCode","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::marker::Sized"],"error::ErrorImpl":["error::ErrorCode","error::ErrorImpl","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::marker::Sized"],"error::make_error":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::string::String"],"error::parse_line_col":["std::marker::Sized","std::option::Option","std::string::String"],"error::starts_with_digit":[],"iter::LineColIterator":["iter::LineColIterator","std::marker::Sized"],"iter::LineColIterator::<I>::byte_offset":["iter::LineColIterator","std::marker::Sized"],"iter::LineColIterator::<I>::col":["iter::LineColIterator","std::marker::Sized"],"iter::LineColIterator::<I>::line":["iter::LineColIterator","std::marker::Sized"],"iter::LineColIterator::<I>::new":["iter::LineColIterator","std::marker::Sized"],"map::Entry":["error::Category","map::Entry","map::OccupiedEntry","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::OccupiedEntry","std::collections::btree_map::VacantEntry","std::marker::Sized"],"map::Entry::<'a>::and_modify":["error::Category","map::Entry","map::OccupiedEntry","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::OccupiedEntry","std::collections::btree_map::VacantEntry","std::marker::Sized","std::ops::FnOnce"],"map::Entry::<'a>::key":["error::Category","map::Entry","map::OccupiedEntry","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::OccupiedEntry","std::collections::btree_map::VacantEntry","std::marker::Sized","std::string::String"],"map::Entry::<'a>::or_insert":["error::Category","map::Entry","map::Map","map::OccupiedEntry","map::VacantEntry","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::collections::btree_map::VacantEntry","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"map::Entry::<'a>::or_insert_with":["error::Category","map::Entry","map::Map","map::OccupiedEntry","map::VacantEntry","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::collections::btree_map::VacantEntry","std::marker::Sized","std::ops::FnOnce","std::string::String","std::vec::Vec","value::Value"],"map::IntoIter":["error::Category","map::IntoIter","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::IntoIter","std::marker::Sized"],"map::Iter":["map::Iter","std::collections::btree_map::Iter","std::marker::Sized"],"map::IterMut":["map::IterMut","std::collections::btree_map::IterMut","std::marker::Sized"],"map::Keys":["map::Keys","std::collections::btree_map::Keys","std::marker::Sized"],"map::Map":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::append":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::clear":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::contains_key":["error::Category","map::Map","number::N","std::alloc::Allocator","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::collections::BTreeMap","std::hash::Hash","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::entry":["error::Category","map::Entry","map::Map","map::OccupiedEntry","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::collections::btree_map::VacantEntry","std::convert::Into","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::get":["error::Category","map::Map","number::N","std::alloc::Allocator","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::collections::BTreeMap","std::hash::Hash","std::marker::Sized","std::option::Option"],"map::Map::<std::string::String, value::Value>::get_key_value":["error::Category","map::Map","number::N","std::alloc::Allocator","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::collections::BTreeMap","std::hash::Hash","std::marker::Sized","std::option::Option"],"map::Map::<std::string::String, value::Value>::get_mut":["error::Category","map::Map","number::N","std::alloc::Allocator","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::collections::BTreeMap","std::hash::Hash","std::marker::Sized","std::option::Option"],"map::Map::<std::string::String, value::Value>::insert":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"map::Map::<std::string::String, value::Value>::is_empty":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::iter":["error::Category","map::Iter","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::Iter","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::iter_mut":["error::Category","map::IterMut","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::IterMut","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::keys":["error::Category","map::Keys","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::Keys","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::len":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::new":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::remove":["error::Category","map::Map","number::N","std::alloc::Allocator","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::collections::BTreeMap","std::hash::Hash","std::marker::Sized","std::option::Option"],"map::Map::<std::string::String, value::Value>::remove_entry":["error::Category","map::Map","number::N","std::alloc::Allocator","std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::collections::BTreeMap","std::hash::Hash","std::marker::Sized","std::option::Option"],"map::Map::<std::string::String, value::Value>::retain":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::ops::FnMut"],"map::Map::<std::string::String, value::Value>::values":["error::Category","map::Map","map::Values","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::Values","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::values_mut":["error::Category","map::Map","map::ValuesMut","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::ValuesMut","std::marker::Sized"],"map::Map::<std::string::String, value::Value>::with_capacity":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized"],"map::OccupiedEntry":["error::Category","map::OccupiedEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::OccupiedEntry","std::marker::Sized"],"map::OccupiedEntry::<'a>::get":["error::Category","map::Map","map::OccupiedEntry","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"map::OccupiedEntry::<'a>::get_mut":["error::Category","map::Map","map::OccupiedEntry","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"map::OccupiedEntry::<'a>::insert":["error::Category","map::Map","map::OccupiedEntry","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"map::OccupiedEntry::<'a>::into_mut":["error::Category","map::Map","map::OccupiedEntry","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"map::OccupiedEntry::<'a>::key":["error::Category","map::OccupiedEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::OccupiedEntry","std::marker::Sized","std::string::String"],"map::OccupiedEntry::<'a>::remove":["error::Category","map::Map","map::OccupiedEntry","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::OccupiedEntry","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"map::VacantEntry":["error::Category","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::VacantEntry","std::marker::Sized"],"map::VacantEntry::<'a>::insert":["error::Category","map::Map","map::VacantEntry","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::collections::btree_map::VacantEntry","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"map::VacantEntry::<'a>::key":["error::Category","map::VacantEntry","std::alloc::Allocator","std::clone::Clone","std::collections::btree_map::VacantEntry","std::marker::Sized","std::string::String"],"map::Values":["map::Values","std::collections::btree_map::Values","std::marker::Sized"],"map::ValuesMut":["map::ValuesMut","std::collections::btree_map::ValuesMut","std::marker::Sized"],"number::N":["number::N"],"number::Number":["number::N","number::Number"],"number::Number::as_f32":["number::N","number::Number","std::marker::Sized","std::option::Option"],"number::Number::as_f64":["number::N","number::Number","std::marker::Sized","std::option::Option"],"number::Number::as_i64":["number::N","number::Number","std::marker::Sized","std::option::Option"],"number::Number::as_u64":["number::N","number::Number","std::marker::Sized","std::option::Option"],"number::Number::from_f32":["std::marker::Sized","std::option::Option"],"number::Number::from_f64":["std::marker::Sized","std::option::Option"],"number::Number::is_f64":["number::N","number::Number"],"number::Number::is_i64":["number::N","number::Number"],"number::Number::is_u64":["number::N","number::Number"],"number::Number::unexpected":["number::N","number::Number","serde::de::Unexpected"],"read::IoRead":["iter::LineColIterator","read::IoRead","std::io::Read","std::marker::Sized","std::option::Option"],"read::IoRead::<R>::new":["iter::LineColIterator","read::IoRead","std::io::Read","std::marker::Sized","std::option::Option"],"read::IoRead::<R>::parse_str_bytes":["iter::LineColIterator","read::IoRead","std::alloc::Allocator","std::io::Read","std::marker::Sized","std::ops::FnOnce","std::option::Option","std::result::Result","std::vec::Vec"],"read::Position":["read::Position"],"read::Read::byte_offset":[],"read::Read::decode_hex_escape":["std::marker::Sized","std::result::Result"],"read::Read::discard":[],"read::Read::ignore_str":["std::marker::Sized","std::result::Result"],"read::Read::next":["std::marker::Sized","std::result::Result"],"read::Read::parse_str":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"read::Read::parse_str_raw":["std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"read::Read::peek":["std::marker::Sized","std::result::Result"],"read::Read::peek_position":["read::Position"],"read::Read::position":["read::Position"],"read::Read::set_failed":[],"read::Reference":["read::Reference"],"read::SliceRead":["read::SliceRead"],"read::SliceRead::<'a>::new":["read::SliceRead"],"read::SliceRead::<'a>::parse_str_bytes":["read::SliceRead","std::alloc::Allocator","std::marker::Sized","std::ops::FnOnce","std::result::Result","std::vec::Vec"],"read::SliceRead::<'a>::position_of_index":["read::Position","read::SliceRead"],"read::StrRead":["read::SliceRead","read::StrRead"],"read::StrRead::<'a>::new":["read::SliceRead","read::StrRead"],"read::as_str":["iter::LineColIterator","read::IoRead","read::Read","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result"],"read::decode_hex_val":["std::marker::Sized","std::option::Option"],"read::error":["error::ErrorCode","iter::LineColIterator","read::IoRead","read::Read","std::alloc::Allocator","std::boxed::Box","std::io::Error","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result"],"read::ignore_escape":["iter::LineColIterator","read::IoRead","read::Read","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result"],"read::next_or_eof":["iter::LineColIterator","read::IoRead","read::Read","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result"],"read::parse_escape":["iter::LineColIterator","read::IoRead","read::Read","std::alloc::Allocator","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"read::parse_escape::encode_surrogate":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"read::peek_or_eof":["iter::LineColIterator","read::IoRead","read::Read","std::io::Read","std::marker::Sized","std::option::Option","std::result::Result"],"ser::CharEscape":["ser::CharEscape"],"ser::CharEscape::from_escape_table":["ser::CharEscape"],"ser::CompactFormatter":["ser::CompactFormatter"],"ser::Compound":["ser::Compound","ser::Serializer","ser::State","std::marker::Sized"],"ser::Formatter::begin_array":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::begin_array_value":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::begin_object":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::begin_object_key":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::begin_object_value":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::begin_string":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::end_array":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::end_array_value":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::end_object":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::end_object_key":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::end_object_value":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::end_string":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_bool":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_char_escape":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","ser::CharEscape","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_f32":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_f64":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_i128":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_i16":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_i32":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_i64":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_i8":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_null":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_number_str":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_raw_fragment":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_string_fragment":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_u128":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_u16":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_u32":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_u64":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::Formatter::write_u8":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::MapKeySerializer":["ser::MapKeySerializer","ser::Serializer","std::marker::Sized"],"ser::PrettyFormatter":["ser::PrettyFormatter"],"ser::PrettyFormatter::<'a>::new":["ser::PrettyFormatter"],"ser::PrettyFormatter::<'a>::with_indent":["ser::PrettyFormatter"],"ser::Serializer":["ser::Serializer","std::marker::Sized"],"ser::Serializer::<W, F>::into_inner":["ser::Serializer","std::marker::Sized"],"ser::Serializer::<W, F>::with_formatter":["ser::Serializer","std::marker::Sized"],"ser::Serializer::<W, ser::PrettyFormatter<'a>>::pretty":["ser::Serializer","std::marker::Sized"],"ser::Serializer::<W>::new":["ser::Serializer","std::marker::Sized"],"ser::State":["ser::State"],"ser::format_escaped_str":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","ser::CompactFormatter","ser::Formatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::format_escaped_str_contents":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","ser::CompactFormatter","ser::Formatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::indent":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::key_must_be_a_string":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"ser::to_string":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"ser::to_string_pretty":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"ser::to_vec":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"ser::to_vec_pretty":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"ser::to_writer":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"ser::to_writer_pretty":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::fmt::Formatter","std::io::Write","std::marker::Sized","std::result::Result"],"value::Value":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_array":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_array_mut":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_bool":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_f64":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_i64":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_null":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_object":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_object_mut":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_str":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::as_u64":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::get":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value","value::index::Index"],"value::Value::get_mut":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value","value::index::Index"],"value::Value::is_array":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_boolean":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_f64":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_i64":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_null":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_number":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_object":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_string":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::Value::is_u64":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::Value::pointer":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::pointer_mut":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::Value::take":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize":["de::Deserializer","de::MapKey","serde::Deserializer","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bool":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_byte_buf":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bytes":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_char":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_enum":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_identifier":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_ignored_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_newtype_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_option":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_seq":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_str":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_string":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bool":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_byte_buf":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bytes":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_char":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_enum":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_identifier":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_ignored_any":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_map":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_newtype_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_option":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_seq":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_str":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_string":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u128":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u16":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u32":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u64":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u8":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit_struct":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl serde::de::IntoDeserializer<'de, error::Error> for value::Value>::into_deserializer":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl std::str::FromStr for value::Value>::from_str":["std::marker::Sized","std::result::Result"],"value::de::<impl value::Value>::invalid_type":["error::Category","error::Error","map::Map","number::N","number::Number","serde::de::Error","std::alloc::Allocator","std::boxed::Box","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::de::<impl value::Value>::unexpected":["error::Category","map::Map","number::N","number::Number","serde::de::Unexpected","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::de::BorrowedCowStrDeserializer":["std::borrow::Cow","std::borrow::ToOwned","value::de::BorrowedCowStrDeserializer"],"value::de::BorrowedCowStrDeserializer::<'de>::new":["std::borrow::Cow","std::borrow::ToOwned","value::de::BorrowedCowStrDeserializer"],"value::de::EnumDeserializer":["std::marker::Sized","std::option::Option","std::string::String","value::de::EnumDeserializer"],"value::de::EnumRefDeserializer":["std::marker::Sized","std::option::Option","value::de::EnumRefDeserializer"],"value::de::KeyClass":["std::string::String","value::de::KeyClass"],"value::de::KeyClassifier":["value::de::KeyClassifier"],"value::de::MapDeserializer":["std::marker::Sized","std::option::Option","value::de::MapDeserializer"],"value::de::MapDeserializer::new":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","value::de::MapDeserializer"],"value::de::MapKeyDeserializer":["std::borrow::Cow","std::borrow::ToOwned","value::de::MapKeyDeserializer"],"value::de::MapRefDeserializer":["std::marker::Sized","std::option::Option","value::de::MapRefDeserializer"],"value::de::MapRefDeserializer::<'de>::new":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","value::de::MapRefDeserializer"],"value::de::SeqDeserializer":["std::alloc::Allocator","std::marker::Sized","std::vec::IntoIter","value::de::SeqDeserializer"],"value::de::SeqDeserializer::new":["std::alloc::Allocator","std::marker::Sized","std::vec::IntoIter","std::vec::Vec","value::de::SeqDeserializer"],"value::de::SeqRefDeserializer":["std::marker::Sized","std::slice::Iter","value::de::SeqRefDeserializer"],"value::de::SeqRefDeserializer::<'de>::new":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::slice::Iter","std::string::String","std::vec::Vec","value::Value","value::de::SeqRefDeserializer"],"value::de::UnitOnly":["value::de::UnitOnly"],"value::de::VariantDeserializer":["std::marker::Sized","std::option::Option","value::de::VariantDeserializer"],"value::de::VariantRefDeserializer":["std::marker::Sized","std::option::Option","value::de::VariantRefDeserializer"],"value::de::visit_array":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","serde::de::Visitor","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"value::de::visit_array_ref":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","number::N","number::Number","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::de::visit_object":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"value::de::visit_object_ref":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","error::Category","map::Map","serde::de::Visitor","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"],"value::from::<impl std::convert::From<&'a [T]> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<&'a str> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<()> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<bool> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<f32> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<f64> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<i16> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<i32> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<i64> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<i8> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<isize> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<map::Map<std::string::String, value::Value>> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<number::Number> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<std::borrow::Cow<'a, str>> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<std::option::Option<T>> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<std::string::String> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<std::vec::Vec<T>> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<u16> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<u32> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<u64> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<u8> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::convert::From<usize> for value::Value>::from":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::iter::FromIterator<(K, V)> for value::Value>::from_iter":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::iter::IntoIterator","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from::<impl std::iter::FromIterator<T> for value::Value>::from_iter":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::iter::IntoIterator","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::from_value":["error::Category","map::Map","number::N","number::Number","serde::de::DeserializeOwned","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::index::<impl std::ops::Index<I> for value::Value>::index":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::index::<impl std::ops::IndexMut<I> for value::Value>::index_mut":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::index::Index::index_into":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::index::Index::index_into_mut":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","std::string::String","std::vec::Vec","value::Value"],"value::index::Index::index_or_insert":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::index::Type":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value","value::index::Type"],"value::parse_index":["std::marker::Sized","std::option::Option"],"value::partial_eq::<impl std::cmp::PartialEq<&'a str> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<bool> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<bool> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<bool> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<f32> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<f32> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<f32> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<f64> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<f64> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<f64> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<i16> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<i16> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<i16> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<i32> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<i32> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<i32> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<i64> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<i64> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<i64> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<i8> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<i8> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<i8> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<isize> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<isize> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<isize> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<std::string::String> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<str> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<u16> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<u16> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<u16> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<u32> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<u32> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<u32> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<u64> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<u64> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<u64> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<u8> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<u8> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<u8> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<usize> for &'a mut value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<usize> for &'a value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<usize> for value::Value>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for &'a str>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for bool>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for f32>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for f64>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i16>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i32>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i64>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i8>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for isize>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for std::string::String>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for str>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u16>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u32>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u64>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u8>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for usize>::eq":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::eq_bool":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::eq_f32":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::eq_f64":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::eq_i64":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::eq_str":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::partial_eq::eq_u64":["error::Category","map::Map","number::N","number::Number","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","std::vec::Vec","value::Value"],"value::ser::<impl serde::Serialize for value::Value>::serialize":["error::Category","map::Map","number::N","number::Number","ser::MapKeySerializer","ser::Serializer","serde::Serializer","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result","std::string::String","std::vec::Vec","value::Value"],"value::ser::MapKeySerializer":["value::ser::MapKeySerializer"],"value::ser::SerializeMap":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::option::Option","value::ser::SerializeMap"],"value::ser::SerializeStructVariant":["error::Category","map::Map","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::string::String","value::ser::SerializeStructVariant"],"value::ser::SerializeTupleVariant":["std::alloc::Allocator","std::marker::Sized","std::string::String","std::vec::Vec","value::ser::SerializeTupleVariant"],"value::ser::SerializeVec":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec","value::ser::SerializeVec"],"value::ser::Serializer":["value::ser::Serializer"],"value::ser::key_must_be_a_string":["error::Error","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"value::to_value":["error::Category","map::Map","serde::Serialize","std::alloc::Allocator","std::clone::Clone","std::collections::BTreeMap","std::marker::Sized","std::result::Result"]},"glob_path_import":{},"self_to_fn":{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter":["impl<'ser, W, F> Write for Adapter<'ser, W, F>\n        where\n            W: io::Write,\n            F: Formatter,\n        {\n            fn write_str(&mut self, s: &str) -> fmt::Result {\n                debug_assert!(self.error.is_none());\n                match format_escaped_str_contents(self.writer, self.formatter, s) {\n                    Ok(()) => Ok(()),\n                    Err(err) => {\n                        self.error = Some(err);\n                        Err(fmt::Error)\n                    }\n                }\n            }\n        }"],"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor":["impl<'de> de::Visitor<'de> for Visitor {\n            type Value = Map<String, Value>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a map\")\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,\n            {\n                Ok(Map::new())\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut values = Map::new();\n\n                while let Some((key, value)) = tri!(visitor.next_entry()) {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }\n        }"],"<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor":["impl<'de> Visitor<'de> for NumberVisitor {\n            type Value = Number;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a JSON number\")\n            }\n\n            #[inline]\n            fn visit_i64<E>(self, value: i64) -> Result<Number, E> {\n                Ok(value.into())\n            }\n\n            #[inline]\n            fn visit_u64<E>(self, value: u64) -> Result<Number, E> {\n                Ok(value.into())\n            }\n\n            #[inline]\n            fn visit_f64<E>(self, value: f64) -> Result<Number, E>\n            where\n                E: de::Error,\n            {\n                Number::from_f64(value).ok_or_else(|| de::Error::custom(\"not a JSON number\"))\n            }\n\n            #[cfg(feature = \"arbitrary_precision\")]\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Number, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let value = visitor.next_key::<NumberKey>()?;\n                if value.is_none() {\n                    return Err(de::Error::invalid_type(Unexpected::Map, &self));\n                }\n                let v: NumberFromString = visitor.next_value()?;\n                Ok(v.value)\n            }\n        }"],"<value::Value as std::fmt::Display>::fmt::WriterFormatter":["impl<'a, 'b> io::Write for WriterFormatter<'a, 'b> {\n            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n                // Safety: the serializer below only emits valid utf8 when using\n                // the default formatter.\n                let s = unsafe { str::from_utf8_unchecked(buf) };\n                tri!(self.inner.write_str(s).map_err(io_error));\n                Ok(buf.len())\n            }\n\n            fn flush(&mut self) -> io::Result<()> {\n                Ok(())\n            }\n        }"],"de::Deserializer":["impl<'a> Deserializer<read::SliceRead<'a>> {\n    /// Creates a JSON deserializer from a `&[u8]`.\n    pub fn from_slice(bytes: &'a [u8]) -> Self {\n        Deserializer::new(read::SliceRead::new(bytes))\n    }\n}","impl<'a> Deserializer<read::StrRead<'a>> {\n    /// Creates a JSON deserializer from a `&str`.\n    pub fn from_str(s: &'a str) -> Self {\n        Deserializer::new(read::StrRead::new(s))\n    }\n}","impl<'de, R: Read<'de>> Deserializer<R> {\n    /// The `Deserializer::end` method should be called after a value has been fully deserialized.\n    /// This allows the `Deserializer` to validate that the input stream is at the end or that it\n    /// only has trailing whitespace.\n    pub fn end(&mut self) -> Result<()> {\n        match tri!(self.parse_whitespace()) {\n            Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n            None => Ok(()),\n        }\n    }\n\n    /// Turn a JSON deserializer into an iterator over values of type T.\n    pub fn into_iter<T>(self) -> StreamDeserializer<'de, R, T>\n    where\n        T: de::Deserialize<'de>,\n    {\n        // This cannot be an implementation of std::iter::IntoIterator because\n        // we need the caller to choose what T is.\n        let offset = self.read.byte_offset();\n        StreamDeserializer {\n            de: self,\n            offset,\n            failed: false,\n            output: PhantomData,\n            lifetime: PhantomData,\n        }\n    }\n\n    /// Parse arbitrarily deep JSON structures without any consideration for\n    /// overflowing the stack.\n    ///\n    /// You will want to provide some other way to protect against stack\n    /// overflows, such as by wrapping your Deserializer in the dynamically\n    /// growing stack adapter provided by the serde_stacker crate. Additionally\n    /// you will need to be careful around other recursive operations on the\n    /// parsed result which may overflow the stack after deserialization has\n    /// completed, including, but not limited to, Display and Debug and Drop\n    /// impls.\n    ///\n    /// *This method is only available if serde_json is built with the\n    /// `\"unbounded_depth\"` feature.*\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde::Deserialize;\n    /// use serde_json::Value;\n    ///\n    /// fn main() {\n    ///     let mut json = String::new();\n    ///     for _ in 0..10000 {\n    ///         json = format!(\"[{}]\", json);\n    ///     }\n    ///\n    ///     let mut deserializer = serde_json::Deserializer::from_str(&json);\n    ///     deserializer.disable_recursion_limit();\n    ///     let deserializer = serde_stacker::Deserializer::new(&mut deserializer);\n    ///     let value = Value::deserialize(deserializer).unwrap();\n    ///\n    ///     carefully_drop_nested_arrays(value);\n    /// }\n    ///\n    /// fn carefully_drop_nested_arrays(value: Value) {\n    ///     let mut stack = vec![value];\n    ///     while let Some(value) = stack.pop() {\n    ///         if let Value::Array(array) = value {\n    ///             stack.extend(array);\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    #[cfg(feature = \"unbounded_depth\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"unbounded_depth\")))]\n    pub fn disable_recursion_limit(&mut self) {\n        self.disable_recursion_limit = true;\n    }\n\n    fn peek(&mut self) -> Result<Option<u8>> {\n        self.read.peek()\n    }\n\n    fn peek_or_null(&mut self) -> Result<u8> {\n        Ok(tri!(self.peek()).unwrap_or(b'\\x00'))\n    }\n\n    fn eat_char(&mut self) {\n        self.read.discard();\n    }\n\n    fn next_char(&mut self) -> Result<Option<u8>> {\n        self.read.next()\n    }\n\n    fn next_char_or_null(&mut self) -> Result<u8> {\n        Ok(tri!(self.next_char()).unwrap_or(b'\\x00'))\n    }\n\n    /// Error caused by a byte from next_char().\n    #[cold]\n    fn error(&self, reason: ErrorCode) -> Error {\n        let position = self.read.position();\n        Error::syntax(reason, position.line, position.column)\n    }\n\n    /// Error caused by a byte from peek().\n    #[cold]\n    fn peek_error(&self, reason: ErrorCode) -> Error {\n        let position = self.read.peek_position();\n        Error::syntax(reason, position.line, position.column)\n    }\n\n    /// Returns the first non-whitespace byte without consuming it, or `None` if\n    /// EOF is encountered.\n    fn parse_whitespace(&mut self) -> Result<Option<u8>> {\n        loop {\n            match tri!(self.peek()) {\n                Some(b' ') | Some(b'\\n') | Some(b'\\t') | Some(b'\\r') => {\n                    self.eat_char();\n                }\n                other => {\n                    return Ok(other);\n                }\n            }\n        }\n    }\n\n    #[cold]\n    fn peek_invalid_type(&mut self, exp: &dyn Expected) -> Error {\n        let err = match self.peek_or_null().unwrap_or(b'\\x00') {\n            b'n' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"ull\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Unit, exp)\n            }\n            b't' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"rue\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Bool(true), exp)\n            }\n            b'f' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"alse\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Bool(false), exp)\n            }\n            b'-' => {\n                self.eat_char();\n                match self.parse_any_number(false) {\n                    Ok(n) => n.invalid_type(exp),\n                    Err(err) => return err,\n                }\n            }\n            b'0'..=b'9' => match self.parse_any_number(true) {\n                Ok(n) => n.invalid_type(exp),\n                Err(err) => return err,\n            },\n            b'\"' => {\n                self.eat_char();\n                self.scratch.clear();\n                match self.read.parse_str(&mut self.scratch) {\n                    Ok(s) => de::Error::invalid_type(Unexpected::Str(&s), exp),\n                    Err(err) => return err,\n                }\n            }\n            b'[' => de::Error::invalid_type(Unexpected::Seq, exp),\n            b'{' => de::Error::invalid_type(Unexpected::Map, exp),\n            _ => self.peek_error(ErrorCode::ExpectedSomeValue),\n        };\n\n        self.fix_position(err)\n    }\n\n    fn deserialize_number<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'-' => {\n                self.eat_char();\n                tri!(self.parse_integer(false)).visit(visitor)\n            }\n            b'0'..=b'9' => tri!(self.parse_integer(true)).visit(visitor),\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }\n\n    fn scan_integer128(&mut self, buf: &mut String) -> Result<()> {\n        match tri!(self.next_char_or_null()) {\n            b'0' => {\n                buf.push('0');\n                // There can be only one leading '0'.\n                match tri!(self.peek_or_null()) {\n                    b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),\n                    _ => Ok(()),\n                }\n            }\n            c @ b'1'..=b'9' => {\n                buf.push(c as char);\n                while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n                    self.eat_char();\n                    buf.push(c as char);\n                }\n                Ok(())\n            }\n            _ => Err(self.error(ErrorCode::InvalidNumber)),\n        }\n    }\n\n    #[cold]\n    fn fix_position(&self, err: Error) -> Error {\n        err.fix_position(move |code| self.error(code))\n    }\n\n    fn parse_ident(&mut self, ident: &[u8]) -> Result<()> {\n        for expected in ident {\n            match tri!(self.next_char()) {\n                None => {\n                    return Err(self.error(ErrorCode::EofWhileParsingValue));\n                }\n                Some(next) => {\n                    if next != *expected {\n                        return Err(self.error(ErrorCode::ExpectedSomeIdent));\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    fn parse_integer(&mut self, positive: bool) -> Result<ParserNumber> {\n        let next = match tri!(self.next_char()) {\n            Some(b) => b,\n            None => {\n                return Err(self.error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        match next {\n            b'0' => {\n                // There can be only one leading '0'.\n                match tri!(self.peek_or_null()) {\n                    b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),\n                    _ => self.parse_number(positive, 0),\n                }\n            }\n            c @ b'1'..=b'9' => {\n                let mut significand = (c - b'0') as u64;\n\n                loop {\n                    match tri!(self.peek_or_null()) {\n                        c @ b'0'..=b'9' => {\n                            let digit = (c - b'0') as u64;\n\n                            // We need to be careful with overflow. If we can,\n                            // try to keep the number as a `u64` until we grow\n                            // too large. At that point, switch to parsing the\n                            // value as a `f64`.\n                            if overflow!(significand * 10 + digit, u64::max_value()) {\n                                return Ok(ParserNumber::F64(tri!(\n                                    self.parse_long_integer(positive, significand),\n                                )));\n                            }\n\n                            self.eat_char();\n                            significand = significand * 10 + digit;\n                        }\n                        _ => {\n                            return self.parse_number(positive, significand);\n                        }\n                    }\n                }\n            }\n            _ => Err(self.error(ErrorCode::InvalidNumber)),\n        }\n    }\n\n    fn parse_number(&mut self, positive: bool, significand: u64) -> Result<ParserNumber> {\n        Ok(match tri!(self.peek_or_null()) {\n            b'.' => ParserNumber::F64(tri!(self.parse_decimal(positive, significand, 0))),\n            b'e' | b'E' => ParserNumber::F64(tri!(self.parse_exponent(positive, significand, 0))),\n            _ => {\n                if positive {\n                    ParserNumber::U64(significand)\n                } else {\n                    let neg = (significand as i64).wrapping_neg();\n\n                    // Convert into a float if we underflow, or on `-0`.\n                    if neg >= 0 {\n                        ParserNumber::F64(-(significand as f64))\n                    } else {\n                        ParserNumber::I64(neg)\n                    }\n                }\n            }\n        })\n    }\n\n    fn parse_decimal(\n        &mut self,\n        positive: bool,\n        mut significand: u64,\n        exponent_before_decimal_point: i32,\n    ) -> Result<f64> {\n        self.eat_char();\n\n        let mut exponent_after_decimal_point = 0;\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            let digit = (c - b'0') as u64;\n\n            if overflow!(significand * 10 + digit, u64::max_value()) {\n                let exponent = exponent_before_decimal_point + exponent_after_decimal_point;\n                return self.parse_decimal_overflow(positive, significand, exponent);\n            }\n\n            self.eat_char();\n            significand = significand * 10 + digit;\n            exponent_after_decimal_point -= 1;\n        }\n\n        // Error if there is not at least one digit after the decimal point.\n        if exponent_after_decimal_point == 0 {\n            match tri!(self.peek()) {\n                Some(_) => return Err(self.peek_error(ErrorCode::InvalidNumber)),\n                None => return Err(self.peek_error(ErrorCode::EofWhileParsingValue)),\n            }\n        }\n\n        let exponent = exponent_before_decimal_point + exponent_after_decimal_point;\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.parse_exponent(positive, significand, exponent),\n            _ => self.f64_from_parts(positive, significand, exponent),\n        }\n    }\n\n    fn parse_exponent(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        starting_exp: i32,\n    ) -> Result<f64> {\n        self.eat_char();\n\n        let positive_exp = match tri!(self.peek_or_null()) {\n            b'+' => {\n                self.eat_char();\n                true\n            }\n            b'-' => {\n                self.eat_char();\n                false\n            }\n            _ => true,\n        };\n\n        let next = match tri!(self.next_char()) {\n            Some(b) => b,\n            None => {\n                return Err(self.error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        // Make sure a digit follows the exponent place.\n        let mut exp = match next {\n            c @ b'0'..=b'9' => (c - b'0') as i32,\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        };\n\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            let digit = (c - b'0') as i32;\n\n            if overflow!(exp * 10 + digit, i32::max_value()) {\n                let zero_significand = significand == 0;\n                return self.parse_exponent_overflow(positive, zero_significand, positive_exp);\n            }\n\n            exp = exp * 10 + digit;\n        }\n\n        let final_exp = if positive_exp {\n            starting_exp.saturating_add(exp)\n        } else {\n            starting_exp.saturating_sub(exp)\n        };\n\n        self.f64_from_parts(positive, significand, final_exp)\n    }\n\n    #[cfg(feature = \"float_roundtrip\")]\n    fn f64_from_parts(&mut self, positive: bool, significand: u64, exponent: i32) -> Result<f64> {\n        let f = if self.single_precision {\n            lexical::parse_concise_float::<f32>(significand, exponent) as f64\n        } else {\n            lexical::parse_concise_float::<f64>(significand, exponent)\n        };\n\n        if f.is_infinite() {\n            Err(self.error(ErrorCode::NumberOutOfRange))\n        } else {\n            Ok(if positive { f } else { -f })\n        }\n    }\n\n    #[cfg(not(feature = \"float_roundtrip\"))]\n    fn f64_from_parts(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        mut exponent: i32,\n    ) -> Result<f64> {\n        let mut f = significand as f64;\n        loop {\n            match POW10.get(exponent.wrapping_abs() as usize) {\n                Some(&pow) => {\n                    if exponent >= 0 {\n                        f *= pow;\n                        if f.is_infinite() {\n                            return Err(self.error(ErrorCode::NumberOutOfRange));\n                        }\n                    } else {\n                        f /= pow;\n                    }\n                    break;\n                }\n                None => {\n                    if f == 0.0 {\n                        break;\n                    }\n                    if exponent >= 0 {\n                        return Err(self.error(ErrorCode::NumberOutOfRange));\n                    }\n                    f /= 1e308;\n                    exponent += 308;\n                }\n            }\n        }\n        Ok(if positive { f } else { -f })\n    }\n\n    #[cfg(feature = \"float_roundtrip\")]\n    #[cold]\n    #[inline(never)]\n    fn parse_long_integer(&mut self, positive: bool, partial_significand: u64) -> Result<f64> {\n        // To deserialize floats we'll first push the integer and fraction\n        // parts, both as byte strings, into the scratch buffer and then feed\n        // both slices to lexical's parser. For example if the input is\n        // `12.34e5` we'll push b\"1234\" into scratch and then pass b\"12\" and\n        // b\"34\" to lexical. `integer_end` will be used to track where to split\n        // the scratch buffer.\n        //\n        // Note that lexical expects the integer part to contain *no* leading\n        // zeroes and the fraction part to contain *no* trailing zeroes. The\n        // first requirement is already handled by the integer parsing logic.\n        // The second requirement will be enforced just before passing the\n        // slices to lexical in f64_long_from_parts.\n        self.scratch.clear();\n        self.scratch\n            .extend_from_slice(itoa::Buffer::new().format(partial_significand).as_bytes());\n\n        loop {\n            match tri!(self.peek_or_null()) {\n                c @ b'0'..=b'9' => {\n                    self.scratch.push(c);\n                    self.eat_char();\n                }\n                b'.' => {\n                    self.eat_char();\n                    return self.parse_long_decimal(positive, self.scratch.len());\n                }\n                b'e' | b'E' => {\n                    return self.parse_long_exponent(positive, self.scratch.len());\n                }\n                _ => {\n                    return self.f64_long_from_parts(positive, self.scratch.len(), 0);\n                }\n            }\n        }\n    }\n\n    #[cfg(not(feature = \"float_roundtrip\"))]\n    #[cold]\n    #[inline(never)]\n    fn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64> {\n        let mut exponent = 0;\n        loop {\n            match tri!(self.peek_or_null()) {\n                b'0'..=b'9' => {\n                    self.eat_char();\n                    // This could overflow... if your integer is gigabytes long.\n                    // Ignore that possibility.\n                    exponent += 1;\n                }\n                b'.' => {\n                    return self.parse_decimal(positive, significand, exponent);\n                }\n                b'e' | b'E' => {\n                    return self.parse_exponent(positive, significand, exponent);\n                }\n                _ => {\n                    return self.f64_from_parts(positive, significand, exponent);\n                }\n            }\n        }\n    }\n\n    #[cfg(feature = \"float_roundtrip\")]\n    #[cold]\n    fn parse_long_decimal(&mut self, positive: bool, integer_end: usize) -> Result<f64> {\n        let mut at_least_one_digit = integer_end < self.scratch.len();\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.scratch.push(c);\n            self.eat_char();\n            at_least_one_digit = true;\n        }\n\n        if !at_least_one_digit {\n            match tri!(self.peek()) {\n                Some(_) => return Err(self.peek_error(ErrorCode::InvalidNumber)),\n                None => return Err(self.peek_error(ErrorCode::EofWhileParsingValue)),\n            }\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.parse_long_exponent(positive, integer_end),\n            _ => self.f64_long_from_parts(positive, integer_end, 0),\n        }\n    }\n\n    #[cfg(feature = \"float_roundtrip\")]\n    fn parse_long_exponent(&mut self, positive: bool, integer_end: usize) -> Result<f64> {\n        self.eat_char();\n\n        let positive_exp = match tri!(self.peek_or_null()) {\n            b'+' => {\n                self.eat_char();\n                true\n            }\n            b'-' => {\n                self.eat_char();\n                false\n            }\n            _ => true,\n        };\n\n        let next = match tri!(self.next_char()) {\n            Some(b) => b,\n            None => {\n                return Err(self.error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        // Make sure a digit follows the exponent place.\n        let mut exp = match next {\n            c @ b'0'..=b'9' => (c - b'0') as i32,\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        };\n\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            let digit = (c - b'0') as i32;\n\n            if overflow!(exp * 10 + digit, i32::max_value()) {\n                let zero_significand = self.scratch.iter().all(|&digit| digit == b'0');\n                return self.parse_exponent_overflow(positive, zero_significand, positive_exp);\n            }\n\n            exp = exp * 10 + digit;\n        }\n\n        let final_exp = if positive_exp { exp } else { -exp };\n\n        self.f64_long_from_parts(positive, integer_end, final_exp)\n    }\n\n    // This cold code should not be inlined into the middle of the hot\n    // decimal-parsing loop above.\n    #[cfg(feature = \"float_roundtrip\")]\n    #[cold]\n    #[inline(never)]\n    fn parse_decimal_overflow(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        exponent: i32,\n    ) -> Result<f64> {\n        let mut buffer = itoa::Buffer::new();\n        let significand = buffer.format(significand);\n        let fraction_digits = -exponent as usize;\n        self.scratch.clear();\n        if let Some(zeros) = fraction_digits.checked_sub(significand.len() + 1) {\n            self.scratch.extend(iter::repeat(b'0').take(zeros + 1));\n        }\n        self.scratch.extend_from_slice(significand.as_bytes());\n        let integer_end = self.scratch.len() - fraction_digits;\n        self.parse_long_decimal(positive, integer_end)\n    }\n\n    #[cfg(not(feature = \"float_roundtrip\"))]\n    #[cold]\n    #[inline(never)]\n    fn parse_decimal_overflow(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        exponent: i32,\n    ) -> Result<f64> {\n        // The next multiply/add would overflow, so just ignore all further\n        // digits.\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.parse_exponent(positive, significand, exponent),\n            _ => self.f64_from_parts(positive, significand, exponent),\n        }\n    }\n\n    // This cold code should not be inlined into the middle of the hot\n    // exponent-parsing loop above.\n    #[cold]\n    #[inline(never)]\n    fn parse_exponent_overflow(\n        &mut self,\n        positive: bool,\n        zero_significand: bool,\n        positive_exp: bool,\n    ) -> Result<f64> {\n        // Error instead of +/- infinity.\n        if !zero_significand && positive_exp {\n            return Err(self.error(ErrorCode::NumberOutOfRange));\n        }\n\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n        }\n        Ok(if positive { 0.0 } else { -0.0 })\n    }\n\n    #[cfg(feature = \"float_roundtrip\")]\n    fn f64_long_from_parts(\n        &mut self,\n        positive: bool,\n        integer_end: usize,\n        exponent: i32,\n    ) -> Result<f64> {\n        let integer = &self.scratch[..integer_end];\n        let fraction = &self.scratch[integer_end..];\n\n        let f = if self.single_precision {\n            lexical::parse_truncated_float::<f32>(integer, fraction, exponent) as f64\n        } else {\n            lexical::parse_truncated_float::<f64>(integer, fraction, exponent)\n        };\n\n        if f.is_infinite() {\n            Err(self.error(ErrorCode::NumberOutOfRange))\n        } else {\n            Ok(if positive { f } else { -f })\n        }\n    }\n\n    fn parse_any_signed_number(&mut self) -> Result<ParserNumber> {\n        let peek = match tri!(self.peek()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'-' => {\n                self.eat_char();\n                self.parse_any_number(false)\n            }\n            b'0'..=b'9' => self.parse_any_number(true),\n            _ => Err(self.peek_error(ErrorCode::InvalidNumber)),\n        };\n\n        let value = match tri!(self.peek()) {\n            Some(_) => Err(self.peek_error(ErrorCode::InvalidNumber)),\n            None => value,\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            // The de::Error impl creates errors with unknown line and column.\n            // Fill in the position here by looking at the current index in the\n            // input. There is no way to tell whether this should call `error`\n            // or `peek_error` so pick the one that seems correct more often.\n            // Worst case, the position is off by one character.\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }\n\n    #[cfg(not(feature = \"arbitrary_precision\"))]\n    fn parse_any_number(&mut self, positive: bool) -> Result<ParserNumber> {\n        self.parse_integer(positive)\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn parse_any_number(&mut self, positive: bool) -> Result<ParserNumber> {\n        let mut buf = String::with_capacity(16);\n        if !positive {\n            buf.push('-');\n        }\n        self.scan_integer(&mut buf)?;\n        if positive {\n            if let Ok(unsigned) = buf.parse() {\n                return Ok(ParserNumber::U64(unsigned));\n            }\n        } else {\n            if let Ok(signed) = buf.parse() {\n                return Ok(ParserNumber::I64(signed));\n            }\n        }\n        Ok(ParserNumber::String(buf))\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_or_eof(&mut self, buf: &mut String) -> Result<u8> {\n        match tri!(self.next_char()) {\n            Some(b) => {\n                buf.push(b as char);\n                Ok(b)\n            }\n            None => Err(self.error(ErrorCode::EofWhileParsingValue)),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_integer(&mut self, buf: &mut String) -> Result<()> {\n        match tri!(self.scan_or_eof(buf)) {\n            b'0' => {\n                // There can be only one leading '0'.\n                match tri!(self.peek_or_null()) {\n                    b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),\n                    _ => self.scan_number(buf),\n                }\n            }\n            b'1'..=b'9' => loop {\n                match tri!(self.peek_or_null()) {\n                    c @ b'0'..=b'9' => {\n                        self.eat_char();\n                        buf.push(c as char);\n                    }\n                    _ => {\n                        return self.scan_number(buf);\n                    }\n                }\n            },\n            _ => Err(self.error(ErrorCode::InvalidNumber)),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_number(&mut self, buf: &mut String) -> Result<()> {\n        match tri!(self.peek_or_null()) {\n            b'.' => self.scan_decimal(buf),\n            e @ b'e' | e @ b'E' => self.scan_exponent(e as char, buf),\n            _ => Ok(()),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_decimal(&mut self, buf: &mut String) -> Result<()> {\n        self.eat_char();\n        buf.push('.');\n\n        let mut at_least_one_digit = false;\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            buf.push(c as char);\n            at_least_one_digit = true;\n        }\n\n        if !at_least_one_digit {\n            match tri!(self.peek()) {\n                Some(_) => return Err(self.peek_error(ErrorCode::InvalidNumber)),\n                None => return Err(self.peek_error(ErrorCode::EofWhileParsingValue)),\n            }\n        }\n\n        match tri!(self.peek_or_null()) {\n            e @ b'e' | e @ b'E' => self.scan_exponent(e as char, buf),\n            _ => Ok(()),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn scan_exponent(&mut self, e: char, buf: &mut String) -> Result<()> {\n        self.eat_char();\n        buf.push(e);\n\n        match tri!(self.peek_or_null()) {\n            b'+' => {\n                self.eat_char();\n                buf.push('+');\n            }\n            b'-' => {\n                self.eat_char();\n                buf.push('-');\n            }\n            _ => {}\n        }\n\n        // Make sure a digit follows the exponent place.\n        match tri!(self.scan_or_eof(buf)) {\n            b'0'..=b'9' => {}\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        }\n\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            buf.push(c as char);\n        }\n\n        Ok(())\n    }\n\n    fn parse_object_colon(&mut self) -> Result<()> {\n        match tri!(self.parse_whitespace()) {\n            Some(b':') => {\n                self.eat_char();\n                Ok(())\n            }\n            Some(_) => Err(self.peek_error(ErrorCode::ExpectedColon)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n        }\n    }\n\n    fn end_seq(&mut self) -> Result<()> {\n        match tri!(self.parse_whitespace()) {\n            Some(b']') => {\n                self.eat_char();\n                Ok(())\n            }\n            Some(b',') => {\n                self.eat_char();\n                match self.parse_whitespace() {\n                    Ok(Some(b']')) => Err(self.peek_error(ErrorCode::TrailingComma)),\n                    _ => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n                }\n            }\n            Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingList)),\n        }\n    }\n\n    fn end_map(&mut self) -> Result<()> {\n        match tri!(self.parse_whitespace()) {\n            Some(b'}') => {\n                self.eat_char();\n                Ok(())\n            }\n            Some(b',') => Err(self.peek_error(ErrorCode::TrailingComma)),\n            Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n        }\n    }\n\n    fn ignore_value(&mut self) -> Result<()> {\n        self.scratch.clear();\n        let mut enclosing = None;\n\n        loop {\n            let peek = match tri!(self.parse_whitespace()) {\n                Some(b) => b,\n                None => {\n                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n                }\n            };\n\n            let frame = match peek {\n                b'n' => {\n                    self.eat_char();\n                    tri!(self.parse_ident(b\"ull\"));\n                    None\n                }\n                b't' => {\n                    self.eat_char();\n                    tri!(self.parse_ident(b\"rue\"));\n                    None\n                }\n                b'f' => {\n                    self.eat_char();\n                    tri!(self.parse_ident(b\"alse\"));\n                    None\n                }\n                b'-' => {\n                    self.eat_char();\n                    tri!(self.ignore_integer());\n                    None\n                }\n                b'0'..=b'9' => {\n                    tri!(self.ignore_integer());\n                    None\n                }\n                b'\"' => {\n                    self.eat_char();\n                    tri!(self.read.ignore_str());\n                    None\n                }\n                frame @ b'[' | frame @ b'{' => {\n                    self.scratch.extend(enclosing.take());\n                    self.eat_char();\n                    Some(frame)\n                }\n                _ => return Err(self.peek_error(ErrorCode::ExpectedSomeValue)),\n            };\n\n            let (mut accept_comma, mut frame) = match frame {\n                Some(frame) => (false, frame),\n                None => match enclosing.take() {\n                    Some(frame) => (true, frame),\n                    None => match self.scratch.pop() {\n                        Some(frame) => (true, frame),\n                        None => return Ok(()),\n                    },\n                },\n            };\n\n            loop {\n                match tri!(self.parse_whitespace()) {\n                    Some(b',') if accept_comma => {\n                        self.eat_char();\n                        break;\n                    }\n                    Some(b']') if frame == b'[' => {}\n                    Some(b'}') if frame == b'{' => {}\n                    Some(_) => {\n                        if accept_comma {\n                            return Err(self.peek_error(match frame {\n                                b'[' => ErrorCode::ExpectedListCommaOrEnd,\n                                b'{' => ErrorCode::ExpectedObjectCommaOrEnd,\n                                _ => unreachable!(),\n                            }));\n                        } else {\n                            break;\n                        }\n                    }\n                    None => {\n                        return Err(self.peek_error(match frame {\n                            b'[' => ErrorCode::EofWhileParsingList,\n                            b'{' => ErrorCode::EofWhileParsingObject,\n                            _ => unreachable!(),\n                        }));\n                    }\n                }\n\n                self.eat_char();\n                frame = match self.scratch.pop() {\n                    Some(frame) => frame,\n                    None => return Ok(()),\n                };\n                accept_comma = true;\n            }\n\n            if frame == b'{' {\n                match tri!(self.parse_whitespace()) {\n                    Some(b'\"') => self.eat_char(),\n                    Some(_) => return Err(self.peek_error(ErrorCode::KeyMustBeAString)),\n                    None => return Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n                }\n                tri!(self.read.ignore_str());\n                match tri!(self.parse_whitespace()) {\n                    Some(b':') => self.eat_char(),\n                    Some(_) => return Err(self.peek_error(ErrorCode::ExpectedColon)),\n                    None => return Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n                }\n            }\n\n            enclosing = Some(frame);\n        }\n    }\n\n    fn ignore_integer(&mut self) -> Result<()> {\n        match tri!(self.next_char_or_null()) {\n            b'0' => {\n                // There can be only one leading '0'.\n                if let b'0'..=b'9' = tri!(self.peek_or_null()) {\n                    return Err(self.peek_error(ErrorCode::InvalidNumber));\n                }\n            }\n            b'1'..=b'9' => {\n                while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n                    self.eat_char();\n                }\n            }\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'.' => self.ignore_decimal(),\n            b'e' | b'E' => self.ignore_exponent(),\n            _ => Ok(()),\n        }\n    }\n\n    fn ignore_decimal(&mut self) -> Result<()> {\n        self.eat_char();\n\n        let mut at_least_one_digit = false;\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            at_least_one_digit = true;\n        }\n\n        if !at_least_one_digit {\n            return Err(self.peek_error(ErrorCode::InvalidNumber));\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.ignore_exponent(),\n            _ => Ok(()),\n        }\n    }\n\n    fn ignore_exponent(&mut self) -> Result<()> {\n        self.eat_char();\n\n        match tri!(self.peek_or_null()) {\n            b'+' | b'-' => self.eat_char(),\n            _ => {}\n        }\n\n        // Make sure a digit follows the exponent place.\n        match tri!(self.next_char_or_null()) {\n            b'0'..=b'9' => {}\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        }\n\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n        }\n\n        Ok(())\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn deserialize_raw_value<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        self.parse_whitespace()?;\n        self.read.begin_raw_buffering();\n        self.ignore_value()?;\n        self.read.end_raw_buffering(visitor)\n    }\n}","impl<'de, R> Deserializer<R>\nwhere\n    R: read::Read<'de>,\n{\n    /// Create a JSON deserializer from one of the possible serde_json input\n    /// sources.\n    ///\n    /// Typically it is more convenient to use one of these methods instead:\n    ///\n    ///   - Deserializer::from_str\n    ///   - Deserializer::from_slice\n    ///   - Deserializer::from_reader\n    pub fn new(read: R) -> Self {\n        Deserializer {\n            read,\n            scratch: Vec::new(),\n            remaining_depth: 128,\n            #[cfg(feature = \"float_roundtrip\")]\n            single_precision: false,\n            #[cfg(feature = \"unbounded_depth\")]\n            disable_recursion_limit: false,\n        }\n    }\n}","impl<R> Deserializer<read::IoRead<R>>\nwhere\n    R: crate::io::Read,\n{\n    /// Creates a JSON deserializer from an `io::Read`.\n    ///\n    /// Reader-based deserializers do not support deserializing borrowed types\n    /// like `&str`, since the `std::io::Read` trait has no non-copying methods\n    /// -- everything it does involves copying bytes out of the data source.\n    pub fn from_reader(reader: R) -> Self {\n        Deserializer::new(read::IoRead::new(reader))\n    }\n}"],"de::MapAccess":["impl<'a, R: 'a> MapAccess<'a, R> {\n    fn new(de: &'a mut Deserializer<R>) -> Self {\n        MapAccess { de, first: true }\n    }\n}","impl<'de, 'a, R: Read<'de> + 'a> de::MapAccess<'de> for MapAccess<'a, R> {\n    type Error = Error;\n\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>>\n    where\n        K: de::DeserializeSeed<'de>,\n    {\n        let peek = match tri!(self.de.parse_whitespace()) {\n            Some(b'}') => {\n                return Ok(None);\n            }\n            Some(b',') if !self.first => {\n                self.de.eat_char();\n                tri!(self.de.parse_whitespace())\n            }\n            Some(b) => {\n                if self.first {\n                    self.first = false;\n                    Some(b)\n                } else {\n                    return Err(self.de.peek_error(ErrorCode::ExpectedObjectCommaOrEnd));\n                }\n            }\n            None => {\n                return Err(self.de.peek_error(ErrorCode::EofWhileParsingObject));\n            }\n        };\n\n        match peek {\n            Some(b'\"') => seed.deserialize(MapKey { de: &mut *self.de }).map(Some),\n            Some(b'}') => Err(self.de.peek_error(ErrorCode::TrailingComma)),\n            Some(_) => Err(self.de.peek_error(ErrorCode::KeyMustBeAString)),\n            None => Err(self.de.peek_error(ErrorCode::EofWhileParsingValue)),\n        }\n    }\n\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        tri!(self.de.parse_object_colon());\n\n        seed.deserialize(&mut *self.de)\n    }\n}"],"de::MapKey":["impl<'de, 'a, R> de::Deserializer<'de> for MapKey<'a, R>\nwhere\n    R: Read<'de>,\n{\n    type Error = Error;\n\n    #[inline]\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        self.de.eat_char();\n        self.de.scratch.clear();\n        match tri!(self.de.read.parse_str(&mut self.de.scratch)) {\n            Reference::Borrowed(s) => visitor.visit_borrowed_str(s),\n            Reference::Copied(s) => visitor.visit_str(s),\n        }\n    }\n\n    deserialize_integer_key!(deserialize_i8 => visit_i8);\n    deserialize_integer_key!(deserialize_i16 => visit_i16);\n    deserialize_integer_key!(deserialize_i32 => visit_i32);\n    deserialize_integer_key!(deserialize_i64 => visit_i64);\n    deserialize_integer_key!(deserialize_i128 => visit_i128);\n    deserialize_integer_key!(deserialize_u8 => visit_u8);\n    deserialize_integer_key!(deserialize_u16 => visit_u16);\n    deserialize_integer_key!(deserialize_u32 => visit_u32);\n    deserialize_integer_key!(deserialize_u64 => visit_u64);\n    deserialize_integer_key!(deserialize_u128 => visit_u128);\n\n    #[inline]\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        // Map keys cannot be null.\n        visitor.visit_some(self)\n    }\n\n    #[inline]\n    fn deserialize_newtype_struct<V>(self, name: &'static str, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        #[cfg(feature = \"raw_value\")]\n        {\n            if name == crate::raw::TOKEN {\n                return self.de.deserialize_raw_value(visitor);\n            }\n        }\n\n        let _ = name;\n        visitor.visit_newtype_struct(self)\n    }\n\n    #[inline]\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        self.de.deserialize_enum(name, variants, visitor)\n    }\n\n    #[inline]\n    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        self.de.deserialize_bytes(visitor)\n    }\n\n    #[inline]\n    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        self.de.deserialize_bytes(visitor)\n    }\n\n    forward_to_deserialize_any! {\n        bool f32 f64 char str string unit unit_struct seq tuple tuple_struct map\n        struct identifier ignored_any\n    }\n}"],"de::ParserNumber":["impl ParserNumber {\n    fn visit<'de, V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        match self {\n            ParserNumber::F64(x) => visitor.visit_f64(x),\n            ParserNumber::U64(x) => visitor.visit_u64(x),\n            ParserNumber::I64(x) => visitor.visit_i64(x),\n            #[cfg(feature = \"arbitrary_precision\")]\n            ParserNumber::String(x) => visitor.visit_map(NumberDeserializer { number: x.into() }),\n        }\n    }\n\n    fn invalid_type(self, exp: &dyn Expected) -> Error {\n        match self {\n            ParserNumber::F64(x) => de::Error::invalid_type(Unexpected::Float(x), exp),\n            ParserNumber::U64(x) => de::Error::invalid_type(Unexpected::Unsigned(x), exp),\n            ParserNumber::I64(x) => de::Error::invalid_type(Unexpected::Signed(x), exp),\n            #[cfg(feature = \"arbitrary_precision\")]\n            ParserNumber::String(_) => de::Error::invalid_type(Unexpected::Other(\"number\"), exp),\n        }\n    }\n}"],"de::SeqAccess":["impl<'a, R: 'a> SeqAccess<'a, R> {\n    fn new(de: &'a mut Deserializer<R>) -> Self {\n        SeqAccess { de, first: true }\n    }\n}","impl<'de, 'a, R: Read<'de> + 'a> de::SeqAccess<'de> for SeqAccess<'a, R> {\n    type Error = Error;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        let peek = match tri!(self.de.parse_whitespace()) {\n            Some(b']') => {\n                return Ok(None);\n            }\n            Some(b',') if !self.first => {\n                self.de.eat_char();\n                tri!(self.de.parse_whitespace())\n            }\n            Some(b) => {\n                if self.first {\n                    self.first = false;\n                    Some(b)\n                } else {\n                    return Err(self.de.peek_error(ErrorCode::ExpectedListCommaOrEnd));\n                }\n            }\n            None => {\n                return Err(self.de.peek_error(ErrorCode::EofWhileParsingList));\n            }\n        };\n\n        match peek {\n            Some(b']') => Err(self.de.peek_error(ErrorCode::TrailingComma)),\n            Some(_) => Ok(Some(tri!(seed.deserialize(&mut *self.de)))),\n            None => Err(self.de.peek_error(ErrorCode::EofWhileParsingValue)),\n        }\n    }\n}"],"de::StreamDeserializer":["impl<'de, R, T> FusedIterator for StreamDeserializer<'de, R, T>\nwhere\n    R: Read<'de> + Fused,\n    T: de::Deserialize<'de>,\n{\n}","impl<'de, R, T> Iterator for StreamDeserializer<'de, R, T>\nwhere\n    R: Read<'de>,\n    T: de::Deserialize<'de>,\n{\n    type Item = Result<T>;\n\n    fn next(&mut self) -> Option<Result<T>> {\n        if R::should_early_return_if_failed && self.failed {\n            return None;\n        }\n\n        // skip whitespaces, if any\n        // this helps with trailing whitespaces, since whitespaces between\n        // values are handled for us.\n        match self.de.parse_whitespace() {\n            Ok(None) => {\n                self.offset = self.de.read.byte_offset();\n                None\n            }\n            Ok(Some(b)) => {\n                // If the value does not have a clear way to show the end of the value\n                // (like numbers, null, true etc.) we have to look for whitespace or\n                // the beginning of a self-delineated value.\n                let self_delineated_value = match b {\n                    b'[' | b'\"' | b'{' => true,\n                    _ => false,\n                };\n                self.offset = self.de.read.byte_offset();\n                let result = de::Deserialize::deserialize(&mut self.de);\n\n                Some(match result {\n                    Ok(value) => {\n                        self.offset = self.de.read.byte_offset();\n                        if self_delineated_value {\n                            Ok(value)\n                        } else {\n                            self.peek_end_of_value().map(|_| value)\n                        }\n                    }\n                    Err(e) => {\n                        self.de.read.set_failed(&mut self.failed);\n                        Err(e)\n                    }\n                })\n            }\n            Err(e) => {\n                self.de.read.set_failed(&mut self.failed);\n                Some(Err(e))\n            }\n        }\n    }\n}","impl<'de, R, T> StreamDeserializer<'de, R, T>\nwhere\n    R: read::Read<'de>,\n    T: de::Deserialize<'de>,\n{\n    /// Create a JSON stream deserializer from one of the possible serde_json\n    /// input sources.\n    ///\n    /// Typically it is more convenient to use one of these methods instead:\n    ///\n    ///   - Deserializer::from_str(...).into_iter()\n    ///   - Deserializer::from_slice(...).into_iter()\n    ///   - Deserializer::from_reader(...).into_iter()\n    pub fn new(read: R) -> Self {\n        let offset = read.byte_offset();\n        StreamDeserializer {\n            de: Deserializer::new(read),\n            offset,\n            failed: false,\n            output: PhantomData,\n            lifetime: PhantomData,\n        }\n    }\n\n    /// Returns the number of bytes so far deserialized into a successful `T`.\n    ///\n    /// If a stream deserializer returns an EOF error, new data can be joined to\n    /// `old_data[stream.byte_offset()..]` to try again.\n    ///\n    /// ```\n    /// let data = b\"[0] [1] [\";\n    ///\n    /// let de = serde_json::Deserializer::from_slice(data);\n    /// let mut stream = de.into_iter::<Vec<i32>>();\n    /// assert_eq!(0, stream.byte_offset());\n    ///\n    /// println!(\"{:?}\", stream.next()); // [0]\n    /// assert_eq!(3, stream.byte_offset());\n    ///\n    /// println!(\"{:?}\", stream.next()); // [1]\n    /// assert_eq!(7, stream.byte_offset());\n    ///\n    /// println!(\"{:?}\", stream.next()); // error\n    /// assert_eq!(8, stream.byte_offset());\n    ///\n    /// // If err.is_eof(), can join the remaining data to new data and continue.\n    /// let remaining = &data[stream.byte_offset()..];\n    /// ```\n    ///\n    /// *Note:* In the future this method may be changed to return the number of\n    /// bytes so far deserialized into a successful T *or* syntactically valid\n    /// JSON skipped over due to a type error. See [serde-rs/json#70] for an\n    /// example illustrating this.\n    ///\n    /// [serde-rs/json#70]: https://github.com/serde-rs/json/issues/70\n    pub fn byte_offset(&self) -> usize {\n        self.offset\n    }\n\n    fn peek_end_of_value(&mut self) -> Result<()> {\n        match tri!(self.de.peek()) {\n            Some(b' ') | Some(b'\\n') | Some(b'\\t') | Some(b'\\r') | Some(b'\"') | Some(b'[')\n            | Some(b']') | Some(b'{') | Some(b'}') | Some(b',') | Some(b':') | None => Ok(()),\n            Some(_) => {\n                let position = self.de.read.peek_position();\n                Err(Error::syntax(\n                    ErrorCode::TrailingCharacters,\n                    position.line,\n                    position.column,\n                ))\n            }\n        }\n    }\n}"],"de::UnitVariantAccess":["impl<'a, R: 'a> UnitVariantAccess<'a, R> {\n    fn new(de: &'a mut Deserializer<R>) -> Self {\n        UnitVariantAccess { de }\n    }\n}","impl<'de, 'a, R: Read<'de> + 'a> de::EnumAccess<'de> for UnitVariantAccess<'a, R> {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self)>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        let variant = tri!(seed.deserialize(&mut *self.de));\n        Ok((variant, self))\n    }\n}","impl<'de, 'a, R: Read<'de> + 'a> de::VariantAccess<'de> for UnitVariantAccess<'a, R> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<()> {\n        Ok(())\n    }\n\n    fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"newtype variant\",\n        ))\n    }\n\n    fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"tuple variant\",\n        ))\n    }\n\n    fn struct_variant<V>(self, _fields: &'static [&'static str], _visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"struct variant\",\n        ))\n    }\n}"],"de::VariantAccess":["impl<'a, R: 'a> VariantAccess<'a, R> {\n    fn new(de: &'a mut Deserializer<R>) -> Self {\n        VariantAccess { de }\n    }\n}","impl<'de, 'a, R: Read<'de> + 'a> de::EnumAccess<'de> for VariantAccess<'a, R> {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self)>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        let val = tri!(seed.deserialize(&mut *self.de));\n        tri!(self.de.parse_object_colon());\n        Ok((val, self))\n    }\n}","impl<'de, 'a, R: Read<'de> + 'a> de::VariantAccess<'de> for VariantAccess<'a, R> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<()> {\n        de::Deserialize::deserialize(self.de)\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        seed.deserialize(self.de)\n    }\n\n    fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        de::Deserializer::deserialize_seq(self.de, visitor)\n    }\n\n    fn struct_variant<V>(self, fields: &'static [&'static str], visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,\n    {\n        de::Deserializer::deserialize_struct(self.de, \"\", fields, visitor)\n    }\n}"],"error::Category":["Clone","Copy","Debug","Eq","PartialEq"],"error::Error":["impl Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"Error({:?}, line: {}, column: {})\",\n            self.err.code.to_string(),\n            self.err.line,\n            self.err.column\n        )\n    }\n}","impl Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(&*self.err, f)\n    }\n}","impl Error {\n    #[cold]\n    pub(crate) fn syntax(code: ErrorCode, line: usize, column: usize) -> Self {\n        Error {\n            err: Box::new(ErrorImpl { code, line, column }),\n        }\n    }\n\n    // Not public API. Should be pub(crate).\n    //\n    // Update `eager_json` crate when this function changes.\n    #[doc(hidden)]\n    #[cold]\n    pub fn io(error: io::Error) -> Self {\n        Error {\n            err: Box::new(ErrorImpl {\n                code: ErrorCode::Io(error),\n                line: 0,\n                column: 0,\n            }),\n        }\n    }\n\n    #[cold]\n    pub(crate) fn fix_position<F>(self, f: F) -> Self\n    where\n        F: FnOnce(ErrorCode) -> Error,\n    {\n        if self.err.line == 0 {\n            f(self.err.code)\n        } else {\n            self\n        }\n    }\n}","impl Error {\n    /// One-based line number at which the error was detected.\n    ///\n    /// Characters in the first line of the input (before the first newline\n    /// character) are in line 1.\n    pub fn line(&self) -> usize {\n        self.err.line\n    }\n\n    /// One-based column number at which the error was detected.\n    ///\n    /// The first character in the input and any characters immediately\n    /// following a newline character are in column 1.\n    ///\n    /// Note that errors may occur in column 0, for example if a read from an IO\n    /// stream fails immediately following a previously read newline character.\n    pub fn column(&self) -> usize {\n        self.err.column\n    }\n\n    /// Categorizes the cause of this error.\n    ///\n    /// - `Category::Io` - failure to read or write bytes on an IO stream\n    /// - `Category::Syntax` - input that is not syntactically valid JSON\n    /// - `Category::Data` - input data that is semantically incorrect\n    /// - `Category::Eof` - unexpected end of the input data\n    pub fn classify(&self) -> Category {\n        match self.err.code {\n            ErrorCode::Message(_) => Category::Data,\n            ErrorCode::Io(_) => Category::Io,\n            ErrorCode::EofWhileParsingList\n            | ErrorCode::EofWhileParsingObject\n            | ErrorCode::EofWhileParsingString\n            | ErrorCode::EofWhileParsingValue => Category::Eof,\n            ErrorCode::ExpectedColon\n            | ErrorCode::ExpectedListCommaOrEnd\n            | ErrorCode::ExpectedObjectCommaOrEnd\n            | ErrorCode::ExpectedSomeIdent\n            | ErrorCode::ExpectedSomeValue\n            | ErrorCode::InvalidEscape\n            | ErrorCode::InvalidNumber\n            | ErrorCode::NumberOutOfRange\n            | ErrorCode::InvalidUnicodeCodePoint\n            | ErrorCode::ControlCharacterWhileParsingString\n            | ErrorCode::KeyMustBeAString\n            | ErrorCode::LoneLeadingSurrogateInHexEscape\n            | ErrorCode::TrailingComma\n            | ErrorCode::TrailingCharacters\n            | ErrorCode::UnexpectedEndOfHexEscape\n            | ErrorCode::RecursionLimitExceeded => Category::Syntax,\n        }\n    }\n\n    /// Returns true if this error was caused by a failure to read or write\n    /// bytes on an IO stream.\n    pub fn is_io(&self) -> bool {\n        self.classify() == Category::Io\n    }\n\n    /// Returns true if this error was caused by input that was not\n    /// syntactically valid JSON.\n    pub fn is_syntax(&self) -> bool {\n        self.classify() == Category::Syntax\n    }\n\n    /// Returns true if this error was caused by input data that was\n    /// semantically incorrect.\n    ///\n    /// For example, JSON containing a number is semantically incorrect when the\n    /// type being deserialized into holds a String.\n    pub fn is_data(&self) -> bool {\n        self.classify() == Category::Data\n    }\n\n    /// Returns true if this error was caused by prematurely reaching the end of\n    /// the input data.\n    ///\n    /// Callers that process streaming input may be interested in retrying the\n    /// deserialization once more data is available.\n    pub fn is_eof(&self) -> bool {\n        self.classify() == Category::Eof\n    }\n}","impl de::Error for Error {\n    #[cold]\n    fn custom<T: Display>(msg: T) -> Error {\n        make_error(msg.to_string())\n    }\n\n    #[cold]\n    fn invalid_type(unexp: de::Unexpected, exp: &dyn de::Expected) -> Self {\n        if let de::Unexpected::Unit = unexp {\n            Error::custom(format_args!(\"invalid type: null, expected {}\", exp))\n        } else {\n            Error::custom(format_args!(\"invalid type: {}, expected {}\", unexp, exp))\n        }\n    }\n}","impl ser::Error for Error {\n    #[cold]\n    fn custom<T: Display>(msg: T) -> Error {\n        make_error(msg.to_string())\n    }\n}","impl serde::de::StdError for Error {\n    #[cfg(feature = \"std\")]\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n        match &self.err.code {\n            ErrorCode::Io(err) => err.source(),\n            _ => None,\n        }\n    }\n}"],"error::ErrorCode":["impl Display for ErrorCode {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            ErrorCode::Message(msg) => f.write_str(msg),\n            ErrorCode::Io(err) => Display::fmt(err, f),\n            ErrorCode::EofWhileParsingList => f.write_str(\"EOF while parsing a list\"),\n            ErrorCode::EofWhileParsingObject => f.write_str(\"EOF while parsing an object\"),\n            ErrorCode::EofWhileParsingString => f.write_str(\"EOF while parsing a string\"),\n            ErrorCode::EofWhileParsingValue => f.write_str(\"EOF while parsing a value\"),\n            ErrorCode::ExpectedColon => f.write_str(\"expected `:`\"),\n            ErrorCode::ExpectedListCommaOrEnd => f.write_str(\"expected `,` or `]`\"),\n            ErrorCode::ExpectedObjectCommaOrEnd => f.write_str(\"expected `,` or `}`\"),\n            ErrorCode::ExpectedSomeIdent => f.write_str(\"expected ident\"),\n            ErrorCode::ExpectedSomeValue => f.write_str(\"expected value\"),\n            ErrorCode::InvalidEscape => f.write_str(\"invalid escape\"),\n            ErrorCode::InvalidNumber => f.write_str(\"invalid number\"),\n            ErrorCode::NumberOutOfRange => f.write_str(\"number out of range\"),\n            ErrorCode::InvalidUnicodeCodePoint => f.write_str(\"invalid unicode code point\"),\n            ErrorCode::ControlCharacterWhileParsingString => {\n                f.write_str(\"control character (\\\\u0000-\\\\u001F) found while parsing a string\")\n            }\n            ErrorCode::KeyMustBeAString => f.write_str(\"key must be a string\"),\n            ErrorCode::LoneLeadingSurrogateInHexEscape => {\n                f.write_str(\"lone leading surrogate in hex escape\")\n            }\n            ErrorCode::TrailingComma => f.write_str(\"trailing comma\"),\n            ErrorCode::TrailingCharacters => f.write_str(\"trailing characters\"),\n            ErrorCode::UnexpectedEndOfHexEscape => f.write_str(\"unexpected end of hex escape\"),\n            ErrorCode::RecursionLimitExceeded => f.write_str(\"recursion limit exceeded\"),\n        }\n    }\n}"],"error::ErrorImpl":["impl Display for ErrorImpl {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if self.line == 0 {\n            Display::fmt(&self.code, f)\n        } else {\n            write!(\n                f,\n                \"{} at line {} column {}\",\n                self.code, self.line, self.column\n            )\n        }\n    }\n}"],"iter::LineColIterator":["impl<I> Iterator for LineColIterator<I>\nwhere\n    I: Iterator<Item = io::Result<u8>>,\n{\n    type Item = io::Result<u8>;\n\n    fn next(&mut self) -> Option<io::Result<u8>> {\n        match self.iter.next() {\n            None => None,\n            Some(Ok(b'\\n')) => {\n                self.start_of_line += self.col + 1;\n                self.line += 1;\n                self.col = 0;\n                Some(Ok(b'\\n'))\n            }\n            Some(Ok(c)) => {\n                self.col += 1;\n                Some(Ok(c))\n            }\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }\n}","impl<I> LineColIterator<I>\nwhere\n    I: Iterator<Item = io::Result<u8>>,\n{\n    pub fn new(iter: I) -> LineColIterator<I> {\n        LineColIterator {\n            iter,\n            line: 1,\n            col: 0,\n            start_of_line: 0,\n        }\n    }\n\n    pub fn line(&self) -> usize {\n        self.line\n    }\n\n    pub fn col(&self) -> usize {\n        self.col\n    }\n\n    pub fn byte_offset(&self) -> usize {\n        self.start_of_line + self.col\n    }\n}"],"map::Entry":["impl<'a> Entry<'a> {\n    /// Returns a reference to this entry's key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut map = serde_json::Map::new();\n    /// assert_eq!(map.entry(\"serde\").key(), &\"serde\");\n    /// ```\n    pub fn key(&self) -> &String {\n        match self {\n            Entry::Vacant(e) => e.key(),\n            Entry::Occupied(e) => e.key(),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the default if empty, and\n    /// returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut map = serde_json::Map::new();\n    /// map.entry(\"serde\").or_insert(json!(12));\n    ///\n    /// assert_eq!(map[\"serde\"], 12);\n    /// ```\n    pub fn or_insert(self, default: Value) -> &'a mut Value {\n        match self {\n            Entry::Vacant(entry) => entry.insert(default),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }\n\n    /// Ensures a value is in the entry by inserting the result of the default\n    /// function if empty, and returns a mutable reference to the value in the\n    /// entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut map = serde_json::Map::new();\n    /// map.entry(\"serde\").or_insert_with(|| json!(\"hoho\"));\n    ///\n    /// assert_eq!(map[\"serde\"], \"hoho\".to_owned());\n    /// ```\n    pub fn or_insert_with<F>(self, default: F) -> &'a mut Value\n    where\n        F: FnOnce() -> Value,\n    {\n        match self {\n            Entry::Vacant(entry) => entry.insert(default()),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut map = serde_json::Map::new();\n    /// map.entry(\"serde\")\n    ///     .and_modify(|e| *e = json!(\"rust\"))\n    ///     .or_insert(json!(\"cpp\"));\n    ///\n    /// assert_eq!(map[\"serde\"], \"cpp\");\n    ///\n    /// map.entry(\"serde\")\n    ///     .and_modify(|e| *e = json!(\"rust\"))\n    ///     .or_insert(json!(\"cpp\"));\n    ///\n    /// assert_eq!(map[\"serde\"], \"rust\");\n    /// ```\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut Value),\n    {\n        match self {\n            Entry::Occupied(mut entry) => {\n                f(entry.get_mut());\n                Entry::Occupied(entry)\n            }\n            Entry::Vacant(entry) => Entry::Vacant(entry),\n        }\n    }\n}"],"map::IntoIter":["impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }","impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }","impl $($generics)* FusedIterator for $name $($generics)* {}","impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"],"map::Iter":["impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }","impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }","impl $($generics)* FusedIterator for $name $($generics)* {}","impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"],"map::IterMut":["impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }","impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }","impl $($generics)* FusedIterator for $name $($generics)* {}","impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"],"map::Keys":["impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }","impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }","impl $($generics)* FusedIterator for $name $($generics)* {}","impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"],"map::Map":["impl Clone for Map<String, Value> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Map {\n            map: self.map.clone(),\n        }\n    }\n\n    #[inline]\n    fn clone_from(&mut self, source: &Self) {\n        self.map.clone_from(&source.map);\n    }\n}","impl Debug for Map<String, Value> {\n    #[inline]\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        self.map.fmt(formatter)\n    }\n}","impl Default for Map<String, Value> {\n    #[inline]\n    fn default() -> Self {\n        Map {\n            map: MapImpl::new(),\n        }\n    }\n}","impl Eq for Map<String, Value> {}","impl Extend<(String, Value)> for Map<String, Value> {\n    fn extend<T>(&mut self, iter: T)\n    where\n        T: IntoIterator<Item = (String, Value)>,\n    {\n        self.map.extend(iter);\n    }\n}","impl FromIterator<(String, Value)> for Map<String, Value> {\n    fn from_iter<T>(iter: T) -> Self\n    where\n        T: IntoIterator<Item = (String, Value)>,\n    {\n        Map {\n            map: FromIterator::from_iter(iter),\n        }\n    }\n}","impl IntoIterator for Map<String, Value> {\n    type Item = (String, Value);\n    type IntoIter = IntoIter;\n    #[inline]\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter {\n            iter: self.map.into_iter(),\n        }\n    }\n}","impl Map<String, Value> {\n    /// Makes a new empty Map.\n    #[inline]\n    pub fn new() -> Self {\n        Map {\n            map: MapImpl::new(),\n        }\n    }\n\n    /// Makes a new empty Map with the given initial capacity.\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Self {\n        Map {\n            #[cfg(not(feature = \"preserve_order\"))]\n            map: {\n                // does not support with_capacity\n                let _ = capacity;\n                BTreeMap::new()\n            },\n            #[cfg(feature = \"preserve_order\")]\n            map: IndexMap::with_capacity(capacity),\n        }\n    }\n\n    /// Clears the map, removing all values.\n    #[inline]\n    pub fn clear(&mut self) {\n        self.map.clear();\n    }\n\n    /// Returns a reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get(key)\n    }\n\n    /// Returns true if the map contains a value for the specified key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.contains_key(key)\n    }\n\n    /// Returns a mutable reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get_mut(key)\n    }\n\n    /// Returns the key-value pair matching the given key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    #[cfg(any(feature = \"preserve_order\", not(no_btreemap_get_key_value)))]\n    pub fn get_key_value<Q>(&self, key: &Q) -> Option<(&String, &Value)>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        self.map.get_key_value(key)\n    }\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not have this key present, `None` is returned.\n    ///\n    /// If the map did have this key present, the value is updated, and the old\n    /// value is returned.\n    #[inline]\n    pub fn insert(&mut self, k: String, v: Value) -> Option<Value> {\n        self.map.insert(k, v)\n    }\n\n    /// Removes a key from the map, returning the value at the key if the key\n    /// was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    #[inline]\n    pub fn remove<Q>(&mut self, key: &Q) -> Option<Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        #[cfg(feature = \"preserve_order\")]\n        return self.map.swap_remove(key);\n        #[cfg(not(feature = \"preserve_order\"))]\n        return self.map.remove(key);\n    }\n\n    /// Removes a key from the map, returning the stored key and value if the\n    /// key was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    pub fn remove_entry<Q>(&mut self, key: &Q) -> Option<(String, Value)>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,\n    {\n        #[cfg(any(feature = \"preserve_order\", not(no_btreemap_remove_entry)))]\n        return self.map.remove_entry(key);\n        #[cfg(all(\n            not(feature = \"preserve_order\"),\n            no_btreemap_remove_entry,\n            not(no_btreemap_get_key_value),\n        ))]\n        {\n            let (key, _value) = self.map.get_key_value(key)?;\n            let key = key.clone();\n            let value = self.map.remove::<String>(&key)?;\n            Some((key, value))\n        }\n        #[cfg(all(\n            not(feature = \"preserve_order\"),\n            no_btreemap_remove_entry,\n            no_btreemap_get_key_value,\n        ))]\n        {\n            use core::ops::{Bound, RangeBounds};\n\n            struct Key<'a, Q: ?Sized>(&'a Q);\n\n            impl<'a, Q: ?Sized> RangeBounds<Q> for Key<'a, Q> {\n                fn start_bound(&self) -> Bound<&Q> {\n                    Bound::Included(self.0)\n                }\n                fn end_bound(&self) -> Bound<&Q> {\n                    Bound::Included(self.0)\n                }\n            }\n\n            let mut range = self.map.range(Key(key));\n            let (key, _value) = range.next()?;\n            let key = key.clone();\n            let value = self.map.remove::<String>(&key)?;\n            Some((key, value))\n        }\n    }\n\n    /// Moves all elements from other into self, leaving other empty.\n    #[inline]\n    pub fn append(&mut self, other: &mut Self) {\n        #[cfg(feature = \"preserve_order\")]\n        self.map\n            .extend(mem::replace(&mut other.map, MapImpl::default()));\n        #[cfg(not(feature = \"preserve_order\"))]\n        self.map.append(&mut other.map);\n    }\n\n    /// Gets the given key's corresponding entry in the map for in-place\n    /// manipulation.\n    pub fn entry<S>(&mut self, key: S) -> Entry\n    where\n        S: Into<String>,\n    {\n        #[cfg(not(feature = \"preserve_order\"))]\n        use alloc::collections::btree_map::Entry as EntryImpl;\n        #[cfg(feature = \"preserve_order\")]\n        use indexmap::map::Entry as EntryImpl;\n\n        match self.map.entry(key.into()) {\n            EntryImpl::Vacant(vacant) => Entry::Vacant(VacantEntry { vacant }),\n            EntryImpl::Occupied(occupied) => Entry::Occupied(OccupiedEntry { occupied }),\n        }\n    }\n\n    /// Returns the number of elements in the map.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.map.len()\n    }\n\n    /// Returns true if the map contains no elements.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.map.is_empty()\n    }\n\n    /// Gets an iterator over the entries of the map.\n    #[inline]\n    pub fn iter(&self) -> Iter {\n        Iter {\n            iter: self.map.iter(),\n        }\n    }\n\n    /// Gets a mutable iterator over the entries of the map.\n    #[inline]\n    pub fn iter_mut(&mut self) -> IterMut {\n        IterMut {\n            iter: self.map.iter_mut(),\n        }\n    }\n\n    /// Gets an iterator over the keys of the map.\n    #[inline]\n    pub fn keys(&self) -> Keys {\n        Keys {\n            iter: self.map.keys(),\n        }\n    }\n\n    /// Gets an iterator over the values of the map.\n    #[inline]\n    pub fn values(&self) -> Values {\n        Values {\n            iter: self.map.values(),\n        }\n    }\n\n    /// Gets an iterator over mutable values of the map.\n    #[inline]\n    pub fn values_mut(&mut self) -> ValuesMut {\n        ValuesMut {\n            iter: self.map.values_mut(),\n        }\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all pairs `(k, v)` such that `f(&k, &mut v)`\n    /// returns `false`.\n    #[cfg(not(no_btreemap_retain))]\n    #[inline]\n    pub fn retain<F>(&mut self, f: F)\n    where\n        F: FnMut(&String, &mut Value) -> bool,\n    {\n        self.map.retain(f);\n    }\n}","impl PartialEq for Map<String, Value> {\n    #[inline]\n    fn eq(&self, other: &Self) -> bool {\n        self.map.eq(&other.map)\n    }\n}","impl serde::ser::Serialize for Map<String, Value> {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::ser::Serializer,\n    {\n        use serde::ser::SerializeMap;\n        let mut map = tri!(serializer.serialize_map(Some(self.len())));\n        for (k, v) in self {\n            tri!(map.serialize_entry(k, v));\n        }\n        map.end()\n    }\n}","impl<'a, Q> ops::Index<&'a Q> for Map<String, Value>\nwhere\n    String: Borrow<Q>,\n    Q: ?Sized + Ord + Eq + Hash,\n{\n    type Output = Value;\n\n    fn index(&self, index: &Q) -> &Value {\n        self.map.index(index)\n    }\n}","impl<'a, Q> ops::IndexMut<&'a Q> for Map<String, Value>\nwhere\n    String: Borrow<Q>,\n    Q: ?Sized + Ord + Eq + Hash,\n{\n    fn index_mut(&mut self, index: &Q) -> &mut Value {\n        self.map.get_mut(index).expect(\"no entry found for key\")\n    }\n}","impl<'de> de::Deserialize<'de> for Map<String, Value> {\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,\n    {\n        struct Visitor;\n\n        impl<'de> de::Visitor<'de> for Visitor {\n            type Value = Map<String, Value>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a map\")\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,\n            {\n                Ok(Map::new())\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut values = Map::new();\n\n                while let Some((key, value)) = tri!(visitor.next_entry()) {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }\n        }\n\n        deserializer.deserialize_map(Visitor)\n    }\n}"],"map::OccupiedEntry":["impl<'a> OccupiedEntry<'a> {\n    /// Gets a reference to the key in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!(12));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(occupied) => {\n    ///         assert_eq!(occupied.key(), &\"serde\");\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn key(&self) -> &String {\n        self.occupied.key()\n    }\n\n    /// Gets a reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!(12));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(occupied) => {\n    ///         assert_eq!(occupied.get(), 12);\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn get(&self) -> &Value {\n        self.occupied.get()\n    }\n\n    /// Gets a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!([1, 2, 3]));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(mut occupied) => {\n    ///         occupied.get_mut().as_array_mut().unwrap().push(json!(4));\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    ///\n    /// assert_eq!(map[\"serde\"].as_array().unwrap().len(), 4);\n    /// ```\n    #[inline]\n    pub fn get_mut(&mut self) -> &mut Value {\n        self.occupied.get_mut()\n    }\n\n    /// Converts the entry into a mutable reference to its value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!([1, 2, 3]));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(mut occupied) => {\n    ///         occupied.into_mut().as_array_mut().unwrap().push(json!(4));\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    ///\n    /// assert_eq!(map[\"serde\"].as_array().unwrap().len(), 4);\n    /// ```\n    #[inline]\n    pub fn into_mut(self) -> &'a mut Value {\n        self.occupied.into_mut()\n    }\n\n    /// Sets the value of the entry with the `OccupiedEntry`'s key, and returns\n    /// the entry's old value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!(12));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(mut occupied) => {\n    ///         assert_eq!(occupied.insert(json!(13)), 12);\n    ///         assert_eq!(occupied.get(), 13);\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn insert(&mut self, value: Value) -> Value {\n        self.occupied.insert(value)\n    }\n\n    /// Takes the value of the entry out of the map, and returns it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    /// map.insert(\"serde\".to_owned(), json!(12));\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Occupied(occupied) => {\n    ///         assert_eq!(occupied.remove(), 12);\n    ///     }\n    ///     Entry::Vacant(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn remove(self) -> Value {\n        #[cfg(feature = \"preserve_order\")]\n        return self.occupied.swap_remove();\n        #[cfg(not(feature = \"preserve_order\"))]\n        return self.occupied.remove();\n    }\n}"],"map::VacantEntry":["impl<'a> VacantEntry<'a> {\n    /// Gets a reference to the key that would be used when inserting a value\n    /// through the VacantEntry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Vacant(vacant) => {\n    ///         assert_eq!(vacant.key(), &\"serde\");\n    ///     }\n    ///     Entry::Occupied(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn key(&self) -> &String {\n        self.vacant.key()\n    }\n\n    /// Sets the value of the entry with the VacantEntry's key, and returns a\n    /// mutable reference to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// use serde_json::map::Entry;\n    ///\n    /// let mut map = serde_json::Map::new();\n    ///\n    /// match map.entry(\"serde\") {\n    ///     Entry::Vacant(vacant) => {\n    ///         vacant.insert(json!(\"hoho\"));\n    ///     }\n    ///     Entry::Occupied(_) => unimplemented!(),\n    /// }\n    /// ```\n    #[inline]\n    pub fn insert(self, value: Value) -> &'a mut Value {\n        self.vacant.insert(value)\n    }\n}"],"map::Values":["impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }","impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }","impl $($generics)* FusedIterator for $name $($generics)* {}","impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"],"map::ValuesMut":["impl $($generics)* DoubleEndedIterator for $name $($generics)* {\n            #[inline]\n            fn next_back(&mut self) -> Option<Self::Item> {\n                self.iter.next_back()\n            }\n        }","impl $($generics)* ExactSizeIterator for $name $($generics)* {\n            #[inline]\n            fn len(&self) -> usize {\n                self.iter.len()\n            }\n        }","impl $($generics)* FusedIterator for $name $($generics)* {}","impl $($generics)* Iterator for $name $($generics)* {\n            type Item = $item;\n            #[inline]\n            fn next(&mut self) -> Option<Self::Item> {\n                self.iter.next()\n            }\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.iter.size_hint()\n            }\n        }"],"number::N":["Clone","Copy","impl Eq for N {}","impl Hash for N {\n    fn hash<H: Hasher>(&self, h: &mut H) {\n        match *self {\n            N::PosInt(i) => i.hash(h),\n            N::NegInt(i) => i.hash(h),\n            N::Float(f) => {\n                if f == 0.0f64 {\n                    // There are 2 zero representations, +0 and -0, which\n                    // compare equal but have different bits. We use the +0 hash\n                    // for both so that hash(+0) == hash(-0).\n                    0.0f64.to_bits().hash(h);\n                } else {\n                    f.to_bits().hash(h);\n                }\n            }\n        }\n    }\n}","impl PartialEq for N {\n    fn eq(&self, other: &Self) -> bool {\n        match (self, other) {\n            (N::PosInt(a), N::PosInt(b)) => a == b,\n            (N::NegInt(a), N::NegInt(b)) => a == b,\n            (N::Float(a), N::Float(b)) => a == b,\n            _ => false,\n        }\n    }\n}"],"number::Number":["Clone","Eq","Hash","PartialEq","impl Debug for Number {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        write!(formatter, \"Number({})\", self)\n    }\n}","impl Display for Number {\n    #[cfg(not(feature = \"arbitrary_precision\"))]\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        match self.n {\n            N::PosInt(u) => formatter.write_str(itoa::Buffer::new().format(u)),\n            N::NegInt(i) => formatter.write_str(itoa::Buffer::new().format(i)),\n            N::Float(f) => formatter.write_str(ryu::Buffer::new().format_finite(f)),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        Display::fmt(&self.n, formatter)\n    }\n}","impl From<$ty> for Number {\n                #[inline]\n                fn from(i: $ty) -> Self {\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        {\n                            if i < 0 {\n                                N::NegInt(i as i64)\n                            } else {\n                                N::PosInt(i as u64)\n                            }\n                        }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(i).to_owned()\n                        }\n                    };\n                    Number { n }\n                }\n            }","impl From<$ty> for Number {\n                #[inline]\n                fn from(u: $ty) -> Self {\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        { N::PosInt(u as u64) }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(u).to_owned()\n                        }\n                    };\n                    Number { n }\n                }\n            }","impl From<ParserNumber> for Number {\n    fn from(value: ParserNumber) -> Self {\n        let n = match value {\n            ParserNumber::F64(f) => {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::Float(f)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    f.to_string()\n                }\n            }\n            ParserNumber::U64(u) => {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::PosInt(u)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    u.to_string()\n                }\n            }\n            ParserNumber::I64(i) => {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::NegInt(i)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    i.to_string()\n                }\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            ParserNumber::String(s) => s,\n        };\n        Number { n }\n    }\n}","impl FromStr for Number {\n    type Err = Error;\n\n    fn from_str(s: &str) -> result::Result<Self, Self::Err> {\n        Deserializer::from_str(s)\n            .parse_any_signed_number()\n            .map(Into::into)\n    }\n}","impl Number {\n    #[cfg(not(feature = \"arbitrary_precision\"))]\n    #[cold]\n    pub(crate) fn unexpected(&self) -> Unexpected {\n        match self.n {\n            N::PosInt(u) => Unexpected::Unsigned(u),\n            N::NegInt(i) => Unexpected::Signed(i),\n            N::Float(f) => Unexpected::Float(f),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    #[cold]\n    pub(crate) fn unexpected(&self) -> Unexpected {\n        Unexpected::Other(\"number\")\n    }\n}","impl Number {\n    /// Returns true if the `Number` is an integer between `i64::MIN` and\n    /// `i64::MAX`.\n    ///\n    /// For any Number on which `is_i64` returns true, `as_i64` is guaranteed to\n    /// return the integer value.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let big = i64::max_value() as u64 + 10;\n    /// let v = json!({ \"a\": 64, \"b\": big, \"c\": 256.0 });\n    ///\n    /// assert!(v[\"a\"].is_i64());\n    ///\n    /// // Greater than i64::MAX.\n    /// assert!(!v[\"b\"].is_i64());\n    ///\n    /// // Numbers with a decimal point are not considered integers.\n    /// assert!(!v[\"c\"].is_i64());\n    /// ```\n    #[inline]\n    pub fn is_i64(&self) -> bool {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(v) => v <= i64::max_value() as u64,\n            N::NegInt(_) => true,\n            N::Float(_) => false,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.as_i64().is_some()\n    }\n\n    /// Returns true if the `Number` is an integer between zero and `u64::MAX`.\n    ///\n    /// For any Number on which `is_u64` returns true, `as_u64` is guaranteed to\n    /// return the integer value.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 64, \"b\": -64, \"c\": 256.0 });\n    ///\n    /// assert!(v[\"a\"].is_u64());\n    ///\n    /// // Negative integer.\n    /// assert!(!v[\"b\"].is_u64());\n    ///\n    /// // Numbers with a decimal point are not considered integers.\n    /// assert!(!v[\"c\"].is_u64());\n    /// ```\n    #[inline]\n    pub fn is_u64(&self) -> bool {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(_) => true,\n            N::NegInt(_) | N::Float(_) => false,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.as_u64().is_some()\n    }\n\n    /// Returns true if the `Number` can be represented by f64.\n    ///\n    /// For any Number on which `is_f64` returns true, `as_f64` is guaranteed to\n    /// return the floating point value.\n    ///\n    /// Currently this function returns true if and only if both `is_i64` and\n    /// `is_u64` return false but this is not a guarantee in the future.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 256.0, \"b\": 64, \"c\": -64 });\n    ///\n    /// assert!(v[\"a\"].is_f64());\n    ///\n    /// // Integers.\n    /// assert!(!v[\"b\"].is_f64());\n    /// assert!(!v[\"c\"].is_f64());\n    /// ```\n    #[inline]\n    pub fn is_f64(&self) -> bool {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::Float(_) => true,\n            N::PosInt(_) | N::NegInt(_) => false,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        {\n            for c in self.n.chars() {\n                if c == '.' || c == 'e' || c == 'E' {\n                    return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);\n                }\n            }\n            false\n        }\n    }\n\n    /// If the `Number` is an integer, represent it as i64 if possible. Returns\n    /// None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let big = i64::max_value() as u64 + 10;\n    /// let v = json!({ \"a\": 64, \"b\": big, \"c\": 256.0 });\n    ///\n    /// assert_eq!(v[\"a\"].as_i64(), Some(64));\n    /// assert_eq!(v[\"b\"].as_i64(), None);\n    /// assert_eq!(v[\"c\"].as_i64(), None);\n    /// ```\n    #[inline]\n    pub fn as_i64(&self) -> Option<i64> {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => {\n                if n <= i64::max_value() as u64 {\n                    Some(n as i64)\n                } else {\n                    None\n                }\n            }\n            N::NegInt(n) => Some(n),\n            N::Float(_) => None,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse().ok()\n    }\n\n    /// If the `Number` is an integer, represent it as u64 if possible. Returns\n    /// None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 64, \"b\": -64, \"c\": 256.0 });\n    ///\n    /// assert_eq!(v[\"a\"].as_u64(), Some(64));\n    /// assert_eq!(v[\"b\"].as_u64(), None);\n    /// assert_eq!(v[\"c\"].as_u64(), None);\n    /// ```\n    #[inline]\n    pub fn as_u64(&self) -> Option<u64> {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n),\n            N::NegInt(_) | N::Float(_) => None,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse().ok()\n    }\n\n    /// Represents the number as f64 if possible. Returns None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 256.0, \"b\": 64, \"c\": -64 });\n    ///\n    /// assert_eq!(v[\"a\"].as_f64(), Some(256.0));\n    /// assert_eq!(v[\"b\"].as_f64(), Some(64.0));\n    /// assert_eq!(v[\"c\"].as_f64(), Some(-64.0));\n    /// ```\n    #[inline]\n    pub fn as_f64(&self) -> Option<f64> {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n as f64),\n            N::NegInt(n) => Some(n as f64),\n            N::Float(n) => Some(n),\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse::<f64>().ok().filter(|float| float.is_finite())\n    }\n\n    /// Converts a finite `f64` to a `Number`. Infinite or NaN values are not JSON\n    /// numbers.\n    ///\n    /// ```\n    /// # use std::f64;\n    /// #\n    /// # use serde_json::Number;\n    /// #\n    /// assert!(Number::from_f64(256.0).is_some());\n    ///\n    /// assert!(Number::from_f64(f64::NAN).is_none());\n    /// ```\n    #[inline]\n    pub fn from_f64(f: f64) -> Option<Number> {\n        if f.is_finite() {\n            let n = {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::Float(f)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    ryu::Buffer::new().format_finite(f).to_owned()\n                }\n            };\n            Some(Number { n })\n        } else {\n            None\n        }\n    }\n\n    pub(crate) fn as_f32(&self) -> Option<f32> {\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n as f32),\n            N::NegInt(n) => Some(n as f32),\n            N::Float(n) => Some(n as f32),\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse::<f32>().ok().filter(|float| float.is_finite())\n    }\n\n    pub(crate) fn from_f32(f: f32) -> Option<Number> {\n        if f.is_finite() {\n            let n = {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::Float(f as f64)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    ryu::Buffer::new().format_finite(f).to_owned()\n                }\n            };\n            Some(Number { n })\n        } else {\n            None\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    /// Not public API. Only tests use this.\n    #[doc(hidden)]\n    #[inline]\n    pub fn from_string_unchecked(n: String) -> Self {\n        Number { n }\n    }\n}","impl Serialize for Number {\n    #[cfg(not(feature = \"arbitrary_precision\"))]\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match self.n {\n            N::PosInt(u) => serializer.serialize_u64(u),\n            N::NegInt(i) => serializer.serialize_i64(i),\n            N::Float(f) => serializer.serialize_f64(f),\n        }\n    }\n\n    #[cfg(feature = \"arbitrary_precision\")]\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use serde::ser::SerializeStruct;\n\n        let mut s = serializer.serialize_struct(TOKEN, 1)?;\n        s.serialize_field(TOKEN, &self.n)?;\n        s.end()\n    }\n}","impl<'de> Deserialize<'de> for Number {\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<Number, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct NumberVisitor;\n\n        impl<'de> Visitor<'de> for NumberVisitor {\n            type Value = Number;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a JSON number\")\n            }\n\n            #[inline]\n            fn visit_i64<E>(self, value: i64) -> Result<Number, E> {\n                Ok(value.into())\n            }\n\n            #[inline]\n            fn visit_u64<E>(self, value: u64) -> Result<Number, E> {\n                Ok(value.into())\n            }\n\n            #[inline]\n            fn visit_f64<E>(self, value: f64) -> Result<Number, E>\n            where\n                E: de::Error,\n            {\n                Number::from_f64(value).ok_or_else(|| de::Error::custom(\"not a JSON number\"))\n            }\n\n            #[cfg(feature = \"arbitrary_precision\")]\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Number, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let value = visitor.next_key::<NumberKey>()?;\n                if value.is_none() {\n                    return Err(de::Error::invalid_type(Unexpected::Map, &self));\n                }\n                let v: NumberFromString = visitor.next_value()?;\n                Ok(v.value)\n            }\n        }\n\n        deserializer.deserialize_any(NumberVisitor)\n    }\n}","impl<'de> Deserializer<'de> for Number {\n    type Error = Error;\n\n    deserialize_any!(owned);\n\n    deserialize_number!(deserialize_i8 => visit_i8);\n    deserialize_number!(deserialize_i16 => visit_i16);\n    deserialize_number!(deserialize_i32 => visit_i32);\n    deserialize_number!(deserialize_i64 => visit_i64);\n    deserialize_number!(deserialize_i128 => visit_i128);\n    deserialize_number!(deserialize_u8 => visit_u8);\n    deserialize_number!(deserialize_u16 => visit_u16);\n    deserialize_number!(deserialize_u32 => visit_u32);\n    deserialize_number!(deserialize_u64 => visit_u64);\n    deserialize_number!(deserialize_u128 => visit_u128);\n    deserialize_number!(deserialize_f32 => visit_f32);\n    deserialize_number!(deserialize_f64 => visit_f64);\n\n    forward_to_deserialize_any! {\n        bool char str string bytes byte_buf option unit unit_struct\n        newtype_struct seq tuple tuple_struct map struct enum identifier\n        ignored_any\n    }\n}"],"read::IoRead":["impl<'de, R> Read<'de> for IoRead<R>\nwhere\n    R: io::Read,\n{\n    #[inline]\n    fn next(&mut self) -> Result<Option<u8>> {\n        match self.ch.take() {\n            Some(ch) => {\n                #[cfg(feature = \"raw_value\")]\n                {\n                    if let Some(buf) = &mut self.raw_buffer {\n                        buf.push(ch);\n                    }\n                }\n                Ok(Some(ch))\n            }\n            None => match self.iter.next() {\n                Some(Err(err)) => Err(Error::io(err)),\n                Some(Ok(ch)) => {\n                    #[cfg(feature = \"raw_value\")]\n                    {\n                        if let Some(buf) = &mut self.raw_buffer {\n                            buf.push(ch);\n                        }\n                    }\n                    Ok(Some(ch))\n                }\n                None => Ok(None),\n            },\n        }\n    }\n\n    #[inline]\n    fn peek(&mut self) -> Result<Option<u8>> {\n        match self.ch {\n            Some(ch) => Ok(Some(ch)),\n            None => match self.iter.next() {\n                Some(Err(err)) => Err(Error::io(err)),\n                Some(Ok(ch)) => {\n                    self.ch = Some(ch);\n                    Ok(self.ch)\n                }\n                None => Ok(None),\n            },\n        }\n    }\n\n    #[cfg(not(feature = \"raw_value\"))]\n    #[inline]\n    fn discard(&mut self) {\n        self.ch = None;\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn discard(&mut self) {\n        if let Some(ch) = self.ch.take() {\n            if let Some(buf) = &mut self.raw_buffer {\n                buf.push(ch);\n            }\n        }\n    }\n\n    fn position(&self) -> Position {\n        Position {\n            line: self.iter.line(),\n            column: self.iter.col(),\n        }\n    }\n\n    fn peek_position(&self) -> Position {\n        // The LineColIterator updates its position during peek() so it has the\n        // right one here.\n        self.position()\n    }\n\n    fn byte_offset(&self) -> usize {\n        match self.ch {\n            Some(_) => self.iter.byte_offset() - 1,\n            None => self.iter.byte_offset(),\n        }\n    }\n\n    fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>> {\n        self.parse_str_bytes(scratch, true, as_str)\n            .map(Reference::Copied)\n    }\n\n    fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, [u8]>> {\n        self.parse_str_bytes(scratch, false, |_, bytes| Ok(bytes))\n            .map(Reference::Copied)\n    }\n\n    fn ignore_str(&mut self) -> Result<()> {\n        loop {\n            let ch = tri!(next_or_eof(self));\n            if !ESCAPE[ch as usize] {\n                continue;\n            }\n            match ch {\n                b'\"' => {\n                    return Ok(());\n                }\n                b'\\\\' => {\n                    tri!(ignore_escape(self));\n                }\n                _ => {\n                    return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                }\n            }\n        }\n    }\n\n    fn decode_hex_escape(&mut self) -> Result<u16> {\n        let mut n = 0;\n        for _ in 0..4 {\n            match decode_hex_val(tri!(next_or_eof(self))) {\n                None => return error(self, ErrorCode::InvalidEscape),\n                Some(val) => {\n                    n = (n << 4) + val;\n                }\n            }\n        }\n        Ok(n)\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn begin_raw_buffering(&mut self) {\n        self.raw_buffer = Some(Vec::new());\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn end_raw_buffering<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'de>,\n    {\n        let raw = self.raw_buffer.take().unwrap();\n        let raw = match String::from_utf8(raw) {\n            Ok(raw) => raw,\n            Err(_) => return error(self, ErrorCode::InvalidUnicodeCodePoint),\n        };\n        visitor.visit_map(OwnedRawDeserializer {\n            raw_value: Some(raw),\n        })\n    }\n\n    const should_early_return_if_failed: bool = true;\n\n    #[inline]\n    #[cold]\n    fn set_failed(&mut self, failed: &mut bool) {\n        *failed = true;\n    }\n}","impl<R> IoRead<R>\nwhere\n    R: io::Read,\n{\n    /// Create a JSON input source to read from a std::io input stream.\n    pub fn new(reader: R) -> Self {\n        IoRead {\n            iter: LineColIterator::new(reader.bytes()),\n            ch: None,\n            #[cfg(feature = \"raw_value\")]\n            raw_buffer: None,\n        }\n    }\n}","impl<R> IoRead<R>\nwhere\n    R: io::Read,\n{\n    fn parse_str_bytes<'s, T, F>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n        validate: bool,\n        result: F,\n    ) -> Result<T>\n    where\n        T: 's,\n        F: FnOnce(&'s Self, &'s [u8]) -> Result<T>,\n    {\n        loop {\n            let ch = tri!(next_or_eof(self));\n            if !ESCAPE[ch as usize] {\n                scratch.push(ch);\n                continue;\n            }\n            match ch {\n                b'\"' => {\n                    return result(self, scratch);\n                }\n                b'\\\\' => {\n                    tri!(parse_escape(self, validate, scratch));\n                }\n                _ => {\n                    if validate {\n                        return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                    }\n                    scratch.push(ch);\n                }\n            }\n        }\n    }\n}","impl<R> private::Sealed for IoRead<R> where R: io::Read {}"],"read::Reference":["impl<'b, 'c, T> Deref for Reference<'b, 'c, T>\nwhere\n    T: ?Sized + 'static,\n{\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        match *self {\n            Reference::Borrowed(b) => b,\n            Reference::Copied(c) => c,\n        }\n    }\n}"],"read::SliceRead":["impl<'a> Fused for SliceRead<'a> {}","impl<'a> Read<'a> for SliceRead<'a> {\n    #[inline]\n    fn next(&mut self) -> Result<Option<u8>> {\n        // `Ok(self.slice.get(self.index).map(|ch| { self.index += 1; *ch }))`\n        // is about 10% slower.\n        Ok(if self.index < self.slice.len() {\n            let ch = self.slice[self.index];\n            self.index += 1;\n            Some(ch)\n        } else {\n            None\n        })\n    }\n\n    #[inline]\n    fn peek(&mut self) -> Result<Option<u8>> {\n        // `Ok(self.slice.get(self.index).map(|ch| *ch))` is about 10% slower\n        // for some reason.\n        Ok(if self.index < self.slice.len() {\n            Some(self.slice[self.index])\n        } else {\n            None\n        })\n    }\n\n    #[inline]\n    fn discard(&mut self) {\n        self.index += 1;\n    }\n\n    fn position(&self) -> Position {\n        self.position_of_index(self.index)\n    }\n\n    fn peek_position(&self) -> Position {\n        // Cap it at slice.len() just in case the most recent call was next()\n        // and it returned the last byte.\n        self.position_of_index(cmp::min(self.slice.len(), self.index + 1))\n    }\n\n    fn byte_offset(&self) -> usize {\n        self.index\n    }\n\n    fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>> {\n        self.parse_str_bytes(scratch, true, as_str)\n    }\n\n    fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'a, 's, [u8]>> {\n        self.parse_str_bytes(scratch, false, |_, bytes| Ok(bytes))\n    }\n\n    fn ignore_str(&mut self) -> Result<()> {\n        loop {\n            while self.index < self.slice.len() && !ESCAPE[self.slice[self.index] as usize] {\n                self.index += 1;\n            }\n            if self.index == self.slice.len() {\n                return error(self, ErrorCode::EofWhileParsingString);\n            }\n            match self.slice[self.index] {\n                b'\"' => {\n                    self.index += 1;\n                    return Ok(());\n                }\n                b'\\\\' => {\n                    self.index += 1;\n                    tri!(ignore_escape(self));\n                }\n                _ => {\n                    return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                }\n            }\n        }\n    }\n\n    fn decode_hex_escape(&mut self) -> Result<u16> {\n        if self.index + 4 > self.slice.len() {\n            self.index = self.slice.len();\n            return error(self, ErrorCode::EofWhileParsingString);\n        }\n\n        let mut n = 0;\n        for _ in 0..4 {\n            let ch = decode_hex_val(self.slice[self.index]);\n            self.index += 1;\n            match ch {\n                None => return error(self, ErrorCode::InvalidEscape),\n                Some(val) => {\n                    n = (n << 4) + val;\n                }\n            }\n        }\n        Ok(n)\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn begin_raw_buffering(&mut self) {\n        self.raw_buffering_start_index = self.index;\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn end_raw_buffering<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'a>,\n    {\n        let raw = &self.slice[self.raw_buffering_start_index..self.index];\n        let raw = match str::from_utf8(raw) {\n            Ok(raw) => raw,\n            Err(_) => return error(self, ErrorCode::InvalidUnicodeCodePoint),\n        };\n        visitor.visit_map(BorrowedRawDeserializer {\n            raw_value: Some(raw),\n        })\n    }\n\n    const should_early_return_if_failed: bool = false;\n\n    #[inline]\n    #[cold]\n    fn set_failed(&mut self, _failed: &mut bool) {\n        self.slice = &self.slice[..self.index];\n    }\n}","impl<'a> SliceRead<'a> {\n    /// Create a JSON input source to read from a slice of bytes.\n    pub fn new(slice: &'a [u8]) -> Self {\n        SliceRead {\n            slice,\n            index: 0,\n            #[cfg(feature = \"raw_value\")]\n            raw_buffering_start_index: 0,\n        }\n    }\n\n    fn position_of_index(&self, i: usize) -> Position {\n        let mut position = Position { line: 1, column: 0 };\n        for ch in &self.slice[..i] {\n            match *ch {\n                b'\\n' => {\n                    position.line += 1;\n                    position.column = 0;\n                }\n                _ => {\n                    position.column += 1;\n                }\n            }\n        }\n        position\n    }\n\n    /// The big optimization here over IoRead is that if the string contains no\n    /// backslash escape sequences, the returned &str is a slice of the raw JSON\n    /// data so we avoid copying into the scratch space.\n    fn parse_str_bytes<'s, T, F>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n        validate: bool,\n        result: F,\n    ) -> Result<Reference<'a, 's, T>>\n    where\n        T: ?Sized + 's,\n        F: for<'f> FnOnce(&'s Self, &'f [u8]) -> Result<&'f T>,\n    {\n        // Index of the first byte not yet copied into the scratch space.\n        let mut start = self.index;\n\n        loop {\n            while self.index < self.slice.len() && !ESCAPE[self.slice[self.index] as usize] {\n                self.index += 1;\n            }\n            if self.index == self.slice.len() {\n                return error(self, ErrorCode::EofWhileParsingString);\n            }\n            match self.slice[self.index] {\n                b'\"' => {\n                    if scratch.is_empty() {\n                        // Fast path: return a slice of the raw JSON without any\n                        // copying.\n                        let borrowed = &self.slice[start..self.index];\n                        self.index += 1;\n                        return result(self, borrowed).map(Reference::Borrowed);\n                    } else {\n                        scratch.extend_from_slice(&self.slice[start..self.index]);\n                        self.index += 1;\n                        return result(self, scratch).map(Reference::Copied);\n                    }\n                }\n                b'\\\\' => {\n                    scratch.extend_from_slice(&self.slice[start..self.index]);\n                    self.index += 1;\n                    tri!(parse_escape(self, validate, scratch));\n                    start = self.index;\n                }\n                _ => {\n                    self.index += 1;\n                    if validate {\n                        return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                    }\n                }\n            }\n        }\n    }\n}","impl<'a> private::Sealed for SliceRead<'a> {}"],"read::StrRead":["impl<'a> Fused for StrRead<'a> {}","impl<'a> Read<'a> for StrRead<'a> {\n    #[inline]\n    fn next(&mut self) -> Result<Option<u8>> {\n        self.delegate.next()\n    }\n\n    #[inline]\n    fn peek(&mut self) -> Result<Option<u8>> {\n        self.delegate.peek()\n    }\n\n    #[inline]\n    fn discard(&mut self) {\n        self.delegate.discard();\n    }\n\n    fn position(&self) -> Position {\n        self.delegate.position()\n    }\n\n    fn peek_position(&self) -> Position {\n        self.delegate.peek_position()\n    }\n\n    fn byte_offset(&self) -> usize {\n        self.delegate.byte_offset()\n    }\n\n    fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>> {\n        self.delegate.parse_str_bytes(scratch, true, |_, bytes| {\n            // The deserialization input came in as &str with a UTF-8 guarantee,\n            // and the \\u-escapes are checked along the way, so don't need to\n            // check here.\n            Ok(unsafe { str::from_utf8_unchecked(bytes) })\n        })\n    }\n\n    fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'a, 's, [u8]>> {\n        self.delegate.parse_str_raw(scratch)\n    }\n\n    fn ignore_str(&mut self) -> Result<()> {\n        self.delegate.ignore_str()\n    }\n\n    fn decode_hex_escape(&mut self) -> Result<u16> {\n        self.delegate.decode_hex_escape()\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn begin_raw_buffering(&mut self) {\n        self.delegate.begin_raw_buffering();\n    }\n\n    #[cfg(feature = \"raw_value\")]\n    fn end_raw_buffering<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'a>,\n    {\n        let raw = &self.data[self.delegate.raw_buffering_start_index..self.delegate.index];\n        visitor.visit_map(BorrowedRawDeserializer {\n            raw_value: Some(raw),\n        })\n    }\n\n    const should_early_return_if_failed: bool = false;\n\n    #[inline]\n    #[cold]\n    fn set_failed(&mut self, failed: &mut bool) {\n        self.delegate.set_failed(failed);\n    }\n}","impl<'a> StrRead<'a> {\n    /// Create a JSON input source to read from a UTF-8 string.\n    pub fn new(s: &'a str) -> Self {\n        StrRead {\n            delegate: SliceRead::new(s.as_bytes()),\n            #[cfg(feature = \"raw_value\")]\n            data: s,\n        }\n    }\n}","impl<'a> private::Sealed for StrRead<'a> {}"],"ser::CharEscape":["impl CharEscape {\n    #[inline]\n    fn from_escape_table(escape: u8, byte: u8) -> CharEscape {\n        match escape {\n            self::BB => CharEscape::Backspace,\n            self::TT => CharEscape::Tab,\n            self::NN => CharEscape::LineFeed,\n            self::FF => CharEscape::FormFeed,\n            self::RR => CharEscape::CarriageReturn,\n            self::QU => CharEscape::Quote,\n            self::BS => CharEscape::ReverseSolidus,\n            self::UU => CharEscape::AsciiControl(byte),\n            _ => unreachable!(),\n        }\n    }\n}"],"ser::CompactFormatter":["Clone","Debug","impl Formatter for CompactFormatter {}"],"ser::Compound":["impl<'a, W, F> ser::SerializeMap for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_key<T>(&mut self, key: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            Compound::Map { ser, state } => {\n                tri!(ser\n                    .formatter\n                    .begin_object_key(&mut ser.writer, *state == State::First)\n                    .map_err(Error::io));\n                *state = State::Rest;\n\n                tri!(key.serialize(MapKeySerializer { ser: *ser }));\n\n                ser.formatter\n                    .end_object_key(&mut ser.writer)\n                    .map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n\n    #[inline]\n    fn serialize_value<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            Compound::Map { ser, .. } => {\n                tri!(ser\n                    .formatter\n                    .begin_object_value(&mut ser.writer)\n                    .map_err(Error::io));\n                tri!(value.serialize(&mut **ser));\n                ser.formatter\n                    .end_object_value(&mut ser.writer)\n                    .map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        match self {\n            Compound::Map { ser, state } => match state {\n                State::Empty => Ok(()),\n                _ => ser.formatter.end_object(&mut ser.writer).map_err(Error::io),\n            },\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n}","impl<'a, W, F> ser::SerializeSeq for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            Compound::Map { ser, state } => {\n                tri!(ser\n                    .formatter\n                    .begin_array_value(&mut ser.writer, *state == State::First)\n                    .map_err(Error::io));\n                *state = State::Rest;\n                tri!(value.serialize(&mut **ser));\n                ser.formatter\n                    .end_array_value(&mut ser.writer)\n                    .map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        match self {\n            Compound::Map { ser, state } => match state {\n                State::Empty => Ok(()),\n                _ => ser.formatter.end_array(&mut ser.writer).map_err(Error::io),\n            },\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n}","impl<'a, W, F> ser::SerializeStruct for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            Compound::Map { .. } => ser::SerializeMap::serialize_entry(self, key, value),\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { ser, .. } => {\n                if key == crate::number::TOKEN {\n                    value.serialize(NumberStrEmitter(ser))\n                } else {\n                    Err(invalid_number())\n                }\n            }\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { ser, .. } => {\n                if key == crate::raw::TOKEN {\n                    value.serialize(RawValueStrEmitter(ser))\n                } else {\n                    Err(invalid_raw_value())\n                }\n            }\n        }\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        match self {\n            Compound::Map { .. } => ser::SerializeMap::end(self),\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => Ok(()),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => Ok(()),\n        }\n    }\n}","impl<'a, W, F> ser::SerializeStructVariant for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match *self {\n            Compound::Map { .. } => ser::SerializeStruct::serialize_field(self, key, value),\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        match self {\n            Compound::Map { ser, state } => {\n                match state {\n                    State::Empty => {}\n                    _ => tri!(ser.formatter.end_object(&mut ser.writer).map_err(Error::io)),\n                }\n                tri!(ser\n                    .formatter\n                    .end_object_value(&mut ser.writer)\n                    .map_err(Error::io));\n                ser.formatter.end_object(&mut ser.writer).map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n}","impl<'a, W, F> ser::SerializeTuple for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        ser::SerializeSeq::end(self)\n    }\n}","impl<'a, W, F> ser::SerializeTupleStruct for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        ser::SerializeSeq::end(self)\n    }\n}","impl<'a, W, F> ser::SerializeTupleVariant for Compound<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    #[inline]\n    fn end(self) -> Result<()> {\n        match self {\n            Compound::Map { ser, state } => {\n                match state {\n                    State::Empty => {}\n                    _ => tri!(ser.formatter.end_array(&mut ser.writer).map_err(Error::io)),\n                }\n                tri!(ser\n                    .formatter\n                    .end_object_value(&mut ser.writer)\n                    .map_err(Error::io));\n                ser.formatter.end_object(&mut ser.writer).map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }\n}"],"ser::MapKeySerializer":["impl<'a, W, F> ser::Serializer for MapKeySerializer<'a, W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    type Ok = ();\n    type Error = Error;\n\n    #[inline]\n    fn serialize_str(self, value: &str) -> Result<()> {\n        self.ser.serialize_str(value)\n    }\n\n    #[inline]\n    fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<()> {\n        self.ser.serialize_str(variant)\n    }\n\n    #[inline]\n    fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        value.serialize(self)\n    }\n\n    type SerializeSeq = Impossible<(), Error>;\n    type SerializeTuple = Impossible<(), Error>;\n    type SerializeTupleStruct = Impossible<(), Error>;\n    type SerializeTupleVariant = Impossible<(), Error>;\n    type SerializeMap = Impossible<(), Error>;\n    type SerializeStruct = Impossible<(), Error>;\n    type SerializeStructVariant = Impossible<(), Error>;\n\n    fn serialize_bool(self, _value: bool) -> Result<()> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_i8(self, value: i8) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i8(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_i16(self, value: i16) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i16(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_i32(self, value: i32) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i32(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_i64(self, value: i64) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i64(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_i128(self, value: i128) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i128(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_u8(self, value: u8) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u8(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_u16(self, value: u16) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u16(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_u32(self, value: u32) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u32(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_u64(self, value: u64) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u64(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_u128(self, value: u128) -> Result<()> {\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u128(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }\n\n    fn serialize_f32(self, _value: f32) -> Result<()> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_f64(self, _value: f64) -> Result<()> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_char(self, value: char) -> Result<()> {\n        self.ser.serialize_str(&value.to_string())\n    }\n\n    fn serialize_bytes(self, _value: &[u8]) -> Result<()> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_unit(self) -> Result<()> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_unit_struct(self, _name: &'static str) -> Result<()> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _value: &T,\n    ) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_none(self) -> Result<()> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_some<T>(self, _value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant> {\n        Err(key_must_be_a_string())\n    }\n\n    fn collect_str<T>(self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Display,\n    {\n        self.ser.collect_str(value)\n    }\n}"],"ser::PrettyFormatter":["Clone","Debug","impl<'a> Default for PrettyFormatter<'a> {\n    fn default() -> Self {\n        PrettyFormatter::new()\n    }\n}","impl<'a> Formatter for PrettyFormatter<'a> {\n    #[inline]\n    fn begin_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        self.current_indent += 1;\n        self.has_value = false;\n        writer.write_all(b\"[\")\n    }\n\n    #[inline]\n    fn end_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        self.current_indent -= 1;\n\n        if self.has_value {\n            tri!(writer.write_all(b\"\\n\"));\n            tri!(indent(writer, self.current_indent, self.indent));\n        }\n\n        writer.write_all(b\"]\")\n    }\n\n    #[inline]\n    fn begin_array_value<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        tri!(writer.write_all(if first { b\"\\n\" } else { b\",\\n\" }));\n        indent(writer, self.current_indent, self.indent)\n    }\n\n    #[inline]\n    fn end_array_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        self.has_value = true;\n        Ok(())\n    }\n\n    #[inline]\n    fn begin_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        self.current_indent += 1;\n        self.has_value = false;\n        writer.write_all(b\"{\")\n    }\n\n    #[inline]\n    fn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        self.current_indent -= 1;\n\n        if self.has_value {\n            tri!(writer.write_all(b\"\\n\"));\n            tri!(indent(writer, self.current_indent, self.indent));\n        }\n\n        writer.write_all(b\"}\")\n    }\n\n    #[inline]\n    fn begin_object_key<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        tri!(writer.write_all(if first { b\"\\n\" } else { b\",\\n\" }));\n        indent(writer, self.current_indent, self.indent)\n    }\n\n    #[inline]\n    fn begin_object_value<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\": \")\n    }\n\n    #[inline]\n    fn end_object_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        self.has_value = true;\n        Ok(())\n    }\n}","impl<'a> PrettyFormatter<'a> {\n    /// Construct a pretty printer formatter that defaults to using two spaces for indentation.\n    pub fn new() -> Self {\n        PrettyFormatter::with_indent(b\"  \")\n    }\n\n    /// Construct a pretty printer formatter that uses the `indent` string for indentation.\n    pub fn with_indent(indent: &'a [u8]) -> Self {\n        PrettyFormatter {\n            current_indent: 0,\n            has_value: false,\n            indent,\n        }\n    }\n}"],"ser::Serializer":["impl<'a, W> Serializer<W, PrettyFormatter<'a>>\nwhere\n    W: io::Write,\n{\n    /// Creates a new JSON pretty print serializer.\n    #[inline]\n    pub fn pretty(writer: W) -> Self {\n        Serializer::with_formatter(writer, PrettyFormatter::new())\n    }\n}","impl<W, F> Serializer<W, F>\nwhere\n    W: io::Write,\n    F: Formatter,\n{\n    /// Creates a new JSON visitor whose output will be written to the writer\n    /// specified.\n    #[inline]\n    pub fn with_formatter(writer: W, formatter: F) -> Self {\n        Serializer { writer, formatter }\n    }\n\n    /// Unwrap the `Writer` from the `Serializer`.\n    #[inline]\n    pub fn into_inner(self) -> W {\n        self.writer\n    }\n}","impl<W> Serializer<W>\nwhere\n    W: io::Write,\n{\n    /// Creates a new JSON serializer.\n    #[inline]\n    pub fn new(writer: W) -> Self {\n        Serializer::with_formatter(writer, CompactFormatter)\n    }\n}"],"ser::State":["Eq","PartialEq"],"std::io::Error":["impl From<Error> for io::Error {\n    /// Convert a `serde_json::Error` into an `io::Error`.\n    ///\n    /// JSON syntax and data errors are turned into `InvalidData` IO errors.\n    /// EOF errors are turned into `UnexpectedEof` IO errors.\n    ///\n    /// ```\n    /// use std::io;\n    ///\n    /// enum MyError {\n    ///     Io(io::Error),\n    ///     Json(serde_json::Error),\n    /// }\n    ///\n    /// impl From<serde_json::Error> for MyError {\n    ///     fn from(err: serde_json::Error) -> MyError {\n    ///         use serde_json::error::Category;\n    ///         match err.classify() {\n    ///             Category::Io => {\n    ///                 MyError::Io(err.into())\n    ///             }\n    ///             Category::Syntax | Category::Data | Category::Eof => {\n    ///                 MyError::Json(err)\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn from(j: Error) -> Self {\n        if let ErrorCode::Io(err) = j.err.code {\n            err\n        } else {\n            match j.classify() {\n                Category::Io => unreachable!(),\n                Category::Syntax | Category::Data => io::Error::new(io::ErrorKind::InvalidData, j),\n                Category::Eof => io::Error::new(io::ErrorKind::UnexpectedEof, j),\n            }\n        }\n    }\n}"],"std::string::String":["impl Index for String {\n    fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value> {\n        self[..].index_into(v)\n    }\n    fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value> {\n        self[..].index_into_mut(v)\n    }\n    fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value {\n        self[..].index_or_insert(v)\n    }\n}","impl PartialEq<Value> for String {\n    fn eq(&self, other: &Value) -> bool {\n        eq_str(other, self.as_str())\n    }\n}","impl Sealed for alloc::string::String {}"],"value::Value":["Clone","Eq","PartialEq","impl Debug for Value {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            Value::Null => formatter.write_str(\"Null\"),\n            Value::Bool(boolean) => write!(formatter, \"Bool({})\", boolean),\n            Value::Number(number) => Debug::fmt(number, formatter),\n            Value::String(string) => write!(formatter, \"String({:?})\", string),\n            Value::Array(vec) => {\n                formatter.write_str(\"Array \")?;\n                Debug::fmt(vec, formatter)\n            }\n            Value::Object(map) => {\n                formatter.write_str(\"Object \")?;\n                Debug::fmt(map, formatter)\n            }\n        }\n    }\n}","impl Default for Value {\n    fn default() -> Value {\n        Value::Null\n    }\n}","impl Display for Value {\n    /// Display a JSON value as a string.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let json = json!({ \"city\": \"London\", \"street\": \"10 Downing Street\" });\n    ///\n    /// // Compact format:\n    /// //\n    /// // {\"city\":\"London\",\"street\":\"10 Downing Street\"}\n    /// let compact = format!(\"{}\", json);\n    /// assert_eq!(compact,\n    ///     \"{\\\"city\\\":\\\"London\\\",\\\"street\\\":\\\"10 Downing Street\\\"}\");\n    ///\n    /// // Pretty format:\n    /// //\n    /// // {\n    /// //   \"city\": \"London\",\n    /// //   \"street\": \"10 Downing Street\"\n    /// // }\n    /// let pretty = format!(\"{:#}\", json);\n    /// assert_eq!(pretty,\n    ///     \"{\\n  \\\"city\\\": \\\"London\\\",\\n  \\\"street\\\": \\\"10 Downing Street\\\"\\n}\");\n    /// ```\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        struct WriterFormatter<'a, 'b: 'a> {\n            inner: &'a mut fmt::Formatter<'b>,\n        }\n\n        impl<'a, 'b> io::Write for WriterFormatter<'a, 'b> {\n            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n                // Safety: the serializer below only emits valid utf8 when using\n                // the default formatter.\n                let s = unsafe { str::from_utf8_unchecked(buf) };\n                tri!(self.inner.write_str(s).map_err(io_error));\n                Ok(buf.len())\n            }\n\n            fn flush(&mut self) -> io::Result<()> {\n                Ok(())\n            }\n        }\n\n        fn io_error(_: fmt::Error) -> io::Error {\n            // Error value does not matter because Display impl just maps it\n            // back to fmt::Error.\n            io::Error::new(io::ErrorKind::Other, \"fmt error\")\n        }\n\n        let alternate = f.alternate();\n        let mut wr = WriterFormatter { inner: f };\n        if alternate {\n            // {:#}\n            super::ser::to_writer_pretty(&mut wr, self).map_err(|_| fmt::Error)\n        } else {\n            // {}\n            super::ser::to_writer(&mut wr, self).map_err(|_| fmt::Error)\n        }\n    }\n}","impl From<$ty> for Value {\n                fn from(n: $ty) -> Self {\n                    Value::Number(n.into())\n                }\n            }","impl From<()> for Value {\n    /// Convert `()` to `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let u = ();\n    /// let x: Value = u.into();\n    /// ```\n    fn from((): ()) -> Self {\n        Value::Null\n    }\n}","impl From<Map<String, Value>> for Value {\n    /// Convert map (with string keys) to `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::{Map, Value};\n    ///\n    /// let mut m = Map::new();\n    /// m.insert(\"Lorem\".to_string(), \"ipsum\".into());\n    /// let x: Value = m.into();\n    /// ```\n    fn from(f: Map<String, Value>) -> Self {\n        Value::Object(f)\n    }\n}","impl From<Number> for Value {\n    /// Convert `Number` to `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::{Number, Value};\n    ///\n    /// let n = Number::from(7);\n    /// let x: Value = n.into();\n    /// ```\n    fn from(f: Number) -> Self {\n        Value::Number(f)\n    }\n}","impl From<String> for Value {\n    /// Convert `String` to `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let s: String = \"lorem\".to_string();\n    /// let x: Value = s.into();\n    /// ```\n    fn from(f: String) -> Self {\n        Value::String(f)\n    }\n}","impl From<bool> for Value {\n    /// Convert boolean to `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let b = false;\n    /// let x: Value = b.into();\n    /// ```\n    fn from(f: bool) -> Self {\n        Value::Bool(f)\n    }\n}","impl From<f32> for Value {\n    /// Convert 32-bit floating point number to `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let f: f32 = 13.37;\n    /// let x: Value = f.into();\n    /// ```\n    fn from(f: f32) -> Self {\n        Number::from_f32(f).map_or(Value::Null, Value::Number)\n    }\n}","impl From<f64> for Value {\n    /// Convert 64-bit floating point number to `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let f: f64 = 13.37;\n    /// let x: Value = f.into();\n    /// ```\n    fn from(f: f64) -> Self {\n        Number::from_f64(f).map_or(Value::Null, Value::Number)\n    }\n}","impl FromStr for Value {\n    type Err = Error;\n    fn from_str(s: &str) -> Result<Value, Error> {\n        super::super::de::from_str(s)\n    }\n}","impl PartialEq<$ty> for Value {\n                fn eq(&self, other: &$ty) -> bool {\n                    $eq(self, *other as _)\n                }\n            }","impl PartialEq<String> for Value {\n    fn eq(&self, other: &String) -> bool {\n        eq_str(self, other.as_str())\n    }\n}","impl PartialEq<str> for Value {\n    fn eq(&self, other: &str) -> bool {\n        eq_str(self, other)\n    }\n}","impl Serialize for Value {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> result::Result<S::Ok, S::Error>\n    where\n        S: ::serde::Serializer,\n    {\n        match self {\n            Value::Null => serializer.serialize_unit(),\n            Value::Bool(b) => serializer.serialize_bool(*b),\n            Value::Number(n) => n.serialize(serializer),\n            Value::String(s) => serializer.serialize_str(s),\n            Value::Array(v) => v.serialize(serializer),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::Object(m) => {\n                use serde::ser::SerializeMap;\n                let mut map = tri!(serializer.serialize_map(Some(m.len())));\n                for (k, v) in m {\n                    tri!(map.serialize_entry(k, v));\n                }\n                map.end()\n            }\n        }\n    }\n}","impl Value {\n    #[cold]\n    fn invalid_type<E>(&self, exp: &dyn Expected) -> E\n    where\n        E: serde::de::Error,\n    {\n        serde::de::Error::invalid_type(self.unexpected(), exp)\n    }\n\n    #[cold]\n    fn unexpected(&self) -> Unexpected {\n        match self {\n            Value::Null => Unexpected::Unit,\n            Value::Bool(b) => Unexpected::Bool(*b),\n            Value::Number(n) => n.unexpected(),\n            Value::String(s) => Unexpected::Str(s),\n            Value::Array(_) => Unexpected::Seq,\n            Value::Object(_) => Unexpected::Map,\n        }\n    }\n}","impl Value {\n    /// Index into a JSON array or map. A string index can be used to access a\n    /// value in a map, and a usize index can be used to access an element of an\n    /// array.\n    ///\n    /// Returns `None` if the type of `self` does not match the type of the\n    /// index, for example if the index is a string and `self` is an array or a\n    /// number. Also returns `None` if the given key does not exist in the map\n    /// or the given index is not within the bounds of the array.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let object = json!({ \"A\": 65, \"B\": 66, \"C\": 67 });\n    /// assert_eq!(*object.get(\"A\").unwrap(), json!(65));\n    ///\n    /// let array = json!([ \"A\", \"B\", \"C\" ]);\n    /// assert_eq!(*array.get(2).unwrap(), json!(\"C\"));\n    ///\n    /// assert_eq!(array.get(\"A\"), None);\n    /// ```\n    ///\n    /// Square brackets can also be used to index into a value in a more concise\n    /// way. This returns `Value::Null` in cases where `get` would have returned\n    /// `None`.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let object = json!({\n    ///     \"A\": [\"a\", \"\", \"\"],\n    ///     \"B\": [\"b\", \"b\"],\n    ///     \"C\": [\"c\", \"\", \"\", \"\"],\n    /// });\n    /// assert_eq!(object[\"B\"][0], json!(\"b\"));\n    ///\n    /// assert_eq!(object[\"D\"], json!(null));\n    /// assert_eq!(object[0][\"x\"][\"y\"][\"z\"], json!(null));\n    /// ```\n    pub fn get<I: Index>(&self, index: I) -> Option<&Value> {\n        index.index_into(self)\n    }\n\n    /// Mutably index into a JSON array or map. A string index can be used to\n    /// access a value in a map, and a usize index can be used to access an\n    /// element of an array.\n    ///\n    /// Returns `None` if the type of `self` does not match the type of the\n    /// index, for example if the index is a string and `self` is an array or a\n    /// number. Also returns `None` if the given key does not exist in the map\n    /// or the given index is not within the bounds of the array.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut object = json!({ \"A\": 65, \"B\": 66, \"C\": 67 });\n    /// *object.get_mut(\"A\").unwrap() = json!(69);\n    ///\n    /// let mut array = json!([ \"A\", \"B\", \"C\" ]);\n    /// *array.get_mut(2).unwrap() = json!(\"D\");\n    /// ```\n    pub fn get_mut<I: Index>(&mut self, index: I) -> Option<&mut Value> {\n        index.index_into_mut(self)\n    }\n\n    /// Returns true if the `Value` is an Object. Returns false otherwise.\n    ///\n    /// For any Value on which `is_object` returns true, `as_object` and\n    /// `as_object_mut` are guaranteed to return the map representation of the\n    /// object.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let obj = json!({ \"a\": { \"nested\": true }, \"b\": [\"an\", \"array\"] });\n    ///\n    /// assert!(obj.is_object());\n    /// assert!(obj[\"a\"].is_object());\n    ///\n    /// // array, not an object\n    /// assert!(!obj[\"b\"].is_object());\n    /// ```\n    pub fn is_object(&self) -> bool {\n        self.as_object().is_some()\n    }\n\n    /// If the `Value` is an Object, returns the associated Map. Returns None\n    /// otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": { \"nested\": true }, \"b\": [\"an\", \"array\"] });\n    ///\n    /// // The length of `{\"nested\": true}` is 1 entry.\n    /// assert_eq!(v[\"a\"].as_object().unwrap().len(), 1);\n    ///\n    /// // The array `[\"an\", \"array\"]` is not an object.\n    /// assert_eq!(v[\"b\"].as_object(), None);\n    /// ```\n    pub fn as_object(&self) -> Option<&Map<String, Value>> {\n        match self {\n            Value::Object(map) => Some(map),\n            _ => None,\n        }\n    }\n\n    /// If the `Value` is an Object, returns the associated mutable Map.\n    /// Returns None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut v = json!({ \"a\": { \"nested\": true } });\n    ///\n    /// v[\"a\"].as_object_mut().unwrap().clear();\n    /// assert_eq!(v, json!({ \"a\": {} }));\n    /// ```\n    pub fn as_object_mut(&mut self) -> Option<&mut Map<String, Value>> {\n        match self {\n            Value::Object(map) => Some(map),\n            _ => None,\n        }\n    }\n\n    /// Returns true if the `Value` is an Array. Returns false otherwise.\n    ///\n    /// For any Value on which `is_array` returns true, `as_array` and\n    /// `as_array_mut` are guaranteed to return the vector representing the\n    /// array.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let obj = json!({ \"a\": [\"an\", \"array\"], \"b\": { \"an\": \"object\" } });\n    ///\n    /// assert!(obj[\"a\"].is_array());\n    ///\n    /// // an object, not an array\n    /// assert!(!obj[\"b\"].is_array());\n    /// ```\n    pub fn is_array(&self) -> bool {\n        self.as_array().is_some()\n    }\n\n    /// If the `Value` is an Array, returns the associated vector. Returns None\n    /// otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": [\"an\", \"array\"], \"b\": { \"an\": \"object\" } });\n    ///\n    /// // The length of `[\"an\", \"array\"]` is 2 elements.\n    /// assert_eq!(v[\"a\"].as_array().unwrap().len(), 2);\n    ///\n    /// // The object `{\"an\": \"object\"}` is not an array.\n    /// assert_eq!(v[\"b\"].as_array(), None);\n    /// ```\n    pub fn as_array(&self) -> Option<&Vec<Value>> {\n        match self {\n            Value::Array(array) => Some(array),\n            _ => None,\n        }\n    }\n\n    /// If the `Value` is an Array, returns the associated mutable vector.\n    /// Returns None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut v = json!({ \"a\": [\"an\", \"array\"] });\n    ///\n    /// v[\"a\"].as_array_mut().unwrap().clear();\n    /// assert_eq!(v, json!({ \"a\": [] }));\n    /// ```\n    pub fn as_array_mut(&mut self) -> Option<&mut Vec<Value>> {\n        match self {\n            Value::Array(list) => Some(list),\n            _ => None,\n        }\n    }\n\n    /// Returns true if the `Value` is a String. Returns false otherwise.\n    ///\n    /// For any Value on which `is_string` returns true, `as_str` is guaranteed\n    /// to return the string slice.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": \"some string\", \"b\": false });\n    ///\n    /// assert!(v[\"a\"].is_string());\n    ///\n    /// // The boolean `false` is not a string.\n    /// assert!(!v[\"b\"].is_string());\n    /// ```\n    pub fn is_string(&self) -> bool {\n        self.as_str().is_some()\n    }\n\n    /// If the `Value` is a String, returns the associated str. Returns None\n    /// otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": \"some string\", \"b\": false });\n    ///\n    /// assert_eq!(v[\"a\"].as_str(), Some(\"some string\"));\n    ///\n    /// // The boolean `false` is not a string.\n    /// assert_eq!(v[\"b\"].as_str(), None);\n    ///\n    /// // JSON values are printed in JSON representation, so strings are in quotes.\n    /// //\n    /// //    The value is: \"some string\"\n    /// println!(\"The value is: {}\", v[\"a\"]);\n    ///\n    /// // Rust strings are printed without quotes.\n    /// //\n    /// //    The value is: some string\n    /// println!(\"The value is: {}\", v[\"a\"].as_str().unwrap());\n    /// ```\n    pub fn as_str(&self) -> Option<&str> {\n        match self {\n            Value::String(s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Returns true if the `Value` is a Number. Returns false otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 1, \"b\": \"2\" });\n    ///\n    /// assert!(v[\"a\"].is_number());\n    ///\n    /// // The string `\"2\"` is a string, not a number.\n    /// assert!(!v[\"b\"].is_number());\n    /// ```\n    pub fn is_number(&self) -> bool {\n        match *self {\n            Value::Number(_) => true,\n            _ => false,\n        }\n    }\n\n    /// Returns true if the `Value` is an integer between `i64::MIN` and\n    /// `i64::MAX`.\n    ///\n    /// For any Value on which `is_i64` returns true, `as_i64` is guaranteed to\n    /// return the integer value.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let big = i64::max_value() as u64 + 10;\n    /// let v = json!({ \"a\": 64, \"b\": big, \"c\": 256.0 });\n    ///\n    /// assert!(v[\"a\"].is_i64());\n    ///\n    /// // Greater than i64::MAX.\n    /// assert!(!v[\"b\"].is_i64());\n    ///\n    /// // Numbers with a decimal point are not considered integers.\n    /// assert!(!v[\"c\"].is_i64());\n    /// ```\n    pub fn is_i64(&self) -> bool {\n        match self {\n            Value::Number(n) => n.is_i64(),\n            _ => false,\n        }\n    }\n\n    /// Returns true if the `Value` is an integer between zero and `u64::MAX`.\n    ///\n    /// For any Value on which `is_u64` returns true, `as_u64` is guaranteed to\n    /// return the integer value.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 64, \"b\": -64, \"c\": 256.0 });\n    ///\n    /// assert!(v[\"a\"].is_u64());\n    ///\n    /// // Negative integer.\n    /// assert!(!v[\"b\"].is_u64());\n    ///\n    /// // Numbers with a decimal point are not considered integers.\n    /// assert!(!v[\"c\"].is_u64());\n    /// ```\n    pub fn is_u64(&self) -> bool {\n        match self {\n            Value::Number(n) => n.is_u64(),\n            _ => false,\n        }\n    }\n\n    /// Returns true if the `Value` is a number that can be represented by f64.\n    ///\n    /// For any Value on which `is_f64` returns true, `as_f64` is guaranteed to\n    /// return the floating point value.\n    ///\n    /// Currently this function returns true if and only if both `is_i64` and\n    /// `is_u64` return false but this is not a guarantee in the future.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 256.0, \"b\": 64, \"c\": -64 });\n    ///\n    /// assert!(v[\"a\"].is_f64());\n    ///\n    /// // Integers.\n    /// assert!(!v[\"b\"].is_f64());\n    /// assert!(!v[\"c\"].is_f64());\n    /// ```\n    pub fn is_f64(&self) -> bool {\n        match self {\n            Value::Number(n) => n.is_f64(),\n            _ => false,\n        }\n    }\n\n    /// If the `Value` is an integer, represent it as i64 if possible. Returns\n    /// None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let big = i64::max_value() as u64 + 10;\n    /// let v = json!({ \"a\": 64, \"b\": big, \"c\": 256.0 });\n    ///\n    /// assert_eq!(v[\"a\"].as_i64(), Some(64));\n    /// assert_eq!(v[\"b\"].as_i64(), None);\n    /// assert_eq!(v[\"c\"].as_i64(), None);\n    /// ```\n    pub fn as_i64(&self) -> Option<i64> {\n        match self {\n            Value::Number(n) => n.as_i64(),\n            _ => None,\n        }\n    }\n\n    /// If the `Value` is an integer, represent it as u64 if possible. Returns\n    /// None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 64, \"b\": -64, \"c\": 256.0 });\n    ///\n    /// assert_eq!(v[\"a\"].as_u64(), Some(64));\n    /// assert_eq!(v[\"b\"].as_u64(), None);\n    /// assert_eq!(v[\"c\"].as_u64(), None);\n    /// ```\n    pub fn as_u64(&self) -> Option<u64> {\n        match self {\n            Value::Number(n) => n.as_u64(),\n            _ => None,\n        }\n    }\n\n    /// If the `Value` is a number, represent it as f64 if possible. Returns\n    /// None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": 256.0, \"b\": 64, \"c\": -64 });\n    ///\n    /// assert_eq!(v[\"a\"].as_f64(), Some(256.0));\n    /// assert_eq!(v[\"b\"].as_f64(), Some(64.0));\n    /// assert_eq!(v[\"c\"].as_f64(), Some(-64.0));\n    /// ```\n    pub fn as_f64(&self) -> Option<f64> {\n        match self {\n            Value::Number(n) => n.as_f64(),\n            _ => None,\n        }\n    }\n\n    /// Returns true if the `Value` is a Boolean. Returns false otherwise.\n    ///\n    /// For any Value on which `is_boolean` returns true, `as_bool` is\n    /// guaranteed to return the boolean value.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": false, \"b\": \"false\" });\n    ///\n    /// assert!(v[\"a\"].is_boolean());\n    ///\n    /// // The string `\"false\"` is a string, not a boolean.\n    /// assert!(!v[\"b\"].is_boolean());\n    /// ```\n    pub fn is_boolean(&self) -> bool {\n        self.as_bool().is_some()\n    }\n\n    /// If the `Value` is a Boolean, returns the associated bool. Returns None\n    /// otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": false, \"b\": \"false\" });\n    ///\n    /// assert_eq!(v[\"a\"].as_bool(), Some(false));\n    ///\n    /// // The string `\"false\"` is a string, not a boolean.\n    /// assert_eq!(v[\"b\"].as_bool(), None);\n    /// ```\n    pub fn as_bool(&self) -> Option<bool> {\n        match *self {\n            Value::Bool(b) => Some(b),\n            _ => None,\n        }\n    }\n\n    /// Returns true if the `Value` is a Null. Returns false otherwise.\n    ///\n    /// For any Value on which `is_null` returns true, `as_null` is guaranteed\n    /// to return `Some(())`.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": null, \"b\": false });\n    ///\n    /// assert!(v[\"a\"].is_null());\n    ///\n    /// // The boolean `false` is not null.\n    /// assert!(!v[\"b\"].is_null());\n    /// ```\n    pub fn is_null(&self) -> bool {\n        self.as_null().is_some()\n    }\n\n    /// If the `Value` is a Null, returns (). Returns None otherwise.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"a\": null, \"b\": false });\n    ///\n    /// assert_eq!(v[\"a\"].as_null(), Some(()));\n    ///\n    /// // The boolean `false` is not null.\n    /// assert_eq!(v[\"b\"].as_null(), None);\n    /// ```\n    pub fn as_null(&self) -> Option<()> {\n        match *self {\n            Value::Null => Some(()),\n            _ => None,\n        }\n    }\n\n    /// Looks up a value by a JSON Pointer.\n    ///\n    /// JSON Pointer defines a string syntax for identifying a specific value\n    /// within a JavaScript Object Notation (JSON) document.\n    ///\n    /// A Pointer is a Unicode string with the reference tokens separated by `/`.\n    /// Inside tokens `/` is replaced by `~1` and `~` is replaced by `~0`. The\n    /// addressed value is returned and if there is no such value `None` is\n    /// returned.\n    ///\n    /// For more information read [RFC6901](https://tools.ietf.org/html/rfc6901).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let data = json!({\n    ///     \"x\": {\n    ///         \"y\": [\"z\", \"zz\"]\n    ///     }\n    /// });\n    ///\n    /// assert_eq!(data.pointer(\"/x/y/1\").unwrap(), &json!(\"zz\"));\n    /// assert_eq!(data.pointer(\"/a/b/c\"), None);\n    /// ```\n    pub fn pointer(&self, pointer: &str) -> Option<&Value> {\n        if pointer.is_empty() {\n            return Some(self);\n        }\n        if !pointer.starts_with('/') {\n            return None;\n        }\n        pointer\n            .split('/')\n            .skip(1)\n            .map(|x| x.replace(\"~1\", \"/\").replace(\"~0\", \"~\"))\n            .try_fold(self, |target, token| match target {\n                Value::Object(map) => map.get(&token),\n                Value::Array(list) => parse_index(&token).and_then(|x| list.get(x)),\n                _ => None,\n            })\n    }\n\n    /// Looks up a value by a JSON Pointer and returns a mutable reference to\n    /// that value.\n    ///\n    /// JSON Pointer defines a string syntax for identifying a specific value\n    /// within a JavaScript Object Notation (JSON) document.\n    ///\n    /// A Pointer is a Unicode string with the reference tokens separated by `/`.\n    /// Inside tokens `/` is replaced by `~1` and `~` is replaced by `~0`. The\n    /// addressed value is returned and if there is no such value `None` is\n    /// returned.\n    ///\n    /// For more information read [RFC6901](https://tools.ietf.org/html/rfc6901).\n    ///\n    /// # Example of Use\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// fn main() {\n    ///     let s = r#\"{\"x\": 1.0, \"y\": 2.0}\"#;\n    ///     let mut value: Value = serde_json::from_str(s).unwrap();\n    ///\n    ///     // Check value using read-only pointer\n    ///     assert_eq!(value.pointer(\"/x\"), Some(&1.0.into()));\n    ///     // Change value with direct assignment\n    ///     *value.pointer_mut(\"/x\").unwrap() = 1.5.into();\n    ///     // Check that new value was written\n    ///     assert_eq!(value.pointer(\"/x\"), Some(&1.5.into()));\n    ///     // Or change the value only if it exists\n    ///     value.pointer_mut(\"/x\").map(|v| *v = 1.5.into());\n    ///\n    ///     // \"Steal\" ownership of a value. Can replace with any valid Value.\n    ///     let old_x = value.pointer_mut(\"/x\").map(Value::take).unwrap();\n    ///     assert_eq!(old_x, 1.5);\n    ///     assert_eq!(value.pointer(\"/x\").unwrap(), &Value::Null);\n    /// }\n    /// ```\n    pub fn pointer_mut(&mut self, pointer: &str) -> Option<&mut Value> {\n        if pointer.is_empty() {\n            return Some(self);\n        }\n        if !pointer.starts_with('/') {\n            return None;\n        }\n        pointer\n            .split('/')\n            .skip(1)\n            .map(|x| x.replace(\"~1\", \"/\").replace(\"~0\", \"~\"))\n            .try_fold(self, |target, token| match target {\n                Value::Object(map) => map.get_mut(&token),\n                Value::Array(list) => parse_index(&token).and_then(move |x| list.get_mut(x)),\n                _ => None,\n            })\n    }\n\n    /// Takes the value out of the `Value`, leaving a `Null` in its place.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut v = json!({ \"x\": \"y\" });\n    /// assert_eq!(v[\"x\"].take(), json!(\"y\"));\n    /// assert_eq!(v, json!({ \"x\": null }));\n    /// ```\n    pub fn take(&mut self) -> Value {\n        mem::replace(self, Value::Null)\n    }\n}","impl<'a, T: Clone + Into<Value>> From<&'a [T]> for Value {\n    /// Convert a slice to `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let v: &[&str] = &[\"lorem\", \"ipsum\", \"dolor\"];\n    /// let x: Value = v.into();\n    /// ```\n    fn from(f: &'a [T]) -> Self {\n        Value::Array(f.iter().cloned().map(Into::into).collect())\n    }\n}","impl<'a> From<&'a str> for Value {\n    /// Convert string slice to `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let s: &str = \"lorem\";\n    /// let x: Value = s.into();\n    /// ```\n    fn from(f: &str) -> Self {\n        Value::String(f.to_string())\n    }\n}","impl<'a> From<Cow<'a, str>> for Value {\n    /// Convert copy-on-write string to `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    /// use std::borrow::Cow;\n    ///\n    /// let s: Cow<str> = Cow::Borrowed(\"lorem\");\n    /// let x: Value = s.into();\n    /// ```\n    ///\n    /// ```\n    /// use serde_json::Value;\n    /// use std::borrow::Cow;\n    ///\n    /// let s: Cow<str> = Cow::Owned(\"lorem\".to_string());\n    /// let x: Value = s.into();\n    /// ```\n    fn from(f: Cow<'a, str>) -> Self {\n        Value::String(f.into_owned())\n    }\n}","impl<'a> PartialEq<&'a str> for Value {\n    fn eq(&self, other: &&str) -> bool {\n        eq_str(self, *other)\n    }\n}","impl<'de> Deserialize<'de> for Value {\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<Value, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        struct ValueVisitor;\n\n        impl<'de> Visitor<'de> for ValueVisitor {\n            type Value = Value;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"any valid JSON value\")\n            }\n\n            #[inline]\n            fn visit_bool<E>(self, value: bool) -> Result<Value, E> {\n                Ok(Value::Bool(value))\n            }\n\n            #[inline]\n            fn visit_i64<E>(self, value: i64) -> Result<Value, E> {\n                Ok(Value::Number(value.into()))\n            }\n\n            #[inline]\n            fn visit_u64<E>(self, value: u64) -> Result<Value, E> {\n                Ok(Value::Number(value.into()))\n            }\n\n            #[inline]\n            fn visit_f64<E>(self, value: f64) -> Result<Value, E> {\n                Ok(Number::from_f64(value).map_or(Value::Null, Value::Number))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_str<E>(self, value: &str) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_string(String::from(value))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_string<E>(self, value: String) -> Result<Value, E> {\n                Ok(Value::String(value))\n            }\n\n            #[inline]\n            fn visit_none<E>(self) -> Result<Value, E> {\n                Ok(Value::Null)\n            }\n\n            #[inline]\n            fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: serde::Deserializer<'de>,\n            {\n                Deserialize::deserialize(deserializer)\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Value, E> {\n                Ok(Value::Null)\n            }\n\n            #[inline]\n            fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: SeqAccess<'de>,\n            {\n                let mut vec = Vec::new();\n\n                while let Some(elem) = tri!(visitor.next_element()) {\n                    vec.push(elem);\n                }\n\n                Ok(Value::Array(vec))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: MapAccess<'de>,\n            {\n                match visitor.next_key_seed(KeyClassifier)? {\n                    #[cfg(feature = \"arbitrary_precision\")]\n                    Some(KeyClass::Number) => {\n                        let number: NumberFromString = visitor.next_value()?;\n                        Ok(Value::Number(number.value))\n                    }\n                    #[cfg(feature = \"raw_value\")]\n                    Some(KeyClass::RawValue) => {\n                        let value = visitor.next_value_seed(crate::raw::BoxedFromString)?;\n                        crate::from_str(value.get()).map_err(de::Error::custom)\n                    }\n                    Some(KeyClass::Map(first_key)) => {\n                        let mut values = Map::new();\n\n                        values.insert(first_key, tri!(visitor.next_value()));\n                        while let Some((key, value)) = tri!(visitor.next_entry()) {\n                            values.insert(key, value);\n                        }\n\n                        Ok(Value::Object(values))\n                    }\n                    None => Ok(Value::Object(Map::new())),\n                }\n            }\n        }\n\n        deserializer.deserialize_any(ValueVisitor)\n    }\n}","impl<'de> IntoDeserializer<'de, Error> for Value {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        self\n    }\n}","impl<'de> serde::Deserializer<'de> for Value {\n    type Error = Error;\n\n    #[inline]\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Null => visitor.visit_unit(),\n            Value::Bool(v) => visitor.visit_bool(v),\n            Value::Number(n) => n.deserialize_any(visitor),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::String(v) => visitor.visit_string(v),\n            Value::Array(v) => visit_array(v, visitor),\n            Value::Object(v) => visit_object(v, visitor),\n        }\n    }\n\n    deserialize_number!(deserialize_i8);\n    deserialize_number!(deserialize_i16);\n    deserialize_number!(deserialize_i32);\n    deserialize_number!(deserialize_i64);\n    deserialize_number!(deserialize_i128);\n    deserialize_number!(deserialize_u8);\n    deserialize_number!(deserialize_u16);\n    deserialize_number!(deserialize_u32);\n    deserialize_number!(deserialize_u64);\n    deserialize_number!(deserialize_u128);\n    deserialize_number!(deserialize_f32);\n    deserialize_number!(deserialize_f64);\n\n    #[inline]\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Null => visitor.visit_none(),\n            _ => visitor.visit_some(self),\n        }\n    }\n\n    #[inline]\n    fn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        let (variant, value) = match self {\n            Value::Object(value) => {\n                let mut iter = value.into_iter();\n                let (variant, value) = match iter.next() {\n                    Some(v) => v,\n                    None => {\n                        return Err(serde::de::Error::invalid_value(\n                            Unexpected::Map,\n                            &\"map with a single key\",\n                        ));\n                    }\n                };\n                // enums are encoded in json as maps with a single key:value pair\n                if iter.next().is_some() {\n                    return Err(serde::de::Error::invalid_value(\n                        Unexpected::Map,\n                        &\"map with a single key\",\n                    ));\n                }\n                (variant, Some(value))\n            }\n            Value::String(variant) => (variant, None),\n            other => {\n                return Err(serde::de::Error::invalid_type(\n                    other.unexpected(),\n                    &\"string or map\",\n                ));\n            }\n        };\n\n        visitor.visit_enum(EnumDeserializer { variant, value })\n    }\n\n    #[inline]\n    fn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        #[cfg(feature = \"raw_value\")]\n        {\n            if name == crate::raw::TOKEN {\n                return visitor.visit_map(crate::raw::OwnedRawDeserializer {\n                    raw_value: Some(self.to_string()),\n                });\n            }\n        }\n\n        let _ = name;\n        visitor.visit_newtype_struct(self)\n    }\n\n    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Bool(v) => visitor.visit_bool(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_string(visitor)\n    }\n\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_string(visitor)\n    }\n\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::String(v) => visitor.visit_string(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_byte_buf(visitor)\n    }\n\n    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::String(v) => visitor.visit_string(v),\n            Value::Array(v) => visit_array(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Null => visitor.visit_unit(),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_unit(visitor)\n    }\n\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Array(v) => visit_array(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_tuple_struct<V>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Object(v) => visit_object(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self {\n            Value::Array(v) => visit_array(v, visitor),\n            Value::Object(v) => visit_object(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n\n    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_string(visitor)\n    }\n\n    fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        drop(self);\n        visitor.visit_unit()\n    }\n}","impl<I> ops::Index<I> for Value\nwhere\n    I: Index,\n{\n    type Output = Value;\n\n    /// Index into a `serde_json::Value` using the syntax `value[0]` or\n    /// `value[\"k\"]`.\n    ///\n    /// Returns `Value::Null` if the type of `self` does not match the type of\n    /// the index, for example if the index is a string and `self` is an array\n    /// or a number. Also returns `Value::Null` if the given key does not exist\n    /// in the map or the given index is not within the bounds of the array.\n    ///\n    /// For retrieving deeply nested values, you should have a look at the\n    /// `Value::pointer` method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let data = json!({\n    ///     \"x\": {\n    ///         \"y\": [\"z\", \"zz\"]\n    ///     }\n    /// });\n    ///\n    /// assert_eq!(data[\"x\"][\"y\"], json!([\"z\", \"zz\"]));\n    /// assert_eq!(data[\"x\"][\"y\"][0], json!(\"z\"));\n    ///\n    /// assert_eq!(data[\"a\"], json!(null)); // returns null for undefined values\n    /// assert_eq!(data[\"a\"][\"b\"], json!(null)); // does not panic\n    /// ```\n    fn index(&self, index: I) -> &Value {\n        static NULL: Value = Value::Null;\n        index.index_into(self).unwrap_or(&NULL)\n    }\n}","impl<I> ops::IndexMut<I> for Value\nwhere\n    I: Index,\n{\n    /// Write into a `serde_json::Value` using the syntax `value[0] = ...` or\n    /// `value[\"k\"] = ...`.\n    ///\n    /// If the index is a number, the value must be an array of length bigger\n    /// than the index. Indexing into a value that is not an array or an array\n    /// that is too small will panic.\n    ///\n    /// If the index is a string, the value must be an object or null which is\n    /// treated like an empty object. If the key is not already present in the\n    /// object, it will be inserted with a value of null. Indexing into a value\n    /// that is neither an object nor null will panic.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let mut data = json!({ \"x\": 0 });\n    ///\n    /// // replace an existing key\n    /// data[\"x\"] = json!(1);\n    ///\n    /// // insert a new key\n    /// data[\"y\"] = json!([false, false, false]);\n    ///\n    /// // replace an array value\n    /// data[\"y\"][0] = json!(true);\n    ///\n    /// // inserted a deeply nested key\n    /// data[\"a\"][\"b\"][\"c\"][\"d\"] = json!(true);\n    ///\n    /// println!(\"{}\", data);\n    /// ```\n    fn index_mut(&mut self, index: I) -> &mut Value {\n        index.index_or_insert(self)\n    }\n}","impl<K: Into<String>, V: Into<Value>> FromIterator<(K, V)> for Value {\n    /// Convert an iteratable type to a `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let v: Vec<_> = vec![(\"lorem\", 40), (\"ipsum\", 2)];\n    /// let x: Value = v.into_iter().collect();\n    /// ```\n    fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self {\n        Value::Object(\n            iter.into_iter()\n                .map(|(k, v)| (k.into(), v.into()))\n                .collect(),\n        )\n    }\n}","impl<T: Into<Value>> From<Vec<T>> for Value {\n    /// Convert a `Vec` to `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let v = vec![\"lorem\", \"ipsum\", \"dolor\"];\n    /// let x: Value = v.into();\n    /// ```\n    fn from(f: Vec<T>) -> Self {\n        Value::Array(f.into_iter().map(Into::into).collect())\n    }\n}","impl<T: Into<Value>> FromIterator<T> for Value {\n    /// Convert an iteratable type to a `Value`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let v = std::iter::repeat(42).take(5);\n    /// let x: Value = v.collect();\n    /// ```\n    ///\n    /// ```\n    /// use serde_json::Value;\n    ///\n    /// let v: Vec<_> = vec![\"lorem\", \"ipsum\", \"dolor\"];\n    /// let x: Value = v.into_iter().collect();\n    /// ```\n    ///\n    /// ```\n    /// use std::iter::FromIterator;\n    /// use serde_json::Value;\n    ///\n    /// let x: Value = Value::from_iter(vec![\"lorem\", \"ipsum\", \"dolor\"]);\n    /// ```\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n        Value::Array(iter.into_iter().map(Into::into).collect())\n    }\n}","impl<T> From<Option<T>> for Value\nwhere\n    T: Into<Value>,\n{\n    fn from(opt: Option<T>) -> Self {\n        match opt {\n            None => Value::Null,\n            Some(value) => Into::into(value),\n        }\n    }\n}"],"value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor":["impl<'de> Visitor<'de> for ValueVisitor {\n            type Value = Value;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"any valid JSON value\")\n            }\n\n            #[inline]\n            fn visit_bool<E>(self, value: bool) -> Result<Value, E> {\n                Ok(Value::Bool(value))\n            }\n\n            #[inline]\n            fn visit_i64<E>(self, value: i64) -> Result<Value, E> {\n                Ok(Value::Number(value.into()))\n            }\n\n            #[inline]\n            fn visit_u64<E>(self, value: u64) -> Result<Value, E> {\n                Ok(Value::Number(value.into()))\n            }\n\n            #[inline]\n            fn visit_f64<E>(self, value: f64) -> Result<Value, E> {\n                Ok(Number::from_f64(value).map_or(Value::Null, Value::Number))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_str<E>(self, value: &str) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_string(String::from(value))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_string<E>(self, value: String) -> Result<Value, E> {\n                Ok(Value::String(value))\n            }\n\n            #[inline]\n            fn visit_none<E>(self) -> Result<Value, E> {\n                Ok(Value::Null)\n            }\n\n            #[inline]\n            fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: serde::Deserializer<'de>,\n            {\n                Deserialize::deserialize(deserializer)\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Value, E> {\n                Ok(Value::Null)\n            }\n\n            #[inline]\n            fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: SeqAccess<'de>,\n            {\n                let mut vec = Vec::new();\n\n                while let Some(elem) = tri!(visitor.next_element()) {\n                    vec.push(elem);\n                }\n\n                Ok(Value::Array(vec))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: MapAccess<'de>,\n            {\n                match visitor.next_key_seed(KeyClassifier)? {\n                    #[cfg(feature = \"arbitrary_precision\")]\n                    Some(KeyClass::Number) => {\n                        let number: NumberFromString = visitor.next_value()?;\n                        Ok(Value::Number(number.value))\n                    }\n                    #[cfg(feature = \"raw_value\")]\n                    Some(KeyClass::RawValue) => {\n                        let value = visitor.next_value_seed(crate::raw::BoxedFromString)?;\n                        crate::from_str(value.get()).map_err(de::Error::custom)\n                    }\n                    Some(KeyClass::Map(first_key)) => {\n                        let mut values = Map::new();\n\n                        values.insert(first_key, tri!(visitor.next_value()));\n                        while let Some((key, value)) = tri!(visitor.next_entry()) {\n                            values.insert(key, value);\n                        }\n\n                        Ok(Value::Object(values))\n                    }\n                    None => Ok(Value::Object(Map::new())),\n                }\n            }\n        }"],"value::de::BorrowedCowStrDeserializer":["impl<'de> BorrowedCowStrDeserializer<'de> {\n    fn new(value: Cow<'de, str>) -> Self {\n        BorrowedCowStrDeserializer { value }\n    }\n}","impl<'de> de::Deserializer<'de> for BorrowedCowStrDeserializer<'de> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        match self.value {\n            Cow::Borrowed(string) => visitor.visit_borrowed_str(string),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Cow::Owned(string) => visitor.visit_string(string),\n        }\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}","impl<'de> de::EnumAccess<'de> for BorrowedCowStrDeserializer<'de> {\n    type Error = Error;\n    type Variant = UnitOnly;\n\n    fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        let value = seed.deserialize(self)?;\n        Ok((value, UnitOnly))\n    }\n}"],"value::de::EnumDeserializer":["impl<'de> EnumAccess<'de> for EnumDeserializer {\n    type Error = Error;\n    type Variant = VariantDeserializer;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, VariantDeserializer), Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        let variant = self.variant.into_deserializer();\n        let visitor = VariantDeserializer { value: self.value };\n        seed.deserialize(variant).map(|v| (v, visitor))\n    }\n}"],"value::de::EnumRefDeserializer":["impl<'de> EnumAccess<'de> for EnumRefDeserializer<'de> {\n    type Error = Error;\n    type Variant = VariantRefDeserializer<'de>;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        let variant = self.variant.into_deserializer();\n        let visitor = VariantRefDeserializer { value: self.value };\n        seed.deserialize(variant).map(|v| (v, visitor))\n    }\n}"],"value::de::KeyClassifier":["impl<'de> DeserializeSeed<'de> for KeyClassifier {\n    type Value = KeyClass;\n\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        deserializer.deserialize_str(self)\n    }\n}","impl<'de> Visitor<'de> for KeyClassifier {\n    type Value = KeyClass;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a string key\")\n    }\n\n    fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n    where\n        E: de::Error,\n    {\n        match s {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(KeyClass::Number),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(KeyClass::RawValue),\n            _ => Ok(KeyClass::Map(s.to_owned())),\n        }\n    }\n\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn visit_string<E>(self, s: String) -> Result<Self::Value, E>\n    where\n        E: de::Error,\n    {\n        match s.as_str() {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(KeyClass::Number),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(KeyClass::RawValue),\n            _ => Ok(KeyClass::Map(s)),\n        }\n    }\n}"],"value::de::MapDeserializer":["impl MapDeserializer {\n    fn new(map: Map<String, Value>) -> Self {\n        MapDeserializer {\n            iter: map.into_iter(),\n            value: None,\n        }\n    }\n}","impl<'de> MapAccess<'de> for MapDeserializer {\n    type Error = Error;\n\n    fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some((key, value)) => {\n                self.value = Some(value);\n                let key_de = MapKeyDeserializer {\n                    key: Cow::Owned(key),\n                };\n                seed.deserialize(key_de).map(Some)\n            }\n            None => Ok(None),\n        }\n    }\n\n    fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.value.take() {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::custom(\"value is missing\")),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}"],"value::de::MapKeyDeserializer":["impl<'de> serde::Deserializer<'de> for MapKeyDeserializer<'de> {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        BorrowedCowStrDeserializer::new(self.key).deserialize_any(visitor)\n    }\n\n    deserialize_integer_key!(deserialize_i8 => visit_i8);\n    deserialize_integer_key!(deserialize_i16 => visit_i16);\n    deserialize_integer_key!(deserialize_i32 => visit_i32);\n    deserialize_integer_key!(deserialize_i64 => visit_i64);\n    deserialize_integer_key!(deserialize_i128 => visit_i128);\n    deserialize_integer_key!(deserialize_u8 => visit_u8);\n    deserialize_integer_key!(deserialize_u16 => visit_u16);\n    deserialize_integer_key!(deserialize_u32 => visit_u32);\n    deserialize_integer_key!(deserialize_u64 => visit_u64);\n    deserialize_integer_key!(deserialize_u128 => visit_u128);\n\n    #[inline]\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        // Map keys cannot be null.\n        visitor.visit_some(self)\n    }\n\n    #[inline]\n    fn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_newtype_struct(self)\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.key\n            .into_deserializer()\n            .deserialize_enum(name, variants, visitor)\n    }\n\n    forward_to_deserialize_any! {\n        bool f32 f64 char str string bytes byte_buf unit unit_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}"],"value::de::MapRefDeserializer":["impl<'de> MapAccess<'de> for MapRefDeserializer<'de> {\n    type Error = Error;\n\n    fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some((key, value)) => {\n                self.value = Some(value);\n                let key_de = MapKeyDeserializer {\n                    key: Cow::Borrowed(&**key),\n                };\n                seed.deserialize(key_de).map(Some)\n            }\n            None => Ok(None),\n        }\n    }\n\n    fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.value.take() {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::custom(\"value is missing\")),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}","impl<'de> MapRefDeserializer<'de> {\n    fn new(map: &'de Map<String, Value>) -> Self {\n        MapRefDeserializer {\n            iter: map.into_iter(),\n            value: None,\n        }\n    }\n}"],"value::de::SeqDeserializer":["impl SeqDeserializer {\n    fn new(vec: Vec<Value>) -> Self {\n        SeqDeserializer {\n            iter: vec.into_iter(),\n        }\n    }\n}","impl<'de> SeqAccess<'de> for SeqDeserializer {\n    type Error = Error;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some(value) => seed.deserialize(value).map(Some),\n            None => Ok(None),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}"],"value::de::SeqRefDeserializer":["impl<'de> SeqAccess<'de> for SeqRefDeserializer<'de> {\n    type Error = Error;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some(value) => seed.deserialize(value).map(Some),\n            None => Ok(None),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}","impl<'de> SeqRefDeserializer<'de> {\n    fn new(slice: &'de [Value]) -> Self {\n        SeqRefDeserializer { iter: slice.iter() }\n    }\n}"],"value::de::UnitOnly":["impl<'de> de::VariantAccess<'de> for UnitOnly {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Error> {\n        Ok(())\n    }\n\n    fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"newtype variant\",\n        ))\n    }\n\n    fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"tuple variant\",\n        ))\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        _visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"struct variant\",\n        ))\n    }\n}"],"value::de::VariantDeserializer":["impl<'de> VariantAccess<'de> for VariantDeserializer {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Error> {\n        match self.value {\n            Some(value) => Deserialize::deserialize(value),\n            None => Ok(()),\n        }\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.value {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"newtype variant\",\n            )),\n        }\n    }\n\n    fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.value {\n            Some(Value::Array(v)) => {\n                if v.is_empty() {\n                    visitor.visit_unit()\n                } else {\n                    visit_array(v, visitor)\n                }\n            }\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"tuple variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"tuple variant\",\n            )),\n        }\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.value {\n            Some(Value::Object(v)) => visit_object(v, visitor),\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"struct variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"struct variant\",\n            )),\n        }\n    }\n}"],"value::de::VariantRefDeserializer":["impl<'de> VariantAccess<'de> for VariantRefDeserializer<'de> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Error> {\n        match self.value {\n            Some(value) => Deserialize::deserialize(value),\n            None => Ok(()),\n        }\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.value {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"newtype variant\",\n            )),\n        }\n    }\n\n    fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.value {\n            Some(Value::Array(v)) => {\n                if v.is_empty() {\n                    visitor.visit_unit()\n                } else {\n                    visit_array_ref(v, visitor)\n                }\n            }\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"tuple variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"tuple variant\",\n            )),\n        }\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.value {\n            Some(Value::Object(v)) => visit_object_ref(v, visitor),\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"struct variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"struct variant\",\n            )),\n        }\n    }\n}"],"value::index::Type":["impl<'a> Display for Type<'a> {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        match *self.0 {\n            Value::Null => formatter.write_str(\"null\"),\n            Value::Bool(_) => formatter.write_str(\"boolean\"),\n            Value::Number(_) => formatter.write_str(\"number\"),\n            Value::String(_) => formatter.write_str(\"string\"),\n            Value::Array(_) => formatter.write_str(\"array\"),\n            Value::Object(_) => formatter.write_str(\"object\"),\n        }\n    }\n}"],"value::ser::MapKeySerializer":["impl serde::Serializer for MapKeySerializer {\n    type Ok = String;\n    type Error = Error;\n\n    type SerializeSeq = Impossible<String, Error>;\n    type SerializeTuple = Impossible<String, Error>;\n    type SerializeTupleStruct = Impossible<String, Error>;\n    type SerializeTupleVariant = Impossible<String, Error>;\n    type SerializeMap = Impossible<String, Error>;\n    type SerializeStruct = Impossible<String, Error>;\n    type SerializeStructVariant = Impossible<String, Error>;\n\n    #[inline]\n    fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<String> {\n        Ok(variant.to_owned())\n    }\n\n    #[inline]\n    fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<String>\n    where\n        T: ?Sized + Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_bool(self, _value: bool) -> Result<String> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_i8(self, value: i8) -> Result<String> {\n        Ok(value.to_string())\n    }\n\n    fn serialize_i16(self, value: i16) -> Result<String> {\n        Ok(value.to_string())\n    }\n\n    fn serialize_i32(self, value: i32) -> Result<String> {\n        Ok(value.to_string())\n    }\n\n    fn serialize_i64(self, value: i64) -> Result<String> {\n        Ok(value.to_string())\n    }\n\n    fn serialize_u8(self, value: u8) -> Result<String> {\n        Ok(value.to_string())\n    }\n\n    fn serialize_u16(self, value: u16) -> Result<String> {\n        Ok(value.to_string())\n    }\n\n    fn serialize_u32(self, value: u32) -> Result<String> {\n        Ok(value.to_string())\n    }\n\n    fn serialize_u64(self, value: u64) -> Result<String> {\n        Ok(value.to_string())\n    }\n\n    fn serialize_f32(self, _value: f32) -> Result<String> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_f64(self, _value: f64) -> Result<String> {\n        Err(key_must_be_a_string())\n    }\n\n    #[inline]\n    fn serialize_char(self, value: char) -> Result<String> {\n        Ok({\n            let mut s = String::new();\n            s.push(value);\n            s\n        })\n    }\n\n    #[inline]\n    fn serialize_str(self, value: &str) -> Result<String> {\n        Ok(value.to_owned())\n    }\n\n    fn serialize_bytes(self, _value: &[u8]) -> Result<String> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_unit(self) -> Result<String> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_unit_struct(self, _name: &'static str) -> Result<String> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _value: &T,\n    ) -> Result<String>\n    where\n        T: ?Sized + Serialize,\n    {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_none(self) -> Result<String> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_some<T>(self, _value: &T) -> Result<String>\n    where\n        T: ?Sized + Serialize,\n    {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct> {\n        Err(key_must_be_a_string())\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant> {\n        Err(key_must_be_a_string())\n    }\n\n    fn collect_str<T>(self, value: &T) -> Result<String>\n    where\n        T: ?Sized + Display,\n    {\n        Ok(value.to_string())\n    }\n}"],"value::ser::SerializeMap":["impl serde::ser::SerializeMap for SerializeMap {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_key<T>(&mut self, key: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            SerializeMap::Map { next_key, .. } => {\n                *next_key = Some(tri!(key.serialize(MapKeySerializer)));\n                Ok(())\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { .. } => unreachable!(),\n        }\n    }\n\n    fn serialize_value<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            SerializeMap::Map { map, next_key } => {\n                let key = next_key.take();\n                // Panic because this indicates a bug in the program rather than an\n                // expected failure.\n                let key = key.expect(\"serialize_value called before serialize_key\");\n                map.insert(key, tri!(to_value(value)));\n                Ok(())\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { .. } => unreachable!(),\n        }\n    }\n\n    fn end(self) -> Result<Value> {\n        match self {\n            SerializeMap::Map { map, .. } => Ok(Value::Object(map)),\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { .. } => unreachable!(),\n        }\n    }\n}","impl serde::ser::SerializeStruct for SerializeMap {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        match self {\n            SerializeMap::Map { .. } => serde::ser::SerializeMap::serialize_entry(self, key, value),\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { out_value } => {\n                if key == crate::number::TOKEN {\n                    *out_value = Some(value.serialize(NumberValueEmitter)?);\n                    Ok(())\n                } else {\n                    Err(invalid_number())\n                }\n            }\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { out_value } => {\n                if key == crate::raw::TOKEN {\n                    *out_value = Some(value.serialize(RawValueEmitter)?);\n                    Ok(())\n                } else {\n                    Err(invalid_raw_value())\n                }\n            }\n        }\n    }\n\n    fn end(self) -> Result<Value> {\n        match self {\n            SerializeMap::Map { .. } => serde::ser::SerializeMap::end(self),\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { out_value, .. } => {\n                Ok(out_value.expect(\"number value was not emitted\"))\n            }\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { out_value, .. } => {\n                Ok(out_value.expect(\"raw value was not emitted\"))\n            }\n        }\n    }\n}"],"value::ser::SerializeStructVariant":["impl serde::ser::SerializeStructVariant for SerializeStructVariant {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        self.map.insert(String::from(key), tri!(to_value(value)));\n        Ok(())\n    }\n\n    fn end(self) -> Result<Value> {\n        let mut object = Map::new();\n\n        object.insert(self.name, Value::Object(self.map));\n\n        Ok(Value::Object(object))\n    }\n}"],"value::ser::SerializeTupleVariant":["impl serde::ser::SerializeTupleVariant for SerializeTupleVariant {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        self.vec.push(tri!(to_value(value)));\n        Ok(())\n    }\n\n    fn end(self) -> Result<Value> {\n        let mut object = Map::new();\n\n        object.insert(self.name, Value::Array(self.vec));\n\n        Ok(Value::Object(object))\n    }\n}"],"value::ser::SerializeVec":["impl serde::ser::SerializeSeq for SerializeVec {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        self.vec.push(tri!(to_value(value)));\n        Ok(())\n    }\n\n    fn end(self) -> Result<Value> {\n        Ok(Value::Array(self.vec))\n    }\n}","impl serde::ser::SerializeTuple for SerializeVec {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        serde::ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Value> {\n        serde::ser::SerializeSeq::end(self)\n    }\n}","impl serde::ser::SerializeTupleStruct for SerializeVec {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,\n    {\n        serde::ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -> Result<Value> {\n        serde::ser::SerializeSeq::end(self)\n    }\n}"],"value::ser::Serializer":["impl serde::Serializer for Serializer {\n    type Ok = Value;\n    type Error = Error;\n\n    type SerializeSeq = SerializeVec;\n    type SerializeTuple = SerializeVec;\n    type SerializeTupleStruct = SerializeVec;\n    type SerializeTupleVariant = SerializeTupleVariant;\n    type SerializeMap = SerializeMap;\n    type SerializeStruct = SerializeMap;\n    type SerializeStructVariant = SerializeStructVariant;\n\n    #[inline]\n    fn serialize_bool(self, value: bool) -> Result<Value> {\n        Ok(Value::Bool(value))\n    }\n\n    #[inline]\n    fn serialize_i8(self, value: i8) -> Result<Value> {\n        self.serialize_i64(value as i64)\n    }\n\n    #[inline]\n    fn serialize_i16(self, value: i16) -> Result<Value> {\n        self.serialize_i64(value as i64)\n    }\n\n    #[inline]\n    fn serialize_i32(self, value: i32) -> Result<Value> {\n        self.serialize_i64(value as i64)\n    }\n\n    fn serialize_i64(self, value: i64) -> Result<Value> {\n        Ok(Value::Number(value.into()))\n    }\n\n    fn serialize_i128(self, value: i128) -> Result<Value> {\n        #[cfg(feature = \"arbitrary_precision\")]\n        {\n            Ok(Value::Number(value.into()))\n        }\n\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        {\n            if let Ok(value) = u64::try_from(value) {\n                Ok(Value::Number(value.into()))\n            } else if let Ok(value) = i64::try_from(value) {\n                Ok(Value::Number(value.into()))\n            } else {\n                Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))\n            }\n        }\n    }\n\n    #[inline]\n    fn serialize_u8(self, value: u8) -> Result<Value> {\n        self.serialize_u64(value as u64)\n    }\n\n    #[inline]\n    fn serialize_u16(self, value: u16) -> Result<Value> {\n        self.serialize_u64(value as u64)\n    }\n\n    #[inline]\n    fn serialize_u32(self, value: u32) -> Result<Value> {\n        self.serialize_u64(value as u64)\n    }\n\n    #[inline]\n    fn serialize_u64(self, value: u64) -> Result<Value> {\n        Ok(Value::Number(value.into()))\n    }\n\n    fn serialize_u128(self, value: u128) -> Result<Value> {\n        #[cfg(feature = \"arbitrary_precision\")]\n        {\n            Ok(Value::Number(value.into()))\n        }\n\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        {\n            if let Ok(value) = u64::try_from(value) {\n                Ok(Value::Number(value.into()))\n            } else {\n                Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))\n            }\n        }\n    }\n\n    #[inline]\n    fn serialize_f32(self, float: f32) -> Result<Value> {\n        Ok(Value::from(float))\n    }\n\n    #[inline]\n    fn serialize_f64(self, float: f64) -> Result<Value> {\n        Ok(Value::from(float))\n    }\n\n    #[inline]\n    fn serialize_char(self, value: char) -> Result<Value> {\n        let mut s = String::new();\n        s.push(value);\n        Ok(Value::String(s))\n    }\n\n    #[inline]\n    fn serialize_str(self, value: &str) -> Result<Value> {\n        Ok(Value::String(value.to_owned()))\n    }\n\n    fn serialize_bytes(self, value: &[u8]) -> Result<Value> {\n        let vec = value.iter().map(|&b| Value::Number(b.into())).collect();\n        Ok(Value::Array(vec))\n    }\n\n    #[inline]\n    fn serialize_unit(self) -> Result<Value> {\n        Ok(Value::Null)\n    }\n\n    #[inline]\n    fn serialize_unit_struct(self, _name: &'static str) -> Result<Value> {\n        self.serialize_unit()\n    }\n\n    #[inline]\n    fn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Value> {\n        self.serialize_str(variant)\n    }\n\n    #[inline]\n    fn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<Value>\n    where\n        T: ?Sized + Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Value>\n    where\n        T: ?Sized + Serialize,\n    {\n        let mut values = Map::new();\n        values.insert(String::from(variant), tri!(to_value(value)));\n        Ok(Value::Object(values))\n    }\n\n    #[inline]\n    fn serialize_none(self) -> Result<Value> {\n        self.serialize_unit()\n    }\n\n    #[inline]\n    fn serialize_some<T>(self, value: &T) -> Result<Value>\n    where\n        T: ?Sized + Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq> {\n        Ok(SerializeVec {\n            vec: Vec::with_capacity(len.unwrap_or(0)),\n        })\n    }\n\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct> {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant> {\n        Ok(SerializeTupleVariant {\n            name: String::from(variant),\n            vec: Vec::with_capacity(len),\n        })\n    }\n\n    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap> {\n        Ok(SerializeMap::Map {\n            map: Map::new(),\n            next_key: None,\n        })\n    }\n\n    fn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct> {\n        match name {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(SerializeMap::Number { out_value: None }),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(SerializeMap::RawValue { out_value: None }),\n            _ => self.serialize_map(Some(len)),\n        }\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant> {\n        Ok(SerializeStructVariant {\n            name: String::from(variant),\n            map: Map::new(),\n        })\n    }\n\n    fn collect_str<T>(self, value: &T) -> Result<Value>\n    where\n        T: ?Sized + Display,\n    {\n        Ok(Value::String(value.to_string()))\n    }\n}"]},"single_path_import":{"de::Deserializer":"Deserializer","de::StreamDeserializer":"StreamDeserializer","de::from_reader":"from_reader","de::from_slice":"from_slice","de::from_str":"from_str","error::Error":"Error","error::Result":"Result","map::Map":"value::Map","number::Number":"value::Number","read::IoRead":"de::IoRead","read::Read":"de::Read","read::SliceRead":"de::SliceRead","read::StrRead":"de::StrRead","ser::Serializer":"Serializer","ser::to_string":"to_string","ser::to_string_pretty":"to_string_pretty","ser::to_vec":"to_vec","ser::to_vec_pretty":"to_vec_pretty","ser::to_writer":"to_writer","ser::to_writer_pretty":"to_writer_pretty","std::io::Bytes":"io::Bytes","std::io::Error":"io::Error","std::io::ErrorKind":"io::ErrorKind","std::io::Read":"io::Read","std::io::Result":"io::Result","std::io::Write":"io::Write","value::Value":"Value","value::from_value":"from_value","value::index::Index":"value::Index","value::ser::Serializer":"value::Serializer","value::to_value":"to_value"},"srcs":{"<&'a T as value::index::Index>::index_into":["fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>{\n        (**self).index_into(v)\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<&'a T as value::index::Index>::index_into_mut":["fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>{\n        (**self).index_into_mut(v)\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<&'a T as value::index::Index>::index_or_insert":["fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value{\n        (**self).index_or_insert(v)\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> Self::IntoIter{\n        Iter {\n            iter: self.map.iter(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"<&'a mut R as read::Read<'de>>::byte_offset":["fn byte_offset(&self) -> usize{\n        R::byte_offset(self)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<&'a mut R as read::Read<'de>>::decode_hex_escape":["fn decode_hex_escape(&mut self) -> Result<u16>{\n        R::decode_hex_escape(self)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<&'a mut R as read::Read<'de>>::discard":["fn discard(&mut self){\n        R::discard(self);\n    }","Real(LocalPath(\"src/read.rs\"))"],"<&'a mut R as read::Read<'de>>::ignore_str":["fn ignore_str(&mut self) -> Result<()>{\n        R::ignore_str(self)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<&'a mut R as read::Read<'de>>::next":["fn next(&mut self) -> Result<Option<u8>>{\n        R::next(self)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<&'a mut R as read::Read<'de>>::parse_str":["fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>>{\n        R::parse_str(self, scratch)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<&'a mut R as read::Read<'de>>::parse_str_raw":["fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, [u8]>>{\n        R::parse_str_raw(self, scratch)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<&'a mut R as read::Read<'de>>::peek":["fn peek(&mut self) -> Result<Option<u8>>{\n        R::peek(self)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<&'a mut R as read::Read<'de>>::peek_position":["fn peek_position(&self) -> Position{\n        R::peek_position(self)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<&'a mut R as read::Read<'de>>::position":["fn position(&self) -> Position{\n        R::position(self)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<&'a mut R as read::Read<'de>>::set_failed":["fn set_failed(&mut self, failed: &mut bool){\n        R::set_failed(self, failed);\n    }","Real(LocalPath(\"src/read.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_any":["#[inline]\nfn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'n' => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"ull\"));\n                visitor.visit_unit()\n            }\n            b't' => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"rue\"));\n                visitor.visit_bool(true)\n            }\n            b'f' => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"alse\"));\n                visitor.visit_bool(false)\n            }\n            b'-' => {\n                self.eat_char();\n                tri!(self.parse_any_number(false)).visit(visitor)\n            }\n            b'0'..=b'9' => tri!(self.parse_any_number(true)).visit(visitor),\n            b'\"' => {\n                self.eat_char();\n                self.scratch.clear();\n                match tri!(self.read.parse_str(&mut self.scratch)) {\n                    Reference::Borrowed(s) => visitor.visit_borrowed_str(s),\n                    Reference::Copied(s) => visitor.visit_str(s),\n                }\n            }\n            b'[' => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_seq(SeqAccess::new(self));\n                }\n\n                match (ret, self.end_seq()) {\n                    (Ok(ret), Ok(())) => Ok(ret),\n                    (Err(err), _) | (_, Err(err)) => Err(err),\n                }\n            }\n            b'{' => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_map(MapAccess::new(self));\n                }\n\n                match (ret, self.end_map()) {\n                    (Ok(ret), Ok(())) => Ok(ret),\n                    (Err(err), _) | (_, Err(err)) => Err(err),\n                }\n            }\n            _ => Err(self.peek_error(ErrorCode::ExpectedSomeValue)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            // The de::Error impl creates errors with unknown line and column.\n            // Fill in the position here by looking at the current index in the\n            // input. There is no way to tell whether this should call `error`\n            // or `peek_error` so pick the one that seems correct more often.\n            // Worst case, the position is off by one character.\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bool":["fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b't' => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"rue\"));\n                visitor.visit_bool(true)\n            }\n            b'f' => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"alse\"));\n                visitor.visit_bool(false)\n            }\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_byte_buf":["#[inline]\nfn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_bytes(visitor)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bytes":["/// Parses a JSON string as bytes. Note that this function does not check\n/// whether the bytes represent a valid UTF-8 string.\n///\n/// The relevant part of the JSON specification is Section 8.2 of [RFC\n/// 7159]:\n///\n/// > When all the strings represented in a JSON text are composed entirely\n/// > of Unicode characters (however escaped), then that JSON text is\n/// > interoperable in the sense that all software implementations that\n/// > parse it will agree on the contents of names and of string values in\n/// > objects and arrays.\n/// >\n/// > However, the ABNF in this specification allows member names and string\n/// > values to contain bit sequences that cannot encode Unicode characters;\n/// > for example, \"\\uDEAD\" (a single unpaired UTF-16 surrogate). Instances\n/// > of this have been observed, for example, when a library truncates a\n/// > UTF-16 string without checking whether the truncation split a\n/// > surrogate pair.  The behavior of software that receives JSON texts\n/// > containing such values is unpredictable; for example, implementations\n/// > might return different values for the length of a string value or even\n/// > suffer fatal runtime exceptions.\n///\n/// [RFC 7159]: https://tools.ietf.org/html/rfc7159\n///\n/// The behavior of serde_json is specified to fail on non-UTF-8 strings\n/// when deserializing into Rust UTF-8 string types such as String, and\n/// succeed with non-UTF-8 bytes when deserializing using this method.\n///\n/// Escape sequences are processed as usual, and for `\\uXXXX` escapes it is\n/// still checked if the hex number represents a valid Unicode code point.\n///\n/// # Examples\n///\n/// You can use this to parse JSON strings containing invalid UTF-8 bytes,\n/// or unpaired surrogates.\n///\n/// ```\n/// use serde_bytes::ByteBuf;\n///\n/// fn look_at_bytes() -> Result<(), serde_json::Error> {\n///     let json_data = b\"\\\"some bytes: \\xe5\\x00\\xe5\\\"\";\n///     let bytes: ByteBuf = serde_json::from_slice(json_data)?;\n///\n///     assert_eq!(b'\\xe5', bytes[12]);\n///     assert_eq!(b'\\0', bytes[13]);\n///     assert_eq!(b'\\xe5', bytes[14]);\n///\n///     Ok(())\n/// }\n/// #\n/// # look_at_bytes().unwrap();\n/// ```\n///\n/// Backslash escape sequences like `\\n` are still interpreted and required\n/// to be valid. `\\u` escape sequences are required to represent a valid\n/// Unicode code point or lone surrogate.\n///\n/// ```\n/// use serde_bytes::ByteBuf;\n///\n/// fn look_at_bytes() -> Result<(), serde_json::Error> {\n///     let json_data = b\"\\\"lone surrogate: \\\\uD801\\\"\";\n///     let bytes: ByteBuf = serde_json::from_slice(json_data)?;\n///     let expected = b\"lone surrogate: \\xED\\xA0\\x81\";\n///     assert_eq!(expected, bytes.as_slice());\n///     Ok(())\n/// }\n/// #\n/// # look_at_bytes();\n/// ```\nfn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'\"' => {\n                self.eat_char();\n                self.scratch.clear();\n                match tri!(self.read.parse_str_raw(&mut self.scratch)) {\n                    Reference::Borrowed(b) => visitor.visit_borrowed_bytes(b),\n                    Reference::Copied(b) => visitor.visit_bytes(b),\n                }\n            }\n            b'[' => self.deserialize_seq(visitor),\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_char":["fn deserialize_char<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_str(visitor)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_enum":["/// Parses an enum as an object like `{\"$KEY\":$VALUE}`, where $VALUE is either a straight\n/// value, a `[..]`, or a `{..}`.\n#[inline]\nfn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        match tri!(self.parse_whitespace()) {\n            Some(b'{') => {\n                check_recursion! {\n                    self.eat_char();\n                    let value = tri!(visitor.visit_enum(VariantAccess::new(self)));\n                }\n\n                match tri!(self.parse_whitespace()) {\n                    Some(b'}') => {\n                        self.eat_char();\n                        Ok(value)\n                    }\n                    Some(_) => Err(self.error(ErrorCode::ExpectedSomeValue)),\n                    None => Err(self.error(ErrorCode::EofWhileParsingObject)),\n                }\n            }\n            Some(b'\"') => visitor.visit_enum(UnitVariantAccess::new(self)),\n            Some(_) => Err(self.peek_error(ErrorCode::ExpectedSomeValue)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingValue)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f32":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f64":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i128":["fn deserialize_i128<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let mut buf = String::new();\n\n        match tri!(self.parse_whitespace()) {\n            Some(b'-') => {\n                self.eat_char();\n                buf.push('-');\n            }\n            Some(_) => {}\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        tri!(self.scan_integer128(&mut buf));\n\n        let value = match buf.parse() {\n            Ok(int) => visitor.visit_i128(int),\n            Err(_) => {\n                return Err(self.error(ErrorCode::NumberOutOfRange));\n            }\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i16":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i32":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i64":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i8":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_identifier":["fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_str(visitor)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_ignored_any":["fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        tri!(self.ignore_value());\n        visitor.visit_unit()\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_map":["fn deserialize_map<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'{' => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_map(MapAccess::new(self));\n                }\n\n                match (ret, self.end_map()) {\n                    (Ok(ret), Ok(())) => Ok(ret),\n                    (Err(err), _) | (_, Err(err)) => Err(err),\n                }\n            }\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_newtype_struct":["/// Parses a newtype struct as the underlying value.\n#[inline]\nfn deserialize_newtype_struct<V>(self, name: &str, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        #[cfg(feature = \"raw_value\")]\n        {\n            if name == crate::raw::TOKEN {\n                return self.deserialize_raw_value(visitor);\n            }\n        }\n\n        let _ = name;\n        visitor.visit_newtype_struct(self)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_option":["/// Parses a `null` as a None, and any other values as a `Some(...)`.\n#[inline]\nfn deserialize_option<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        match tri!(self.parse_whitespace()) {\n            Some(b'n') => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"ull\"));\n                visitor.visit_none()\n            }\n            _ => visitor.visit_some(self),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_seq":["fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'[' => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_seq(SeqAccess::new(self));\n                }\n\n                match (ret, self.end_seq()) {\n                    (Ok(ret), Ok(())) => Ok(ret),\n                    (Err(err), _) | (_, Err(err)) => Err(err),\n                }\n            }\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_str":["fn deserialize_str<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'\"' => {\n                self.eat_char();\n                self.scratch.clear();\n                match tri!(self.read.parse_str(&mut self.scratch)) {\n                    Reference::Borrowed(s) => visitor.visit_borrowed_str(s),\n                    Reference::Copied(s) => visitor.visit_str(s),\n                }\n            }\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_string":["fn deserialize_string<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_str(visitor)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_struct":["fn deserialize_struct<V>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'[' => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_seq(SeqAccess::new(self));\n                }\n\n                match (ret, self.end_seq()) {\n                    (Ok(ret), Ok(())) => Ok(ret),\n                    (Err(err), _) | (_, Err(err)) => Err(err),\n                }\n            }\n            b'{' => {\n                check_recursion! {\n                    self.eat_char();\n                    let ret = visitor.visit_map(MapAccess::new(self));\n                }\n\n                match (ret, self.end_map()) {\n                    (Ok(ret), Ok(())) => Ok(ret),\n                    (Err(err), _) | (_, Err(err)) => Err(err),\n                }\n            }\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple":["fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_seq(visitor)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple_struct":["fn deserialize_tuple_struct<V>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_seq(visitor)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u128":["fn deserialize_u128<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        match tri!(self.parse_whitespace()) {\n            Some(b'-') => {\n                return Err(self.peek_error(ErrorCode::NumberOutOfRange));\n            }\n            Some(_) => {}\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        }\n\n        let mut buf = String::new();\n        tri!(self.scan_integer128(&mut buf));\n\n        let value = match buf.parse() {\n            Ok(int) => visitor.visit_u128(int),\n            Err(_) => {\n                return Err(self.error(ErrorCode::NumberOutOfRange));\n            }\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u16":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u32":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u64":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u8":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.deserialize_number(visitor)\n        }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit":["fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'n' => {\n                self.eat_char();\n                tri!(self.parse_ident(b\"ull\"));\n                visitor.visit_unit()\n            }\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit_struct":["fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.deserialize_unit(visitor)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> Self::IntoIter{\n        IterMut {\n            iter: self.map.iter_mut(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str":["fn collect_str<T>(self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Display,{\n        use self::fmt::Write;\n\n        struct Adapter<'ser, W: 'ser, F: 'ser> {\n            writer: &'ser mut W,\n            formatter: &'ser mut F,\n            error: Option<io::Error>,\n        }\n\n        impl<'ser, W, F> Write for Adapter<'ser, W, F>\n        where\n            W: io::Write,\n            F: Formatter,\n        {\n            fn write_str(&mut self, s: &str) -> fmt::Result {\n                debug_assert!(self.error.is_none());\n                match format_escaped_str_contents(self.writer, self.formatter, s) {\n                    Ok(()) => Ok(()),\n                    Err(err) => {\n                        self.error = Some(err);\n                        Err(fmt::Error)\n                    }\n                }\n            }\n        }\n\n        tri!(self\n            .formatter\n            .begin_string(&mut self.writer)\n            .map_err(Error::io));\n        {\n            let mut adapter = Adapter {\n                writer: &mut self.writer,\n                formatter: &mut self.formatter,\n                error: None,\n            };\n            match write!(adapter, \"{}\", value) {\n                Ok(()) => debug_assert!(adapter.error.is_none()),\n                Err(fmt::Error) => {\n                    return Err(Error::io(adapter.error.expect(\"there should be an error\")));\n                }\n            }\n        }\n        self.formatter\n            .end_string(&mut self.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter":["struct Adapter<'ser, W: 'ser, F: 'ser> {\n            writer: &'ser mut W,\n            formatter: &'ser mut F,\n            error: Option<io::Error>,\n        }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bool":["#[inline]\nfn serialize_bool(self, value: bool) -> Result<()>{\n        self.formatter\n            .write_bool(&mut self.writer, value)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bytes":["#[inline]\nfn serialize_bytes(self, value: &[u8]) -> Result<()>{\n        use serde::ser::SerializeSeq;\n        let mut seq = tri!(self.serialize_seq(Some(value.len())));\n        for byte in value {\n            tri!(seq.serialize_element(byte));\n        }\n        seq.end()\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_char":["#[inline]\nfn serialize_char(self, value: char) -> Result<()>{\n        // A char encoded as UTF-8 takes 4 bytes at most.\n        let mut buf = [0; 4];\n        self.serialize_str(value.encode_utf8(&mut buf))\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f32":["#[inline]\nfn serialize_f32(self, value: f32) -> Result<()>{\n        match value.classify() {\n            FpCategory::Nan | FpCategory::Infinite => self\n                .formatter\n                .write_null(&mut self.writer)\n                .map_err(Error::io),\n            _ => self\n                .formatter\n                .write_f32(&mut self.writer, value)\n                .map_err(Error::io),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f64":["#[inline]\nfn serialize_f64(self, value: f64) -> Result<()>{\n        match value.classify() {\n            FpCategory::Nan | FpCategory::Infinite => self\n                .formatter\n                .write_null(&mut self.writer)\n                .map_err(Error::io),\n            _ => self\n                .formatter\n                .write_f64(&mut self.writer, value)\n                .map_err(Error::io),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i128":["fn serialize_i128(self, value: i128) -> Result<()>{\n        self.formatter\n            .write_i128(&mut self.writer, value)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i16":["#[inline]\nfn serialize_i16(self, value: i16) -> Result<()>{\n        self.formatter\n            .write_i16(&mut self.writer, value)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i32":["#[inline]\nfn serialize_i32(self, value: i32) -> Result<()>{\n        self.formatter\n            .write_i32(&mut self.writer, value)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i64":["#[inline]\nfn serialize_i64(self, value: i64) -> Result<()>{\n        self.formatter\n            .write_i64(&mut self.writer, value)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i8":["#[inline]\nfn serialize_i8(self, value: i8) -> Result<()>{\n        self.formatter\n            .write_i8(&mut self.writer, value)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_map":["#[inline]\nfn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap>{\n        tri!(self\n            .formatter\n            .begin_object(&mut self.writer)\n            .map_err(Error::io));\n        if len == Some(0) {\n            tri!(self\n                .formatter\n                .end_object(&mut self.writer)\n                .map_err(Error::io));\n            Ok(Compound::Map {\n                ser: self,\n                state: State::Empty,\n            })\n        } else {\n            Ok(Compound::Map {\n                ser: self,\n                state: State::First,\n            })\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_struct":["/// Serialize newtypes without an object wrapper.\n#[inline]\nfn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_variant":["#[inline]\nfn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        tri!(self\n            .formatter\n            .begin_object(&mut self.writer)\n            .map_err(Error::io));\n        tri!(self\n            .formatter\n            .begin_object_key(&mut self.writer, true)\n            .map_err(Error::io));\n        tri!(self.serialize_str(variant));\n        tri!(self\n            .formatter\n            .end_object_key(&mut self.writer)\n            .map_err(Error::io));\n        tri!(self\n            .formatter\n            .begin_object_value(&mut self.writer)\n            .map_err(Error::io));\n        tri!(value.serialize(&mut *self));\n        tri!(self\n            .formatter\n            .end_object_value(&mut self.writer)\n            .map_err(Error::io));\n        self.formatter\n            .end_object(&mut self.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_none":["#[inline]\nfn serialize_none(self) -> Result<()>{\n        self.serialize_unit()\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_seq":["#[inline]\nfn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq>{\n        tri!(self\n            .formatter\n            .begin_array(&mut self.writer)\n            .map_err(Error::io));\n        if len == Some(0) {\n            tri!(self\n                .formatter\n                .end_array(&mut self.writer)\n                .map_err(Error::io));\n            Ok(Compound::Map {\n                ser: self,\n                state: State::Empty,\n            })\n        } else {\n            Ok(Compound::Map {\n                ser: self,\n                state: State::First,\n            })\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_some":["#[inline]\nfn serialize_some<T>(self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_str":["#[inline]\nfn serialize_str(self, value: &str) -> Result<()>{\n        format_escaped_str(&mut self.writer, &mut self.formatter, value).map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct":["#[inline]\nfn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct>{\n        match name {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(Compound::Number { ser: self }),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(Compound::RawValue { ser: self }),\n            _ => self.serialize_map(Some(len)),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct_variant":["#[inline]\nfn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStructVariant>{\n        tri!(self\n            .formatter\n            .begin_object(&mut self.writer)\n            .map_err(Error::io));\n        tri!(self\n            .formatter\n            .begin_object_key(&mut self.writer, true)\n            .map_err(Error::io));\n        tri!(self.serialize_str(variant));\n        tri!(self\n            .formatter\n            .end_object_key(&mut self.writer)\n            .map_err(Error::io));\n        tri!(self\n            .formatter\n            .begin_object_value(&mut self.writer)\n            .map_err(Error::io));\n        self.serialize_map(Some(len))\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple":["#[inline]\nfn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_struct":["#[inline]\nfn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_variant":["#[inline]\nfn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant>{\n        tri!(self\n            .formatter\n            .begin_object(&mut self.writer)\n            .map_err(Error::io));\n        tri!(self\n            .formatter\n            .begin_object_key(&mut self.writer, true)\n            .map_err(Error::io));\n        tri!(self.serialize_str(variant));\n        tri!(self\n            .formatter\n            .end_object_key(&mut self.writer)\n            .map_err(Error::io));\n        tri!(self\n            .formatter\n            .begin_object_value(&mut self.writer)\n            .map_err(Error::io));\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u128":["fn serialize_u128(self, value: u128) -> Result<()>{\n        self.formatter\n            .write_u128(&mut self.writer, value)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u16":["#[inline]\nfn serialize_u16(self, value: u16) -> Result<()>{\n        self.formatter\n            .write_u16(&mut self.writer, value)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u32":["#[inline]\nfn serialize_u32(self, value: u32) -> Result<()>{\n        self.formatter\n            .write_u32(&mut self.writer, value)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u64":["#[inline]\nfn serialize_u64(self, value: u64) -> Result<()>{\n        self.formatter\n            .write_u64(&mut self.writer, value)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u8":["#[inline]\nfn serialize_u8(self, value: u8) -> Result<()>{\n        self.formatter\n            .write_u8(&mut self.writer, value)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit":["#[inline]\nfn serialize_unit(self) -> Result<()>{\n        self.formatter\n            .write_null(&mut self.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_struct":["#[inline]\nfn serialize_unit_struct(self, _name: &'static str) -> Result<()>{\n        self.serialize_unit()\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_variant":["#[inline]\nfn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<()>{\n        self.serialize_str(variant)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_any":["#[cfg(not(feature = \"arbitrary_precision\"))]\n#[inline]\nfn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self.n {\n                N::PosInt(u) => visitor.visit_u64(u),\n                N::NegInt(i) => visitor.visit_i64(i),\n                N::Float(f) => visitor.visit_f64(f),\n            }\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_bool":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_byte_buf":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_bytes":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_char":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_enum":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_f32":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_f64":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i128":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i16":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i32":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i64":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i8":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_identifier":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_ignored_any":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_map":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_option":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_seq":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_str":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_string":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u128":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u16":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u32":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u64":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u8":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F> as std::fmt::Write>::write_str":["fn write_str(&mut self, s: &str) -> fmt::Result{\n                debug_assert!(self.error.is_none());\n                match format_escaped_str_contents(self.writer, self.formatter, s) {\n                    Ok(()) => Ok(()),\n                    Err(err) => {\n                        self.error = Some(err);\n                        Err(fmt::Error)\n                    }\n                }\n            }","Real(LocalPath(\"src/ser.rs\"))"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting":["fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n                formatter.write_str(\"a map\")\n            }","Real(LocalPath(\"src/map.rs\"))"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map":["#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[inline]\nfn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,{\n                let mut values = Map::new();\n\n                while let Some((key, value)) = tri!(visitor.next_entry()) {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }","Real(LocalPath(\"src/map.rs\"))"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit":["#[inline]\nfn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,{\n                Ok(Map::new())\n            }","Real(LocalPath(\"src/map.rs\"))"],"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::expecting":["fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n                formatter.write_str(\"a JSON number\")\n            }","Real(LocalPath(\"src/number.rs\"))"],"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_f64":["#[inline]\nfn visit_f64<E>(self, value: f64) -> Result<Number, E>\n            where\n                E: de::Error,{\n                Number::from_f64(value).ok_or_else(|| de::Error::custom(\"not a JSON number\"))\n            }","Real(LocalPath(\"src/number.rs\"))"],"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i64":["#[inline]\nfn visit_i64<E>(self, value: i64) -> Result<Number, E>{\n                Ok(value.into())\n            }","Real(LocalPath(\"src/number.rs\"))"],"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u64":["#[inline]\nfn visit_u64<E>(self, value: u64) -> Result<Number, E>{\n                Ok(value.into())\n            }","Real(LocalPath(\"src/number.rs\"))"],"<<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::flush":["fn flush(&mut self) -> io::Result<()>{\n                Ok(())\n            }","Real(LocalPath(\"src/value/mod.rs\"))"],"<<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::write":["fn write(&mut self, buf: &[u8]) -> io::Result<usize>{\n                // Safety: the serializer below only emits valid utf8 when using\n                // the default formatter.\n                let s = unsafe { str::from_utf8_unchecked(buf) };\n                tri!(self.inner.write_str(s).map_err(io_error));\n                Ok(buf.len())\n            }","Real(LocalPath(\"src/value/mod.rs\"))"],"<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed":["fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>>\n    where\n        K: de::DeserializeSeed<'de>,{\n        let peek = match tri!(self.de.parse_whitespace()) {\n            Some(b'}') => {\n                return Ok(None);\n            }\n            Some(b',') if !self.first => {\n                self.de.eat_char();\n                tri!(self.de.parse_whitespace())\n            }\n            Some(b) => {\n                if self.first {\n                    self.first = false;\n                    Some(b)\n                } else {\n                    return Err(self.de.peek_error(ErrorCode::ExpectedObjectCommaOrEnd));\n                }\n            }\n            None => {\n                return Err(self.de.peek_error(ErrorCode::EofWhileParsingObject));\n            }\n        };\n\n        match peek {\n            Some(b'\"') => seed.deserialize(MapKey { de: &mut *self.de }).map(Some),\n            Some(b'}') => Err(self.de.peek_error(ErrorCode::TrailingComma)),\n            Some(_) => Err(self.de.peek_error(ErrorCode::KeyMustBeAString)),\n            None => Err(self.de.peek_error(ErrorCode::EofWhileParsingValue)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_value_seed":["fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value>\n    where\n        V: de::DeserializeSeed<'de>,{\n        tri!(self.de.parse_object_colon());\n\n        seed.deserialize(&mut *self.de)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_any":["#[inline]\nfn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.de.eat_char();\n        self.de.scratch.clear();\n        match tri!(self.de.read.parse_str(&mut self.de.scratch)) {\n            Reference::Borrowed(s) => visitor.visit_borrowed_str(s),\n            Reference::Copied(s) => visitor.visit_str(s),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bool":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_byte_buf":["#[inline]\nfn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.de.deserialize_bytes(visitor)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bytes":["#[inline]\nfn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.de.deserialize_bytes(visitor)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_char":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_enum":["#[inline]\nfn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        self.de.deserialize_enum(name, variants, visitor)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i128":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n            self.de.scratch.clear();\n            let string = tri!(self.de.read.parse_str(&mut self.de.scratch));\n            match (string.parse(), string) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Reference::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                (Err(_), Reference::Copied(s)) => visitor.visit_str(s),\n            }\n        }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i16":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n            self.de.scratch.clear();\n            let string = tri!(self.de.read.parse_str(&mut self.de.scratch));\n            match (string.parse(), string) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Reference::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                (Err(_), Reference::Copied(s)) => visitor.visit_str(s),\n            }\n        }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i32":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n            self.de.scratch.clear();\n            let string = tri!(self.de.read.parse_str(&mut self.de.scratch));\n            match (string.parse(), string) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Reference::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                (Err(_), Reference::Copied(s)) => visitor.visit_str(s),\n            }\n        }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i64":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n            self.de.scratch.clear();\n            let string = tri!(self.de.read.parse_str(&mut self.de.scratch));\n            match (string.parse(), string) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Reference::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                (Err(_), Reference::Copied(s)) => visitor.visit_str(s),\n            }\n        }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i8":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n            self.de.scratch.clear();\n            let string = tri!(self.de.read.parse_str(&mut self.de.scratch));\n            match (string.parse(), string) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Reference::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                (Err(_), Reference::Copied(s)) => visitor.visit_str(s),\n            }\n        }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_identifier":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_ignored_any":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_map":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_newtype_struct":["#[inline]\nfn deserialize_newtype_struct<V>(self, name: &'static str, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        #[cfg(feature = \"raw_value\")]\n        {\n            if name == crate::raw::TOKEN {\n                return self.de.deserialize_raw_value(visitor);\n            }\n        }\n\n        let _ = name;\n        visitor.visit_newtype_struct(self)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_option":["#[inline]\nfn deserialize_option<V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        // Map keys cannot be null.\n        visitor.visit_some(self)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_seq":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_str":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_string":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u128":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n            self.de.scratch.clear();\n            let string = tri!(self.de.read.parse_str(&mut self.de.scratch));\n            match (string.parse(), string) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Reference::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                (Err(_), Reference::Copied(s)) => visitor.visit_str(s),\n            }\n        }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u16":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n            self.de.scratch.clear();\n            let string = tri!(self.de.read.parse_str(&mut self.de.scratch));\n            match (string.parse(), string) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Reference::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                (Err(_), Reference::Copied(s)) => visitor.visit_str(s),\n            }\n        }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u32":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n            self.de.scratch.clear();\n            let string = tri!(self.de.read.parse_str(&mut self.de.scratch));\n            match (string.parse(), string) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Reference::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                (Err(_), Reference::Copied(s)) => visitor.visit_str(s),\n            }\n        }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u64":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n            self.de.scratch.clear();\n            let string = tri!(self.de.read.parse_str(&mut self.de.scratch));\n            match (string.parse(), string) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Reference::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                (Err(_), Reference::Copied(s)) => visitor.visit_str(s),\n            }\n        }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u8":["fn $method<V>(self, visitor: V) -> Result<V::Value>\n        where\n            V: de::Visitor<'de>,{\n            self.de.eat_char();\n            self.de.scratch.clear();\n            let string = tri!(self.de.read.parse_str(&mut self.de.scratch));\n            match (string.parse(), string) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Reference::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                (Err(_), Reference::Copied(s)) => visitor.visit_str(s),\n            }\n        }","Real(LocalPath(\"src/de.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed":["fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n    where\n        T: de::DeserializeSeed<'de>,{\n        let peek = match tri!(self.de.parse_whitespace()) {\n            Some(b']') => {\n                return Ok(None);\n            }\n            Some(b',') if !self.first => {\n                self.de.eat_char();\n                tri!(self.de.parse_whitespace())\n            }\n            Some(b) => {\n                if self.first {\n                    self.first = false;\n                    Some(b)\n                } else {\n                    return Err(self.de.peek_error(ErrorCode::ExpectedListCommaOrEnd));\n                }\n            }\n            None => {\n                return Err(self.de.peek_error(ErrorCode::EofWhileParsingList));\n            }\n        };\n\n        match peek {\n            Some(b']') => Err(self.de.peek_error(ErrorCode::TrailingComma)),\n            Some(_) => Ok(Some(tri!(seed.deserialize(&mut *self.de)))),\n            None => Err(self.de.peek_error(ErrorCode::EofWhileParsingValue)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::StreamDeserializer<'de, R, T> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Result<T>>{\n        if R::should_early_return_if_failed && self.failed {\n            return None;\n        }\n\n        // skip whitespaces, if any\n        // this helps with trailing whitespaces, since whitespaces between\n        // values are handled for us.\n        match self.de.parse_whitespace() {\n            Ok(None) => {\n                self.offset = self.de.read.byte_offset();\n                None\n            }\n            Ok(Some(b)) => {\n                // If the value does not have a clear way to show the end of the value\n                // (like numbers, null, true etc.) we have to look for whitespace or\n                // the beginning of a self-delineated value.\n                let self_delineated_value = match b {\n                    b'[' | b'\"' | b'{' => true,\n                    _ => false,\n                };\n                self.offset = self.de.read.byte_offset();\n                let result = de::Deserialize::deserialize(&mut self.de);\n\n                Some(match result {\n                    Ok(value) => {\n                        self.offset = self.de.read.byte_offset();\n                        if self_delineated_value {\n                            Ok(value)\n                        } else {\n                            self.peek_end_of_value().map(|_| value)\n                        }\n                    }\n                    Err(e) => {\n                        self.de.read.set_failed(&mut self.failed);\n                        Err(e)\n                    }\n                })\n            }\n            Err(e) => {\n                self.de.read.set_failed(&mut self.failed);\n                Some(Err(e))\n            }\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::UnitVariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed":["fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self)>\n    where\n        V: de::DeserializeSeed<'de>,{\n        let variant = tri!(seed.deserialize(&mut *self.de));\n        Ok((variant, self))\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed":["fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value>\n    where\n        T: de::DeserializeSeed<'de>,{\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"newtype variant\",\n        ))\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant":["fn struct_variant<V>(self, _fields: &'static [&'static str], _visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"struct variant\",\n        ))\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant":["fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"tuple variant\",\n        ))\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant":["fn unit_variant(self) -> Result<()>{\n        Ok(())\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::VariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed":["fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self)>\n    where\n        V: de::DeserializeSeed<'de>,{\n        let val = tri!(seed.deserialize(&mut *self.de));\n        tri!(self.de.parse_object_colon());\n        Ok((val, self))\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed":["fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value>\n    where\n        T: de::DeserializeSeed<'de>,{\n        seed.deserialize(self.de)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant":["fn struct_variant<V>(self, fields: &'static [&'static str], visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        de::Deserializer::deserialize_struct(self.de, \"\", fields, visitor)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant":["fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        de::Deserializer::deserialize_seq(self.de, visitor)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant":["fn unit_variant(self) -> Result<()>{\n        de::Deserialize::deserialize(self.de)\n    }","Real(LocalPath(\"src/de.rs\"))"],"<error::Error as serde::de::Error>::custom":["#[cold]\nfn custom<T: Display>(msg: T) -> Error{\n        make_error(msg.to_string())\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as serde::de::Error>::invalid_type":["#[cold]\nfn invalid_type(unexp: de::Unexpected, exp: &dyn de::Expected) -> Self{\n        if let de::Unexpected::Unit = unexp {\n            Error::custom(format_args!(\"invalid type: null, expected {}\", exp))\n        } else {\n            Error::custom(format_args!(\"invalid type: {}, expected {}\", unexp, exp))\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as serde::ser::Error>::custom":["#[cold]\nfn custom<T: Display>(msg: T) -> Error{\n        make_error(msg.to_string())\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::error::Error>::source":["#[cfg(feature = \"std\")]\nfn source(&self) -> Option<&(dyn error::Error + 'static)>{\n        match &self.err.code {\n            ErrorCode::Io(err) => err.source(),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(\n            f,\n            \"Error({:?}, line: {}, column: {})\",\n            self.err.code.to_string(),\n            self.err.line,\n            self.err.column\n        )\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        Display::fmt(&*self.err, f)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::ErrorCode as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            ErrorCode::Message(msg) => f.write_str(msg),\n            ErrorCode::Io(err) => Display::fmt(err, f),\n            ErrorCode::EofWhileParsingList => f.write_str(\"EOF while parsing a list\"),\n            ErrorCode::EofWhileParsingObject => f.write_str(\"EOF while parsing an object\"),\n            ErrorCode::EofWhileParsingString => f.write_str(\"EOF while parsing a string\"),\n            ErrorCode::EofWhileParsingValue => f.write_str(\"EOF while parsing a value\"),\n            ErrorCode::ExpectedColon => f.write_str(\"expected `:`\"),\n            ErrorCode::ExpectedListCommaOrEnd => f.write_str(\"expected `,` or `]`\"),\n            ErrorCode::ExpectedObjectCommaOrEnd => f.write_str(\"expected `,` or `}`\"),\n            ErrorCode::ExpectedSomeIdent => f.write_str(\"expected ident\"),\n            ErrorCode::ExpectedSomeValue => f.write_str(\"expected value\"),\n            ErrorCode::InvalidEscape => f.write_str(\"invalid escape\"),\n            ErrorCode::InvalidNumber => f.write_str(\"invalid number\"),\n            ErrorCode::NumberOutOfRange => f.write_str(\"number out of range\"),\n            ErrorCode::InvalidUnicodeCodePoint => f.write_str(\"invalid unicode code point\"),\n            ErrorCode::ControlCharacterWhileParsingString => {\n                f.write_str(\"control character (\\\\u0000-\\\\u001F) found while parsing a string\")\n            }\n            ErrorCode::KeyMustBeAString => f.write_str(\"key must be a string\"),\n            ErrorCode::LoneLeadingSurrogateInHexEscape => {\n                f.write_str(\"lone leading surrogate in hex escape\")\n            }\n            ErrorCode::TrailingComma => f.write_str(\"trailing comma\"),\n            ErrorCode::TrailingCharacters => f.write_str(\"trailing characters\"),\n            ErrorCode::UnexpectedEndOfHexEscape => f.write_str(\"unexpected end of hex escape\"),\n            ErrorCode::RecursionLimitExceeded => f.write_str(\"recursion limit exceeded\"),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::ErrorImpl as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        if self.line == 0 {\n            Display::fmt(&self.code, f)\n        } else {\n            write!(\n                f,\n                \"{} at line {} column {}\",\n                self.code, self.line, self.column\n            )\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<iter::LineColIterator<I> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<io::Result<u8>>{\n        match self.iter.next() {\n            None => None,\n            Some(Ok(b'\\n')) => {\n                self.start_of_line += self.col + 1;\n                self.line += 1;\n                self.col = 0;\n                Some(Ok(b'\\n'))\n            }\n            Some(Ok(c)) => {\n                self.col += 1;\n                Some(Ok(c))\n            }\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"<map::IntoIter as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::IntoIter as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::IntoIter as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::IntoIter as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::Iter<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::Iter<'a> as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::Iter<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::Iter<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::IterMut<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::IterMut<'a> as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::IterMut<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::IterMut<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::Keys<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::Keys<'a> as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::Keys<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::Keys<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize":["#[inline]\nfn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: de::Deserializer<'de>,{\n        struct Visitor;\n\n        impl<'de> de::Visitor<'de> for Visitor {\n            type Value = Map<String, Value>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a map\")\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Self::Value, E>\n            where\n                E: de::Error,\n            {\n                Ok(Map::new())\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let mut values = Map::new();\n\n                while let Some((key, value)) = tri!(visitor.next_entry()) {\n                    values.insert(key, value);\n                }\n\n                Ok(values)\n            }\n        }\n\n        deserializer.deserialize_map(Visitor)\n    }","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor":["struct Visitor;","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize":["#[inline]\nfn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::ser::Serializer,{\n        use serde::ser::SerializeMap;\n        let mut map = tri!(serializer.serialize_map(Some(self.len())));\n        for (k, v) in self {\n            tri!(map.serialize_entry(k, v));\n        }\n        map.end()\n    }","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone":["#[inline]\nfn clone(&self) -> Self{\n        Map {\n            map: self.map.clone(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone_from":["#[inline]\nfn clone_from(&mut self, source: &Self){\n        self.map.clone_from(&source.map);\n    }","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::cmp::PartialEq>::eq":["#[inline]\nfn eq(&self, other: &Self) -> bool{\n        self.map.eq(&other.map)\n    }","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::default::Default>::default":["#[inline]\nfn default() -> Self{\n        Map {\n            map: MapImpl::new(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error>{\n        self.map.fmt(formatter)\n    }","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend":["fn extend<T>(&mut self, iter: T)\n    where\n        T: IntoIterator<Item = (String, Value)>,{\n        self.map.extend(iter);\n    }","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter":["fn from_iter<T>(iter: T) -> Self\n    where\n        T: IntoIterator<Item = (String, Value)>,{\n        Map {\n            map: FromIterator::from_iter(iter),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["#[inline]\nfn into_iter(self) -> Self::IntoIter{\n        IntoIter {\n            iter: self.map.into_iter(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index":["fn index(&self, index: &Q) -> &Value{\n        self.map.index(index)\n    }","Real(LocalPath(\"src/map.rs\"))"],"<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut":["fn index_mut(&mut self, index: &Q) -> &mut Value{\n        self.map.get_mut(index).expect(\"no entry found for key\")\n    }","Real(LocalPath(\"src/map.rs\"))"],"<map::Values<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::Values<'a> as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::Values<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::Values<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::ValuesMut<'a> as std::iter::DoubleEndedIterator>::next_back":["#[inline]\nfn next_back(&mut self) -> Option<Self::Item>{\n                self.iter.next_back()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::ValuesMut<'a> as std::iter::ExactSizeIterator>::len":["#[inline]\nfn len(&self) -> usize{\n                self.iter.len()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::ValuesMut<'a> as std::iter::Iterator>::next":["#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n                self.iter.next()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<map::ValuesMut<'a> as std::iter::Iterator>::size_hint":["#[inline]\nfn size_hint(&self) -> (usize, Option<usize>){\n                self.iter.size_hint()\n            }","Real(LocalPath(\"src/map.rs\"))"],"<number::N as std::cmp::PartialEq>::eq":["fn eq(&self, other: &Self) -> bool{\n        match (self, other) {\n            (N::PosInt(a), N::PosInt(b)) => a == b,\n            (N::NegInt(a), N::NegInt(b)) => a == b,\n            (N::Float(a), N::Float(b)) => a == b,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/number.rs\"))"],"<number::N as std::hash::Hash>::hash":["fn hash<H: Hasher>(&self, h: &mut H){\n        match *self {\n            N::PosInt(i) => i.hash(h),\n            N::NegInt(i) => i.hash(h),\n            N::Float(f) => {\n                if f == 0.0f64 {\n                    // There are 2 zero representations, +0 and -0, which\n                    // compare equal but have different bits. We use the +0 hash\n                    // for both so that hash(+0) == hash(-0).\n                    0.0f64.to_bits().hash(h);\n                } else {\n                    f.to_bits().hash(h);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserialize<'de>>::deserialize":["#[inline]\nfn deserialize<D>(deserializer: D) -> Result<Number, D::Error>\n    where\n        D: Deserializer<'de>,{\n        struct NumberVisitor;\n\n        impl<'de> Visitor<'de> for NumberVisitor {\n            type Value = Number;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a JSON number\")\n            }\n\n            #[inline]\n            fn visit_i64<E>(self, value: i64) -> Result<Number, E> {\n                Ok(value.into())\n            }\n\n            #[inline]\n            fn visit_u64<E>(self, value: u64) -> Result<Number, E> {\n                Ok(value.into())\n            }\n\n            #[inline]\n            fn visit_f64<E>(self, value: f64) -> Result<Number, E>\n            where\n                E: de::Error,\n            {\n                Number::from_f64(value).ok_or_else(|| de::Error::custom(\"not a JSON number\"))\n            }\n\n            #[cfg(feature = \"arbitrary_precision\")]\n            #[inline]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Number, V::Error>\n            where\n                V: de::MapAccess<'de>,\n            {\n                let value = visitor.next_key::<NumberKey>()?;\n                if value.is_none() {\n                    return Err(de::Error::invalid_type(Unexpected::Map, &self));\n                }\n                let v: NumberFromString = visitor.next_value()?;\n                Ok(v.value)\n            }\n        }\n\n        deserializer.deserialize_any(NumberVisitor)\n    }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor":["struct NumberVisitor;","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_any":["#[cfg(not(feature = \"arbitrary_precision\"))]\n#[inline]\nfn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self.n {\n                N::PosInt(u) => visitor.visit_u64(u),\n                N::NegInt(i) => visitor.visit_i64(i),\n                N::Float(f) => visitor.visit_f64(f),\n            }\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_bool":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_byte_buf":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_bytes":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_char":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_enum":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_f32":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_f64":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_i128":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_i16":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_i32":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_i64":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_i8":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_identifier":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_ignored_any":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_map":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_option":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_seq":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_str":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_string":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_tuple":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_u128":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_u16":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_u32":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_u64":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_u8":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_unit":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Deserializer<'de>>::deserialize_unit_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<number::Number as serde::Serialize>::serialize":["#[cfg(not(feature = \"arbitrary_precision\"))]\n#[inline]\nfn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,{\n        match self.n {\n            N::PosInt(u) => serializer.serialize_u64(u),\n            N::NegInt(i) => serializer.serialize_i64(i),\n            N::Float(f) => serializer.serialize_f64(f),\n        }\n    }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::convert::From<de::ParserNumber>>::from":["fn from(value: ParserNumber) -> Self{\n        let n = match value {\n            ParserNumber::F64(f) => {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::Float(f)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    f.to_string()\n                }\n            }\n            ParserNumber::U64(u) => {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::PosInt(u)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    u.to_string()\n                }\n            }\n            ParserNumber::I64(i) => {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::NegInt(i)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    i.to_string()\n                }\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            ParserNumber::String(s) => s,\n        };\n        Number { n }\n    }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::convert::From<i16>>::from":["#[inline]\nfn from(i: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        {\n                            if i < 0 {\n                                N::NegInt(i as i64)\n                            } else {\n                                N::PosInt(i as u64)\n                            }\n                        }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(i).to_owned()\n                        }\n                    };\n                    Number { n }\n                }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::convert::From<i32>>::from":["#[inline]\nfn from(i: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        {\n                            if i < 0 {\n                                N::NegInt(i as i64)\n                            } else {\n                                N::PosInt(i as u64)\n                            }\n                        }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(i).to_owned()\n                        }\n                    };\n                    Number { n }\n                }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::convert::From<i64>>::from":["#[inline]\nfn from(i: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        {\n                            if i < 0 {\n                                N::NegInt(i as i64)\n                            } else {\n                                N::PosInt(i as u64)\n                            }\n                        }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(i).to_owned()\n                        }\n                    };\n                    Number { n }\n                }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::convert::From<i8>>::from":["#[inline]\nfn from(i: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        {\n                            if i < 0 {\n                                N::NegInt(i as i64)\n                            } else {\n                                N::PosInt(i as u64)\n                            }\n                        }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(i).to_owned()\n                        }\n                    };\n                    Number { n }\n                }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::convert::From<isize>>::from":["#[inline]\nfn from(i: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        {\n                            if i < 0 {\n                                N::NegInt(i as i64)\n                            } else {\n                                N::PosInt(i as u64)\n                            }\n                        }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(i).to_owned()\n                        }\n                    };\n                    Number { n }\n                }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::convert::From<u16>>::from":["#[inline]\nfn from(u: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        { N::PosInt(u as u64) }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(u).to_owned()\n                        }\n                    };\n                    Number { n }\n                }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::convert::From<u32>>::from":["#[inline]\nfn from(u: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        { N::PosInt(u as u64) }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(u).to_owned()\n                        }\n                    };\n                    Number { n }\n                }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::convert::From<u64>>::from":["#[inline]\nfn from(u: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        { N::PosInt(u as u64) }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(u).to_owned()\n                        }\n                    };\n                    Number { n }\n                }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::convert::From<u8>>::from":["#[inline]\nfn from(u: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        { N::PosInt(u as u64) }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(u).to_owned()\n                        }\n                    };\n                    Number { n }\n                }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::convert::From<usize>>::from":["#[inline]\nfn from(u: $ty) -> Self{\n                    let n = {\n                        #[cfg(not(feature = \"arbitrary_precision\"))]\n                        { N::PosInt(u as u64) }\n                        #[cfg(feature = \"arbitrary_precision\")]\n                        {\n                            itoa::Buffer::new().format(u).to_owned()\n                        }\n                    };\n                    Number { n }\n                }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::fmt::Debug>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        write!(formatter, \"Number({})\", self)\n    }","Real(LocalPath(\"src/number.rs\"))"],"<number::Number as std::fmt::Display>::fmt":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        match self.n {\n            N::PosInt(u) => formatter.write_str(itoa::Buffer::new().format(u)),\n            N::NegInt(i) => formatter.write_str(itoa::Buffer::new().format(i)),\n            N::Float(f) => formatter.write_str(ryu::Buffer::new().format_finite(f)),\n        }\n    }","Real(LocalPath(\"src/number.rs\"))"],"<read::IoRead<R> as read::Read<'de>>::byte_offset":["fn byte_offset(&self) -> usize{\n        match self.ch {\n            Some(_) => self.iter.byte_offset() - 1,\n            None => self.iter.byte_offset(),\n        }\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::IoRead<R> as read::Read<'de>>::decode_hex_escape":["fn decode_hex_escape(&mut self) -> Result<u16>{\n        let mut n = 0;\n        for _ in 0..4 {\n            match decode_hex_val(tri!(next_or_eof(self))) {\n                None => return error(self, ErrorCode::InvalidEscape),\n                Some(val) => {\n                    n = (n << 4) + val;\n                }\n            }\n        }\n        Ok(n)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::IoRead<R> as read::Read<'de>>::discard":["#[cfg(not(feature = \"raw_value\"))]\n#[inline]\nfn discard(&mut self){\n        self.ch = None;\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::IoRead<R> as read::Read<'de>>::ignore_str":["fn ignore_str(&mut self) -> Result<()>{\n        loop {\n            let ch = tri!(next_or_eof(self));\n            if !ESCAPE[ch as usize] {\n                continue;\n            }\n            match ch {\n                b'\"' => {\n                    return Ok(());\n                }\n                b'\\\\' => {\n                    tri!(ignore_escape(self));\n                }\n                _ => {\n                    return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::IoRead<R> as read::Read<'de>>::next":["#[inline]\nfn next(&mut self) -> Result<Option<u8>>{\n        match self.ch.take() {\n            Some(ch) => {\n                #[cfg(feature = \"raw_value\")]\n                {\n                    if let Some(buf) = &mut self.raw_buffer {\n                        buf.push(ch);\n                    }\n                }\n                Ok(Some(ch))\n            }\n            None => match self.iter.next() {\n                Some(Err(err)) => Err(Error::io(err)),\n                Some(Ok(ch)) => {\n                    #[cfg(feature = \"raw_value\")]\n                    {\n                        if let Some(buf) = &mut self.raw_buffer {\n                            buf.push(ch);\n                        }\n                    }\n                    Ok(Some(ch))\n                }\n                None => Ok(None),\n            },\n        }\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::IoRead<R> as read::Read<'de>>::parse_str":["fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>>{\n        self.parse_str_bytes(scratch, true, as_str)\n            .map(Reference::Copied)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::IoRead<R> as read::Read<'de>>::parse_str_raw":["fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, [u8]>>{\n        self.parse_str_bytes(scratch, false, |_, bytes| Ok(bytes))\n            .map(Reference::Copied)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::IoRead<R> as read::Read<'de>>::peek":["#[inline]\nfn peek(&mut self) -> Result<Option<u8>>{\n        match self.ch {\n            Some(ch) => Ok(Some(ch)),\n            None => match self.iter.next() {\n                Some(Err(err)) => Err(Error::io(err)),\n                Some(Ok(ch)) => {\n                    self.ch = Some(ch);\n                    Ok(self.ch)\n                }\n                None => Ok(None),\n            },\n        }\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::IoRead<R> as read::Read<'de>>::peek_position":["fn peek_position(&self) -> Position{\n        // The LineColIterator updates its position during peek() so it has the\n        // right one here.\n        self.position()\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::IoRead<R> as read::Read<'de>>::position":["fn position(&self) -> Position{\n        Position {\n            line: self.iter.line(),\n            column: self.iter.col(),\n        }\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::IoRead<R> as read::Read<'de>>::set_failed":["#[inline]\n#[cold]\nfn set_failed(&mut self, failed: &mut bool){\n        *failed = true;\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::Reference<'b, 'c, T> as std::ops::Deref>::deref":["fn deref(&self) -> &Self::Target{\n        match *self {\n            Reference::Borrowed(b) => b,\n            Reference::Copied(c) => c,\n        }\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::SliceRead<'a> as read::Read<'a>>::byte_offset":["fn byte_offset(&self) -> usize{\n        self.index\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::SliceRead<'a> as read::Read<'a>>::decode_hex_escape":["fn decode_hex_escape(&mut self) -> Result<u16>{\n        if self.index + 4 > self.slice.len() {\n            self.index = self.slice.len();\n            return error(self, ErrorCode::EofWhileParsingString);\n        }\n\n        let mut n = 0;\n        for _ in 0..4 {\n            let ch = decode_hex_val(self.slice[self.index]);\n            self.index += 1;\n            match ch {\n                None => return error(self, ErrorCode::InvalidEscape),\n                Some(val) => {\n                    n = (n << 4) + val;\n                }\n            }\n        }\n        Ok(n)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::SliceRead<'a> as read::Read<'a>>::discard":["#[inline]\nfn discard(&mut self){\n        self.index += 1;\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::SliceRead<'a> as read::Read<'a>>::ignore_str":["fn ignore_str(&mut self) -> Result<()>{\n        loop {\n            while self.index < self.slice.len() && !ESCAPE[self.slice[self.index] as usize] {\n                self.index += 1;\n            }\n            if self.index == self.slice.len() {\n                return error(self, ErrorCode::EofWhileParsingString);\n            }\n            match self.slice[self.index] {\n                b'\"' => {\n                    self.index += 1;\n                    return Ok(());\n                }\n                b'\\\\' => {\n                    self.index += 1;\n                    tri!(ignore_escape(self));\n                }\n                _ => {\n                    return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::SliceRead<'a> as read::Read<'a>>::next":["#[inline]\nfn next(&mut self) -> Result<Option<u8>>{\n        // `Ok(self.slice.get(self.index).map(|ch| { self.index += 1; *ch }))`\n        // is about 10% slower.\n        Ok(if self.index < self.slice.len() {\n            let ch = self.slice[self.index];\n            self.index += 1;\n            Some(ch)\n        } else {\n            None\n        })\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::SliceRead<'a> as read::Read<'a>>::parse_str":["fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>>{\n        self.parse_str_bytes(scratch, true, as_str)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::SliceRead<'a> as read::Read<'a>>::parse_str_raw":["fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'a, 's, [u8]>>{\n        self.parse_str_bytes(scratch, false, |_, bytes| Ok(bytes))\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::SliceRead<'a> as read::Read<'a>>::peek":["#[inline]\nfn peek(&mut self) -> Result<Option<u8>>{\n        // `Ok(self.slice.get(self.index).map(|ch| *ch))` is about 10% slower\n        // for some reason.\n        Ok(if self.index < self.slice.len() {\n            Some(self.slice[self.index])\n        } else {\n            None\n        })\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::SliceRead<'a> as read::Read<'a>>::peek_position":["fn peek_position(&self) -> Position{\n        // Cap it at slice.len() just in case the most recent call was next()\n        // and it returned the last byte.\n        self.position_of_index(cmp::min(self.slice.len(), self.index + 1))\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::SliceRead<'a> as read::Read<'a>>::position":["fn position(&self) -> Position{\n        self.position_of_index(self.index)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::SliceRead<'a> as read::Read<'a>>::set_failed":["#[inline]\n#[cold]\nfn set_failed(&mut self, _failed: &mut bool){\n        self.slice = &self.slice[..self.index];\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::StrRead<'a> as read::Read<'a>>::byte_offset":["fn byte_offset(&self) -> usize{\n        self.delegate.byte_offset()\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::StrRead<'a> as read::Read<'a>>::decode_hex_escape":["fn decode_hex_escape(&mut self) -> Result<u16>{\n        self.delegate.decode_hex_escape()\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::StrRead<'a> as read::Read<'a>>::discard":["#[inline]\nfn discard(&mut self){\n        self.delegate.discard();\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::StrRead<'a> as read::Read<'a>>::ignore_str":["fn ignore_str(&mut self) -> Result<()>{\n        self.delegate.ignore_str()\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::StrRead<'a> as read::Read<'a>>::next":["#[inline]\nfn next(&mut self) -> Result<Option<u8>>{\n        self.delegate.next()\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::StrRead<'a> as read::Read<'a>>::parse_str":["fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'a, 's, str>>{\n        self.delegate.parse_str_bytes(scratch, true, |_, bytes| {\n            // The deserialization input came in as &str with a UTF-8 guarantee,\n            // and the \\u-escapes are checked along the way, so don't need to\n            // check here.\n            Ok(unsafe { str::from_utf8_unchecked(bytes) })\n        })\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::StrRead<'a> as read::Read<'a>>::parse_str_raw":["fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'a, 's, [u8]>>{\n        self.delegate.parse_str_raw(scratch)\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::StrRead<'a> as read::Read<'a>>::peek":["#[inline]\nfn peek(&mut self) -> Result<Option<u8>>{\n        self.delegate.peek()\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::StrRead<'a> as read::Read<'a>>::peek_position":["fn peek_position(&self) -> Position{\n        self.delegate.peek_position()\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::StrRead<'a> as read::Read<'a>>::position":["fn position(&self) -> Position{\n        self.delegate.position()\n    }","Real(LocalPath(\"src/read.rs\"))"],"<read::StrRead<'a> as read::Read<'a>>::set_failed":["#[inline]\n#[cold]\nfn set_failed(&mut self, failed: &mut bool){\n        self.delegate.set_failed(failed);\n    }","Real(LocalPath(\"src/read.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::end":["#[inline]\nfn end(self) -> Result<()>{\n        match self {\n            Compound::Map { ser, state } => match state {\n                State::Empty => Ok(()),\n                _ => ser.formatter.end_object(&mut ser.writer).map_err(Error::io),\n            },\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_key":["#[inline]\nfn serialize_key<T>(&mut self, key: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            Compound::Map { ser, state } => {\n                tri!(ser\n                    .formatter\n                    .begin_object_key(&mut ser.writer, *state == State::First)\n                    .map_err(Error::io));\n                *state = State::Rest;\n\n                tri!(key.serialize(MapKeySerializer { ser: *ser }));\n\n                ser.formatter\n                    .end_object_key(&mut ser.writer)\n                    .map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_value":["#[inline]\nfn serialize_value<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            Compound::Map { ser, .. } => {\n                tri!(ser\n                    .formatter\n                    .begin_object_value(&mut ser.writer)\n                    .map_err(Error::io));\n                tri!(value.serialize(&mut **ser));\n                ser.formatter\n                    .end_object_value(&mut ser.writer)\n                    .map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::end":["#[inline]\nfn end(self) -> Result<()>{\n        match self {\n            Compound::Map { ser, state } => match state {\n                State::Empty => Ok(()),\n                _ => ser.formatter.end_array(&mut ser.writer).map_err(Error::io),\n            },\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::serialize_element":["#[inline]\nfn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            Compound::Map { ser, state } => {\n                tri!(ser\n                    .formatter\n                    .begin_array_value(&mut ser.writer, *state == State::First)\n                    .map_err(Error::io));\n                *state = State::Rest;\n                tri!(value.serialize(&mut **ser));\n                ser.formatter\n                    .end_array_value(&mut ser.writer)\n                    .map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::end":["#[inline]\nfn end(self) -> Result<()>{\n        match self {\n            Compound::Map { .. } => ser::SerializeMap::end(self),\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => Ok(()),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => Ok(()),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::serialize_field":["#[inline]\nfn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            Compound::Map { .. } => ser::SerializeMap::serialize_entry(self, key, value),\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { ser, .. } => {\n                if key == crate::number::TOKEN {\n                    value.serialize(NumberStrEmitter(ser))\n                } else {\n                    Err(invalid_number())\n                }\n            }\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { ser, .. } => {\n                if key == crate::raw::TOKEN {\n                    value.serialize(RawValueStrEmitter(ser))\n                } else {\n                    Err(invalid_raw_value())\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::end":["#[inline]\nfn end(self) -> Result<()>{\n        match self {\n            Compound::Map { ser, state } => {\n                match state {\n                    State::Empty => {}\n                    _ => tri!(ser.formatter.end_object(&mut ser.writer).map_err(Error::io)),\n                }\n                tri!(ser\n                    .formatter\n                    .end_object_value(&mut ser.writer)\n                    .map_err(Error::io));\n                ser.formatter.end_object(&mut ser.writer).map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::serialize_field":["#[inline]\nfn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match *self {\n            Compound::Map { .. } => ser::SerializeStruct::serialize_field(self, key, value),\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::end":["#[inline]\nfn end(self) -> Result<()>{\n        ser::SerializeSeq::end(self)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::serialize_element":["#[inline]\nfn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        ser::SerializeSeq::serialize_element(self, value)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::end":["#[inline]\nfn end(self) -> Result<()>{\n        ser::SerializeSeq::end(self)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::serialize_field":["#[inline]\nfn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        ser::SerializeSeq::serialize_element(self, value)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::end":["#[inline]\nfn end(self) -> Result<()>{\n        match self {\n            Compound::Map { ser, state } => {\n                match state {\n                    State::Empty => {}\n                    _ => tri!(ser.formatter.end_array(&mut ser.writer).map_err(Error::io)),\n                }\n                tri!(ser\n                    .formatter\n                    .end_object_value(&mut ser.writer)\n                    .map_err(Error::io));\n                ser.formatter.end_object(&mut ser.writer).map_err(Error::io)\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            Compound::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            Compound::RawValue { .. } => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::serialize_field":["#[inline]\nfn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        ser::SerializeSeq::serialize_element(self, value)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::collect_str":["fn collect_str<T>(self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Display,{\n        self.ser.collect_str(value)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bool":["fn serialize_bool(self, _value: bool) -> Result<()>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bytes":["fn serialize_bytes(self, _value: &[u8]) -> Result<()>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_char":["fn serialize_char(self, value: char) -> Result<()>{\n        self.ser.serialize_str(&value.to_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f32":["fn serialize_f32(self, _value: f32) -> Result<()>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f64":["fn serialize_f64(self, _value: f64) -> Result<()>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i128":["fn serialize_i128(self, value: i128) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i128(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i16":["fn serialize_i16(self, value: i16) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i16(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i32":["fn serialize_i32(self, value: i32) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i32(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i64":["fn serialize_i64(self, value: i64) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i64(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i8":["fn serialize_i8(self, value: i8) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_i8(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_map":["fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_struct":["#[inline]\nfn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_variant":["fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _value: &T,\n    ) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_none":["fn serialize_none(self) -> Result<()>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_seq":["fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_some":["fn serialize_some<T>(self, _value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_str":["#[inline]\nfn serialize_str(self, value: &str) -> Result<()>{\n        self.ser.serialize_str(value)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct":["fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct_variant":["fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple":["fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_struct":["fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_variant":["fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u128":["fn serialize_u128(self, value: u128) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u128(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u16":["fn serialize_u16(self, value: u16) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u16(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u32":["fn serialize_u32(self, value: u32) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u32(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u64":["fn serialize_u64(self, value: u64) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u64(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u8":["fn serialize_u8(self, value: u8) -> Result<()>{\n        tri!(self\n            .ser\n            .formatter\n            .begin_string(&mut self.ser.writer)\n            .map_err(Error::io));\n        tri!(self\n            .ser\n            .formatter\n            .write_u8(&mut self.ser.writer, value)\n            .map_err(Error::io));\n        self.ser\n            .formatter\n            .end_string(&mut self.ser.writer)\n            .map_err(Error::io)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit":["fn serialize_unit(self) -> Result<()>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_struct":["fn serialize_unit_struct(self, _name: &'static str) -> Result<()>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_variant":["#[inline]\nfn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<()>{\n        self.ser.serialize_str(variant)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array":["#[inline]\nfn begin_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        self.current_indent += 1;\n        self.has_value = false;\n        writer.write_all(b\"[\")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array_value":["#[inline]\nfn begin_array_value<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        tri!(writer.write_all(if first { b\"\\n\" } else { b\",\\n\" }));\n        indent(writer, self.current_indent, self.indent)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object":["#[inline]\nfn begin_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        self.current_indent += 1;\n        self.has_value = false;\n        writer.write_all(b\"{\")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_key":["#[inline]\nfn begin_object_key<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        tri!(writer.write_all(if first { b\"\\n\" } else { b\",\\n\" }));\n        indent(writer, self.current_indent, self.indent)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_value":["#[inline]\nfn begin_object_value<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\": \")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::PrettyFormatter<'a> as ser::Formatter>::end_array":["#[inline]\nfn end_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        self.current_indent -= 1;\n\n        if self.has_value {\n            tri!(writer.write_all(b\"\\n\"));\n            tri!(indent(writer, self.current_indent, self.indent));\n        }\n\n        writer.write_all(b\"]\")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::PrettyFormatter<'a> as ser::Formatter>::end_array_value":["#[inline]\nfn end_array_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        self.has_value = true;\n        Ok(())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::PrettyFormatter<'a> as ser::Formatter>::end_object":["#[inline]\nfn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        self.current_indent -= 1;\n\n        if self.has_value {\n            tri!(writer.write_all(b\"\\n\"));\n            tri!(indent(writer, self.current_indent, self.indent));\n        }\n\n        writer.write_all(b\"}\")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::PrettyFormatter<'a> as ser::Formatter>::end_object_value":["#[inline]\nfn end_object_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        self.has_value = true;\n        Ok(())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<ser::PrettyFormatter<'a> as std::default::Default>::default":["fn default() -> Self{\n        PrettyFormatter::new()\n    }","Real(LocalPath(\"src/ser.rs\"))"],"<std::string::String as value::index::Index>::index_into":["fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>{\n        self[..].index_into(v)\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<std::string::String as value::index::Index>::index_into_mut":["fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>{\n        self[..].index_into_mut(v)\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<std::string::String as value::index::Index>::index_or_insert":["fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value{\n        self[..].index_or_insert(v)\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<str as value::index::Index>::index_into":["fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>{\n        match v {\n            Value::Object(map) => map.get(self),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<str as value::index::Index>::index_into_mut":["fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>{\n        match v {\n            Value::Object(map) => map.get_mut(self),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<str as value::index::Index>::index_or_insert":["fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value{\n        if let Value::Null = v {\n            *v = Value::Object(Map::new());\n        }\n        match v {\n            Value::Object(map) => map.entry(self.to_owned()).or_insert(Value::Null),\n            _ => panic!(\"cannot access key {:?} in JSON {}\", self, Type(v)),\n        }\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<usize as value::index::Index>::index_into":["fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>{\n        match v {\n            Value::Array(vec) => vec.get(*self),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<usize as value::index::Index>::index_into_mut":["fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>{\n        match v {\n            Value::Array(vec) => vec.get_mut(*self),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<usize as value::index::Index>::index_or_insert":["fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value{\n        match v {\n            Value::Array(vec) => {\n                let len = vec.len();\n                vec.get_mut(*self).unwrap_or_else(|| {\n                    panic!(\n                        \"cannot access index {} of JSON array of length {}\",\n                        self, len\n                    )\n                })\n            }\n            _ => panic!(\"cannot access index {} of JSON {}\", self, Type(v)),\n        }\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<value::Value as std::default::Default>::default":["fn default() -> Value{\n        Value::Null\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"<value::Value as std::fmt::Debug>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        match self {\n            Value::Null => formatter.write_str(\"Null\"),\n            Value::Bool(boolean) => write!(formatter, \"Bool({})\", boolean),\n            Value::Number(number) => Debug::fmt(number, formatter),\n            Value::String(string) => write!(formatter, \"String({:?})\", string),\n            Value::Array(vec) => {\n                formatter.write_str(\"Array \")?;\n                Debug::fmt(vec, formatter)\n            }\n            Value::Object(map) => {\n                formatter.write_str(\"Object \")?;\n                Debug::fmt(map, formatter)\n            }\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"<value::Value as std::fmt::Display>::fmt":["/// Display a JSON value as a string.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let json = json!({ \"city\": \"London\", \"street\": \"10 Downing Street\" });\n///\n/// // Compact format:\n/// //\n/// // {\"city\":\"London\",\"street\":\"10 Downing Street\"}\n/// let compact = format!(\"{}\", json);\n/// assert_eq!(compact,\n///     \"{\\\"city\\\":\\\"London\\\",\\\"street\\\":\\\"10 Downing Street\\\"}\");\n///\n/// // Pretty format:\n/// //\n/// // {\n/// //   \"city\": \"London\",\n/// //   \"street\": \"10 Downing Street\"\n/// // }\n/// let pretty = format!(\"{:#}\", json);\n/// assert_eq!(pretty,\n///     \"{\\n  \\\"city\\\": \\\"London\\\",\\n  \\\"street\\\": \\\"10 Downing Street\\\"\\n}\");\n/// ```\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        struct WriterFormatter<'a, 'b: 'a> {\n            inner: &'a mut fmt::Formatter<'b>,\n        }\n\n        impl<'a, 'b> io::Write for WriterFormatter<'a, 'b> {\n            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n                // Safety: the serializer below only emits valid utf8 when using\n                // the default formatter.\n                let s = unsafe { str::from_utf8_unchecked(buf) };\n                tri!(self.inner.write_str(s).map_err(io_error));\n                Ok(buf.len())\n            }\n\n            fn flush(&mut self) -> io::Result<()> {\n                Ok(())\n            }\n        }\n\n        fn io_error(_: fmt::Error) -> io::Error {\n            // Error value does not matter because Display impl just maps it\n            // back to fmt::Error.\n            io::Error::new(io::ErrorKind::Other, \"fmt error\")\n        }\n\n        let alternate = f.alternate();\n        let mut wr = WriterFormatter { inner: f };\n        if alternate {\n            // {:#}\n            super::ser::to_writer_pretty(&mut wr, self).map_err(|_| fmt::Error)\n        } else {\n            // {}\n            super::ser::to_writer(&mut wr, self).map_err(|_| fmt::Error)\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"<value::Value as std::fmt::Display>::fmt::WriterFormatter":["struct WriterFormatter<'a, 'b: 'a> {\n            inner: &'a mut fmt::Formatter<'b>,\n        }","Real(LocalPath(\"src/value/mod.rs\"))"],"<value::Value as std::fmt::Display>::fmt::io_error":["fn io_error(_: fmt::Error) -> io::Error{\n            // Error value does not matter because Display impl just maps it\n            // back to fmt::Error.\n            io::Error::new(io::ErrorKind::Other, \"fmt error\")\n        }","Real(LocalPath(\"src/value/mod.rs\"))"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting":["fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n                formatter.write_str(\"any valid JSON value\")\n            }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool":["#[inline]\nfn visit_bool<E>(self, value: bool) -> Result<Value, E>{\n                Ok(Value::Bool(value))\n            }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64":["#[inline]\nfn visit_f64<E>(self, value: f64) -> Result<Value, E>{\n                Ok(Number::from_f64(value).map_or(Value::Null, Value::Number))\n            }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64":["#[inline]\nfn visit_i64<E>(self, value: i64) -> Result<Value, E>{\n                Ok(Value::Number(value.into()))\n            }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map":["#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nfn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: MapAccess<'de>,{\n                match visitor.next_key_seed(KeyClassifier)? {\n                    #[cfg(feature = \"arbitrary_precision\")]\n                    Some(KeyClass::Number) => {\n                        let number: NumberFromString = visitor.next_value()?;\n                        Ok(Value::Number(number.value))\n                    }\n                    #[cfg(feature = \"raw_value\")]\n                    Some(KeyClass::RawValue) => {\n                        let value = visitor.next_value_seed(crate::raw::BoxedFromString)?;\n                        crate::from_str(value.get()).map_err(de::Error::custom)\n                    }\n                    Some(KeyClass::Map(first_key)) => {\n                        let mut values = Map::new();\n\n                        values.insert(first_key, tri!(visitor.next_value()));\n                        while let Some((key, value)) = tri!(visitor.next_entry()) {\n                            values.insert(key, value);\n                        }\n\n                        Ok(Value::Object(values))\n                    }\n                    None => Ok(Value::Object(Map::new())),\n                }\n            }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_none":["#[inline]\nfn visit_none<E>(self) -> Result<Value, E>{\n                Ok(Value::Null)\n            }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq":["#[inline]\nfn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: SeqAccess<'de>,{\n                let mut vec = Vec::new();\n\n                while let Some(elem) = tri!(visitor.next_element()) {\n                    vec.push(elem);\n                }\n\n                Ok(Value::Array(vec))\n            }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some":["#[inline]\nfn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: serde::Deserializer<'de>,{\n                Deserialize::deserialize(deserializer)\n            }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str":["#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[inline]\nfn visit_str<E>(self, value: &str) -> Result<Value, E>\n            where\n                E: serde::de::Error,{\n                self.visit_string(String::from(value))\n            }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string":["#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[inline]\nfn visit_string<E>(self, value: String) -> Result<Value, E>{\n                Ok(Value::String(value))\n            }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64":["#[inline]\nfn visit_u64<E>(self, value: u64) -> Result<Value, E>{\n                Ok(Value::Number(value.into()))\n            }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_unit":["#[inline]\nfn visit_unit<E>(self) -> Result<Value, E>{\n                Ok(Value::Null)\n            }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any":["fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,{\n        match self.value {\n            Cow::Borrowed(string) => visitor.visit_borrowed_str(string),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Cow::Owned(string) => visitor.visit_string(string),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum":["fn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,{\n        visitor.visit_enum(self)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed":["fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Error>\n    where\n        T: de::DeserializeSeed<'de>,{\n        let value = seed.deserialize(self)?;\n        Ok((value, UnitOnly))\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::EnumDeserializer as serde::de::EnumAccess<'de>>::variant_seed":["fn variant_seed<V>(self, seed: V) -> Result<(V::Value, VariantDeserializer), Error>\n    where\n        V: DeserializeSeed<'de>,{\n        let variant = self.variant.into_deserializer();\n        let visitor = VariantDeserializer { value: self.value };\n        seed.deserialize(variant).map(|v| (v, visitor))\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::EnumRefDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed":["fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Error>\n    where\n        V: DeserializeSeed<'de>,{\n        let variant = self.variant.into_deserializer();\n        let visitor = VariantRefDeserializer { value: self.value };\n        seed.deserialize(variant).map(|v| (v, visitor))\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::KeyClassifier as serde::de::DeserializeSeed<'de>>::deserialize":["fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: serde::Deserializer<'de>,{\n        deserializer.deserialize_str(self)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::KeyClassifier as serde::de::Visitor<'de>>::expecting":["fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        formatter.write_str(\"a string key\")\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_str":["fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n    where\n        E: de::Error,{\n        match s {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(KeyClass::Number),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(KeyClass::RawValue),\n            _ => Ok(KeyClass::Map(s.to_owned())),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_string":["#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nfn visit_string<E>(self, s: String) -> Result<Self::Value, E>\n    where\n        E: de::Error,{\n        match s.as_str() {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(KeyClass::Number),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(KeyClass::RawValue),\n            _ => Ok(KeyClass::Map(s)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed":["fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.iter.next() {\n            Some((key, value)) => {\n                self.value = Some(value);\n                let key_de = MapKeyDeserializer {\n                    key: Cow::Owned(key),\n                };\n                seed.deserialize(key_de).map(Some)\n            }\n            None => Ok(None),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed":["fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.value.take() {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::custom(\"value is missing\")),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::size_hint":["fn size_hint(&self) -> Option<usize>{\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any":["fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        BorrowedCowStrDeserializer::new(self.key).deserialize_any(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum":["fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.key\n            .into_deserializer()\n            .deserialize_enum(name, variants, visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128":["fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match (self.key.parse(), self.key) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n                (Err(_), Cow::Owned(s)) => visitor.visit_string(s),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16":["fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match (self.key.parse(), self.key) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n                (Err(_), Cow::Owned(s)) => visitor.visit_string(s),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32":["fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match (self.key.parse(), self.key) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n                (Err(_), Cow::Owned(s)) => visitor.visit_string(s),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64":["fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match (self.key.parse(), self.key) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n                (Err(_), Cow::Owned(s)) => visitor.visit_string(s),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8":["fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match (self.key.parse(), self.key) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n                (Err(_), Cow::Owned(s)) => visitor.visit_string(s),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct":["#[inline]\nfn deserialize_newtype_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        visitor.visit_newtype_struct(self)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option":["#[inline]\nfn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        // Map keys cannot be null.\n        visitor.visit_some(self)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128":["fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match (self.key.parse(), self.key) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n                (Err(_), Cow::Owned(s)) => visitor.visit_string(s),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16":["fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match (self.key.parse(), self.key) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n                (Err(_), Cow::Owned(s)) => visitor.visit_string(s),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32":["fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match (self.key.parse(), self.key) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n                (Err(_), Cow::Owned(s)) => visitor.visit_string(s),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64":["fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match (self.key.parse(), self.key) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n                (Err(_), Cow::Owned(s)) => visitor.visit_string(s),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8":["fn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match (self.key.parse(), self.key) {\n                (Ok(integer), _) => visitor.$visit(integer),\n                (Err(_), Cow::Borrowed(s)) => visitor.visit_borrowed_str(s),\n                #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n                (Err(_), Cow::Owned(s)) => visitor.visit_string(s),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct":["#[inline]\nfn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::__private::Result<$v::Value, <Self as $crate::de::Deserializer<$l>>::Error>\n        where\n            $v: $crate::de::Visitor<$l>,{\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))"],"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_key_seed":["fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.iter.next() {\n            Some((key, value)) => {\n                self.value = Some(value);\n                let key_de = MapKeyDeserializer {\n                    key: Cow::Borrowed(&**key),\n                };\n                seed.deserialize(key_de).map(Some)\n            }\n            None => Ok(None),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_value_seed":["fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.value.take() {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::custom(\"value is missing\")),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::size_hint":["fn size_hint(&self) -> Option<usize>{\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed":["fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.iter.next() {\n            Some(value) => seed.deserialize(value).map(Some),\n            None => Ok(None),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint":["fn size_hint(&self) -> Option<usize>{\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::next_element_seed":["fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.iter.next() {\n            Some(value) => seed.deserialize(value).map(Some),\n            None => Ok(None),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::size_hint":["fn size_hint(&self) -> Option<usize>{\n        match self.iter.size_hint() {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::newtype_variant_seed":["fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Error>\n    where\n        T: de::DeserializeSeed<'de>,{\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"newtype variant\",\n        ))\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::struct_variant":["fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        _visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,{\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"struct variant\",\n        ))\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::tuple_variant":["fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Error>\n    where\n        V: de::Visitor<'de>,{\n        Err(de::Error::invalid_type(\n            Unexpected::UnitVariant,\n            &\"tuple variant\",\n        ))\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::unit_variant":["fn unit_variant(self) -> Result<(), Error>{\n        Ok(())\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed":["fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.value {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"newtype variant\",\n            )),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::struct_variant":["fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self.value {\n            Some(Value::Object(v)) => visit_object(v, visitor),\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"struct variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"struct variant\",\n            )),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::tuple_variant":["fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self.value {\n            Some(Value::Array(v)) => {\n                if v.is_empty() {\n                    visitor.visit_unit()\n                } else {\n                    visit_array(v, visitor)\n                }\n            }\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"tuple variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"tuple variant\",\n            )),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::unit_variant":["fn unit_variant(self) -> Result<(), Error>{\n        match self.value {\n            Some(value) => Deserialize::deserialize(value),\n            None => Ok(()),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::newtype_variant_seed":["fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>\n    where\n        T: DeserializeSeed<'de>,{\n        match self.value {\n            Some(value) => seed.deserialize(value),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"newtype variant\",\n            )),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::struct_variant":["fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self.value {\n            Some(Value::Object(v)) => visit_object_ref(v, visitor),\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"struct variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"struct variant\",\n            )),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::tuple_variant":["fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self.value {\n            Some(Value::Array(v)) => {\n                if v.is_empty() {\n                    visitor.visit_unit()\n                } else {\n                    visit_array_ref(v, visitor)\n                }\n            }\n            Some(other) => Err(serde::de::Error::invalid_type(\n                other.unexpected(),\n                &\"tuple variant\",\n            )),\n            None => Err(serde::de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"tuple variant\",\n            )),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::unit_variant":["fn unit_variant(self) -> Result<(), Error>{\n        match self.value {\n            Some(value) => Deserialize::deserialize(value),\n            None => Ok(()),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"<value::index::Type<'a> as std::fmt::Display>::fmt":["fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result{\n        match *self.0 {\n            Value::Null => formatter.write_str(\"null\"),\n            Value::Bool(_) => formatter.write_str(\"boolean\"),\n            Value::Number(_) => formatter.write_str(\"number\"),\n            Value::String(_) => formatter.write_str(\"string\"),\n            Value::Array(_) => formatter.write_str(\"array\"),\n            Value::Object(_) => formatter.write_str(\"object\"),\n        }\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::collect_str":["fn collect_str<T>(self, value: &T) -> Result<String>\n    where\n        T: ?Sized + Display,{\n        Ok(value.to_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_bool":["fn serialize_bool(self, _value: bool) -> Result<String>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_bytes":["fn serialize_bytes(self, _value: &[u8]) -> Result<String>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_char":["#[inline]\nfn serialize_char(self, value: char) -> Result<String>{\n        Ok({\n            let mut s = String::new();\n            s.push(value);\n            s\n        })\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_f32":["fn serialize_f32(self, _value: f32) -> Result<String>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_f64":["fn serialize_f64(self, _value: f64) -> Result<String>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_i16":["fn serialize_i16(self, value: i16) -> Result<String>{\n        Ok(value.to_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_i32":["fn serialize_i32(self, value: i32) -> Result<String>{\n        Ok(value.to_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_i64":["fn serialize_i64(self, value: i64) -> Result<String>{\n        Ok(value.to_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_i8":["fn serialize_i8(self, value: i8) -> Result<String>{\n        Ok(value.to_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_map":["fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_struct":["#[inline]\nfn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<String>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_variant":["fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _value: &T,\n    ) -> Result<String>\n    where\n        T: ?Sized + Serialize,{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_none":["fn serialize_none(self) -> Result<String>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_seq":["fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_some":["fn serialize_some<T>(self, _value: &T) -> Result<String>\n    where\n        T: ?Sized + Serialize,{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_str":["#[inline]\nfn serialize_str(self, value: &str) -> Result<String>{\n        Ok(value.to_owned())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct":["fn serialize_struct(self, _name: &'static str, _len: usize) -> Result<Self::SerializeStruct>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct_variant":["fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple":["fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_struct":["fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleStruct>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_variant":["fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        _variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeTupleVariant>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_u16":["fn serialize_u16(self, value: u16) -> Result<String>{\n        Ok(value.to_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_u32":["fn serialize_u32(self, value: u32) -> Result<String>{\n        Ok(value.to_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_u64":["fn serialize_u64(self, value: u64) -> Result<String>{\n        Ok(value.to_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_u8":["fn serialize_u8(self, value: u8) -> Result<String>{\n        Ok(value.to_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit":["fn serialize_unit(self) -> Result<String>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_struct":["fn serialize_unit_struct(self, _name: &'static str) -> Result<String>{\n        Err(key_must_be_a_string())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_variant":["#[inline]\nfn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<String>{\n        Ok(variant.to_owned())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeMap as serde::ser::SerializeMap>::end":["fn end(self) -> Result<Value>{\n        match self {\n            SerializeMap::Map { map, .. } => Ok(Value::Object(map)),\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { .. } => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_key":["fn serialize_key<T>(&mut self, key: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            SerializeMap::Map { next_key, .. } => {\n                *next_key = Some(tri!(key.serialize(MapKeySerializer)));\n                Ok(())\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { .. } => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_value":["fn serialize_value<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            SerializeMap::Map { map, next_key } => {\n                let key = next_key.take();\n                // Panic because this indicates a bug in the program rather than an\n                // expected failure.\n                let key = key.expect(\"serialize_value called before serialize_key\");\n                map.insert(key, tri!(to_value(value)));\n                Ok(())\n            }\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { .. } => unreachable!(),\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { .. } => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeMap as serde::ser::SerializeStruct>::end":["fn end(self) -> Result<Value>{\n        match self {\n            SerializeMap::Map { .. } => serde::ser::SerializeMap::end(self),\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { out_value, .. } => {\n                Ok(out_value.expect(\"number value was not emitted\"))\n            }\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { out_value, .. } => {\n                Ok(out_value.expect(\"raw value was not emitted\"))\n            }\n        }\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeMap as serde::ser::SerializeStruct>::serialize_field":["fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        match self {\n            SerializeMap::Map { .. } => serde::ser::SerializeMap::serialize_entry(self, key, value),\n            #[cfg(feature = \"arbitrary_precision\")]\n            SerializeMap::Number { out_value } => {\n                if key == crate::number::TOKEN {\n                    *out_value = Some(value.serialize(NumberValueEmitter)?);\n                    Ok(())\n                } else {\n                    Err(invalid_number())\n                }\n            }\n            #[cfg(feature = \"raw_value\")]\n            SerializeMap::RawValue { out_value } => {\n                if key == crate::raw::TOKEN {\n                    *out_value = Some(value.serialize(RawValueEmitter)?);\n                    Ok(())\n                } else {\n                    Err(invalid_raw_value())\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::end":["fn end(self) -> Result<Value>{\n        let mut object = Map::new();\n\n        object.insert(self.name, Value::Object(self.map));\n\n        Ok(Value::Object(object))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::serialize_field":["fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        self.map.insert(String::from(key), tri!(to_value(value)));\n        Ok(())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::end":["fn end(self) -> Result<Value>{\n        let mut object = Map::new();\n\n        object.insert(self.name, Value::Array(self.vec));\n\n        Ok(Value::Object(object))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::serialize_field":["fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        self.vec.push(tri!(to_value(value)));\n        Ok(())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeVec as serde::ser::SerializeSeq>::end":["fn end(self) -> Result<Value>{\n        Ok(Value::Array(self.vec))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeVec as serde::ser::SerializeSeq>::serialize_element":["fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        self.vec.push(tri!(to_value(value)));\n        Ok(())\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeVec as serde::ser::SerializeTuple>::end":["fn end(self) -> Result<Value>{\n        serde::ser::SerializeSeq::end(self)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeVec as serde::ser::SerializeTuple>::serialize_element":["fn serialize_element<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        serde::ser::SerializeSeq::serialize_element(self, value)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::end":["fn end(self) -> Result<Value>{\n        serde::ser::SerializeSeq::end(self)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::serialize_field":["fn serialize_field<T>(&mut self, value: &T) -> Result<()>\n    where\n        T: ?Sized + Serialize,{\n        serde::ser::SerializeSeq::serialize_element(self, value)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::collect_str":["fn collect_str<T>(self, value: &T) -> Result<Value>\n    where\n        T: ?Sized + Display,{\n        Ok(Value::String(value.to_string()))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_bool":["#[inline]\nfn serialize_bool(self, value: bool) -> Result<Value>{\n        Ok(Value::Bool(value))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_bytes":["fn serialize_bytes(self, value: &[u8]) -> Result<Value>{\n        let vec = value.iter().map(|&b| Value::Number(b.into())).collect();\n        Ok(Value::Array(vec))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_char":["#[inline]\nfn serialize_char(self, value: char) -> Result<Value>{\n        let mut s = String::new();\n        s.push(value);\n        Ok(Value::String(s))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_f32":["#[inline]\nfn serialize_f32(self, float: f32) -> Result<Value>{\n        Ok(Value::from(float))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_f64":["#[inline]\nfn serialize_f64(self, float: f64) -> Result<Value>{\n        Ok(Value::from(float))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_i128":["fn serialize_i128(self, value: i128) -> Result<Value>{\n        #[cfg(feature = \"arbitrary_precision\")]\n        {\n            Ok(Value::Number(value.into()))\n        }\n\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        {\n            if let Ok(value) = u64::try_from(value) {\n                Ok(Value::Number(value.into()))\n            } else if let Ok(value) = i64::try_from(value) {\n                Ok(Value::Number(value.into()))\n            } else {\n                Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))\n            }\n        }\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_i16":["#[inline]\nfn serialize_i16(self, value: i16) -> Result<Value>{\n        self.serialize_i64(value as i64)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_i32":["#[inline]\nfn serialize_i32(self, value: i32) -> Result<Value>{\n        self.serialize_i64(value as i64)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_i64":["fn serialize_i64(self, value: i64) -> Result<Value>{\n        Ok(Value::Number(value.into()))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_i8":["#[inline]\nfn serialize_i8(self, value: i8) -> Result<Value>{\n        self.serialize_i64(value as i64)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_map":["fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap>{\n        Ok(SerializeMap::Map {\n            map: Map::new(),\n            next_key: None,\n        })\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_newtype_struct":["#[inline]\nfn serialize_newtype_struct<T>(self, _name: &'static str, value: &T) -> Result<Value>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_newtype_variant":["fn serialize_newtype_variant<T>(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Value>\n    where\n        T: ?Sized + Serialize,{\n        let mut values = Map::new();\n        values.insert(String::from(variant), tri!(to_value(value)));\n        Ok(Value::Object(values))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_none":["#[inline]\nfn serialize_none(self) -> Result<Value>{\n        self.serialize_unit()\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_seq":["fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq>{\n        Ok(SerializeVec {\n            vec: Vec::with_capacity(len.unwrap_or(0)),\n        })\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_some":["#[inline]\nfn serialize_some<T>(self, value: &T) -> Result<Value>\n    where\n        T: ?Sized + Serialize,{\n        value.serialize(self)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_str":["#[inline]\nfn serialize_str(self, value: &str) -> Result<Value>{\n        Ok(Value::String(value.to_owned()))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_struct":["fn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct>{\n        match name {\n            #[cfg(feature = \"arbitrary_precision\")]\n            crate::number::TOKEN => Ok(SerializeMap::Number { out_value: None }),\n            #[cfg(feature = \"raw_value\")]\n            crate::raw::TOKEN => Ok(SerializeMap::RawValue { out_value: None }),\n            _ => self.serialize_map(Some(len)),\n        }\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_struct_variant":["fn serialize_struct_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        _len: usize,\n    ) -> Result<Self::SerializeStructVariant>{\n        Ok(SerializeStructVariant {\n            name: String::from(variant),\n            map: Map::new(),\n        })\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_tuple":["fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_tuple_struct":["fn serialize_tuple_struct(\n        self,\n        _name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct>{\n        self.serialize_seq(Some(len))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_tuple_variant":["fn serialize_tuple_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant>{\n        Ok(SerializeTupleVariant {\n            name: String::from(variant),\n            vec: Vec::with_capacity(len),\n        })\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_u128":["fn serialize_u128(self, value: u128) -> Result<Value>{\n        #[cfg(feature = \"arbitrary_precision\")]\n        {\n            Ok(Value::Number(value.into()))\n        }\n\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        {\n            if let Ok(value) = u64::try_from(value) {\n                Ok(Value::Number(value.into()))\n            } else {\n                Err(Error::syntax(ErrorCode::NumberOutOfRange, 0, 0))\n            }\n        }\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_u16":["#[inline]\nfn serialize_u16(self, value: u16) -> Result<Value>{\n        self.serialize_u64(value as u64)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_u32":["#[inline]\nfn serialize_u32(self, value: u32) -> Result<Value>{\n        self.serialize_u64(value as u64)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_u64":["#[inline]\nfn serialize_u64(self, value: u64) -> Result<Value>{\n        Ok(Value::Number(value.into()))\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_u8":["#[inline]\nfn serialize_u8(self, value: u8) -> Result<Value>{\n        self.serialize_u64(value as u64)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_unit":["#[inline]\nfn serialize_unit(self) -> Result<Value>{\n        Ok(Value::Null)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_unit_struct":["#[inline]\nfn serialize_unit_struct(self, _name: &'static str) -> Result<Value>{\n        self.serialize_unit()\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"<value::ser::Serializer as serde::Serializer>::serialize_unit_variant":["#[inline]\nfn serialize_unit_variant(\n        self,\n        _name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Value>{\n        self.serialize_str(variant)\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"de::<impl std::str::FromStr for number::Number>::from_str":["fn from_str(s: &str) -> result::Result<Self, Self::Err>{\n        Deserializer::from_str(s)\n            .parse_any_signed_number()\n            .map(Into::into)\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer":["/// A structure that deserializes JSON into Rust values.\npub struct Deserializer<R> {\n    read: R,\n    scratch: Vec<u8>,\n    remaining_depth: u8,\n    #[cfg(feature = \"float_roundtrip\")]\n    single_precision: bool,\n    #[cfg(feature = \"unbounded_depth\")]\n    disable_recursion_limit: bool,\n}","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::deserialize_number":["fn deserialize_number<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        let peek = match tri!(self.parse_whitespace()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'-' => {\n                self.eat_char();\n                tri!(self.parse_integer(false)).visit(visitor)\n            }\n            b'0'..=b'9' => tri!(self.parse_integer(true)).visit(visitor),\n            _ => Err(self.peek_invalid_type(&visitor)),\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::eat_char":["fn eat_char(&mut self){\n        self.read.discard();\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::end":["/// The `Deserializer::end` method should be called after a value has been fully deserialized.\n/// This allows the `Deserializer` to validate that the input stream is at the end or that it\n/// only has trailing whitespace.\npub fn end(&mut self) -> Result<()>{\n        match tri!(self.parse_whitespace()) {\n            Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n            None => Ok(()),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::end_map":["fn end_map(&mut self) -> Result<()>{\n        match tri!(self.parse_whitespace()) {\n            Some(b'}') => {\n                self.eat_char();\n                Ok(())\n            }\n            Some(b',') => Err(self.peek_error(ErrorCode::TrailingComma)),\n            Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::end_seq":["fn end_seq(&mut self) -> Result<()>{\n        match tri!(self.parse_whitespace()) {\n            Some(b']') => {\n                self.eat_char();\n                Ok(())\n            }\n            Some(b',') => {\n                self.eat_char();\n                match self.parse_whitespace() {\n                    Ok(Some(b']')) => Err(self.peek_error(ErrorCode::TrailingComma)),\n                    _ => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n                }\n            }\n            Some(_) => Err(self.peek_error(ErrorCode::TrailingCharacters)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingList)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::error":["/// Error caused by a byte from next_char().\n#[cold]\nfn error(&self, reason: ErrorCode) -> Error{\n        let position = self.read.position();\n        Error::syntax(reason, position.line, position.column)\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::f64_from_parts":["#[cfg(not(feature = \"float_roundtrip\"))]\nfn f64_from_parts(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        mut exponent: i32,\n    ) -> Result<f64>{\n        let mut f = significand as f64;\n        loop {\n            match POW10.get(exponent.wrapping_abs() as usize) {\n                Some(&pow) => {\n                    if exponent >= 0 {\n                        f *= pow;\n                        if f.is_infinite() {\n                            return Err(self.error(ErrorCode::NumberOutOfRange));\n                        }\n                    } else {\n                        f /= pow;\n                    }\n                    break;\n                }\n                None => {\n                    if f == 0.0 {\n                        break;\n                    }\n                    if exponent >= 0 {\n                        return Err(self.error(ErrorCode::NumberOutOfRange));\n                    }\n                    f /= 1e308;\n                    exponent += 308;\n                }\n            }\n        }\n        Ok(if positive { f } else { -f })\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::fix_position":["#[cold]\nfn fix_position(&self, err: Error) -> Error{\n        err.fix_position(move |code| self.error(code))\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::ignore_decimal":["fn ignore_decimal(&mut self) -> Result<()>{\n        self.eat_char();\n\n        let mut at_least_one_digit = false;\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            at_least_one_digit = true;\n        }\n\n        if !at_least_one_digit {\n            return Err(self.peek_error(ErrorCode::InvalidNumber));\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.ignore_exponent(),\n            _ => Ok(()),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::ignore_exponent":["fn ignore_exponent(&mut self) -> Result<()>{\n        self.eat_char();\n\n        match tri!(self.peek_or_null()) {\n            b'+' | b'-' => self.eat_char(),\n            _ => {}\n        }\n\n        // Make sure a digit follows the exponent place.\n        match tri!(self.next_char_or_null()) {\n            b'0'..=b'9' => {}\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        }\n\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::ignore_integer":["fn ignore_integer(&mut self) -> Result<()>{\n        match tri!(self.next_char_or_null()) {\n            b'0' => {\n                // There can be only one leading '0'.\n                if let b'0'..=b'9' = tri!(self.peek_or_null()) {\n                    return Err(self.peek_error(ErrorCode::InvalidNumber));\n                }\n            }\n            b'1'..=b'9' => {\n                while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n                    self.eat_char();\n                }\n            }\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'.' => self.ignore_decimal(),\n            b'e' | b'E' => self.ignore_exponent(),\n            _ => Ok(()),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::ignore_value":["fn ignore_value(&mut self) -> Result<()>{\n        self.scratch.clear();\n        let mut enclosing = None;\n\n        loop {\n            let peek = match tri!(self.parse_whitespace()) {\n                Some(b) => b,\n                None => {\n                    return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n                }\n            };\n\n            let frame = match peek {\n                b'n' => {\n                    self.eat_char();\n                    tri!(self.parse_ident(b\"ull\"));\n                    None\n                }\n                b't' => {\n                    self.eat_char();\n                    tri!(self.parse_ident(b\"rue\"));\n                    None\n                }\n                b'f' => {\n                    self.eat_char();\n                    tri!(self.parse_ident(b\"alse\"));\n                    None\n                }\n                b'-' => {\n                    self.eat_char();\n                    tri!(self.ignore_integer());\n                    None\n                }\n                b'0'..=b'9' => {\n                    tri!(self.ignore_integer());\n                    None\n                }\n                b'\"' => {\n                    self.eat_char();\n                    tri!(self.read.ignore_str());\n                    None\n                }\n                frame @ b'[' | frame @ b'{' => {\n                    self.scratch.extend(enclosing.take());\n                    self.eat_char();\n                    Some(frame)\n                }\n                _ => return Err(self.peek_error(ErrorCode::ExpectedSomeValue)),\n            };\n\n            let (mut accept_comma, mut frame) = match frame {\n                Some(frame) => (false, frame),\n                None => match enclosing.take() {\n                    Some(frame) => (true, frame),\n                    None => match self.scratch.pop() {\n                        Some(frame) => (true, frame),\n                        None => return Ok(()),\n                    },\n                },\n            };\n\n            loop {\n                match tri!(self.parse_whitespace()) {\n                    Some(b',') if accept_comma => {\n                        self.eat_char();\n                        break;\n                    }\n                    Some(b']') if frame == b'[' => {}\n                    Some(b'}') if frame == b'{' => {}\n                    Some(_) => {\n                        if accept_comma {\n                            return Err(self.peek_error(match frame {\n                                b'[' => ErrorCode::ExpectedListCommaOrEnd,\n                                b'{' => ErrorCode::ExpectedObjectCommaOrEnd,\n                                _ => unreachable!(),\n                            }));\n                        } else {\n                            break;\n                        }\n                    }\n                    None => {\n                        return Err(self.peek_error(match frame {\n                            b'[' => ErrorCode::EofWhileParsingList,\n                            b'{' => ErrorCode::EofWhileParsingObject,\n                            _ => unreachable!(),\n                        }));\n                    }\n                }\n\n                self.eat_char();\n                frame = match self.scratch.pop() {\n                    Some(frame) => frame,\n                    None => return Ok(()),\n                };\n                accept_comma = true;\n            }\n\n            if frame == b'{' {\n                match tri!(self.parse_whitespace()) {\n                    Some(b'\"') => self.eat_char(),\n                    Some(_) => return Err(self.peek_error(ErrorCode::KeyMustBeAString)),\n                    None => return Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n                }\n                tri!(self.read.ignore_str());\n                match tri!(self.parse_whitespace()) {\n                    Some(b':') => self.eat_char(),\n                    Some(_) => return Err(self.peek_error(ErrorCode::ExpectedColon)),\n                    None => return Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n                }\n            }\n\n            enclosing = Some(frame);\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::into_iter":["/// Turn a JSON deserializer into an iterator over values of type T.\npub fn into_iter<T>(self) -> StreamDeserializer<'de, R, T>\n    where\n        T: de::Deserialize<'de>,{\n        // This cannot be an implementation of std::iter::IntoIterator because\n        // we need the caller to choose what T is.\n        let offset = self.read.byte_offset();\n        StreamDeserializer {\n            de: self,\n            offset,\n            failed: false,\n            output: PhantomData,\n            lifetime: PhantomData,\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::new":["/// Create a JSON deserializer from one of the possible serde_json input\n/// sources.\n///\n/// Typically it is more convenient to use one of these methods instead:\n///\n///   - Deserializer::from_str\n///   - Deserializer::from_slice\n///   - Deserializer::from_reader\npub fn new(read: R) -> Self{\n        Deserializer {\n            read,\n            scratch: Vec::new(),\n            remaining_depth: 128,\n            #[cfg(feature = \"float_roundtrip\")]\n            single_precision: false,\n            #[cfg(feature = \"unbounded_depth\")]\n            disable_recursion_limit: false,\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::next_char":["fn next_char(&mut self) -> Result<Option<u8>>{\n        self.read.next()\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::next_char_or_null":["fn next_char_or_null(&mut self) -> Result<u8>{\n        Ok(tri!(self.next_char()).unwrap_or(b'\\x00'))\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::parse_any_number":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn parse_any_number(&mut self, positive: bool) -> Result<ParserNumber>{\n        self.parse_integer(positive)\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::parse_any_signed_number":["fn parse_any_signed_number(&mut self) -> Result<ParserNumber>{\n        let peek = match tri!(self.peek()) {\n            Some(b) => b,\n            None => {\n                return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        let value = match peek {\n            b'-' => {\n                self.eat_char();\n                self.parse_any_number(false)\n            }\n            b'0'..=b'9' => self.parse_any_number(true),\n            _ => Err(self.peek_error(ErrorCode::InvalidNumber)),\n        };\n\n        let value = match tri!(self.peek()) {\n            Some(_) => Err(self.peek_error(ErrorCode::InvalidNumber)),\n            None => value,\n        };\n\n        match value {\n            Ok(value) => Ok(value),\n            // The de::Error impl creates errors with unknown line and column.\n            // Fill in the position here by looking at the current index in the\n            // input. There is no way to tell whether this should call `error`\n            // or `peek_error` so pick the one that seems correct more often.\n            // Worst case, the position is off by one character.\n            Err(err) => Err(self.fix_position(err)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::parse_decimal":["fn parse_decimal(\n        &mut self,\n        positive: bool,\n        mut significand: u64,\n        exponent_before_decimal_point: i32,\n    ) -> Result<f64>{\n        self.eat_char();\n\n        let mut exponent_after_decimal_point = 0;\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            let digit = (c - b'0') as u64;\n\n            if overflow!(significand * 10 + digit, u64::max_value()) {\n                let exponent = exponent_before_decimal_point + exponent_after_decimal_point;\n                return self.parse_decimal_overflow(positive, significand, exponent);\n            }\n\n            self.eat_char();\n            significand = significand * 10 + digit;\n            exponent_after_decimal_point -= 1;\n        }\n\n        // Error if there is not at least one digit after the decimal point.\n        if exponent_after_decimal_point == 0 {\n            match tri!(self.peek()) {\n                Some(_) => return Err(self.peek_error(ErrorCode::InvalidNumber)),\n                None => return Err(self.peek_error(ErrorCode::EofWhileParsingValue)),\n            }\n        }\n\n        let exponent = exponent_before_decimal_point + exponent_after_decimal_point;\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.parse_exponent(positive, significand, exponent),\n            _ => self.f64_from_parts(positive, significand, exponent),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::parse_decimal_overflow":["#[cfg(not(feature = \"float_roundtrip\"))]\n#[cold]\n#[inline(never)]\nfn parse_decimal_overflow(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        exponent: i32,\n    ) -> Result<f64>{\n        // The next multiply/add would overflow, so just ignore all further\n        // digits.\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n        }\n\n        match tri!(self.peek_or_null()) {\n            b'e' | b'E' => self.parse_exponent(positive, significand, exponent),\n            _ => self.f64_from_parts(positive, significand, exponent),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::parse_exponent":["fn parse_exponent(\n        &mut self,\n        positive: bool,\n        significand: u64,\n        starting_exp: i32,\n    ) -> Result<f64>{\n        self.eat_char();\n\n        let positive_exp = match tri!(self.peek_or_null()) {\n            b'+' => {\n                self.eat_char();\n                true\n            }\n            b'-' => {\n                self.eat_char();\n                false\n            }\n            _ => true,\n        };\n\n        let next = match tri!(self.next_char()) {\n            Some(b) => b,\n            None => {\n                return Err(self.error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        // Make sure a digit follows the exponent place.\n        let mut exp = match next {\n            c @ b'0'..=b'9' => (c - b'0') as i32,\n            _ => {\n                return Err(self.error(ErrorCode::InvalidNumber));\n            }\n        };\n\n        while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n            let digit = (c - b'0') as i32;\n\n            if overflow!(exp * 10 + digit, i32::max_value()) {\n                let zero_significand = significand == 0;\n                return self.parse_exponent_overflow(positive, zero_significand, positive_exp);\n            }\n\n            exp = exp * 10 + digit;\n        }\n\n        let final_exp = if positive_exp {\n            starting_exp.saturating_add(exp)\n        } else {\n            starting_exp.saturating_sub(exp)\n        };\n\n        self.f64_from_parts(positive, significand, final_exp)\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::parse_exponent_overflow":["#[cold]\n#[inline(never)]\nfn parse_exponent_overflow(\n        &mut self,\n        positive: bool,\n        zero_significand: bool,\n        positive_exp: bool,\n    ) -> Result<f64>{\n        // Error instead of +/- infinity.\n        if !zero_significand && positive_exp {\n            return Err(self.error(ErrorCode::NumberOutOfRange));\n        }\n\n        while let b'0'..=b'9' = tri!(self.peek_or_null()) {\n            self.eat_char();\n        }\n        Ok(if positive { 0.0 } else { -0.0 })\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::parse_ident":["fn parse_ident(&mut self, ident: &[u8]) -> Result<()>{\n        for expected in ident {\n            match tri!(self.next_char()) {\n                None => {\n                    return Err(self.error(ErrorCode::EofWhileParsingValue));\n                }\n                Some(next) => {\n                    if next != *expected {\n                        return Err(self.error(ErrorCode::ExpectedSomeIdent));\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::parse_integer":["fn parse_integer(&mut self, positive: bool) -> Result<ParserNumber>{\n        let next = match tri!(self.next_char()) {\n            Some(b) => b,\n            None => {\n                return Err(self.error(ErrorCode::EofWhileParsingValue));\n            }\n        };\n\n        match next {\n            b'0' => {\n                // There can be only one leading '0'.\n                match tri!(self.peek_or_null()) {\n                    b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),\n                    _ => self.parse_number(positive, 0),\n                }\n            }\n            c @ b'1'..=b'9' => {\n                let mut significand = (c - b'0') as u64;\n\n                loop {\n                    match tri!(self.peek_or_null()) {\n                        c @ b'0'..=b'9' => {\n                            let digit = (c - b'0') as u64;\n\n                            // We need to be careful with overflow. If we can,\n                            // try to keep the number as a `u64` until we grow\n                            // too large. At that point, switch to parsing the\n                            // value as a `f64`.\n                            if overflow!(significand * 10 + digit, u64::max_value()) {\n                                return Ok(ParserNumber::F64(tri!(\n                                    self.parse_long_integer(positive, significand),\n                                )));\n                            }\n\n                            self.eat_char();\n                            significand = significand * 10 + digit;\n                        }\n                        _ => {\n                            return self.parse_number(positive, significand);\n                        }\n                    }\n                }\n            }\n            _ => Err(self.error(ErrorCode::InvalidNumber)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::parse_long_integer":["#[cfg(not(feature = \"float_roundtrip\"))]\n#[cold]\n#[inline(never)]\nfn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64>{\n        let mut exponent = 0;\n        loop {\n            match tri!(self.peek_or_null()) {\n                b'0'..=b'9' => {\n                    self.eat_char();\n                    // This could overflow... if your integer is gigabytes long.\n                    // Ignore that possibility.\n                    exponent += 1;\n                }\n                b'.' => {\n                    return self.parse_decimal(positive, significand, exponent);\n                }\n                b'e' | b'E' => {\n                    return self.parse_exponent(positive, significand, exponent);\n                }\n                _ => {\n                    return self.f64_from_parts(positive, significand, exponent);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::parse_number":["fn parse_number(&mut self, positive: bool, significand: u64) -> Result<ParserNumber>{\n        Ok(match tri!(self.peek_or_null()) {\n            b'.' => ParserNumber::F64(tri!(self.parse_decimal(positive, significand, 0))),\n            b'e' | b'E' => ParserNumber::F64(tri!(self.parse_exponent(positive, significand, 0))),\n            _ => {\n                if positive {\n                    ParserNumber::U64(significand)\n                } else {\n                    let neg = (significand as i64).wrapping_neg();\n\n                    // Convert into a float if we underflow, or on `-0`.\n                    if neg >= 0 {\n                        ParserNumber::F64(-(significand as f64))\n                    } else {\n                        ParserNumber::I64(neg)\n                    }\n                }\n            }\n        })\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::parse_object_colon":["fn parse_object_colon(&mut self) -> Result<()>{\n        match tri!(self.parse_whitespace()) {\n            Some(b':') => {\n                self.eat_char();\n                Ok(())\n            }\n            Some(_) => Err(self.peek_error(ErrorCode::ExpectedColon)),\n            None => Err(self.peek_error(ErrorCode::EofWhileParsingObject)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::parse_whitespace":["/// Returns the first non-whitespace byte without consuming it, or `None` if\n/// EOF is encountered.\nfn parse_whitespace(&mut self) -> Result<Option<u8>>{\n        loop {\n            match tri!(self.peek()) {\n                Some(b' ') | Some(b'\\n') | Some(b'\\t') | Some(b'\\r') => {\n                    self.eat_char();\n                }\n                other => {\n                    return Ok(other);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::peek":["fn peek(&mut self) -> Result<Option<u8>>{\n        self.read.peek()\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::peek_error":["/// Error caused by a byte from peek().\n#[cold]\nfn peek_error(&self, reason: ErrorCode) -> Error{\n        let position = self.read.peek_position();\n        Error::syntax(reason, position.line, position.column)\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::peek_invalid_type":["#[cold]\nfn peek_invalid_type(&mut self, exp: &dyn Expected) -> Error{\n        let err = match self.peek_or_null().unwrap_or(b'\\x00') {\n            b'n' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"ull\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Unit, exp)\n            }\n            b't' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"rue\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Bool(true), exp)\n            }\n            b'f' => {\n                self.eat_char();\n                if let Err(err) = self.parse_ident(b\"alse\") {\n                    return err;\n                }\n                de::Error::invalid_type(Unexpected::Bool(false), exp)\n            }\n            b'-' => {\n                self.eat_char();\n                match self.parse_any_number(false) {\n                    Ok(n) => n.invalid_type(exp),\n                    Err(err) => return err,\n                }\n            }\n            b'0'..=b'9' => match self.parse_any_number(true) {\n                Ok(n) => n.invalid_type(exp),\n                Err(err) => return err,\n            },\n            b'\"' => {\n                self.eat_char();\n                self.scratch.clear();\n                match self.read.parse_str(&mut self.scratch) {\n                    Ok(s) => de::Error::invalid_type(Unexpected::Str(&s), exp),\n                    Err(err) => return err,\n                }\n            }\n            b'[' => de::Error::invalid_type(Unexpected::Seq, exp),\n            b'{' => de::Error::invalid_type(Unexpected::Map, exp),\n            _ => self.peek_error(ErrorCode::ExpectedSomeValue),\n        };\n\n        self.fix_position(err)\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::peek_or_null":["fn peek_or_null(&mut self) -> Result<u8>{\n        Ok(tri!(self.peek()).unwrap_or(b'\\x00'))\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<R>::scan_integer128":["fn scan_integer128(&mut self, buf: &mut String) -> Result<()>{\n        match tri!(self.next_char_or_null()) {\n            b'0' => {\n                buf.push('0');\n                // There can be only one leading '0'.\n                match tri!(self.peek_or_null()) {\n                    b'0'..=b'9' => Err(self.peek_error(ErrorCode::InvalidNumber)),\n                    _ => Ok(()),\n                }\n            }\n            c @ b'1'..=b'9' => {\n                buf.push(c as char);\n                while let c @ b'0'..=b'9' = tri!(self.peek_or_null()) {\n                    self.eat_char();\n                    buf.push(c as char);\n                }\n                Ok(())\n            }\n            _ => Err(self.error(ErrorCode::InvalidNumber)),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<read::IoRead<R>>::from_reader":["/// Creates a JSON deserializer from an `io::Read`.\n///\n/// Reader-based deserializers do not support deserializing borrowed types\n/// like `&str`, since the `std::io::Read` trait has no non-copying methods\n/// -- everything it does involves copying bytes out of the data source.\npub fn from_reader(reader: R) -> Self{\n        Deserializer::new(read::IoRead::new(reader))\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<read::SliceRead<'a>>::from_slice":["/// Creates a JSON deserializer from a `&[u8]`.\npub fn from_slice(bytes: &'a [u8]) -> Self{\n        Deserializer::new(read::SliceRead::new(bytes))\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::Deserializer::<read::StrRead<'a>>::from_str":["/// Creates a JSON deserializer from a `&str`.\npub fn from_str(s: &'a str) -> Self{\n        Deserializer::new(read::StrRead::new(s))\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::MapAccess":["struct MapAccess<'a, R: 'a> {\n    de: &'a mut Deserializer<R>,\n    first: bool,\n}","Real(LocalPath(\"src/de.rs\"))"],"de::MapAccess::<'a, R>::new":["fn new(de: &'a mut Deserializer<R>) -> Self{\n        MapAccess { de, first: true }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::MapKey":["/// Only deserialize from this after peeking a '\"' byte! Otherwise it may\n/// deserialize invalid JSON successfully.\nstruct MapKey<'a, R: 'a> {\n    de: &'a mut Deserializer<R>,\n}","Real(LocalPath(\"src/de.rs\"))"],"de::ParserNumber":["pub(crate) enum ParserNumber {\n    F64(f64),\n    U64(u64),\n    I64(i64),\n    #[cfg(feature = \"arbitrary_precision\")]\n    String(String),\n}","Real(LocalPath(\"src/de.rs\"))"],"de::ParserNumber::invalid_type":["fn invalid_type(self, exp: &dyn Expected) -> Error{\n        match self {\n            ParserNumber::F64(x) => de::Error::invalid_type(Unexpected::Float(x), exp),\n            ParserNumber::U64(x) => de::Error::invalid_type(Unexpected::Unsigned(x), exp),\n            ParserNumber::I64(x) => de::Error::invalid_type(Unexpected::Signed(x), exp),\n            #[cfg(feature = \"arbitrary_precision\")]\n            ParserNumber::String(_) => de::Error::invalid_type(Unexpected::Other(\"number\"), exp),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::ParserNumber::visit":["fn visit<'de, V>(self, visitor: V) -> Result<V::Value>\n    where\n        V: de::Visitor<'de>,{\n        match self {\n            ParserNumber::F64(x) => visitor.visit_f64(x),\n            ParserNumber::U64(x) => visitor.visit_u64(x),\n            ParserNumber::I64(x) => visitor.visit_i64(x),\n            #[cfg(feature = \"arbitrary_precision\")]\n            ParserNumber::String(x) => visitor.visit_map(NumberDeserializer { number: x.into() }),\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::SeqAccess":["struct SeqAccess<'a, R: 'a> {\n    de: &'a mut Deserializer<R>,\n    first: bool,\n}","Real(LocalPath(\"src/de.rs\"))"],"de::SeqAccess::<'a, R>::new":["fn new(de: &'a mut Deserializer<R>) -> Self{\n        SeqAccess { de, first: true }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::StreamDeserializer":["/// Iterator that deserializes a stream into multiple JSON values.\n///\n/// A stream deserializer can be created from any JSON deserializer using the\n/// `Deserializer::into_iter` method.\n///\n/// The data can consist of any JSON value. Values need to be a self-delineating value e.g.\n/// arrays, objects, or strings, or be followed by whitespace or a self-delineating value.\n///\n/// ```\n/// use serde_json::{Deserializer, Value};\n///\n/// fn main() {\n///     let data = \"{\\\"k\\\": 3}1\\\"cool\\\"\\\"stuff\\\" 3{}  [0, 1, 2]\";\n///\n///     let stream = Deserializer::from_str(data).into_iter::<Value>();\n///\n///     for value in stream {\n///         println!(\"{}\", value.unwrap());\n///     }\n/// }\n/// ```\npub struct StreamDeserializer<'de, R, T> {\n    de: Deserializer<R>,\n    offset: usize,\n    failed: bool,\n    output: PhantomData<T>,\n    lifetime: PhantomData<&'de ()>,\n}","Real(LocalPath(\"src/de.rs\"))"],"de::StreamDeserializer::<'de, R, T>::byte_offset":["/// Returns the number of bytes so far deserialized into a successful `T`.\n///\n/// If a stream deserializer returns an EOF error, new data can be joined to\n/// `old_data[stream.byte_offset()..]` to try again.\n///\n/// ```\n/// let data = b\"[0] [1] [\";\n///\n/// let de = serde_json::Deserializer::from_slice(data);\n/// let mut stream = de.into_iter::<Vec<i32>>();\n/// assert_eq!(0, stream.byte_offset());\n///\n/// println!(\"{:?}\", stream.next()); // [0]\n/// assert_eq!(3, stream.byte_offset());\n///\n/// println!(\"{:?}\", stream.next()); // [1]\n/// assert_eq!(7, stream.byte_offset());\n///\n/// println!(\"{:?}\", stream.next()); // error\n/// assert_eq!(8, stream.byte_offset());\n///\n/// // If err.is_eof(), can join the remaining data to new data and continue.\n/// let remaining = &data[stream.byte_offset()..];\n/// ```\n///\n/// *Note:* In the future this method may be changed to return the number of\n/// bytes so far deserialized into a successful T *or* syntactically valid\n/// JSON skipped over due to a type error. See [serde-rs/json#70] for an\n/// example illustrating this.\n///\n/// [serde-rs/json#70]: https://github.com/serde-rs/json/issues/70\npub fn byte_offset(&self) -> usize{\n        self.offset\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::StreamDeserializer::<'de, R, T>::new":["/// Create a JSON stream deserializer from one of the possible serde_json\n/// input sources.\n///\n/// Typically it is more convenient to use one of these methods instead:\n///\n///   - Deserializer::from_str(...).into_iter()\n///   - Deserializer::from_slice(...).into_iter()\n///   - Deserializer::from_reader(...).into_iter()\npub fn new(read: R) -> Self{\n        let offset = read.byte_offset();\n        StreamDeserializer {\n            de: Deserializer::new(read),\n            offset,\n            failed: false,\n            output: PhantomData,\n            lifetime: PhantomData,\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::StreamDeserializer::<'de, R, T>::peek_end_of_value":["fn peek_end_of_value(&mut self) -> Result<()>{\n        match tri!(self.de.peek()) {\n            Some(b' ') | Some(b'\\n') | Some(b'\\t') | Some(b'\\r') | Some(b'\"') | Some(b'[')\n            | Some(b']') | Some(b'{') | Some(b'}') | Some(b',') | Some(b':') | None => Ok(()),\n            Some(_) => {\n                let position = self.de.read.peek_position();\n                Err(Error::syntax(\n                    ErrorCode::TrailingCharacters,\n                    position.line,\n                    position.column,\n                ))\n            }\n        }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::UnitVariantAccess":["struct UnitVariantAccess<'a, R: 'a> {\n    de: &'a mut Deserializer<R>,\n}","Real(LocalPath(\"src/de.rs\"))"],"de::UnitVariantAccess::<'a, R>::new":["fn new(de: &'a mut Deserializer<R>) -> Self{\n        UnitVariantAccess { de }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::VariantAccess":["struct VariantAccess<'a, R: 'a> {\n    de: &'a mut Deserializer<R>,\n}","Real(LocalPath(\"src/de.rs\"))"],"de::VariantAccess::<'a, R>::new":["fn new(de: &'a mut Deserializer<R>) -> Self{\n        VariantAccess { de }\n    }","Real(LocalPath(\"src/de.rs\"))"],"de::from_reader":["/// Deserialize an instance of type `T` from an IO stream of JSON.\n///\n/// The content of the IO stream is deserialized directly from the stream\n/// without being buffered in memory by serde_json.\n///\n/// When reading from a source against which short reads are not efficient, such\n/// as a [`File`], you will want to apply your own buffering because serde_json\n/// will not buffer the input. See [`std::io::BufReader`].\n///\n/// It is expected that the input stream ends after the deserialized object.\n/// If the stream does not end, such as in the case of a persistent socket connection,\n/// this function will not return. It is possible instead to deserialize from a prefix of an input\n/// stream without looking for EOF by managing your own [`Deserializer`].\n///\n/// Note that counter to intuition, this function is usually slower than\n/// reading a file completely into memory and then applying [`from_str`]\n/// or [`from_slice`] on it. See [issue #160].\n///\n/// [`File`]: https://doc.rust-lang.org/std/fs/struct.File.html\n/// [`std::io::BufReader`]: https://doc.rust-lang.org/std/io/struct.BufReader.html\n/// [`from_str`]: ./fn.from_str.html\n/// [`from_slice`]: ./fn.from_slice.html\n/// [issue #160]: https://github.com/serde-rs/json/issues/160\n///\n/// # Example\n///\n/// Reading the contents of a file.\n///\n/// ```\n/// use serde::Deserialize;\n///\n/// use std::error::Error;\n/// use std::fs::File;\n/// use std::io::BufReader;\n/// use std::path::Path;\n///\n/// #[derive(Deserialize, Debug)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn read_user_from_file<P: AsRef<Path>>(path: P) -> Result<User, Box<dyn Error>> {\n///     // Open the file in read-only mode with buffer.\n///     let file = File::open(path)?;\n///     let reader = BufReader::new(file);\n///\n///     // Read the JSON contents of the file as an instance of `User`.\n///     let u = serde_json::from_reader(reader)?;\n///\n///     // Return the `User`.\n///     Ok(u)\n/// }\n///\n/// fn main() {\n/// # }\n/// # fn fake_main() {\n///     let u = read_user_from_file(\"test.json\").unwrap();\n///     println!(\"{:#?}\", u);\n/// }\n/// ```\n///\n/// Reading from a persistent socket connection.\n///\n/// ```\n/// use serde::Deserialize;\n///\n/// use std::error::Error;\n/// use std::net::{TcpListener, TcpStream};\n///\n/// #[derive(Deserialize, Debug)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn read_user_from_stream(tcp_stream: TcpStream) -> Result<User, Box<dyn Error>> {\n///     let mut de = serde_json::Deserializer::from_reader(tcp_stream);\n///     let u = User::deserialize(&mut de)?;\n///\n///     Ok(u)\n/// }\n///\n/// fn main() {\n/// # }\n/// # fn fake_main() {\n///     let listener = TcpListener::bind(\"127.0.0.1:4000\").unwrap();\n///\n///     for stream in listener.incoming() {\n///         println!(\"{:#?}\", read_user_from_stream(stream.unwrap()));\n///     }\n/// }\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if the structure of the input does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the input\n/// contains something other than a JSON map. It can also fail if the structure\n/// is correct but `T`'s implementation of `Deserialize` decides that something\n/// is wrong with the data, for example required struct fields are missing from\n/// the JSON map or some number is too big to fit in the expected primitive\n/// type.\n#[cfg(feature = \"std\")]\npub fn from_reader<R, T>(rdr: R) -> Result<T>\nwhere\n    R: crate::io::Read,\n    T: de::DeserializeOwned,{\n    from_trait(read::IoRead::new(rdr))\n}","Real(LocalPath(\"src/de.rs\"))"],"de::from_slice":["/// Deserialize an instance of type `T` from bytes of JSON text.\n///\n/// # Example\n///\n/// ```\n/// use serde::Deserialize;\n///\n/// #[derive(Deserialize, Debug)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn main() {\n///     // The type of `j` is `&[u8]`\n///     let j = b\"\n///         {\n///             \\\"fingerprint\\\": \\\"0xF9BA143B95FF6D82\\\",\n///             \\\"location\\\": \\\"Menlo Park, CA\\\"\n///         }\";\n///\n///     let u: User = serde_json::from_slice(j).unwrap();\n///     println!(\"{:#?}\", u);\n/// }\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if the structure of the input does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the input\n/// contains something other than a JSON map. It can also fail if the structure\n/// is correct but `T`'s implementation of `Deserialize` decides that something\n/// is wrong with the data, for example required struct fields are missing from\n/// the JSON map or some number is too big to fit in the expected primitive\n/// type.\npub fn from_slice<'a, T>(v: &'a [u8]) -> Result<T>\nwhere\n    T: de::Deserialize<'a>,{\n    from_trait(read::SliceRead::new(v))\n}","Real(LocalPath(\"src/de.rs\"))"],"de::from_str":["/// Deserialize an instance of type `T` from a string of JSON text.\n///\n/// # Example\n///\n/// ```\n/// use serde::Deserialize;\n///\n/// #[derive(Deserialize, Debug)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn main() {\n///     // The type of `j` is `&str`\n///     let j = \"\n///         {\n///             \\\"fingerprint\\\": \\\"0xF9BA143B95FF6D82\\\",\n///             \\\"location\\\": \\\"Menlo Park, CA\\\"\n///         }\";\n///\n///     let u: User = serde_json::from_str(j).unwrap();\n///     println!(\"{:#?}\", u);\n/// }\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if the structure of the input does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the input\n/// contains something other than a JSON map. It can also fail if the structure\n/// is correct but `T`'s implementation of `Deserialize` decides that something\n/// is wrong with the data, for example required struct fields are missing from\n/// the JSON map or some number is too big to fit in the expected primitive\n/// type.\npub fn from_str<'a, T>(s: &'a str) -> Result<T>\nwhere\n    T: de::Deserialize<'a>,{\n    from_trait(read::StrRead::new(s))\n}","Real(LocalPath(\"src/de.rs\"))"],"de::from_trait":["fn from_trait<'de, R, T>(read: R) -> Result<T>\nwhere\n    R: Read<'de>,\n    T: de::Deserialize<'de>,{\n    let mut de = Deserializer::new(read);\n    let value = tri!(de::Deserialize::deserialize(&mut de));\n\n    // Make sure the whole stream has been consumed.\n    tri!(de.end());\n    Ok(value)\n}","Real(LocalPath(\"src/de.rs\"))"],"error::<impl std::convert::From<error::Error> for std::io::Error>::from":["/// Convert a `serde_json::Error` into an `io::Error`.\n///\n/// JSON syntax and data errors are turned into `InvalidData` IO errors.\n/// EOF errors are turned into `UnexpectedEof` IO errors.\n///\n/// ```\n/// use std::io;\n///\n/// enum MyError {\n///     Io(io::Error),\n///     Json(serde_json::Error),\n/// }\n///\n/// impl From<serde_json::Error> for MyError {\n///     fn from(err: serde_json::Error) -> MyError {\n///         use serde_json::error::Category;\n///         match err.classify() {\n///             Category::Io => {\n///                 MyError::Io(err.into())\n///             }\n///             Category::Syntax | Category::Data | Category::Eof => {\n///                 MyError::Json(err)\n///             }\n///         }\n///     }\n/// }\n/// ```\nfn from(j: Error) -> Self{\n        if let ErrorCode::Io(err) = j.err.code {\n            err\n        } else {\n            match j.classify() {\n                Category::Io => unreachable!(),\n                Category::Syntax | Category::Data => io::Error::new(io::ErrorKind::InvalidData, j),\n                Category::Eof => io::Error::new(io::ErrorKind::UnexpectedEof, j),\n            }\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Category":["/// Categorizes the cause of a `serde_json::Error`.\npub enum Category {\n    /// The error was caused by a failure to read or write bytes on an IO\n    /// stream.\n    Io,\n\n    /// The error was caused by input that was not syntactically valid JSON.\n    Syntax,\n\n    /// The error was caused by input data that was semantically incorrect.\n    ///\n    /// For example, JSON containing a number is semantically incorrect when the\n    /// type being deserialized into holds a String.\n    Data,\n\n    /// The error was caused by prematurely reaching the end of the input data.\n    ///\n    /// Callers that process streaming input may be interested in retrying the\n    /// deserialization once more data is available.\n    Eof,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Error":["/// This type represents all possible errors that can occur when serializing or\n/// deserializing JSON data.\npub struct Error {\n    /// This `Box` allows us to keep the size of `Error` as small as possible. A\n    /// larger `Error` type was substantially slower due to all the functions\n    /// that pass around `Result<T, Error>`.\n    err: Box<ErrorImpl>,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::Error::classify":["/// Categorizes the cause of this error.\n///\n/// - `Category::Io` - failure to read or write bytes on an IO stream\n/// - `Category::Syntax` - input that is not syntactically valid JSON\n/// - `Category::Data` - input data that is semantically incorrect\n/// - `Category::Eof` - unexpected end of the input data\npub fn classify(&self) -> Category{\n        match self.err.code {\n            ErrorCode::Message(_) => Category::Data,\n            ErrorCode::Io(_) => Category::Io,\n            ErrorCode::EofWhileParsingList\n            | ErrorCode::EofWhileParsingObject\n            | ErrorCode::EofWhileParsingString\n            | ErrorCode::EofWhileParsingValue => Category::Eof,\n            ErrorCode::ExpectedColon\n            | ErrorCode::ExpectedListCommaOrEnd\n            | ErrorCode::ExpectedObjectCommaOrEnd\n            | ErrorCode::ExpectedSomeIdent\n            | ErrorCode::ExpectedSomeValue\n            | ErrorCode::InvalidEscape\n            | ErrorCode::InvalidNumber\n            | ErrorCode::NumberOutOfRange\n            | ErrorCode::InvalidUnicodeCodePoint\n            | ErrorCode::ControlCharacterWhileParsingString\n            | ErrorCode::KeyMustBeAString\n            | ErrorCode::LoneLeadingSurrogateInHexEscape\n            | ErrorCode::TrailingComma\n            | ErrorCode::TrailingCharacters\n            | ErrorCode::UnexpectedEndOfHexEscape\n            | ErrorCode::RecursionLimitExceeded => Category::Syntax,\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::column":["/// One-based column number at which the error was detected.\n///\n/// The first character in the input and any characters immediately\n/// following a newline character are in column 1.\n///\n/// Note that errors may occur in column 0, for example if a read from an IO\n/// stream fails immediately following a previously read newline character.\npub fn column(&self) -> usize{\n        self.err.column\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::fix_position":["#[cold]\npub(crate) fn fix_position<F>(self, f: F) -> Self\n    where\n        F: FnOnce(ErrorCode) -> Error,{\n        if self.err.line == 0 {\n            f(self.err.code)\n        } else {\n            self\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::io":["#[doc(hidden)]\n#[cold]\npub fn io(error: io::Error) -> Self{\n        Error {\n            err: Box::new(ErrorImpl {\n                code: ErrorCode::Io(error),\n                line: 0,\n                column: 0,\n            }),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::is_data":["/// Returns true if this error was caused by input data that was\n/// semantically incorrect.\n///\n/// For example, JSON containing a number is semantically incorrect when the\n/// type being deserialized into holds a String.\npub fn is_data(&self) -> bool{\n        self.classify() == Category::Data\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::is_eof":["/// Returns true if this error was caused by prematurely reaching the end of\n/// the input data.\n///\n/// Callers that process streaming input may be interested in retrying the\n/// deserialization once more data is available.\npub fn is_eof(&self) -> bool{\n        self.classify() == Category::Eof\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::is_io":["/// Returns true if this error was caused by a failure to read or write\n/// bytes on an IO stream.\npub fn is_io(&self) -> bool{\n        self.classify() == Category::Io\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::is_syntax":["/// Returns true if this error was caused by input that was not\n/// syntactically valid JSON.\npub fn is_syntax(&self) -> bool{\n        self.classify() == Category::Syntax\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::line":["/// One-based line number at which the error was detected.\n///\n/// Characters in the first line of the input (before the first newline\n/// character) are in line 1.\npub fn line(&self) -> usize{\n        self.err.line\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::Error::syntax":["#[cold]\npub(crate) fn syntax(code: ErrorCode, line: usize, column: usize) -> Self{\n        Error {\n            err: Box::new(ErrorImpl { code, line, column }),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::ErrorCode":["pub(crate) enum ErrorCode {\n    /// Catchall for syntax error messages\n    Message(Box<str>),\n\n    /// Some IO error occurred while serializing or deserializing.\n    Io(io::Error),\n\n    /// EOF while parsing a list.\n    EofWhileParsingList,\n\n    /// EOF while parsing an object.\n    EofWhileParsingObject,\n\n    /// EOF while parsing a string.\n    EofWhileParsingString,\n\n    /// EOF while parsing a JSON value.\n    EofWhileParsingValue,\n\n    /// Expected this character to be a `':'`.\n    ExpectedColon,\n\n    /// Expected this character to be either a `','` or a `']'`.\n    ExpectedListCommaOrEnd,\n\n    /// Expected this character to be either a `','` or a `'}'`.\n    ExpectedObjectCommaOrEnd,\n\n    /// Expected to parse either a `true`, `false`, or a `null`.\n    ExpectedSomeIdent,\n\n    /// Expected this character to start a JSON value.\n    ExpectedSomeValue,\n\n    /// Invalid hex escape code.\n    InvalidEscape,\n\n    /// Invalid number.\n    InvalidNumber,\n\n    /// Number is bigger than the maximum value of its type.\n    NumberOutOfRange,\n\n    /// Invalid unicode code point.\n    InvalidUnicodeCodePoint,\n\n    /// Control character found while parsing a string.\n    ControlCharacterWhileParsingString,\n\n    /// Object key is not a string.\n    KeyMustBeAString,\n\n    /// Lone leading surrogate in hex escape.\n    LoneLeadingSurrogateInHexEscape,\n\n    /// JSON has a comma after the last value in an array or map.\n    TrailingComma,\n\n    /// JSON has non-whitespace trailing characters after the value.\n    TrailingCharacters,\n\n    /// Unexpected end of hex escape.\n    UnexpectedEndOfHexEscape,\n\n    /// Encountered nesting of JSON maps and arrays more than 128 layers deep.\n    RecursionLimitExceeded,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::ErrorImpl":["struct ErrorImpl {\n    code: ErrorCode,\n    line: usize,\n    column: usize,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::make_error":["fn make_error(mut msg: String) -> Error{\n    let (line, column) = parse_line_col(&mut msg).unwrap_or((0, 0));\n    Error {\n        err: Box::new(ErrorImpl {\n            code: ErrorCode::Message(msg.into_boxed_str()),\n            line,\n            column,\n        }),\n    }\n}","Real(LocalPath(\"src/error.rs\"))"],"error::parse_line_col":["fn parse_line_col(msg: &mut String) -> Option<(usize, usize)>{\n    let start_of_suffix = match msg.rfind(\" at line \") {\n        Some(index) => index,\n        None => return None,\n    };\n\n    // Find start and end of line number.\n    let start_of_line = start_of_suffix + \" at line \".len();\n    let mut end_of_line = start_of_line;\n    while starts_with_digit(&msg[end_of_line..]) {\n        end_of_line += 1;\n    }\n\n    if !msg[end_of_line..].starts_with(\" column \") {\n        return None;\n    }\n\n    // Find start and end of column number.\n    let start_of_column = end_of_line + \" column \".len();\n    let mut end_of_column = start_of_column;\n    while starts_with_digit(&msg[end_of_column..]) {\n        end_of_column += 1;\n    }\n\n    if end_of_column < msg.len() {\n        return None;\n    }\n\n    // Parse numbers.\n    let line = match usize::from_str(&msg[start_of_line..end_of_line]) {\n        Ok(line) => line,\n        Err(_) => return None,\n    };\n    let column = match usize::from_str(&msg[start_of_column..end_of_column]) {\n        Ok(column) => column,\n        Err(_) => return None,\n    };\n\n    msg.truncate(start_of_suffix);\n    Some((line, column))\n}","Real(LocalPath(\"src/error.rs\"))"],"error::starts_with_digit":["fn starts_with_digit(slice: &str) -> bool{\n    match slice.as_bytes().first() {\n        None => false,\n        Some(&byte) => byte >= b'0' && byte <= b'9',\n    }\n}","Real(LocalPath(\"src/error.rs\"))"],"iter::LineColIterator":["pub struct LineColIterator<I> {\n    iter: I,\n\n    /// Index of the current line. Characters in the first line of the input\n    /// (before the first newline character) are in line 1.\n    line: usize,\n\n    /// Index of the current column. The first character in the input and any\n    /// characters immediately following a newline character are in column 1.\n    /// The column is 0 immediately after a newline character has been read.\n    col: usize,\n\n    /// Byte offset of the start of the current line. This is the sum of lengths\n    /// of all previous lines. Keeping track of things this way allows efficient\n    /// computation of the current line, column, and byte offset while only\n    /// updating one of the counters in `next()` in the common case.\n    start_of_line: usize,\n}","Real(LocalPath(\"src/iter.rs\"))"],"iter::LineColIterator::<I>::byte_offset":["pub fn byte_offset(&self) -> usize{\n        self.start_of_line + self.col\n    }","Real(LocalPath(\"src/iter.rs\"))"],"iter::LineColIterator::<I>::col":["pub fn col(&self) -> usize{\n        self.col\n    }","Real(LocalPath(\"src/iter.rs\"))"],"iter::LineColIterator::<I>::line":["pub fn line(&self) -> usize{\n        self.line\n    }","Real(LocalPath(\"src/iter.rs\"))"],"iter::LineColIterator::<I>::new":["pub fn new(iter: I) -> LineColIterator<I>{\n        LineColIterator {\n            iter,\n            line: 1,\n            col: 0,\n            start_of_line: 0,\n        }\n    }","Real(LocalPath(\"src/iter.rs\"))"],"map::Entry":["/// A view into a single entry in a map, which may either be vacant or occupied.\n/// This enum is constructed from the [`entry`] method on [`Map`].\n///\n/// [`entry`]: struct.Map.html#method.entry\n/// [`Map`]: struct.Map.html\npub enum Entry<'a> {\n    /// A vacant Entry.\n    Vacant(VacantEntry<'a>),\n    /// An occupied Entry.\n    Occupied(OccupiedEntry<'a>),\n}","Real(LocalPath(\"src/map.rs\"))"],"map::Entry::<'a>::and_modify":["/// Provides in-place mutable access to an occupied entry before any\n/// potential inserts into the map.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut map = serde_json::Map::new();\n/// map.entry(\"serde\")\n///     .and_modify(|e| *e = json!(\"rust\"))\n///     .or_insert(json!(\"cpp\"));\n///\n/// assert_eq!(map[\"serde\"], \"cpp\");\n///\n/// map.entry(\"serde\")\n///     .and_modify(|e| *e = json!(\"rust\"))\n///     .or_insert(json!(\"cpp\"));\n///\n/// assert_eq!(map[\"serde\"], \"rust\");\n/// ```\npub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut Value),{\n        match self {\n            Entry::Occupied(mut entry) => {\n                f(entry.get_mut());\n                Entry::Occupied(entry)\n            }\n            Entry::Vacant(entry) => Entry::Vacant(entry),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Entry::<'a>::key":["/// Returns a reference to this entry's key.\n///\n/// # Examples\n///\n/// ```\n/// let mut map = serde_json::Map::new();\n/// assert_eq!(map.entry(\"serde\").key(), &\"serde\");\n/// ```\npub fn key(&self) -> &String{\n        match self {\n            Entry::Vacant(e) => e.key(),\n            Entry::Occupied(e) => e.key(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Entry::<'a>::or_insert":["/// Ensures a value is in the entry by inserting the default if empty, and\n/// returns a mutable reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut map = serde_json::Map::new();\n/// map.entry(\"serde\").or_insert(json!(12));\n///\n/// assert_eq!(map[\"serde\"], 12);\n/// ```\npub fn or_insert(self, default: Value) -> &'a mut Value{\n        match self {\n            Entry::Vacant(entry) => entry.insert(default),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Entry::<'a>::or_insert_with":["/// Ensures a value is in the entry by inserting the result of the default\n/// function if empty, and returns a mutable reference to the value in the\n/// entry.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut map = serde_json::Map::new();\n/// map.entry(\"serde\").or_insert_with(|| json!(\"hoho\"));\n///\n/// assert_eq!(map[\"serde\"], \"hoho\".to_owned());\n/// ```\npub fn or_insert_with<F>(self, default: F) -> &'a mut Value\n    where\n        F: FnOnce() -> Value,{\n        match self {\n            Entry::Vacant(entry) => entry.insert(default()),\n            Entry::Occupied(entry) => entry.into_mut(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::IntoIter":["/// An owning iterator over a serde_json::Map's entries.\npub struct IntoIter {\n    iter: IntoIterImpl,\n}","Real(LocalPath(\"src/map.rs\"))"],"map::Iter":["/// An iterator over a serde_json::Map's entries.\npub struct Iter<'a> {\n    iter: IterImpl<'a>,\n}","Real(LocalPath(\"src/map.rs\"))"],"map::IterMut":["/// A mutable iterator over a serde_json::Map's entries.\npub struct IterMut<'a> {\n    iter: IterMutImpl<'a>,\n}","Real(LocalPath(\"src/map.rs\"))"],"map::Keys":["/// An iterator over a serde_json::Map's keys.\npub struct Keys<'a> {\n    iter: KeysImpl<'a>,\n}","Real(LocalPath(\"src/map.rs\"))"],"map::Map":["/// Represents a JSON key/value type.\npub struct Map<K, V> {\n    map: MapImpl<K, V>,\n}","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::append":["/// Moves all elements from other into self, leaving other empty.\n#[inline]\npub fn append(&mut self, other: &mut Self){\n        #[cfg(feature = \"preserve_order\")]\n        self.map\n            .extend(mem::replace(&mut other.map, MapImpl::default()));\n        #[cfg(not(feature = \"preserve_order\"))]\n        self.map.append(&mut other.map);\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::clear":["/// Clears the map, removing all values.\n#[inline]\npub fn clear(&mut self){\n        self.map.clear();\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::contains_key":["/// Returns true if the map contains a value for the specified key.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\npub fn contains_key<Q>(&self, key: &Q) -> bool\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,{\n        self.map.contains_key(key)\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::entry":["/// Gets the given key's corresponding entry in the map for in-place\n/// manipulation.\npub fn entry<S>(&mut self, key: S) -> Entry\n    where\n        S: Into<String>,{\n        #[cfg(not(feature = \"preserve_order\"))]\n        use alloc::collections::btree_map::Entry as EntryImpl;\n        #[cfg(feature = \"preserve_order\")]\n        use indexmap::map::Entry as EntryImpl;\n\n        match self.map.entry(key.into()) {\n            EntryImpl::Vacant(vacant) => Entry::Vacant(VacantEntry { vacant }),\n            EntryImpl::Occupied(occupied) => Entry::Occupied(OccupiedEntry { occupied }),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::get":["/// Returns a reference to the value corresponding to the key.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\npub fn get<Q>(&self, key: &Q) -> Option<&Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,{\n        self.map.get(key)\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::get_key_value":["/// Returns the key-value pair matching the given key.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\n#[cfg(any(feature = \"preserve_order\", not(no_btreemap_get_key_value)))]\npub fn get_key_value<Q>(&self, key: &Q) -> Option<(&String, &Value)>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,{\n        self.map.get_key_value(key)\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::get_mut":["/// Returns a mutable reference to the value corresponding to the key.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\npub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,{\n        self.map.get_mut(key)\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::insert":["/// Inserts a key-value pair into the map.\n///\n/// If the map did not have this key present, `None` is returned.\n///\n/// If the map did have this key present, the value is updated, and the old\n/// value is returned.\n#[inline]\npub fn insert(&mut self, k: String, v: Value) -> Option<Value>{\n        self.map.insert(k, v)\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::is_empty":["/// Returns true if the map contains no elements.\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.map.is_empty()\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::iter":["/// Gets an iterator over the entries of the map.\n#[inline]\npub fn iter(&self) -> Iter{\n        Iter {\n            iter: self.map.iter(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::iter_mut":["/// Gets a mutable iterator over the entries of the map.\n#[inline]\npub fn iter_mut(&mut self) -> IterMut{\n        IterMut {\n            iter: self.map.iter_mut(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::keys":["/// Gets an iterator over the keys of the map.\n#[inline]\npub fn keys(&self) -> Keys{\n        Keys {\n            iter: self.map.keys(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::len":["/// Returns the number of elements in the map.\n#[inline]\npub fn len(&self) -> usize{\n        self.map.len()\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::new":["/// Makes a new empty Map.\n#[inline]\npub fn new() -> Self{\n        Map {\n            map: MapImpl::new(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::remove":["/// Removes a key from the map, returning the value at the key if the key\n/// was previously in the map.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\n#[inline]\npub fn remove<Q>(&mut self, key: &Q) -> Option<Value>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,{\n        #[cfg(feature = \"preserve_order\")]\n        return self.map.swap_remove(key);\n        #[cfg(not(feature = \"preserve_order\"))]\n        return self.map.remove(key);\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::remove_entry":["/// Removes a key from the map, returning the stored key and value if the\n/// key was previously in the map.\n///\n/// The key may be any borrowed form of the map's key type, but the ordering\n/// on the borrowed form *must* match the ordering on the key type.\npub fn remove_entry<Q>(&mut self, key: &Q) -> Option<(String, Value)>\n    where\n        String: Borrow<Q>,\n        Q: ?Sized + Ord + Eq + Hash,{\n        #[cfg(any(feature = \"preserve_order\", not(no_btreemap_remove_entry)))]\n        return self.map.remove_entry(key);\n        #[cfg(all(\n            not(feature = \"preserve_order\"),\n            no_btreemap_remove_entry,\n            not(no_btreemap_get_key_value),\n        ))]\n        {\n            let (key, _value) = self.map.get_key_value(key)?;\n            let key = key.clone();\n            let value = self.map.remove::<String>(&key)?;\n            Some((key, value))\n        }\n        #[cfg(all(\n            not(feature = \"preserve_order\"),\n            no_btreemap_remove_entry,\n            no_btreemap_get_key_value,\n        ))]\n        {\n            use core::ops::{Bound, RangeBounds};\n\n            struct Key<'a, Q: ?Sized>(&'a Q);\n\n            impl<'a, Q: ?Sized> RangeBounds<Q> for Key<'a, Q> {\n                fn start_bound(&self) -> Bound<&Q> {\n                    Bound::Included(self.0)\n                }\n                fn end_bound(&self) -> Bound<&Q> {\n                    Bound::Included(self.0)\n                }\n            }\n\n            let mut range = self.map.range(Key(key));\n            let (key, _value) = range.next()?;\n            let key = key.clone();\n            let value = self.map.remove::<String>(&key)?;\n            Some((key, value))\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::retain":["/// Retains only the elements specified by the predicate.\n///\n/// In other words, remove all pairs `(k, v)` such that `f(&k, &mut v)`\n/// returns `false`.\n#[cfg(not(no_btreemap_retain))]\n#[inline]\npub fn retain<F>(&mut self, f: F)\n    where\n        F: FnMut(&String, &mut Value) -> bool,{\n        self.map.retain(f);\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::values":["/// Gets an iterator over the values of the map.\n#[inline]\npub fn values(&self) -> Values{\n        Values {\n            iter: self.map.values(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::values_mut":["/// Gets an iterator over mutable values of the map.\n#[inline]\npub fn values_mut(&mut self) -> ValuesMut{\n        ValuesMut {\n            iter: self.map.values_mut(),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Map::<std::string::String, value::Value>::with_capacity":["/// Makes a new empty Map with the given initial capacity.\n#[inline]\npub fn with_capacity(capacity: usize) -> Self{\n        Map {\n            #[cfg(not(feature = \"preserve_order\"))]\n            map: {\n                // does not support with_capacity\n                let _ = capacity;\n                BTreeMap::new()\n            },\n            #[cfg(feature = \"preserve_order\")]\n            map: IndexMap::with_capacity(capacity),\n        }\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::OccupiedEntry":["/// An occupied Entry. It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\npub struct OccupiedEntry<'a> {\n    occupied: OccupiedEntryImpl<'a>,\n}","Real(LocalPath(\"src/map.rs\"))"],"map::OccupiedEntry::<'a>::get":["/// Gets a reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!(12));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(occupied) => {\n///         assert_eq!(occupied.get(), 12);\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn get(&self) -> &Value{\n        self.occupied.get()\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::OccupiedEntry::<'a>::get_mut":["/// Gets a mutable reference to the value in the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!([1, 2, 3]));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(mut occupied) => {\n///         occupied.get_mut().as_array_mut().unwrap().push(json!(4));\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n///\n/// assert_eq!(map[\"serde\"].as_array().unwrap().len(), 4);\n/// ```\n#[inline]\npub fn get_mut(&mut self) -> &mut Value{\n        self.occupied.get_mut()\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::OccupiedEntry::<'a>::insert":["/// Sets the value of the entry with the `OccupiedEntry`'s key, and returns\n/// the entry's old value.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!(12));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(mut occupied) => {\n///         assert_eq!(occupied.insert(json!(13)), 12);\n///         assert_eq!(occupied.get(), 13);\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn insert(&mut self, value: Value) -> Value{\n        self.occupied.insert(value)\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::OccupiedEntry::<'a>::into_mut":["/// Converts the entry into a mutable reference to its value.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!([1, 2, 3]));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(mut occupied) => {\n///         occupied.into_mut().as_array_mut().unwrap().push(json!(4));\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n///\n/// assert_eq!(map[\"serde\"].as_array().unwrap().len(), 4);\n/// ```\n#[inline]\npub fn into_mut(self) -> &'a mut Value{\n        self.occupied.into_mut()\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::OccupiedEntry::<'a>::key":["/// Gets a reference to the key in the entry.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!(12));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(occupied) => {\n///         assert_eq!(occupied.key(), &\"serde\");\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn key(&self) -> &String{\n        self.occupied.key()\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::OccupiedEntry::<'a>::remove":["/// Takes the value of the entry out of the map, and returns it.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n/// map.insert(\"serde\".to_owned(), json!(12));\n///\n/// match map.entry(\"serde\") {\n///     Entry::Occupied(occupied) => {\n///         assert_eq!(occupied.remove(), 12);\n///     }\n///     Entry::Vacant(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn remove(self) -> Value{\n        #[cfg(feature = \"preserve_order\")]\n        return self.occupied.swap_remove();\n        #[cfg(not(feature = \"preserve_order\"))]\n        return self.occupied.remove();\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::VacantEntry":["/// A vacant Entry. It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\npub struct VacantEntry<'a> {\n    vacant: VacantEntryImpl<'a>,\n}","Real(LocalPath(\"src/map.rs\"))"],"map::VacantEntry::<'a>::insert":["/// Sets the value of the entry with the VacantEntry's key, and returns a\n/// mutable reference to it.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n///\n/// match map.entry(\"serde\") {\n///     Entry::Vacant(vacant) => {\n///         vacant.insert(json!(\"hoho\"));\n///     }\n///     Entry::Occupied(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn insert(self, value: Value) -> &'a mut Value{\n        self.vacant.insert(value)\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::VacantEntry::<'a>::key":["/// Gets a reference to the key that would be used when inserting a value\n/// through the VacantEntry.\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::map::Entry;\n///\n/// let mut map = serde_json::Map::new();\n///\n/// match map.entry(\"serde\") {\n///     Entry::Vacant(vacant) => {\n///         assert_eq!(vacant.key(), &\"serde\");\n///     }\n///     Entry::Occupied(_) => unimplemented!(),\n/// }\n/// ```\n#[inline]\npub fn key(&self) -> &String{\n        self.vacant.key()\n    }","Real(LocalPath(\"src/map.rs\"))"],"map::Values":["/// An iterator over a serde_json::Map's values.\npub struct Values<'a> {\n    iter: ValuesImpl<'a>,\n}","Real(LocalPath(\"src/map.rs\"))"],"map::ValuesMut":["/// A mutable iterator over a serde_json::Map's values.\npub struct ValuesMut<'a> {\n    iter: ValuesMutImpl<'a>,\n}","Real(LocalPath(\"src/map.rs\"))"],"number::N":["#[cfg(not(feature = \"arbitrary_precision\"))]\nenum N {\n    PosInt(u64),\n    /// Always less than zero.\n    NegInt(i64),\n    /// Always finite.\n    Float(f64),\n}","Real(LocalPath(\"src/number.rs\"))"],"number::Number":["/// Represents a JSON number, whether integer or floating point.\npub struct Number {\n    n: N,\n}","Real(LocalPath(\"src/number.rs\"))"],"number::Number::as_f32":["pub(crate) fn as_f32(&self) -> Option<f32>{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n as f32),\n            N::NegInt(n) => Some(n as f32),\n            N::Float(n) => Some(n as f32),\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse::<f32>().ok().filter(|float| float.is_finite())\n    }","Real(LocalPath(\"src/number.rs\"))"],"number::Number::as_f64":["/// Represents the number as f64 if possible. Returns None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 256.0, \"b\": 64, \"c\": -64 });\n///\n/// assert_eq!(v[\"a\"].as_f64(), Some(256.0));\n/// assert_eq!(v[\"b\"].as_f64(), Some(64.0));\n/// assert_eq!(v[\"c\"].as_f64(), Some(-64.0));\n/// ```\n#[inline]\npub fn as_f64(&self) -> Option<f64>{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n as f64),\n            N::NegInt(n) => Some(n as f64),\n            N::Float(n) => Some(n),\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse::<f64>().ok().filter(|float| float.is_finite())\n    }","Real(LocalPath(\"src/number.rs\"))"],"number::Number::as_i64":["/// If the `Number` is an integer, represent it as i64 if possible. Returns\n/// None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let big = i64::max_value() as u64 + 10;\n/// let v = json!({ \"a\": 64, \"b\": big, \"c\": 256.0 });\n///\n/// assert_eq!(v[\"a\"].as_i64(), Some(64));\n/// assert_eq!(v[\"b\"].as_i64(), None);\n/// assert_eq!(v[\"c\"].as_i64(), None);\n/// ```\n#[inline]\npub fn as_i64(&self) -> Option<i64>{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => {\n                if n <= i64::max_value() as u64 {\n                    Some(n as i64)\n                } else {\n                    None\n                }\n            }\n            N::NegInt(n) => Some(n),\n            N::Float(_) => None,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse().ok()\n    }","Real(LocalPath(\"src/number.rs\"))"],"number::Number::as_u64":["/// If the `Number` is an integer, represent it as u64 if possible. Returns\n/// None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 64, \"b\": -64, \"c\": 256.0 });\n///\n/// assert_eq!(v[\"a\"].as_u64(), Some(64));\n/// assert_eq!(v[\"b\"].as_u64(), None);\n/// assert_eq!(v[\"c\"].as_u64(), None);\n/// ```\n#[inline]\npub fn as_u64(&self) -> Option<u64>{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(n) => Some(n),\n            N::NegInt(_) | N::Float(_) => None,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.n.parse().ok()\n    }","Real(LocalPath(\"src/number.rs\"))"],"number::Number::from_f32":["pub(crate) fn from_f32(f: f32) -> Option<Number>{\n        if f.is_finite() {\n            let n = {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::Float(f as f64)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    ryu::Buffer::new().format_finite(f).to_owned()\n                }\n            };\n            Some(Number { n })\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/number.rs\"))"],"number::Number::from_f64":["/// Converts a finite `f64` to a `Number`. Infinite or NaN values are not JSON\n/// numbers.\n///\n/// ```\n/// # use std::f64;\n/// #\n/// # use serde_json::Number;\n/// #\n/// assert!(Number::from_f64(256.0).is_some());\n///\n/// assert!(Number::from_f64(f64::NAN).is_none());\n/// ```\n#[inline]\npub fn from_f64(f: f64) -> Option<Number>{\n        if f.is_finite() {\n            let n = {\n                #[cfg(not(feature = \"arbitrary_precision\"))]\n                {\n                    N::Float(f)\n                }\n                #[cfg(feature = \"arbitrary_precision\")]\n                {\n                    ryu::Buffer::new().format_finite(f).to_owned()\n                }\n            };\n            Some(Number { n })\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/number.rs\"))"],"number::Number::is_f64":["/// Returns true if the `Number` can be represented by f64.\n///\n/// For any Number on which `is_f64` returns true, `as_f64` is guaranteed to\n/// return the floating point value.\n///\n/// Currently this function returns true if and only if both `is_i64` and\n/// `is_u64` return false but this is not a guarantee in the future.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 256.0, \"b\": 64, \"c\": -64 });\n///\n/// assert!(v[\"a\"].is_f64());\n///\n/// // Integers.\n/// assert!(!v[\"b\"].is_f64());\n/// assert!(!v[\"c\"].is_f64());\n/// ```\n#[inline]\npub fn is_f64(&self) -> bool{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::Float(_) => true,\n            N::PosInt(_) | N::NegInt(_) => false,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        {\n            for c in self.n.chars() {\n                if c == '.' || c == 'e' || c == 'E' {\n                    return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);\n                }\n            }\n            false\n        }\n    }","Real(LocalPath(\"src/number.rs\"))"],"number::Number::is_i64":["/// Returns true if the `Number` is an integer between `i64::MIN` and\n/// `i64::MAX`.\n///\n/// For any Number on which `is_i64` returns true, `as_i64` is guaranteed to\n/// return the integer value.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let big = i64::max_value() as u64 + 10;\n/// let v = json!({ \"a\": 64, \"b\": big, \"c\": 256.0 });\n///\n/// assert!(v[\"a\"].is_i64());\n///\n/// // Greater than i64::MAX.\n/// assert!(!v[\"b\"].is_i64());\n///\n/// // Numbers with a decimal point are not considered integers.\n/// assert!(!v[\"c\"].is_i64());\n/// ```\n#[inline]\npub fn is_i64(&self) -> bool{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(v) => v <= i64::max_value() as u64,\n            N::NegInt(_) => true,\n            N::Float(_) => false,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.as_i64().is_some()\n    }","Real(LocalPath(\"src/number.rs\"))"],"number::Number::is_u64":["/// Returns true if the `Number` is an integer between zero and `u64::MAX`.\n///\n/// For any Number on which `is_u64` returns true, `as_u64` is guaranteed to\n/// return the integer value.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 64, \"b\": -64, \"c\": 256.0 });\n///\n/// assert!(v[\"a\"].is_u64());\n///\n/// // Negative integer.\n/// assert!(!v[\"b\"].is_u64());\n///\n/// // Numbers with a decimal point are not considered integers.\n/// assert!(!v[\"c\"].is_u64());\n/// ```\n#[inline]\npub fn is_u64(&self) -> bool{\n        #[cfg(not(feature = \"arbitrary_precision\"))]\n        match self.n {\n            N::PosInt(_) => true,\n            N::NegInt(_) | N::Float(_) => false,\n        }\n        #[cfg(feature = \"arbitrary_precision\")]\n        self.as_u64().is_some()\n    }","Real(LocalPath(\"src/number.rs\"))"],"number::Number::unexpected":["#[cfg(not(feature = \"arbitrary_precision\"))]\n#[cold]\npub(crate) fn unexpected(&self) -> Unexpected{\n        match self.n {\n            N::PosInt(u) => Unexpected::Unsigned(u),\n            N::NegInt(i) => Unexpected::Signed(i),\n            N::Float(f) => Unexpected::Float(f),\n        }\n    }","Real(LocalPath(\"src/number.rs\"))"],"read::Fused":["/// Marker for whether StreamDeserializer can implement FusedIterator.\npub trait Fused: private::Sealed {}","Real(LocalPath(\"src/read.rs\"))"],"read::IoRead":["/// JSON input source that reads from a std::io input stream.\n#[cfg(feature = \"std\")]\npub struct IoRead<R>\nwhere\n    R: io::Read,\n{\n    iter: LineColIterator<io::Bytes<R>>,\n    /// Temporary storage of peeked byte.\n    ch: Option<u8>,\n    #[cfg(feature = \"raw_value\")]\n    raw_buffer: Option<Vec<u8>>,\n}","Real(LocalPath(\"src/read.rs\"))"],"read::IoRead::<R>::new":["/// Create a JSON input source to read from a std::io input stream.\npub fn new(reader: R) -> Self{\n        IoRead {\n            iter: LineColIterator::new(reader.bytes()),\n            ch: None,\n            #[cfg(feature = \"raw_value\")]\n            raw_buffer: None,\n        }\n    }","Real(LocalPath(\"src/read.rs\"))"],"read::IoRead::<R>::parse_str_bytes":["fn parse_str_bytes<'s, T, F>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n        validate: bool,\n        result: F,\n    ) -> Result<T>\n    where\n        T: 's,\n        F: FnOnce(&'s Self, &'s [u8]) -> Result<T>,{\n        loop {\n            let ch = tri!(next_or_eof(self));\n            if !ESCAPE[ch as usize] {\n                scratch.push(ch);\n                continue;\n            }\n            match ch {\n                b'\"' => {\n                    return result(self, scratch);\n                }\n                b'\\\\' => {\n                    tri!(parse_escape(self, validate, scratch));\n                }\n                _ => {\n                    if validate {\n                        return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                    }\n                    scratch.push(ch);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/read.rs\"))"],"read::Position":["pub struct Position {\n    pub line: usize,\n    pub column: usize,\n}","Real(LocalPath(\"src/read.rs\"))"],"read::Read":["/// Trait used by the deserializer for iterating over input. This is manually\n/// \"specialized\" for iterating over &[u8]. Once feature(specialization) is\n/// stable we can use actual specialization.\n///\n/// This trait is sealed and cannot be implemented for types outside of\n/// `serde_json`.\npub trait Read<'de>: private::Sealed {\n    #[doc(hidden)]\n    fn next(&mut self) -> Result<Option<u8>>;\n    #[doc(hidden)]\n    fn peek(&mut self) -> Result<Option<u8>>;\n\n    /// Only valid after a call to peek(). Discards the peeked byte.\n    #[doc(hidden)]\n    fn discard(&mut self);\n\n    /// Position of the most recent call to next().\n    ///\n    /// The most recent call was probably next() and not peek(), but this method\n    /// should try to return a sensible result if the most recent call was\n    /// actually peek() because we don't always know.\n    ///\n    /// Only called in case of an error, so performance is not important.\n    #[doc(hidden)]\n    fn position(&self) -> Position;\n\n    /// Position of the most recent call to peek().\n    ///\n    /// The most recent call was probably peek() and not next(), but this method\n    /// should try to return a sensible result if the most recent call was\n    /// actually next() because we don't always know.\n    ///\n    /// Only called in case of an error, so performance is not important.\n    #[doc(hidden)]\n    fn peek_position(&self) -> Position;\n\n    /// Offset from the beginning of the input to the next byte that would be\n    /// returned by next() or peek().\n    #[doc(hidden)]\n    fn byte_offset(&self) -> usize;\n\n    /// Assumes the previous byte was a quotation mark. Parses a JSON-escaped\n    /// string until the next quotation mark using the given scratch space if\n    /// necessary. The scratch space is initially empty.\n    #[doc(hidden)]\n    fn parse_str<'s>(&'s mut self, scratch: &'s mut Vec<u8>) -> Result<Reference<'de, 's, str>>;\n\n    /// Assumes the previous byte was a quotation mark. Parses a JSON-escaped\n    /// string until the next quotation mark using the given scratch space if\n    /// necessary. The scratch space is initially empty.\n    ///\n    /// This function returns the raw bytes in the string with escape sequences\n    /// expanded but without performing unicode validation.\n    #[doc(hidden)]\n    fn parse_str_raw<'s>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n    ) -> Result<Reference<'de, 's, [u8]>>;\n\n    /// Assumes the previous byte was a quotation mark. Parses a JSON-escaped\n    /// string until the next quotation mark but discards the data.\n    #[doc(hidden)]\n    fn ignore_str(&mut self) -> Result<()>;\n\n    /// Assumes the previous byte was a hex escape sequnce ('\\u') in a string.\n    /// Parses next hexadecimal sequence.\n    #[doc(hidden)]\n    fn decode_hex_escape(&mut self) -> Result<u16>;\n\n    /// Switch raw buffering mode on.\n    ///\n    /// This is used when deserializing `RawValue`.\n    #[cfg(feature = \"raw_value\")]\n    #[doc(hidden)]\n    fn begin_raw_buffering(&mut self);\n\n    /// Switch raw buffering mode off and provides the raw buffered data to the\n    /// given visitor.\n    #[cfg(feature = \"raw_value\")]\n    #[doc(hidden)]\n    fn end_raw_buffering<V>(&mut self, visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'de>;\n\n    /// Whether StreamDeserializer::next needs to check the failed flag. True\n    /// for IoRead, false for StrRead and SliceRead which can track failure by\n    /// truncating their input slice to avoid the extra check on every next\n    /// call.\n    #[doc(hidden)]\n    const should_early_return_if_failed: bool;\n\n    /// Mark a persistent failure of StreamDeserializer, either by setting the\n    /// flag or by truncating the input data.\n    #[doc(hidden)]\n    fn set_failed(&mut self, failed: &mut bool);\n}","Real(LocalPath(\"src/read.rs\"))"],"read::Reference":["pub enum Reference<'b, 'c, T>\nwhere\n    T: ?Sized + 'static,\n{\n    Borrowed(&'b T),\n    Copied(&'c T),\n}","Real(LocalPath(\"src/read.rs\"))"],"read::SliceRead":["/// JSON input source that reads from a slice of bytes.\npub struct SliceRead<'a> {\n    slice: &'a [u8],\n    /// Index of the *next* byte that will be returned by next() or peek().\n    index: usize,\n    #[cfg(feature = \"raw_value\")]\n    raw_buffering_start_index: usize,\n}","Real(LocalPath(\"src/read.rs\"))"],"read::SliceRead::<'a>::new":["/// Create a JSON input source to read from a slice of bytes.\npub fn new(slice: &'a [u8]) -> Self{\n        SliceRead {\n            slice,\n            index: 0,\n            #[cfg(feature = \"raw_value\")]\n            raw_buffering_start_index: 0,\n        }\n    }","Real(LocalPath(\"src/read.rs\"))"],"read::SliceRead::<'a>::parse_str_bytes":["/// The big optimization here over IoRead is that if the string contains no\n/// backslash escape sequences, the returned &str is a slice of the raw JSON\n/// data so we avoid copying into the scratch space.\nfn parse_str_bytes<'s, T, F>(\n        &'s mut self,\n        scratch: &'s mut Vec<u8>,\n        validate: bool,\n        result: F,\n    ) -> Result<Reference<'a, 's, T>>\n    where\n        T: ?Sized + 's,\n        F: for<'f> FnOnce(&'s Self, &'f [u8]) -> Result<&'f T>,{\n        // Index of the first byte not yet copied into the scratch space.\n        let mut start = self.index;\n\n        loop {\n            while self.index < self.slice.len() && !ESCAPE[self.slice[self.index] as usize] {\n                self.index += 1;\n            }\n            if self.index == self.slice.len() {\n                return error(self, ErrorCode::EofWhileParsingString);\n            }\n            match self.slice[self.index] {\n                b'\"' => {\n                    if scratch.is_empty() {\n                        // Fast path: return a slice of the raw JSON without any\n                        // copying.\n                        let borrowed = &self.slice[start..self.index];\n                        self.index += 1;\n                        return result(self, borrowed).map(Reference::Borrowed);\n                    } else {\n                        scratch.extend_from_slice(&self.slice[start..self.index]);\n                        self.index += 1;\n                        return result(self, scratch).map(Reference::Copied);\n                    }\n                }\n                b'\\\\' => {\n                    scratch.extend_from_slice(&self.slice[start..self.index]);\n                    self.index += 1;\n                    tri!(parse_escape(self, validate, scratch));\n                    start = self.index;\n                }\n                _ => {\n                    self.index += 1;\n                    if validate {\n                        return error(self, ErrorCode::ControlCharacterWhileParsingString);\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/read.rs\"))"],"read::SliceRead::<'a>::position_of_index":["fn position_of_index(&self, i: usize) -> Position{\n        let mut position = Position { line: 1, column: 0 };\n        for ch in &self.slice[..i] {\n            match *ch {\n                b'\\n' => {\n                    position.line += 1;\n                    position.column = 0;\n                }\n                _ => {\n                    position.column += 1;\n                }\n            }\n        }\n        position\n    }","Real(LocalPath(\"src/read.rs\"))"],"read::StrRead":["/// JSON input source that reads from a UTF-8 string.\npub struct StrRead<'a> {\n    delegate: SliceRead<'a>,\n    #[cfg(feature = \"raw_value\")]\n    data: &'a str,\n}","Real(LocalPath(\"src/read.rs\"))"],"read::StrRead::<'a>::new":["/// Create a JSON input source to read from a UTF-8 string.\npub fn new(s: &'a str) -> Self{\n        StrRead {\n            delegate: SliceRead::new(s.as_bytes()),\n            #[cfg(feature = \"raw_value\")]\n            data: s,\n        }\n    }","Real(LocalPath(\"src/read.rs\"))"],"read::as_str":["fn as_str<'de, 's, R: Read<'de>>(read: &R, slice: &'s [u8]) -> Result<&'s str>{\n    str::from_utf8(slice).or_else(|_| error(read, ErrorCode::InvalidUnicodeCodePoint))\n}","Real(LocalPath(\"src/read.rs\"))"],"read::decode_hex_val":["fn decode_hex_val(val: u8) -> Option<u16>{\n    let n = HEX[val as usize] as u16;\n    if n == 255 {\n        None\n    } else {\n        Some(n)\n    }\n}","Real(LocalPath(\"src/read.rs\"))"],"read::error":["fn error<'de, R, T>(read: &R, reason: ErrorCode) -> Result<T>\nwhere\n    R: ?Sized + Read<'de>,{\n    let position = read.position();\n    Err(Error::syntax(reason, position.line, position.column))\n}","Real(LocalPath(\"src/read.rs\"))"],"read::ignore_escape":["/// Parses a JSON escape sequence and discards the value. Assumes the previous\n/// byte read was a backslash.\nfn ignore_escape<'de, R>(read: &mut R) -> Result<()>\nwhere\n    R: ?Sized + Read<'de>,{\n    let ch = tri!(next_or_eof(read));\n\n    match ch {\n        b'\"' | b'\\\\' | b'/' | b'b' | b'f' | b'n' | b'r' | b't' => {}\n        b'u' => {\n            // At this point we don't care if the codepoint is valid. We just\n            // want to consume it. We don't actually know what is valid or not\n            // at this point, because that depends on if this string will\n            // ultimately be parsed into a string or a byte buffer in the \"real\"\n            // parse.\n\n            tri!(read.decode_hex_escape());\n        }\n        _ => {\n            return error(read, ErrorCode::InvalidEscape);\n        }\n    }\n\n    Ok(())\n}","Real(LocalPath(\"src/read.rs\"))"],"read::next_or_eof":["fn next_or_eof<'de, R>(read: &mut R) -> Result<u8>\nwhere\n    R: ?Sized + Read<'de>,{\n    match tri!(read.next()) {\n        Some(b) => Ok(b),\n        None => error(read, ErrorCode::EofWhileParsingString),\n    }\n}","Real(LocalPath(\"src/read.rs\"))"],"read::parse_escape":["/// Parses a JSON escape sequence and appends it into the scratch space. Assumes\n/// the previous byte read was a backslash.\nfn parse_escape<'de, R: Read<'de>>(\n    read: &mut R,\n    validate: bool,\n    scratch: &mut Vec<u8>,\n) -> Result<()>{\n    let ch = tri!(next_or_eof(read));\n\n    match ch {\n        b'\"' => scratch.push(b'\"'),\n        b'\\\\' => scratch.push(b'\\\\'),\n        b'/' => scratch.push(b'/'),\n        b'b' => scratch.push(b'\\x08'),\n        b'f' => scratch.push(b'\\x0c'),\n        b'n' => scratch.push(b'\\n'),\n        b'r' => scratch.push(b'\\r'),\n        b't' => scratch.push(b'\\t'),\n        b'u' => {\n            fn encode_surrogate(scratch: &mut Vec<u8>, n: u16) {\n                scratch.extend_from_slice(&[\n                    (n >> 12 & 0b0000_1111) as u8 | 0b1110_0000,\n                    (n >> 6 & 0b0011_1111) as u8 | 0b1000_0000,\n                    (n & 0b0011_1111) as u8 | 0b1000_0000,\n                ]);\n            }\n\n            let c = match tri!(read.decode_hex_escape()) {\n                n @ 0xDC00..=0xDFFF => {\n                    return if validate {\n                        error(read, ErrorCode::LoneLeadingSurrogateInHexEscape)\n                    } else {\n                        encode_surrogate(scratch, n);\n                        Ok(())\n                    };\n                }\n\n                // Non-BMP characters are encoded as a sequence of two hex\n                // escapes, representing UTF-16 surrogates. If deserializing a\n                // utf-8 string the surrogates are required to be paired,\n                // whereas deserializing a byte string accepts lone surrogates.\n                n1 @ 0xD800..=0xDBFF => {\n                    if tri!(peek_or_eof(read)) == b'\\\\' {\n                        read.discard();\n                    } else {\n                        return if validate {\n                            read.discard();\n                            error(read, ErrorCode::UnexpectedEndOfHexEscape)\n                        } else {\n                            encode_surrogate(scratch, n1);\n                            Ok(())\n                        };\n                    }\n\n                    if tri!(peek_or_eof(read)) == b'u' {\n                        read.discard();\n                    } else {\n                        return if validate {\n                            read.discard();\n                            error(read, ErrorCode::UnexpectedEndOfHexEscape)\n                        } else {\n                            encode_surrogate(scratch, n1);\n                            // The \\ prior to this byte started an escape sequence,\n                            // so we need to parse that now. This recursive call\n                            // does not blow the stack on malicious input because\n                            // the escape is not \\u, so it will be handled by one\n                            // of the easy nonrecursive cases.\n                            parse_escape(read, validate, scratch)\n                        };\n                    }\n\n                    let n2 = tri!(read.decode_hex_escape());\n\n                    if n2 < 0xDC00 || n2 > 0xDFFF {\n                        return error(read, ErrorCode::LoneLeadingSurrogateInHexEscape);\n                    }\n\n                    let n = (((n1 - 0xD800) as u32) << 10 | (n2 - 0xDC00) as u32) + 0x1_0000;\n\n                    match char::from_u32(n) {\n                        Some(c) => c,\n                        None => {\n                            return error(read, ErrorCode::InvalidUnicodeCodePoint);\n                        }\n                    }\n                }\n\n                // Every u16 outside of the surrogate ranges above is guaranteed\n                // to be a legal char.\n                n => char::from_u32(n as u32).unwrap(),\n            };\n\n            scratch.extend_from_slice(c.encode_utf8(&mut [0_u8; 4]).as_bytes());\n        }\n        _ => {\n            return error(read, ErrorCode::InvalidEscape);\n        }\n    }\n\n    Ok(())\n}","Real(LocalPath(\"src/read.rs\"))"],"read::parse_escape::encode_surrogate":["fn encode_surrogate(scratch: &mut Vec<u8>, n: u16){\n                scratch.extend_from_slice(&[\n                    (n >> 12 & 0b0000_1111) as u8 | 0b1110_0000,\n                    (n >> 6 & 0b0011_1111) as u8 | 0b1000_0000,\n                    (n & 0b0011_1111) as u8 | 0b1000_0000,\n                ]);\n            }","Real(LocalPath(\"src/read.rs\"))"],"read::peek_or_eof":["fn peek_or_eof<'de, R>(read: &mut R) -> Result<u8>\nwhere\n    R: ?Sized + Read<'de>,{\n    match tri!(read.peek()) {\n        Some(b) => Ok(b),\n        None => error(read, ErrorCode::EofWhileParsingString),\n    }\n}","Real(LocalPath(\"src/read.rs\"))"],"read::private::Sealed":["pub trait Sealed {}","Real(LocalPath(\"src/read.rs\"))"],"ser::CharEscape":["/// Represents a character escape code in a type-safe manner.\npub enum CharEscape {\n    /// An escaped quote `\"`\n    Quote,\n    /// An escaped reverse solidus `\\`\n    ReverseSolidus,\n    /// An escaped solidus `/`\n    Solidus,\n    /// An escaped backspace character (usually escaped as `\\b`)\n    Backspace,\n    /// An escaped form feed character (usually escaped as `\\f`)\n    FormFeed,\n    /// An escaped line feed character (usually escaped as `\\n`)\n    LineFeed,\n    /// An escaped carriage return character (usually escaped as `\\r`)\n    CarriageReturn,\n    /// An escaped tab character (usually escaped as `\\t`)\n    Tab,\n    /// An escaped ASCII plane control character (usually escaped as\n    /// `\\u00XX` where `XX` are two hex characters)\n    AsciiControl(u8),\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::CharEscape::from_escape_table":["#[inline]\nfn from_escape_table(escape: u8, byte: u8) -> CharEscape{\n        match escape {\n            self::BB => CharEscape::Backspace,\n            self::TT => CharEscape::Tab,\n            self::NN => CharEscape::LineFeed,\n            self::FF => CharEscape::FormFeed,\n            self::RR => CharEscape::CarriageReturn,\n            self::QU => CharEscape::Quote,\n            self::BS => CharEscape::ReverseSolidus,\n            self::UU => CharEscape::AsciiControl(byte),\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::CompactFormatter":["/// This structure compacts a JSON value with no extra whitespace.\npub struct CompactFormatter;","Real(LocalPath(\"src/ser.rs\"))"],"ser::Compound":["#[doc(hidden)]\npub enum Compound<'a, W: 'a, F: 'a> {\n    Map {\n        ser: &'a mut Serializer<W, F>,\n        state: State,\n    },\n    #[cfg(feature = \"arbitrary_precision\")]\n    Number { ser: &'a mut Serializer<W, F> },\n    #[cfg(feature = \"raw_value\")]\n    RawValue { ser: &'a mut Serializer<W, F> },\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter":["/// This trait abstracts away serializing the JSON control characters, which allows the user to\n/// optionally pretty print the JSON output.\npub trait Formatter {\n    /// Writes a `null` value to the specified writer.\n    #[inline]\n    fn write_null<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"null\")\n    }\n\n    /// Writes a `true` or `false` value to the specified writer.\n    #[inline]\n    fn write_bool<W>(&mut self, writer: &mut W, value: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let s = if value {\n            b\"true\" as &[u8]\n        } else {\n            b\"false\" as &[u8]\n        };\n        writer.write_all(s)\n    }\n\n    /// Writes an integer value like `-123` to the specified writer.\n    #[inline]\n    fn write_i8<W>(&mut self, writer: &mut W, value: i8) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `-123` to the specified writer.\n    #[inline]\n    fn write_i16<W>(&mut self, writer: &mut W, value: i16) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `-123` to the specified writer.\n    #[inline]\n    fn write_i32<W>(&mut self, writer: &mut W, value: i32) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `-123` to the specified writer.\n    #[inline]\n    fn write_i64<W>(&mut self, writer: &mut W, value: i64) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `-123` to the specified writer.\n    #[inline]\n    fn write_i128<W>(&mut self, writer: &mut W, value: i128) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `123` to the specified writer.\n    #[inline]\n    fn write_u8<W>(&mut self, writer: &mut W, value: u8) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `123` to the specified writer.\n    #[inline]\n    fn write_u16<W>(&mut self, writer: &mut W, value: u16) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `123` to the specified writer.\n    #[inline]\n    fn write_u32<W>(&mut self, writer: &mut W, value: u32) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `123` to the specified writer.\n    #[inline]\n    fn write_u64<W>(&mut self, writer: &mut W, value: u64) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes an integer value like `123` to the specified writer.\n    #[inline]\n    fn write_u128<W>(&mut self, writer: &mut W, value: u128) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes a floating point value like `-31.26e+12` to the specified writer.\n    #[inline]\n    fn write_f32<W>(&mut self, writer: &mut W, value: f32) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = ryu::Buffer::new();\n        let s = buffer.format_finite(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes a floating point value like `-31.26e+12` to the specified writer.\n    #[inline]\n    fn write_f64<W>(&mut self, writer: &mut W, value: f64) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        let mut buffer = ryu::Buffer::new();\n        let s = buffer.format_finite(value);\n        writer.write_all(s.as_bytes())\n    }\n\n    /// Writes a number that has already been rendered to a string.\n    #[inline]\n    fn write_number_str<W>(&mut self, writer: &mut W, value: &str) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(value.as_bytes())\n    }\n\n    /// Called before each series of `write_string_fragment` and\n    /// `write_char_escape`.  Writes a `\"` to the specified writer.\n    #[inline]\n    fn begin_string<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"\\\"\")\n    }\n\n    /// Called after each series of `write_string_fragment` and\n    /// `write_char_escape`.  Writes a `\"` to the specified writer.\n    #[inline]\n    fn end_string<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"\\\"\")\n    }\n\n    /// Writes a string fragment that doesn't need any escaping to the\n    /// specified writer.\n    #[inline]\n    fn write_string_fragment<W>(&mut self, writer: &mut W, fragment: &str) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(fragment.as_bytes())\n    }\n\n    /// Writes a character escape code to the specified writer.\n    #[inline]\n    fn write_char_escape<W>(&mut self, writer: &mut W, char_escape: CharEscape) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        use self::CharEscape::*;\n\n        let s = match char_escape {\n            Quote => b\"\\\\\\\"\",\n            ReverseSolidus => b\"\\\\\\\\\",\n            Solidus => b\"\\\\/\",\n            Backspace => b\"\\\\b\",\n            FormFeed => b\"\\\\f\",\n            LineFeed => b\"\\\\n\",\n            CarriageReturn => b\"\\\\r\",\n            Tab => b\"\\\\t\",\n            AsciiControl(byte) => {\n                static HEX_DIGITS: [u8; 16] = *b\"0123456789abcdef\";\n                let bytes = &[\n                    b'\\\\',\n                    b'u',\n                    b'0',\n                    b'0',\n                    HEX_DIGITS[(byte >> 4) as usize],\n                    HEX_DIGITS[(byte & 0xF) as usize],\n                ];\n                return writer.write_all(bytes);\n            }\n        };\n\n        writer.write_all(s)\n    }\n\n    /// Called before every array.  Writes a `[` to the specified\n    /// writer.\n    #[inline]\n    fn begin_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"[\")\n    }\n\n    /// Called after every array.  Writes a `]` to the specified\n    /// writer.\n    #[inline]\n    fn end_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"]\")\n    }\n\n    /// Called before every array value.  Writes a `,` if needed to\n    /// the specified writer.\n    #[inline]\n    fn begin_array_value<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        if first {\n            Ok(())\n        } else {\n            writer.write_all(b\",\")\n        }\n    }\n\n    /// Called after every array value.\n    #[inline]\n    fn end_array_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        Ok(())\n    }\n\n    /// Called before every object.  Writes a `{` to the specified\n    /// writer.\n    #[inline]\n    fn begin_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"{\")\n    }\n\n    /// Called after every object.  Writes a `}` to the specified\n    /// writer.\n    #[inline]\n    fn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\"}\")\n    }\n\n    /// Called before every object key.\n    #[inline]\n    fn begin_object_key<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        if first {\n            Ok(())\n        } else {\n            writer.write_all(b\",\")\n        }\n    }\n\n    /// Called after every object key.  A `:` should be written to the\n    /// specified writer by either this method or\n    /// `begin_object_value`.\n    #[inline]\n    fn end_object_key<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        Ok(())\n    }\n\n    /// Called before every object value.  A `:` should be written to\n    /// the specified writer by either this method or\n    /// `end_object_key`.\n    #[inline]\n    fn begin_object_value<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(b\":\")\n    }\n\n    /// Called after every object value.\n    #[inline]\n    fn end_object_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        Ok(())\n    }\n\n    /// Writes a raw JSON fragment that doesn't need any escaping to the\n    /// specified writer.\n    #[inline]\n    fn write_raw_fragment<W>(&mut self, writer: &mut W, fragment: &str) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,\n    {\n        writer.write_all(fragment.as_bytes())\n    }\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::begin_array":["/// Called before every array.  Writes a `[` to the specified\n/// writer.\n#[inline]\nfn begin_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"[\")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::begin_array_value":["/// Called before every array value.  Writes a `,` if needed to\n/// the specified writer.\n#[inline]\nfn begin_array_value<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        if first {\n            Ok(())\n        } else {\n            writer.write_all(b\",\")\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::begin_object":["/// Called before every object.  Writes a `{` to the specified\n/// writer.\n#[inline]\nfn begin_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"{\")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::begin_object_key":["/// Called before every object key.\n#[inline]\nfn begin_object_key<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        if first {\n            Ok(())\n        } else {\n            writer.write_all(b\",\")\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::begin_object_value":["/// Called before every object value.  A `:` should be written to\n/// the specified writer by either this method or\n/// `end_object_key`.\n#[inline]\nfn begin_object_value<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\":\")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::begin_string":["/// Called before each series of `write_string_fragment` and\n/// `write_char_escape`.  Writes a `\"` to the specified writer.\n#[inline]\nfn begin_string<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"\\\"\")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::end_array":["/// Called after every array.  Writes a `]` to the specified\n/// writer.\n#[inline]\nfn end_array<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"]\")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::end_array_value":["/// Called after every array value.\n#[inline]\nfn end_array_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        Ok(())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::end_object":["/// Called after every object.  Writes a `}` to the specified\n/// writer.\n#[inline]\nfn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"}\")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::end_object_key":["/// Called after every object key.  A `:` should be written to the\n/// specified writer by either this method or\n/// `begin_object_value`.\n#[inline]\nfn end_object_key<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        Ok(())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::end_object_value":["/// Called after every object value.\n#[inline]\nfn end_object_value<W>(&mut self, _writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        Ok(())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::end_string":["/// Called after each series of `write_string_fragment` and\n/// `write_char_escape`.  Writes a `\"` to the specified writer.\n#[inline]\nfn end_string<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"\\\"\")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_bool":["/// Writes a `true` or `false` value to the specified writer.\n#[inline]\nfn write_bool<W>(&mut self, writer: &mut W, value: bool) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let s = if value {\n            b\"true\" as &[u8]\n        } else {\n            b\"false\" as &[u8]\n        };\n        writer.write_all(s)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_char_escape":["/// Writes a character escape code to the specified writer.\n#[inline]\nfn write_char_escape<W>(&mut self, writer: &mut W, char_escape: CharEscape) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        use self::CharEscape::*;\n\n        let s = match char_escape {\n            Quote => b\"\\\\\\\"\",\n            ReverseSolidus => b\"\\\\\\\\\",\n            Solidus => b\"\\\\/\",\n            Backspace => b\"\\\\b\",\n            FormFeed => b\"\\\\f\",\n            LineFeed => b\"\\\\n\",\n            CarriageReturn => b\"\\\\r\",\n            Tab => b\"\\\\t\",\n            AsciiControl(byte) => {\n                static HEX_DIGITS: [u8; 16] = *b\"0123456789abcdef\";\n                let bytes = &[\n                    b'\\\\',\n                    b'u',\n                    b'0',\n                    b'0',\n                    HEX_DIGITS[(byte >> 4) as usize],\n                    HEX_DIGITS[(byte & 0xF) as usize],\n                ];\n                return writer.write_all(bytes);\n            }\n        };\n\n        writer.write_all(s)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_f32":["/// Writes a floating point value like `-31.26e+12` to the specified writer.\n#[inline]\nfn write_f32<W>(&mut self, writer: &mut W, value: f32) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = ryu::Buffer::new();\n        let s = buffer.format_finite(value);\n        writer.write_all(s.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_f64":["/// Writes a floating point value like `-31.26e+12` to the specified writer.\n#[inline]\nfn write_f64<W>(&mut self, writer: &mut W, value: f64) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = ryu::Buffer::new();\n        let s = buffer.format_finite(value);\n        writer.write_all(s.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_i128":["/// Writes an integer value like `-123` to the specified writer.\n#[inline]\nfn write_i128<W>(&mut self, writer: &mut W, value: i128) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_i16":["/// Writes an integer value like `-123` to the specified writer.\n#[inline]\nfn write_i16<W>(&mut self, writer: &mut W, value: i16) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_i32":["/// Writes an integer value like `-123` to the specified writer.\n#[inline]\nfn write_i32<W>(&mut self, writer: &mut W, value: i32) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_i64":["/// Writes an integer value like `-123` to the specified writer.\n#[inline]\nfn write_i64<W>(&mut self, writer: &mut W, value: i64) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_i8":["/// Writes an integer value like `-123` to the specified writer.\n#[inline]\nfn write_i8<W>(&mut self, writer: &mut W, value: i8) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_null":["/// Writes a `null` value to the specified writer.\n#[inline]\nfn write_null<W>(&mut self, writer: &mut W) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(b\"null\")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_number_str":["/// Writes a number that has already been rendered to a string.\n#[inline]\nfn write_number_str<W>(&mut self, writer: &mut W, value: &str) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(value.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_raw_fragment":["/// Writes a raw JSON fragment that doesn't need any escaping to the\n/// specified writer.\n#[inline]\nfn write_raw_fragment<W>(&mut self, writer: &mut W, fragment: &str) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(fragment.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_string_fragment":["/// Writes a string fragment that doesn't need any escaping to the\n/// specified writer.\n#[inline]\nfn write_string_fragment<W>(&mut self, writer: &mut W, fragment: &str) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        writer.write_all(fragment.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_u128":["/// Writes an integer value like `123` to the specified writer.\n#[inline]\nfn write_u128<W>(&mut self, writer: &mut W, value: u128) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_u16":["/// Writes an integer value like `123` to the specified writer.\n#[inline]\nfn write_u16<W>(&mut self, writer: &mut W, value: u16) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_u32":["/// Writes an integer value like `123` to the specified writer.\n#[inline]\nfn write_u32<W>(&mut self, writer: &mut W, value: u32) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_u64":["/// Writes an integer value like `123` to the specified writer.\n#[inline]\nfn write_u64<W>(&mut self, writer: &mut W, value: u64) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Formatter::write_u8":["/// Writes an integer value like `123` to the specified writer.\n#[inline]\nfn write_u8<W>(&mut self, writer: &mut W, value: u8) -> io::Result<()>\n    where\n        W: ?Sized + io::Write,{\n        let mut buffer = itoa::Buffer::new();\n        let s = buffer.format(value);\n        writer.write_all(s.as_bytes())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::MapKeySerializer":["struct MapKeySerializer<'a, W: 'a, F: 'a> {\n    ser: &'a mut Serializer<W, F>,\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::PrettyFormatter":["/// This structure pretty prints a JSON value to make it human readable.\npub struct PrettyFormatter<'a> {\n    current_indent: usize,\n    has_value: bool,\n    indent: &'a [u8],\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::PrettyFormatter::<'a>::new":["/// Construct a pretty printer formatter that defaults to using two spaces for indentation.\npub fn new() -> Self{\n        PrettyFormatter::with_indent(b\"  \")\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::PrettyFormatter::<'a>::with_indent":["/// Construct a pretty printer formatter that uses the `indent` string for indentation.\npub fn with_indent(indent: &'a [u8]) -> Self{\n        PrettyFormatter {\n            current_indent: 0,\n            has_value: false,\n            indent,\n        }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Serializer":["/// A structure for serializing Rust values into JSON.\npub struct Serializer<W, F = CompactFormatter> {\n    writer: W,\n    formatter: F,\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::Serializer::<W, F>::into_inner":["/// Unwrap the `Writer` from the `Serializer`.\n#[inline]\npub fn into_inner(self) -> W{\n        self.writer\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Serializer::<W, F>::with_formatter":["/// Creates a new JSON visitor whose output will be written to the writer\n/// specified.\n#[inline]\npub fn with_formatter(writer: W, formatter: F) -> Self{\n        Serializer { writer, formatter }\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Serializer::<W, ser::PrettyFormatter<'a>>::pretty":["/// Creates a new JSON pretty print serializer.\n#[inline]\npub fn pretty(writer: W) -> Self{\n        Serializer::with_formatter(writer, PrettyFormatter::new())\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::Serializer::<W>::new":["/// Creates a new JSON serializer.\n#[inline]\npub fn new(writer: W) -> Self{\n        Serializer::with_formatter(writer, CompactFormatter)\n    }","Real(LocalPath(\"src/ser.rs\"))"],"ser::State":["#[doc(hidden)]\npub enum State {\n    Empty,\n    First,\n    Rest,\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::format_escaped_str":["fn format_escaped_str<W, F>(writer: &mut W, formatter: &mut F, value: &str) -> io::Result<()>\nwhere\n    W: ?Sized + io::Write,\n    F: ?Sized + Formatter,{\n    tri!(formatter.begin_string(writer));\n    tri!(format_escaped_str_contents(writer, formatter, value));\n    formatter.end_string(writer)\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::format_escaped_str_contents":["fn format_escaped_str_contents<W, F>(\n    writer: &mut W,\n    formatter: &mut F,\n    value: &str,\n) -> io::Result<()>\nwhere\n    W: ?Sized + io::Write,\n    F: ?Sized + Formatter,{\n    let bytes = value.as_bytes();\n\n    let mut start = 0;\n\n    for (i, &byte) in bytes.iter().enumerate() {\n        let escape = ESCAPE[byte as usize];\n        if escape == 0 {\n            continue;\n        }\n\n        if start < i {\n            tri!(formatter.write_string_fragment(writer, &value[start..i]));\n        }\n\n        let char_escape = CharEscape::from_escape_table(escape, byte);\n        tri!(formatter.write_char_escape(writer, char_escape));\n\n        start = i + 1;\n    }\n\n    if start == bytes.len() {\n        return Ok(());\n    }\n\n    formatter.write_string_fragment(writer, &value[start..])\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::indent":["fn indent<W>(wr: &mut W, n: usize, s: &[u8]) -> io::Result<()>\nwhere\n    W: ?Sized + io::Write,{\n    for _ in 0..n {\n        tri!(wr.write_all(s));\n    }\n\n    Ok(())\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::key_must_be_a_string":["fn key_must_be_a_string() -> Error{\n    Error::syntax(ErrorCode::KeyMustBeAString, 0, 0)\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::to_string":["/// Serialize the given data structure as a String of JSON.\n///\n/// # Errors\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n#[inline]\npub fn to_string<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,{\n    let vec = tri!(to_vec(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::to_string_pretty":["/// Serialize the given data structure as a pretty-printed String of JSON.\n///\n/// # Errors\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n#[inline]\npub fn to_string_pretty<T>(value: &T) -> Result<String>\nwhere\n    T: ?Sized + Serialize,{\n    let vec = tri!(to_vec_pretty(value));\n    let string = unsafe {\n        // We do not emit invalid UTF-8.\n        String::from_utf8_unchecked(vec)\n    };\n    Ok(string)\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::to_vec":["/// Serialize the given data structure as a JSON byte vector.\n///\n/// # Errors\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n#[inline]\npub fn to_vec<T>(value: &T) -> Result<Vec<u8>>\nwhere\n    T: ?Sized + Serialize,{\n    let mut writer = Vec::with_capacity(128);\n    tri!(to_writer(&mut writer, value));\n    Ok(writer)\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::to_vec_pretty":["/// Serialize the given data structure as a pretty-printed JSON byte vector.\n///\n/// # Errors\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n#[inline]\npub fn to_vec_pretty<T>(value: &T) -> Result<Vec<u8>>\nwhere\n    T: ?Sized + Serialize,{\n    let mut writer = Vec::with_capacity(128);\n    tri!(to_writer_pretty(&mut writer, value));\n    Ok(writer)\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::to_writer":["/// Serialize the given data structure as JSON into the IO stream.\n///\n/// Serialization guarantees it only feeds valid UTF-8 sequences to the writer.\n///\n/// # Errors\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n#[inline]\npub fn to_writer<W, T>(writer: W, value: &T) -> Result<()>\nwhere\n    W: io::Write,\n    T: ?Sized + Serialize,{\n    let mut ser = Serializer::new(writer);\n    value.serialize(&mut ser)\n}","Real(LocalPath(\"src/ser.rs\"))"],"ser::to_writer_pretty":["/// Serialize the given data structure as pretty-printed JSON into the IO\n/// stream.\n///\n/// Serialization guarantees it only feeds valid UTF-8 sequences to the writer.\n///\n/// # Errors\n///\n/// Serialization can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n#[inline]\npub fn to_writer_pretty<W, T>(writer: W, value: &T) -> Result<()>\nwhere\n    W: io::Write,\n    T: ?Sized + Serialize,{\n    let mut ser = Serializer::pretty(writer);\n    value.serialize(&mut ser)\n}","Real(LocalPath(\"src/ser.rs\"))"],"value::Value":["/// Represents any valid JSON value.\n///\n/// See the [`serde_json::value` module documentation](self) for usage examples.\npub enum Value {\n    /// Represents a JSON null value.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!(null);\n    /// ```\n    Null,\n\n    /// Represents a JSON boolean.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!(true);\n    /// ```\n    Bool(bool),\n\n    /// Represents a JSON number, whether integer or floating point.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!(12.5);\n    /// ```\n    Number(Number),\n\n    /// Represents a JSON string.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!(\"a string\");\n    /// ```\n    String(String),\n\n    /// Represents a JSON array.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!([\"an\", \"array\"]);\n    /// ```\n    Array(Vec<Value>),\n\n    /// Represents a JSON object.\n    ///\n    /// By default the map is backed by a BTreeMap. Enable the `preserve_order`\n    /// feature of serde_json to use IndexMap instead, which preserves\n    /// entries in the order they are inserted into the map. In particular, this\n    /// allows JSON data to be deserialized into a Value and serialized to a\n    /// string while retaining the order of map keys in the input.\n    ///\n    /// ```\n    /// # use serde_json::json;\n    /// #\n    /// let v = json!({ \"an\": \"object\" });\n    /// ```\n    Object(Map<String, Value>),\n}","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::as_array":["/// If the `Value` is an Array, returns the associated vector. Returns None\n/// otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": [\"an\", \"array\"], \"b\": { \"an\": \"object\" } });\n///\n/// // The length of `[\"an\", \"array\"]` is 2 elements.\n/// assert_eq!(v[\"a\"].as_array().unwrap().len(), 2);\n///\n/// // The object `{\"an\": \"object\"}` is not an array.\n/// assert_eq!(v[\"b\"].as_array(), None);\n/// ```\npub fn as_array(&self) -> Option<&Vec<Value>>{\n        match self {\n            Value::Array(array) => Some(array),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::as_array_mut":["/// If the `Value` is an Array, returns the associated mutable vector.\n/// Returns None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut v = json!({ \"a\": [\"an\", \"array\"] });\n///\n/// v[\"a\"].as_array_mut().unwrap().clear();\n/// assert_eq!(v, json!({ \"a\": [] }));\n/// ```\npub fn as_array_mut(&mut self) -> Option<&mut Vec<Value>>{\n        match self {\n            Value::Array(list) => Some(list),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::as_bool":["/// If the `Value` is a Boolean, returns the associated bool. Returns None\n/// otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": false, \"b\": \"false\" });\n///\n/// assert_eq!(v[\"a\"].as_bool(), Some(false));\n///\n/// // The string `\"false\"` is a string, not a boolean.\n/// assert_eq!(v[\"b\"].as_bool(), None);\n/// ```\npub fn as_bool(&self) -> Option<bool>{\n        match *self {\n            Value::Bool(b) => Some(b),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::as_f64":["/// If the `Value` is a number, represent it as f64 if possible. Returns\n/// None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 256.0, \"b\": 64, \"c\": -64 });\n///\n/// assert_eq!(v[\"a\"].as_f64(), Some(256.0));\n/// assert_eq!(v[\"b\"].as_f64(), Some(64.0));\n/// assert_eq!(v[\"c\"].as_f64(), Some(-64.0));\n/// ```\npub fn as_f64(&self) -> Option<f64>{\n        match self {\n            Value::Number(n) => n.as_f64(),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::as_i64":["/// If the `Value` is an integer, represent it as i64 if possible. Returns\n/// None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let big = i64::max_value() as u64 + 10;\n/// let v = json!({ \"a\": 64, \"b\": big, \"c\": 256.0 });\n///\n/// assert_eq!(v[\"a\"].as_i64(), Some(64));\n/// assert_eq!(v[\"b\"].as_i64(), None);\n/// assert_eq!(v[\"c\"].as_i64(), None);\n/// ```\npub fn as_i64(&self) -> Option<i64>{\n        match self {\n            Value::Number(n) => n.as_i64(),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::as_null":["/// If the `Value` is a Null, returns (). Returns None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": null, \"b\": false });\n///\n/// assert_eq!(v[\"a\"].as_null(), Some(()));\n///\n/// // The boolean `false` is not null.\n/// assert_eq!(v[\"b\"].as_null(), None);\n/// ```\npub fn as_null(&self) -> Option<()>{\n        match *self {\n            Value::Null => Some(()),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::as_object":["/// If the `Value` is an Object, returns the associated Map. Returns None\n/// otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": { \"nested\": true }, \"b\": [\"an\", \"array\"] });\n///\n/// // The length of `{\"nested\": true}` is 1 entry.\n/// assert_eq!(v[\"a\"].as_object().unwrap().len(), 1);\n///\n/// // The array `[\"an\", \"array\"]` is not an object.\n/// assert_eq!(v[\"b\"].as_object(), None);\n/// ```\npub fn as_object(&self) -> Option<&Map<String, Value>>{\n        match self {\n            Value::Object(map) => Some(map),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::as_object_mut":["/// If the `Value` is an Object, returns the associated mutable Map.\n/// Returns None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut v = json!({ \"a\": { \"nested\": true } });\n///\n/// v[\"a\"].as_object_mut().unwrap().clear();\n/// assert_eq!(v, json!({ \"a\": {} }));\n/// ```\npub fn as_object_mut(&mut self) -> Option<&mut Map<String, Value>>{\n        match self {\n            Value::Object(map) => Some(map),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::as_str":["/// If the `Value` is a String, returns the associated str. Returns None\n/// otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": \"some string\", \"b\": false });\n///\n/// assert_eq!(v[\"a\"].as_str(), Some(\"some string\"));\n///\n/// // The boolean `false` is not a string.\n/// assert_eq!(v[\"b\"].as_str(), None);\n///\n/// // JSON values are printed in JSON representation, so strings are in quotes.\n/// //\n/// //    The value is: \"some string\"\n/// println!(\"The value is: {}\", v[\"a\"]);\n///\n/// // Rust strings are printed without quotes.\n/// //\n/// //    The value is: some string\n/// println!(\"The value is: {}\", v[\"a\"].as_str().unwrap());\n/// ```\npub fn as_str(&self) -> Option<&str>{\n        match self {\n            Value::String(s) => Some(s),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::as_u64":["/// If the `Value` is an integer, represent it as u64 if possible. Returns\n/// None otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 64, \"b\": -64, \"c\": 256.0 });\n///\n/// assert_eq!(v[\"a\"].as_u64(), Some(64));\n/// assert_eq!(v[\"b\"].as_u64(), None);\n/// assert_eq!(v[\"c\"].as_u64(), None);\n/// ```\npub fn as_u64(&self) -> Option<u64>{\n        match self {\n            Value::Number(n) => n.as_u64(),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::get":["/// Index into a JSON array or map. A string index can be used to access a\n/// value in a map, and a usize index can be used to access an element of an\n/// array.\n///\n/// Returns `None` if the type of `self` does not match the type of the\n/// index, for example if the index is a string and `self` is an array or a\n/// number. Also returns `None` if the given key does not exist in the map\n/// or the given index is not within the bounds of the array.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let object = json!({ \"A\": 65, \"B\": 66, \"C\": 67 });\n/// assert_eq!(*object.get(\"A\").unwrap(), json!(65));\n///\n/// let array = json!([ \"A\", \"B\", \"C\" ]);\n/// assert_eq!(*array.get(2).unwrap(), json!(\"C\"));\n///\n/// assert_eq!(array.get(\"A\"), None);\n/// ```\n///\n/// Square brackets can also be used to index into a value in a more concise\n/// way. This returns `Value::Null` in cases where `get` would have returned\n/// `None`.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let object = json!({\n///     \"A\": [\"a\", \"\", \"\"],\n///     \"B\": [\"b\", \"b\"],\n///     \"C\": [\"c\", \"\", \"\", \"\"],\n/// });\n/// assert_eq!(object[\"B\"][0], json!(\"b\"));\n///\n/// assert_eq!(object[\"D\"], json!(null));\n/// assert_eq!(object[0][\"x\"][\"y\"][\"z\"], json!(null));\n/// ```\npub fn get<I: Index>(&self, index: I) -> Option<&Value>{\n        index.index_into(self)\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::get_mut":["/// Mutably index into a JSON array or map. A string index can be used to\n/// access a value in a map, and a usize index can be used to access an\n/// element of an array.\n///\n/// Returns `None` if the type of `self` does not match the type of the\n/// index, for example if the index is a string and `self` is an array or a\n/// number. Also returns `None` if the given key does not exist in the map\n/// or the given index is not within the bounds of the array.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut object = json!({ \"A\": 65, \"B\": 66, \"C\": 67 });\n/// *object.get_mut(\"A\").unwrap() = json!(69);\n///\n/// let mut array = json!([ \"A\", \"B\", \"C\" ]);\n/// *array.get_mut(2).unwrap() = json!(\"D\");\n/// ```\npub fn get_mut<I: Index>(&mut self, index: I) -> Option<&mut Value>{\n        index.index_into_mut(self)\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::is_array":["/// Returns true if the `Value` is an Array. Returns false otherwise.\n///\n/// For any Value on which `is_array` returns true, `as_array` and\n/// `as_array_mut` are guaranteed to return the vector representing the\n/// array.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let obj = json!({ \"a\": [\"an\", \"array\"], \"b\": { \"an\": \"object\" } });\n///\n/// assert!(obj[\"a\"].is_array());\n///\n/// // an object, not an array\n/// assert!(!obj[\"b\"].is_array());\n/// ```\npub fn is_array(&self) -> bool{\n        self.as_array().is_some()\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::is_boolean":["/// Returns true if the `Value` is a Boolean. Returns false otherwise.\n///\n/// For any Value on which `is_boolean` returns true, `as_bool` is\n/// guaranteed to return the boolean value.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": false, \"b\": \"false\" });\n///\n/// assert!(v[\"a\"].is_boolean());\n///\n/// // The string `\"false\"` is a string, not a boolean.\n/// assert!(!v[\"b\"].is_boolean());\n/// ```\npub fn is_boolean(&self) -> bool{\n        self.as_bool().is_some()\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::is_f64":["/// Returns true if the `Value` is a number that can be represented by f64.\n///\n/// For any Value on which `is_f64` returns true, `as_f64` is guaranteed to\n/// return the floating point value.\n///\n/// Currently this function returns true if and only if both `is_i64` and\n/// `is_u64` return false but this is not a guarantee in the future.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 256.0, \"b\": 64, \"c\": -64 });\n///\n/// assert!(v[\"a\"].is_f64());\n///\n/// // Integers.\n/// assert!(!v[\"b\"].is_f64());\n/// assert!(!v[\"c\"].is_f64());\n/// ```\npub fn is_f64(&self) -> bool{\n        match self {\n            Value::Number(n) => n.is_f64(),\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::is_i64":["/// Returns true if the `Value` is an integer between `i64::MIN` and\n/// `i64::MAX`.\n///\n/// For any Value on which `is_i64` returns true, `as_i64` is guaranteed to\n/// return the integer value.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let big = i64::max_value() as u64 + 10;\n/// let v = json!({ \"a\": 64, \"b\": big, \"c\": 256.0 });\n///\n/// assert!(v[\"a\"].is_i64());\n///\n/// // Greater than i64::MAX.\n/// assert!(!v[\"b\"].is_i64());\n///\n/// // Numbers with a decimal point are not considered integers.\n/// assert!(!v[\"c\"].is_i64());\n/// ```\npub fn is_i64(&self) -> bool{\n        match self {\n            Value::Number(n) => n.is_i64(),\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::is_null":["/// Returns true if the `Value` is a Null. Returns false otherwise.\n///\n/// For any Value on which `is_null` returns true, `as_null` is guaranteed\n/// to return `Some(())`.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": null, \"b\": false });\n///\n/// assert!(v[\"a\"].is_null());\n///\n/// // The boolean `false` is not null.\n/// assert!(!v[\"b\"].is_null());\n/// ```\npub fn is_null(&self) -> bool{\n        self.as_null().is_some()\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::is_number":["/// Returns true if the `Value` is a Number. Returns false otherwise.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 1, \"b\": \"2\" });\n///\n/// assert!(v[\"a\"].is_number());\n///\n/// // The string `\"2\"` is a string, not a number.\n/// assert!(!v[\"b\"].is_number());\n/// ```\npub fn is_number(&self) -> bool{\n        match *self {\n            Value::Number(_) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::is_object":["/// Returns true if the `Value` is an Object. Returns false otherwise.\n///\n/// For any Value on which `is_object` returns true, `as_object` and\n/// `as_object_mut` are guaranteed to return the map representation of the\n/// object.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let obj = json!({ \"a\": { \"nested\": true }, \"b\": [\"an\", \"array\"] });\n///\n/// assert!(obj.is_object());\n/// assert!(obj[\"a\"].is_object());\n///\n/// // array, not an object\n/// assert!(!obj[\"b\"].is_object());\n/// ```\npub fn is_object(&self) -> bool{\n        self.as_object().is_some()\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::is_string":["/// Returns true if the `Value` is a String. Returns false otherwise.\n///\n/// For any Value on which `is_string` returns true, `as_str` is guaranteed\n/// to return the string slice.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": \"some string\", \"b\": false });\n///\n/// assert!(v[\"a\"].is_string());\n///\n/// // The boolean `false` is not a string.\n/// assert!(!v[\"b\"].is_string());\n/// ```\npub fn is_string(&self) -> bool{\n        self.as_str().is_some()\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::is_u64":["/// Returns true if the `Value` is an integer between zero and `u64::MAX`.\n///\n/// For any Value on which `is_u64` returns true, `as_u64` is guaranteed to\n/// return the integer value.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let v = json!({ \"a\": 64, \"b\": -64, \"c\": 256.0 });\n///\n/// assert!(v[\"a\"].is_u64());\n///\n/// // Negative integer.\n/// assert!(!v[\"b\"].is_u64());\n///\n/// // Numbers with a decimal point are not considered integers.\n/// assert!(!v[\"c\"].is_u64());\n/// ```\npub fn is_u64(&self) -> bool{\n        match self {\n            Value::Number(n) => n.is_u64(),\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::pointer":["/// Looks up a value by a JSON Pointer.\n///\n/// JSON Pointer defines a string syntax for identifying a specific value\n/// within a JavaScript Object Notation (JSON) document.\n///\n/// A Pointer is a Unicode string with the reference tokens separated by `/`.\n/// Inside tokens `/` is replaced by `~1` and `~` is replaced by `~0`. The\n/// addressed value is returned and if there is no such value `None` is\n/// returned.\n///\n/// For more information read [RFC6901](https://tools.ietf.org/html/rfc6901).\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let data = json!({\n///     \"x\": {\n///         \"y\": [\"z\", \"zz\"]\n///     }\n/// });\n///\n/// assert_eq!(data.pointer(\"/x/y/1\").unwrap(), &json!(\"zz\"));\n/// assert_eq!(data.pointer(\"/a/b/c\"), None);\n/// ```\npub fn pointer(&self, pointer: &str) -> Option<&Value>{\n        if pointer.is_empty() {\n            return Some(self);\n        }\n        if !pointer.starts_with('/') {\n            return None;\n        }\n        pointer\n            .split('/')\n            .skip(1)\n            .map(|x| x.replace(\"~1\", \"/\").replace(\"~0\", \"~\"))\n            .try_fold(self, |target, token| match target {\n                Value::Object(map) => map.get(&token),\n                Value::Array(list) => parse_index(&token).and_then(|x| list.get(x)),\n                _ => None,\n            })\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::pointer_mut":["/// Looks up a value by a JSON Pointer and returns a mutable reference to\n/// that value.\n///\n/// JSON Pointer defines a string syntax for identifying a specific value\n/// within a JavaScript Object Notation (JSON) document.\n///\n/// A Pointer is a Unicode string with the reference tokens separated by `/`.\n/// Inside tokens `/` is replaced by `~1` and `~` is replaced by `~0`. The\n/// addressed value is returned and if there is no such value `None` is\n/// returned.\n///\n/// For more information read [RFC6901](https://tools.ietf.org/html/rfc6901).\n///\n/// # Example of Use\n///\n/// ```\n/// use serde_json::Value;\n///\n/// fn main() {\n///     let s = r#\"{\"x\": 1.0, \"y\": 2.0}\"#;\n///     let mut value: Value = serde_json::from_str(s).unwrap();\n///\n///     // Check value using read-only pointer\n///     assert_eq!(value.pointer(\"/x\"), Some(&1.0.into()));\n///     // Change value with direct assignment\n///     *value.pointer_mut(\"/x\").unwrap() = 1.5.into();\n///     // Check that new value was written\n///     assert_eq!(value.pointer(\"/x\"), Some(&1.5.into()));\n///     // Or change the value only if it exists\n///     value.pointer_mut(\"/x\").map(|v| *v = 1.5.into());\n///\n///     // \"Steal\" ownership of a value. Can replace with any valid Value.\n///     let old_x = value.pointer_mut(\"/x\").map(Value::take).unwrap();\n///     assert_eq!(old_x, 1.5);\n///     assert_eq!(value.pointer(\"/x\").unwrap(), &Value::Null);\n/// }\n/// ```\npub fn pointer_mut(&mut self, pointer: &str) -> Option<&mut Value>{\n        if pointer.is_empty() {\n            return Some(self);\n        }\n        if !pointer.starts_with('/') {\n            return None;\n        }\n        pointer\n            .split('/')\n            .skip(1)\n            .map(|x| x.replace(\"~1\", \"/\").replace(\"~0\", \"~\"))\n            .try_fold(self, |target, token| match target {\n                Value::Object(map) => map.get_mut(&token),\n                Value::Array(list) => parse_index(&token).and_then(move |x| list.get_mut(x)),\n                _ => None,\n            })\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::Value::take":["/// Takes the value out of the `Value`, leaving a `Null` in its place.\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut v = json!({ \"x\": \"y\" });\n/// assert_eq!(v[\"x\"].take(), json!(\"y\"));\n/// assert_eq!(v, json!({ \"x\": null }));\n/// ```\npub fn take(&mut self) -> Value{\n        mem::replace(self, Value::Null)\n    }","Real(LocalPath(\"src/value/mod.rs\"))"],"value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize":["#[inline]\nfn deserialize<D>(deserializer: D) -> Result<Value, D::Error>\n    where\n        D: serde::Deserializer<'de>,{\n        struct ValueVisitor;\n\n        impl<'de> Visitor<'de> for ValueVisitor {\n            type Value = Value;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"any valid JSON value\")\n            }\n\n            #[inline]\n            fn visit_bool<E>(self, value: bool) -> Result<Value, E> {\n                Ok(Value::Bool(value))\n            }\n\n            #[inline]\n            fn visit_i64<E>(self, value: i64) -> Result<Value, E> {\n                Ok(Value::Number(value.into()))\n            }\n\n            #[inline]\n            fn visit_u64<E>(self, value: u64) -> Result<Value, E> {\n                Ok(Value::Number(value.into()))\n            }\n\n            #[inline]\n            fn visit_f64<E>(self, value: f64) -> Result<Value, E> {\n                Ok(Number::from_f64(value).map_or(Value::Null, Value::Number))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_str<E>(self, value: &str) -> Result<Value, E>\n            where\n                E: serde::de::Error,\n            {\n                self.visit_string(String::from(value))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            #[inline]\n            fn visit_string<E>(self, value: String) -> Result<Value, E> {\n                Ok(Value::String(value))\n            }\n\n            #[inline]\n            fn visit_none<E>(self) -> Result<Value, E> {\n                Ok(Value::Null)\n            }\n\n            #[inline]\n            fn visit_some<D>(self, deserializer: D) -> Result<Value, D::Error>\n            where\n                D: serde::Deserializer<'de>,\n            {\n                Deserialize::deserialize(deserializer)\n            }\n\n            #[inline]\n            fn visit_unit<E>(self) -> Result<Value, E> {\n                Ok(Value::Null)\n            }\n\n            #[inline]\n            fn visit_seq<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: SeqAccess<'de>,\n            {\n                let mut vec = Vec::new();\n\n                while let Some(elem) = tri!(visitor.next_element()) {\n                    vec.push(elem);\n                }\n\n                Ok(Value::Array(vec))\n            }\n\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            fn visit_map<V>(self, mut visitor: V) -> Result<Value, V::Error>\n            where\n                V: MapAccess<'de>,\n            {\n                match visitor.next_key_seed(KeyClassifier)? {\n                    #[cfg(feature = \"arbitrary_precision\")]\n                    Some(KeyClass::Number) => {\n                        let number: NumberFromString = visitor.next_value()?;\n                        Ok(Value::Number(number.value))\n                    }\n                    #[cfg(feature = \"raw_value\")]\n                    Some(KeyClass::RawValue) => {\n                        let value = visitor.next_value_seed(crate::raw::BoxedFromString)?;\n                        crate::from_str(value.get()).map_err(de::Error::custom)\n                    }\n                    Some(KeyClass::Map(first_key)) => {\n                        let mut values = Map::new();\n\n                        values.insert(first_key, tri!(visitor.next_value()));\n                        while let Some((key, value)) = tri!(visitor.next_entry()) {\n                            values.insert(key, value);\n                        }\n\n                        Ok(Value::Object(values))\n                    }\n                    None => Ok(Value::Object(Map::new())),\n                }\n            }\n        }\n\n        deserializer.deserialize_any(ValueVisitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor":["struct ValueVisitor;","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_any":["fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Null => visitor.visit_unit(),\n            Value::Bool(v) => visitor.visit_bool(*v),\n            Value::Number(n) => n.deserialize_any(visitor),\n            Value::String(v) => visitor.visit_borrowed_str(v),\n            Value::Array(v) => visit_array_ref(v, visitor),\n            Value::Object(v) => visit_object_ref(v, visitor),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bool":["fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match *self {\n            Value::Bool(v) => visitor.visit_bool(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_byte_buf":["fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_bytes(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bytes":["fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::String(v) => visitor.visit_borrowed_str(v),\n            Value::Array(v) => visit_array_ref(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_char":["fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_str(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_enum":["fn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        let (variant, value) = match self {\n            Value::Object(value) => {\n                let mut iter = value.into_iter();\n                let (variant, value) = match iter.next() {\n                    Some(v) => v,\n                    None => {\n                        return Err(serde::de::Error::invalid_value(\n                            Unexpected::Map,\n                            &\"map with a single key\",\n                        ));\n                    }\n                };\n                // enums are encoded in json as maps with a single key:value pair\n                if iter.next().is_some() {\n                    return Err(serde::de::Error::invalid_value(\n                        Unexpected::Map,\n                        &\"map with a single key\",\n                    ));\n                }\n                (variant, Some(value))\n            }\n            Value::String(variant) => (variant, None),\n            other => {\n                return Err(serde::de::Error::invalid_type(\n                    other.unexpected(),\n                    &\"string or map\",\n                ));\n            }\n        };\n\n        visitor.visit_enum(EnumRefDeserializer { variant, value })\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f32":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f64":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i128":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i16":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i32":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i64":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i8":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_identifier":["fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_str(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_ignored_any":["fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        visitor.visit_unit()\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_map":["fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Object(v) => visit_object_ref(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_newtype_struct":["#[inline]\nfn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        #[cfg(feature = \"raw_value\")]\n        {\n            if name == crate::raw::TOKEN {\n                return visitor.visit_map(crate::raw::OwnedRawDeserializer {\n                    raw_value: Some(self.to_string()),\n                });\n            }\n        }\n\n        let _ = name;\n        visitor.visit_newtype_struct(self)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_option":["fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match *self {\n            Value::Null => visitor.visit_none(),\n            _ => visitor.visit_some(self),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_seq":["fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Array(v) => visit_array_ref(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_str":["fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::String(v) => visitor.visit_borrowed_str(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_string":["fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_str(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_struct":["fn deserialize_struct<V>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Array(v) => visit_array_ref(v, visitor),\n            Value::Object(v) => visit_object_ref(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple":["fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_seq(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple_struct":["fn deserialize_tuple_struct<V>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_seq(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u128":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u16":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u32":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u64":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u8":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit":["fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match *self {\n            Value::Null => visitor.visit_unit(),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit_struct":["fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_unit(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_any":["#[inline]\nfn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Null => visitor.visit_unit(),\n            Value::Bool(v) => visitor.visit_bool(v),\n            Value::Number(n) => n.deserialize_any(visitor),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::String(v) => visitor.visit_string(v),\n            Value::Array(v) => visit_array(v, visitor),\n            Value::Object(v) => visit_object(v, visitor),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bool":["fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Bool(v) => visitor.visit_bool(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_byte_buf":["fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::String(v) => visitor.visit_string(v),\n            Value::Array(v) => visit_array(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bytes":["fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_byte_buf(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_char":["fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_string(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_enum":["#[inline]\nfn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        let (variant, value) = match self {\n            Value::Object(value) => {\n                let mut iter = value.into_iter();\n                let (variant, value) = match iter.next() {\n                    Some(v) => v,\n                    None => {\n                        return Err(serde::de::Error::invalid_value(\n                            Unexpected::Map,\n                            &\"map with a single key\",\n                        ));\n                    }\n                };\n                // enums are encoded in json as maps with a single key:value pair\n                if iter.next().is_some() {\n                    return Err(serde::de::Error::invalid_value(\n                        Unexpected::Map,\n                        &\"map with a single key\",\n                    ));\n                }\n                (variant, Some(value))\n            }\n            Value::String(variant) => (variant, None),\n            other => {\n                return Err(serde::de::Error::invalid_type(\n                    other.unexpected(),\n                    &\"string or map\",\n                ));\n            }\n        };\n\n        visitor.visit_enum(EnumDeserializer { variant, value })\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f32":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f64":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i128":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i16":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i32":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i64":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i8":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_identifier":["fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_string(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_ignored_any":["fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        drop(self);\n        visitor.visit_unit()\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_map":["fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Object(v) => visit_object(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_newtype_struct":["#[inline]\nfn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        #[cfg(feature = \"raw_value\")]\n        {\n            if name == crate::raw::TOKEN {\n                return visitor.visit_map(crate::raw::OwnedRawDeserializer {\n                    raw_value: Some(self.to_string()),\n                });\n            }\n        }\n\n        let _ = name;\n        visitor.visit_newtype_struct(self)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_option":["#[inline]\nfn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Null => visitor.visit_none(),\n            _ => visitor.visit_some(self),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_seq":["fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Array(v) => visit_array(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_str":["fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_string(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_string":["fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::String(v) => visitor.visit_string(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_struct":["fn deserialize_struct<V>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Array(v) => visit_array(v, visitor),\n            Value::Object(v) => visit_object(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple":["fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_seq(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple_struct":["fn deserialize_tuple_struct<V>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_seq(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u128":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u16":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u32":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u64":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u8":["#[cfg(not(feature = \"arbitrary_precision\"))]\nfn $method<V>(self, visitor: V) -> Result<V::Value, Error>\n        where\n            V: Visitor<'de>,{\n            match self {\n                Value::Number(n) => n.deserialize_any(visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit":["fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        match self {\n            Value::Null => visitor.visit_unit(),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit_struct":["fn deserialize_unit_struct<V>(self, _name: &'static str, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,{\n        self.deserialize_unit(visitor)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl serde::de::IntoDeserializer<'de, error::Error> for value::Value>::into_deserializer":["fn into_deserializer(self) -> Self::Deserializer{\n        self\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl std::str::FromStr for value::Value>::from_str":["fn from_str(s: &str) -> Result<Value, Error>{\n        super::super::de::from_str(s)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl value::Value>::invalid_type":["#[cold]\nfn invalid_type<E>(&self, exp: &dyn Expected) -> E\n    where\n        E: serde::de::Error,{\n        serde::de::Error::invalid_type(self.unexpected(), exp)\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::<impl value::Value>::unexpected":["#[cold]\nfn unexpected(&self) -> Unexpected{\n        match self {\n            Value::Null => Unexpected::Unit,\n            Value::Bool(b) => Unexpected::Bool(*b),\n            Value::Number(n) => n.unexpected(),\n            Value::String(s) => Unexpected::Str(s),\n            Value::Array(_) => Unexpected::Seq,\n            Value::Object(_) => Unexpected::Map,\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::BorrowedCowStrDeserializer":["struct BorrowedCowStrDeserializer<'de> {\n    value: Cow<'de, str>,\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::BorrowedCowStrDeserializer::<'de>::new":["fn new(value: Cow<'de, str>) -> Self{\n        BorrowedCowStrDeserializer { value }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::EnumDeserializer":["struct EnumDeserializer {\n    variant: String,\n    value: Option<Value>,\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::EnumRefDeserializer":["struct EnumRefDeserializer<'de> {\n    variant: &'de str,\n    value: Option<&'de Value>,\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::KeyClass":["enum KeyClass {\n    Map(String),\n    #[cfg(feature = \"arbitrary_precision\")]\n    Number,\n    #[cfg(feature = \"raw_value\")]\n    RawValue,\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::KeyClassifier":["struct KeyClassifier;","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::MapDeserializer":["struct MapDeserializer {\n    iter: <Map<String, Value> as IntoIterator>::IntoIter,\n    value: Option<Value>,\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::MapDeserializer::new":["fn new(map: Map<String, Value>) -> Self{\n        MapDeserializer {\n            iter: map.into_iter(),\n            value: None,\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::MapKeyDeserializer":["struct MapKeyDeserializer<'de> {\n    key: Cow<'de, str>,\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::MapRefDeserializer":["struct MapRefDeserializer<'de> {\n    iter: <&'de Map<String, Value> as IntoIterator>::IntoIter,\n    value: Option<&'de Value>,\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::MapRefDeserializer::<'de>::new":["fn new(map: &'de Map<String, Value>) -> Self{\n        MapRefDeserializer {\n            iter: map.into_iter(),\n            value: None,\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::SeqDeserializer":["struct SeqDeserializer {\n    iter: vec::IntoIter<Value>,\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::SeqDeserializer::new":["fn new(vec: Vec<Value>) -> Self{\n        SeqDeserializer {\n            iter: vec.into_iter(),\n        }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::SeqRefDeserializer":["struct SeqRefDeserializer<'de> {\n    iter: slice::Iter<'de, Value>,\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::SeqRefDeserializer::<'de>::new":["fn new(slice: &'de [Value]) -> Self{\n        SeqRefDeserializer { iter: slice.iter() }\n    }","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::UnitOnly":["struct UnitOnly;","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::VariantDeserializer":["struct VariantDeserializer {\n    value: Option<Value>,\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::VariantRefDeserializer":["struct VariantRefDeserializer<'de> {\n    value: Option<&'de Value>,\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::visit_array":["fn visit_array<'de, V>(array: Vec<Value>, visitor: V) -> Result<V::Value, Error>\nwhere\n    V: Visitor<'de>,{\n    let len = array.len();\n    let mut deserializer = SeqDeserializer::new(array);\n    let seq = tri!(visitor.visit_seq(&mut deserializer));\n    let remaining = deserializer.iter.len();\n    if remaining == 0 {\n        Ok(seq)\n    } else {\n        Err(serde::de::Error::invalid_length(\n            len,\n            &\"fewer elements in array\",\n        ))\n    }\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::visit_array_ref":["fn visit_array_ref<'de, V>(array: &'de [Value], visitor: V) -> Result<V::Value, Error>\nwhere\n    V: Visitor<'de>,{\n    let len = array.len();\n    let mut deserializer = SeqRefDeserializer::new(array);\n    let seq = tri!(visitor.visit_seq(&mut deserializer));\n    let remaining = deserializer.iter.len();\n    if remaining == 0 {\n        Ok(seq)\n    } else {\n        Err(serde::de::Error::invalid_length(\n            len,\n            &\"fewer elements in array\",\n        ))\n    }\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::visit_object":["fn visit_object<'de, V>(object: Map<String, Value>, visitor: V) -> Result<V::Value, Error>\nwhere\n    V: Visitor<'de>,{\n    let len = object.len();\n    let mut deserializer = MapDeserializer::new(object);\n    let map = tri!(visitor.visit_map(&mut deserializer));\n    let remaining = deserializer.iter.len();\n    if remaining == 0 {\n        Ok(map)\n    } else {\n        Err(serde::de::Error::invalid_length(\n            len,\n            &\"fewer elements in map\",\n        ))\n    }\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::de::visit_object_ref":["fn visit_object_ref<'de, V>(object: &'de Map<String, Value>, visitor: V) -> Result<V::Value, Error>\nwhere\n    V: Visitor<'de>,{\n    let len = object.len();\n    let mut deserializer = MapRefDeserializer::new(object);\n    let map = tri!(visitor.visit_map(&mut deserializer));\n    let remaining = deserializer.iter.len();\n    if remaining == 0 {\n        Ok(map)\n    } else {\n        Err(serde::de::Error::invalid_length(\n            len,\n            &\"fewer elements in map\",\n        ))\n    }\n}","Real(LocalPath(\"src/value/de.rs\"))"],"value::from::<impl std::convert::From<&'a [T]> for value::Value>::from":["/// Convert a slice to `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let v: &[&str] = &[\"lorem\", \"ipsum\", \"dolor\"];\n/// let x: Value = v.into();\n/// ```\nfn from(f: &'a [T]) -> Self{\n        Value::Array(f.iter().cloned().map(Into::into).collect())\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<&'a str> for value::Value>::from":["/// Convert string slice to `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let s: &str = \"lorem\";\n/// let x: Value = s.into();\n/// ```\nfn from(f: &str) -> Self{\n        Value::String(f.to_string())\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<()> for value::Value>::from":["/// Convert `()` to `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let u = ();\n/// let x: Value = u.into();\n/// ```\nfn from((): ()) -> Self{\n        Value::Null\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<bool> for value::Value>::from":["/// Convert boolean to `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let b = false;\n/// let x: Value = b.into();\n/// ```\nfn from(f: bool) -> Self{\n        Value::Bool(f)\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<f32> for value::Value>::from":["/// Convert 32-bit floating point number to `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let f: f32 = 13.37;\n/// let x: Value = f.into();\n/// ```\nfn from(f: f32) -> Self{\n        Number::from_f32(f).map_or(Value::Null, Value::Number)\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<f64> for value::Value>::from":["/// Convert 64-bit floating point number to `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let f: f64 = 13.37;\n/// let x: Value = f.into();\n/// ```\nfn from(f: f64) -> Self{\n        Number::from_f64(f).map_or(Value::Null, Value::Number)\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<i16> for value::Value>::from":["fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<i32> for value::Value>::from":["fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<i64> for value::Value>::from":["fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<i8> for value::Value>::from":["fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<isize> for value::Value>::from":["fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<map::Map<std::string::String, value::Value>> for value::Value>::from":["/// Convert map (with string keys) to `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::{Map, Value};\n///\n/// let mut m = Map::new();\n/// m.insert(\"Lorem\".to_string(), \"ipsum\".into());\n/// let x: Value = m.into();\n/// ```\nfn from(f: Map<String, Value>) -> Self{\n        Value::Object(f)\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<number::Number> for value::Value>::from":["/// Convert `Number` to `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::{Number, Value};\n///\n/// let n = Number::from(7);\n/// let x: Value = n.into();\n/// ```\nfn from(f: Number) -> Self{\n        Value::Number(f)\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<std::borrow::Cow<'a, str>> for value::Value>::from":["/// Convert copy-on-write string to `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n/// use std::borrow::Cow;\n///\n/// let s: Cow<str> = Cow::Borrowed(\"lorem\");\n/// let x: Value = s.into();\n/// ```\n///\n/// ```\n/// use serde_json::Value;\n/// use std::borrow::Cow;\n///\n/// let s: Cow<str> = Cow::Owned(\"lorem\".to_string());\n/// let x: Value = s.into();\n/// ```\nfn from(f: Cow<'a, str>) -> Self{\n        Value::String(f.into_owned())\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<std::option::Option<T>> for value::Value>::from":["fn from(opt: Option<T>) -> Self{\n        match opt {\n            None => Value::Null,\n            Some(value) => Into::into(value),\n        }\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<std::string::String> for value::Value>::from":["/// Convert `String` to `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let s: String = \"lorem\".to_string();\n/// let x: Value = s.into();\n/// ```\nfn from(f: String) -> Self{\n        Value::String(f)\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<std::vec::Vec<T>> for value::Value>::from":["/// Convert a `Vec` to `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let v = vec![\"lorem\", \"ipsum\", \"dolor\"];\n/// let x: Value = v.into();\n/// ```\nfn from(f: Vec<T>) -> Self{\n        Value::Array(f.into_iter().map(Into::into).collect())\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<u16> for value::Value>::from":["fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<u32> for value::Value>::from":["fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<u64> for value::Value>::from":["fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<u8> for value::Value>::from":["fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::convert::From<usize> for value::Value>::from":["fn from(n: $ty) -> Self{\n                    Value::Number(n.into())\n                }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::iter::FromIterator<(K, V)> for value::Value>::from_iter":["/// Convert an iteratable type to a `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let v: Vec<_> = vec![(\"lorem\", 40), (\"ipsum\", 2)];\n/// let x: Value = v.into_iter().collect();\n/// ```\nfn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self{\n        Value::Object(\n            iter.into_iter()\n                .map(|(k, v)| (k.into(), v.into()))\n                .collect(),\n        )\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from::<impl std::iter::FromIterator<T> for value::Value>::from_iter":["/// Convert an iteratable type to a `Value`\n///\n/// # Examples\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let v = std::iter::repeat(42).take(5);\n/// let x: Value = v.collect();\n/// ```\n///\n/// ```\n/// use serde_json::Value;\n///\n/// let v: Vec<_> = vec![\"lorem\", \"ipsum\", \"dolor\"];\n/// let x: Value = v.into_iter().collect();\n/// ```\n///\n/// ```\n/// use std::iter::FromIterator;\n/// use serde_json::Value;\n///\n/// let x: Value = Value::from_iter(vec![\"lorem\", \"ipsum\", \"dolor\"]);\n/// ```\nfn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self{\n        Value::Array(iter.into_iter().map(Into::into).collect())\n    }","Real(LocalPath(\"src/value/from.rs\"))"],"value::from_value":["/// Interpret a `serde_json::Value` as an instance of type `T`.\n///\n/// # Example\n///\n/// ```\n/// use serde::Deserialize;\n/// use serde_json::json;\n///\n/// #[derive(Deserialize, Debug)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn main() {\n///     // The type of `j` is `serde_json::Value`\n///     let j = json!({\n///         \"fingerprint\": \"0xF9BA143B95FF6D82\",\n///         \"location\": \"Menlo Park, CA\"\n///     });\n///\n///     let u: User = serde_json::from_value(j).unwrap();\n///     println!(\"{:#?}\", u);\n/// }\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if the structure of the Value does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the Value\n/// contains something other than a JSON map. It can also fail if the structure\n/// is correct but `T`'s implementation of `Deserialize` decides that something\n/// is wrong with the data, for example required struct fields are missing from\n/// the JSON map or some number is too big to fit in the expected primitive\n/// type.\npub fn from_value<T>(value: Value) -> Result<T, Error>\nwhere\n    T: DeserializeOwned,{\n    T::deserialize(value)\n}","Real(LocalPath(\"src/value/mod.rs\"))"],"value::index::<impl std::ops::Index<I> for value::Value>::index":["/// Index into a `serde_json::Value` using the syntax `value[0]` or\n/// `value[\"k\"]`.\n///\n/// Returns `Value::Null` if the type of `self` does not match the type of\n/// the index, for example if the index is a string and `self` is an array\n/// or a number. Also returns `Value::Null` if the given key does not exist\n/// in the map or the given index is not within the bounds of the array.\n///\n/// For retrieving deeply nested values, you should have a look at the\n/// `Value::pointer` method.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let data = json!({\n///     \"x\": {\n///         \"y\": [\"z\", \"zz\"]\n///     }\n/// });\n///\n/// assert_eq!(data[\"x\"][\"y\"], json!([\"z\", \"zz\"]));\n/// assert_eq!(data[\"x\"][\"y\"][0], json!(\"z\"));\n///\n/// assert_eq!(data[\"a\"], json!(null)); // returns null for undefined values\n/// assert_eq!(data[\"a\"][\"b\"], json!(null)); // does not panic\n/// ```\nfn index(&self, index: I) -> &Value{\n        static NULL: Value = Value::Null;\n        index.index_into(self).unwrap_or(&NULL)\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"value::index::<impl std::ops::IndexMut<I> for value::Value>::index_mut":["/// Write into a `serde_json::Value` using the syntax `value[0] = ...` or\n/// `value[\"k\"] = ...`.\n///\n/// If the index is a number, the value must be an array of length bigger\n/// than the index. Indexing into a value that is not an array or an array\n/// that is too small will panic.\n///\n/// If the index is a string, the value must be an object or null which is\n/// treated like an empty object. If the key is not already present in the\n/// object, it will be inserted with a value of null. Indexing into a value\n/// that is neither an object nor null will panic.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let mut data = json!({ \"x\": 0 });\n///\n/// // replace an existing key\n/// data[\"x\"] = json!(1);\n///\n/// // insert a new key\n/// data[\"y\"] = json!([false, false, false]);\n///\n/// // replace an array value\n/// data[\"y\"][0] = json!(true);\n///\n/// // inserted a deeply nested key\n/// data[\"a\"][\"b\"][\"c\"][\"d\"] = json!(true);\n///\n/// println!(\"{}\", data);\n/// ```\nfn index_mut(&mut self, index: I) -> &mut Value{\n        index.index_or_insert(self)\n    }","Real(LocalPath(\"src/value/index.rs\"))"],"value::index::Index":["/// A type that can be used to index into a `serde_json::Value`.\n///\n/// The [`get`] and [`get_mut`] methods of `Value` accept any type that\n/// implements `Index`, as does the [square-bracket indexing operator]. This\n/// trait is implemented for strings which are used as the index into a JSON\n/// map, and for `usize` which is used as the index into a JSON array.\n///\n/// [`get`]: ../enum.Value.html#method.get\n/// [`get_mut`]: ../enum.Value.html#method.get_mut\n/// [square-bracket indexing operator]: ../enum.Value.html#impl-Index%3CI%3E\n///\n/// This trait is sealed and cannot be implemented for types outside of\n/// `serde_json`.\n///\n/// # Examples\n///\n/// ```\n/// # use serde_json::json;\n/// #\n/// let data = json!({ \"inner\": [1, 2, 3] });\n///\n/// // Data is a JSON map so it can be indexed with a string.\n/// let inner = &data[\"inner\"];\n///\n/// // Inner is a JSON array so it can be indexed with an integer.\n/// let first = &inner[0];\n///\n/// assert_eq!(first, 1);\n/// ```\npub trait Index: private::Sealed {\n    /// Return None if the key is not already in the array or object.\n    #[doc(hidden)]\n    fn index_into<'v>(&self, v: &'v Value) -> Option<&'v Value>;\n\n    /// Return None if the key is not already in the array or object.\n    #[doc(hidden)]\n    fn index_into_mut<'v>(&self, v: &'v mut Value) -> Option<&'v mut Value>;\n\n    /// Panic if array index out of bounds. If key is not already in the object,\n    /// insert it with a value of null. Panic if Value is a type that cannot be\n    /// indexed into, except if Value is null then it can be treated as an empty\n    /// object.\n    #[doc(hidden)]\n    fn index_or_insert<'v>(&self, v: &'v mut Value) -> &'v mut Value;\n}","Real(LocalPath(\"src/value/index.rs\"))"],"value::index::Type":["/// Used in panic messages.\nstruct Type<'a>(&'a Value);","Real(LocalPath(\"src/value/index.rs\"))"],"value::index::private::Sealed":["pub trait Sealed {}","Real(LocalPath(\"src/value/index.rs\"))"],"value::parse_index":["fn parse_index(s: &str) -> Option<usize>{\n    if s.starts_with('+') || (s.starts_with('0') && s.len() != 1) {\n        return None;\n    }\n    s.parse().ok()\n}","Real(LocalPath(\"src/value/mod.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<&'a str> for value::Value>::eq":["fn eq(&self, other: &&str) -> bool{\n        eq_str(self, *other)\n    }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<bool> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<bool> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<bool> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<f32> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<f32> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<f32> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<f64> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<f64> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<f64> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<i16> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<i16> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<i16> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<i32> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<i32> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<i32> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<i64> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<i64> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<i64> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<i8> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<i8> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<i8> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<isize> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<isize> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<isize> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<std::string::String> for value::Value>::eq":["fn eq(&self, other: &String) -> bool{\n        eq_str(self, other.as_str())\n    }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<str> for value::Value>::eq":["fn eq(&self, other: &str) -> bool{\n        eq_str(self, other)\n    }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<u16> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<u16> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<u16> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<u32> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<u32> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<u32> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<u64> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<u64> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<u64> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<u8> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<u8> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<u8> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<usize> for &'a mut value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<usize> for &'a value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(*self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<usize> for value::Value>::eq":["fn eq(&self, other: &$ty) -> bool{\n                    $eq(self, *other as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for &'a str>::eq":["fn eq(&self, other: &Value) -> bool{\n        eq_str(other, *self)\n    }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for bool>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for f32>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for f64>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i16>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i32>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i64>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i8>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for isize>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for std::string::String>::eq":["fn eq(&self, other: &Value) -> bool{\n        eq_str(other, self.as_str())\n    }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for str>::eq":["fn eq(&self, other: &Value) -> bool{\n        eq_str(other, self)\n    }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u16>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u32>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u64>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u8>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for usize>::eq":["fn eq(&self, other: &Value) -> bool{\n                    $eq(other, *self as _)\n                }","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::eq_bool":["fn eq_bool(value: &Value, other: bool) -> bool{\n    value.as_bool().map_or(false, |i| i == other)\n}","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::eq_f32":["fn eq_f32(value: &Value, other: f32) -> bool{\n    match value {\n        Value::Number(n) => n.as_f32().map_or(false, |i| i == other),\n        _ => false,\n    }\n}","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::eq_f64":["fn eq_f64(value: &Value, other: f64) -> bool{\n    value.as_f64().map_or(false, |i| i == other)\n}","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::eq_i64":["fn eq_i64(value: &Value, other: i64) -> bool{\n    value.as_i64().map_or(false, |i| i == other)\n}","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::eq_str":["fn eq_str(value: &Value, other: &str) -> bool{\n    value.as_str().map_or(false, |i| i == other)\n}","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::partial_eq::eq_u64":["fn eq_u64(value: &Value, other: u64) -> bool{\n    value.as_u64().map_or(false, |i| i == other)\n}","Real(LocalPath(\"src/value/partial_eq.rs\"))"],"value::ser::<impl serde::Serialize for value::Value>::serialize":["#[inline]\nfn serialize<S>(&self, serializer: S) -> result::Result<S::Ok, S::Error>\n    where\n        S: ::serde::Serializer,{\n        match self {\n            Value::Null => serializer.serialize_unit(),\n            Value::Bool(b) => serializer.serialize_bool(*b),\n            Value::Number(n) => n.serialize(serializer),\n            Value::String(s) => serializer.serialize_str(s),\n            Value::Array(v) => v.serialize(serializer),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Value::Object(m) => {\n                use serde::ser::SerializeMap;\n                let mut map = tri!(serializer.serialize_map(Some(m.len())));\n                for (k, v) in m {\n                    tri!(map.serialize_entry(k, v));\n                }\n                map.end()\n            }\n        }\n    }","Real(LocalPath(\"src/value/ser.rs\"))"],"value::ser::MapKeySerializer":["struct MapKeySerializer;","Real(LocalPath(\"src/value/ser.rs\"))"],"value::ser::SerializeMap":["pub enum SerializeMap {\n    Map {\n        map: Map<String, Value>,\n        next_key: Option<String>,\n    },\n    #[cfg(feature = \"arbitrary_precision\")]\n    Number { out_value: Option<Value> },\n    #[cfg(feature = \"raw_value\")]\n    RawValue { out_value: Option<Value> },\n}","Real(LocalPath(\"src/value/ser.rs\"))"],"value::ser::SerializeStructVariant":["pub struct SerializeStructVariant {\n    name: String,\n    map: Map<String, Value>,\n}","Real(LocalPath(\"src/value/ser.rs\"))"],"value::ser::SerializeTupleVariant":["pub struct SerializeTupleVariant {\n    name: String,\n    vec: Vec<Value>,\n}","Real(LocalPath(\"src/value/ser.rs\"))"],"value::ser::SerializeVec":["pub struct SerializeVec {\n    vec: Vec<Value>,\n}","Real(LocalPath(\"src/value/ser.rs\"))"],"value::ser::Serializer":["/// Serializer whose output is a `Value`.\n///\n/// This is the serializer that backs [`serde_json::to_value`][crate::to_value].\n/// Unlike the main serde_json serializer which goes from some serializable\n/// value of type `T` to JSON text, this one goes from `T` to\n/// `serde_json::Value`.\n///\n/// The `to_value` function is implementable as:\n///\n/// ```\n/// use serde::Serialize;\n/// use serde_json::{Error, Value};\n///\n/// pub fn to_value<T>(input: T) -> Result<Value, Error>\n/// where\n///     T: Serialize,\n/// {\n///     input.serialize(serde_json::value::Serializer)\n/// }\n/// ```\npub struct Serializer;","Real(LocalPath(\"src/value/ser.rs\"))"],"value::ser::key_must_be_a_string":["fn key_must_be_a_string() -> Error{\n    Error::syntax(ErrorCode::KeyMustBeAString, 0, 0)\n}","Real(LocalPath(\"src/value/ser.rs\"))"],"value::to_value":["/// Convert a `T` into `serde_json::Value` which is an enum that can represent\n/// any valid JSON data.\n///\n/// # Example\n///\n/// ```\n/// use serde::Serialize;\n/// use serde_json::json;\n///\n/// use std::error::Error;\n///\n/// #[derive(Serialize)]\n/// struct User {\n///     fingerprint: String,\n///     location: String,\n/// }\n///\n/// fn compare_json_values() -> Result<(), Box<Error>> {\n///     let u = User {\n///         fingerprint: \"0xF9BA143B95FF6D82\".to_owned(),\n///         location: \"Menlo Park, CA\".to_owned(),\n///     };\n///\n///     // The type of `expected` is `serde_json::Value`\n///     let expected = json!({\n///         \"fingerprint\": \"0xF9BA143B95FF6D82\",\n///         \"location\": \"Menlo Park, CA\",\n///     });\n///\n///     let v = serde_json::to_value(u).unwrap();\n///     assert_eq!(v, expected);\n///\n///     Ok(())\n/// }\n/// #\n/// # compare_json_values().unwrap();\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if `T`'s implementation of `Serialize` decides to\n/// fail, or if `T` contains a map with non-string keys.\n///\n/// ```\n/// use std::collections::BTreeMap;\n///\n/// fn main() {\n///     // The keys in this map are vectors, not strings.\n///     let mut map = BTreeMap::new();\n///     map.insert(vec![32, 64], \"x86\");\n///\n///     println!(\"{}\", serde_json::to_value(map).unwrap_err());\n/// }\n/// ```\npub fn to_value<T>(value: T) -> Result<Value, Error>\nwhere\n    T: Serialize,{\n    value.serialize(Serializer)\n}","Real(LocalPath(\"src/value/mod.rs\"))"]},"struct_constructor":{"&'a mut value::Value":["insert","into_mut","or_insert","or_insert_with"],"&'s str":["as_str"],"&(dyn std::error::Error + 'static)":["source"],"&<read::Reference<'b, 'c, T> as std::ops::Deref>::Target":["deref"],"&mut value::Value":["get_mut","index_mut"],"&std::string::String":["key"],"&str":["as_str"],"&value::Value":["get","index"],"(&std::string::String, &value::Value)":["get_key_value"],"(<T as serde::de::DeserializeSeed<'de>>::Value, <value::de::BorrowedCowStrDeserializer<'de> as serde::de::EnumAccess<'de>>::Variant)":["variant_seed"],"(<V as serde::de::DeserializeSeed<'de>>::Value, <value::de::EnumRefDeserializer<'de> as serde::de::EnumAccess<'de>>::Variant)":["variant_seed"],"(<V as serde::de::DeserializeSeed<'de>>::Value, de::UnitVariantAccess<'a, R>)":["variant_seed"],"(<V as serde::de::DeserializeSeed<'de>>::Value, de::VariantAccess<'a, R>)":["variant_seed"],"(<V as serde::de::DeserializeSeed<'de>>::Value, value::de::VariantDeserializer)":["variant_seed"],"(std::string::String, value::Value)":["remove_entry"],"(usize, std::option::Option<usize>)":["size_hint"],"(usize, usize)":["parse_line_col"],"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::SerializeMap":["serialize_map"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::SerializeSeq":["serialize_seq"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::SerializeStruct":["serialize_struct"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::SerializeStructVariant":["serialize_struct_variant"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::SerializeTuple":["serialize_tuple"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::SerializeTupleStruct":["serialize_tuple_struct"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::SerializeTupleVariant":["serialize_tuple_variant"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::Value":["visit_map","visit_unit"],"<K as serde::de::DeserializeSeed<'de>>::Value":["next_key_seed"],"<S as serde::Serializer>::Ok":["serialize"],"<T as serde::de::DeserializeSeed<'de>>::Value":["newtype_variant_seed","next_element_seed","next_key_seed","next_value_seed"],"<V as serde::de::DeserializeSeed<'de>>::Value":["next_value_seed"],"<V as serde::de::Visitor<'de>>::Value":["deserialize_any","deserialize_bool","deserialize_byte_buf","deserialize_bytes","deserialize_char","deserialize_enum","deserialize_f32","deserialize_f64","deserialize_i128","deserialize_i16","deserialize_i32","deserialize_i64","deserialize_i8","deserialize_identifier","deserialize_ignored_any","deserialize_map","deserialize_newtype_struct","deserialize_number","deserialize_option","deserialize_seq","deserialize_str","deserialize_string","deserialize_struct","deserialize_tuple","deserialize_tuple_struct","deserialize_u128","deserialize_u16","deserialize_u32","deserialize_u64","deserialize_u8","deserialize_unit","deserialize_unit_struct","struct_variant","tuple_variant","visit","visit_array","visit_array_ref","visit_object","visit_object_ref"],"<map::IntoIter as std::iter::Iterator>::Item":["next","next_back"],"<map::Iter<'a> as std::iter::Iterator>::Item":["next","next_back"],"<map::IterMut<'a> as std::iter::Iterator>::Item":["next","next_back"],"<map::Keys<'a> as std::iter::Iterator>::Item":["next","next_back"],"<map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::IntoIter":["into_iter"],"<map::Values<'a> as std::iter::Iterator>::Item":["next","next_back"],"<map::ValuesMut<'a> as std::iter::Iterator>::Item":["next","next_back"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::SerializeMap":["serialize_map"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::SerializeSeq":["serialize_seq"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::SerializeStruct":["serialize_struct"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::SerializeStructVariant":["serialize_struct_variant"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::SerializeTuple":["serialize_tuple"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::SerializeTupleStruct":["serialize_tuple_struct"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::SerializeTupleVariant":["serialize_tuple_variant"],"<value::Value as serde::de::IntoDeserializer<'de, error::Error>>::Deserializer":["into_deserializer"],"<value::de::KeyClassifier as serde::de::DeserializeSeed<'de>>::Value":["deserialize"],"<value::de::KeyClassifier as serde::de::Visitor<'de>>::Value":["visit_str","visit_string"],"<value::ser::MapKeySerializer as serde::Serializer>::SerializeMap":["serialize_map"],"<value::ser::MapKeySerializer as serde::Serializer>::SerializeSeq":["serialize_seq"],"<value::ser::MapKeySerializer as serde::Serializer>::SerializeStruct":["serialize_struct"],"<value::ser::MapKeySerializer as serde::Serializer>::SerializeStructVariant":["serialize_struct_variant"],"<value::ser::MapKeySerializer as serde::Serializer>::SerializeTuple":["serialize_tuple"],"<value::ser::MapKeySerializer as serde::Serializer>::SerializeTupleStruct":["serialize_tuple_struct"],"<value::ser::MapKeySerializer as serde::Serializer>::SerializeTupleVariant":["serialize_tuple_variant"],"<value::ser::Serializer as serde::Serializer>::SerializeMap":["serialize_map"],"<value::ser::Serializer as serde::Serializer>::SerializeSeq":["serialize_seq"],"<value::ser::Serializer as serde::Serializer>::SerializeStruct":["serialize_struct"],"<value::ser::Serializer as serde::Serializer>::SerializeStructVariant":["serialize_struct_variant"],"<value::ser::Serializer as serde::Serializer>::SerializeTuple":["serialize_tuple"],"<value::ser::Serializer as serde::Serializer>::SerializeTupleStruct":["serialize_tuple_struct"],"<value::ser::Serializer as serde::Serializer>::SerializeTupleVariant":["serialize_tuple_variant"],"bool":["as_bool","contains_key","eq","eq_f32","eq_f64","eq_i64","eq_str","eq_u64","is_array","is_boolean","is_data","is_empty","is_eof","is_f64","is_i64","is_io","is_null","is_number","is_object","is_string","is_syntax","is_u64","starts_with_digit"],"de::Deserializer":["from_reader","from_slice","from_str","new"],"de::MapAccess":["new"],"de::ParserNumber":["parse_any_number","parse_any_signed_number","parse_integer","parse_number"],"de::SeqAccess":["new"],"de::StreamDeserializer":["into_iter","new"],"de::UnitVariantAccess":["new"],"de::VariantAccess":["new"],"error::Category":["classify","clone"],"error::Error":["custom","error","invalid_type","io","key_must_be_a_string","make_error","peek_error","peek_invalid_type","syntax"],"f32":["as_f32"],"f64":["as_f64","f64_from_parts","parse_decimal","parse_decimal_overflow","parse_exponent","parse_exponent_overflow","parse_long_integer"],"i64":["as_i64"],"iter::LineColIterator":["new"],"map::Entry":["entry"],"map::Iter":["iter"],"map::IterMut":["iter_mut"],"map::Keys":["keys"],"map::Map":["clone","default","deserialize","from_iter","new","with_capacity"],"map::Values":["values"],"map::ValuesMut":["values_mut"],"number::N":["clone"],"number::Number":["clone","deserialize","from","from_f32","from_f64","from_str","visit_f64","visit_i64","visit_u64"],"read::IoRead":["new"],"read::Position":["peek_position","position","position_of_index"],"read::Reference":["parse_str","parse_str_bytes","parse_str_raw"],"read::SliceRead":["new"],"read::StrRead":["new"],"ser::CharEscape":["from_escape_table"],"ser::CompactFormatter":["clone"],"ser::PrettyFormatter":["clone","default","new","with_indent"],"ser::Serializer":["new","pretty","with_formatter"],"serde::de::Unexpected":["unexpected"],"std::io::Error":["from","io_error"],"std::string::String":["collect_str","serialize_bool","serialize_bytes","serialize_char","serialize_f32","serialize_f64","serialize_i16","serialize_i32","serialize_i64","serialize_i8","serialize_newtype_struct","serialize_newtype_variant","serialize_none","serialize_some","serialize_str","serialize_u16","serialize_u32","serialize_u64","serialize_u8","serialize_unit","serialize_unit_struct","serialize_unit_variant","to_string","to_string_pretty"],"std::vec::Vec":["to_vec","to_vec_pretty"],"u16":["decode_hex_escape","decode_hex_val"],"u64":["as_u64"],"u8":["next","next_char","next_char_or_null","next_or_eof","parse_whitespace","peek","peek_or_eof","peek_or_null"],"usize":["byte_offset","col","column","len","line","parse_index","size_hint","write"],"value::Value":["clone","collect_str","default","deserialize","end","from","from_iter","from_str","remove","serialize_bool","serialize_bytes","serialize_char","serialize_f32","serialize_f64","serialize_i128","serialize_i16","serialize_i32","serialize_i64","serialize_i8","serialize_newtype_struct","serialize_newtype_variant","serialize_none","serialize_some","serialize_str","serialize_u128","serialize_u16","serialize_u32","serialize_u64","serialize_u8","serialize_unit","serialize_unit_struct","serialize_unit_variant","take","to_value","visit_bool","visit_f64","visit_i64","visit_map","visit_none","visit_seq","visit_some","visit_str","visit_string","visit_u64","visit_unit"],"value::de::BorrowedCowStrDeserializer":["new"],"value::de::MapDeserializer":["new"],"value::de::MapRefDeserializer":["new"],"value::de::SeqDeserializer":["new"],"value::de::SeqRefDeserializer":["new"]},"struct_to_trait":{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter":["std::fmt::Write"],"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor":["serde::de::Visitor"],"<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor":["serde::de::Visitor"],"<value::Value as std::fmt::Display>::fmt::WriterFormatter":["std::io::Write"],"de::MapAccess":["serde::de::MapAccess"],"de::MapKey":["serde::Deserializer"],"de::SeqAccess":["serde::de::SeqAccess"],"de::StreamDeserializer":["std::iter::FusedIterator","std::iter::Iterator"],"de::UnitVariantAccess":["serde::de::EnumAccess","serde::de::VariantAccess"],"de::VariantAccess":["serde::de::EnumAccess","serde::de::VariantAccess"],"error::Category":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::Error":["serde::de::Error","serde::ser::Error","std::error::Error","std::fmt::Debug","std::fmt::Display"],"error::ErrorCode":["std::fmt::Display"],"error::ErrorImpl":["std::fmt::Display"],"iter::LineColIterator":["std::iter::Iterator"],"map::IntoIter":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"map::Iter":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"map::IterMut":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"map::Keys":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"map::Map":["serde::Deserialize","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::iter::Extend","std::iter::FromIterator","std::iter::IntoIterator","std::ops::Index","std::ops::IndexMut"],"map::Values":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"map::ValuesMut":["std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"number::N":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","std::marker::Copy"],"number::Number":["serde::Deserialize","serde::Deserializer","serde::Serialize","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"],"read::IoRead":["read::Read","read::private::Sealed"],"read::Reference":["std::ops::Deref"],"read::SliceRead":["read::Fused","read::Read","read::private::Sealed"],"read::StrRead":["read::Fused","read::Read","read::private::Sealed"],"ser::CompactFormatter":["ser::Formatter","std::clone::Clone","std::fmt::Debug"],"ser::Compound":["serde::ser::SerializeMap","serde::ser::SerializeSeq","serde::ser::SerializeStruct","serde::ser::SerializeStructVariant","serde::ser::SerializeTuple","serde::ser::SerializeTupleStruct","serde::ser::SerializeTupleVariant"],"ser::MapKeySerializer":["serde::Serializer"],"ser::PrettyFormatter":["ser::Formatter","std::clone::Clone","std::default::Default","std::fmt::Debug"],"ser::State":["std::cmp::Eq","std::cmp::PartialEq","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"std::io::Error":["std::convert::From"],"std::string::String":["std::cmp::PartialEq","value::index::Index","value::index::private::Sealed"],"value::Value":["serde::Deserialize","serde::Deserializer","serde::Serialize","serde::de::IntoDeserializer","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::iter::FromIterator","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Index","std::ops::IndexMut","std::str::FromStr"],"value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor":["serde::de::Visitor"],"value::de::BorrowedCowStrDeserializer":["serde::Deserializer","serde::de::EnumAccess"],"value::de::EnumDeserializer":["serde::de::EnumAccess"],"value::de::EnumRefDeserializer":["serde::de::EnumAccess"],"value::de::KeyClassifier":["serde::de::DeserializeSeed","serde::de::Visitor"],"value::de::MapDeserializer":["serde::de::MapAccess"],"value::de::MapKeyDeserializer":["serde::Deserializer"],"value::de::MapRefDeserializer":["serde::de::MapAccess"],"value::de::SeqDeserializer":["serde::de::SeqAccess"],"value::de::SeqRefDeserializer":["serde::de::SeqAccess"],"value::de::UnitOnly":["serde::de::VariantAccess"],"value::de::VariantDeserializer":["serde::de::VariantAccess"],"value::de::VariantRefDeserializer":["serde::de::VariantAccess"],"value::index::Type":["std::fmt::Display"],"value::ser::MapKeySerializer":["serde::Serializer"],"value::ser::SerializeMap":["serde::ser::SerializeMap","serde::ser::SerializeStruct"],"value::ser::SerializeStructVariant":["serde::ser::SerializeStructVariant"],"value::ser::SerializeTupleVariant":["serde::ser::SerializeTupleVariant"],"value::ser::SerializeVec":["serde::ser::SerializeSeq","serde::ser::SerializeTuple","serde::ser::SerializeTupleStruct"],"value::ser::Serializer":["serde::Serializer"]},"targets":{"<&'a T as value::index::Index>::index_into":["index_into","Real(LocalPath(\"src/value/index.rs\"))","value::index::Index"],"<&'a T as value::index::Index>::index_into_mut":["index_into_mut","Real(LocalPath(\"src/value/index.rs\"))","value::index::Index"],"<&'a T as value::index::Index>::index_or_insert":["index_or_insert","Real(LocalPath(\"src/value/index.rs\"))","value::index::Index"],"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/map.rs\"))","std::iter::IntoIterator"],"<&'a mut R as read::Read<'de>>::byte_offset":["byte_offset","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<&'a mut R as read::Read<'de>>::decode_hex_escape":["decode_hex_escape","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<&'a mut R as read::Read<'de>>::discard":["discard","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<&'a mut R as read::Read<'de>>::ignore_str":["ignore_str","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<&'a mut R as read::Read<'de>>::next":["next","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<&'a mut R as read::Read<'de>>::parse_str":["parse_str","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<&'a mut R as read::Read<'de>>::parse_str_raw":["parse_str_raw","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<&'a mut R as read::Read<'de>>::peek":["peek","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<&'a mut R as read::Read<'de>>::peek_position":["peek_position","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<&'a mut R as read::Read<'de>>::position":["position","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<&'a mut R as read::Read<'de>>::set_failed":["set_failed","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_any":["deserialize_any","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_char":["deserialize_char","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i128":["deserialize_i128","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_map":["deserialize_map","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_option":["deserialize_option","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_str":["deserialize_str","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_string":["deserialize_string","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u128":["deserialize_u128","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/map.rs\"))","std::iter::IntoIterator"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str":["collect_str","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bool":["serialize_bool","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bytes":["serialize_bytes","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_char":["serialize_char","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f32":["serialize_f32","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f64":["serialize_f64","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i128":["serialize_i128","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i16":["serialize_i16","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i32":["serialize_i32","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i64":["serialize_i64","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i8":["serialize_i8","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_map":["serialize_map","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_struct":["serialize_newtype_struct","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_variant":["serialize_newtype_variant","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_none":["serialize_none","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_seq":["serialize_seq","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_some":["serialize_some","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_str":["serialize_str","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct":["serialize_struct","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct_variant":["serialize_struct_variant","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple":["serialize_tuple","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_struct":["serialize_tuple_struct","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_variant":["serialize_tuple_variant","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u128":["serialize_u128","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u16":["serialize_u16","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u32":["serialize_u32","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u64":["serialize_u64","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u8":["serialize_u8","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit":["serialize_unit","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_struct":["serialize_unit_struct","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_variant":["serialize_unit_variant","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_any":["deserialize_any","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_char":["deserialize_char","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i128":["deserialize_i128","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_map":["deserialize_map","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_option":["deserialize_option","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_str":["deserialize_str","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_string":["deserialize_string","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u128":["deserialize_u128","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F> as std::fmt::Write>::write_str":["write_str","Real(LocalPath(\"src/ser.rs\"))","std::fmt::Write"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting":["expecting","Real(LocalPath(\"src/map.rs\"))","serde::de::Visitor"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map":["visit_map","Real(LocalPath(\"src/map.rs\"))","serde::de::Visitor"],"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit":["visit_unit","Real(LocalPath(\"src/map.rs\"))","serde::de::Visitor"],"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::expecting":["expecting","Real(LocalPath(\"src/number.rs\"))","serde::de::Visitor"],"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_f64":["visit_f64","Real(LocalPath(\"src/number.rs\"))","serde::de::Visitor"],"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i64":["visit_i64","Real(LocalPath(\"src/number.rs\"))","serde::de::Visitor"],"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u64":["visit_u64","Real(LocalPath(\"src/number.rs\"))","serde::de::Visitor"],"<<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::flush":["flush","Real(LocalPath(\"src/value/mod.rs\"))","std::io::Write"],"<<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::write":["write","Real(LocalPath(\"src/value/mod.rs\"))","std::io::Write"],"<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed":["next_key_seed","Real(LocalPath(\"src/de.rs\"))","serde::de::MapAccess"],"<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_value_seed":["next_value_seed","Real(LocalPath(\"src/de.rs\"))","serde::de::MapAccess"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_any":["deserialize_any","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_char":["deserialize_char","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i128":["deserialize_i128","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_map":["deserialize_map","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_option":["deserialize_option","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_str":["deserialize_str","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_string":["deserialize_string","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u128":["deserialize_u128","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"src/de.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed":["next_element_seed","Real(LocalPath(\"src/de.rs\"))","serde::de::SeqAccess"],"<de::StreamDeserializer<'de, R, T> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/de.rs\"))","std::iter::Iterator"],"<de::UnitVariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed":["variant_seed","Real(LocalPath(\"src/de.rs\"))","serde::de::EnumAccess"],"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed":["newtype_variant_seed","Real(LocalPath(\"src/de.rs\"))","serde::de::VariantAccess"],"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant":["struct_variant","Real(LocalPath(\"src/de.rs\"))","serde::de::VariantAccess"],"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant":["tuple_variant","Real(LocalPath(\"src/de.rs\"))","serde::de::VariantAccess"],"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant":["unit_variant","Real(LocalPath(\"src/de.rs\"))","serde::de::VariantAccess"],"<de::VariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed":["variant_seed","Real(LocalPath(\"src/de.rs\"))","serde::de::EnumAccess"],"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed":["newtype_variant_seed","Real(LocalPath(\"src/de.rs\"))","serde::de::VariantAccess"],"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant":["struct_variant","Real(LocalPath(\"src/de.rs\"))","serde::de::VariantAccess"],"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant":["tuple_variant","Real(LocalPath(\"src/de.rs\"))","serde::de::VariantAccess"],"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant":["unit_variant","Real(LocalPath(\"src/de.rs\"))","serde::de::VariantAccess"],"<error::Error as serde::de::Error>::custom":["custom","Real(LocalPath(\"src/error.rs\"))","serde::de::Error"],"<error::Error as serde::de::Error>::invalid_type":["invalid_type","Real(LocalPath(\"src/error.rs\"))","serde::de::Error"],"<error::Error as serde::ser::Error>::custom":["custom","Real(LocalPath(\"src/error.rs\"))","serde::ser::Error"],"<error::Error as std::error::Error>::source":["source","Real(LocalPath(\"src/error.rs\"))","std::error::Error"],"<error::Error as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Debug"],"<error::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::ErrorCode as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<error::ErrorImpl as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<iter::LineColIterator<I> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/iter.rs\"))","std::iter::Iterator"],"<map::IntoIter as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::IntoIter as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/map.rs\"))","std::iter::ExactSizeIterator"],"<map::IntoIter as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/map.rs\"))","std::iter::Iterator"],"<map::IntoIter as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/map.rs\"))","std::iter::Iterator"],"<map::Iter<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::Iter<'a> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/map.rs\"))","std::iter::ExactSizeIterator"],"<map::Iter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/map.rs\"))","std::iter::Iterator"],"<map::Iter<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/map.rs\"))","std::iter::Iterator"],"<map::IterMut<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::IterMut<'a> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/map.rs\"))","std::iter::ExactSizeIterator"],"<map::IterMut<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/map.rs\"))","std::iter::Iterator"],"<map::IterMut<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/map.rs\"))","std::iter::Iterator"],"<map::Keys<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::Keys<'a> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/map.rs\"))","std::iter::ExactSizeIterator"],"<map::Keys<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/map.rs\"))","std::iter::Iterator"],"<map::Keys<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/map.rs\"))","std::iter::Iterator"],"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize":["deserialize","Real(LocalPath(\"src/map.rs\"))","serde::Deserialize"],"<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize":["serialize","Real(LocalPath(\"src/map.rs\"))","serde::Serialize"],"<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/map.rs\"))","std::clone::Clone"],"<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone_from":["clone_from","Real(LocalPath(\"src/map.rs\"))","std::clone::Clone"],"<map::Map<std::string::String, value::Value> as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/map.rs\"))","std::cmp::PartialEq"],"<map::Map<std::string::String, value::Value> as std::default::Default>::default":["default","Real(LocalPath(\"src/map.rs\"))","std::default::Default"],"<map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/map.rs\"))","std::fmt::Debug"],"<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend":["extend","Real(LocalPath(\"src/map.rs\"))","std::iter::Extend"],"<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter":["from_iter","Real(LocalPath(\"src/map.rs\"))","std::iter::FromIterator"],"<map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/map.rs\"))","std::iter::IntoIterator"],"<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index":["index","Real(LocalPath(\"src/map.rs\"))","std::ops::Index"],"<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut":["index_mut","Real(LocalPath(\"src/map.rs\"))","std::ops::IndexMut"],"<map::Values<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::Values<'a> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/map.rs\"))","std::iter::ExactSizeIterator"],"<map::Values<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/map.rs\"))","std::iter::Iterator"],"<map::Values<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/map.rs\"))","std::iter::Iterator"],"<map::ValuesMut<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/map.rs\"))","std::iter::DoubleEndedIterator"],"<map::ValuesMut<'a> as std::iter::ExactSizeIterator>::len":["len","Real(LocalPath(\"src/map.rs\"))","std::iter::ExactSizeIterator"],"<map::ValuesMut<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/map.rs\"))","std::iter::Iterator"],"<map::ValuesMut<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/map.rs\"))","std::iter::Iterator"],"<number::N as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/number.rs\"))","std::cmp::PartialEq"],"<number::N as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/number.rs\"))","std::hash::Hash"],"<number::Number as serde::Deserialize<'de>>::deserialize":["deserialize","Real(LocalPath(\"src/number.rs\"))","serde::Deserialize"],"<number::Number as serde::Deserializer<'de>>::deserialize_any":["deserialize_any","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_char":["deserialize_char","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_i128":["deserialize_i128","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_map":["deserialize_map","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_option":["deserialize_option","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_str":["deserialize_str","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_string":["deserialize_string","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_u128":["deserialize_u128","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"src/number.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Deserializer<'de>>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<number::Number as serde::Serialize>::serialize":["serialize","Real(LocalPath(\"src/number.rs\"))","serde::Serialize"],"<number::Number as std::convert::From<de::ParserNumber>>::from":["from","Real(LocalPath(\"src/number.rs\"))","std::convert::From"],"<number::Number as std::convert::From<i16>>::from":["from","Real(LocalPath(\"src/number.rs\"))","std::convert::From"],"<number::Number as std::convert::From<i32>>::from":["from","Real(LocalPath(\"src/number.rs\"))","std::convert::From"],"<number::Number as std::convert::From<i64>>::from":["from","Real(LocalPath(\"src/number.rs\"))","std::convert::From"],"<number::Number as std::convert::From<i8>>::from":["from","Real(LocalPath(\"src/number.rs\"))","std::convert::From"],"<number::Number as std::convert::From<isize>>::from":["from","Real(LocalPath(\"src/number.rs\"))","std::convert::From"],"<number::Number as std::convert::From<u16>>::from":["from","Real(LocalPath(\"src/number.rs\"))","std::convert::From"],"<number::Number as std::convert::From<u32>>::from":["from","Real(LocalPath(\"src/number.rs\"))","std::convert::From"],"<number::Number as std::convert::From<u64>>::from":["from","Real(LocalPath(\"src/number.rs\"))","std::convert::From"],"<number::Number as std::convert::From<u8>>::from":["from","Real(LocalPath(\"src/number.rs\"))","std::convert::From"],"<number::Number as std::convert::From<usize>>::from":["from","Real(LocalPath(\"src/number.rs\"))","std::convert::From"],"<number::Number as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/number.rs\"))","std::fmt::Debug"],"<number::Number as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/number.rs\"))","std::fmt::Display"],"<read::IoRead<R> as read::Read<'de>>::byte_offset":["byte_offset","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::IoRead<R> as read::Read<'de>>::decode_hex_escape":["decode_hex_escape","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::IoRead<R> as read::Read<'de>>::discard":["discard","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::IoRead<R> as read::Read<'de>>::ignore_str":["ignore_str","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::IoRead<R> as read::Read<'de>>::next":["next","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::IoRead<R> as read::Read<'de>>::parse_str":["parse_str","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::IoRead<R> as read::Read<'de>>::parse_str_raw":["parse_str_raw","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::IoRead<R> as read::Read<'de>>::peek":["peek","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::IoRead<R> as read::Read<'de>>::peek_position":["peek_position","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::IoRead<R> as read::Read<'de>>::position":["position","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::IoRead<R> as read::Read<'de>>::set_failed":["set_failed","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::Reference<'b, 'c, T> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/read.rs\"))","std::ops::Deref"],"<read::SliceRead<'a> as read::Read<'a>>::byte_offset":["byte_offset","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::SliceRead<'a> as read::Read<'a>>::decode_hex_escape":["decode_hex_escape","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::SliceRead<'a> as read::Read<'a>>::discard":["discard","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::SliceRead<'a> as read::Read<'a>>::ignore_str":["ignore_str","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::SliceRead<'a> as read::Read<'a>>::next":["next","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::SliceRead<'a> as read::Read<'a>>::parse_str":["parse_str","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::SliceRead<'a> as read::Read<'a>>::parse_str_raw":["parse_str_raw","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::SliceRead<'a> as read::Read<'a>>::peek":["peek","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::SliceRead<'a> as read::Read<'a>>::peek_position":["peek_position","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::SliceRead<'a> as read::Read<'a>>::position":["position","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::SliceRead<'a> as read::Read<'a>>::set_failed":["set_failed","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::StrRead<'a> as read::Read<'a>>::byte_offset":["byte_offset","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::StrRead<'a> as read::Read<'a>>::decode_hex_escape":["decode_hex_escape","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::StrRead<'a> as read::Read<'a>>::discard":["discard","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::StrRead<'a> as read::Read<'a>>::ignore_str":["ignore_str","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::StrRead<'a> as read::Read<'a>>::next":["next","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::StrRead<'a> as read::Read<'a>>::parse_str":["parse_str","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::StrRead<'a> as read::Read<'a>>::parse_str_raw":["parse_str_raw","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::StrRead<'a> as read::Read<'a>>::peek":["peek","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::StrRead<'a> as read::Read<'a>>::peek_position":["peek_position","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::StrRead<'a> as read::Read<'a>>::position":["position","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<read::StrRead<'a> as read::Read<'a>>::set_failed":["set_failed","Real(LocalPath(\"src/read.rs\"))","read::Read"],"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::end":["end","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeMap"],"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_key":["serialize_key","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeMap"],"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_value":["serialize_value","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeMap"],"<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::end":["end","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeSeq"],"<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::serialize_element":["serialize_element","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeSeq"],"<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::end":["end","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeStruct"],"<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::serialize_field":["serialize_field","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeStruct"],"<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::end":["end","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeStructVariant"],"<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::serialize_field":["serialize_field","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeStructVariant"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::end":["end","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeTuple"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::serialize_element":["serialize_element","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeTuple"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::end":["end","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeTupleStruct"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::serialize_field":["serialize_field","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeTupleStruct"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::end":["end","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeTupleVariant"],"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::serialize_field":["serialize_field","Real(LocalPath(\"src/ser.rs\"))","serde::ser::SerializeTupleVariant"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::collect_str":["collect_str","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bool":["serialize_bool","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bytes":["serialize_bytes","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_char":["serialize_char","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f32":["serialize_f32","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f64":["serialize_f64","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i128":["serialize_i128","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i16":["serialize_i16","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i32":["serialize_i32","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i64":["serialize_i64","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i8":["serialize_i8","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_map":["serialize_map","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_struct":["serialize_newtype_struct","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_variant":["serialize_newtype_variant","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_none":["serialize_none","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_seq":["serialize_seq","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_some":["serialize_some","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_str":["serialize_str","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct":["serialize_struct","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct_variant":["serialize_struct_variant","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple":["serialize_tuple","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_struct":["serialize_tuple_struct","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_variant":["serialize_tuple_variant","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u128":["serialize_u128","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u16":["serialize_u16","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u32":["serialize_u32","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u64":["serialize_u64","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u8":["serialize_u8","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit":["serialize_unit","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_struct":["serialize_unit_struct","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_variant":["serialize_unit_variant","Real(LocalPath(\"src/ser.rs\"))","serde::Serializer"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array":["begin_array","Real(LocalPath(\"src/ser.rs\"))","ser::Formatter"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array_value":["begin_array_value","Real(LocalPath(\"src/ser.rs\"))","ser::Formatter"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object":["begin_object","Real(LocalPath(\"src/ser.rs\"))","ser::Formatter"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_key":["begin_object_key","Real(LocalPath(\"src/ser.rs\"))","ser::Formatter"],"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_value":["begin_object_value","Real(LocalPath(\"src/ser.rs\"))","ser::Formatter"],"<ser::PrettyFormatter<'a> as ser::Formatter>::end_array":["end_array","Real(LocalPath(\"src/ser.rs\"))","ser::Formatter"],"<ser::PrettyFormatter<'a> as ser::Formatter>::end_array_value":["end_array_value","Real(LocalPath(\"src/ser.rs\"))","ser::Formatter"],"<ser::PrettyFormatter<'a> as ser::Formatter>::end_object":["end_object","Real(LocalPath(\"src/ser.rs\"))","ser::Formatter"],"<ser::PrettyFormatter<'a> as ser::Formatter>::end_object_value":["end_object_value","Real(LocalPath(\"src/ser.rs\"))","ser::Formatter"],"<ser::PrettyFormatter<'a> as std::default::Default>::default":["default","Real(LocalPath(\"src/ser.rs\"))","std::default::Default"],"<std::string::String as value::index::Index>::index_into":["index_into","Real(LocalPath(\"src/value/index.rs\"))","value::index::Index"],"<std::string::String as value::index::Index>::index_into_mut":["index_into_mut","Real(LocalPath(\"src/value/index.rs\"))","value::index::Index"],"<std::string::String as value::index::Index>::index_or_insert":["index_or_insert","Real(LocalPath(\"src/value/index.rs\"))","value::index::Index"],"<str as value::index::Index>::index_into":["index_into","Real(LocalPath(\"src/value/index.rs\"))","value::index::Index"],"<str as value::index::Index>::index_into_mut":["index_into_mut","Real(LocalPath(\"src/value/index.rs\"))","value::index::Index"],"<str as value::index::Index>::index_or_insert":["index_or_insert","Real(LocalPath(\"src/value/index.rs\"))","value::index::Index"],"<usize as value::index::Index>::index_into":["index_into","Real(LocalPath(\"src/value/index.rs\"))","value::index::Index"],"<usize as value::index::Index>::index_into_mut":["index_into_mut","Real(LocalPath(\"src/value/index.rs\"))","value::index::Index"],"<usize as value::index::Index>::index_or_insert":["index_or_insert","Real(LocalPath(\"src/value/index.rs\"))","value::index::Index"],"<value::Value as std::default::Default>::default":["default","Real(LocalPath(\"src/value/mod.rs\"))","std::default::Default"],"<value::Value as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/value/mod.rs\"))","std::fmt::Debug"],"<value::Value as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/value/mod.rs\"))","std::fmt::Display"],"<value::Value as std::fmt::Display>::fmt::io_error":["io_error","Real(LocalPath(\"src/value/mod.rs\"))",""],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting":["expecting","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool":["visit_bool","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64":["visit_f64","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64":["visit_i64","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map":["visit_map","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_none":["visit_none","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq":["visit_seq","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some":["visit_some","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str":["visit_str","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string":["visit_string","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64":["visit_u64","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_unit":["visit_unit","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any":["deserialize_any","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char":["deserialize_char","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128":["deserialize_i128","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map":["deserialize_map","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option":["deserialize_option","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str":["deserialize_str","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string":["deserialize_string","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128":["deserialize_u128","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::BorrowedCowStrDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed":["variant_seed","Real(LocalPath(\"src/value/de.rs\"))","serde::de::EnumAccess"],"<value::de::EnumDeserializer as serde::de::EnumAccess<'de>>::variant_seed":["variant_seed","Real(LocalPath(\"src/value/de.rs\"))","serde::de::EnumAccess"],"<value::de::EnumRefDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed":["variant_seed","Real(LocalPath(\"src/value/de.rs\"))","serde::de::EnumAccess"],"<value::de::KeyClassifier as serde::de::DeserializeSeed<'de>>::deserialize":["deserialize","Real(LocalPath(\"src/value/de.rs\"))","serde::de::DeserializeSeed"],"<value::de::KeyClassifier as serde::de::Visitor<'de>>::expecting":["expecting","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_str":["visit_str","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_string":["visit_string","Real(LocalPath(\"src/value/de.rs\"))","serde::de::Visitor"],"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed":["next_key_seed","Real(LocalPath(\"src/value/de.rs\"))","serde::de::MapAccess"],"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed":["next_value_seed","Real(LocalPath(\"src/value/de.rs\"))","serde::de::MapAccess"],"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::size_hint":["size_hint","Real(LocalPath(\"src/value/de.rs\"))","serde::de::MapAccess"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any":["deserialize_any","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char":["deserialize_char","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128":["deserialize_i128","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map":["deserialize_map","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option":["deserialize_option","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str":["deserialize_str","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string":["deserialize_string","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128":["deserialize_u128","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs\"))","serde::Deserializer"],"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_key_seed":["next_key_seed","Real(LocalPath(\"src/value/de.rs\"))","serde::de::MapAccess"],"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_value_seed":["next_value_seed","Real(LocalPath(\"src/value/de.rs\"))","serde::de::MapAccess"],"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::size_hint":["size_hint","Real(LocalPath(\"src/value/de.rs\"))","serde::de::MapAccess"],"<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed":["next_element_seed","Real(LocalPath(\"src/value/de.rs\"))","serde::de::SeqAccess"],"<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint":["size_hint","Real(LocalPath(\"src/value/de.rs\"))","serde::de::SeqAccess"],"<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::next_element_seed":["next_element_seed","Real(LocalPath(\"src/value/de.rs\"))","serde::de::SeqAccess"],"<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::size_hint":["size_hint","Real(LocalPath(\"src/value/de.rs\"))","serde::de::SeqAccess"],"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::newtype_variant_seed":["newtype_variant_seed","Real(LocalPath(\"src/value/de.rs\"))","serde::de::VariantAccess"],"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::struct_variant":["struct_variant","Real(LocalPath(\"src/value/de.rs\"))","serde::de::VariantAccess"],"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::tuple_variant":["tuple_variant","Real(LocalPath(\"src/value/de.rs\"))","serde::de::VariantAccess"],"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::unit_variant":["unit_variant","Real(LocalPath(\"src/value/de.rs\"))","serde::de::VariantAccess"],"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed":["newtype_variant_seed","Real(LocalPath(\"src/value/de.rs\"))","serde::de::VariantAccess"],"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::struct_variant":["struct_variant","Real(LocalPath(\"src/value/de.rs\"))","serde::de::VariantAccess"],"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::tuple_variant":["tuple_variant","Real(LocalPath(\"src/value/de.rs\"))","serde::de::VariantAccess"],"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::unit_variant":["unit_variant","Real(LocalPath(\"src/value/de.rs\"))","serde::de::VariantAccess"],"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::newtype_variant_seed":["newtype_variant_seed","Real(LocalPath(\"src/value/de.rs\"))","serde::de::VariantAccess"],"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::struct_variant":["struct_variant","Real(LocalPath(\"src/value/de.rs\"))","serde::de::VariantAccess"],"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::tuple_variant":["tuple_variant","Real(LocalPath(\"src/value/de.rs\"))","serde::de::VariantAccess"],"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::unit_variant":["unit_variant","Real(LocalPath(\"src/value/de.rs\"))","serde::de::VariantAccess"],"<value::index::Type<'a> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/value/index.rs\"))","std::fmt::Display"],"<value::ser::MapKeySerializer as serde::Serializer>::collect_str":["collect_str","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_bool":["serialize_bool","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_bytes":["serialize_bytes","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_char":["serialize_char","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_f32":["serialize_f32","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_f64":["serialize_f64","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_i16":["serialize_i16","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_i32":["serialize_i32","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_i64":["serialize_i64","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_i8":["serialize_i8","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_map":["serialize_map","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_struct":["serialize_newtype_struct","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_variant":["serialize_newtype_variant","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_none":["serialize_none","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_seq":["serialize_seq","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_some":["serialize_some","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_str":["serialize_str","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct":["serialize_struct","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct_variant":["serialize_struct_variant","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple":["serialize_tuple","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_struct":["serialize_tuple_struct","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_variant":["serialize_tuple_variant","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_u16":["serialize_u16","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_u32":["serialize_u32","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_u64":["serialize_u64","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_u8":["serialize_u8","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit":["serialize_unit","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_struct":["serialize_unit_struct","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_variant":["serialize_unit_variant","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::SerializeMap as serde::ser::SerializeMap>::end":["end","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeMap"],"<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_key":["serialize_key","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeMap"],"<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_value":["serialize_value","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeMap"],"<value::ser::SerializeMap as serde::ser::SerializeStruct>::end":["end","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeStruct"],"<value::ser::SerializeMap as serde::ser::SerializeStruct>::serialize_field":["serialize_field","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeStruct"],"<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::end":["end","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeStructVariant"],"<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::serialize_field":["serialize_field","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeStructVariant"],"<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::end":["end","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeTupleVariant"],"<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::serialize_field":["serialize_field","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeTupleVariant"],"<value::ser::SerializeVec as serde::ser::SerializeSeq>::end":["end","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeSeq"],"<value::ser::SerializeVec as serde::ser::SerializeSeq>::serialize_element":["serialize_element","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeSeq"],"<value::ser::SerializeVec as serde::ser::SerializeTuple>::end":["end","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeTuple"],"<value::ser::SerializeVec as serde::ser::SerializeTuple>::serialize_element":["serialize_element","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeTuple"],"<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::end":["end","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeTupleStruct"],"<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::serialize_field":["serialize_field","Real(LocalPath(\"src/value/ser.rs\"))","serde::ser::SerializeTupleStruct"],"<value::ser::Serializer as serde::Serializer>::collect_str":["collect_str","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_bool":["serialize_bool","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_bytes":["serialize_bytes","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_char":["serialize_char","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_f32":["serialize_f32","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_f64":["serialize_f64","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_i128":["serialize_i128","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_i16":["serialize_i16","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_i32":["serialize_i32","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_i64":["serialize_i64","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_i8":["serialize_i8","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_map":["serialize_map","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_newtype_struct":["serialize_newtype_struct","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_newtype_variant":["serialize_newtype_variant","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_none":["serialize_none","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_seq":["serialize_seq","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_some":["serialize_some","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_str":["serialize_str","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_struct":["serialize_struct","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_struct_variant":["serialize_struct_variant","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_tuple":["serialize_tuple","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_tuple_struct":["serialize_tuple_struct","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_tuple_variant":["serialize_tuple_variant","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_u128":["serialize_u128","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_u16":["serialize_u16","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_u32":["serialize_u32","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_u64":["serialize_u64","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_u8":["serialize_u8","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_unit":["serialize_unit","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_unit_struct":["serialize_unit_struct","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"<value::ser::Serializer as serde::Serializer>::serialize_unit_variant":["serialize_unit_variant","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serializer"],"de::<impl std::str::FromStr for number::Number>::from_str":["from_str","Real(LocalPath(\"src/de.rs\"))","std::str::FromStr"],"de::Deserializer::<R>::deserialize_number":["deserialize_number","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::eat_char":["eat_char","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::end":["end","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::end_map":["end_map","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::end_seq":["end_seq","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::error":["error","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::f64_from_parts":["f64_from_parts","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::fix_position":["fix_position","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::ignore_decimal":["ignore_decimal","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::ignore_exponent":["ignore_exponent","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::ignore_integer":["ignore_integer","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::ignore_value":["ignore_value","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::into_iter":["into_iter","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::new":["new","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::next_char":["next_char","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::next_char_or_null":["next_char_or_null","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::parse_any_number":["parse_any_number","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::parse_any_signed_number":["parse_any_signed_number","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::parse_decimal":["parse_decimal","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::parse_decimal_overflow":["parse_decimal_overflow","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::parse_exponent":["parse_exponent","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::parse_exponent_overflow":["parse_exponent_overflow","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::parse_ident":["parse_ident","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::parse_integer":["parse_integer","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::parse_long_integer":["parse_long_integer","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::parse_number":["parse_number","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::parse_object_colon":["parse_object_colon","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::parse_whitespace":["parse_whitespace","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::peek":["peek","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::peek_error":["peek_error","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::peek_invalid_type":["peek_invalid_type","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::peek_or_null":["peek_or_null","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<R>::scan_integer128":["scan_integer128","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<read::IoRead<R>>::from_reader":["from_reader","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<read::SliceRead<'a>>::from_slice":["from_slice","Real(LocalPath(\"src/de.rs\"))",""],"de::Deserializer::<read::StrRead<'a>>::from_str":["from_str","Real(LocalPath(\"src/de.rs\"))",""],"de::MapAccess::<'a, R>::new":["new","Real(LocalPath(\"src/de.rs\"))",""],"de::ParserNumber::invalid_type":["invalid_type","Real(LocalPath(\"src/de.rs\"))",""],"de::ParserNumber::visit":["visit","Real(LocalPath(\"src/de.rs\"))",""],"de::SeqAccess::<'a, R>::new":["new","Real(LocalPath(\"src/de.rs\"))",""],"de::StreamDeserializer::<'de, R, T>::byte_offset":["byte_offset","Real(LocalPath(\"src/de.rs\"))",""],"de::StreamDeserializer::<'de, R, T>::new":["new","Real(LocalPath(\"src/de.rs\"))",""],"de::StreamDeserializer::<'de, R, T>::peek_end_of_value":["peek_end_of_value","Real(LocalPath(\"src/de.rs\"))",""],"de::UnitVariantAccess::<'a, R>::new":["new","Real(LocalPath(\"src/de.rs\"))",""],"de::VariantAccess::<'a, R>::new":["new","Real(LocalPath(\"src/de.rs\"))",""],"de::from_reader":["from_reader","Real(LocalPath(\"src/de.rs\"))",""],"de::from_slice":["from_slice","Real(LocalPath(\"src/de.rs\"))",""],"de::from_str":["from_str","Real(LocalPath(\"src/de.rs\"))",""],"de::from_trait":["from_trait","Real(LocalPath(\"src/de.rs\"))",""],"error::<impl std::convert::From<error::Error> for std::io::Error>::from":["from","Real(LocalPath(\"src/error.rs\"))","std::convert::From"],"error::Error::classify":["classify","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::column":["column","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::fix_position":["fix_position","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::io":["io","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::is_data":["is_data","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::is_eof":["is_eof","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::is_io":["is_io","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::is_syntax":["is_syntax","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::line":["line","Real(LocalPath(\"src/error.rs\"))",""],"error::Error::syntax":["syntax","Real(LocalPath(\"src/error.rs\"))",""],"error::make_error":["make_error","Real(LocalPath(\"src/error.rs\"))",""],"error::parse_line_col":["parse_line_col","Real(LocalPath(\"src/error.rs\"))",""],"error::starts_with_digit":["starts_with_digit","Real(LocalPath(\"src/error.rs\"))",""],"iter::LineColIterator::<I>::byte_offset":["byte_offset","Real(LocalPath(\"src/iter.rs\"))",""],"iter::LineColIterator::<I>::col":["col","Real(LocalPath(\"src/iter.rs\"))",""],"iter::LineColIterator::<I>::line":["line","Real(LocalPath(\"src/iter.rs\"))",""],"iter::LineColIterator::<I>::new":["new","Real(LocalPath(\"src/iter.rs\"))",""],"map::Entry::<'a>::and_modify":["and_modify","Real(LocalPath(\"src/map.rs\"))",""],"map::Entry::<'a>::key":["key","Real(LocalPath(\"src/map.rs\"))",""],"map::Entry::<'a>::or_insert":["or_insert","Real(LocalPath(\"src/map.rs\"))",""],"map::Entry::<'a>::or_insert_with":["or_insert_with","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::append":["append","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::clear":["clear","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::contains_key":["contains_key","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::entry":["entry","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::get":["get","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::get_key_value":["get_key_value","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::get_mut":["get_mut","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::insert":["insert","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::is_empty":["is_empty","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::iter":["iter","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::iter_mut":["iter_mut","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::keys":["keys","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::len":["len","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::new":["new","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::remove":["remove","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::remove_entry":["remove_entry","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::retain":["retain","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::values":["values","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::values_mut":["values_mut","Real(LocalPath(\"src/map.rs\"))",""],"map::Map::<std::string::String, value::Value>::with_capacity":["with_capacity","Real(LocalPath(\"src/map.rs\"))",""],"map::OccupiedEntry::<'a>::get":["get","Real(LocalPath(\"src/map.rs\"))",""],"map::OccupiedEntry::<'a>::get_mut":["get_mut","Real(LocalPath(\"src/map.rs\"))",""],"map::OccupiedEntry::<'a>::insert":["insert","Real(LocalPath(\"src/map.rs\"))",""],"map::OccupiedEntry::<'a>::into_mut":["into_mut","Real(LocalPath(\"src/map.rs\"))",""],"map::OccupiedEntry::<'a>::key":["key","Real(LocalPath(\"src/map.rs\"))",""],"map::OccupiedEntry::<'a>::remove":["remove","Real(LocalPath(\"src/map.rs\"))",""],"map::VacantEntry::<'a>::insert":["insert","Real(LocalPath(\"src/map.rs\"))",""],"map::VacantEntry::<'a>::key":["key","Real(LocalPath(\"src/map.rs\"))",""],"number::Number::as_f32":["as_f32","Real(LocalPath(\"src/number.rs\"))",""],"number::Number::as_f64":["as_f64","Real(LocalPath(\"src/number.rs\"))",""],"number::Number::as_i64":["as_i64","Real(LocalPath(\"src/number.rs\"))",""],"number::Number::as_u64":["as_u64","Real(LocalPath(\"src/number.rs\"))",""],"number::Number::from_f32":["from_f32","Real(LocalPath(\"src/number.rs\"))",""],"number::Number::from_f64":["from_f64","Real(LocalPath(\"src/number.rs\"))",""],"number::Number::is_f64":["is_f64","Real(LocalPath(\"src/number.rs\"))",""],"number::Number::is_i64":["is_i64","Real(LocalPath(\"src/number.rs\"))",""],"number::Number::is_u64":["is_u64","Real(LocalPath(\"src/number.rs\"))",""],"number::Number::unexpected":["unexpected","Real(LocalPath(\"src/number.rs\"))",""],"read::IoRead::<R>::new":["new","Real(LocalPath(\"src/read.rs\"))",""],"read::IoRead::<R>::parse_str_bytes":["parse_str_bytes","Real(LocalPath(\"src/read.rs\"))",""],"read::SliceRead::<'a>::new":["new","Real(LocalPath(\"src/read.rs\"))",""],"read::SliceRead::<'a>::parse_str_bytes":["parse_str_bytes","Real(LocalPath(\"src/read.rs\"))",""],"read::SliceRead::<'a>::position_of_index":["position_of_index","Real(LocalPath(\"src/read.rs\"))",""],"read::StrRead::<'a>::new":["new","Real(LocalPath(\"src/read.rs\"))",""],"read::as_str":["as_str","Real(LocalPath(\"src/read.rs\"))",""],"read::decode_hex_val":["decode_hex_val","Real(LocalPath(\"src/read.rs\"))",""],"read::error":["error","Real(LocalPath(\"src/read.rs\"))",""],"read::ignore_escape":["ignore_escape","Real(LocalPath(\"src/read.rs\"))",""],"read::next_or_eof":["next_or_eof","Real(LocalPath(\"src/read.rs\"))",""],"read::parse_escape":["parse_escape","Real(LocalPath(\"src/read.rs\"))",""],"read::parse_escape::encode_surrogate":["encode_surrogate","Real(LocalPath(\"src/read.rs\"))",""],"read::peek_or_eof":["peek_or_eof","Real(LocalPath(\"src/read.rs\"))",""],"ser::CharEscape::from_escape_table":["from_escape_table","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::begin_array":["begin_array","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::begin_array_value":["begin_array_value","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::begin_object":["begin_object","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::begin_object_key":["begin_object_key","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::begin_object_value":["begin_object_value","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::begin_string":["begin_string","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::end_array":["end_array","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::end_array_value":["end_array_value","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::end_object":["end_object","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::end_object_key":["end_object_key","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::end_object_value":["end_object_value","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::end_string":["end_string","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_bool":["write_bool","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_char_escape":["write_char_escape","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_f32":["write_f32","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_f64":["write_f64","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_i128":["write_i128","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_i16":["write_i16","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_i32":["write_i32","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_i64":["write_i64","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_i8":["write_i8","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_null":["write_null","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_number_str":["write_number_str","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_raw_fragment":["write_raw_fragment","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_string_fragment":["write_string_fragment","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_u128":["write_u128","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_u16":["write_u16","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_u32":["write_u32","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_u64":["write_u64","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Formatter::write_u8":["write_u8","Real(LocalPath(\"src/ser.rs\"))",""],"ser::PrettyFormatter::<'a>::new":["new","Real(LocalPath(\"src/ser.rs\"))",""],"ser::PrettyFormatter::<'a>::with_indent":["with_indent","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Serializer::<W, F>::into_inner":["into_inner","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Serializer::<W, F>::with_formatter":["with_formatter","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Serializer::<W, ser::PrettyFormatter<'a>>::pretty":["pretty","Real(LocalPath(\"src/ser.rs\"))",""],"ser::Serializer::<W>::new":["new","Real(LocalPath(\"src/ser.rs\"))",""],"ser::format_escaped_str":["format_escaped_str","Real(LocalPath(\"src/ser.rs\"))",""],"ser::format_escaped_str_contents":["format_escaped_str_contents","Real(LocalPath(\"src/ser.rs\"))",""],"ser::indent":["indent","Real(LocalPath(\"src/ser.rs\"))",""],"ser::key_must_be_a_string":["key_must_be_a_string","Real(LocalPath(\"src/ser.rs\"))",""],"ser::to_string":["to_string","Real(LocalPath(\"src/ser.rs\"))",""],"ser::to_string_pretty":["to_string_pretty","Real(LocalPath(\"src/ser.rs\"))",""],"ser::to_vec":["to_vec","Real(LocalPath(\"src/ser.rs\"))",""],"ser::to_vec_pretty":["to_vec_pretty","Real(LocalPath(\"src/ser.rs\"))",""],"ser::to_writer":["to_writer","Real(LocalPath(\"src/ser.rs\"))",""],"ser::to_writer_pretty":["to_writer_pretty","Real(LocalPath(\"src/ser.rs\"))",""],"value::Value::as_array":["as_array","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::as_array_mut":["as_array_mut","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::as_bool":["as_bool","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::as_f64":["as_f64","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::as_i64":["as_i64","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::as_null":["as_null","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::as_object":["as_object","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::as_object_mut":["as_object_mut","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::as_str":["as_str","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::as_u64":["as_u64","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::get":["get","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::get_mut":["get_mut","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::is_array":["is_array","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::is_boolean":["is_boolean","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::is_f64":["is_f64","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::is_i64":["is_i64","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::is_null":["is_null","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::is_number":["is_number","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::is_object":["is_object","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::is_string":["is_string","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::is_u64":["is_u64","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::pointer":["pointer","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::pointer_mut":["pointer_mut","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::Value::take":["take","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize":["deserialize","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserialize"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_any":["deserialize_any","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_char":["deserialize_char","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i128":["deserialize_i128","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_map":["deserialize_map","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_option":["deserialize_option","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_str":["deserialize_str","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_string":["deserialize_string","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u128":["deserialize_u128","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_any":["deserialize_any","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bool":["deserialize_bool","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_byte_buf":["deserialize_byte_buf","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bytes":["deserialize_bytes","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_char":["deserialize_char","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_enum":["deserialize_enum","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f32":["deserialize_f32","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f64":["deserialize_f64","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i128":["deserialize_i128","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i16":["deserialize_i16","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i32":["deserialize_i32","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i64":["deserialize_i64","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i8":["deserialize_i8","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_identifier":["deserialize_identifier","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_ignored_any":["deserialize_ignored_any","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_map":["deserialize_map","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_newtype_struct":["deserialize_newtype_struct","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_option":["deserialize_option","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_seq":["deserialize_seq","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_str":["deserialize_str","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_string":["deserialize_string","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_struct":["deserialize_struct","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple":["deserialize_tuple","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple_struct":["deserialize_tuple_struct","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u128":["deserialize_u128","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u16":["deserialize_u16","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u32":["deserialize_u32","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u64":["deserialize_u64","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u8":["deserialize_u8","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit":["deserialize_unit","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit_struct":["deserialize_unit_struct","Real(LocalPath(\"src/value/de.rs\"))","serde::Deserializer"],"value::de::<impl serde::de::IntoDeserializer<'de, error::Error> for value::Value>::into_deserializer":["into_deserializer","Real(LocalPath(\"src/value/de.rs\"))","serde::de::IntoDeserializer"],"value::de::<impl std::str::FromStr for value::Value>::from_str":["from_str","Real(LocalPath(\"src/value/de.rs\"))","std::str::FromStr"],"value::de::<impl value::Value>::invalid_type":["invalid_type","Real(LocalPath(\"src/value/de.rs\"))",""],"value::de::<impl value::Value>::unexpected":["unexpected","Real(LocalPath(\"src/value/de.rs\"))",""],"value::de::BorrowedCowStrDeserializer::<'de>::new":["new","Real(LocalPath(\"src/value/de.rs\"))",""],"value::de::MapDeserializer::new":["new","Real(LocalPath(\"src/value/de.rs\"))",""],"value::de::MapRefDeserializer::<'de>::new":["new","Real(LocalPath(\"src/value/de.rs\"))",""],"value::de::SeqDeserializer::new":["new","Real(LocalPath(\"src/value/de.rs\"))",""],"value::de::SeqRefDeserializer::<'de>::new":["new","Real(LocalPath(\"src/value/de.rs\"))",""],"value::de::visit_array":["visit_array","Real(LocalPath(\"src/value/de.rs\"))",""],"value::de::visit_array_ref":["visit_array_ref","Real(LocalPath(\"src/value/de.rs\"))",""],"value::de::visit_object":["visit_object","Real(LocalPath(\"src/value/de.rs\"))",""],"value::de::visit_object_ref":["visit_object_ref","Real(LocalPath(\"src/value/de.rs\"))",""],"value::from::<impl std::convert::From<&'a [T]> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<&'a str> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<()> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<bool> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<f32> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<f64> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<i16> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<i32> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<i64> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<i8> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<isize> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<map::Map<std::string::String, value::Value>> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<number::Number> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<std::borrow::Cow<'a, str>> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<std::option::Option<T>> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<std::string::String> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<std::vec::Vec<T>> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<u16> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<u32> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<u64> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<u8> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::convert::From<usize> for value::Value>::from":["from","Real(LocalPath(\"src/value/from.rs\"))","std::convert::From"],"value::from::<impl std::iter::FromIterator<(K, V)> for value::Value>::from_iter":["from_iter","Real(LocalPath(\"src/value/from.rs\"))","std::iter::FromIterator"],"value::from::<impl std::iter::FromIterator<T> for value::Value>::from_iter":["from_iter","Real(LocalPath(\"src/value/from.rs\"))","std::iter::FromIterator"],"value::from_value":["from_value","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::index::<impl std::ops::Index<I> for value::Value>::index":["index","Real(LocalPath(\"src/value/index.rs\"))","std::ops::Index"],"value::index::<impl std::ops::IndexMut<I> for value::Value>::index_mut":["index_mut","Real(LocalPath(\"src/value/index.rs\"))","std::ops::IndexMut"],"value::parse_index":["parse_index","Real(LocalPath(\"src/value/mod.rs\"))",""],"value::partial_eq::<impl std::cmp::PartialEq<&'a str> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<bool> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<bool> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<bool> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<f32> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<f32> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<f32> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<f64> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<f64> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<f64> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<i16> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<i16> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<i16> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<i32> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<i32> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<i32> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<i64> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<i64> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<i64> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<i8> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<i8> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<i8> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<isize> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<isize> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<isize> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<std::string::String> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<str> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<u16> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<u16> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<u16> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<u32> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<u32> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<u32> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<u64> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<u64> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<u64> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<u8> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<u8> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<u8> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<usize> for &'a mut value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<usize> for &'a value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<usize> for value::Value>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for &'a str>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for bool>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for f32>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for f64>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i16>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i32>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i64>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i8>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for isize>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for std::string::String>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for str>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u16>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u32>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u64>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u8>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::<impl std::cmp::PartialEq<value::Value> for usize>::eq":["eq","Real(LocalPath(\"src/value/partial_eq.rs\"))","std::cmp::PartialEq"],"value::partial_eq::eq_bool":["eq_bool","Real(LocalPath(\"src/value/partial_eq.rs\"))",""],"value::partial_eq::eq_f32":["eq_f32","Real(LocalPath(\"src/value/partial_eq.rs\"))",""],"value::partial_eq::eq_f64":["eq_f64","Real(LocalPath(\"src/value/partial_eq.rs\"))",""],"value::partial_eq::eq_i64":["eq_i64","Real(LocalPath(\"src/value/partial_eq.rs\"))",""],"value::partial_eq::eq_str":["eq_str","Real(LocalPath(\"src/value/partial_eq.rs\"))",""],"value::partial_eq::eq_u64":["eq_u64","Real(LocalPath(\"src/value/partial_eq.rs\"))",""],"value::ser::<impl serde::Serialize for value::Value>::serialize":["serialize","Real(LocalPath(\"src/value/ser.rs\"))","serde::Serialize"],"value::ser::key_must_be_a_string":["key_must_be_a_string","Real(LocalPath(\"src/value/ser.rs\"))",""],"value::to_value":["to_value","Real(LocalPath(\"src/value/mod.rs\"))",""]},"trait_to_struct":{"read::Fused":["read::SliceRead","read::StrRead"],"read::Read":["read::IoRead","read::SliceRead","read::StrRead"],"read::private::Sealed":["read::IoRead","read::SliceRead","read::StrRead"],"ser::Formatter":["ser::CompactFormatter","ser::PrettyFormatter"],"serde::Deserialize":["map::Map","number::Number","value::Value"],"serde::Deserializer":["de::MapKey","number::Number","value::Value","value::de::BorrowedCowStrDeserializer","value::de::MapKeyDeserializer"],"serde::Serialize":["map::Map","number::Number","value::Value"],"serde::Serializer":["ser::MapKeySerializer","value::ser::MapKeySerializer","value::ser::Serializer"],"serde::de::DeserializeSeed":["value::de::KeyClassifier"],"serde::de::EnumAccess":["de::UnitVariantAccess","de::VariantAccess","value::de::BorrowedCowStrDeserializer","value::de::EnumDeserializer","value::de::EnumRefDeserializer"],"serde::de::Error":["error::Error"],"serde::de::IntoDeserializer":["value::Value"],"serde::de::MapAccess":["de::MapAccess","value::de::MapDeserializer","value::de::MapRefDeserializer"],"serde::de::SeqAccess":["de::SeqAccess","value::de::SeqDeserializer","value::de::SeqRefDeserializer"],"serde::de::VariantAccess":["de::UnitVariantAccess","de::VariantAccess","value::de::UnitOnly","value::de::VariantDeserializer","value::de::VariantRefDeserializer"],"serde::de::Visitor":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"],"serde::ser::Error":["error::Error"],"serde::ser::SerializeMap":["ser::Compound","value::ser::SerializeMap"],"serde::ser::SerializeSeq":["ser::Compound","value::ser::SerializeVec"],"serde::ser::SerializeStruct":["ser::Compound","value::ser::SerializeMap"],"serde::ser::SerializeStructVariant":["ser::Compound","value::ser::SerializeStructVariant"],"serde::ser::SerializeTuple":["ser::Compound","value::ser::SerializeVec"],"serde::ser::SerializeTupleStruct":["ser::Compound","value::ser::SerializeVec"],"serde::ser::SerializeTupleVariant":["ser::Compound","value::ser::SerializeTupleVariant"],"std::clone::Clone":["error::Category","map::Map","number::N","number::Number","ser::CompactFormatter","ser::PrettyFormatter","value::Value"],"std::cmp::Eq":["error::Category","map::Map","number::N","number::Number","ser::State","value::Value"],"std::cmp::PartialEq":["error::Category","map::Map","number::N","number::Number","ser::State","std::string::String","value::Value"],"std::convert::From":["number::Number","std::io::Error","value::Value"],"std::default::Default":["map::Map","ser::PrettyFormatter","value::Value"],"std::error::Error":["error::Error"],"std::fmt::Debug":["error::Category","error::Error","map::Map","number::Number","ser::CompactFormatter","ser::PrettyFormatter","value::Value"],"std::fmt::Display":["error::Error","error::ErrorCode","error::ErrorImpl","number::Number","value::Value","value::index::Type"],"std::fmt::Write":["<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter"],"std::hash::Hash":["number::N","number::Number"],"std::io::Write":["<value::Value as std::fmt::Display>::fmt::WriterFormatter"],"std::iter::DoubleEndedIterator":["map::IntoIter","map::Iter","map::IterMut","map::Keys","map::Values","map::ValuesMut"],"std::iter::ExactSizeIterator":["map::IntoIter","map::Iter","map::IterMut","map::Keys","map::Values","map::ValuesMut"],"std::iter::Extend":["map::Map"],"std::iter::FromIterator":["map::Map","value::Value"],"std::iter::FusedIterator":["de::StreamDeserializer","map::IntoIter","map::Iter","map::IterMut","map::Keys","map::Values","map::ValuesMut"],"std::iter::IntoIterator":["map::Map"],"std::iter::Iterator":["de::StreamDeserializer","iter::LineColIterator","map::IntoIter","map::Iter","map::IterMut","map::Keys","map::Values","map::ValuesMut"],"std::marker::Copy":["error::Category","number::N"],"std::marker::StructuralEq":["error::Category","number::Number","ser::State","value::Value"],"std::marker::StructuralPartialEq":["error::Category","number::Number","ser::State","value::Value"],"std::ops::Deref":["read::Reference"],"std::ops::Index":["map::Map","value::Value"],"std::ops::IndexMut":["map::Map","value::Value"],"std::str::FromStr":["number::Number","value::Value"],"value::index::Index":["std::string::String"],"value::index::private::Sealed":["std::string::String"]},"type_to_def_path":{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F>":"<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor":"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor":"<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b>":"<value::Value as std::fmt::Display>::fmt::WriterFormatter","de::Deserializer<R>":"de::Deserializer","de::MapAccess<'a, R>":"de::MapAccess","de::MapKey<'a, R>":"de::MapKey","de::ParserNumber":"de::ParserNumber","de::SeqAccess<'a, R>":"de::SeqAccess","de::StreamDeserializer<'de, R, T>":"de::StreamDeserializer","de::UnitVariantAccess<'a, R>":"de::UnitVariantAccess","de::VariantAccess<'a, R>":"de::VariantAccess","error::Category":"error::Category","error::Error":"error::Error","error::ErrorCode":"error::ErrorCode","error::ErrorImpl":"error::ErrorImpl","iter::LineColIterator<I>":"iter::LineColIterator","map::Entry<'a>":"map::Entry","map::IntoIter":"map::IntoIter","map::Iter<'a>":"map::Iter","map::IterMut<'a>":"map::IterMut","map::Keys<'a>":"map::Keys","map::Map<K, V>":"map::Map","map::OccupiedEntry<'a>":"map::OccupiedEntry","map::VacantEntry<'a>":"map::VacantEntry","map::Values<'a>":"map::Values","map::ValuesMut<'a>":"map::ValuesMut","number::N":"number::N","number::Number":"number::Number","read::IoRead<R>":"read::IoRead","read::Position":"read::Position","read::Reference<'b, 'c, T>":"read::Reference","read::SliceRead<'a>":"read::SliceRead","read::StrRead<'a>":"read::StrRead","ser::CharEscape":"ser::CharEscape","ser::CompactFormatter":"ser::CompactFormatter","ser::Compound<'a, W, F>":"ser::Compound","ser::MapKeySerializer<'a, W, F>":"ser::MapKeySerializer","ser::PrettyFormatter<'a>":"ser::PrettyFormatter","ser::Serializer<W, F>":"ser::Serializer","ser::State":"ser::State","value::Value":"value::Value","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor":"value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::BorrowedCowStrDeserializer<'de>":"value::de::BorrowedCowStrDeserializer","value::de::EnumDeserializer":"value::de::EnumDeserializer","value::de::EnumRefDeserializer<'de>":"value::de::EnumRefDeserializer","value::de::KeyClass":"value::de::KeyClass","value::de::KeyClassifier":"value::de::KeyClassifier","value::de::MapDeserializer":"value::de::MapDeserializer","value::de::MapKeyDeserializer<'de>":"value::de::MapKeyDeserializer","value::de::MapRefDeserializer<'de>":"value::de::MapRefDeserializer","value::de::SeqDeserializer":"value::de::SeqDeserializer","value::de::SeqRefDeserializer<'de>":"value::de::SeqRefDeserializer","value::de::UnitOnly":"value::de::UnitOnly","value::de::VariantDeserializer":"value::de::VariantDeserializer","value::de::VariantRefDeserializer<'de>":"value::de::VariantRefDeserializer","value::index::Type<'a>":"value::index::Type","value::ser::MapKeySerializer":"value::ser::MapKeySerializer","value::ser::SerializeMap":"value::ser::SerializeMap","value::ser::SerializeStructVariant":"value::ser::SerializeStructVariant","value::ser::SerializeTupleVariant":"value::ser::SerializeTupleVariant","value::ser::SerializeVec":"value::ser::SerializeVec","value::ser::Serializer":"value::ser::Serializer"}}