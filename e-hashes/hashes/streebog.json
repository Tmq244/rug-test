{"dependencies":{"<Oid256 as core::clone::Clone>::clone":["Oid256"],"<Oid256 as core::cmp::Eq>::assert_receiver_is_total_eq":["Oid256"],"<Oid256 as core::cmp::PartialEq>::eq":["Oid256"],"<Oid256 as core::fmt::Debug>::fmt":["Oid256","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Oid256 as core::hash::Hash>::hash":["Oid256","core::hash::Hasher","core::marker::Sized"],"<Oid512 as core::clone::Clone>::clone":["Oid512"],"<Oid512 as core::cmp::Eq>::assert_receiver_is_total_eq":["Oid512"],"<Oid512 as core::cmp::PartialEq>::eq":["Oid512"],"<Oid512 as core::fmt::Debug>::fmt":["Oid512","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Oid512 as core::hash::Hash>::hash":["Oid512","core::hash::Hasher","core::marker::Sized"],"<core_api::StreebogVarCore as core::clone::Clone>::clone":["core_api::StreebogVarCore"],"<core_api::StreebogVarCore as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","core_api::StreebogVarCore"],"<core_api::StreebogVarCore as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<core_api::StreebogVarCore as digest::core_api::UpdateCore>::update_blocks":["core::marker::Sized","core_api::StreebogVarCore","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"<core_api::StreebogVarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["core::marker::Sized","core_api::StreebogVarCore","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero"],"<core_api::StreebogVarCore as digest::core_api::VariableOutputCore>::new":["core::marker::Sized","core::result::Result"],"Oid256":["Oid256"],"Oid512":["Oid512"],"core_api::StreebogVarCore":["core_api::StreebogVarCore"],"core_api::StreebogVarCore::compress":["core_api::StreebogVarCore"],"core_api::StreebogVarCore::g":["core_api::StreebogVarCore"],"core_api::StreebogVarCore::update_n":["core_api::StreebogVarCore"],"core_api::StreebogVarCore::update_sigma":["core_api::StreebogVarCore"],"core_api::adc":[],"core_api::from_bytes":[],"core_api::lps":[],"core_api::to_bytes":[]},"glob_path_import":{},"self_to_fn":{"Oid256":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"Oid512":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"core_api::StreebogVarCore":["Clone","impl AlgorithmName for StreebogVarCore {\n    #[inline]\n    fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"Streebog\")\n    }\n}","impl BlockSizeUser for StreebogVarCore {\n    type BlockSize = U64;\n}","impl BufferKindUser for StreebogVarCore {\n    type BufferKind = Eager;\n}","impl HashMarker for StreebogVarCore {}","impl OutputSizeUser for StreebogVarCore {\n    type OutputSize = U64;\n}","impl StreebogVarCore {\n    fn g(&mut self, n: &Block, m: &Block) {\n        let mut key = [0u8; 64];\n        let mut block = [0u8; 64];\n\n        key.copy_from_slice(&self.h);\n        block.copy_from_slice(m);\n\n        lps(&mut key, n);\n\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..12 {\n            lps(&mut block, &key);\n            lps(&mut key, &C[i]);\n        }\n\n        for i in 0..64 {\n            self.h[i] ^= block[i] ^ key[i] ^ m[i];\n        }\n    }\n\n    fn update_sigma(&mut self, m: &Block) {\n        let t = from_bytes(m);\n        let mut carry = 0;\n        adc(&mut self.sigma[0], t[0], &mut carry);\n        adc(&mut self.sigma[1], t[1], &mut carry);\n        adc(&mut self.sigma[2], t[2], &mut carry);\n        adc(&mut self.sigma[3], t[3], &mut carry);\n        adc(&mut self.sigma[4], t[4], &mut carry);\n        adc(&mut self.sigma[5], t[5], &mut carry);\n        adc(&mut self.sigma[6], t[6], &mut carry);\n        adc(&mut self.sigma[7], t[7], &mut carry);\n    }\n\n    fn update_n(&mut self, len: u64) {\n        let mut carry = 0;\n        // note: `len` can not be bigger than block size,\n        // so `8*len` will never overflow\n        adc(&mut self.n[0], 8 * len, &mut carry);\n        adc(&mut self.n[1], 0, &mut carry);\n        adc(&mut self.n[2], 0, &mut carry);\n        adc(&mut self.n[3], 0, &mut carry);\n        adc(&mut self.n[4], 0, &mut carry);\n        adc(&mut self.n[5], 0, &mut carry);\n        adc(&mut self.n[6], 0, &mut carry);\n        adc(&mut self.n[7], 0, &mut carry);\n    }\n\n    fn compress(&mut self, block: &[u8; 64], msg_len: u64) {\n        self.g(&to_bytes(&self.n), block);\n        self.update_n(msg_len);\n        self.update_sigma(block);\n    }\n}","impl UpdateCore for StreebogVarCore {\n    #[inline]\n    fn update_blocks(&mut self, blocks: &[GenBlock<Self>]) {\n        for block in blocks {\n            self.compress(block.as_ref(), BLOCK_SIZE as u64);\n        }\n    }\n}","impl VariableOutputCore for StreebogVarCore {\n    const TRUNC_SIDE: TruncSide = TruncSide::Right;\n\n    #[inline]\n    fn new(output_size: usize) -> Result<Self, InvalidOutputSize> {\n        let h = match output_size {\n            32 => [1; 64],\n            64 => [0; 64],\n            _ => return Err(InvalidOutputSize),\n        };\n        let (n, sigma) = Default::default();\n        Ok(Self { h, n, sigma })\n    }\n\n    #[inline]\n    fn finalize_variable_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n        let pos = buffer.get_pos();\n        let block = buffer.pad_with_zeros();\n        block[pos] = 1;\n        self.compress(block.as_ref(), pos as u64);\n        self.g(&[0u8; 64], &to_bytes(&self.n));\n        self.g(&[0u8; 64], &to_bytes(&self.sigma));\n        out.copy_from_slice(&self.h);\n    }\n}","impl fmt::Debug for StreebogVarCore {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"StreebogVarCore { ... }\")\n    }\n}"]},"single_path_import":{"core_api::StreebogVarCore":"StreebogVarCore","digest":"digest","digest::Digest":"Digest"},"srcs":{"<core_api::StreebogVarCore as core::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"StreebogVarCore { ... }\")\n    }","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"<core_api::StreebogVarCore as digest::core_api::AlgorithmName>::write_alg_name":["#[inline]\nfn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"Streebog\")\n    }","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"<core_api::StreebogVarCore as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[GenBlock<Self>]){\n        for block in blocks {\n            self.compress(block.as_ref(), BLOCK_SIZE as u64);\n        }\n    }","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"<core_api::StreebogVarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["#[inline]\nfn finalize_variable_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n        let pos = buffer.get_pos();\n        let block = buffer.pad_with_zeros();\n        block[pos] = 1;\n        self.compress(block.as_ref(), pos as u64);\n        self.g(&[0u8; 64], &to_bytes(&self.n));\n        self.g(&[0u8; 64], &to_bytes(&self.sigma));\n        out.copy_from_slice(&self.h);\n    }","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"<core_api::StreebogVarCore as digest::core_api::VariableOutputCore>::new":["#[inline]\nfn new(output_size: usize) -> Result<Self, InvalidOutputSize>{\n        let h = match output_size {\n            32 => [1; 64],\n            64 => [0; 64],\n            _ => return Err(InvalidOutputSize),\n        };\n        let (n, sigma) = Default::default();\n        Ok(Self { h, n, sigma })\n    }","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"Oid256":["#[doc(hidden)]\npub struct $name;","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/digest-0.10.7/src/core_api/ct_variable.rs\"))"],"Oid512":["#[doc(hidden)]\npub struct $name;","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/digest-0.10.7/src/core_api/ct_variable.rs\"))"],"core_api::StreebogVarCore":["/// Core block-level Streebog hasher with variable output size.\n///\n/// Supports initialization only for 32 and 64 byte output sizes,\n/// i.e. 256 and 512 bits respectively.\npub struct StreebogVarCore {\n    h: Block,\n    n: [u64; 8],\n    sigma: [u64; 8],\n}","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"core_api::StreebogVarCore::compress":["fn compress(&mut self, block: &[u8; 64], msg_len: u64){\n        self.g(&to_bytes(&self.n), block);\n        self.update_n(msg_len);\n        self.update_sigma(block);\n    }","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"core_api::StreebogVarCore::g":["fn g(&mut self, n: &Block, m: &Block){\n        let mut key = [0u8; 64];\n        let mut block = [0u8; 64];\n\n        key.copy_from_slice(&self.h);\n        block.copy_from_slice(m);\n\n        lps(&mut key, n);\n\n        #[allow(clippy::needless_range_loop)]\n        for i in 0..12 {\n            lps(&mut block, &key);\n            lps(&mut key, &C[i]);\n        }\n\n        for i in 0..64 {\n            self.h[i] ^= block[i] ^ key[i] ^ m[i];\n        }\n    }","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"core_api::StreebogVarCore::update_n":["fn update_n(&mut self, len: u64){\n        let mut carry = 0;\n        // note: `len` can not be bigger than block size,\n        // so `8*len` will never overflow\n        adc(&mut self.n[0], 8 * len, &mut carry);\n        adc(&mut self.n[1], 0, &mut carry);\n        adc(&mut self.n[2], 0, &mut carry);\n        adc(&mut self.n[3], 0, &mut carry);\n        adc(&mut self.n[4], 0, &mut carry);\n        adc(&mut self.n[5], 0, &mut carry);\n        adc(&mut self.n[6], 0, &mut carry);\n        adc(&mut self.n[7], 0, &mut carry);\n    }","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"core_api::StreebogVarCore::update_sigma":["fn update_sigma(&mut self, m: &Block){\n        let t = from_bytes(m);\n        let mut carry = 0;\n        adc(&mut self.sigma[0], t[0], &mut carry);\n        adc(&mut self.sigma[1], t[1], &mut carry);\n        adc(&mut self.sigma[2], t[2], &mut carry);\n        adc(&mut self.sigma[3], t[3], &mut carry);\n        adc(&mut self.sigma[4], t[4], &mut carry);\n        adc(&mut self.sigma[5], t[5], &mut carry);\n        adc(&mut self.sigma[6], t[6], &mut carry);\n        adc(&mut self.sigma[7], t[7], &mut carry);\n    }","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"core_api::adc":["#[inline(always)]\nfn adc(a: &mut u64, b: u64, carry: &mut u64){\n    let ret = (*a as u128) + (b as u128) + (*carry as u128);\n    *a = ret as u64;\n    *carry = (ret >> 64) as u64;\n}","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"core_api::from_bytes":["#[inline(always)]\nfn from_bytes(b: &Block) -> [u64; 8]{\n    let mut t = [0u64; 8];\n    for (v, chunk) in t.iter_mut().zip(b.chunks_exact(8)) {\n        *v = u64::from_le_bytes(chunk.try_into().unwrap());\n    }\n    t\n}","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"core_api::lps":["#[inline(always)]\nfn lps(h: &mut Block, n: &Block){\n    for i in 0..64 {\n        h[i] ^= n[i];\n    }\n\n    let mut buf = [0u64; 8];\n\n    for i in 0..4 {\n        for j in 0..8 {\n            let b = h[2 * i + 8 * j] as usize;\n            buf[2 * i] ^= SHUFFLED_LIN_TABLE[j][b];\n            let b = h[2 * i + 1 + 8 * j] as usize;\n            buf[2 * i + 1] ^= SHUFFLED_LIN_TABLE[j][b];\n        }\n    }\n\n    *h = to_bytes(&buf);\n}","Real(LocalPath(\"streebog/src/core_api.rs\"))"],"core_api::to_bytes":["#[inline(always)]\nfn to_bytes(b: &[u64; 8]) -> Block{\n    let mut t = [0; 64];\n    for (chunk, v) in t.chunks_exact_mut(8).zip(b.iter()) {\n        chunk.copy_from_slice(&v.to_le_bytes());\n    }\n    t\n}","Real(LocalPath(\"streebog/src/core_api.rs\"))"]},"struct_constructor":{"Oid256":["clone"],"Oid512":["clone"],"[u64; 8]":["from_bytes"],"[u8; 64]":["to_bytes"],"bool":["eq"],"core::result::Result":["fmt","new","write_alg_name"],"core_api::StreebogVarCore":["clone"]},"struct_to_trait":{"Oid256":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::hash::Hash","core::marker::Copy","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"Oid512":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::hash::Hash","core::marker::Copy","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"core_api::StreebogVarCore":["core::clone::Clone","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::UpdateCore","digest::core_api::VariableOutputCore"]},"targets":{"<core_api::StreebogVarCore as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"streebog/src/core_api.rs\"))","core::fmt::Debug"],"<core_api::StreebogVarCore as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"streebog/src/core_api.rs\"))","digest::core_api::AlgorithmName"],"<core_api::StreebogVarCore as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"streebog/src/core_api.rs\"))","digest::core_api::UpdateCore"],"<core_api::StreebogVarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["finalize_variable_core","Real(LocalPath(\"streebog/src/core_api.rs\"))","digest::core_api::VariableOutputCore"],"<core_api::StreebogVarCore as digest::core_api::VariableOutputCore>::new":["new","Real(LocalPath(\"streebog/src/core_api.rs\"))","digest::core_api::VariableOutputCore"],"core_api::StreebogVarCore::compress":["compress","Real(LocalPath(\"streebog/src/core_api.rs\"))",""],"core_api::StreebogVarCore::g":["g","Real(LocalPath(\"streebog/src/core_api.rs\"))",""],"core_api::StreebogVarCore::update_n":["update_n","Real(LocalPath(\"streebog/src/core_api.rs\"))",""],"core_api::StreebogVarCore::update_sigma":["update_sigma","Real(LocalPath(\"streebog/src/core_api.rs\"))",""],"core_api::adc":["adc","Real(LocalPath(\"streebog/src/core_api.rs\"))",""],"core_api::from_bytes":["from_bytes","Real(LocalPath(\"streebog/src/core_api.rs\"))",""],"core_api::lps":["lps","Real(LocalPath(\"streebog/src/core_api.rs\"))",""],"core_api::to_bytes":["to_bytes","Real(LocalPath(\"streebog/src/core_api.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["Oid256","Oid512","core_api::StreebogVarCore"],"core::cmp::Eq":["Oid256","Oid512"],"core::cmp::PartialEq":["Oid256","Oid512"],"core::fmt::Debug":["Oid256","Oid512","core_api::StreebogVarCore"],"core::hash::Hash":["Oid256","Oid512"],"core::marker::Copy":["Oid256","Oid512"],"core::marker::StructuralEq":["Oid256","Oid512"],"core::marker::StructuralPartialEq":["Oid256","Oid512"],"digest::HashMarker":["core_api::StreebogVarCore"],"digest::OutputSizeUser":["core_api::StreebogVarCore"],"digest::core_api::AlgorithmName":["core_api::StreebogVarCore"],"digest::core_api::BlockSizeUser":["core_api::StreebogVarCore"],"digest::core_api::BufferKindUser":["core_api::StreebogVarCore"],"digest::core_api::UpdateCore":["core_api::StreebogVarCore"],"digest::core_api::VariableOutputCore":["core_api::StreebogVarCore"]},"type_to_def_path":{"Oid256":"Oid256","Oid512":"Oid512","core_api::StreebogVarCore":"core_api::StreebogVarCore"}}