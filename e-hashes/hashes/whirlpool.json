{"dependencies":{"<WhirlpoolCore as core::clone::Clone>::clone":["WhirlpoolCore"],"<WhirlpoolCore as core::default::Default>::default":["WhirlpoolCore"],"<WhirlpoolCore as core::fmt::Debug>::fmt":["WhirlpoolCore","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<WhirlpoolCore as digest::Reset>::reset":["WhirlpoolCore"],"<WhirlpoolCore as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<WhirlpoolCore as digest::core_api::FixedOutputCore>::finalize_fixed_core":["WhirlpoolCore","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero"],"<WhirlpoolCore as digest::core_api::UpdateCore>::update_blocks":["WhirlpoolCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"WhirlpoolCore":["WhirlpoolCore"],"WhirlpoolCore::update_len":["WhirlpoolCore"],"adc":[],"compress::compress":[],"compress::compress_block":[],"convert":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"]},"glob_path_import":{},"self_to_fn":{"WhirlpoolCore":["Clone","impl AlgorithmName for WhirlpoolCore {\n    fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"Whirlpool\")\n    }\n}","impl BlockSizeUser for WhirlpoolCore {\n    type BlockSize = U64;\n}","impl BufferKindUser for WhirlpoolCore {\n    type BufferKind = Eager;\n}","impl Default for WhirlpoolCore {\n    #[inline]\n    fn default() -> Self {\n        Self {\n            bit_len: Default::default(),\n            state: [0u64; 8],\n        }\n    }\n}","impl FixedOutputCore for WhirlpoolCore {\n    #[inline]\n    fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n        let pos = buffer.get_pos();\n        self.update_len(8 * pos as u64);\n\n        let mut buf = [0u8; 4 * 8];\n        for (chunk, v) in buf.chunks_exact_mut(8).zip(self.bit_len.iter()) {\n            chunk.copy_from_slice(&v.to_be_bytes());\n        }\n\n        let mut state = self.state;\n        buffer.digest_pad(0x80, &buf, |block| {\n            compress(&mut state, convert(core::slice::from_ref(block)));\n        });\n\n        for (chunk, v) in out.chunks_exact_mut(8).zip(state.iter()) {\n            chunk.copy_from_slice(&v.to_le_bytes());\n        }\n    }\n}","impl HashMarker for WhirlpoolCore {}","impl OutputSizeUser for WhirlpoolCore {\n    type OutputSize = U64;\n}","impl Reset for WhirlpoolCore {\n    #[inline]\n    fn reset(&mut self) {\n        *self = Default::default();\n    }\n}","impl UpdateCore for WhirlpoolCore {\n    #[inline]\n    fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n        let block_bits = 8 * BLOCK_SIZE as u64;\n        self.update_len(block_bits * (blocks.len() as u64));\n        compress(&mut self.state, convert(blocks));\n    }\n}","impl WhirlpoolCore {\n    fn update_len(&mut self, len: u64) {\n        let mut carry = 0;\n        adc(&mut self.bit_len[3], len, &mut carry);\n        adc(&mut self.bit_len[2], 0, &mut carry);\n        adc(&mut self.bit_len[1], 0, &mut carry);\n        adc(&mut self.bit_len[0], 0, &mut carry);\n    }\n}","impl fmt::Debug for WhirlpoolCore {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"WhirlpoolCore { ... }\")\n    }\n}"]},"single_path_import":{"digest":"digest","digest::Digest":"Digest"},"srcs":{"<WhirlpoolCore as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n        Self {\n            bit_len: Default::default(),\n            state: [0u64; 8],\n        }\n    }","Real(LocalPath(\"whirlpool/src/lib.rs\"))"],"<WhirlpoolCore as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"WhirlpoolCore { ... }\")\n    }","Real(LocalPath(\"whirlpool/src/lib.rs\"))"],"<WhirlpoolCore as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n        *self = Default::default();\n    }","Real(LocalPath(\"whirlpool/src/lib.rs\"))"],"<WhirlpoolCore as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"Whirlpool\")\n    }","Real(LocalPath(\"whirlpool/src/lib.rs\"))"],"<WhirlpoolCore as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n        let pos = buffer.get_pos();\n        self.update_len(8 * pos as u64);\n\n        let mut buf = [0u8; 4 * 8];\n        for (chunk, v) in buf.chunks_exact_mut(8).zip(self.bit_len.iter()) {\n            chunk.copy_from_slice(&v.to_be_bytes());\n        }\n\n        let mut state = self.state;\n        buffer.digest_pad(0x80, &buf, |block| {\n            compress(&mut state, convert(core::slice::from_ref(block)));\n        });\n\n        for (chunk, v) in out.chunks_exact_mut(8).zip(state.iter()) {\n            chunk.copy_from_slice(&v.to_le_bytes());\n        }\n    }","Real(LocalPath(\"whirlpool/src/lib.rs\"))"],"<WhirlpoolCore as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n        let block_bits = 8 * BLOCK_SIZE as u64;\n        self.update_len(block_bits * (blocks.len() as u64));\n        compress(&mut self.state, convert(blocks));\n    }","Real(LocalPath(\"whirlpool/src/lib.rs\"))"],"WhirlpoolCore":["/// Core Whirlpool hasher state.\npub struct WhirlpoolCore {\n    bit_len: [u64; 4],\n    state: [u64; 8],\n}","Real(LocalPath(\"whirlpool/src/lib.rs\"))"],"WhirlpoolCore::update_len":["fn update_len(&mut self, len: u64){\n        let mut carry = 0;\n        adc(&mut self.bit_len[3], len, &mut carry);\n        adc(&mut self.bit_len[2], 0, &mut carry);\n        adc(&mut self.bit_len[1], 0, &mut carry);\n        adc(&mut self.bit_len[0], 0, &mut carry);\n    }","Real(LocalPath(\"whirlpool/src/lib.rs\"))"],"adc":["#[inline(always)]\nfn adc(a: &mut u64, b: u64, carry: &mut u64){\n    let ret = (*a as u128) + (b as u128) + (*carry as u128);\n    *a = ret as u64;\n    *carry = (ret >> 64) as u64;\n}","Real(LocalPath(\"whirlpool/src/lib.rs\"))"],"compress::compress":["pub(crate) fn compress(state: &mut [u64; 8], blocks: &[[u8; BLOCK_SIZE]]){\n    for block in blocks {\n        compress_block(state, block);\n    }\n}","Real(LocalPath(\"whirlpool/src/compress.rs\"))"],"compress::compress_block":["fn compress_block(state: &mut [u64; 8], b: &[u8; BLOCK_SIZE]){\n    let mut k = [0u64; 8];\n    let mut block = [0u64; 8];\n    let mut s = [0u64; 8];\n    let mut l = [0u64; 8];\n\n    for (o, chunk) in block.iter_mut().zip(b.chunks_exact(8)) {\n        *o = u64::from_le_bytes(chunk.try_into().unwrap());\n    }\n    k.copy_from_slice(state);\n\n    for i in 0..8 {\n        s[i] = block[i] ^ k[i];\n    }\n\n    #[allow(clippy::needless_range_loop)]\n    for r in 0..R {\n        for i in 0..8 {\n            l[i] = C0[(k[(i) % 8] & 0xff) as usize]\n                ^ C1[((k[(7 + i) % 8] >> 8) & 0xff) as usize]\n                ^ C2[((k[(6 + i) % 8] >> 16) & 0xff) as usize]\n                ^ C3[((k[(5 + i) % 8] >> 24) & 0xff) as usize]\n                ^ C4[((k[(4 + i) % 8] >> 32) & 0xff) as usize]\n                ^ C5[((k[(3 + i) % 8] >> 40) & 0xff) as usize]\n                ^ C6[((k[(2 + i) % 8] >> 48) & 0xff) as usize]\n                ^ C7[((k[(1 + i) % 8] >> 56) & 0xff) as usize]\n                ^ if i == 0 { RC[r] } else { 0 };\n        }\n        k = l;\n        for i in 0..8 {\n            l[i] = C0[(s[(i) % 8] & 0xff) as usize]\n                ^ C1[((s[(7 + i) % 8] >> 8) & 0xff) as usize]\n                ^ C2[((s[(6 + i) % 8] >> 16) & 0xff) as usize]\n                ^ C3[((s[(5 + i) % 8] >> 24) & 0xff) as usize]\n                ^ C4[((s[(4 + i) % 8] >> 32) & 0xff) as usize]\n                ^ C5[((s[(3 + i) % 8] >> 40) & 0xff) as usize]\n                ^ C6[((s[(2 + i) % 8] >> 48) & 0xff) as usize]\n                ^ C7[((s[(1 + i) % 8] >> 56) & 0xff) as usize]\n                ^ k[i];\n        }\n        s = l;\n    }\n\n    for i in 0..8 {\n        state[i] ^= s[i] ^ block[i];\n    }\n}","Real(LocalPath(\"whirlpool/src/compress.rs\"))"],"convert":["#[inline(always)]\nfn convert(blocks: &[Block<WhirlpoolCore>]) -> &[[u8; BLOCK_SIZE]]{\n    // SAFETY: GenericArray<u8, U64> and [u8; 64] have\n    // exactly the same memory layout\n    let p = blocks.as_ptr() as *const [u8; BLOCK_SIZE];\n    unsafe { core::slice::from_raw_parts(p, blocks.len()) }\n}","Real(LocalPath(\"whirlpool/src/lib.rs\"))"]},"struct_constructor":{"&[[u8; _]]":["convert"],"WhirlpoolCore":["clone","default"],"core::result::Result":["fmt","write_alg_name"]},"struct_to_trait":{"WhirlpoolCore":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"]},"targets":{"<WhirlpoolCore as core::default::Default>::default":["default","Real(LocalPath(\"whirlpool/src/lib.rs\"))","core::default::Default"],"<WhirlpoolCore as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"whirlpool/src/lib.rs\"))","core::fmt::Debug"],"<WhirlpoolCore as digest::Reset>::reset":["reset","Real(LocalPath(\"whirlpool/src/lib.rs\"))","digest::Reset"],"<WhirlpoolCore as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"whirlpool/src/lib.rs\"))","digest::core_api::AlgorithmName"],"<WhirlpoolCore as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"whirlpool/src/lib.rs\"))","digest::core_api::FixedOutputCore"],"<WhirlpoolCore as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"whirlpool/src/lib.rs\"))","digest::core_api::UpdateCore"],"WhirlpoolCore::update_len":["update_len","Real(LocalPath(\"whirlpool/src/lib.rs\"))",""],"adc":["adc","Real(LocalPath(\"whirlpool/src/lib.rs\"))",""],"compress::compress":["compress","Real(LocalPath(\"whirlpool/src/compress.rs\"))",""],"compress::compress_block":["compress_block","Real(LocalPath(\"whirlpool/src/compress.rs\"))",""],"convert":["convert","Real(LocalPath(\"whirlpool/src/lib.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["WhirlpoolCore"],"core::default::Default":["WhirlpoolCore"],"core::fmt::Debug":["WhirlpoolCore"],"digest::HashMarker":["WhirlpoolCore"],"digest::OutputSizeUser":["WhirlpoolCore"],"digest::Reset":["WhirlpoolCore"],"digest::core_api::AlgorithmName":["WhirlpoolCore"],"digest::core_api::BlockSizeUser":["WhirlpoolCore"],"digest::core_api::BufferKindUser":["WhirlpoolCore"],"digest::core_api::FixedOutputCore":["WhirlpoolCore"],"digest::core_api::UpdateCore":["WhirlpoolCore"]},"type_to_def_path":{"WhirlpoolCore":"WhirlpoolCore"}}