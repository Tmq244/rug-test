{"dependencies":{"<OidSha224 as core::clone::Clone>::clone":["OidSha224"],"<OidSha224 as core::cmp::Eq>::assert_receiver_is_total_eq":["OidSha224"],"<OidSha224 as core::cmp::PartialEq>::eq":["OidSha224"],"<OidSha224 as core::fmt::Debug>::fmt":["OidSha224","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<OidSha224 as core::hash::Hash>::hash":["OidSha224","core::hash::Hasher","core::marker::Sized"],"<OidSha256 as core::clone::Clone>::clone":["OidSha256"],"<OidSha256 as core::cmp::Eq>::assert_receiver_is_total_eq":["OidSha256"],"<OidSha256 as core::cmp::PartialEq>::eq":["OidSha256"],"<OidSha256 as core::fmt::Debug>::fmt":["OidSha256","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<OidSha256 as core::hash::Hash>::hash":["OidSha256","core::hash::Hasher","core::marker::Sized"],"<OidSha384 as core::clone::Clone>::clone":["OidSha384"],"<OidSha384 as core::cmp::Eq>::assert_receiver_is_total_eq":["OidSha384"],"<OidSha384 as core::cmp::PartialEq>::eq":["OidSha384"],"<OidSha384 as core::fmt::Debug>::fmt":["OidSha384","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<OidSha384 as core::hash::Hash>::hash":["OidSha384","core::hash::Hasher","core::marker::Sized"],"<OidSha512 as core::clone::Clone>::clone":["OidSha512"],"<OidSha512 as core::cmp::Eq>::assert_receiver_is_total_eq":["OidSha512"],"<OidSha512 as core::cmp::PartialEq>::eq":["OidSha512"],"<OidSha512 as core::fmt::Debug>::fmt":["OidSha512","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<OidSha512 as core::hash::Hash>::hash":["OidSha512","core::hash::Hasher","core::marker::Sized"],"<OidSha512_224 as core::clone::Clone>::clone":["OidSha512_224"],"<OidSha512_224 as core::cmp::Eq>::assert_receiver_is_total_eq":["OidSha512_224"],"<OidSha512_224 as core::cmp::PartialEq>::eq":["OidSha512_224"],"<OidSha512_224 as core::fmt::Debug>::fmt":["OidSha512_224","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<OidSha512_224 as core::hash::Hash>::hash":["OidSha512_224","core::hash::Hasher","core::marker::Sized"],"<OidSha512_256 as core::clone::Clone>::clone":["OidSha512_256"],"<OidSha512_256 as core::cmp::Eq>::assert_receiver_is_total_eq":["OidSha512_256"],"<OidSha512_256 as core::cmp::PartialEq>::eq":["OidSha512_256"],"<OidSha512_256 as core::fmt::Debug>::fmt":["OidSha512_256","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<OidSha512_256 as core::hash::Hash>::hash":["OidSha512_256","core::hash::Hasher","core::marker::Sized"],"<core_api::Sha256VarCore as core::clone::Clone>::clone":["core_api::Sha256VarCore"],"<core_api::Sha256VarCore as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","core_api::Sha256VarCore"],"<core_api::Sha256VarCore as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<core_api::Sha256VarCore as digest::core_api::UpdateCore>::update_blocks":["core::marker::Sized","core_api::Sha256VarCore","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"<core_api::Sha256VarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["core::marker::Sized","core_api::Sha256VarCore","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero"],"<core_api::Sha256VarCore as digest::core_api::VariableOutputCore>::new":["core::marker::Sized","core::result::Result"],"<core_api::Sha512VarCore as core::clone::Clone>::clone":["core_api::Sha512VarCore"],"<core_api::Sha512VarCore as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","core_api::Sha512VarCore"],"<core_api::Sha512VarCore as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<core_api::Sha512VarCore as digest::core_api::UpdateCore>::update_blocks":["core::marker::Sized","core_api::Sha512VarCore","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"<core_api::Sha512VarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["core::marker::Sized","core_api::Sha512VarCore","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero"],"<core_api::Sha512VarCore as digest::core_api::VariableOutputCore>::new":["core::marker::Sized","core::result::Result"],"<sha256::x86::shani_cpuid::InitToken as core::clone::Clone>::clone":["sha256::x86::shani_cpuid::InitToken"],"<sha256::x86::shani_cpuid::InitToken as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","sha256::x86::shani_cpuid::InitToken"],"<sha512::x86::avx2_cpuid::InitToken as core::clone::Clone>::clone":["sha512::x86::avx2_cpuid::InitToken"],"<sha512::x86::avx2_cpuid::InitToken as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","sha512::x86::avx2_cpuid::InitToken"],"OidSha224":["OidSha224"],"OidSha256":["OidSha256"],"OidSha384":["OidSha384"],"OidSha512":["OidSha512"],"OidSha512_224":["OidSha512_224"],"OidSha512_256":["OidSha512_256"],"core_api::Sha256VarCore":["core_api::Sha256VarCore"],"core_api::Sha512VarCore":["core_api::Sha512VarCore"],"sha256::compress256":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"sha256::soft::add":[],"sha256::soft::compress":[],"sha256::soft::or":[],"sha256::soft::schedule":[],"sha256::soft::sha256_digest_block_u32":[],"sha256::soft::sha256_digest_round_x2":[],"sha256::soft::sha256load":[],"sha256::soft::sha256msg1":[],"sha256::soft::sha256msg1::sigma0x4":[],"sha256::soft::sha256msg2":[],"sha256::soft::sha256swap":[],"sha256::soft::shl":[],"sha256::soft::shr":[],"sha256::soft::xor":[],"sha256::x86::compress":[],"sha256::x86::digest_blocks":[],"sha256::x86::schedule":["core::arch::x86_64::__m128i"],"sha256::x86::shani_cpuid::InitToken":["sha256::x86::shani_cpuid::InitToken"],"sha256::x86::shani_cpuid::InitToken::get":["sha256::x86::shani_cpuid::InitToken"],"sha256::x86::shani_cpuid::get":[],"sha256::x86::shani_cpuid::init":["sha256::x86::shani_cpuid::InitToken"],"sha256::x86::shani_cpuid::init_get":["sha256::x86::shani_cpuid::InitToken"],"sha256::x86::shani_cpuid::init_get::cpuid":["core::arch::x86_64::CpuidResult"],"sha256::x86::shani_cpuid::init_get::cpuid_count":["core::arch::x86_64::CpuidResult"],"sha512::compress512":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"sha512::soft::add":[],"sha512::soft::compress":[],"sha512::soft::sha512_digest_block_u64":[],"sha512::soft::sha512_digest_round":[],"sha512::soft::sha512_schedule_x2":[],"sha512::soft::sha512_schedule_x2::sigma0":[],"sha512::soft::sha512_schedule_x2::sigma1":[],"sha512::soft::sha512load":[],"sha512::x86::accumulate_state":[],"sha512::x86::avx2_cpuid::InitToken":["sha512::x86::avx2_cpuid::InitToken"],"sha512::x86::avx2_cpuid::InitToken::get":["sha512::x86::avx2_cpuid::InitToken"],"sha512::x86::avx2_cpuid::get":[],"sha512::x86::avx2_cpuid::init":["sha512::x86::avx2_cpuid::InitToken"],"sha512::x86::avx2_cpuid::init_get":["sha512::x86::avx2_cpuid::InitToken"],"sha512::x86::avx2_cpuid::init_get::cpuid":["core::arch::x86_64::CpuidResult"],"sha512::x86::avx2_cpuid::init_get::cpuid_count":["core::arch::x86_64::CpuidResult"],"sha512::x86::cast_ms":["core::arch::x86_64::__m128i"],"sha512::x86::cast_rs":["core::arch::x86_64::__m128i"],"sha512::x86::compress":[],"sha512::x86::load_data_avx":["core::arch::x86_64::__m128i"],"sha512::x86::load_data_avx2":["core::arch::x86_64::__m128i","core::arch::x86_64::__m256i"],"sha512::x86::process_second_block":["core::arch::x86_64::__m128i"],"sha512::x86::rounds_0_63_avx":["core::arch::x86_64::__m128i"],"sha512::x86::rounds_0_63_avx2":["core::arch::x86_64::__m128i","core::arch::x86_64::__m256i"],"sha512::x86::rounds_64_79":["core::arch::x86_64::__m128i"],"sha512::x86::sha512_compress_x86_64_avx":[],"sha512::x86::sha512_compress_x86_64_avx2":[],"sha512::x86::sha512_update_x_avx":["core::arch::x86_64::__m128i"],"sha512::x86::sha512_update_x_avx2":["core::arch::x86_64::__m256i"],"sha512::x86::sha_round":[]},"glob_path_import":{},"self_to_fn":{"OidSha224":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"OidSha256":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"OidSha384":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"OidSha512":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"OidSha512_224":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"OidSha512_256":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"core_api::Sha256VarCore":["Clone","impl AlgorithmName for Sha256VarCore {\n    #[inline]\n    fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"Sha256\")\n    }\n}","impl BlockSizeUser for Sha256VarCore {\n    type BlockSize = U64;\n}","impl BufferKindUser for Sha256VarCore {\n    type BufferKind = Eager;\n}","impl HashMarker for Sha256VarCore {}","impl OutputSizeUser for Sha256VarCore {\n    type OutputSize = U32;\n}","impl UpdateCore for Sha256VarCore {\n    #[inline]\n    fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n        self.block_len += blocks.len() as u64;\n        compress256(&mut self.state, blocks);\n    }\n}","impl VariableOutputCore for Sha256VarCore {\n    const TRUNC_SIDE: TruncSide = TruncSide::Left;\n\n    #[inline]\n    fn new(output_size: usize) -> Result<Self, InvalidOutputSize> {\n        let state = match output_size {\n            28 => consts::H256_224,\n            32 => consts::H256_256,\n            _ => return Err(InvalidOutputSize),\n        };\n        let block_len = 0;\n        Ok(Self { state, block_len })\n    }\n\n    #[inline]\n    fn finalize_variable_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n        let bs = Self::BlockSize::U64;\n        let bit_len = 8 * (buffer.get_pos() as u64 + bs * self.block_len);\n        buffer.len64_padding_be(bit_len, |b| compress256(&mut self.state, from_ref(b)));\n\n        for (chunk, v) in out.chunks_exact_mut(4).zip(self.state.iter()) {\n            chunk.copy_from_slice(&v.to_be_bytes());\n        }\n    }\n}","impl fmt::Debug for Sha256VarCore {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"Sha256VarCore { ... }\")\n    }\n}"],"core_api::Sha512VarCore":["Clone","impl AlgorithmName for Sha512VarCore {\n    #[inline]\n    fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"Sha512\")\n    }\n}","impl BlockSizeUser for Sha512VarCore {\n    type BlockSize = U128;\n}","impl BufferKindUser for Sha512VarCore {\n    type BufferKind = Eager;\n}","impl HashMarker for Sha512VarCore {}","impl OutputSizeUser for Sha512VarCore {\n    type OutputSize = U64;\n}","impl UpdateCore for Sha512VarCore {\n    #[inline]\n    fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n        self.block_len += blocks.len() as u128;\n        compress512(&mut self.state, blocks);\n    }\n}","impl VariableOutputCore for Sha512VarCore {\n    const TRUNC_SIDE: TruncSide = TruncSide::Left;\n\n    #[inline]\n    fn new(output_size: usize) -> Result<Self, InvalidOutputSize> {\n        let state = match output_size {\n            28 => consts::H512_224,\n            32 => consts::H512_256,\n            48 => consts::H512_384,\n            64 => consts::H512_512,\n            _ => return Err(InvalidOutputSize),\n        };\n        let block_len = 0;\n        Ok(Self { state, block_len })\n    }\n\n    #[inline]\n    fn finalize_variable_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n        let bs = Self::BlockSize::U64 as u128;\n        let bit_len = 8 * (buffer.get_pos() as u128 + bs * self.block_len);\n        buffer.len128_padding_be(bit_len, |b| compress512(&mut self.state, from_ref(b)));\n\n        for (chunk, v) in out.chunks_exact_mut(8).zip(self.state.iter()) {\n            chunk.copy_from_slice(&v.to_be_bytes());\n        }\n    }\n}","impl fmt::Debug for Sha512VarCore {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"Sha512VarCore { ... }\")\n    }\n}"],"sha256::x86::shani_cpuid::InitToken":["Clone","Copy","Debug","impl InitToken {\n                /// Get initialized value\n                #[inline(always)]\n                pub fn get(&self) -> bool {\n                    $crate::__unless_target_features! {\n                        $($tf),+ => {\n                            STORAGE.load(Relaxed) == 1\n                        }\n                    }\n                }\n            }"],"sha512::x86::avx2_cpuid::InitToken":["Clone","Copy","Debug","impl InitToken {\n                /// Get initialized value\n                #[inline(always)]\n                pub fn get(&self) -> bool {\n                    $crate::__unless_target_features! {\n                        $($tf),+ => {\n                            STORAGE.load(Relaxed) == 1\n                        }\n                    }\n                }\n            }"]},"single_path_import":{"core_api::Sha256VarCore":"Sha256VarCore","core_api::Sha512VarCore":"Sha512VarCore","digest":"digest","digest::Digest":"Digest"},"srcs":{"<core_api::Sha256VarCore as core::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"Sha256VarCore { ... }\")\n    }","Real(LocalPath(\"sha2/src/core_api.rs\"))"],"<core_api::Sha256VarCore as digest::core_api::AlgorithmName>::write_alg_name":["#[inline]\nfn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"Sha256\")\n    }","Real(LocalPath(\"sha2/src/core_api.rs\"))"],"<core_api::Sha256VarCore as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n        self.block_len += blocks.len() as u64;\n        compress256(&mut self.state, blocks);\n    }","Real(LocalPath(\"sha2/src/core_api.rs\"))"],"<core_api::Sha256VarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["#[inline]\nfn finalize_variable_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n        let bs = Self::BlockSize::U64;\n        let bit_len = 8 * (buffer.get_pos() as u64 + bs * self.block_len);\n        buffer.len64_padding_be(bit_len, |b| compress256(&mut self.state, from_ref(b)));\n\n        for (chunk, v) in out.chunks_exact_mut(4).zip(self.state.iter()) {\n            chunk.copy_from_slice(&v.to_be_bytes());\n        }\n    }","Real(LocalPath(\"sha2/src/core_api.rs\"))"],"<core_api::Sha256VarCore as digest::core_api::VariableOutputCore>::new":["#[inline]\nfn new(output_size: usize) -> Result<Self, InvalidOutputSize>{\n        let state = match output_size {\n            28 => consts::H256_224,\n            32 => consts::H256_256,\n            _ => return Err(InvalidOutputSize),\n        };\n        let block_len = 0;\n        Ok(Self { state, block_len })\n    }","Real(LocalPath(\"sha2/src/core_api.rs\"))"],"<core_api::Sha512VarCore as core::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"Sha512VarCore { ... }\")\n    }","Real(LocalPath(\"sha2/src/core_api.rs\"))"],"<core_api::Sha512VarCore as digest::core_api::AlgorithmName>::write_alg_name":["#[inline]\nfn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"Sha512\")\n    }","Real(LocalPath(\"sha2/src/core_api.rs\"))"],"<core_api::Sha512VarCore as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n        self.block_len += blocks.len() as u128;\n        compress512(&mut self.state, blocks);\n    }","Real(LocalPath(\"sha2/src/core_api.rs\"))"],"<core_api::Sha512VarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["#[inline]\nfn finalize_variable_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n        let bs = Self::BlockSize::U64 as u128;\n        let bit_len = 8 * (buffer.get_pos() as u128 + bs * self.block_len);\n        buffer.len128_padding_be(bit_len, |b| compress512(&mut self.state, from_ref(b)));\n\n        for (chunk, v) in out.chunks_exact_mut(8).zip(self.state.iter()) {\n            chunk.copy_from_slice(&v.to_be_bytes());\n        }\n    }","Real(LocalPath(\"sha2/src/core_api.rs\"))"],"<core_api::Sha512VarCore as digest::core_api::VariableOutputCore>::new":["#[inline]\nfn new(output_size: usize) -> Result<Self, InvalidOutputSize>{\n        let state = match output_size {\n            28 => consts::H512_224,\n            32 => consts::H512_256,\n            48 => consts::H512_384,\n            64 => consts::H512_512,\n            _ => return Err(InvalidOutputSize),\n        };\n        let block_len = 0;\n        Ok(Self { state, block_len })\n    }","Real(LocalPath(\"sha2/src/core_api.rs\"))"],"OidSha224":["#[doc(hidden)]\npub struct $name;","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/digest-0.10.7/src/core_api/ct_variable.rs\"))"],"OidSha256":["#[doc(hidden)]\npub struct $name;","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/digest-0.10.7/src/core_api/ct_variable.rs\"))"],"OidSha384":["#[doc(hidden)]\npub struct $name;","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/digest-0.10.7/src/core_api/ct_variable.rs\"))"],"OidSha512":["#[doc(hidden)]\npub struct $name;","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/digest-0.10.7/src/core_api/ct_variable.rs\"))"],"OidSha512_224":["#[doc(hidden)]\npub struct $name;","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/digest-0.10.7/src/core_api/ct_variable.rs\"))"],"OidSha512_256":["#[doc(hidden)]\npub struct $name;","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/digest-0.10.7/src/core_api/ct_variable.rs\"))"],"core_api::Sha256VarCore":["/// Core block-level SHA-256 hasher with variable output size.\n///\n/// Supports initialization only for 28 and 32 byte output sizes,\n/// i.e. 224 and 256 bits respectively.\npub struct Sha256VarCore {\n    state: consts::State256,\n    block_len: u64,\n}","Real(LocalPath(\"sha2/src/core_api.rs\"))"],"core_api::Sha512VarCore":["/// Core block-level SHA-512 hasher with variable output size.\n///\n/// Supports initialization only for 28, 32, 48, and 64 byte output sizes,\n/// i.e. 224, 256, 384, and 512 bits respectively.\npub struct Sha512VarCore {\n    state: consts::State512,\n    block_len: u128,\n}","Real(LocalPath(\"sha2/src/core_api.rs\"))"],"sha256::compress256":["/// Raw SHA-256 compression function.\n///\n/// This is a low-level \"hazmat\" API which provides direct access to the core\n/// functionality of SHA-256.\npub fn compress256(state: &mut [u32; 8], blocks: &[GenericArray<u8, U64>]){\n    // SAFETY: GenericArray<u8, U64> and [u8; 64] have\n    // exactly the same memory layout\n    let p = blocks.as_ptr() as *const [u8; 64];\n    let blocks = unsafe { core::slice::from_raw_parts(p, blocks.len()) };\n    compress(state, blocks)\n}","Real(LocalPath(\"sha2/src/sha256.rs\"))"],"sha256::soft::add":["#[inline(always)]\nfn add(a: [u32; 4], b: [u32; 4]) -> [u32; 4]{\n    [\n        a[0].wrapping_add(b[0]),\n        a[1].wrapping_add(b[1]),\n        a[2].wrapping_add(b[2]),\n        a[3].wrapping_add(b[3]),\n    ]\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::compress":["pub fn compress(state: &mut [u32; 8], blocks: &[[u8; 64]]){\n    let mut block_u32 = [0u32; BLOCK_LEN];\n    // since LLVM can't properly use aliasing yet it will make\n    // unnecessary state stores without this copy\n    let mut state_cpy = *state;\n    for block in blocks {\n        for (o, chunk) in block_u32.iter_mut().zip(block.chunks_exact(4)) {\n            *o = u32::from_be_bytes(chunk.try_into().unwrap());\n        }\n        sha256_digest_block_u32(&mut state_cpy, &block_u32);\n    }\n    *state = state_cpy;\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::or":["#[inline(always)]\nfn or(a: [u32; 4], b: [u32; 4]) -> [u32; 4]{\n    [a[0] | b[0], a[1] | b[1], a[2] | b[2], a[3] | b[3]]\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::schedule":["fn schedule(v0: [u32; 4], v1: [u32; 4], v2: [u32; 4], v3: [u32; 4]) -> [u32; 4]{\n    let t1 = sha256msg1(v0, v1);\n    let t2 = sha256load(v2, v3);\n    let t3 = add(t1, t2);\n    sha256msg2(t3, v3)\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::sha256_digest_block_u32":["/// Process a block with the SHA-256 algorithm.\nfn sha256_digest_block_u32(state: &mut [u32; 8], block: &[u32; 16]){\n    let mut abef = [state[0], state[1], state[4], state[5]];\n    let mut cdgh = [state[2], state[3], state[6], state[7]];\n\n    // Rounds 0..64\n    let mut w0 = [block[3], block[2], block[1], block[0]];\n    let mut w1 = [block[7], block[6], block[5], block[4]];\n    let mut w2 = [block[11], block[10], block[9], block[8]];\n    let mut w3 = [block[15], block[14], block[13], block[12]];\n    let mut w4;\n\n    rounds4!(abef, cdgh, w0, 0);\n    rounds4!(abef, cdgh, w1, 1);\n    rounds4!(abef, cdgh, w2, 2);\n    rounds4!(abef, cdgh, w3, 3);\n    schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 4);\n    schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 5);\n    schedule_rounds4!(abef, cdgh, w2, w3, w4, w0, w1, 6);\n    schedule_rounds4!(abef, cdgh, w3, w4, w0, w1, w2, 7);\n    schedule_rounds4!(abef, cdgh, w4, w0, w1, w2, w3, 8);\n    schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 9);\n    schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 10);\n    schedule_rounds4!(abef, cdgh, w2, w3, w4, w0, w1, 11);\n    schedule_rounds4!(abef, cdgh, w3, w4, w0, w1, w2, 12);\n    schedule_rounds4!(abef, cdgh, w4, w0, w1, w2, w3, 13);\n    schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 14);\n    schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 15);\n\n    let [a, b, e, f] = abef;\n    let [c, d, g, h] = cdgh;\n\n    state[0] = state[0].wrapping_add(a);\n    state[1] = state[1].wrapping_add(b);\n    state[2] = state[2].wrapping_add(c);\n    state[3] = state[3].wrapping_add(d);\n    state[4] = state[4].wrapping_add(e);\n    state[5] = state[5].wrapping_add(f);\n    state[6] = state[6].wrapping_add(g);\n    state[7] = state[7].wrapping_add(h);\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::sha256_digest_round_x2":["fn sha256_digest_round_x2(cdgh: [u32; 4], abef: [u32; 4], wk: [u32; 4]) -> [u32; 4]{\n    macro_rules! big_sigma0 {\n        ($a:expr) => {\n            ($a.rotate_right(2) ^ $a.rotate_right(13) ^ $a.rotate_right(22))\n        };\n    }\n    macro_rules! big_sigma1 {\n        ($a:expr) => {\n            ($a.rotate_right(6) ^ $a.rotate_right(11) ^ $a.rotate_right(25))\n        };\n    }\n    macro_rules! bool3ary_202 {\n        ($a:expr, $b:expr, $c:expr) => {\n            $c ^ ($a & ($b ^ $c))\n        };\n    } // Choose, MD5F, SHA1C\n    macro_rules! bool3ary_232 {\n        ($a:expr, $b:expr, $c:expr) => {\n            ($a & $b) ^ ($a & $c) ^ ($b & $c)\n        };\n    } // Majority, SHA1M\n\n    let [_, _, wk1, wk0] = wk;\n    let [a0, b0, e0, f0] = abef;\n    let [c0, d0, g0, h0] = cdgh;\n\n    // a round\n    let x0 = big_sigma1!(e0)\n        .wrapping_add(bool3ary_202!(e0, f0, g0))\n        .wrapping_add(wk0)\n        .wrapping_add(h0);\n    let y0 = big_sigma0!(a0).wrapping_add(bool3ary_232!(a0, b0, c0));\n    let (a1, b1, c1, d1, e1, f1, g1, h1) = (\n        x0.wrapping_add(y0),\n        a0,\n        b0,\n        c0,\n        x0.wrapping_add(d0),\n        e0,\n        f0,\n        g0,\n    );\n\n    // a round\n    let x1 = big_sigma1!(e1)\n        .wrapping_add(bool3ary_202!(e1, f1, g1))\n        .wrapping_add(wk1)\n        .wrapping_add(h1);\n    let y1 = big_sigma0!(a1).wrapping_add(bool3ary_232!(a1, b1, c1));\n    let (a2, b2, _, _, e2, f2, _, _) = (\n        x1.wrapping_add(y1),\n        a1,\n        b1,\n        c1,\n        x1.wrapping_add(d1),\n        e1,\n        f1,\n        g1,\n    );\n\n    [a2, b2, e2, f2]\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::sha256load":["fn sha256load(v2: [u32; 4], v3: [u32; 4]) -> [u32; 4]{\n    [v3[3], v2[0], v2[1], v2[2]]\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::sha256msg1":["fn sha256msg1(v0: [u32; 4], v1: [u32; 4]) -> [u32; 4]{\n    // sigma 0 on vectors\n    #[inline]\n    fn sigma0x4(x: [u32; 4]) -> [u32; 4] {\n        let t1 = or(shl(x, 7), shr(x, 25));\n        let t2 = or(shl(x, 18), shr(x, 14));\n        let t3 = shl(x, 3);\n        xor(xor(t1, t2), t3)\n    }\n\n    add(v0, sigma0x4(sha256load(v0, v1)))\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::sha256msg1::sigma0x4":["#[inline]\nfn sigma0x4(x: [u32; 4]) -> [u32; 4]{\n        let t1 = or(shl(x, 7), shr(x, 25));\n        let t2 = or(shl(x, 18), shr(x, 14));\n        let t3 = shl(x, 3);\n        xor(xor(t1, t2), t3)\n    }","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::sha256msg2":["fn sha256msg2(v4: [u32; 4], v3: [u32; 4]) -> [u32; 4]{\n    macro_rules! sigma1 {\n        ($a:expr) => {\n            $a.rotate_right(17) ^ $a.rotate_right(19) ^ ($a >> 10)\n        };\n    }\n\n    let [x3, x2, x1, x0] = v4;\n    let [w15, w14, _, _] = v3;\n\n    let w16 = x0.wrapping_add(sigma1!(w14));\n    let w17 = x1.wrapping_add(sigma1!(w15));\n    let w18 = x2.wrapping_add(sigma1!(w16));\n    let w19 = x3.wrapping_add(sigma1!(w17));\n\n    [w19, w18, w17, w16]\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::sha256swap":["fn sha256swap(v0: [u32; 4]) -> [u32; 4]{\n    [v0[2], v0[3], v0[0], v0[1]]\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::shl":["#[inline(always)]\nfn shl(v: [u32; 4], o: u32) -> [u32; 4]{\n    [v[0] >> o, v[1] >> o, v[2] >> o, v[3] >> o]\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::shr":["#[inline(always)]\nfn shr(v: [u32; 4], o: u32) -> [u32; 4]{\n    [v[0] << o, v[1] << o, v[2] << o, v[3] << o]\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::soft::xor":["#[inline(always)]\nfn xor(a: [u32; 4], b: [u32; 4]) -> [u32; 4]{\n    [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]\n}","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))"],"sha256::x86::compress":["pub fn compress(state: &mut [u32; 8], blocks: &[[u8; 64]]){\n    // TODO: Replace with https://github.com/rust-lang/rfcs/pull/2725\n    // after stabilization\n    if shani_cpuid::get() {\n        unsafe {\n            digest_blocks(state, blocks);\n        }\n    } else {\n        super::soft::compress(state, blocks);\n    }\n}","Real(LocalPath(\"sha2/src/sha256/x86.rs\"))"],"sha256::x86::digest_blocks":["#[allow(clippy::cast_ptr_alignment)]\n#[target_feature(enable = \"sha,sse2,ssse3,sse4.1\")]\nunsafe fn digest_blocks(state: &mut [u32; 8], blocks: &[[u8; 64]]){\n    #[allow(non_snake_case)]\n    let MASK: __m128i = _mm_set_epi64x(\n        0x0C0D_0E0F_0809_0A0Bu64 as i64,\n        0x0405_0607_0001_0203u64 as i64,\n    );\n\n    let state_ptr = state.as_ptr() as *const __m128i;\n    let dcba = _mm_loadu_si128(state_ptr.add(0));\n    let efgh = _mm_loadu_si128(state_ptr.add(1));\n\n    let cdab = _mm_shuffle_epi32(dcba, 0xB1);\n    let efgh = _mm_shuffle_epi32(efgh, 0x1B);\n    let mut abef = _mm_alignr_epi8(cdab, efgh, 8);\n    let mut cdgh = _mm_blend_epi16(efgh, cdab, 0xF0);\n\n    for block in blocks {\n        let abef_save = abef;\n        let cdgh_save = cdgh;\n\n        let data_ptr = block.as_ptr() as *const __m128i;\n        let mut w0 = _mm_shuffle_epi8(_mm_loadu_si128(data_ptr.add(0)), MASK);\n        let mut w1 = _mm_shuffle_epi8(_mm_loadu_si128(data_ptr.add(1)), MASK);\n        let mut w2 = _mm_shuffle_epi8(_mm_loadu_si128(data_ptr.add(2)), MASK);\n        let mut w3 = _mm_shuffle_epi8(_mm_loadu_si128(data_ptr.add(3)), MASK);\n        let mut w4;\n\n        rounds4!(abef, cdgh, w0, 0);\n        rounds4!(abef, cdgh, w1, 1);\n        rounds4!(abef, cdgh, w2, 2);\n        rounds4!(abef, cdgh, w3, 3);\n        schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 4);\n        schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 5);\n        schedule_rounds4!(abef, cdgh, w2, w3, w4, w0, w1, 6);\n        schedule_rounds4!(abef, cdgh, w3, w4, w0, w1, w2, 7);\n        schedule_rounds4!(abef, cdgh, w4, w0, w1, w2, w3, 8);\n        schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 9);\n        schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 10);\n        schedule_rounds4!(abef, cdgh, w2, w3, w4, w0, w1, 11);\n        schedule_rounds4!(abef, cdgh, w3, w4, w0, w1, w2, 12);\n        schedule_rounds4!(abef, cdgh, w4, w0, w1, w2, w3, 13);\n        schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 14);\n        schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 15);\n\n        abef = _mm_add_epi32(abef, abef_save);\n        cdgh = _mm_add_epi32(cdgh, cdgh_save);\n    }\n\n    let feba = _mm_shuffle_epi32(abef, 0x1B);\n    let dchg = _mm_shuffle_epi32(cdgh, 0xB1);\n    let dcba = _mm_blend_epi16(feba, dchg, 0xF0);\n    let hgef = _mm_alignr_epi8(dchg, feba, 8);\n\n    let state_ptr_mut = state.as_mut_ptr() as *mut __m128i;\n    _mm_storeu_si128(state_ptr_mut.add(0), dcba);\n    _mm_storeu_si128(state_ptr_mut.add(1), hgef);\n}","Real(LocalPath(\"sha2/src/sha256/x86.rs\"))"],"sha256::x86::schedule":["unsafe fn schedule(v0: __m128i, v1: __m128i, v2: __m128i, v3: __m128i) -> __m128i{\n    let t1 = _mm_sha256msg1_epu32(v0, v1);\n    let t2 = _mm_alignr_epi8(v3, v2, 4);\n    let t3 = _mm_add_epi32(t1, t2);\n    _mm_sha256msg2_epu32(t3, v3)\n}","Real(LocalPath(\"sha2/src/sha256/x86.rs\"))"],"sha256::x86::shani_cpuid::InitToken":["/// Initialization token\npub struct InitToken(());","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"sha256::x86::shani_cpuid::InitToken::get":["/// Get initialized value\n#[inline(always)]\npub fn get(&self) -> bool{\n                    $crate::__unless_target_features! {\n                        $($tf),+ => {\n                            STORAGE.load(Relaxed) == 1\n                        }\n                    }\n                }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"sha256::x86::shani_cpuid::get":["/// Initialize underlying storage if needed and get\n/// stored value.\n#[inline]\npub fn get() -> bool{\n                init_get().1\n            }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"sha256::x86::shani_cpuid::init":["/// Initialize underlying storage if needed and get\n/// initialization token.\n#[inline]\npub fn init() -> InitToken{\n                init_get().0\n            }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"sha256::x86::shani_cpuid::init_get":["/// Initialize underlying storage if needed and get\n/// stored value and initialization token.\n#[inline]\npub fn init_get() -> (InitToken, bool){\n                let res = $crate::__unless_target_features! {\n                    $($tf),+ => {\n                        // Relaxed ordering is fine, as we only have a single atomic variable.\n                        let val = STORAGE.load(Relaxed);\n\n                        if val == UNINIT {\n                            let res = $crate::__detect_target_features!($($tf),+);\n                            STORAGE.store(res as u8, Relaxed);\n                            res\n                        } else {\n                            val == 1\n                        }\n                    }\n                };\n\n                (InitToken(()), res)\n            }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"sha256::x86::shani_cpuid::init_get::cpuid":["#[inline(never)]\nunsafe fn cpuid(leaf: u32) -> CpuidResult{\n            __cpuid(leaf)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/x86.rs\"))"],"sha256::x86::shani_cpuid::init_get::cpuid_count":["#[inline(never)]\nunsafe fn cpuid_count(leaf: u32, sub_leaf: u32) -> CpuidResult{\n            __cpuid_count(leaf, sub_leaf)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/x86.rs\"))"],"sha512::compress512":["/// Raw SHA-512 compression function.\n///\n/// This is a low-level \"hazmat\" API which provides direct access to the core\n/// functionality of SHA-512.\npub fn compress512(state: &mut [u64; 8], blocks: &[GenericArray<u8, U128>]){\n    // SAFETY: GenericArray<u8, U64> and [u8; 64] have\n    // exactly the same memory layout\n    let p = blocks.as_ptr() as *const [u8; 128];\n    let blocks = unsafe { core::slice::from_raw_parts(p, blocks.len()) };\n    compress(state, blocks)\n}","Real(LocalPath(\"sha2/src/sha512.rs\"))"],"sha512::soft::add":["fn add(a: [u64; 2], b: [u64; 2]) -> [u64; 2]{\n    [a[0].wrapping_add(b[0]), a[1].wrapping_add(b[1])]\n}","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))"],"sha512::soft::compress":["pub fn compress(state: &mut [u64; 8], blocks: &[[u8; 128]]){\n    let mut block_u32 = [0u64; BLOCK_LEN];\n    // since LLVM can't properly use aliasing yet it will make\n    // unnecessary state stores without this copy\n    let mut state_cpy = *state;\n    for block in blocks {\n        for (o, chunk) in block_u32.iter_mut().zip(block.chunks_exact(8)) {\n            *o = u64::from_be_bytes(chunk.try_into().unwrap());\n        }\n        sha512_digest_block_u64(&mut state_cpy, &block_u32);\n    }\n    *state = state_cpy;\n}","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))"],"sha512::soft::sha512_digest_block_u64":["/// Process a block with the SHA-512 algorithm.\npub fn sha512_digest_block_u64(state: &mut [u64; 8], block: &[u64; 16]){\n    let k = &K64X2;\n\n    macro_rules! schedule {\n        ($v0:expr, $v1:expr, $v4:expr, $v5:expr, $v7:expr) => {\n            sha512_schedule_x2($v0, $v1, sha512load($v4, $v5), $v7)\n        };\n    }\n\n    macro_rules! rounds4 {\n        ($ae:ident, $bf:ident, $cg:ident, $dh:ident, $wk0:expr, $wk1:expr) => {{\n            let [u, t] = $wk0;\n            let [w, v] = $wk1;\n\n            $dh = sha512_digest_round($ae, $bf, $cg, $dh, t);\n            $cg = sha512_digest_round($dh, $ae, $bf, $cg, u);\n            $bf = sha512_digest_round($cg, $dh, $ae, $bf, v);\n            $ae = sha512_digest_round($bf, $cg, $dh, $ae, w);\n        }};\n    }\n\n    let mut ae = [state[0], state[4]];\n    let mut bf = [state[1], state[5]];\n    let mut cg = [state[2], state[6]];\n    let mut dh = [state[3], state[7]];\n\n    // Rounds 0..20\n    let (mut w1, mut w0) = ([block[3], block[2]], [block[1], block[0]]);\n    rounds4!(ae, bf, cg, dh, add(k[0], w0), add(k[1], w1));\n    let (mut w3, mut w2) = ([block[7], block[6]], [block[5], block[4]]);\n    rounds4!(ae, bf, cg, dh, add(k[2], w2), add(k[3], w3));\n    let (mut w5, mut w4) = ([block[11], block[10]], [block[9], block[8]]);\n    rounds4!(ae, bf, cg, dh, add(k[4], w4), add(k[5], w5));\n    let (mut w7, mut w6) = ([block[15], block[14]], [block[13], block[12]]);\n    rounds4!(ae, bf, cg, dh, add(k[6], w6), add(k[7], w7));\n    let mut w8 = schedule!(w0, w1, w4, w5, w7);\n    let mut w9 = schedule!(w1, w2, w5, w6, w8);\n    rounds4!(ae, bf, cg, dh, add(k[8], w8), add(k[9], w9));\n\n    // Rounds 20..40\n    w0 = schedule!(w2, w3, w6, w7, w9);\n    w1 = schedule!(w3, w4, w7, w8, w0);\n    rounds4!(ae, bf, cg, dh, add(k[10], w0), add(k[11], w1));\n    w2 = schedule!(w4, w5, w8, w9, w1);\n    w3 = schedule!(w5, w6, w9, w0, w2);\n    rounds4!(ae, bf, cg, dh, add(k[12], w2), add(k[13], w3));\n    w4 = schedule!(w6, w7, w0, w1, w3);\n    w5 = schedule!(w7, w8, w1, w2, w4);\n    rounds4!(ae, bf, cg, dh, add(k[14], w4), add(k[15], w5));\n    w6 = schedule!(w8, w9, w2, w3, w5);\n    w7 = schedule!(w9, w0, w3, w4, w6);\n    rounds4!(ae, bf, cg, dh, add(k[16], w6), add(k[17], w7));\n    w8 = schedule!(w0, w1, w4, w5, w7);\n    w9 = schedule!(w1, w2, w5, w6, w8);\n    rounds4!(ae, bf, cg, dh, add(k[18], w8), add(k[19], w9));\n\n    // Rounds 40..60\n    w0 = schedule!(w2, w3, w6, w7, w9);\n    w1 = schedule!(w3, w4, w7, w8, w0);\n    rounds4!(ae, bf, cg, dh, add(k[20], w0), add(k[21], w1));\n    w2 = schedule!(w4, w5, w8, w9, w1);\n    w3 = schedule!(w5, w6, w9, w0, w2);\n    rounds4!(ae, bf, cg, dh, add(k[22], w2), add(k[23], w3));\n    w4 = schedule!(w6, w7, w0, w1, w3);\n    w5 = schedule!(w7, w8, w1, w2, w4);\n    rounds4!(ae, bf, cg, dh, add(k[24], w4), add(k[25], w5));\n    w6 = schedule!(w8, w9, w2, w3, w5);\n    w7 = schedule!(w9, w0, w3, w4, w6);\n    rounds4!(ae, bf, cg, dh, add(k[26], w6), add(k[27], w7));\n    w8 = schedule!(w0, w1, w4, w5, w7);\n    w9 = schedule!(w1, w2, w5, w6, w8);\n    rounds4!(ae, bf, cg, dh, add(k[28], w8), add(k[29], w9));\n\n    // Rounds 60..80\n    w0 = schedule!(w2, w3, w6, w7, w9);\n    w1 = schedule!(w3, w4, w7, w8, w0);\n    rounds4!(ae, bf, cg, dh, add(k[30], w0), add(k[31], w1));\n    w2 = schedule!(w4, w5, w8, w9, w1);\n    w3 = schedule!(w5, w6, w9, w0, w2);\n    rounds4!(ae, bf, cg, dh, add(k[32], w2), add(k[33], w3));\n    w4 = schedule!(w6, w7, w0, w1, w3);\n    w5 = schedule!(w7, w8, w1, w2, w4);\n    rounds4!(ae, bf, cg, dh, add(k[34], w4), add(k[35], w5));\n    w6 = schedule!(w8, w9, w2, w3, w5);\n    w7 = schedule!(w9, w0, w3, w4, w6);\n    rounds4!(ae, bf, cg, dh, add(k[36], w6), add(k[37], w7));\n    w8 = schedule!(w0, w1, w4, w5, w7);\n    w9 = schedule!(w1, w2, w5, w6, w8);\n    rounds4!(ae, bf, cg, dh, add(k[38], w8), add(k[39], w9));\n\n    let [a, e] = ae;\n    let [b, f] = bf;\n    let [c, g] = cg;\n    let [d, h] = dh;\n\n    state[0] = state[0].wrapping_add(a);\n    state[1] = state[1].wrapping_add(b);\n    state[2] = state[2].wrapping_add(c);\n    state[3] = state[3].wrapping_add(d);\n    state[4] = state[4].wrapping_add(e);\n    state[5] = state[5].wrapping_add(f);\n    state[6] = state[6].wrapping_add(g);\n    state[7] = state[7].wrapping_add(h);\n}","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))"],"sha512::soft::sha512_digest_round":["/// Performs one round of the SHA-512 message block digest.\npub fn sha512_digest_round(\n    ae: [u64; 2],\n    bf: [u64; 2],\n    cg: [u64; 2],\n    dh: [u64; 2],\n    wk0: u64,\n) -> [u64; 2]{\n    macro_rules! big_sigma0 {\n        ($a:expr) => {\n            ($a.rotate_right(28) ^ $a.rotate_right(34) ^ $a.rotate_right(39))\n        };\n    }\n    macro_rules! big_sigma1 {\n        ($a:expr) => {\n            ($a.rotate_right(14) ^ $a.rotate_right(18) ^ $a.rotate_right(41))\n        };\n    }\n    macro_rules! bool3ary_202 {\n        ($a:expr, $b:expr, $c:expr) => {\n            $c ^ ($a & ($b ^ $c))\n        };\n    } // Choose, MD5F, SHA1C\n    macro_rules! bool3ary_232 {\n        ($a:expr, $b:expr, $c:expr) => {\n            ($a & $b) ^ ($a & $c) ^ ($b & $c)\n        };\n    } // Majority, SHA1M\n\n    let [a0, e0] = ae;\n    let [b0, f0] = bf;\n    let [c0, g0] = cg;\n    let [d0, h0] = dh;\n\n    // a round\n    let x0 = big_sigma1!(e0)\n        .wrapping_add(bool3ary_202!(e0, f0, g0))\n        .wrapping_add(wk0)\n        .wrapping_add(h0);\n    let y0 = big_sigma0!(a0).wrapping_add(bool3ary_232!(a0, b0, c0));\n    let (a1, _, _, _, e1, _, _, _) = (\n        x0.wrapping_add(y0),\n        a0,\n        b0,\n        c0,\n        x0.wrapping_add(d0),\n        e0,\n        f0,\n        g0,\n    );\n\n    [a1, e1]\n}","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))"],"sha512::soft::sha512_schedule_x2":["/// Performs 2 rounds of the SHA-512 message schedule update.\npub fn sha512_schedule_x2(v0: [u64; 2], v1: [u64; 2], v4to5: [u64; 2], v7: [u64; 2]) -> [u64; 2]{\n    // sigma 0\n    fn sigma0(x: u64) -> u64 {\n        ((x << 63) | (x >> 1)) ^ ((x << 56) | (x >> 8)) ^ (x >> 7)\n    }\n\n    // sigma 1\n    fn sigma1(x: u64) -> u64 {\n        ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6)\n    }\n\n    let [w1, w0] = v0;\n    let [_, w2] = v1;\n    let [w10, w9] = v4to5;\n    let [w15, w14] = v7;\n\n    let w16 = sigma1(w14)\n        .wrapping_add(w9)\n        .wrapping_add(sigma0(w1))\n        .wrapping_add(w0);\n    let w17 = sigma1(w15)\n        .wrapping_add(w10)\n        .wrapping_add(sigma0(w2))\n        .wrapping_add(w1);\n\n    [w17, w16]\n}","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))"],"sha512::soft::sha512_schedule_x2::sigma0":["fn sigma0(x: u64) -> u64{\n        ((x << 63) | (x >> 1)) ^ ((x << 56) | (x >> 8)) ^ (x >> 7)\n    }","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))"],"sha512::soft::sha512_schedule_x2::sigma1":["fn sigma1(x: u64) -> u64{\n        ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6)\n    }","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))"],"sha512::soft::sha512load":["/// Not an intrinsic, but works like an unaligned load.\nfn sha512load(v0: [u64; 2], v1: [u64; 2]) -> [u64; 2]{\n    [v1[1], v0[0]]\n}","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))"],"sha512::x86::accumulate_state":["#[inline(always)]\nfn accumulate_state(dst: &mut State, src: &State){\n    for i in 0..SHA512_HASH_WORDS_NUM {\n        dst[i] = dst[i].wrapping_add(src[i]);\n    }\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::avx2_cpuid::InitToken":["/// Initialization token\npub struct InitToken(());","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"sha512::x86::avx2_cpuid::InitToken::get":["/// Get initialized value\n#[inline(always)]\npub fn get(&self) -> bool{\n                    $crate::__unless_target_features! {\n                        $($tf),+ => {\n                            STORAGE.load(Relaxed) == 1\n                        }\n                    }\n                }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"sha512::x86::avx2_cpuid::get":["/// Initialize underlying storage if needed and get\n/// stored value.\n#[inline]\npub fn get() -> bool{\n                init_get().1\n            }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"sha512::x86::avx2_cpuid::init":["/// Initialize underlying storage if needed and get\n/// initialization token.\n#[inline]\npub fn init() -> InitToken{\n                init_get().0\n            }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"sha512::x86::avx2_cpuid::init_get":["/// Initialize underlying storage if needed and get\n/// stored value and initialization token.\n#[inline]\npub fn init_get() -> (InitToken, bool){\n                let res = $crate::__unless_target_features! {\n                    $($tf),+ => {\n                        // Relaxed ordering is fine, as we only have a single atomic variable.\n                        let val = STORAGE.load(Relaxed);\n\n                        if val == UNINIT {\n                            let res = $crate::__detect_target_features!($($tf),+);\n                            STORAGE.store(res as u8, Relaxed);\n                            res\n                        } else {\n                            val == 1\n                        }\n                    }\n                };\n\n                (InitToken(()), res)\n            }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"sha512::x86::avx2_cpuid::init_get::cpuid":["#[inline(never)]\nunsafe fn cpuid(leaf: u32) -> CpuidResult{\n            __cpuid(leaf)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/x86.rs\"))"],"sha512::x86::avx2_cpuid::init_get::cpuid_count":["#[inline(never)]\nunsafe fn cpuid_count(leaf: u32, sub_leaf: u32) -> CpuidResult{\n            __cpuid_count(leaf, sub_leaf)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/x86.rs\"))"],"sha512::x86::cast_ms":["#[inline(always)]\nfn cast_ms(ms: &MsgSchedule) -> &[u64; SHA512_BLOCK_WORDS_NUM]{\n    unsafe { &*(ms as *const MsgSchedule as *const _) }\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::cast_rs":["#[inline(always)]\nfn cast_rs(rs: &RoundStates) -> &[u64; SHA512_ROUNDS_NUM]{\n    unsafe { &*(rs as *const RoundStates as *const _) }\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::compress":["pub fn compress(state: &mut [u64; 8], blocks: &[[u8; 128]]){\n    // TODO: Replace with https://github.com/rust-lang/rfcs/pull/2725\n    // after stabilization\n    if avx2_cpuid::get() {\n        unsafe {\n            sha512_compress_x86_64_avx2(state, blocks);\n        }\n    } else {\n        super::soft::compress(state, blocks);\n    }\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::load_data_avx":["#[inline(always)]\nunsafe fn load_data_avx(x: &mut [__m128i; 8], ms: &mut MsgSchedule, data: *const __m128i){\n    #[allow(non_snake_case)]\n    let MASK = _mm_setr_epi32(0x04050607, 0x00010203, 0x0c0d0e0f, 0x08090a0b);\n\n    macro_rules! unrolled_iterations {\n        ($($i:literal),*) => {$(\n            x[$i] = _mm_loadu_si128(data.add($i) as *const _);\n            x[$i] = _mm_shuffle_epi8(x[$i], MASK);\n\n            let y = _mm_add_epi64(\n                x[$i],\n                _mm_loadu_si128(&K64[2 * $i] as *const u64 as *const _),\n            );\n\n            ms[$i] = y;\n        )*};\n    }\n\n    unrolled_iterations!(0, 1, 2, 3, 4, 5, 6, 7);\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::load_data_avx2":["#[inline(always)]\nunsafe fn load_data_avx2(\n    x: &mut [__m256i; 8],\n    ms: &mut MsgSchedule,\n    t2: &mut RoundStates,\n    data: *const __m128i,\n){\n    #[allow(non_snake_case)]\n    let MASK = _mm256_set_epi64x(\n        0x0809_0A0B_0C0D_0E0F_i64,\n        0x0001_0203_0405_0607_i64,\n        0x0809_0A0B_0C0D_0E0F_i64,\n        0x0001_0203_0405_0607_i64,\n    );\n\n    macro_rules! unrolled_iterations {\n        ($($i:literal),*) => {$(\n            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add(8 + $i) as *const _), 1);\n            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 0);\n\n            x[$i] = _mm256_shuffle_epi8(x[$i], MASK);\n\n            let t = _mm_loadu_si128(K64.as_ptr().add($i * 2) as *const u64 as *const _);\n            let y = _mm256_add_epi64(x[$i], _mm256_set_m128i(t, t));\n\n            ms[$i] = _mm256_extracti128_si256(y, 0);\n            t2[$i] = _mm256_extracti128_si256(y, 1);\n        )*};\n    }\n\n    unrolled_iterations!(0, 1, 2, 3, 4, 5, 6, 7);\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::process_second_block":["#[inline(always)]\nfn process_second_block(current_state: &mut State, t2: &RoundStates){\n    for t2 in cast_rs(t2).iter() {\n        sha_round(current_state, *t2);\n    }\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::rounds_0_63_avx":["#[inline(always)]\nunsafe fn rounds_0_63_avx(current_state: &mut State, x: &mut [__m128i; 8], ms: &mut MsgSchedule){\n    let mut k64_idx: usize = SHA512_BLOCK_WORDS_NUM;\n\n    for _ in 0..4 {\n        for j in 0..8 {\n            let k64 = _mm_loadu_si128(&K64[k64_idx] as *const u64 as *const _);\n            let y = sha512_update_x_avx(x, k64);\n\n            {\n                let ms = cast_ms(ms);\n                sha_round(current_state, ms[2 * j]);\n                sha_round(current_state, ms[2 * j + 1]);\n            }\n\n            ms[j] = y;\n            k64_idx += 2;\n        }\n    }\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::rounds_0_63_avx2":["#[inline(always)]\nunsafe fn rounds_0_63_avx2(\n    current_state: &mut State,\n    x: &mut [__m256i; 8],\n    ms: &mut MsgSchedule,\n    t2: &mut RoundStates,\n){\n    let mut k64x4_idx: usize = SHA512_BLOCK_WORDS_NUM;\n\n    for i in 1..5 {\n        for j in 0..8 {\n            let t = _mm_loadu_si128(K64.as_ptr().add(k64x4_idx) as *const u64 as *const _);\n            let y = sha512_update_x_avx2(x, _mm256_set_m128i(t, t));\n\n            {\n                let ms = cast_ms(ms);\n                sha_round(current_state, ms[2 * j]);\n                sha_round(current_state, ms[2 * j + 1]);\n            }\n\n            ms[j] = _mm256_extracti128_si256(y, 0);\n            t2[8 * i + j] = _mm256_extracti128_si256(y, 1);\n\n            k64x4_idx += 2;\n        }\n    }\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::rounds_64_79":["#[inline(always)]\nfn rounds_64_79(current_state: &mut State, ms: &MsgSchedule){\n    let ms = cast_ms(ms);\n    for i in 64..80 {\n        sha_round(current_state, ms[i & 0xf]);\n    }\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::sha512_compress_x86_64_avx":["#[inline(always)]\nunsafe fn sha512_compress_x86_64_avx(state: &mut [u64; 8], block: &[u8; 128]){\n    let mut ms = [_mm_setzero_si128(); 8];\n    let mut x = [_mm_setzero_si128(); 8];\n\n    // Reduced to single iteration\n    let mut current_state = *state;\n    load_data_avx(&mut x, &mut ms, block.as_ptr() as *const _);\n    rounds_0_63_avx(&mut current_state, &mut x, &mut ms);\n    rounds_64_79(&mut current_state, &ms);\n    accumulate_state(state, &current_state);\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::sha512_compress_x86_64_avx2":["#[target_feature(enable = \"avx2\")]\nunsafe fn sha512_compress_x86_64_avx2(state: &mut [u64; 8], blocks: &[[u8; 128]]){\n    let mut start_block = 0;\n\n    if blocks.len() & 0b1 != 0 {\n        sha512_compress_x86_64_avx(state, &blocks[0]);\n        start_block += 1;\n    }\n\n    let mut ms: MsgSchedule = [_mm_setzero_si128(); 8];\n    let mut t2: RoundStates = [_mm_setzero_si128(); 40];\n    let mut x = [_mm256_setzero_si256(); 8];\n\n    for i in (start_block..blocks.len()).step_by(2) {\n        load_data_avx2(&mut x, &mut ms, &mut t2, blocks.as_ptr().add(i) as *const _);\n\n        // First block\n        let mut current_state = *state;\n        rounds_0_63_avx2(&mut current_state, &mut x, &mut ms, &mut t2);\n        rounds_64_79(&mut current_state, &ms);\n        accumulate_state(state, &current_state);\n\n        // Second block\n        current_state = *state;\n        process_second_block(&mut current_state, &t2);\n        accumulate_state(state, &current_state);\n    }\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::sha512_update_x_avx":["unsafe fn $name(x: &mut [$ty; 8], k64: $ty) -> $ty{\n            // q[2:1]\n            let mut t0 = $ALIGNR8(x[1], x[0], 8);\n            // q[10:9]\n            let mut t3 = $ALIGNR8(x[5], x[4], 8);\n            // q[2:1] >> s0[0]\n            let mut t2 = $SRL64(t0, 1);\n            // q[1:0] + q[10:9]\n            x[0] = $ADD64(x[0], t3);\n            // q[2:1] >> s0[2]\n            t3 = $SRL64(t0, 7);\n            // q[2:1] << (64 - s0[1])\n            let mut t1 = $SLL64(t0, 64 - 8);\n            // (q[2:1] >> s0[2]) ^\n            // (q[2:1] >> s0[0])\n            t0 = $XOR(t3, t2);\n            // q[2:1] >> s0[1]\n            t2 = $SRL64(t2, 8 - 1);\n            // (q[2:1] >> s0[2]) ^\n            // (q[2:1] >> s0[0]) ^\n            // q[2:1] << (64 - s0[1])\n            t0 = $XOR(t0, t1);\n            // q[2:1] << (64 - s0[0])\n            t1 = $SLL64(t1, 8 - 1);\n            // sigma1(q[2:1])\n            t0 = $XOR(t0, t2);\n            t0 = $XOR(t0, t1);\n            // q[15:14] >> s1[2]\n            t3 = $SRL64(x[7], 6);\n            // q[15:14] >> (64 - s1[1])\n            t2 = $SLL64(x[7], 64 - 61);\n            // q[1:0] + sigma0(q[2:1])\n            x[0] = $ADD64(x[0], t0);\n            // q[15:14] >> s1[0]\n            t1 = $SRL64(x[7], 19);\n            // q[15:14] >> s1[2] ^\n            // q[15:14] >> (64 - s1[1])\n            t3 = $XOR(t3, t2);\n            // q[15:14] >> (64 - s1[0])\n            t2 = $SLL64(t2, 61 - 19);\n            // q[15:14] >> s1[2] ^\n            // q[15:14] >> (64 - s1[1] ^\n            // q[15:14] >> s1[0]\n            t3 = $XOR(t3, t1);\n            // q[15:14] >> s1[1]\n            t1 = $SRL64(t1, 61 - 19);\n            // sigma1(q[15:14])\n            t3 = $XOR(t3, t2);\n            t3 = $XOR(t3, t1);\n\n            // q[1:0] + q[10:9] + sigma1(q[15:14]) + sigma0(q[2:1])\n            x[0] = $ADD64(x[0], t3);\n\n            // rotate\n            let temp = x[0];\n            x[0] = x[1];\n            x[1] = x[2];\n            x[2] = x[3];\n            x[3] = x[4];\n            x[4] = x[5];\n            x[5] = x[6];\n            x[6] = x[7];\n            x[7] = temp;\n\n            $ADD64(x[7], k64)\n        }","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::sha512_update_x_avx2":["unsafe fn $name(x: &mut [$ty; 8], k64: $ty) -> $ty{\n            // q[2:1]\n            let mut t0 = $ALIGNR8(x[1], x[0], 8);\n            // q[10:9]\n            let mut t3 = $ALIGNR8(x[5], x[4], 8);\n            // q[2:1] >> s0[0]\n            let mut t2 = $SRL64(t0, 1);\n            // q[1:0] + q[10:9]\n            x[0] = $ADD64(x[0], t3);\n            // q[2:1] >> s0[2]\n            t3 = $SRL64(t0, 7);\n            // q[2:1] << (64 - s0[1])\n            let mut t1 = $SLL64(t0, 64 - 8);\n            // (q[2:1] >> s0[2]) ^\n            // (q[2:1] >> s0[0])\n            t0 = $XOR(t3, t2);\n            // q[2:1] >> s0[1]\n            t2 = $SRL64(t2, 8 - 1);\n            // (q[2:1] >> s0[2]) ^\n            // (q[2:1] >> s0[0]) ^\n            // q[2:1] << (64 - s0[1])\n            t0 = $XOR(t0, t1);\n            // q[2:1] << (64 - s0[0])\n            t1 = $SLL64(t1, 8 - 1);\n            // sigma1(q[2:1])\n            t0 = $XOR(t0, t2);\n            t0 = $XOR(t0, t1);\n            // q[15:14] >> s1[2]\n            t3 = $SRL64(x[7], 6);\n            // q[15:14] >> (64 - s1[1])\n            t2 = $SLL64(x[7], 64 - 61);\n            // q[1:0] + sigma0(q[2:1])\n            x[0] = $ADD64(x[0], t0);\n            // q[15:14] >> s1[0]\n            t1 = $SRL64(x[7], 19);\n            // q[15:14] >> s1[2] ^\n            // q[15:14] >> (64 - s1[1])\n            t3 = $XOR(t3, t2);\n            // q[15:14] >> (64 - s1[0])\n            t2 = $SLL64(t2, 61 - 19);\n            // q[15:14] >> s1[2] ^\n            // q[15:14] >> (64 - s1[1] ^\n            // q[15:14] >> s1[0]\n            t3 = $XOR(t3, t1);\n            // q[15:14] >> s1[1]\n            t1 = $SRL64(t1, 61 - 19);\n            // sigma1(q[15:14])\n            t3 = $XOR(t3, t2);\n            t3 = $XOR(t3, t1);\n\n            // q[1:0] + q[10:9] + sigma1(q[15:14]) + sigma0(q[2:1])\n            x[0] = $ADD64(x[0], t3);\n\n            // rotate\n            let temp = x[0];\n            x[0] = x[1];\n            x[1] = x[2];\n            x[2] = x[3];\n            x[3] = x[4];\n            x[4] = x[5];\n            x[5] = x[6];\n            x[6] = x[7];\n            x[7] = temp;\n\n            $ADD64(x[7], k64)\n        }","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"],"sha512::x86::sha_round":["#[inline(always)]\nfn sha_round(s: &mut State, x: u64){\n    macro_rules! big_sigma0 {\n        ($a:expr) => {\n            $a.rotate_right(28) ^ $a.rotate_right(34) ^ $a.rotate_right(39)\n        };\n    }\n    macro_rules! big_sigma1 {\n        ($a:expr) => {\n            $a.rotate_right(14) ^ $a.rotate_right(18) ^ $a.rotate_right(41)\n        };\n    }\n    macro_rules! bool3ary_202 {\n        ($a:expr, $b:expr, $c:expr) => {\n            $c ^ ($a & ($b ^ $c))\n        };\n    } // Choose, MD5F, SHA1C\n    macro_rules! bool3ary_232 {\n        ($a:expr, $b:expr, $c:expr) => {\n            ($a & $b) ^ ($a & $c) ^ ($b & $c)\n        };\n    } // Majority, SHA1M\n\n    macro_rules! rotate_state {\n        ($s:ident) => {{\n            let tmp = $s[7];\n            $s[7] = $s[6];\n            $s[6] = $s[5];\n            $s[5] = $s[4];\n            $s[4] = $s[3];\n            $s[3] = $s[2];\n            $s[2] = $s[1];\n            $s[1] = $s[0];\n            $s[0] = tmp;\n        }};\n    }\n\n    let t = x\n        .wrapping_add(s[7])\n        .wrapping_add(big_sigma1!(s[4]))\n        .wrapping_add(bool3ary_202!(s[4], s[5], s[6]));\n\n    s[7] = t\n        .wrapping_add(big_sigma0!(s[0]))\n        .wrapping_add(bool3ary_232!(s[0], s[1], s[2]));\n    s[3] = s[3].wrapping_add(t);\n\n    rotate_state!(s);\n}","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))"]},"struct_constructor":{"&[u64; _]":["cast_ms","cast_rs"],"(sha256::x86::shani_cpuid::InitToken, bool)":["init_get"],"(sha512::x86::avx2_cpuid::InitToken, bool)":["init_get"],"OidSha224":["clone"],"OidSha256":["clone"],"OidSha384":["clone"],"OidSha512":["clone"],"OidSha512_224":["clone"],"OidSha512_256":["clone"],"bool":["eq","get"],"core::arch::x86_64::CpuidResult":["cpuid","cpuid_count"],"core::result::Result":["fmt","new","write_alg_name"],"core_api::Sha256VarCore":["clone"],"core_api::Sha512VarCore":["clone"],"sha256::x86::shani_cpuid::InitToken":["clone","init"],"sha512::x86::avx2_cpuid::InitToken":["clone","init"]},"struct_to_trait":{"OidSha224":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::hash::Hash","core::marker::Copy","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"OidSha256":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::hash::Hash","core::marker::Copy","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"OidSha384":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::hash::Hash","core::marker::Copy","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"OidSha512":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::hash::Hash","core::marker::Copy","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"OidSha512_224":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::hash::Hash","core::marker::Copy","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"OidSha512_256":["core::clone::Clone","core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::hash::Hash","core::marker::Copy","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"core_api::Sha256VarCore":["core::clone::Clone","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::UpdateCore","digest::core_api::VariableOutputCore"],"core_api::Sha512VarCore":["core::clone::Clone","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::UpdateCore","digest::core_api::VariableOutputCore"],"sha256::x86::shani_cpuid::InitToken":["core::clone::Clone","core::fmt::Debug","core::marker::Copy"],"sha512::x86::avx2_cpuid::InitToken":["core::clone::Clone","core::fmt::Debug","core::marker::Copy"]},"targets":{"<core_api::Sha256VarCore as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha2/src/core_api.rs\"))","core::fmt::Debug"],"<core_api::Sha256VarCore as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha2/src/core_api.rs\"))","digest::core_api::AlgorithmName"],"<core_api::Sha256VarCore as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha2/src/core_api.rs\"))","digest::core_api::UpdateCore"],"<core_api::Sha256VarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["finalize_variable_core","Real(LocalPath(\"sha2/src/core_api.rs\"))","digest::core_api::VariableOutputCore"],"<core_api::Sha256VarCore as digest::core_api::VariableOutputCore>::new":["new","Real(LocalPath(\"sha2/src/core_api.rs\"))","digest::core_api::VariableOutputCore"],"<core_api::Sha512VarCore as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha2/src/core_api.rs\"))","core::fmt::Debug"],"<core_api::Sha512VarCore as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha2/src/core_api.rs\"))","digest::core_api::AlgorithmName"],"<core_api::Sha512VarCore as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha2/src/core_api.rs\"))","digest::core_api::UpdateCore"],"<core_api::Sha512VarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["finalize_variable_core","Real(LocalPath(\"sha2/src/core_api.rs\"))","digest::core_api::VariableOutputCore"],"<core_api::Sha512VarCore as digest::core_api::VariableOutputCore>::new":["new","Real(LocalPath(\"sha2/src/core_api.rs\"))","digest::core_api::VariableOutputCore"],"sha256::compress256":["compress256","Real(LocalPath(\"sha2/src/sha256.rs\"))",""],"sha256::soft::add":["add","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::compress":["compress","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::or":["or","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::schedule":["schedule","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::sha256_digest_block_u32":["sha256_digest_block_u32","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::sha256_digest_round_x2":["sha256_digest_round_x2","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::sha256load":["sha256load","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::sha256msg1":["sha256msg1","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::sha256msg1::sigma0x4":["sigma0x4","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::sha256msg2":["sha256msg2","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::sha256swap":["sha256swap","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::shl":["shl","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::shr":["shr","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::soft::xor":["xor","Real(LocalPath(\"sha2/src/sha256/soft.rs\"))",""],"sha256::x86::compress":["compress","Real(LocalPath(\"sha2/src/sha256/x86.rs\"))",""],"sha256::x86::digest_blocks":["digest_blocks","Real(LocalPath(\"sha2/src/sha256/x86.rs\"))",""],"sha256::x86::schedule":["schedule","Real(LocalPath(\"sha2/src/sha256/x86.rs\"))",""],"sha256::x86::shani_cpuid::InitToken::get":["get","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))",""],"sha256::x86::shani_cpuid::get":["get","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))",""],"sha256::x86::shani_cpuid::init":["init","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))",""],"sha256::x86::shani_cpuid::init_get":["init_get","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))",""],"sha256::x86::shani_cpuid::init_get::cpuid":["cpuid","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/x86.rs\"))",""],"sha256::x86::shani_cpuid::init_get::cpuid_count":["cpuid_count","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/x86.rs\"))",""],"sha512::compress512":["compress512","Real(LocalPath(\"sha2/src/sha512.rs\"))",""],"sha512::soft::add":["add","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))",""],"sha512::soft::compress":["compress","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))",""],"sha512::soft::sha512_digest_block_u64":["sha512_digest_block_u64","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))",""],"sha512::soft::sha512_digest_round":["sha512_digest_round","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))",""],"sha512::soft::sha512_schedule_x2":["sha512_schedule_x2","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))",""],"sha512::soft::sha512_schedule_x2::sigma0":["sigma0","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))",""],"sha512::soft::sha512_schedule_x2::sigma1":["sigma1","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))",""],"sha512::soft::sha512load":["sha512load","Real(LocalPath(\"sha2/src/sha512/soft.rs\"))",""],"sha512::x86::accumulate_state":["accumulate_state","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::avx2_cpuid::InitToken::get":["get","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))",""],"sha512::x86::avx2_cpuid::get":["get","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))",""],"sha512::x86::avx2_cpuid::init":["init","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))",""],"sha512::x86::avx2_cpuid::init_get":["init_get","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))",""],"sha512::x86::avx2_cpuid::init_get::cpuid":["cpuid","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/x86.rs\"))",""],"sha512::x86::avx2_cpuid::init_get::cpuid_count":["cpuid_count","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/x86.rs\"))",""],"sha512::x86::cast_ms":["cast_ms","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::cast_rs":["cast_rs","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::compress":["compress","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::load_data_avx":["load_data_avx","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::load_data_avx2":["load_data_avx2","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::process_second_block":["process_second_block","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::rounds_0_63_avx":["rounds_0_63_avx","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::rounds_0_63_avx2":["rounds_0_63_avx2","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::rounds_64_79":["rounds_64_79","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::sha512_compress_x86_64_avx":["sha512_compress_x86_64_avx","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::sha512_compress_x86_64_avx2":["sha512_compress_x86_64_avx2","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::sha512_update_x_avx":["sha512_update_x_avx","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::sha512_update_x_avx2":["sha512_update_x_avx2","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""],"sha512::x86::sha_round":["sha_round","Real(LocalPath(\"sha2/src/sha512/x86.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["OidSha224","OidSha256","OidSha384","OidSha512","OidSha512_224","OidSha512_256","core_api::Sha256VarCore","core_api::Sha512VarCore","sha256::x86::shani_cpuid::InitToken","sha512::x86::avx2_cpuid::InitToken"],"core::cmp::Eq":["OidSha224","OidSha256","OidSha384","OidSha512","OidSha512_224","OidSha512_256"],"core::cmp::PartialEq":["OidSha224","OidSha256","OidSha384","OidSha512","OidSha512_224","OidSha512_256"],"core::fmt::Debug":["OidSha224","OidSha256","OidSha384","OidSha512","OidSha512_224","OidSha512_256","core_api::Sha256VarCore","core_api::Sha512VarCore","sha256::x86::shani_cpuid::InitToken","sha512::x86::avx2_cpuid::InitToken"],"core::hash::Hash":["OidSha224","OidSha256","OidSha384","OidSha512","OidSha512_224","OidSha512_256"],"core::marker::Copy":["OidSha224","OidSha256","OidSha384","OidSha512","OidSha512_224","OidSha512_256","sha256::x86::shani_cpuid::InitToken","sha512::x86::avx2_cpuid::InitToken"],"core::marker::StructuralEq":["OidSha224","OidSha256","OidSha384","OidSha512","OidSha512_224","OidSha512_256"],"core::marker::StructuralPartialEq":["OidSha224","OidSha256","OidSha384","OidSha512","OidSha512_224","OidSha512_256"],"digest::HashMarker":["core_api::Sha256VarCore","core_api::Sha512VarCore"],"digest::OutputSizeUser":["core_api::Sha256VarCore","core_api::Sha512VarCore"],"digest::core_api::AlgorithmName":["core_api::Sha256VarCore","core_api::Sha512VarCore"],"digest::core_api::BlockSizeUser":["core_api::Sha256VarCore","core_api::Sha512VarCore"],"digest::core_api::BufferKindUser":["core_api::Sha256VarCore","core_api::Sha512VarCore"],"digest::core_api::UpdateCore":["core_api::Sha256VarCore","core_api::Sha512VarCore"],"digest::core_api::VariableOutputCore":["core_api::Sha256VarCore","core_api::Sha512VarCore"]},"type_to_def_path":{"OidSha224":"OidSha224","OidSha256":"OidSha256","OidSha384":"OidSha384","OidSha512":"OidSha512","OidSha512_224":"OidSha512_224","OidSha512_256":"OidSha512_256","core_api::Sha256VarCore":"core_api::Sha256VarCore","core_api::Sha512VarCore":"core_api::Sha512VarCore","sha256::x86::shani_cpuid::InitToken":"sha256::x86::shani_cpuid::InitToken","sha512::x86::avx2_cpuid::InitToken":"sha512::x86::avx2_cpuid::InitToken"}}