{"dependencies":{"<Blake2bMac<OutSize> as core::clone::Clone>::clone":["Blake2bMac","Blake2bVarCore","core::marker::PhantomData","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::IsLessOrEqual","digest::typenum::NonZero","simd::simdty::Simd4"],"<Blake2bMac<OutSize> as core::fmt::Debug>::fmt":["Blake2bMac","Blake2bVarCore","core::fmt::Formatter","core::marker::PhantomData","core::marker::Sized","core::result::Result","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::IsLessOrEqual","digest::typenum::NonZero","simd::simdty::Simd4"],"<Blake2bMac<OutSize> as digest::FixedOutput>::finalize_into":["Blake2bMac","Blake2bVarCore","core::marker::PhantomData","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::IsLessOrEqual","digest::typenum::NonZero","simd::simdty::Simd4"],"<Blake2bMac<OutSize> as digest::KeyInit>::new":["Blake2bMac","Blake2bVarCore","core::marker::PhantomData","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::IsLessOrEqual","digest::typenum::NonZero","simd::simdty::Simd4"],"<Blake2bMac<OutSize> as digest::KeyInit>::new_from_slice":["core::marker::Sized","core::result::Result"],"<Blake2bMac<OutSize> as digest::Update>::update":["Blake2bMac","Blake2bVarCore","core::marker::PhantomData","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::IsLessOrEqual","digest::typenum::NonZero","simd::simdty::Simd4"],"<Blake2bVarCore as core::clone::Clone>::clone":["Blake2bVarCore","core::marker::Sized","simd::simdty::Simd4"],"<Blake2bVarCore as core::fmt::Debug>::fmt":["Blake2bVarCore","core::fmt::Formatter","core::marker::Sized","core::result::Result","simd::simdty::Simd4"],"<Blake2bVarCore as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Blake2bVarCore as digest::core_api::UpdateCore>::update_blocks":["Blake2bVarCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","simd::simdty::Simd4"],"<Blake2bVarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["Blake2bVarCore","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero","simd::simdty::Simd4"],"<Blake2bVarCore as digest::core_api::VariableOutputCore>::new":["core::marker::Sized","core::result::Result"],"<Blake2sMac<OutSize> as core::clone::Clone>::clone":["Blake2sMac","Blake2sVarCore","core::marker::PhantomData","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::IsLessOrEqual","digest::typenum::NonZero","simd::simdty::Simd4"],"<Blake2sMac<OutSize> as core::fmt::Debug>::fmt":["Blake2sMac","Blake2sVarCore","core::fmt::Formatter","core::marker::PhantomData","core::marker::Sized","core::result::Result","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::IsLessOrEqual","digest::typenum::NonZero","simd::simdty::Simd4"],"<Blake2sMac<OutSize> as digest::FixedOutput>::finalize_into":["Blake2sMac","Blake2sVarCore","core::marker::PhantomData","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::IsLessOrEqual","digest::typenum::NonZero","simd::simdty::Simd4"],"<Blake2sMac<OutSize> as digest::KeyInit>::new":["Blake2sMac","Blake2sVarCore","core::marker::PhantomData","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::IsLessOrEqual","digest::typenum::NonZero","simd::simdty::Simd4"],"<Blake2sMac<OutSize> as digest::KeyInit>::new_from_slice":["core::marker::Sized","core::result::Result"],"<Blake2sMac<OutSize> as digest::Update>::update":["Blake2sMac","Blake2sVarCore","core::marker::PhantomData","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::IsLessOrEqual","digest::typenum::NonZero","simd::simdty::Simd4"],"<Blake2sVarCore as core::clone::Clone>::clone":["Blake2sVarCore","core::marker::Sized","simd::simdty::Simd4"],"<Blake2sVarCore as core::fmt::Debug>::fmt":["Blake2sVarCore","core::fmt::Formatter","core::marker::Sized","core::result::Result","simd::simdty::Simd4"],"<Blake2sVarCore as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Blake2sVarCore as digest::core_api::UpdateCore>::update_blocks":["Blake2sVarCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","simd::simdty::Simd4"],"<Blake2sVarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["Blake2sVarCore","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero","simd::simdty::Simd4"],"<Blake2sVarCore as digest::core_api::VariableOutputCore>::new":["core::marker::Sized","core::result::Result"],"<[T] as as_bytes::AsBytes>::as_bytes":[],"<[T] as as_bytes::AsBytes>::as_mut_bytes":[],"<simd::simdty::Simd16<T> as core::clone::Clone>::clone":["core::marker::Sized","simd::simdty::Simd16"],"<simd::simdty::Simd16<T> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","simd::simdty::Simd16"],"<simd::simdty::Simd2<T> as core::clone::Clone>::clone":["core::marker::Sized","simd::simdty::Simd2"],"<simd::simdty::Simd2<T> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","simd::simdty::Simd2"],"<simd::simdty::Simd32<T> as core::clone::Clone>::clone":["core::marker::Sized","simd::simdty::Simd32"],"<simd::simdty::Simd32<T> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","simd::simdty::Simd32"],"<simd::simdty::Simd4<T> as core::clone::Clone>::clone":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<T> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","simd::simdty::Simd4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::from_le":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::gather":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::rotate_right_const":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::shuffle_left_1":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::shuffle_left_2":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::shuffle_left_3":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::to_le":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::wrapping_add":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::from_le":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::gather":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::rotate_right_const":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::shuffle_left_1":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::shuffle_left_2":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::shuffle_left_3":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::to_le":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::wrapping_add":["core::marker::Sized","simd::simdty::Simd4"],"<simd::simdty::Simd8<T> as core::clone::Clone>::clone":["core::marker::Sized","simd::simdty::Simd8"],"<simd::simdty::Simd8<T> as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","simd::simdty::Simd8"],"Blake2bMac":["Blake2bMac","Blake2bVarCore","core::marker::PhantomData","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::IsLessOrEqual","digest::typenum::NonZero","simd::simdty::Simd4"],"Blake2bMac::<OutSize>::new_with_salt_and_personal":["core::marker::Sized","core::result::Result"],"Blake2bVarCore":["Blake2bVarCore","core::marker::Sized","simd::simdty::Simd4"],"Blake2bVarCore::compress":["Blake2bVarCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","simd::simdty::Simd4"],"Blake2bVarCore::compress::quarter_round":["core::marker::Sized","simd::simdty::Simd4"],"Blake2bVarCore::compress::round":["core::marker::Sized","simd::simdty::Simd4"],"Blake2bVarCore::compress::shuffle":["core::marker::Sized","simd::simdty::Simd4"],"Blake2bVarCore::compress::unshuffle":["core::marker::Sized","simd::simdty::Simd4"],"Blake2bVarCore::finalize_with_flag":["Blake2bVarCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","simd::simdty::Simd4"],"Blake2bVarCore::iv0":["core::marker::Sized","simd::simdty::Simd4"],"Blake2bVarCore::iv1":["core::marker::Sized","simd::simdty::Simd4"],"Blake2bVarCore::new_with_params":["Blake2bVarCore","core::marker::Sized","simd::simdty::Simd4"],"Blake2sMac":["Blake2sMac","Blake2sVarCore","core::marker::PhantomData","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::IsLessOrEqual","digest::typenum::NonZero","simd::simdty::Simd4"],"Blake2sMac::<OutSize>::new_with_salt_and_personal":["core::marker::Sized","core::result::Result"],"Blake2sVarCore":["Blake2sVarCore","core::marker::Sized","simd::simdty::Simd4"],"Blake2sVarCore::compress":["Blake2sVarCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","simd::simdty::Simd4"],"Blake2sVarCore::compress::quarter_round":["core::marker::Sized","simd::simdty::Simd4"],"Blake2sVarCore::compress::round":["core::marker::Sized","simd::simdty::Simd4"],"Blake2sVarCore::compress::shuffle":["core::marker::Sized","simd::simdty::Simd4"],"Blake2sVarCore::compress::unshuffle":["core::marker::Sized","simd::simdty::Simd4"],"Blake2sVarCore::finalize_with_flag":["Blake2sVarCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","simd::simdty::Simd4"],"Blake2sVarCore::iv0":["core::marker::Sized","simd::simdty::Simd4"],"Blake2sVarCore::iv1":["core::marker::Sized","simd::simdty::Simd4"],"Blake2sVarCore::new_with_params":["Blake2sVarCore","core::marker::Sized","simd::simdty::Simd4"],"as_bytes::AsBytes::as_bytes":[],"as_bytes::AsBytes::as_mut_bytes":[],"simd::Vector4::from_le":[],"simd::Vector4::gather":[],"simd::Vector4::rotate_right_const":[],"simd::Vector4::shuffle_left_1":[],"simd::Vector4::shuffle_left_2":[],"simd::Vector4::shuffle_left_3":[],"simd::Vector4::shuffle_right_1":[],"simd::Vector4::shuffle_right_2":[],"simd::Vector4::shuffle_right_3":[],"simd::Vector4::to_le":[],"simd::Vector4::wrapping_add":[],"simd::simd_opt::u32x4::rotate_right_const":["core::marker::Sized","simd::simdty::Simd4"],"simd::simd_opt::u64x4::rotate_right_const":["core::marker::Sized","simd::simdty::Simd4"],"simd::simdop::<impl core::ops::Add for simd::simdty::Simd4<u32>>::add":["core::marker::Sized","simd::simdty::Simd4"],"simd::simdop::<impl core::ops::Add for simd::simdty::Simd4<u64>>::add":["core::marker::Sized","simd::simdty::Simd4"],"simd::simdop::<impl core::ops::BitXor for simd::simdty::Simd4<u32>>::bitxor":["core::marker::Sized","simd::simdty::Simd4"],"simd::simdop::<impl core::ops::BitXor for simd::simdty::Simd4<u64>>::bitxor":["core::marker::Sized","simd::simdty::Simd4"],"simd::simdop::<impl core::ops::Shl for simd::simdty::Simd4<u32>>::shl":["core::marker::Sized","simd::simdty::Simd4"],"simd::simdop::<impl core::ops::Shl for simd::simdty::Simd4<u64>>::shl":["core::marker::Sized","simd::simdty::Simd4"],"simd::simdop::<impl core::ops::Shr for simd::simdty::Simd4<u32>>::shr":["core::marker::Sized","simd::simdty::Simd4"],"simd::simdop::<impl core::ops::Shr for simd::simdty::Simd4<u64>>::shr":["core::marker::Sized","simd::simdty::Simd4"],"simd::simdty::Simd16":["core::marker::Sized","simd::simdty::Simd16"],"simd::simdty::Simd2":["core::marker::Sized","simd::simdty::Simd2"],"simd::simdty::Simd32":["core::marker::Sized","simd::simdty::Simd32"],"simd::simdty::Simd4":["core::marker::Sized","simd::simdty::Simd4"],"simd::simdty::Simd4::<T>::new":["core::marker::Sized","simd::simdty::Simd4"],"simd::simdty::Simd8":["core::marker::Sized","simd::simdty::Simd8"]},"glob_path_import":{},"self_to_fn":{"Blake2bMac":["Clone","impl<OutSize> $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            /// Create new instance using provided key, salt, and persona.\n            ///\n            /// Key length should not be bigger than block size, salt and persona\n            /// length should not be bigger than quarter of block size. If any\n            /// of those conditions is false the method will return an error.\n            #[inline]\n            pub fn new_with_salt_and_personal(\n                key: &[u8],\n                salt: &[u8],\n                persona: &[u8],\n            ) -> Result<Self, InvalidLength> {\n                let kl = key.len();\n                let bs = <$hash as BlockSizeUser>::BlockSize::USIZE;\n                let qbs = bs / 4;\n                if kl > bs || salt.len() > qbs || persona.len() > qbs {\n                    return Err(InvalidLength);\n                }\n                let mut padded_key = Block::<$hash>::default();\n                padded_key[..kl].copy_from_slice(key);\n                Ok(Self {\n                    core: <$hash>::new_with_params(salt, persona, key.len(), OutSize::USIZE),\n                    buffer: LazyBuffer::new(&padded_key),\n                    #[cfg(feature = \"reset\")]\n                    key_block: {\n                        let mut t = Key::<Self>::default();\n                        t[..kl].copy_from_slice(key);\n                        t\n                    },\n                    _out: PhantomData,\n                })\n            }\n        }","impl<OutSize> FixedOutput for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size> + 'static,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            #[inline]\n            fn finalize_into(mut self, out: &mut Output<Self>) {\n                let Self { core, buffer, .. } = &mut self;\n                let mut full_res = Default::default();\n                core.finalize_variable_core(buffer, &mut full_res);\n                out.copy_from_slice(&full_res[..OutSize::USIZE]);\n            }\n        }","impl<OutSize> KeyInit for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            #[inline]\n            fn new(key: &Key<Self>) -> Self {\n                Self::new_from_slice(key).expect(\"Key has correct length\")\n            }\n\n            #[inline]\n            fn new_from_slice(key: &[u8]) -> Result<Self, InvalidLength> {\n                let kl = key.len();\n                if kl > <Self as KeySizeUser>::KeySize::USIZE {\n                    return Err(InvalidLength);\n                }\n                let mut padded_key = Block::<$hash>::default();\n                padded_key[..kl].copy_from_slice(key);\n                Ok(Self {\n                    core: <$hash>::new_with_params(&[], &[], key.len(), OutSize::USIZE),\n                    buffer: LazyBuffer::new(&padded_key),\n                    #[cfg(feature = \"reset\")]\n                    key_block: {\n                        let mut t = Key::<Self>::default();\n                        t[..kl].copy_from_slice(key);\n                        t\n                    },\n                    _out: PhantomData,\n                })\n            }\n        }","impl<OutSize> KeySizeUser for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            type KeySize = $max_size;\n        }","impl<OutSize> MacMarker for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n        }","impl<OutSize> OutputSizeUser for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size> + 'static,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            type OutputSize = OutSize;\n        }","impl<OutSize> Update for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            #[inline]\n            fn update(&mut self, input: &[u8]) {\n                let Self { core, buffer, .. } = self;\n                buffer.digest_blocks(input, |blocks| core.update_blocks(blocks));\n            }\n        }","impl<OutSize> fmt::Debug for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                write!(f, \"{}{} {{ ... }}\", stringify!($name), OutSize::USIZE)\n            }\n        }"],"Blake2bVarCore":["Clone","impl $name {\n            #[inline(always)]\n            fn iv0() -> $vec {\n                $vec::new($IV[0], $IV[1], $IV[2], $IV[3])\n            }\n            #[inline(always)]\n            fn iv1() -> $vec {\n                $vec::new($IV[4], $IV[5], $IV[6], $IV[7])\n            }\n\n            /// Creates a new context with the full set of sequential-mode parameters.\n            pub fn new_with_params(\n                salt: &[u8],\n                persona: &[u8],\n                key_size: usize,\n                output_size: usize,\n            ) -> Self {\n                assert!(key_size <= $bytes::to_usize());\n                assert!(output_size <= $bytes::to_usize());\n\n                // The number of bytes needed to express two words.\n                let length = $bytes::to_usize() / 4;\n                assert!(salt.len() <= length);\n                assert!(persona.len() <= length);\n\n                // Build a parameter block\n                let mut p = [0 as $word; 8];\n                p[0] = 0x0101_0000 ^ ((key_size as $word) << 8) ^ (output_size as $word);\n\n                // salt is two words long\n                if salt.len() < length {\n                    let mut padded_salt =\n                        GenericArray::<u8, <$bytes as Div<U4>>::Output>::default();\n                    for i in 0..salt.len() {\n                        padded_salt[i] = salt[i];\n                    }\n                    p[4] = $word::from_le_bytes(padded_salt[0..length / 2].try_into().unwrap());\n                    p[5] = $word::from_le_bytes(\n                        padded_salt[length / 2..padded_salt.len()]\n                            .try_into()\n                            .unwrap(),\n                    );\n                } else {\n                    p[4] = $word::from_le_bytes(salt[0..salt.len() / 2].try_into().unwrap());\n                    p[5] =\n                        $word::from_le_bytes(salt[salt.len() / 2..salt.len()].try_into().unwrap());\n                }\n\n                // persona is also two words long\n                if persona.len() < length {\n                    let mut padded_persona =\n                        GenericArray::<u8, <$bytes as Div<U4>>::Output>::default();\n                    for i in 0..persona.len() {\n                        padded_persona[i] = persona[i];\n                    }\n                    p[6] = $word::from_le_bytes(padded_persona[0..length / 2].try_into().unwrap());\n                    p[7] = $word::from_le_bytes(\n                        padded_persona[length / 2..padded_persona.len()]\n                            .try_into()\n                            .unwrap(),\n                    );\n                } else {\n                    p[6] = $word::from_le_bytes(persona[0..length / 2].try_into().unwrap());\n                    p[7] = $word::from_le_bytes(\n                        persona[length / 2..persona.len()].try_into().unwrap(),\n                    );\n                }\n\n                let h = [\n                    Self::iv0() ^ $vec::new(p[0], p[1], p[2], p[3]),\n                    Self::iv1() ^ $vec::new(p[4], p[5], p[6], p[7]),\n                ];\n                $name {\n                    #[cfg(feature = \"reset\")]\n                    h0: h.clone(),\n                    h,\n                    t: 0,\n                }\n            }\n\n            fn finalize_with_flag(\n                &mut self,\n                final_block: &GenericArray<u8, $block_size>,\n                flag: $word,\n                out: &mut Output<Self>,\n            ) {\n                self.compress(final_block, !0, flag);\n                let buf = [self.h[0].to_le(), self.h[1].to_le()];\n                out.copy_from_slice(buf.as_bytes())\n            }\n\n            fn compress(&mut self, block: &Block<Self>, f0: $word, f1: $word) {\n                use $crate::consts::SIGMA;\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn quarter_round(v: &mut [$vec; 4], rd: u32, rb: u32, m: $vec) {\n                    v[0] = v[0].wrapping_add(v[1]).wrapping_add(m.from_le());\n                    v[3] = (v[3] ^ v[0]).rotate_right_const(rd);\n                    v[2] = v[2].wrapping_add(v[3]);\n                    v[1] = (v[1] ^ v[2]).rotate_right_const(rb);\n                }\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn shuffle(v: &mut [$vec; 4]) {\n                    v[1] = v[1].shuffle_left_1();\n                    v[2] = v[2].shuffle_left_2();\n                    v[3] = v[3].shuffle_left_3();\n                }\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn unshuffle(v: &mut [$vec; 4]) {\n                    v[1] = v[1].shuffle_right_1();\n                    v[2] = v[2].shuffle_right_2();\n                    v[3] = v[3].shuffle_right_3();\n                }\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn round(v: &mut [$vec; 4], m: &[$word; 16], s: &[usize; 16]) {\n                    quarter_round(v, $R1, $R2, $vec::gather(m, s[0], s[2], s[4], s[6]));\n                    quarter_round(v, $R3, $R4, $vec::gather(m, s[1], s[3], s[5], s[7]));\n\n                    shuffle(v);\n                    quarter_round(v, $R1, $R2, $vec::gather(m, s[8], s[10], s[12], s[14]));\n                    quarter_round(v, $R3, $R4, $vec::gather(m, s[9], s[11], s[13], s[15]));\n                    unshuffle(v);\n                }\n\n                let mut m: [$word; 16] = Default::default();\n                let n = core::mem::size_of::<$word>();\n                for (v, chunk) in m.iter_mut().zip(block.chunks_exact(n)) {\n                    *v = $word::from_ne_bytes(chunk.try_into().unwrap());\n                }\n                let h = &mut self.h;\n\n                let t0 = self.t as $word;\n                let t1 = match $bytes::to_u8() {\n                    64 => 0,\n                    32 => (self.t >> 32) as $word,\n                    _ => unreachable!(),\n                };\n\n                let mut v = [\n                    h[0],\n                    h[1],\n                    Self::iv0(),\n                    Self::iv1() ^ $vec::new(t0, t1, f0, f1),\n                ];\n\n                round(&mut v, &m, &SIGMA[0]);\n                round(&mut v, &m, &SIGMA[1]);\n                round(&mut v, &m, &SIGMA[2]);\n                round(&mut v, &m, &SIGMA[3]);\n                round(&mut v, &m, &SIGMA[4]);\n                round(&mut v, &m, &SIGMA[5]);\n                round(&mut v, &m, &SIGMA[6]);\n                round(&mut v, &m, &SIGMA[7]);\n                round(&mut v, &m, &SIGMA[8]);\n                round(&mut v, &m, &SIGMA[9]);\n                if $bytes::to_u8() == 64 {\n                    round(&mut v, &m, &SIGMA[0]);\n                    round(&mut v, &m, &SIGMA[1]);\n                }\n\n                h[0] = h[0] ^ (v[0] ^ v[2]);\n                h[1] = h[1] ^ (v[1] ^ v[3]);\n            }\n        }","impl AlgorithmName for $name {\n            #[inline]\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str($alg_name)\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $block_size;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Lazy;\n        }","impl HashMarker for $name {}","impl OutputSizeUser for $name {\n            type OutputSize = $bytes;\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.t += block.len() as u64;\n                    self.compress(block, 0, 0);\n                }\n            }\n        }","impl VariableOutputCore for $name {\n            const TRUNC_SIDE: TruncSide = TruncSide::Left;\n\n            #[inline]\n            fn new(output_size: usize) -> Result<Self, InvalidOutputSize> {\n                if output_size > Self::OutputSize::USIZE {\n                    return Err(InvalidOutputSize);\n                }\n                Ok(Self::new_with_params(&[], &[], 0, output_size))\n            }\n\n            #[inline]\n            fn finalize_variable_core(\n                &mut self,\n                buffer: &mut Buffer<Self>,\n                out: &mut Output<Self>,\n            ) {\n                self.t += buffer.get_pos() as u64;\n                let block = buffer.pad_with_zeros();\n                self.finalize_with_flag(block, 0, out);\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"Blake2sMac":["Clone","impl<OutSize> $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            /// Create new instance using provided key, salt, and persona.\n            ///\n            /// Key length should not be bigger than block size, salt and persona\n            /// length should not be bigger than quarter of block size. If any\n            /// of those conditions is false the method will return an error.\n            #[inline]\n            pub fn new_with_salt_and_personal(\n                key: &[u8],\n                salt: &[u8],\n                persona: &[u8],\n            ) -> Result<Self, InvalidLength> {\n                let kl = key.len();\n                let bs = <$hash as BlockSizeUser>::BlockSize::USIZE;\n                let qbs = bs / 4;\n                if kl > bs || salt.len() > qbs || persona.len() > qbs {\n                    return Err(InvalidLength);\n                }\n                let mut padded_key = Block::<$hash>::default();\n                padded_key[..kl].copy_from_slice(key);\n                Ok(Self {\n                    core: <$hash>::new_with_params(salt, persona, key.len(), OutSize::USIZE),\n                    buffer: LazyBuffer::new(&padded_key),\n                    #[cfg(feature = \"reset\")]\n                    key_block: {\n                        let mut t = Key::<Self>::default();\n                        t[..kl].copy_from_slice(key);\n                        t\n                    },\n                    _out: PhantomData,\n                })\n            }\n        }","impl<OutSize> FixedOutput for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size> + 'static,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            #[inline]\n            fn finalize_into(mut self, out: &mut Output<Self>) {\n                let Self { core, buffer, .. } = &mut self;\n                let mut full_res = Default::default();\n                core.finalize_variable_core(buffer, &mut full_res);\n                out.copy_from_slice(&full_res[..OutSize::USIZE]);\n            }\n        }","impl<OutSize> KeyInit for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            #[inline]\n            fn new(key: &Key<Self>) -> Self {\n                Self::new_from_slice(key).expect(\"Key has correct length\")\n            }\n\n            #[inline]\n            fn new_from_slice(key: &[u8]) -> Result<Self, InvalidLength> {\n                let kl = key.len();\n                if kl > <Self as KeySizeUser>::KeySize::USIZE {\n                    return Err(InvalidLength);\n                }\n                let mut padded_key = Block::<$hash>::default();\n                padded_key[..kl].copy_from_slice(key);\n                Ok(Self {\n                    core: <$hash>::new_with_params(&[], &[], key.len(), OutSize::USIZE),\n                    buffer: LazyBuffer::new(&padded_key),\n                    #[cfg(feature = \"reset\")]\n                    key_block: {\n                        let mut t = Key::<Self>::default();\n                        t[..kl].copy_from_slice(key);\n                        t\n                    },\n                    _out: PhantomData,\n                })\n            }\n        }","impl<OutSize> KeySizeUser for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            type KeySize = $max_size;\n        }","impl<OutSize> MacMarker for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n        }","impl<OutSize> OutputSizeUser for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size> + 'static,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            type OutputSize = OutSize;\n        }","impl<OutSize> Update for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            #[inline]\n            fn update(&mut self, input: &[u8]) {\n                let Self { core, buffer, .. } = self;\n                buffer.digest_blocks(input, |blocks| core.update_blocks(blocks));\n            }\n        }","impl<OutSize> fmt::Debug for $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                write!(f, \"{}{} {{ ... }}\", stringify!($name), OutSize::USIZE)\n            }\n        }"],"Blake2sVarCore":["Clone","impl $name {\n            #[inline(always)]\n            fn iv0() -> $vec {\n                $vec::new($IV[0], $IV[1], $IV[2], $IV[3])\n            }\n            #[inline(always)]\n            fn iv1() -> $vec {\n                $vec::new($IV[4], $IV[5], $IV[6], $IV[7])\n            }\n\n            /// Creates a new context with the full set of sequential-mode parameters.\n            pub fn new_with_params(\n                salt: &[u8],\n                persona: &[u8],\n                key_size: usize,\n                output_size: usize,\n            ) -> Self {\n                assert!(key_size <= $bytes::to_usize());\n                assert!(output_size <= $bytes::to_usize());\n\n                // The number of bytes needed to express two words.\n                let length = $bytes::to_usize() / 4;\n                assert!(salt.len() <= length);\n                assert!(persona.len() <= length);\n\n                // Build a parameter block\n                let mut p = [0 as $word; 8];\n                p[0] = 0x0101_0000 ^ ((key_size as $word) << 8) ^ (output_size as $word);\n\n                // salt is two words long\n                if salt.len() < length {\n                    let mut padded_salt =\n                        GenericArray::<u8, <$bytes as Div<U4>>::Output>::default();\n                    for i in 0..salt.len() {\n                        padded_salt[i] = salt[i];\n                    }\n                    p[4] = $word::from_le_bytes(padded_salt[0..length / 2].try_into().unwrap());\n                    p[5] = $word::from_le_bytes(\n                        padded_salt[length / 2..padded_salt.len()]\n                            .try_into()\n                            .unwrap(),\n                    );\n                } else {\n                    p[4] = $word::from_le_bytes(salt[0..salt.len() / 2].try_into().unwrap());\n                    p[5] =\n                        $word::from_le_bytes(salt[salt.len() / 2..salt.len()].try_into().unwrap());\n                }\n\n                // persona is also two words long\n                if persona.len() < length {\n                    let mut padded_persona =\n                        GenericArray::<u8, <$bytes as Div<U4>>::Output>::default();\n                    for i in 0..persona.len() {\n                        padded_persona[i] = persona[i];\n                    }\n                    p[6] = $word::from_le_bytes(padded_persona[0..length / 2].try_into().unwrap());\n                    p[7] = $word::from_le_bytes(\n                        padded_persona[length / 2..padded_persona.len()]\n                            .try_into()\n                            .unwrap(),\n                    );\n                } else {\n                    p[6] = $word::from_le_bytes(persona[0..length / 2].try_into().unwrap());\n                    p[7] = $word::from_le_bytes(\n                        persona[length / 2..persona.len()].try_into().unwrap(),\n                    );\n                }\n\n                let h = [\n                    Self::iv0() ^ $vec::new(p[0], p[1], p[2], p[3]),\n                    Self::iv1() ^ $vec::new(p[4], p[5], p[6], p[7]),\n                ];\n                $name {\n                    #[cfg(feature = \"reset\")]\n                    h0: h.clone(),\n                    h,\n                    t: 0,\n                }\n            }\n\n            fn finalize_with_flag(\n                &mut self,\n                final_block: &GenericArray<u8, $block_size>,\n                flag: $word,\n                out: &mut Output<Self>,\n            ) {\n                self.compress(final_block, !0, flag);\n                let buf = [self.h[0].to_le(), self.h[1].to_le()];\n                out.copy_from_slice(buf.as_bytes())\n            }\n\n            fn compress(&mut self, block: &Block<Self>, f0: $word, f1: $word) {\n                use $crate::consts::SIGMA;\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn quarter_round(v: &mut [$vec; 4], rd: u32, rb: u32, m: $vec) {\n                    v[0] = v[0].wrapping_add(v[1]).wrapping_add(m.from_le());\n                    v[3] = (v[3] ^ v[0]).rotate_right_const(rd);\n                    v[2] = v[2].wrapping_add(v[3]);\n                    v[1] = (v[1] ^ v[2]).rotate_right_const(rb);\n                }\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn shuffle(v: &mut [$vec; 4]) {\n                    v[1] = v[1].shuffle_left_1();\n                    v[2] = v[2].shuffle_left_2();\n                    v[3] = v[3].shuffle_left_3();\n                }\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn unshuffle(v: &mut [$vec; 4]) {\n                    v[1] = v[1].shuffle_right_1();\n                    v[2] = v[2].shuffle_right_2();\n                    v[3] = v[3].shuffle_right_3();\n                }\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn round(v: &mut [$vec; 4], m: &[$word; 16], s: &[usize; 16]) {\n                    quarter_round(v, $R1, $R2, $vec::gather(m, s[0], s[2], s[4], s[6]));\n                    quarter_round(v, $R3, $R4, $vec::gather(m, s[1], s[3], s[5], s[7]));\n\n                    shuffle(v);\n                    quarter_round(v, $R1, $R2, $vec::gather(m, s[8], s[10], s[12], s[14]));\n                    quarter_round(v, $R3, $R4, $vec::gather(m, s[9], s[11], s[13], s[15]));\n                    unshuffle(v);\n                }\n\n                let mut m: [$word; 16] = Default::default();\n                let n = core::mem::size_of::<$word>();\n                for (v, chunk) in m.iter_mut().zip(block.chunks_exact(n)) {\n                    *v = $word::from_ne_bytes(chunk.try_into().unwrap());\n                }\n                let h = &mut self.h;\n\n                let t0 = self.t as $word;\n                let t1 = match $bytes::to_u8() {\n                    64 => 0,\n                    32 => (self.t >> 32) as $word,\n                    _ => unreachable!(),\n                };\n\n                let mut v = [\n                    h[0],\n                    h[1],\n                    Self::iv0(),\n                    Self::iv1() ^ $vec::new(t0, t1, f0, f1),\n                ];\n\n                round(&mut v, &m, &SIGMA[0]);\n                round(&mut v, &m, &SIGMA[1]);\n                round(&mut v, &m, &SIGMA[2]);\n                round(&mut v, &m, &SIGMA[3]);\n                round(&mut v, &m, &SIGMA[4]);\n                round(&mut v, &m, &SIGMA[5]);\n                round(&mut v, &m, &SIGMA[6]);\n                round(&mut v, &m, &SIGMA[7]);\n                round(&mut v, &m, &SIGMA[8]);\n                round(&mut v, &m, &SIGMA[9]);\n                if $bytes::to_u8() == 64 {\n                    round(&mut v, &m, &SIGMA[0]);\n                    round(&mut v, &m, &SIGMA[1]);\n                }\n\n                h[0] = h[0] ^ (v[0] ^ v[2]);\n                h[1] = h[1] ^ (v[1] ^ v[3]);\n            }\n        }","impl AlgorithmName for $name {\n            #[inline]\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str($alg_name)\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $block_size;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Lazy;\n        }","impl HashMarker for $name {}","impl OutputSizeUser for $name {\n            type OutputSize = $bytes;\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.t += block.len() as u64;\n                    self.compress(block, 0, 0);\n                }\n            }\n        }","impl VariableOutputCore for $name {\n            const TRUNC_SIDE: TruncSide = TruncSide::Left;\n\n            #[inline]\n            fn new(output_size: usize) -> Result<Self, InvalidOutputSize> {\n                if output_size > Self::OutputSize::USIZE {\n                    return Err(InvalidOutputSize);\n                }\n                Ok(Self::new_with_params(&[], &[], 0, output_size))\n            }\n\n            #[inline]\n            fn finalize_variable_core(\n                &mut self,\n                buffer: &mut Buffer<Self>,\n                out: &mut Output<Self>,\n            ) {\n                self.t += buffer.get_pos() as u64;\n                let block = buffer.pad_with_zeros();\n                self.finalize_with_flag(block, 0, out);\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"simd::simdty::Simd16":["Clone","Copy","Debug","unsafe impl<T: Safe> Safe for Simd16<T> {}"],"simd::simdty::Simd2":["Clone","Copy","Debug","unsafe impl<T: Safe> Safe for Simd2<T> {}"],"simd::simdty::Simd32":["Clone","Copy","Debug","unsafe impl<T: Safe> Safe for Simd32<T> {}"],"simd::simdty::Simd4":["Clone","Copy","Debug","impl<T> Simd4<T> {\n    #[inline(always)]\n    pub fn new(e0: T, e1: T, e2: T, e3: T) -> Simd4<T> {\n        Simd4(e0, e1, e2, e3)\n    }\n}","unsafe impl<T: Safe> Safe for Simd4<T> {}"],"simd::simdty::Simd8":["Clone","Copy","Debug","unsafe impl<T: Safe> Safe for Simd8<T> {}"],"simd::simdty::u32x4":["impl Add for $vec {\n            type Output = Self;\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn add(self, rhs: Self) -> Self::Output {\n                unsafe { simdint::simd_add(self, rhs) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn add(self, rhs: Self) -> Self::Output {\n                $vec::new(\n                    self.0.wrapping_add(rhs.0),\n                    self.1.wrapping_add(rhs.1),\n                    self.2.wrapping_add(rhs.2),\n                    self.3.wrapping_add(rhs.3),\n                )\n            }\n        }","impl BitXor for $vec {\n            type Output = Self;\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn bitxor(self, rhs: Self) -> Self::Output {\n                unsafe { simdint::simd_xor(self, rhs) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn bitxor(self, rhs: Self) -> Self::Output {\n                $vec::new(\n                    self.0 ^ rhs.0,\n                    self.1 ^ rhs.1,\n                    self.2 ^ rhs.2,\n                    self.3 ^ rhs.3,\n                )\n            }\n        }","impl Shl<$vec> for $vec {\n            type Output = Self;\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn shl(self, rhs: Self) -> Self::Output {\n                unsafe { simdint::simd_shl(self, rhs) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn shl(self, rhs: Self) -> Self::Output {\n                $vec::new(\n                    self.0 << rhs.0,\n                    self.1 << rhs.1,\n                    self.2 << rhs.2,\n                    self.3 << rhs.3,\n                )\n            }\n        }","impl Shr<$vec> for $vec {\n            type Output = Self;\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn shr(self, rhs: Self) -> Self::Output {\n                unsafe { simdint::simd_shr(self, rhs) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn shr(self, rhs: Self) -> Self::Output {\n                $vec::new(\n                    self.0 >> rhs.0,\n                    self.1 >> rhs.1,\n                    self.2 >> rhs.2,\n                    self.3 >> rhs.3,\n                )\n            }\n        }","impl Vector4<$word> for $vec {\n            #[inline(always)]\n            fn gather(src: &[$word], i0: usize, i1: usize, i2: usize, i3: usize) -> Self {\n                $vec::new(src[i0], src[i1], src[i2], src[i3])\n            }\n\n            #[cfg(target_endian = \"little\")]\n            #[inline(always)]\n            fn from_le(self) -> Self {\n                self\n            }\n\n            #[cfg(not(target_endian = \"little\"))]\n            #[inline(always)]\n            fn from_le(self) -> Self {\n                $vec::new(\n                    $word::from_le(self.0),\n                    $word::from_le(self.1),\n                    $word::from_le(self.2),\n                    $word::from_le(self.3),\n                )\n            }\n\n            #[cfg(target_endian = \"little\")]\n            #[inline(always)]\n            fn to_le(self) -> Self {\n                self\n            }\n\n            #[cfg(not(target_endian = \"little\"))]\n            #[inline(always)]\n            fn to_le(self) -> Self {\n                $vec::new(\n                    self.0.to_le(),\n                    self.1.to_le(),\n                    self.2.to_le(),\n                    self.3.to_le(),\n                )\n            }\n\n            #[inline(always)]\n            fn wrapping_add(self, rhs: Self) -> Self {\n                self + rhs\n            }\n\n            #[inline(always)]\n            fn rotate_right_const(self, n: u32) -> Self {\n                simd_opt::$vec::rotate_right_const(self, n)\n            }\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn shuffle_left_1(self) -> Self {\n                use crate::simd::simdint::simd_shuffle4;\n                const IDX: [u32; 4] = [1, 2, 3, 0];\n                unsafe { simd_shuffle4(self, self, IDX) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn shuffle_left_1(self) -> Self {\n                $vec::new(self.1, self.2, self.3, self.0)\n            }\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn shuffle_left_2(self) -> Self {\n                use crate::simd::simdint::simd_shuffle4;\n                const IDX: [u32; 4] = [2, 3, 0, 1];\n                unsafe { simd_shuffle4(self, self, IDX) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn shuffle_left_2(self) -> Self {\n                $vec::new(self.2, self.3, self.0, self.1)\n            }\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn shuffle_left_3(self) -> Self {\n                use crate::simd::simdint::simd_shuffle4;\n                const IDX: [u32; 4] = [3, 0, 1, 2];\n                unsafe { simd_shuffle4(self, self, IDX) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn shuffle_left_3(self) -> Self {\n                $vec::new(self.3, self.0, self.1, self.2)\n            }\n        }"],"simd::simdty::u64x4":["impl Add for $vec {\n            type Output = Self;\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn add(self, rhs: Self) -> Self::Output {\n                unsafe { simdint::simd_add(self, rhs) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn add(self, rhs: Self) -> Self::Output {\n                $vec::new(\n                    self.0.wrapping_add(rhs.0),\n                    self.1.wrapping_add(rhs.1),\n                    self.2.wrapping_add(rhs.2),\n                    self.3.wrapping_add(rhs.3),\n                )\n            }\n        }","impl BitXor for $vec {\n            type Output = Self;\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn bitxor(self, rhs: Self) -> Self::Output {\n                unsafe { simdint::simd_xor(self, rhs) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn bitxor(self, rhs: Self) -> Self::Output {\n                $vec::new(\n                    self.0 ^ rhs.0,\n                    self.1 ^ rhs.1,\n                    self.2 ^ rhs.2,\n                    self.3 ^ rhs.3,\n                )\n            }\n        }","impl Shl<$vec> for $vec {\n            type Output = Self;\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn shl(self, rhs: Self) -> Self::Output {\n                unsafe { simdint::simd_shl(self, rhs) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn shl(self, rhs: Self) -> Self::Output {\n                $vec::new(\n                    self.0 << rhs.0,\n                    self.1 << rhs.1,\n                    self.2 << rhs.2,\n                    self.3 << rhs.3,\n                )\n            }\n        }","impl Shr<$vec> for $vec {\n            type Output = Self;\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn shr(self, rhs: Self) -> Self::Output {\n                unsafe { simdint::simd_shr(self, rhs) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn shr(self, rhs: Self) -> Self::Output {\n                $vec::new(\n                    self.0 >> rhs.0,\n                    self.1 >> rhs.1,\n                    self.2 >> rhs.2,\n                    self.3 >> rhs.3,\n                )\n            }\n        }","impl Vector4<$word> for $vec {\n            #[inline(always)]\n            fn gather(src: &[$word], i0: usize, i1: usize, i2: usize, i3: usize) -> Self {\n                $vec::new(src[i0], src[i1], src[i2], src[i3])\n            }\n\n            #[cfg(target_endian = \"little\")]\n            #[inline(always)]\n            fn from_le(self) -> Self {\n                self\n            }\n\n            #[cfg(not(target_endian = \"little\"))]\n            #[inline(always)]\n            fn from_le(self) -> Self {\n                $vec::new(\n                    $word::from_le(self.0),\n                    $word::from_le(self.1),\n                    $word::from_le(self.2),\n                    $word::from_le(self.3),\n                )\n            }\n\n            #[cfg(target_endian = \"little\")]\n            #[inline(always)]\n            fn to_le(self) -> Self {\n                self\n            }\n\n            #[cfg(not(target_endian = \"little\"))]\n            #[inline(always)]\n            fn to_le(self) -> Self {\n                $vec::new(\n                    self.0.to_le(),\n                    self.1.to_le(),\n                    self.2.to_le(),\n                    self.3.to_le(),\n                )\n            }\n\n            #[inline(always)]\n            fn wrapping_add(self, rhs: Self) -> Self {\n                self + rhs\n            }\n\n            #[inline(always)]\n            fn rotate_right_const(self, n: u32) -> Self {\n                simd_opt::$vec::rotate_right_const(self, n)\n            }\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn shuffle_left_1(self) -> Self {\n                use crate::simd::simdint::simd_shuffle4;\n                const IDX: [u32; 4] = [1, 2, 3, 0];\n                unsafe { simd_shuffle4(self, self, IDX) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn shuffle_left_1(self) -> Self {\n                $vec::new(self.1, self.2, self.3, self.0)\n            }\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn shuffle_left_2(self) -> Self {\n                use crate::simd::simdint::simd_shuffle4;\n                const IDX: [u32; 4] = [2, 3, 0, 1];\n                unsafe { simd_shuffle4(self, self, IDX) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn shuffle_left_2(self) -> Self {\n                $vec::new(self.2, self.3, self.0, self.1)\n            }\n\n            #[cfg(feature = \"simd\")]\n            #[inline(always)]\n            fn shuffle_left_3(self) -> Self {\n                use crate::simd::simdint::simd_shuffle4;\n                const IDX: [u32; 4] = [3, 0, 1, 2];\n                unsafe { simd_shuffle4(self, self, IDX) }\n            }\n\n            #[cfg(not(feature = \"simd\"))]\n            #[inline(always)]\n            fn shuffle_left_3(self) -> Self {\n                $vec::new(self.3, self.0, self.1, self.2)\n            }\n        }"]},"single_path_import":{"digest":"digest","digest::Digest":"Digest","simd::simdty::u32x4":"simd::u32x4","simd::simdty::u64x4":"simd::u64x4"},"srcs":{"<Blake2bMac<OutSize> as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                write!(f, \"{}{} {{ ... }}\", stringify!($name), OutSize::USIZE)\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2bMac<OutSize> as digest::FixedOutput>::finalize_into":["#[inline]\nfn finalize_into(mut self, out: &mut Output<Self>){\n                let Self { core, buffer, .. } = &mut self;\n                let mut full_res = Default::default();\n                core.finalize_variable_core(buffer, &mut full_res);\n                out.copy_from_slice(&full_res[..OutSize::USIZE]);\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2bMac<OutSize> as digest::KeyInit>::new":["#[inline]\nfn new(key: &Key<Self>) -> Self{\n                Self::new_from_slice(key).expect(\"Key has correct length\")\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2bMac<OutSize> as digest::KeyInit>::new_from_slice":["#[inline]\nfn new_from_slice(key: &[u8]) -> Result<Self, InvalidLength>{\n                let kl = key.len();\n                if kl > <Self as KeySizeUser>::KeySize::USIZE {\n                    return Err(InvalidLength);\n                }\n                let mut padded_key = Block::<$hash>::default();\n                padded_key[..kl].copy_from_slice(key);\n                Ok(Self {\n                    core: <$hash>::new_with_params(&[], &[], key.len(), OutSize::USIZE),\n                    buffer: LazyBuffer::new(&padded_key),\n                    #[cfg(feature = \"reset\")]\n                    key_block: {\n                        let mut t = Key::<Self>::default();\n                        t[..kl].copy_from_slice(key);\n                        t\n                    },\n                    _out: PhantomData,\n                })\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2bMac<OutSize> as digest::Update>::update":["#[inline]\nfn update(&mut self, input: &[u8]){\n                let Self { core, buffer, .. } = self;\n                buffer.digest_blocks(input, |blocks| core.update_blocks(blocks));\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2bVarCore as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2bVarCore as digest::core_api::AlgorithmName>::write_alg_name":["#[inline]\nfn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str($alg_name)\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2bVarCore as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.t += block.len() as u64;\n                    self.compress(block, 0, 0);\n                }\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2bVarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["#[inline]\nfn finalize_variable_core(\n                &mut self,\n                buffer: &mut Buffer<Self>,\n                out: &mut Output<Self>,\n            ){\n                self.t += buffer.get_pos() as u64;\n                let block = buffer.pad_with_zeros();\n                self.finalize_with_flag(block, 0, out);\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2bVarCore as digest::core_api::VariableOutputCore>::new":["#[inline]\nfn new(output_size: usize) -> Result<Self, InvalidOutputSize>{\n                if output_size > Self::OutputSize::USIZE {\n                    return Err(InvalidOutputSize);\n                }\n                Ok(Self::new_with_params(&[], &[], 0, output_size))\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2sMac<OutSize> as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                write!(f, \"{}{} {{ ... }}\", stringify!($name), OutSize::USIZE)\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2sMac<OutSize> as digest::FixedOutput>::finalize_into":["#[inline]\nfn finalize_into(mut self, out: &mut Output<Self>){\n                let Self { core, buffer, .. } = &mut self;\n                let mut full_res = Default::default();\n                core.finalize_variable_core(buffer, &mut full_res);\n                out.copy_from_slice(&full_res[..OutSize::USIZE]);\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2sMac<OutSize> as digest::KeyInit>::new":["#[inline]\nfn new(key: &Key<Self>) -> Self{\n                Self::new_from_slice(key).expect(\"Key has correct length\")\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2sMac<OutSize> as digest::KeyInit>::new_from_slice":["#[inline]\nfn new_from_slice(key: &[u8]) -> Result<Self, InvalidLength>{\n                let kl = key.len();\n                if kl > <Self as KeySizeUser>::KeySize::USIZE {\n                    return Err(InvalidLength);\n                }\n                let mut padded_key = Block::<$hash>::default();\n                padded_key[..kl].copy_from_slice(key);\n                Ok(Self {\n                    core: <$hash>::new_with_params(&[], &[], key.len(), OutSize::USIZE),\n                    buffer: LazyBuffer::new(&padded_key),\n                    #[cfg(feature = \"reset\")]\n                    key_block: {\n                        let mut t = Key::<Self>::default();\n                        t[..kl].copy_from_slice(key);\n                        t\n                    },\n                    _out: PhantomData,\n                })\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2sMac<OutSize> as digest::Update>::update":["#[inline]\nfn update(&mut self, input: &[u8]){\n                let Self { core, buffer, .. } = self;\n                buffer.digest_blocks(input, |blocks| core.update_blocks(blocks));\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2sVarCore as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2sVarCore as digest::core_api::AlgorithmName>::write_alg_name":["#[inline]\nfn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str($alg_name)\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2sVarCore as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.t += block.len() as u64;\n                    self.compress(block, 0, 0);\n                }\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2sVarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["#[inline]\nfn finalize_variable_core(\n                &mut self,\n                buffer: &mut Buffer<Self>,\n                out: &mut Output<Self>,\n            ){\n                self.t += buffer.get_pos() as u64;\n                let block = buffer.pad_with_zeros();\n                self.finalize_with_flag(block, 0, out);\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<Blake2sVarCore as digest::core_api::VariableOutputCore>::new":["#[inline]\nfn new(output_size: usize) -> Result<Self, InvalidOutputSize>{\n                if output_size > Self::OutputSize::USIZE {\n                    return Err(InvalidOutputSize);\n                }\n                Ok(Self::new_with_params(&[], &[], 0, output_size))\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"<[T] as as_bytes::AsBytes>::as_bytes":["#[inline]\nfn as_bytes(&self) -> &[u8]{\n        unsafe {\n            slice::from_raw_parts(self.as_ptr() as *const u8, self.len() * mem::size_of::<T>())\n        }\n    }","Real(LocalPath(\"blake2/src/as_bytes.rs\"))"],"<[T] as as_bytes::AsBytes>::as_mut_bytes":["#[inline]\nfn as_mut_bytes(&mut self) -> &mut [u8]{\n        unsafe {\n            slice::from_raw_parts_mut(\n                self.as_mut_ptr() as *mut u8,\n                self.len() * mem::size_of::<T>(),\n            )\n        }\n    }","Real(LocalPath(\"blake2/src/as_bytes.rs\"))"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::from_le":["#[cfg(target_endian = \"little\")]\n#[inline(always)]\nfn from_le(self) -> Self{\n                self\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::gather":["#[inline(always)]\nfn gather(src: &[$word], i0: usize, i1: usize, i2: usize, i3: usize) -> Self{\n                $vec::new(src[i0], src[i1], src[i2], src[i3])\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::rotate_right_const":["#[inline(always)]\nfn rotate_right_const(self, n: u32) -> Self{\n                simd_opt::$vec::rotate_right_const(self, n)\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::shuffle_left_1":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn shuffle_left_1(self) -> Self{\n                $vec::new(self.1, self.2, self.3, self.0)\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::shuffle_left_2":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn shuffle_left_2(self) -> Self{\n                $vec::new(self.2, self.3, self.0, self.1)\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::shuffle_left_3":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn shuffle_left_3(self) -> Self{\n                $vec::new(self.3, self.0, self.1, self.2)\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::to_le":["#[cfg(target_endian = \"little\")]\n#[inline(always)]\nfn to_le(self) -> Self{\n                self\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::wrapping_add":["#[inline(always)]\nfn wrapping_add(self, rhs: Self) -> Self{\n                self + rhs\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::from_le":["#[cfg(target_endian = \"little\")]\n#[inline(always)]\nfn from_le(self) -> Self{\n                self\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::gather":["#[inline(always)]\nfn gather(src: &[$word], i0: usize, i1: usize, i2: usize, i3: usize) -> Self{\n                $vec::new(src[i0], src[i1], src[i2], src[i3])\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::rotate_right_const":["#[inline(always)]\nfn rotate_right_const(self, n: u32) -> Self{\n                simd_opt::$vec::rotate_right_const(self, n)\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::shuffle_left_1":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn shuffle_left_1(self) -> Self{\n                $vec::new(self.1, self.2, self.3, self.0)\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::shuffle_left_2":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn shuffle_left_2(self) -> Self{\n                $vec::new(self.2, self.3, self.0, self.1)\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::shuffle_left_3":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn shuffle_left_3(self) -> Self{\n                $vec::new(self.3, self.0, self.1, self.2)\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::to_le":["#[cfg(target_endian = \"little\")]\n#[inline(always)]\nfn to_le(self) -> Self{\n                self\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::wrapping_add":["#[inline(always)]\nfn wrapping_add(self, rhs: Self) -> Self{\n                self + rhs\n            }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"Blake2bMac":["#[doc=$doc]\npub struct $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            core: $hash,\n            buffer: LazyBuffer<<$hash as BlockSizeUser>::BlockSize>,\n            #[cfg(feature = \"reset\")]\n            key_block: Key<Self>,\n            _out: PhantomData<OutSize>,\n        }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2bMac::<OutSize>::new_with_salt_and_personal":["/// Create new instance using provided key, salt, and persona.\n///\n/// Key length should not be bigger than block size, salt and persona\n/// length should not be bigger than quarter of block size. If any\n/// of those conditions is false the method will return an error.\n#[inline]\npub fn new_with_salt_and_personal(\n                key: &[u8],\n                salt: &[u8],\n                persona: &[u8],\n            ) -> Result<Self, InvalidLength>{\n                let kl = key.len();\n                let bs = <$hash as BlockSizeUser>::BlockSize::USIZE;\n                let qbs = bs / 4;\n                if kl > bs || salt.len() > qbs || persona.len() > qbs {\n                    return Err(InvalidLength);\n                }\n                let mut padded_key = Block::<$hash>::default();\n                padded_key[..kl].copy_from_slice(key);\n                Ok(Self {\n                    core: <$hash>::new_with_params(salt, persona, key.len(), OutSize::USIZE),\n                    buffer: LazyBuffer::new(&padded_key),\n                    #[cfg(feature = \"reset\")]\n                    key_block: {\n                        let mut t = Key::<Self>::default();\n                        t[..kl].copy_from_slice(key);\n                        t\n                    },\n                    _out: PhantomData,\n                })\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2bVarCore":["#[doc=$vardoc]\npub struct $name {\n            h: [$vec; 2],\n            t: u64,\n            #[cfg(feature = \"reset\")]\n            h0: [$vec; 2],\n        }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2bVarCore::compress":["fn compress(&mut self, block: &Block<Self>, f0: $word, f1: $word){\n                use $crate::consts::SIGMA;\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn quarter_round(v: &mut [$vec; 4], rd: u32, rb: u32, m: $vec) {\n                    v[0] = v[0].wrapping_add(v[1]).wrapping_add(m.from_le());\n                    v[3] = (v[3] ^ v[0]).rotate_right_const(rd);\n                    v[2] = v[2].wrapping_add(v[3]);\n                    v[1] = (v[1] ^ v[2]).rotate_right_const(rb);\n                }\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn shuffle(v: &mut [$vec; 4]) {\n                    v[1] = v[1].shuffle_left_1();\n                    v[2] = v[2].shuffle_left_2();\n                    v[3] = v[3].shuffle_left_3();\n                }\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn unshuffle(v: &mut [$vec; 4]) {\n                    v[1] = v[1].shuffle_right_1();\n                    v[2] = v[2].shuffle_right_2();\n                    v[3] = v[3].shuffle_right_3();\n                }\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn round(v: &mut [$vec; 4], m: &[$word; 16], s: &[usize; 16]) {\n                    quarter_round(v, $R1, $R2, $vec::gather(m, s[0], s[2], s[4], s[6]));\n                    quarter_round(v, $R3, $R4, $vec::gather(m, s[1], s[3], s[5], s[7]));\n\n                    shuffle(v);\n                    quarter_round(v, $R1, $R2, $vec::gather(m, s[8], s[10], s[12], s[14]));\n                    quarter_round(v, $R3, $R4, $vec::gather(m, s[9], s[11], s[13], s[15]));\n                    unshuffle(v);\n                }\n\n                let mut m: [$word; 16] = Default::default();\n                let n = core::mem::size_of::<$word>();\n                for (v, chunk) in m.iter_mut().zip(block.chunks_exact(n)) {\n                    *v = $word::from_ne_bytes(chunk.try_into().unwrap());\n                }\n                let h = &mut self.h;\n\n                let t0 = self.t as $word;\n                let t1 = match $bytes::to_u8() {\n                    64 => 0,\n                    32 => (self.t >> 32) as $word,\n                    _ => unreachable!(),\n                };\n\n                let mut v = [\n                    h[0],\n                    h[1],\n                    Self::iv0(),\n                    Self::iv1() ^ $vec::new(t0, t1, f0, f1),\n                ];\n\n                round(&mut v, &m, &SIGMA[0]);\n                round(&mut v, &m, &SIGMA[1]);\n                round(&mut v, &m, &SIGMA[2]);\n                round(&mut v, &m, &SIGMA[3]);\n                round(&mut v, &m, &SIGMA[4]);\n                round(&mut v, &m, &SIGMA[5]);\n                round(&mut v, &m, &SIGMA[6]);\n                round(&mut v, &m, &SIGMA[7]);\n                round(&mut v, &m, &SIGMA[8]);\n                round(&mut v, &m, &SIGMA[9]);\n                if $bytes::to_u8() == 64 {\n                    round(&mut v, &m, &SIGMA[0]);\n                    round(&mut v, &m, &SIGMA[1]);\n                }\n\n                h[0] = h[0] ^ (v[0] ^ v[2]);\n                h[1] = h[1] ^ (v[1] ^ v[3]);\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2bVarCore::compress::quarter_round":["inline(always)\nfn quarter_round(v: &mut [$vec; 4], rd: u32, rb: u32, m: $vec){\n                    v[0] = v[0].wrapping_add(v[1]).wrapping_add(m.from_le());\n                    v[3] = (v[3] ^ v[0]).rotate_right_const(rd);\n                    v[2] = v[2].wrapping_add(v[3]);\n                    v[1] = (v[1] ^ v[2]).rotate_right_const(rb);\n                }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2bVarCore::compress::round":["inline(always)\nfn round(v: &mut [$vec; 4], m: &[$word; 16], s: &[usize; 16]){\n                    quarter_round(v, $R1, $R2, $vec::gather(m, s[0], s[2], s[4], s[6]));\n                    quarter_round(v, $R3, $R4, $vec::gather(m, s[1], s[3], s[5], s[7]));\n\n                    shuffle(v);\n                    quarter_round(v, $R1, $R2, $vec::gather(m, s[8], s[10], s[12], s[14]));\n                    quarter_round(v, $R3, $R4, $vec::gather(m, s[9], s[11], s[13], s[15]));\n                    unshuffle(v);\n                }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2bVarCore::compress::shuffle":["inline(always)\nfn shuffle(v: &mut [$vec; 4]){\n                    v[1] = v[1].shuffle_left_1();\n                    v[2] = v[2].shuffle_left_2();\n                    v[3] = v[3].shuffle_left_3();\n                }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2bVarCore::compress::unshuffle":["inline(always)\nfn unshuffle(v: &mut [$vec; 4]){\n                    v[1] = v[1].shuffle_right_1();\n                    v[2] = v[2].shuffle_right_2();\n                    v[3] = v[3].shuffle_right_3();\n                }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2bVarCore::finalize_with_flag":["fn finalize_with_flag(\n                &mut self,\n                final_block: &GenericArray<u8, $block_size>,\n                flag: $word,\n                out: &mut Output<Self>,\n            ){\n                self.compress(final_block, !0, flag);\n                let buf = [self.h[0].to_le(), self.h[1].to_le()];\n                out.copy_from_slice(buf.as_bytes())\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2bVarCore::iv0":["#[inline(always)]\nfn iv0() -> $vec{\n                $vec::new($IV[0], $IV[1], $IV[2], $IV[3])\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2bVarCore::iv1":["#[inline(always)]\nfn iv1() -> $vec{\n                $vec::new($IV[4], $IV[5], $IV[6], $IV[7])\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2bVarCore::new_with_params":["/// Creates a new context with the full set of sequential-mode parameters.\npub fn new_with_params(\n                salt: &[u8],\n                persona: &[u8],\n                key_size: usize,\n                output_size: usize,\n            ) -> Self{\n                assert!(key_size <= $bytes::to_usize());\n                assert!(output_size <= $bytes::to_usize());\n\n                // The number of bytes needed to express two words.\n                let length = $bytes::to_usize() / 4;\n                assert!(salt.len() <= length);\n                assert!(persona.len() <= length);\n\n                // Build a parameter block\n                let mut p = [0 as $word; 8];\n                p[0] = 0x0101_0000 ^ ((key_size as $word) << 8) ^ (output_size as $word);\n\n                // salt is two words long\n                if salt.len() < length {\n                    let mut padded_salt =\n                        GenericArray::<u8, <$bytes as Div<U4>>::Output>::default();\n                    for i in 0..salt.len() {\n                        padded_salt[i] = salt[i];\n                    }\n                    p[4] = $word::from_le_bytes(padded_salt[0..length / 2].try_into().unwrap());\n                    p[5] = $word::from_le_bytes(\n                        padded_salt[length / 2..padded_salt.len()]\n                            .try_into()\n                            .unwrap(),\n                    );\n                } else {\n                    p[4] = $word::from_le_bytes(salt[0..salt.len() / 2].try_into().unwrap());\n                    p[5] =\n                        $word::from_le_bytes(salt[salt.len() / 2..salt.len()].try_into().unwrap());\n                }\n\n                // persona is also two words long\n                if persona.len() < length {\n                    let mut padded_persona =\n                        GenericArray::<u8, <$bytes as Div<U4>>::Output>::default();\n                    for i in 0..persona.len() {\n                        padded_persona[i] = persona[i];\n                    }\n                    p[6] = $word::from_le_bytes(padded_persona[0..length / 2].try_into().unwrap());\n                    p[7] = $word::from_le_bytes(\n                        padded_persona[length / 2..padded_persona.len()]\n                            .try_into()\n                            .unwrap(),\n                    );\n                } else {\n                    p[6] = $word::from_le_bytes(persona[0..length / 2].try_into().unwrap());\n                    p[7] = $word::from_le_bytes(\n                        persona[length / 2..persona.len()].try_into().unwrap(),\n                    );\n                }\n\n                let h = [\n                    Self::iv0() ^ $vec::new(p[0], p[1], p[2], p[3]),\n                    Self::iv1() ^ $vec::new(p[4], p[5], p[6], p[7]),\n                ];\n                $name {\n                    #[cfg(feature = \"reset\")]\n                    h0: h.clone(),\n                    h,\n                    t: 0,\n                }\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2sMac":["#[doc=$doc]\npub struct $name<OutSize>\n        where\n            OutSize: ArrayLength<u8> + IsLessOrEqual<$max_size>,\n            LeEq<OutSize, $max_size>: NonZero,\n        {\n            core: $hash,\n            buffer: LazyBuffer<<$hash as BlockSizeUser>::BlockSize>,\n            #[cfg(feature = \"reset\")]\n            key_block: Key<Self>,\n            _out: PhantomData<OutSize>,\n        }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2sMac::<OutSize>::new_with_salt_and_personal":["/// Create new instance using provided key, salt, and persona.\n///\n/// Key length should not be bigger than block size, salt and persona\n/// length should not be bigger than quarter of block size. If any\n/// of those conditions is false the method will return an error.\n#[inline]\npub fn new_with_salt_and_personal(\n                key: &[u8],\n                salt: &[u8],\n                persona: &[u8],\n            ) -> Result<Self, InvalidLength>{\n                let kl = key.len();\n                let bs = <$hash as BlockSizeUser>::BlockSize::USIZE;\n                let qbs = bs / 4;\n                if kl > bs || salt.len() > qbs || persona.len() > qbs {\n                    return Err(InvalidLength);\n                }\n                let mut padded_key = Block::<$hash>::default();\n                padded_key[..kl].copy_from_slice(key);\n                Ok(Self {\n                    core: <$hash>::new_with_params(salt, persona, key.len(), OutSize::USIZE),\n                    buffer: LazyBuffer::new(&padded_key),\n                    #[cfg(feature = \"reset\")]\n                    key_block: {\n                        let mut t = Key::<Self>::default();\n                        t[..kl].copy_from_slice(key);\n                        t\n                    },\n                    _out: PhantomData,\n                })\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2sVarCore":["#[doc=$vardoc]\npub struct $name {\n            h: [$vec; 2],\n            t: u64,\n            #[cfg(feature = \"reset\")]\n            h0: [$vec; 2],\n        }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2sVarCore::compress":["fn compress(&mut self, block: &Block<Self>, f0: $word, f1: $word){\n                use $crate::consts::SIGMA;\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn quarter_round(v: &mut [$vec; 4], rd: u32, rb: u32, m: $vec) {\n                    v[0] = v[0].wrapping_add(v[1]).wrapping_add(m.from_le());\n                    v[3] = (v[3] ^ v[0]).rotate_right_const(rd);\n                    v[2] = v[2].wrapping_add(v[3]);\n                    v[1] = (v[1] ^ v[2]).rotate_right_const(rb);\n                }\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn shuffle(v: &mut [$vec; 4]) {\n                    v[1] = v[1].shuffle_left_1();\n                    v[2] = v[2].shuffle_left_2();\n                    v[3] = v[3].shuffle_left_3();\n                }\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn unshuffle(v: &mut [$vec; 4]) {\n                    v[1] = v[1].shuffle_right_1();\n                    v[2] = v[2].shuffle_right_2();\n                    v[3] = v[3].shuffle_right_3();\n                }\n\n                #[cfg_attr(not(feature = \"size_opt\"), inline(always))]\n                fn round(v: &mut [$vec; 4], m: &[$word; 16], s: &[usize; 16]) {\n                    quarter_round(v, $R1, $R2, $vec::gather(m, s[0], s[2], s[4], s[6]));\n                    quarter_round(v, $R3, $R4, $vec::gather(m, s[1], s[3], s[5], s[7]));\n\n                    shuffle(v);\n                    quarter_round(v, $R1, $R2, $vec::gather(m, s[8], s[10], s[12], s[14]));\n                    quarter_round(v, $R3, $R4, $vec::gather(m, s[9], s[11], s[13], s[15]));\n                    unshuffle(v);\n                }\n\n                let mut m: [$word; 16] = Default::default();\n                let n = core::mem::size_of::<$word>();\n                for (v, chunk) in m.iter_mut().zip(block.chunks_exact(n)) {\n                    *v = $word::from_ne_bytes(chunk.try_into().unwrap());\n                }\n                let h = &mut self.h;\n\n                let t0 = self.t as $word;\n                let t1 = match $bytes::to_u8() {\n                    64 => 0,\n                    32 => (self.t >> 32) as $word,\n                    _ => unreachable!(),\n                };\n\n                let mut v = [\n                    h[0],\n                    h[1],\n                    Self::iv0(),\n                    Self::iv1() ^ $vec::new(t0, t1, f0, f1),\n                ];\n\n                round(&mut v, &m, &SIGMA[0]);\n                round(&mut v, &m, &SIGMA[1]);\n                round(&mut v, &m, &SIGMA[2]);\n                round(&mut v, &m, &SIGMA[3]);\n                round(&mut v, &m, &SIGMA[4]);\n                round(&mut v, &m, &SIGMA[5]);\n                round(&mut v, &m, &SIGMA[6]);\n                round(&mut v, &m, &SIGMA[7]);\n                round(&mut v, &m, &SIGMA[8]);\n                round(&mut v, &m, &SIGMA[9]);\n                if $bytes::to_u8() == 64 {\n                    round(&mut v, &m, &SIGMA[0]);\n                    round(&mut v, &m, &SIGMA[1]);\n                }\n\n                h[0] = h[0] ^ (v[0] ^ v[2]);\n                h[1] = h[1] ^ (v[1] ^ v[3]);\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2sVarCore::compress::quarter_round":["inline(always)\nfn quarter_round(v: &mut [$vec; 4], rd: u32, rb: u32, m: $vec){\n                    v[0] = v[0].wrapping_add(v[1]).wrapping_add(m.from_le());\n                    v[3] = (v[3] ^ v[0]).rotate_right_const(rd);\n                    v[2] = v[2].wrapping_add(v[3]);\n                    v[1] = (v[1] ^ v[2]).rotate_right_const(rb);\n                }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2sVarCore::compress::round":["inline(always)\nfn round(v: &mut [$vec; 4], m: &[$word; 16], s: &[usize; 16]){\n                    quarter_round(v, $R1, $R2, $vec::gather(m, s[0], s[2], s[4], s[6]));\n                    quarter_round(v, $R3, $R4, $vec::gather(m, s[1], s[3], s[5], s[7]));\n\n                    shuffle(v);\n                    quarter_round(v, $R1, $R2, $vec::gather(m, s[8], s[10], s[12], s[14]));\n                    quarter_round(v, $R3, $R4, $vec::gather(m, s[9], s[11], s[13], s[15]));\n                    unshuffle(v);\n                }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2sVarCore::compress::shuffle":["inline(always)\nfn shuffle(v: &mut [$vec; 4]){\n                    v[1] = v[1].shuffle_left_1();\n                    v[2] = v[2].shuffle_left_2();\n                    v[3] = v[3].shuffle_left_3();\n                }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2sVarCore::compress::unshuffle":["inline(always)\nfn unshuffle(v: &mut [$vec; 4]){\n                    v[1] = v[1].shuffle_right_1();\n                    v[2] = v[2].shuffle_right_2();\n                    v[3] = v[3].shuffle_right_3();\n                }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2sVarCore::finalize_with_flag":["fn finalize_with_flag(\n                &mut self,\n                final_block: &GenericArray<u8, $block_size>,\n                flag: $word,\n                out: &mut Output<Self>,\n            ){\n                self.compress(final_block, !0, flag);\n                let buf = [self.h[0].to_le(), self.h[1].to_le()];\n                out.copy_from_slice(buf.as_bytes())\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2sVarCore::iv0":["#[inline(always)]\nfn iv0() -> $vec{\n                $vec::new($IV[0], $IV[1], $IV[2], $IV[3])\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2sVarCore::iv1":["#[inline(always)]\nfn iv1() -> $vec{\n                $vec::new($IV[4], $IV[5], $IV[6], $IV[7])\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"Blake2sVarCore::new_with_params":["/// Creates a new context with the full set of sequential-mode parameters.\npub fn new_with_params(\n                salt: &[u8],\n                persona: &[u8],\n                key_size: usize,\n                output_size: usize,\n            ) -> Self{\n                assert!(key_size <= $bytes::to_usize());\n                assert!(output_size <= $bytes::to_usize());\n\n                // The number of bytes needed to express two words.\n                let length = $bytes::to_usize() / 4;\n                assert!(salt.len() <= length);\n                assert!(persona.len() <= length);\n\n                // Build a parameter block\n                let mut p = [0 as $word; 8];\n                p[0] = 0x0101_0000 ^ ((key_size as $word) << 8) ^ (output_size as $word);\n\n                // salt is two words long\n                if salt.len() < length {\n                    let mut padded_salt =\n                        GenericArray::<u8, <$bytes as Div<U4>>::Output>::default();\n                    for i in 0..salt.len() {\n                        padded_salt[i] = salt[i];\n                    }\n                    p[4] = $word::from_le_bytes(padded_salt[0..length / 2].try_into().unwrap());\n                    p[5] = $word::from_le_bytes(\n                        padded_salt[length / 2..padded_salt.len()]\n                            .try_into()\n                            .unwrap(),\n                    );\n                } else {\n                    p[4] = $word::from_le_bytes(salt[0..salt.len() / 2].try_into().unwrap());\n                    p[5] =\n                        $word::from_le_bytes(salt[salt.len() / 2..salt.len()].try_into().unwrap());\n                }\n\n                // persona is also two words long\n                if persona.len() < length {\n                    let mut padded_persona =\n                        GenericArray::<u8, <$bytes as Div<U4>>::Output>::default();\n                    for i in 0..persona.len() {\n                        padded_persona[i] = persona[i];\n                    }\n                    p[6] = $word::from_le_bytes(padded_persona[0..length / 2].try_into().unwrap());\n                    p[7] = $word::from_le_bytes(\n                        padded_persona[length / 2..padded_persona.len()]\n                            .try_into()\n                            .unwrap(),\n                    );\n                } else {\n                    p[6] = $word::from_le_bytes(persona[0..length / 2].try_into().unwrap());\n                    p[7] = $word::from_le_bytes(\n                        persona[length / 2..persona.len()].try_into().unwrap(),\n                    );\n                }\n\n                let h = [\n                    Self::iv0() ^ $vec::new(p[0], p[1], p[2], p[3]),\n                    Self::iv1() ^ $vec::new(p[4], p[5], p[6], p[7]),\n                ];\n                $name {\n                    #[cfg(feature = \"reset\")]\n                    h0: h.clone(),\n                    h,\n                    t: 0,\n                }\n            }","Real(LocalPath(\"blake2/src/macros.rs\"))"],"as_bytes::AsBytes":["pub trait AsBytes {\n    fn as_bytes(&self) -> &[u8];\n    fn as_mut_bytes(&mut self) -> &mut [u8];\n}","Real(LocalPath(\"blake2/src/as_bytes.rs\"))"],"as_bytes::Safe":["#[allow(clippy::missing_safety_doc)]\npub unsafe trait Safe {}","Real(LocalPath(\"blake2/src/as_bytes.rs\"))"],"simd::Vector4":["pub trait Vector4<T>: Copy {\n    fn gather(src: &[T], i0: usize, i1: usize, i2: usize, i3: usize) -> Self;\n\n    #[allow(clippy::wrong_self_convention)]\n    fn from_le(self) -> Self;\n    fn to_le(self) -> Self;\n\n    fn wrapping_add(self, rhs: Self) -> Self;\n\n    fn rotate_right_const(self, n: u32) -> Self;\n\n    fn shuffle_left_1(self) -> Self;\n    fn shuffle_left_2(self) -> Self;\n    fn shuffle_left_3(self) -> Self;\n\n    #[inline(always)]\n    fn shuffle_right_1(self) -> Self {\n        self.shuffle_left_3()\n    }\n    #[inline(always)]\n    fn shuffle_right_2(self) -> Self {\n        self.shuffle_left_2()\n    }\n    #[inline(always)]\n    fn shuffle_right_3(self) -> Self {\n        self.shuffle_left_1()\n    }\n}","Real(LocalPath(\"blake2/src/simd.rs\"))"],"simd::Vector4::shuffle_right_1":["#[inline(always)]\nfn shuffle_right_1(self) -> Self{\n        self.shuffle_left_3()\n    }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"simd::Vector4::shuffle_right_2":["#[inline(always)]\nfn shuffle_right_2(self) -> Self{\n        self.shuffle_left_2()\n    }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"simd::Vector4::shuffle_right_3":["#[inline(always)]\nfn shuffle_right_3(self) -> Self{\n        self.shuffle_left_1()\n    }","Real(LocalPath(\"blake2/src/simd.rs\"))"],"simd::simd_opt::u32x4::rotate_right_const":["#[inline(always)]\npub fn rotate_right_const(vec: $vec, n: u32) -> $vec{\n                $vec::new(\n                    vec.0.rotate_right(n),\n                    vec.1.rotate_right(n),\n                    vec.2.rotate_right(n),\n                    vec.3.rotate_right(n),\n                )\n            }","Real(LocalPath(\"blake2/src/simd/simd_opt.rs\"))"],"simd::simd_opt::u64x4::rotate_right_const":["#[inline(always)]\npub fn rotate_right_const(vec: $vec, n: u32) -> $vec{\n                $vec::new(\n                    vec.0.rotate_right(n),\n                    vec.1.rotate_right(n),\n                    vec.2.rotate_right(n),\n                    vec.3.rotate_right(n),\n                )\n            }","Real(LocalPath(\"blake2/src/simd/simd_opt.rs\"))"],"simd::simdop::<impl core::ops::Add for simd::simdty::Simd4<u32>>::add":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn add(self, rhs: Self) -> Self::Output{\n                $vec::new(\n                    self.0.wrapping_add(rhs.0),\n                    self.1.wrapping_add(rhs.1),\n                    self.2.wrapping_add(rhs.2),\n                    self.3.wrapping_add(rhs.3),\n                )\n            }","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))"],"simd::simdop::<impl core::ops::Add for simd::simdty::Simd4<u64>>::add":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn add(self, rhs: Self) -> Self::Output{\n                $vec::new(\n                    self.0.wrapping_add(rhs.0),\n                    self.1.wrapping_add(rhs.1),\n                    self.2.wrapping_add(rhs.2),\n                    self.3.wrapping_add(rhs.3),\n                )\n            }","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))"],"simd::simdop::<impl core::ops::BitXor for simd::simdty::Simd4<u32>>::bitxor":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn bitxor(self, rhs: Self) -> Self::Output{\n                $vec::new(\n                    self.0 ^ rhs.0,\n                    self.1 ^ rhs.1,\n                    self.2 ^ rhs.2,\n                    self.3 ^ rhs.3,\n                )\n            }","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))"],"simd::simdop::<impl core::ops::BitXor for simd::simdty::Simd4<u64>>::bitxor":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn bitxor(self, rhs: Self) -> Self::Output{\n                $vec::new(\n                    self.0 ^ rhs.0,\n                    self.1 ^ rhs.1,\n                    self.2 ^ rhs.2,\n                    self.3 ^ rhs.3,\n                )\n            }","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))"],"simd::simdop::<impl core::ops::Shl for simd::simdty::Simd4<u32>>::shl":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn shl(self, rhs: Self) -> Self::Output{\n                $vec::new(\n                    self.0 << rhs.0,\n                    self.1 << rhs.1,\n                    self.2 << rhs.2,\n                    self.3 << rhs.3,\n                )\n            }","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))"],"simd::simdop::<impl core::ops::Shl for simd::simdty::Simd4<u64>>::shl":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn shl(self, rhs: Self) -> Self::Output{\n                $vec::new(\n                    self.0 << rhs.0,\n                    self.1 << rhs.1,\n                    self.2 << rhs.2,\n                    self.3 << rhs.3,\n                )\n            }","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))"],"simd::simdop::<impl core::ops::Shr for simd::simdty::Simd4<u32>>::shr":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn shr(self, rhs: Self) -> Self::Output{\n                $vec::new(\n                    self.0 >> rhs.0,\n                    self.1 >> rhs.1,\n                    self.2 >> rhs.2,\n                    self.3 >> rhs.3,\n                )\n            }","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))"],"simd::simdop::<impl core::ops::Shr for simd::simdty::Simd4<u64>>::shr":["#[cfg(not(feature = \"simd\"))]\n#[inline(always)]\nfn shr(self, rhs: Self) -> Self::Output{\n                $vec::new(\n                    self.0 >> rhs.0,\n                    self.1 >> rhs.1,\n                    self.2 >> rhs.2,\n                    self.3 >> rhs.3,\n                )\n            }","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))"],"simd::simdty::Simd16":["#[repr(C)]\npub struct Simd16<T>(pub T, pub T, pub T, pub T,\n                         pub T, pub T, pub T, pub T,\n                         pub T, pub T, pub T, pub T,\n                         pub T, pub T, pub T, pub T);","Real(LocalPath(\"blake2/src/simd/simdty.rs\"))"],"simd::simdty::Simd2":["#[repr(C)]\npub struct Simd2<T>(pub T, pub T);","Real(LocalPath(\"blake2/src/simd/simdty.rs\"))"],"simd::simdty::Simd32":["#[repr(C)]\npub struct Simd32<T>(pub T, pub T, pub T, pub T,\n                         pub T, pub T, pub T, pub T,\n                         pub T, pub T, pub T, pub T,\n                         pub T, pub T, pub T, pub T,\n                         pub T, pub T, pub T, pub T,\n                         pub T, pub T, pub T, pub T,\n                         pub T, pub T, pub T, pub T,\n                         pub T, pub T, pub T, pub T);","Real(LocalPath(\"blake2/src/simd/simdty.rs\"))"],"simd::simdty::Simd4":["#[repr(C)]\npub struct Simd4<T>(pub T, pub T, pub T, pub T);","Real(LocalPath(\"blake2/src/simd/simdty.rs\"))"],"simd::simdty::Simd4::<T>::new":["#[inline(always)]\npub fn new(e0: T, e1: T, e2: T, e3: T) -> Simd4<T>{\n        Simd4(e0, e1, e2, e3)\n    }","Real(LocalPath(\"blake2/src/simd/simdty.rs\"))"],"simd::simdty::Simd8":["#[repr(C)]\npub struct Simd8<T>(pub T, pub T, pub T, pub T,\n                        pub T, pub T, pub T, pub T);","Real(LocalPath(\"blake2/src/simd/simdty.rs\"))"]},"struct_constructor":{"&[u8]":["as_bytes"],"&mut [u8]":["as_mut_bytes"],"<simd::simdty::Simd4<u32> as core::ops::Add>::Output":["add"],"<simd::simdty::Simd4<u32> as core::ops::BitXor>::Output":["bitxor"],"<simd::simdty::Simd4<u32> as core::ops::Shl>::Output":["shl"],"<simd::simdty::Simd4<u32> as core::ops::Shr>::Output":["shr"],"<simd::simdty::Simd4<u64> as core::ops::Add>::Output":["add"],"<simd::simdty::Simd4<u64> as core::ops::BitXor>::Output":["bitxor"],"<simd::simdty::Simd4<u64> as core::ops::Shl>::Output":["shl"],"<simd::simdty::Simd4<u64> as core::ops::Shr>::Output":["shr"],"Blake2bMac":["clone","new"],"Blake2bVarCore":["clone","new_with_params"],"Blake2sMac":["clone","new"],"Blake2sVarCore":["clone","new_with_params"],"core::result::Result":["fmt","new","new_from_slice","new_with_salt_and_personal","write_alg_name"],"simd::simdty::Simd16":["clone"],"simd::simdty::Simd2":["clone"],"simd::simdty::Simd32":["clone"],"simd::simdty::Simd4":["clone","gather","iv0","iv1","new"],"simd::simdty::Simd8":["clone"]},"struct_to_trait":{"Blake2bMac":["core::clone::Clone","core::fmt::Debug","digest::FixedOutput","digest::KeyInit","digest::MacMarker","digest::OutputSizeUser","digest::Update","digest::crypto_common::KeySizeUser"],"Blake2bVarCore":["core::clone::Clone","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::UpdateCore","digest::core_api::VariableOutputCore"],"Blake2sMac":["core::clone::Clone","core::fmt::Debug","digest::FixedOutput","digest::KeyInit","digest::MacMarker","digest::OutputSizeUser","digest::Update","digest::crypto_common::KeySizeUser"],"Blake2sVarCore":["core::clone::Clone","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::UpdateCore","digest::core_api::VariableOutputCore"],"simd::simdty::Simd16":["as_bytes::Safe","core::clone::Clone","core::fmt::Debug","core::marker::Copy"],"simd::simdty::Simd2":["as_bytes::Safe","core::clone::Clone","core::fmt::Debug","core::marker::Copy"],"simd::simdty::Simd32":["as_bytes::Safe","core::clone::Clone","core::fmt::Debug","core::marker::Copy"],"simd::simdty::Simd4":["as_bytes::Safe","core::clone::Clone","core::fmt::Debug","core::marker::Copy"],"simd::simdty::Simd8":["as_bytes::Safe","core::clone::Clone","core::fmt::Debug","core::marker::Copy"],"simd::simdty::u32x4":["core::ops::Add","core::ops::BitXor","core::ops::Shl","core::ops::Shr","simd::Vector4"],"simd::simdty::u64x4":["core::ops::Add","core::ops::BitXor","core::ops::Shl","core::ops::Shr","simd::Vector4"]},"targets":{"<Blake2bMac<OutSize> as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"blake2/src/macros.rs\"))","core::fmt::Debug"],"<Blake2bMac<OutSize> as digest::FixedOutput>::finalize_into":["finalize_into","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::FixedOutput"],"<Blake2bMac<OutSize> as digest::KeyInit>::new":["new","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::KeyInit"],"<Blake2bMac<OutSize> as digest::KeyInit>::new_from_slice":["new_from_slice","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::KeyInit"],"<Blake2bMac<OutSize> as digest::Update>::update":["update","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::Update"],"<Blake2bVarCore as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"blake2/src/macros.rs\"))","core::fmt::Debug"],"<Blake2bVarCore as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Blake2bVarCore as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Blake2bVarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["finalize_variable_core","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::core_api::VariableOutputCore"],"<Blake2bVarCore as digest::core_api::VariableOutputCore>::new":["new","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::core_api::VariableOutputCore"],"<Blake2sMac<OutSize> as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"blake2/src/macros.rs\"))","core::fmt::Debug"],"<Blake2sMac<OutSize> as digest::FixedOutput>::finalize_into":["finalize_into","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::FixedOutput"],"<Blake2sMac<OutSize> as digest::KeyInit>::new":["new","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::KeyInit"],"<Blake2sMac<OutSize> as digest::KeyInit>::new_from_slice":["new_from_slice","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::KeyInit"],"<Blake2sMac<OutSize> as digest::Update>::update":["update","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::Update"],"<Blake2sVarCore as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"blake2/src/macros.rs\"))","core::fmt::Debug"],"<Blake2sVarCore as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Blake2sVarCore as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Blake2sVarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["finalize_variable_core","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::core_api::VariableOutputCore"],"<Blake2sVarCore as digest::core_api::VariableOutputCore>::new":["new","Real(LocalPath(\"blake2/src/macros.rs\"))","digest::core_api::VariableOutputCore"],"<[T] as as_bytes::AsBytes>::as_bytes":["as_bytes","Real(LocalPath(\"blake2/src/as_bytes.rs\"))","as_bytes::AsBytes"],"<[T] as as_bytes::AsBytes>::as_mut_bytes":["as_mut_bytes","Real(LocalPath(\"blake2/src/as_bytes.rs\"))","as_bytes::AsBytes"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::from_le":["from_le","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::gather":["gather","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::rotate_right_const":["rotate_right_const","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::shuffle_left_1":["shuffle_left_1","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::shuffle_left_2":["shuffle_left_2","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::shuffle_left_3":["shuffle_left_3","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::to_le":["to_le","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u32> as simd::Vector4<u32>>::wrapping_add":["wrapping_add","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::from_le":["from_le","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::gather":["gather","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::rotate_right_const":["rotate_right_const","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::shuffle_left_1":["shuffle_left_1","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::shuffle_left_2":["shuffle_left_2","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::shuffle_left_3":["shuffle_left_3","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::to_le":["to_le","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"<simd::simdty::Simd4<u64> as simd::Vector4<u64>>::wrapping_add":["wrapping_add","Real(LocalPath(\"blake2/src/simd.rs\"))","simd::Vector4"],"Blake2bMac::<OutSize>::new_with_salt_and_personal":["new_with_salt_and_personal","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2bVarCore::compress":["compress","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2bVarCore::compress::quarter_round":["quarter_round","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2bVarCore::compress::round":["round","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2bVarCore::compress::shuffle":["shuffle","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2bVarCore::compress::unshuffle":["unshuffle","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2bVarCore::finalize_with_flag":["finalize_with_flag","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2bVarCore::iv0":["iv0","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2bVarCore::iv1":["iv1","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2bVarCore::new_with_params":["new_with_params","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2sMac::<OutSize>::new_with_salt_and_personal":["new_with_salt_and_personal","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2sVarCore::compress":["compress","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2sVarCore::compress::quarter_round":["quarter_round","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2sVarCore::compress::round":["round","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2sVarCore::compress::shuffle":["shuffle","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2sVarCore::compress::unshuffle":["unshuffle","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2sVarCore::finalize_with_flag":["finalize_with_flag","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2sVarCore::iv0":["iv0","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2sVarCore::iv1":["iv1","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"Blake2sVarCore::new_with_params":["new_with_params","Real(LocalPath(\"blake2/src/macros.rs\"))",""],"simd::Vector4::shuffle_right_1":["shuffle_right_1","Real(LocalPath(\"blake2/src/simd.rs\"))",""],"simd::Vector4::shuffle_right_2":["shuffle_right_2","Real(LocalPath(\"blake2/src/simd.rs\"))",""],"simd::Vector4::shuffle_right_3":["shuffle_right_3","Real(LocalPath(\"blake2/src/simd.rs\"))",""],"simd::simd_opt::u32x4::rotate_right_const":["rotate_right_const","Real(LocalPath(\"blake2/src/simd/simd_opt.rs\"))",""],"simd::simd_opt::u64x4::rotate_right_const":["rotate_right_const","Real(LocalPath(\"blake2/src/simd/simd_opt.rs\"))",""],"simd::simdop::<impl core::ops::Add for simd::simdty::Simd4<u32>>::add":["add","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))","core::ops::Add"],"simd::simdop::<impl core::ops::Add for simd::simdty::Simd4<u64>>::add":["add","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))","core::ops::Add"],"simd::simdop::<impl core::ops::BitXor for simd::simdty::Simd4<u32>>::bitxor":["bitxor","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))","core::ops::BitXor"],"simd::simdop::<impl core::ops::BitXor for simd::simdty::Simd4<u64>>::bitxor":["bitxor","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))","core::ops::BitXor"],"simd::simdop::<impl core::ops::Shl for simd::simdty::Simd4<u32>>::shl":["shl","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))","core::ops::Shl"],"simd::simdop::<impl core::ops::Shl for simd::simdty::Simd4<u64>>::shl":["shl","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))","core::ops::Shl"],"simd::simdop::<impl core::ops::Shr for simd::simdty::Simd4<u32>>::shr":["shr","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))","core::ops::Shr"],"simd::simdop::<impl core::ops::Shr for simd::simdty::Simd4<u64>>::shr":["shr","Real(LocalPath(\"blake2/src/simd/simdop.rs\"))","core::ops::Shr"],"simd::simdty::Simd4::<T>::new":["new","Real(LocalPath(\"blake2/src/simd/simdty.rs\"))",""]},"trait_to_struct":{"as_bytes::Safe":["simd::simdty::Simd16","simd::simdty::Simd2","simd::simdty::Simd32","simd::simdty::Simd4","simd::simdty::Simd8"],"core::clone::Clone":["Blake2bMac","Blake2bVarCore","Blake2sMac","Blake2sVarCore","simd::simdty::Simd16","simd::simdty::Simd2","simd::simdty::Simd32","simd::simdty::Simd4","simd::simdty::Simd8"],"core::fmt::Debug":["Blake2bMac","Blake2bVarCore","Blake2sMac","Blake2sVarCore","simd::simdty::Simd16","simd::simdty::Simd2","simd::simdty::Simd32","simd::simdty::Simd4","simd::simdty::Simd8"],"core::marker::Copy":["simd::simdty::Simd16","simd::simdty::Simd2","simd::simdty::Simd32","simd::simdty::Simd4","simd::simdty::Simd8"],"core::ops::Add":["simd::simdty::u32x4","simd::simdty::u64x4"],"core::ops::BitXor":["simd::simdty::u32x4","simd::simdty::u64x4"],"core::ops::Shl":["simd::simdty::u32x4","simd::simdty::u64x4"],"core::ops::Shr":["simd::simdty::u32x4","simd::simdty::u64x4"],"digest::FixedOutput":["Blake2bMac","Blake2sMac"],"digest::HashMarker":["Blake2bVarCore","Blake2sVarCore"],"digest::KeyInit":["Blake2bMac","Blake2sMac"],"digest::MacMarker":["Blake2bMac","Blake2sMac"],"digest::OutputSizeUser":["Blake2bMac","Blake2bVarCore","Blake2sMac","Blake2sVarCore"],"digest::Update":["Blake2bMac","Blake2sMac"],"digest::core_api::AlgorithmName":["Blake2bVarCore","Blake2sVarCore"],"digest::core_api::BlockSizeUser":["Blake2bVarCore","Blake2sVarCore"],"digest::core_api::BufferKindUser":["Blake2bVarCore","Blake2sVarCore"],"digest::core_api::UpdateCore":["Blake2bVarCore","Blake2sVarCore"],"digest::core_api::VariableOutputCore":["Blake2bVarCore","Blake2sVarCore"],"digest::crypto_common::KeySizeUser":["Blake2bMac","Blake2sMac"],"simd::Vector4":["simd::simdty::u32x4","simd::simdty::u64x4"]},"type_to_def_path":{"Blake2bMac<OutSize>":"Blake2bMac","Blake2bVarCore":"Blake2bVarCore","Blake2sMac<OutSize>":"Blake2sMac","Blake2sVarCore":"Blake2sVarCore","simd::simdty::Simd16<T>":"simd::simdty::Simd16","simd::simdty::Simd2<T>":"simd::simdty::Simd2","simd::simdty::Simd32<T>":"simd::simdty::Simd32","simd::simdty::Simd4<T>":"simd::simdty::Simd4","simd::simdty::Simd8<T>":"simd::simdty::Simd8"}}