{"dependencies":{"<&'a event::events::Events as std::iter::IntoIterator>::into_iter":["event::events::Events","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<<event::event::Event as std::fmt::Debug>::fmt::EventDetails<'a> as std::fmt::Debug>::fmt":["<event::event::Event as std::fmt::Debug>::fmt::EventDetails","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<event::event::Event as std::clone::Clone>::clone":["event::event::Event"],"<event::event::Event as std::fmt::Debug>::fmt":["event::event::Event","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<event::event::Event as std::fmt::Debug>::fmt::EventDetails":["<event::event::Event as std::fmt::Debug>::fmt::EventDetails"],"<event::events::Events as std::fmt::Debug>::fmt":["event::events::Events","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<event::events::Iter<'a> as std::clone::Clone>::clone":["event::events::Events","event::events::Iter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<event::events::Iter<'a> as std::fmt::Debug>::fmt":["event::events::Events","event::events::Iter","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<event::events::Iter<'a> as std::iter::Iterator>::count":["event::events::Events","event::events::Iter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<event::events::Iter<'a> as std::iter::Iterator>::next":["event::events::Events","event::events::Iter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<event::events::Iter<'a> as std::iter::Iterator>::size_hint":["event::events::Events","event::events::Iter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<interest::Interest as std::clone::Clone>::clone":["interest::Interest","std::num::NonZeroU8"],"<interest::Interest as std::cmp::Eq>::assert_receiver_is_total_eq":["interest::Interest","std::num::NonZeroU8"],"<interest::Interest as std::cmp::Ord>::cmp":["interest::Interest","std::cmp::Ordering","std::num::NonZeroU8"],"<interest::Interest as std::cmp::PartialEq>::eq":["interest::Interest","std::num::NonZeroU8"],"<interest::Interest as std::cmp::PartialOrd>::partial_cmp":["interest::Interest","std::marker::Sized","std::num::NonZeroU8","std::option::Option"],"<interest::Interest as std::fmt::Debug>::fmt":["interest::Interest","std::fmt::Formatter","std::marker::Sized","std::num::NonZeroU8","std::result::Result"],"<interest::Interest as std::ops::BitOr>::bitor":["interest::Interest","std::num::NonZeroU8"],"<interest::Interest as std::ops::BitOrAssign>::bitor_assign":["interest::Interest","std::num::NonZeroU8"],"<poll::Poll as std::fmt::Debug>::fmt":["poll::Poll","poll::Registry","std::fmt::Formatter","std::marker::Sized","std::result::Result","sys::shell::selector::Selector"],"<poll::Poll as std::os::fd::AsRawFd>::as_raw_fd":["poll::Poll","poll::Registry","sys::shell::selector::Selector"],"<poll::Registry as std::fmt::Debug>::fmt":["poll::Registry","std::fmt::Formatter","std::marker::Sized","std::result::Result","sys::shell::selector::Selector"],"<poll::Registry as std::os::fd::AsRawFd>::as_raw_fd":["poll::Registry","sys::shell::selector::Selector"],"<std::boxed::Box<T> as event::source::Source>::deregister":["poll::Registry","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::result::Result","sys::shell::selector::Selector"],"<std::boxed::Box<T> as event::source::Source>::register":["interest::Interest","poll::Registry","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::num::NonZeroU8","std::result::Result","sys::shell::selector::Selector","token::Token"],"<std::boxed::Box<T> as event::source::Source>::reregister":["interest::Interest","poll::Registry","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::num::NonZeroU8","std::result::Result","sys::shell::selector::Selector","token::Token"],"<sys::shell::selector::Selector as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","sys::shell::selector::Selector"],"<sys::shell::selector::Selector as std::os::fd::AsRawFd>::as_raw_fd":["sys::shell::selector::Selector"],"<sys::shell::waker::Waker as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","sys::shell::waker::Waker"],"<token::Token as std::clone::Clone>::clone":["token::Token"],"<token::Token as std::cmp::Eq>::assert_receiver_is_total_eq":["token::Token"],"<token::Token as std::cmp::Ord>::cmp":["std::cmp::Ordering","token::Token"],"<token::Token as std::cmp::PartialEq>::eq":["token::Token"],"<token::Token as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","token::Token"],"<token::Token as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","token::Token"],"<token::Token as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","token::Token"],"<waker::Waker as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","sys::shell::waker::Waker","waker::Waker"],"event::event::Event":["event::event::Event"],"event::event::Event::from_sys_event_ref":["event::event::Event"],"event::event::Event::is_aio":["event::event::Event"],"event::event::Event::is_error":["event::event::Event"],"event::event::Event::is_lio":["event::event::Event"],"event::event::Event::is_priority":["event::event::Event"],"event::event::Event::is_read_closed":["event::event::Event"],"event::event::Event::is_readable":["event::event::Event"],"event::event::Event::is_writable":["event::event::Event"],"event::event::Event::is_write_closed":["event::event::Event"],"event::event::Event::token":["event::event::Event","token::Token"],"event::events::Events":["event::events::Events","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"event::events::Events::capacity":["event::events::Events","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"event::events::Events::clear":["event::events::Events","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"event::events::Events::is_empty":["event::events::Events","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"event::events::Events::iter":["event::events::Events","event::events::Iter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"event::events::Events::sys":["event::events::Events","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"event::events::Events::with_capacity":["event::events::Events","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"event::events::Iter":["event::events::Events","event::events::Iter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"event::source::Source::deregister":["poll::Registry","std::marker::Sized","std::result::Result","sys::shell::selector::Selector"],"event::source::Source::register":["interest::Interest","poll::Registry","std::marker::Sized","std::num::NonZeroU8","std::result::Result","sys::shell::selector::Selector","token::Token"],"event::source::Source::reregister":["interest::Interest","poll::Registry","std::marker::Sized","std::num::NonZeroU8","std::result::Result","sys::shell::selector::Selector","token::Token"],"interest::Interest":["interest::Interest","std::num::NonZeroU8"],"interest::Interest::add":["interest::Interest","std::num::NonZeroU8"],"interest::Interest::is_aio":["interest::Interest","std::num::NonZeroU8"],"interest::Interest::is_lio":["interest::Interest","std::num::NonZeroU8"],"interest::Interest::is_priority":["interest::Interest","std::num::NonZeroU8"],"interest::Interest::is_readable":["interest::Interest","std::num::NonZeroU8"],"interest::Interest::is_writable":["interest::Interest","std::num::NonZeroU8"],"interest::Interest::remove":["interest::Interest","std::marker::Sized","std::num::NonZeroU8","std::option::Option"],"poll::Poll":["poll::Poll","poll::Registry","sys::shell::selector::Selector"],"poll::Poll::poll":["event::events::Events","poll::Poll","poll::Registry","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","sys::shell::selector::Selector"],"poll::Poll::registry":["poll::Poll","poll::Registry","sys::shell::selector::Selector"],"poll::Registry":["poll::Registry","sys::shell::selector::Selector"],"poll::Registry::deregister":["event::source::Source","poll::Registry","std::boxed::Box","std::marker::Sized","std::result::Result","sys::shell::selector::Selector"],"poll::Registry::register":["event::source::Source","interest::Interest","poll::Registry","std::boxed::Box","std::marker::Sized","std::num::NonZeroU8","std::result::Result","sys::shell::selector::Selector","token::Token"],"poll::Registry::register_waker":["poll::Registry","sys::shell::selector::Selector"],"poll::Registry::reregister":["event::source::Source","interest::Interest","poll::Registry","std::boxed::Box","std::marker::Sized","std::num::NonZeroU8","std::result::Result","sys::shell::selector::Selector","token::Token"],"poll::Registry::selector":["poll::Registry","sys::shell::selector::Selector"],"poll::Registry::try_clone":["poll::Registry","std::marker::Sized","std::result::Result","sys::shell::selector::Selector"],"sys::shell::selector::Selector":["sys::shell::selector::Selector"],"sys::shell::selector::Selector::register_waker":["sys::shell::selector::Selector"],"sys::shell::selector::Selector::select":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec","sys::shell::selector::Selector"],"sys::shell::selector::Selector::try_clone":["std::marker::Sized","std::result::Result","sys::shell::selector::Selector"],"sys::shell::selector::event::debug_details":["std::fmt::Formatter","std::marker::Sized","std::result::Result"],"sys::shell::selector::event::is_aio":[],"sys::shell::selector::event::is_error":[],"sys::shell::selector::event::is_lio":[],"sys::shell::selector::event::is_priority":[],"sys::shell::selector::event::is_read_closed":[],"sys::shell::selector::event::is_readable":[],"sys::shell::selector::event::is_writable":[],"sys::shell::selector::event::is_write_closed":[],"sys::shell::selector::event::token":["token::Token"],"sys::shell::waker::Waker":["sys::shell::waker::Waker"],"sys::shell::waker::Waker::new":["std::marker::Sized","std::result::Result","sys::shell::selector::Selector","token::Token"],"sys::shell::waker::Waker::wake":["std::marker::Sized","std::result::Result","sys::shell::waker::Waker"],"token::<impl std::convert::From<token::Token> for usize>::from":["token::Token"],"token::Token":["token::Token"],"waker::Waker":["sys::shell::waker::Waker","waker::Waker"],"waker::Waker::new":["poll::Registry","std::marker::Sized","std::result::Result","sys::shell::selector::Selector","token::Token"],"waker::Waker::wake":["std::marker::Sized","std::result::Result","sys::shell::waker::Waker","waker::Waker"]},"glob_path_import":{},"self_to_fn":{"<event::event::Event as std::fmt::Debug>::fmt::EventDetails":["impl<'a> fmt::Debug for EventDetails<'a> {\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                    sys::event::debug_details(f, self.0)\n                }\n            }"],"event::event::Event":["Clone","impl Event {\n    /// Returns the event's token.\n    pub fn token(&self) -> Token {\n        sys::event::token(&self.inner)\n    }\n\n    /// Returns true if the event contains readable readiness.\n    ///\n    /// # Notes\n    ///\n    /// Out-of-band (OOB) data also triggers readable events. But must\n    /// application don't actually read OOB data, this could leave an\n    /// application open to a Denial-of-Service (Dos) attack, see\n    /// <https://github.com/sandstorm-io/sandstorm-website/blob/58f93346028c0576e8147627667328eaaf4be9fa/_posts/2015-04-08-osx-security-bug.md>.\n    /// However because Mio uses edge-triggers it will not result in an infinite\n    /// loop as described in the article above.\n    pub fn is_readable(&self) -> bool {\n        sys::event::is_readable(&self.inner)\n    }\n\n    /// Returns true if the event contains writable readiness.\n    pub fn is_writable(&self) -> bool {\n        sys::event::is_writable(&self.inner)\n    }\n\n    /// Returns true if the event contains error readiness.\n    ///\n    /// Error events occur when the socket enters an error state. In this case,\n    /// the socket will also receive a readable or writable event. Reading or\n    /// writing to the socket will result in an error.\n    ///\n    /// # Notes\n    ///\n    /// Method is available on all platforms, but not all platforms trigger the\n    /// error event.\n    ///\n    /// The table below shows what flags are checked on what OS.\n    ///\n    /// | [OS selector] | Flag(s) checked |\n    /// |---------------|-----------------|\n    /// | [epoll]       | `EPOLLERR`      |\n    /// | [kqueue]      | `EV_ERROR` and `EV_EOF` with `fflags` set to `0`. |\n    ///\n    /// [OS selector]: ../struct.Poll.html#implementation-notes\n    /// [epoll]: https://man7.org/linux/man-pages/man7/epoll.7.html\n    /// [kqueue]: https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\n    pub fn is_error(&self) -> bool {\n        sys::event::is_error(&self.inner)\n    }\n\n    /// Returns true if the event contains read closed readiness.\n    ///\n    /// # Notes\n    ///\n    /// Read closed readiness can be expected after any of the following have\n    /// occurred:\n    /// * The local stream has shutdown the read half of its socket\n    /// * The local stream has shutdown both the read half and the write half\n    ///   of its socket\n    /// * The peer stream has shutdown the write half its socket; this sends a\n    ///   `FIN` packet that has been received by the local stream\n    ///\n    /// Method is a best effort implementation. While some platforms may not\n    /// return readiness when read half is closed, it is guaranteed that\n    /// false-positives will not occur.\n    ///\n    /// The table below shows what flags are checked on what OS.\n    ///\n    /// | [OS selector] | Flag(s) checked |\n    /// |---------------|-----------------|\n    /// | [epoll]       | `EPOLLHUP`, or  |\n    /// |               | `EPOLLIN` and `EPOLLRDHUP` |\n    /// | [kqueue]      | `EV_EOF`        |\n    ///\n    /// [OS selector]: ../struct.Poll.html#implementation-notes\n    /// [epoll]: https://man7.org/linux/man-pages/man7/epoll.7.html\n    /// [kqueue]: https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\n    pub fn is_read_closed(&self) -> bool {\n        sys::event::is_read_closed(&self.inner)\n    }\n\n    /// Returns true if the event contains write closed readiness.\n    ///\n    /// # Notes\n    ///\n    /// On [epoll] this is essentially a check for `EPOLLHUP` flag as the\n    /// local stream shutting down its write half does not trigger this event.\n    ///\n    /// On [kqueue] the local stream shutting down the write half of its\n    /// socket will trigger this event.\n    ///\n    /// Method is a best effort implementation. While some platforms may not\n    /// return readiness when write half is closed, it is guaranteed that\n    /// false-positives will not occur.\n    ///\n    /// The table below shows what flags are checked on what OS.\n    ///\n    /// | [OS selector] | Flag(s) checked |\n    /// |---------------|-----------------|\n    /// | [epoll]       | `EPOLLHUP`, or  |\n    /// |               | only `EPOLLERR`, or |\n    /// |               | `EPOLLOUT` and `EPOLLERR` |\n    /// | [kqueue]      | `EV_EOF`        |\n    ///\n    /// [OS selector]: ../struct.Poll.html#implementation-notes\n    /// [epoll]: https://man7.org/linux/man-pages/man7/epoll.7.html\n    /// [kqueue]: https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\n    pub fn is_write_closed(&self) -> bool {\n        sys::event::is_write_closed(&self.inner)\n    }\n\n    /// Returns true if the event contains priority readiness.\n    ///\n    /// # Notes\n    ///\n    /// Method is available on all platforms, but not all platforms trigger the\n    /// priority event.\n    ///\n    /// The table below shows what flags are checked on what OS.\n    ///\n    /// | [OS selector] | Flag(s) checked |\n    /// |---------------|-----------------|\n    /// | [epoll]       | `EPOLLPRI`      |\n    /// | [kqueue]      | *Not supported* |\n    ///\n    /// [OS selector]: ../struct.Poll.html#implementation-notes\n    /// [epoll]: https://man7.org/linux/man-pages/man7/epoll.7.html\n    /// [kqueue]: https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\n    #[inline]\n    pub fn is_priority(&self) -> bool {\n        sys::event::is_priority(&self.inner)\n    }\n\n    /// Returns true if the event contains AIO readiness.\n    ///\n    /// # Notes\n    ///\n    /// Method is available on all platforms, but not all platforms support AIO.\n    ///\n    /// The table below shows what flags are checked on what OS.\n    ///\n    /// | [OS selector] | Flag(s) checked |\n    /// |---------------|-----------------|\n    /// | [epoll]       | *Not supported* |\n    /// | [kqueue]<sup>1</sup> | `EVFILT_AIO` |\n    ///\n    /// 1: Only supported on DragonFly BSD, FreeBSD, iOS and macOS.\n    ///\n    /// [OS selector]: ../struct.Poll.html#implementation-notes\n    /// [epoll]: https://man7.org/linux/man-pages/man7/epoll.7.html\n    /// [kqueue]: https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\n    pub fn is_aio(&self) -> bool {\n        sys::event::is_aio(&self.inner)\n    }\n\n    /// Returns true if the event contains LIO readiness.\n    ///\n    /// # Notes\n    ///\n    /// Method is available on all platforms, but only FreeBSD supports LIO. On\n    /// FreeBSD this method checks the `EVFILT_LIO` flag.\n    pub fn is_lio(&self) -> bool {\n        sys::event::is_lio(&self.inner)\n    }\n\n    /// Create a reference to an `Event` from a platform specific event.\n    pub(crate) fn from_sys_event_ref(sys_event: &sys::Event) -> &Event {\n        unsafe {\n            // This is safe because the memory layout of `Event` is\n            // the same as `sys::Event` due to the `repr(transparent)` attribute.\n            &*(sys_event as *const sys::Event as *const Event)\n        }\n    }\n}","impl fmt::Debug for Event {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let alternate = f.alternate();\n        let mut d = f.debug_struct(\"Event\");\n        d.field(\"token\", &self.token())\n            .field(\"readable\", &self.is_readable())\n            .field(\"writable\", &self.is_writable())\n            .field(\"error\", &self.is_error())\n            .field(\"read_closed\", &self.is_read_closed())\n            .field(\"write_closed\", &self.is_write_closed())\n            .field(\"priority\", &self.is_priority())\n            .field(\"aio\", &self.is_aio())\n            .field(\"lio\", &self.is_lio());\n\n        if alternate {\n            struct EventDetails<'a>(&'a sys::Event);\n\n            impl<'a> fmt::Debug for EventDetails<'a> {\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                    sys::event::debug_details(f, self.0)\n                }\n            }\n\n            d.field(\"details\", &EventDetails(&self.inner)).finish()\n        } else {\n            d.finish()\n        }\n    }\n}"],"event::events::Events":["impl Events {\n    /// Return a new `Events` capable of holding up to `capacity` events.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use mio::Events;\n    ///\n    /// let events = Events::with_capacity(1024);\n    /// assert_eq!(1024, events.capacity());\n    /// ```\n    pub fn with_capacity(capacity: usize) -> Events {\n        Events {\n            inner: sys::Events::with_capacity(capacity),\n        }\n    }\n\n    /// Returns the number of `Event` values that `self` can hold.\n    ///\n    /// ```\n    /// use mio::Events;\n    ///\n    /// let events = Events::with_capacity(1024);\n    /// assert_eq!(1024, events.capacity());\n    /// ```\n    pub fn capacity(&self) -> usize {\n        self.inner.capacity()\n    }\n\n    /// Returns `true` if `self` contains no `Event` values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use mio::Events;\n    ///\n    /// let events = Events::with_capacity(1024);\n    /// assert!(events.is_empty());\n    /// ```\n    pub fn is_empty(&self) -> bool {\n        self.inner.is_empty()\n    }\n\n    /// Returns an iterator over the `Event` values.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(feature = \"os-poll\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"os-poll\"), doc = \"```ignore\")]\n    /// # use std::error::Error;\n    /// # fn main() -> Result<(), Box<dyn Error>> {\n    /// use mio::{Events, Poll};\n    /// use std::time::Duration;\n    ///\n    /// let mut events = Events::with_capacity(1024);\n    /// let mut poll = Poll::new()?;\n    ///\n    /// // Register handles with `poll`.\n    ///\n    /// poll.poll(&mut events, Some(Duration::from_millis(100)))?;\n    ///\n    /// for event in events.iter() {\n    ///     println!(\"Got an event for {:?}\", event.token());\n    /// }\n    /// #     Ok(())\n    /// # }\n    /// ```\n    pub fn iter(&self) -> Iter<'_> {\n        Iter {\n            inner: self,\n            pos: 0,\n        }\n    }\n\n    /// Clearing all `Event` values from container explicitly.\n    ///\n    /// # Notes\n    ///\n    /// Events are cleared before every `poll`, so it is not required to call\n    /// this manually.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(feature = \"os-poll\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"os-poll\"), doc = \"```ignore\")]\n    /// # use std::error::Error;\n    /// # fn main() -> Result<(), Box<dyn Error>> {\n    /// use mio::{Events, Poll};\n    /// use std::time::Duration;\n    ///\n    /// let mut events = Events::with_capacity(1024);\n    /// let mut poll = Poll::new()?;\n    ///\n    /// // Register handles with `poll`.\n    ///\n    /// poll.poll(&mut events, Some(Duration::from_millis(100)))?;\n    ///\n    /// // Clear all events.\n    /// events.clear();\n    /// assert!(events.is_empty());\n    /// #     Ok(())\n    /// # }\n    /// ```\n    pub fn clear(&mut self) {\n        self.inner.clear();\n    }\n\n    /// Returns the inner `sys::Events`.\n    pub(crate) fn sys(&mut self) -> &mut sys::Events {\n        &mut self.inner\n    }\n}","impl fmt::Debug for Events {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list().entries(self).finish()\n    }\n}"],"event::events::Iter":["Clone","Debug","impl<'a> Iterator for Iter<'a> {\n    type Item = &'a Event;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let ret = self\n            .inner\n            .inner\n            .get(self.pos)\n            .map(Event::from_sys_event_ref);\n        self.pos += 1;\n        ret\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let size = self.inner.inner.len();\n        (size, Some(size))\n    }\n\n    fn count(self) -> usize {\n        self.inner.inner.len()\n    }\n}"],"interest::Interest":["Clone","Copy","Eq","Ord","PartialEq","PartialOrd","impl Interest {\n    /// Returns a `Interest` set representing readable interests.\n    pub const READABLE: Interest = Interest(unsafe { NonZeroU8::new_unchecked(READABLE) });\n\n    /// Returns a `Interest` set representing writable interests.\n    pub const WRITABLE: Interest = Interest(unsafe { NonZeroU8::new_unchecked(WRITABLE) });\n\n    /// Returns a `Interest` set representing AIO completion interests.\n    #[cfg(any(\n        target_os = \"dragonfly\",\n        target_os = \"freebsd\",\n        target_os = \"ios\",\n        target_os = \"macos\",\n    ))]\n    pub const AIO: Interest = Interest(unsafe { NonZeroU8::new_unchecked(AIO) });\n\n    /// Returns a `Interest` set representing LIO completion interests.\n    #[cfg(target_os = \"freebsd\")]\n    pub const LIO: Interest = Interest(unsafe { NonZeroU8::new_unchecked(LIO) });\n\n    /// Returns a `Interest` set representing priority completion interests.\n    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n    pub const PRIORITY: Interest = Interest(unsafe { NonZeroU8::new_unchecked(PRIORITY) });\n\n    /// Add together two `Interest`.\n    ///\n    /// This does the same thing as the `BitOr` implementation, but is a\n    /// constant function.\n    ///\n    /// ```\n    /// use mio::Interest;\n    ///\n    /// const INTERESTS: Interest = Interest::READABLE.add(Interest::WRITABLE);\n    /// # fn silent_dead_code_warning(_: Interest) { }\n    /// # silent_dead_code_warning(INTERESTS)\n    /// ```\n    #[allow(clippy::should_implement_trait)]\n    pub const fn add(self, other: Interest) -> Interest {\n        Interest(unsafe { NonZeroU8::new_unchecked(self.0.get() | other.0.get()) })\n    }\n\n    /// Removes `other` `Interest` from `self`.\n    ///\n    /// Returns `None` if the set would be empty after removing `other`.\n    ///\n    /// ```\n    /// use mio::Interest;\n    ///\n    /// const RW_INTERESTS: Interest = Interest::READABLE.add(Interest::WRITABLE);\n    ///\n    /// // As long a one interest remain this will return `Some`.\n    /// let w_interest = RW_INTERESTS.remove(Interest::READABLE).unwrap();\n    /// assert!(!w_interest.is_readable());\n    /// assert!(w_interest.is_writable());\n    ///\n    /// // Removing all interests from the set will return `None`.\n    /// assert_eq!(w_interest.remove(Interest::WRITABLE), None);\n    ///\n    /// // Its also possible to remove multiple interests at once.\n    /// assert_eq!(RW_INTERESTS.remove(RW_INTERESTS), None);\n    /// ```\n    pub fn remove(self, other: Interest) -> Option<Interest> {\n        NonZeroU8::new(self.0.get() & !other.0.get()).map(Interest)\n    }\n\n    /// Returns true if the value includes readable readiness.\n    pub const fn is_readable(self) -> bool {\n        (self.0.get() & READABLE) != 0\n    }\n\n    /// Returns true if the value includes writable readiness.\n    pub const fn is_writable(self) -> bool {\n        (self.0.get() & WRITABLE) != 0\n    }\n\n    /// Returns true if `Interest` contains AIO readiness.\n    pub const fn is_aio(self) -> bool {\n        (self.0.get() & AIO) != 0\n    }\n\n    /// Returns true if `Interest` contains LIO readiness.\n    pub const fn is_lio(self) -> bool {\n        (self.0.get() & LIO) != 0\n    }\n\n    /// Returns true if `Interest` contains priority readiness.\n    pub const fn is_priority(self) -> bool {\n        (self.0.get() & PRIORITY) != 0\n    }\n}","impl fmt::Debug for Interest {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut one = false;\n        if self.is_readable() {\n            if one {\n                write!(fmt, \" | \")?\n            }\n            write!(fmt, \"READABLE\")?;\n            one = true\n        }\n        if self.is_writable() {\n            if one {\n                write!(fmt, \" | \")?\n            }\n            write!(fmt, \"WRITABLE\")?;\n            one = true\n        }\n        #[cfg(any(\n            target_os = \"dragonfly\",\n            target_os = \"freebsd\",\n            target_os = \"ios\",\n            target_os = \"macos\",\n        ))]\n        {\n            if self.is_aio() {\n                if one {\n                    write!(fmt, \" | \")?\n                }\n                write!(fmt, \"AIO\")?;\n                one = true\n            }\n        }\n        #[cfg(any(target_os = \"freebsd\"))]\n        {\n            if self.is_lio() {\n                if one {\n                    write!(fmt, \" | \")?\n                }\n                write!(fmt, \"LIO\")?;\n                one = true\n            }\n        }\n        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n        {\n            if self.is_priority() {\n                if one {\n                    write!(fmt, \" | \")?\n                }\n                write!(fmt, \"PRIORITY\")?;\n                one = true\n            }\n        }\n        debug_assert!(one, \"printing empty interests\");\n        Ok(())\n    }\n}","impl ops::BitOr for Interest {\n    type Output = Self;\n\n    #[inline]\n    fn bitor(self, other: Self) -> Self {\n        self.add(other)\n    }\n}","impl ops::BitOrAssign for Interest {\n    #[inline]\n    fn bitor_assign(&mut self, other: Self) {\n        self.0 = (*self | other).0;\n    }\n}"],"poll::Poll":["impl AsRawFd for Poll {\n    fn as_raw_fd(&self) -> RawFd {\n        self.registry.as_raw_fd()\n    }\n}","impl Poll {\n    cfg_os_poll! {\n        /// Return a new `Poll` handle.\n        ///\n        /// This function will make a syscall to the operating system to create\n        /// the system selector. If this syscall fails, `Poll::new` will return\n        /// with the error.\n        ///\n        /// close-on-exec flag is set on the file descriptors used by the selector to prevent\n        /// leaking it to executed processes. However, on some systems such as\n        /// old Linux systems that don't support `epoll_create1` syscall it is done\n        /// non-atomically, so a separate thread executing in parallel to this\n        /// function may accidentally leak the file descriptor if it executes a\n        /// new process before this function returns.\n        ///\n        /// See [struct] level docs for more details.\n        ///\n        /// [struct]: struct.Poll.html\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// # use std::error::Error;\n        /// # fn main() -> Result<(), Box<dyn Error>> {\n        /// use mio::{Poll, Events};\n        /// use std::time::Duration;\n        ///\n        /// let mut poll = match Poll::new() {\n        ///     Ok(poll) => poll,\n        ///     Err(e) => panic!(\"failed to create Poll instance; err={:?}\", e),\n        /// };\n        ///\n        /// // Create a structure to receive polled events\n        /// let mut events = Events::with_capacity(1024);\n        ///\n        /// // Wait for events, but none will be received because no\n        /// // `event::Source`s have been registered with this `Poll` instance.\n        /// poll.poll(&mut events, Some(Duration::from_millis(500)))?;\n        /// assert!(events.is_empty());\n        /// #     Ok(())\n        /// # }\n        /// ```\n        pub fn new() -> io::Result<Poll> {\n            sys::Selector::new().map(|selector| Poll {\n                registry: Registry { selector },\n            })\n        }\n    }\n\n    /// Create a separate `Registry` which can be used to register\n    /// `event::Source`s.\n    pub fn registry(&self) -> &Registry {\n        &self.registry\n    }\n\n    /// Wait for readiness events\n    ///\n    /// Blocks the current thread and waits for readiness events for any of the\n    /// [`event::Source`]s that have been registered with this `Poll` instance.\n    /// The function will block until either at least one readiness event has\n    /// been received or `timeout` has elapsed. A `timeout` of `None` means that\n    /// `poll` will block until a readiness event has been received.\n    ///\n    /// The supplied `events` will be cleared and newly received readiness events\n    /// will be pushed onto the end. At most `events.capacity()` events will be\n    /// returned. If there are further pending readiness events, they will be\n    /// returned on the next call to `poll`.\n    ///\n    /// A single call to `poll` may result in multiple readiness events being\n    /// returned for a single event source. For example, if a TCP socket becomes\n    /// both readable and writable, it may be possible for a single readiness\n    /// event to be returned with both [`readable`] and [`writable`] readiness\n    /// **OR** two separate events may be returned, one with [`readable`] set\n    /// and one with [`writable`] set.\n    ///\n    /// Note that the `timeout` will be rounded up to the system clock\n    /// granularity (usually 1ms), and kernel scheduling delays mean that\n    /// the blocking interval may be overrun by a small amount.\n    ///\n    /// See the [struct] level documentation for a higher level discussion of\n    /// polling.\n    ///\n    /// [`event::Source`]: ./event/trait.Source.html\n    /// [`readable`]: struct.Interest.html#associatedconstant.READABLE\n    /// [`writable`]: struct.Interest.html#associatedconstant.WRITABLE\n    /// [struct]: struct.Poll.html\n    /// [`iter`]: ./event/struct.Events.html#method.iter\n    ///\n    /// # Notes\n    ///\n    /// This returns any errors without attempting to retry, previous versions\n    /// of Mio would automatically retry the poll call if it was interrupted\n    /// (if `EINTR` was returned).\n    ///\n    /// Currently if the `timeout` elapses without any readiness events\n    /// triggering this will return `Ok(())`. However we're not guaranteeing\n    /// this behaviour as this depends on the OS.\n    ///\n    /// # Examples\n    ///\n    /// A basic example -- establishing a `TcpStream` connection.\n    ///\n    #[cfg_attr(all(feature = \"os-poll\", feature = \"net\"), doc = \"```\")]\n    #[cfg_attr(not(all(feature = \"os-poll\", feature = \"net\")), doc = \"```ignore\")]\n    /// # use std::error::Error;\n    /// # fn main() -> Result<(), Box<dyn Error>> {\n    /// use mio::{Events, Poll, Interest, Token};\n    /// use mio::net::TcpStream;\n    ///\n    /// use std::net::{TcpListener, SocketAddr};\n    /// use std::thread;\n    ///\n    /// // Bind a server socket to connect to.\n    /// let addr: SocketAddr = \"127.0.0.1:0\".parse()?;\n    /// let server = TcpListener::bind(addr)?;\n    /// let addr = server.local_addr()?.clone();\n    ///\n    /// // Spawn a thread to accept the socket\n    /// thread::spawn(move || {\n    ///     let _ = server.accept();\n    /// });\n    ///\n    /// // Construct a new `Poll` handle as well as the `Events` we'll store into\n    /// let mut poll = Poll::new()?;\n    /// let mut events = Events::with_capacity(1024);\n    ///\n    /// // Connect the stream\n    /// let mut stream = TcpStream::connect(addr)?;\n    ///\n    /// // Register the stream with `Poll`\n    /// poll.registry().register(\n    ///     &mut stream,\n    ///     Token(0),\n    ///     Interest::READABLE | Interest::WRITABLE)?;\n    ///\n    /// // Wait for the socket to become ready. This has to happens in a loop to\n    /// // handle spurious wakeups.\n    /// loop {\n    ///     poll.poll(&mut events, None)?;\n    ///\n    ///     for event in &events {\n    ///         if event.token() == Token(0) && event.is_writable() {\n    ///             // The socket connected (probably, it could still be a spurious\n    ///             // wakeup)\n    ///             return Ok(());\n    ///         }\n    ///     }\n    /// }\n    /// # }\n    /// ```\n    ///\n    /// [struct]: #\n    pub fn poll(&mut self, events: &mut Events, timeout: Option<Duration>) -> io::Result<()> {\n        self.registry.selector.select(events.sys(), timeout)\n    }\n}","impl fmt::Debug for Poll {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.debug_struct(\"Poll\").finish()\n    }\n}"],"poll::Registry":["impl AsRawFd for Registry {\n    fn as_raw_fd(&self) -> RawFd {\n        self.selector.as_raw_fd()\n    }\n}","impl Registry {\n    /// Register an [`event::Source`] with the `Poll` instance.\n    ///\n    /// Once registered, the `Poll` instance will monitor the event source for\n    /// readiness state changes. When it notices a state change, it will return\n    /// a readiness event for the handle the next time [`poll`] is called.\n    ///\n    /// See [`Poll`] docs for a high level overview.\n    ///\n    /// # Arguments\n    ///\n    /// `source: &mut S: event::Source`: This is the source of events that the\n    /// `Poll` instance should monitor for readiness state changes.\n    ///\n    /// `token: Token`: The caller picks a token to associate with the socket.\n    /// When [`poll`] returns an event for the handle, this token is included.\n    /// This allows the caller to map the event to its source. The token\n    /// associated with the `event::Source` can be changed at any time by\n    /// calling [`reregister`].\n    ///\n    /// See documentation on [`Token`] for an example showing how to pick\n    /// [`Token`] values.\n    ///\n    /// `interest: Interest`: Specifies which operations `Poll` should monitor\n    /// for readiness. `Poll` will only return readiness events for operations\n    /// specified by this argument.\n    ///\n    /// If a socket is registered with readable interest and the socket becomes\n    /// writable, no event will be returned from [`poll`].\n    ///\n    /// The readiness interest for an `event::Source` can be changed at any time\n    /// by calling [`reregister`].\n    ///\n    /// # Notes\n    ///\n    /// Callers must ensure that if a source being registered with a `Poll`\n    /// instance was previously registered with that `Poll` instance, then a\n    /// call to [`deregister`] has already occurred. Consecutive calls to\n    /// `register` is unspecified behavior.\n    ///\n    /// Unless otherwise specified, the caller should assume that once an event\n    /// source is registered with a `Poll` instance, it is bound to that `Poll`\n    /// instance for the lifetime of the event source. This remains true even\n    /// if the event source is deregistered from the poll instance using\n    /// [`deregister`].\n    ///\n    /// [`event::Source`]: ./event/trait.Source.html\n    /// [`poll`]: struct.Poll.html#method.poll\n    /// [`reregister`]: struct.Registry.html#method.reregister\n    /// [`deregister`]: struct.Registry.html#method.deregister\n    /// [`Token`]: struct.Token.html\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(all(feature = \"os-poll\", feature = \"net\"), doc = \"```\")]\n    #[cfg_attr(not(all(feature = \"os-poll\", feature = \"net\")), doc = \"```ignore\")]\n    /// # use std::error::Error;\n    /// # use std::net;\n    /// # fn main() -> Result<(), Box<dyn Error>> {\n    /// use mio::{Events, Poll, Interest, Token};\n    /// use mio::net::TcpStream;\n    /// use std::net::SocketAddr;\n    /// use std::time::{Duration, Instant};\n    ///\n    /// let mut poll = Poll::new()?;\n    ///\n    /// let address: SocketAddr = \"127.0.0.1:0\".parse()?;\n    /// let listener = net::TcpListener::bind(address)?;\n    /// let mut socket = TcpStream::connect(listener.local_addr()?)?;\n    ///\n    /// // Register the socket with `poll`\n    /// poll.registry().register(\n    ///     &mut socket,\n    ///     Token(0),\n    ///     Interest::READABLE | Interest::WRITABLE)?;\n    ///\n    /// let mut events = Events::with_capacity(1024);\n    /// let start = Instant::now();\n    /// let timeout = Duration::from_millis(500);\n    ///\n    /// loop {\n    ///     let elapsed = start.elapsed();\n    ///\n    ///     if elapsed >= timeout {\n    ///         // Connection timed out\n    ///         return Ok(());\n    ///     }\n    ///\n    ///     let remaining = timeout - elapsed;\n    ///     poll.poll(&mut events, Some(remaining))?;\n    ///\n    ///     for event in &events {\n    ///         if event.token() == Token(0) {\n    ///             // Something (probably) happened on the socket.\n    ///             return Ok(());\n    ///         }\n    ///     }\n    /// }\n    /// # }\n    /// ```\n    pub fn register<S>(&self, source: &mut S, token: Token, interests: Interest) -> io::Result<()>\n    where\n        S: event::Source + ?Sized,\n    {\n        trace!(\n            \"registering event source with poller: token={:?}, interests={:?}\",\n            token,\n            interests\n        );\n        source.register(self, token, interests)\n    }\n\n    /// Re-register an [`event::Source`] with the `Poll` instance.\n    ///\n    /// Re-registering an event source allows changing the details of the\n    /// registration. Specifically, it allows updating the associated `token`\n    /// and `interests` specified in previous `register` and `reregister` calls.\n    ///\n    /// The `reregister` arguments fully override the previous values. In other\n    /// words, if a socket is registered with [`readable`] interest and the call\n    /// to `reregister` specifies [`writable`], then read interest is no longer\n    /// requested for the handle.\n    ///\n    /// The event source must have previously been registered with this instance\n    /// of `Poll`, otherwise the behavior is unspecified.\n    ///\n    /// See the [`register`] documentation for details about the function\n    /// arguments and see the [`struct`] docs for a high level overview of\n    /// polling.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(all(feature = \"os-poll\", feature = \"net\"), doc = \"```\")]\n    #[cfg_attr(not(all(feature = \"os-poll\", feature = \"net\")), doc = \"```ignore\")]\n    /// # use std::error::Error;\n    /// # use std::net;\n    /// # fn main() -> Result<(), Box<dyn Error>> {\n    /// use mio::{Poll, Interest, Token};\n    /// use mio::net::TcpStream;\n    /// use std::net::SocketAddr;\n    ///\n    /// let poll = Poll::new()?;\n    ///\n    /// let address: SocketAddr = \"127.0.0.1:0\".parse()?;\n    /// let listener = net::TcpListener::bind(address)?;\n    /// let mut socket = TcpStream::connect(listener.local_addr()?)?;\n    ///\n    /// // Register the socket with `poll`, requesting readable\n    /// poll.registry().register(\n    ///     &mut socket,\n    ///     Token(0),\n    ///     Interest::READABLE)?;\n    ///\n    /// // Reregister the socket specifying write interest instead. Even though\n    /// // the token is the same it must be specified.\n    /// poll.registry().reregister(\n    ///     &mut socket,\n    ///     Token(0),\n    ///     Interest::WRITABLE)?;\n    /// #     Ok(())\n    /// # }\n    /// ```\n    ///\n    /// [`event::Source`]: ./event/trait.Source.html\n    /// [`struct`]: struct.Poll.html\n    /// [`register`]: struct.Registry.html#method.register\n    /// [`readable`]: ./event/struct.Event.html#is_readable\n    /// [`writable`]: ./event/struct.Event.html#is_writable\n    pub fn reregister<S>(&self, source: &mut S, token: Token, interests: Interest) -> io::Result<()>\n    where\n        S: event::Source + ?Sized,\n    {\n        trace!(\n            \"reregistering event source with poller: token={:?}, interests={:?}\",\n            token,\n            interests\n        );\n        source.reregister(self, token, interests)\n    }\n\n    /// Deregister an [`event::Source`] with the `Poll` instance.\n    ///\n    /// When an event source is deregistered, the `Poll` instance will no longer\n    /// monitor it for readiness state changes. Deregistering clears up any\n    /// internal resources needed to track the handle.  After an explicit call\n    /// to this method completes, it is guaranteed that the token previously\n    /// registered to this handle will not be returned by a future poll, so long\n    /// as a happens-before relationship is established between this call and\n    /// the poll.\n    ///\n    /// The event source must have previously been registered with this instance\n    /// of `Poll`, otherwise the behavior is unspecified.\n    ///\n    /// A handle can be passed back to `register` after it has been\n    /// deregistered; however, it must be passed back to the **same** `Poll`\n    /// instance, otherwise the behavior is unspecified.\n    ///\n    /// # Examples\n    ///\n    #[cfg_attr(all(feature = \"os-poll\", feature = \"net\"), doc = \"```\")]\n    #[cfg_attr(not(all(feature = \"os-poll\", feature = \"net\")), doc = \"```ignore\")]\n    /// # use std::error::Error;\n    /// # use std::net;\n    /// # fn main() -> Result<(), Box<dyn Error>> {\n    /// use mio::{Events, Poll, Interest, Token};\n    /// use mio::net::TcpStream;\n    /// use std::net::SocketAddr;\n    /// use std::time::Duration;\n    ///\n    /// let mut poll = Poll::new()?;\n    ///\n    /// let address: SocketAddr = \"127.0.0.1:0\".parse()?;\n    /// let listener = net::TcpListener::bind(address)?;\n    /// let mut socket = TcpStream::connect(listener.local_addr()?)?;\n    ///\n    /// // Register the socket with `poll`\n    /// poll.registry().register(\n    ///     &mut socket,\n    ///     Token(0),\n    ///     Interest::READABLE)?;\n    ///\n    /// poll.registry().deregister(&mut socket)?;\n    ///\n    /// let mut events = Events::with_capacity(1024);\n    ///\n    /// // Set a timeout because this poll should never receive any events.\n    /// poll.poll(&mut events, Some(Duration::from_secs(1)))?;\n    /// assert!(events.is_empty());\n    /// #     Ok(())\n    /// # }\n    /// ```\n    pub fn deregister<S>(&self, source: &mut S) -> io::Result<()>\n    where\n        S: event::Source + ?Sized,\n    {\n        trace!(\"deregistering event source from poller\");\n        source.deregister(self)\n    }\n\n    /// Creates a new independently owned `Registry`.\n    ///\n    /// Event sources registered with this `Registry` will be registered with\n    /// the original `Registry` and `Poll` instance.\n    pub fn try_clone(&self) -> io::Result<Registry> {\n        self.selector\n            .try_clone()\n            .map(|selector| Registry { selector })\n    }\n\n    /// Internal check to ensure only a single `Waker` is active per [`Poll`]\n    /// instance.\n    #[cfg(all(debug_assertions, not(target_os = \"wasi\")))]\n    pub(crate) fn register_waker(&self) {\n        assert!(\n            !self.selector.register_waker(),\n            \"Only a single `Waker` can be active per `Poll` instance\"\n        );\n    }\n\n    /// Get access to the `sys::Selector`.\n    #[cfg(any(not(target_os = \"wasi\"), feature = \"net\"))]\n    pub(crate) fn selector(&self) -> &sys::Selector {\n        &self.selector\n    }\n}","impl fmt::Debug for Registry {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.debug_struct(\"Registry\").finish()\n    }\n}"],"std::boxed::Box":["impl<T> Source for Box<T>\nwhere\n    T: Source + ?Sized,\n{\n    fn register(\n        &mut self,\n        registry: &Registry,\n        token: Token,\n        interests: Interest,\n    ) -> io::Result<()> {\n        (**self).register(registry, token, interests)\n    }\n\n    fn reregister(\n        &mut self,\n        registry: &Registry,\n        token: Token,\n        interests: Interest,\n    ) -> io::Result<()> {\n        (**self).reregister(registry, token, interests)\n    }\n\n    fn deregister(&mut self, registry: &Registry) -> io::Result<()> {\n        (**self).deregister(registry)\n    }\n}"],"sys::shell::selector::Selector":["Debug","impl AsRawFd for Selector {\n    fn as_raw_fd(&self) -> RawFd {\n        os_required!()\n    }\n}","impl Selector {\n    pub fn try_clone(&self) -> io::Result<Selector> {\n        os_required!();\n    }\n\n    pub fn select(&self, _: &mut Events, _: Option<Duration>) -> io::Result<()> {\n        os_required!();\n    }\n\n    #[cfg(all(debug_assertions, not(target_os = \"wasi\")))]\n    pub fn register_waker(&self) -> bool {\n        os_required!();\n    }\n}"],"sys::shell::waker::Waker":["Debug","impl Waker {\n    pub fn new(_: &Selector, _: Token) -> io::Result<Waker> {\n        os_required!();\n    }\n\n    pub fn wake(&self) -> io::Result<()> {\n        os_required!();\n    }\n}"],"token::Token":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd"],"waker::Waker":["Debug","impl Waker {\n    /// Create a new `Waker`.\n    pub fn new(registry: &Registry, token: Token) -> io::Result<Waker> {\n        #[cfg(debug_assertions)]\n        registry.register_waker();\n        sys::Waker::new(registry.selector(), token).map(|inner| Waker { inner })\n    }\n\n    /// Wake up the [`Poll`] associated with this `Waker`.\n    ///\n    /// [`Poll`]: struct.Poll.html\n    pub fn wake(&self) -> io::Result<()> {\n        self.inner.wake()\n    }\n}"]},"single_path_import":{"event::event::Event":"event::Event","event::events::Events":"Events","event::events::Iter":"event::Iter","event::source::Source":"event::Source","interest::Interest":"Interest","poll::Poll":"Poll","poll::Registry":"Registry","token::Token":"Token","waker::Waker":"Waker"},"srcs":{"<&'a event::events::Events as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/event/events.rs\"))"],"<<event::event::Event as std::fmt::Debug>::fmt::EventDetails<'a> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                    sys::event::debug_details(f, self.0)\n                }","Real(LocalPath(\"src/event/event.rs\"))"],"<event::event::Event as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let alternate = f.alternate();\n        let mut d = f.debug_struct(\"Event\");\n        d.field(\"token\", &self.token())\n            .field(\"readable\", &self.is_readable())\n            .field(\"writable\", &self.is_writable())\n            .field(\"error\", &self.is_error())\n            .field(\"read_closed\", &self.is_read_closed())\n            .field(\"write_closed\", &self.is_write_closed())\n            .field(\"priority\", &self.is_priority())\n            .field(\"aio\", &self.is_aio())\n            .field(\"lio\", &self.is_lio());\n\n        if alternate {\n            struct EventDetails<'a>(&'a sys::Event);\n\n            impl<'a> fmt::Debug for EventDetails<'a> {\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                    sys::event::debug_details(f, self.0)\n                }\n            }\n\n            d.field(\"details\", &EventDetails(&self.inner)).finish()\n        } else {\n            d.finish()\n        }\n    }","Real(LocalPath(\"src/event/event.rs\"))"],"<event::event::Event as std::fmt::Debug>::fmt::EventDetails":["struct EventDetails<'a>(&'a sys::Event);","Real(LocalPath(\"src/event/event.rs\"))"],"<event::events::Events as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_list().entries(self).finish()\n    }","Real(LocalPath(\"src/event/events.rs\"))"],"<event::events::Iter<'a> as std::iter::Iterator>::count":["fn count(self) -> usize{\n        self.inner.inner.len()\n    }","Real(LocalPath(\"src/event/events.rs\"))"],"<event::events::Iter<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        let ret = self\n            .inner\n            .inner\n            .get(self.pos)\n            .map(Event::from_sys_event_ref);\n        self.pos += 1;\n        ret\n    }","Real(LocalPath(\"src/event/events.rs\"))"],"<event::events::Iter<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let size = self.inner.inner.len();\n        (size, Some(size))\n    }","Real(LocalPath(\"src/event/events.rs\"))"],"<interest::Interest as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let mut one = false;\n        if self.is_readable() {\n            if one {\n                write!(fmt, \" | \")?\n            }\n            write!(fmt, \"READABLE\")?;\n            one = true\n        }\n        if self.is_writable() {\n            if one {\n                write!(fmt, \" | \")?\n            }\n            write!(fmt, \"WRITABLE\")?;\n            one = true\n        }\n        #[cfg(any(\n            target_os = \"dragonfly\",\n            target_os = \"freebsd\",\n            target_os = \"ios\",\n            target_os = \"macos\",\n        ))]\n        {\n            if self.is_aio() {\n                if one {\n                    write!(fmt, \" | \")?\n                }\n                write!(fmt, \"AIO\")?;\n                one = true\n            }\n        }\n        #[cfg(any(target_os = \"freebsd\"))]\n        {\n            if self.is_lio() {\n                if one {\n                    write!(fmt, \" | \")?\n                }\n                write!(fmt, \"LIO\")?;\n                one = true\n            }\n        }\n        #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n        {\n            if self.is_priority() {\n                if one {\n                    write!(fmt, \" | \")?\n                }\n                write!(fmt, \"PRIORITY\")?;\n                one = true\n            }\n        }\n        debug_assert!(one, \"printing empty interests\");\n        Ok(())\n    }","Real(LocalPath(\"src/interest.rs\"))"],"<interest::Interest as std::ops::BitOr>::bitor":["#[inline]\nfn bitor(self, other: Self) -> Self{\n        self.add(other)\n    }","Real(LocalPath(\"src/interest.rs\"))"],"<interest::Interest as std::ops::BitOrAssign>::bitor_assign":["#[inline]\nfn bitor_assign(&mut self, other: Self){\n        self.0 = (*self | other).0;\n    }","Real(LocalPath(\"src/interest.rs\"))"],"<poll::Poll as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt.debug_struct(\"Poll\").finish()\n    }","Real(LocalPath(\"src/poll.rs\"))"],"<poll::Poll as std::os::fd::AsRawFd>::as_raw_fd":["fn as_raw_fd(&self) -> RawFd{\n        self.registry.as_raw_fd()\n    }","Real(LocalPath(\"src/poll.rs\"))"],"<poll::Registry as std::fmt::Debug>::fmt":["fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt.debug_struct(\"Registry\").finish()\n    }","Real(LocalPath(\"src/poll.rs\"))"],"<poll::Registry as std::os::fd::AsRawFd>::as_raw_fd":["fn as_raw_fd(&self) -> RawFd{\n        self.selector.as_raw_fd()\n    }","Real(LocalPath(\"src/poll.rs\"))"],"<std::boxed::Box<T> as event::source::Source>::deregister":["fn deregister(&mut self, registry: &Registry) -> io::Result<()>{\n        (**self).deregister(registry)\n    }","Real(LocalPath(\"src/event/source.rs\"))"],"<std::boxed::Box<T> as event::source::Source>::register":["fn register(\n        &mut self,\n        registry: &Registry,\n        token: Token,\n        interests: Interest,\n    ) -> io::Result<()>{\n        (**self).register(registry, token, interests)\n    }","Real(LocalPath(\"src/event/source.rs\"))"],"<std::boxed::Box<T> as event::source::Source>::reregister":["fn reregister(\n        &mut self,\n        registry: &Registry,\n        token: Token,\n        interests: Interest,\n    ) -> io::Result<()>{\n        (**self).reregister(registry, token, interests)\n    }","Real(LocalPath(\"src/event/source.rs\"))"],"<sys::shell::selector::Selector as std::os::fd::AsRawFd>::as_raw_fd":["fn as_raw_fd(&self) -> RawFd{\n        os_required!()\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"event::event::Event":["/// A readiness event.\n///\n/// `Event` is a readiness state paired with a [`Token`]. It is returned by\n/// [`Poll::poll`].\n///\n/// For more documentation on polling and events, see [`Poll`].\n///\n/// [`Poll::poll`]: ../struct.Poll.html#method.poll\n/// [`Poll`]: ../struct.Poll.html\n/// [`Token`]: ../struct.Token.html\n#[repr(transparent)]\npub struct Event {\n    inner: sys::Event,\n}","Real(LocalPath(\"src/event/event.rs\"))"],"event::event::Event::from_sys_event_ref":["/// Create a reference to an `Event` from a platform specific event.\npub(crate) fn from_sys_event_ref(sys_event: &sys::Event) -> &Event{\n        unsafe {\n            // This is safe because the memory layout of `Event` is\n            // the same as `sys::Event` due to the `repr(transparent)` attribute.\n            &*(sys_event as *const sys::Event as *const Event)\n        }\n    }","Real(LocalPath(\"src/event/event.rs\"))"],"event::event::Event::is_aio":["/// Returns true if the event contains AIO readiness.\n///\n/// # Notes\n///\n/// Method is available on all platforms, but not all platforms support AIO.\n///\n/// The table below shows what flags are checked on what OS.\n///\n/// | [OS selector] | Flag(s) checked |\n/// |---------------|-----------------|\n/// | [epoll]       | *Not supported* |\n/// | [kqueue]<sup>1</sup> | `EVFILT_AIO` |\n///\n/// 1: Only supported on DragonFly BSD, FreeBSD, iOS and macOS.\n///\n/// [OS selector]: ../struct.Poll.html#implementation-notes\n/// [epoll]: https://man7.org/linux/man-pages/man7/epoll.7.html\n/// [kqueue]: https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\npub fn is_aio(&self) -> bool{\n        sys::event::is_aio(&self.inner)\n    }","Real(LocalPath(\"src/event/event.rs\"))"],"event::event::Event::is_error":["/// Returns true if the event contains error readiness.\n///\n/// Error events occur when the socket enters an error state. In this case,\n/// the socket will also receive a readable or writable event. Reading or\n/// writing to the socket will result in an error.\n///\n/// # Notes\n///\n/// Method is available on all platforms, but not all platforms trigger the\n/// error event.\n///\n/// The table below shows what flags are checked on what OS.\n///\n/// | [OS selector] | Flag(s) checked |\n/// |---------------|-----------------|\n/// | [epoll]       | `EPOLLERR`      |\n/// | [kqueue]      | `EV_ERROR` and `EV_EOF` with `fflags` set to `0`. |\n///\n/// [OS selector]: ../struct.Poll.html#implementation-notes\n/// [epoll]: https://man7.org/linux/man-pages/man7/epoll.7.html\n/// [kqueue]: https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\npub fn is_error(&self) -> bool{\n        sys::event::is_error(&self.inner)\n    }","Real(LocalPath(\"src/event/event.rs\"))"],"event::event::Event::is_lio":["/// Returns true if the event contains LIO readiness.\n///\n/// # Notes\n///\n/// Method is available on all platforms, but only FreeBSD supports LIO. On\n/// FreeBSD this method checks the `EVFILT_LIO` flag.\npub fn is_lio(&self) -> bool{\n        sys::event::is_lio(&self.inner)\n    }","Real(LocalPath(\"src/event/event.rs\"))"],"event::event::Event::is_priority":["/// Returns true if the event contains priority readiness.\n///\n/// # Notes\n///\n/// Method is available on all platforms, but not all platforms trigger the\n/// priority event.\n///\n/// The table below shows what flags are checked on what OS.\n///\n/// | [OS selector] | Flag(s) checked |\n/// |---------------|-----------------|\n/// | [epoll]       | `EPOLLPRI`      |\n/// | [kqueue]      | *Not supported* |\n///\n/// [OS selector]: ../struct.Poll.html#implementation-notes\n/// [epoll]: https://man7.org/linux/man-pages/man7/epoll.7.html\n/// [kqueue]: https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\n#[inline]\npub fn is_priority(&self) -> bool{\n        sys::event::is_priority(&self.inner)\n    }","Real(LocalPath(\"src/event/event.rs\"))"],"event::event::Event::is_read_closed":["/// Returns true if the event contains read closed readiness.\n///\n/// # Notes\n///\n/// Read closed readiness can be expected after any of the following have\n/// occurred:\n/// * The local stream has shutdown the read half of its socket\n/// * The local stream has shutdown both the read half and the write half\n///   of its socket\n/// * The peer stream has shutdown the write half its socket; this sends a\n///   `FIN` packet that has been received by the local stream\n///\n/// Method is a best effort implementation. While some platforms may not\n/// return readiness when read half is closed, it is guaranteed that\n/// false-positives will not occur.\n///\n/// The table below shows what flags are checked on what OS.\n///\n/// | [OS selector] | Flag(s) checked |\n/// |---------------|-----------------|\n/// | [epoll]       | `EPOLLHUP`, or  |\n/// |               | `EPOLLIN` and `EPOLLRDHUP` |\n/// | [kqueue]      | `EV_EOF`        |\n///\n/// [OS selector]: ../struct.Poll.html#implementation-notes\n/// [epoll]: https://man7.org/linux/man-pages/man7/epoll.7.html\n/// [kqueue]: https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\npub fn is_read_closed(&self) -> bool{\n        sys::event::is_read_closed(&self.inner)\n    }","Real(LocalPath(\"src/event/event.rs\"))"],"event::event::Event::is_readable":["/// Returns true if the event contains readable readiness.\n///\n/// # Notes\n///\n/// Out-of-band (OOB) data also triggers readable events. But must\n/// application don't actually read OOB data, this could leave an\n/// application open to a Denial-of-Service (Dos) attack, see\n/// <https://github.com/sandstorm-io/sandstorm-website/blob/58f93346028c0576e8147627667328eaaf4be9fa/_posts/2015-04-08-osx-security-bug.md>.\n/// However because Mio uses edge-triggers it will not result in an infinite\n/// loop as described in the article above.\npub fn is_readable(&self) -> bool{\n        sys::event::is_readable(&self.inner)\n    }","Real(LocalPath(\"src/event/event.rs\"))"],"event::event::Event::is_writable":["/// Returns true if the event contains writable readiness.\npub fn is_writable(&self) -> bool{\n        sys::event::is_writable(&self.inner)\n    }","Real(LocalPath(\"src/event/event.rs\"))"],"event::event::Event::is_write_closed":["/// Returns true if the event contains write closed readiness.\n///\n/// # Notes\n///\n/// On [epoll] this is essentially a check for `EPOLLHUP` flag as the\n/// local stream shutting down its write half does not trigger this event.\n///\n/// On [kqueue] the local stream shutting down the write half of its\n/// socket will trigger this event.\n///\n/// Method is a best effort implementation. While some platforms may not\n/// return readiness when write half is closed, it is guaranteed that\n/// false-positives will not occur.\n///\n/// The table below shows what flags are checked on what OS.\n///\n/// | [OS selector] | Flag(s) checked |\n/// |---------------|-----------------|\n/// | [epoll]       | `EPOLLHUP`, or  |\n/// |               | only `EPOLLERR`, or |\n/// |               | `EPOLLOUT` and `EPOLLERR` |\n/// | [kqueue]      | `EV_EOF`        |\n///\n/// [OS selector]: ../struct.Poll.html#implementation-notes\n/// [epoll]: https://man7.org/linux/man-pages/man7/epoll.7.html\n/// [kqueue]: https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\npub fn is_write_closed(&self) -> bool{\n        sys::event::is_write_closed(&self.inner)\n    }","Real(LocalPath(\"src/event/event.rs\"))"],"event::event::Event::token":["/// Returns the event's token.\npub fn token(&self) -> Token{\n        sys::event::token(&self.inner)\n    }","Real(LocalPath(\"src/event/event.rs\"))"],"event::events::Events":["/// A collection of readiness events.\n///\n/// `Events` is passed as an argument to [`Poll::poll`] and will be used to\n/// receive any new readiness events received since the last poll. Usually, a\n/// single `Events` instance is created at the same time as a [`Poll`] and\n/// reused on each call to [`Poll::poll`].\n///\n/// See [`Poll`] for more documentation on polling.\n///\n/// [`Poll::poll`]: ../struct.Poll.html#method.poll\n/// [`Poll`]: ../struct.Poll.html\n///\n/// # Examples\n///\ndoc = \"```ignore\"\n/// # use std::error::Error;\n/// # fn main() -> Result<(), Box<dyn Error>> {\n/// use mio::{Events, Poll};\n/// use std::time::Duration;\n///\n/// let mut events = Events::with_capacity(1024);\n/// let mut poll = Poll::new()?;\n/// #\n/// # assert!(events.is_empty());\n///\n/// // Register `event::Source`s with `poll`.\n///\n/// poll.poll(&mut events, Some(Duration::from_millis(100)))?;\n///\n/// for event in events.iter() {\n///     println!(\"Got an event for {:?}\", event.token());\n/// }\n/// #     Ok(())\n/// # }\n/// ```\npub struct Events {\n    inner: sys::Events,\n}","Real(LocalPath(\"src/event/events.rs\"))"],"event::events::Events::capacity":["/// Returns the number of `Event` values that `self` can hold.\n///\n/// ```\n/// use mio::Events;\n///\n/// let events = Events::with_capacity(1024);\n/// assert_eq!(1024, events.capacity());\n/// ```\npub fn capacity(&self) -> usize{\n        self.inner.capacity()\n    }","Real(LocalPath(\"src/event/events.rs\"))"],"event::events::Events::clear":["/// Clearing all `Event` values from container explicitly.\n///\n/// # Notes\n///\n/// Events are cleared before every `poll`, so it is not required to call\n/// this manually.\n///\n/// # Examples\n///\ndoc = \"```ignore\"\n/// # use std::error::Error;\n/// # fn main() -> Result<(), Box<dyn Error>> {\n/// use mio::{Events, Poll};\n/// use std::time::Duration;\n///\n/// let mut events = Events::with_capacity(1024);\n/// let mut poll = Poll::new()?;\n///\n/// // Register handles with `poll`.\n///\n/// poll.poll(&mut events, Some(Duration::from_millis(100)))?;\n///\n/// // Clear all events.\n/// events.clear();\n/// assert!(events.is_empty());\n/// #     Ok(())\n/// # }\n/// ```\npub fn clear(&mut self){\n        self.inner.clear();\n    }","Real(LocalPath(\"src/event/events.rs\"))"],"event::events::Events::is_empty":["/// Returns `true` if `self` contains no `Event` values.\n///\n/// # Examples\n///\n/// ```\n/// use mio::Events;\n///\n/// let events = Events::with_capacity(1024);\n/// assert!(events.is_empty());\n/// ```\npub fn is_empty(&self) -> bool{\n        self.inner.is_empty()\n    }","Real(LocalPath(\"src/event/events.rs\"))"],"event::events::Events::iter":["/// Returns an iterator over the `Event` values.\n///\n/// # Examples\n///\ndoc = \"```ignore\"\n/// # use std::error::Error;\n/// # fn main() -> Result<(), Box<dyn Error>> {\n/// use mio::{Events, Poll};\n/// use std::time::Duration;\n///\n/// let mut events = Events::with_capacity(1024);\n/// let mut poll = Poll::new()?;\n///\n/// // Register handles with `poll`.\n///\n/// poll.poll(&mut events, Some(Duration::from_millis(100)))?;\n///\n/// for event in events.iter() {\n///     println!(\"Got an event for {:?}\", event.token());\n/// }\n/// #     Ok(())\n/// # }\n/// ```\npub fn iter(&self) -> Iter<'_>{\n        Iter {\n            inner: self,\n            pos: 0,\n        }\n    }","Real(LocalPath(\"src/event/events.rs\"))"],"event::events::Events::sys":["/// Returns the inner `sys::Events`.\npub(crate) fn sys(&mut self) -> &mut sys::Events{\n        &mut self.inner\n    }","Real(LocalPath(\"src/event/events.rs\"))"],"event::events::Events::with_capacity":["/// Return a new `Events` capable of holding up to `capacity` events.\n///\n/// # Examples\n///\n/// ```\n/// use mio::Events;\n///\n/// let events = Events::with_capacity(1024);\n/// assert_eq!(1024, events.capacity());\n/// ```\npub fn with_capacity(capacity: usize) -> Events{\n        Events {\n            inner: sys::Events::with_capacity(capacity),\n        }\n    }","Real(LocalPath(\"src/event/events.rs\"))"],"event::events::Iter":["/// [`Events`] iterator.\n///\n/// This struct is created by the [`iter`] method on [`Events`].\n///\n/// [`Events`]: struct.Events.html\n/// [`iter`]: struct.Events.html#method.iter\n///\n/// # Examples\n///\ndoc = \"```ignore\"\n/// # use std::error::Error;\n/// # fn main() -> Result<(), Box<dyn Error>> {\n/// use mio::{Events, Poll};\n/// use std::time::Duration;\n///\n/// let mut events = Events::with_capacity(1024);\n/// let mut poll = Poll::new()?;\n///\n/// // Register handles with `poll`.\n///\n/// poll.poll(&mut events, Some(Duration::from_millis(100)))?;\n///\n/// for event in events.iter() {\n///     println!(\"Got an event for {:?}\", event.token());\n/// }\n/// #     Ok(())\n/// # }\n/// ```\npub struct Iter<'a> {\n    inner: &'a Events,\n    pos: usize,\n}","Real(LocalPath(\"src/event/events.rs\"))"],"event::source::Source":["/// An event source that may be registered with [`Registry`].\n///\n/// Types that implement `event::Source` can be registered with\n/// `Registry`. Users of Mio **should not** use the `event::Source` trait\n/// functions directly. Instead, the equivalent functions on `Registry` should\n/// be used.\n///\n/// See [`Registry`] for more details.\n///\n/// [`Registry`]: ../struct.Registry.html\n///\n/// # Implementing `event::Source`\n///\n/// Event sources are always backed by system handles, such as sockets or other\n/// system handles. These `event::Source`s will be monitored by the system\n/// selector. An implementation of `Source` will almost always delegates to a\n/// lower level handle. Examples of this are [`TcpStream`]s, or the *unix only*\n/// [`SourceFd`].\n///\n/// [`TcpStream`]: ../net/struct.TcpStream.html\n/// [`SourceFd`]: ../unix/struct.SourceFd.html\n///\n/// # Dropping `event::Source`s\n///\n/// All `event::Source`s, unless otherwise specified, need to be [deregistered]\n/// before being dropped for them to not leak resources. This goes against the\n/// normal drop behaviour of types in Rust which cleanup after themselves, e.g.\n/// a `File` will close itself. However since deregistering needs access to\n/// [`Registry`] this cannot be done while being dropped.\n///\n/// [deregistered]: ../struct.Registry.html#method.deregister\n///\n/// # Examples\n///\n/// Implementing `Source` on a struct containing a socket:\n///\ndoc = \"```ignore\"\n/// use mio::{Interest, Registry, Token};\n/// use mio::event::Source;\n/// use mio::net::TcpStream;\n///\n/// use std::io;\n///\n/// # #[allow(dead_code)]\n/// pub struct MySource {\n///     socket: TcpStream,\n/// }\n///\n/// impl Source for MySource {\n///     fn register(&mut self, registry: &Registry, token: Token, interests: Interest)\n///         -> io::Result<()>\n///     {\n///         // Delegate the `register` call to `socket`\n///         self.socket.register(registry, token, interests)\n///     }\n///\n///     fn reregister(&mut self, registry: &Registry, token: Token, interests: Interest)\n///         -> io::Result<()>\n///     {\n///         // Delegate the `reregister` call to `socket`\n///         self.socket.reregister(registry, token, interests)\n///     }\n///\n///     fn deregister(&mut self, registry: &Registry) -> io::Result<()> {\n///         // Delegate the `deregister` call to `socket`\n///         self.socket.deregister(registry)\n///     }\n/// }\n/// ```\npub trait Source {\n    /// Register `self` with the given `Registry` instance.\n    ///\n    /// This function should not be called directly. Use [`Registry::register`]\n    /// instead. Implementors should handle registration by delegating the call\n    /// to another `Source` type.\n    ///\n    /// [`Registry::register`]: ../struct.Registry.html#method.register\n    fn register(\n        &mut self,\n        registry: &Registry,\n        token: Token,\n        interests: Interest,\n    ) -> io::Result<()>;\n\n    /// Re-register `self` with the given `Registry` instance.\n    ///\n    /// This function should not be called directly. Use\n    /// [`Registry::reregister`] instead. Implementors should handle\n    /// re-registration by either delegating the call to another `Source` type.\n    ///\n    /// [`Registry::reregister`]: ../struct.Registry.html#method.reregister\n    fn reregister(\n        &mut self,\n        registry: &Registry,\n        token: Token,\n        interests: Interest,\n    ) -> io::Result<()>;\n\n    /// Deregister `self` from the given `Registry` instance.\n    ///\n    /// This function should not be called directly. Use\n    /// [`Registry::deregister`] instead. Implementors should handle\n    /// deregistration by delegating the call to another `Source` type.\n    ///\n    /// [`Registry::deregister`]: ../struct.Registry.html#method.deregister\n    fn deregister(&mut self, registry: &Registry) -> io::Result<()>;\n}","Real(LocalPath(\"src/event/source.rs\"))"],"interest::Interest":["/// Interest used in registering.\n///\n/// Interest are used in [registering] [`event::Source`]s with [`Poll`], they\n/// indicate what readiness should be monitored for. For example if a socket is\n/// registered with [readable] interests and the socket becomes writable, no\n/// event will be returned from a call to [`poll`].\n///\n/// [registering]: struct.Registry.html#method.register\n/// [`event::Source`]: ./event/trait.Source.html\n/// [`Poll`]: struct.Poll.html\n/// [readable]: struct.Interest.html#associatedconstant.READABLE\n/// [`poll`]: struct.Poll.html#method.poll\npub struct Interest(NonZeroU8);","Real(LocalPath(\"src/interest.rs\"))"],"interest::Interest::add":["/// Add together two `Interest`.\n///\n/// This does the same thing as the `BitOr` implementation, but is a\n/// constant function.\n///\n/// ```\n/// use mio::Interest;\n///\n/// const INTERESTS: Interest = Interest::READABLE.add(Interest::WRITABLE);\n/// # fn silent_dead_code_warning(_: Interest) { }\n/// # silent_dead_code_warning(INTERESTS)\n/// ```\n#[allow(clippy::should_implement_trait)]\npub const fn add(self, other: Interest) -> Interest{\n        Interest(unsafe { NonZeroU8::new_unchecked(self.0.get() | other.0.get()) })\n    }","Real(LocalPath(\"src/interest.rs\"))"],"interest::Interest::is_aio":["/// Returns true if `Interest` contains AIO readiness.\npub const fn is_aio(self) -> bool{\n        (self.0.get() & AIO) != 0\n    }","Real(LocalPath(\"src/interest.rs\"))"],"interest::Interest::is_lio":["/// Returns true if `Interest` contains LIO readiness.\npub const fn is_lio(self) -> bool{\n        (self.0.get() & LIO) != 0\n    }","Real(LocalPath(\"src/interest.rs\"))"],"interest::Interest::is_priority":["/// Returns true if `Interest` contains priority readiness.\npub const fn is_priority(self) -> bool{\n        (self.0.get() & PRIORITY) != 0\n    }","Real(LocalPath(\"src/interest.rs\"))"],"interest::Interest::is_readable":["/// Returns true if the value includes readable readiness.\npub const fn is_readable(self) -> bool{\n        (self.0.get() & READABLE) != 0\n    }","Real(LocalPath(\"src/interest.rs\"))"],"interest::Interest::is_writable":["/// Returns true if the value includes writable readiness.\npub const fn is_writable(self) -> bool{\n        (self.0.get() & WRITABLE) != 0\n    }","Real(LocalPath(\"src/interest.rs\"))"],"interest::Interest::remove":["/// Removes `other` `Interest` from `self`.\n///\n/// Returns `None` if the set would be empty after removing `other`.\n///\n/// ```\n/// use mio::Interest;\n///\n/// const RW_INTERESTS: Interest = Interest::READABLE.add(Interest::WRITABLE);\n///\n/// // As long a one interest remain this will return `Some`.\n/// let w_interest = RW_INTERESTS.remove(Interest::READABLE).unwrap();\n/// assert!(!w_interest.is_readable());\n/// assert!(w_interest.is_writable());\n///\n/// // Removing all interests from the set will return `None`.\n/// assert_eq!(w_interest.remove(Interest::WRITABLE), None);\n///\n/// // Its also possible to remove multiple interests at once.\n/// assert_eq!(RW_INTERESTS.remove(RW_INTERESTS), None);\n/// ```\npub fn remove(self, other: Interest) -> Option<Interest>{\n        NonZeroU8::new(self.0.get() & !other.0.get()).map(Interest)\n    }","Real(LocalPath(\"src/interest.rs\"))"],"poll::Poll":["/// Polls for readiness events on all registered values.\n///\n/// `Poll` allows a program to monitor a large number of [`event::Source`]s,\n/// waiting until one or more become \"ready\" for some class of operations; e.g.\n/// reading and writing. An event source is considered ready if it is possible\n/// to immediately perform a corresponding operation; e.g. [`read`] or\n/// [`write`].\n///\n/// To use `Poll`, an `event::Source` must first be registered with the `Poll`\n/// instance using the [`register`] method on its associated `Register`,\n/// supplying readiness interest. The readiness interest tells `Poll` which\n/// specific operations on the handle to monitor for readiness. A `Token` is\n/// also passed to the [`register`] function. When `Poll` returns a readiness\n/// event, it will include this token.  This associates the event with the\n/// event source that generated the event.\n///\n/// [`event::Source`]: ./event/trait.Source.html\n/// [`read`]: ./net/struct.TcpStream.html#method.read\n/// [`write`]: ./net/struct.TcpStream.html#method.write\n/// [`register`]: struct.Registry.html#method.register\n///\n/// # Examples\n///\n/// A basic example -- establishing a `TcpStream` connection.\n///\ndoc = \"```ignore\"\n/// # use std::error::Error;\n/// # fn main() -> Result<(), Box<dyn Error>> {\n/// use mio::{Events, Poll, Interest, Token};\n/// use mio::net::TcpStream;\n///\n/// use std::net::{self, SocketAddr};\n///\n/// // Bind a server socket to connect to.\n/// let addr: SocketAddr = \"127.0.0.1:0\".parse()?;\n/// let server = net::TcpListener::bind(addr)?;\n///\n/// // Construct a new `Poll` handle as well as the `Events` we'll store into\n/// let mut poll = Poll::new()?;\n/// let mut events = Events::with_capacity(1024);\n///\n/// // Connect the stream\n/// let mut stream = TcpStream::connect(server.local_addr()?)?;\n///\n/// // Register the stream with `Poll`\n/// poll.registry().register(&mut stream, Token(0), Interest::READABLE | Interest::WRITABLE)?;\n///\n/// // Wait for the socket to become ready. This has to happens in a loop to\n/// // handle spurious wakeups.\n/// loop {\n///     poll.poll(&mut events, None)?;\n///\n///     for event in &events {\n///         if event.token() == Token(0) && event.is_writable() {\n///             // The socket connected (probably, it could still be a spurious\n///             // wakeup)\n///             return Ok(());\n///         }\n///     }\n/// }\n/// # }\n/// ```\n///\n/// # Portability\n///\n/// Using `Poll` provides a portable interface across supported platforms as\n/// long as the caller takes the following into consideration:\n///\n/// ### Spurious events\n///\n/// [`Poll::poll`] may return readiness events even if the associated\n/// event source is not actually ready. Given the same code, this may\n/// happen more on some platforms than others. It is important to never assume\n/// that, just because a readiness event was received, that the associated\n/// operation will succeed as well.\n///\n/// If operation fails with [`WouldBlock`], then the caller should not treat\n/// this as an error, but instead should wait until another readiness event is\n/// received.\n///\n/// ### Draining readiness\n///\n/// Once a readiness event is received, the corresponding operation must be\n/// performed repeatedly until it returns [`WouldBlock`]. Unless this is done,\n/// there is no guarantee that another readiness event will be delivered, even\n/// if further data is received for the event source.\n///\n/// [`WouldBlock`]: std::io::ErrorKind::WouldBlock\n///\n/// ### Readiness operations\n///\n/// The only readiness operations that are guaranteed to be present on all\n/// supported platforms are [`readable`] and [`writable`]. All other readiness\n/// operations may have false negatives and as such should be considered\n/// **hints**. This means that if a socket is registered with [`readable`]\n/// interest and either an error or close is received, a readiness event will\n/// be generated for the socket, but it **may** only include `readable`\n/// readiness. Also note that, given the potential for spurious events,\n/// receiving a readiness event with `read_closed`, `write_closed`, or `error`\n/// doesn't actually mean that a `read` on the socket will return a result\n/// matching the readiness event.\n///\n/// In other words, portable programs that explicitly check for [`read_closed`],\n/// [`write_closed`], or [`error`] readiness should be doing so as an\n/// **optimization** and always be able to handle an error or close situation\n/// when performing the actual read operation.\n///\n/// [`readable`]: ./event/struct.Event.html#method.is_readable\n/// [`writable`]: ./event/struct.Event.html#method.is_writable\n/// [`error`]: ./event/struct.Event.html#method.is_error\n/// [`read_closed`]: ./event/struct.Event.html#method.is_read_closed\n/// [`write_closed`]: ./event/struct.Event.html#method.is_write_closed\n///\n/// ### Registering handles\n///\n/// Unless otherwise noted, it should be assumed that types implementing\n/// [`event::Source`] will never become ready unless they are registered with\n/// `Poll`.\n///\n/// For example:\n///\ndoc = \"```ignore\"\n/// # use std::error::Error;\n/// # use std::net;\n/// # fn main() -> Result<(), Box<dyn Error>> {\n/// use mio::{Poll, Interest, Token};\n/// use mio::net::TcpStream;\n/// use std::net::SocketAddr;\n/// use std::time::Duration;\n/// use std::thread;\n///\n/// let address: SocketAddr = \"127.0.0.1:0\".parse()?;\n/// let listener = net::TcpListener::bind(address)?;\n/// let mut sock = TcpStream::connect(listener.local_addr()?)?;\n///\n/// thread::sleep(Duration::from_secs(1));\n///\n/// let poll = Poll::new()?;\n///\n/// // The connect is not guaranteed to have started until it is registered at\n/// // this point\n/// poll.registry().register(&mut sock, Token(0), Interest::READABLE | Interest::WRITABLE)?;\n/// #     Ok(())\n/// # }\n/// ```\n///\n/// ### Dropping `Poll`\n///\n/// When the `Poll` instance is dropped it may cancel in-flight operations for\n/// the registered [event sources], meaning that no further events for them may\n/// be received. It also means operations on the registered event sources may no\n/// longer work. It is up to the user to keep the `Poll` instance alive while\n/// registered event sources are being used.\n///\n/// [event sources]: ./event/trait.Source.html\n///\n/// ### Accessing raw fd/socket/handle\n///\n/// Mio makes it possible for many types to be converted into a raw file\n/// descriptor (fd, Unix), socket (Windows) or handle (Windows). This makes it\n/// possible to support more operations on the type than Mio supports, for\n/// example it makes [mio-aio] possible. However accessing the raw fd is not\n/// without it's pitfalls.\n///\n/// Specifically performing I/O operations outside of Mio on these types (via\n/// the raw fd) has unspecified behaviour. It could cause no more events to be\n/// generated for the type even though it returned `WouldBlock` (in an operation\n/// directly accessing the fd). The behaviour is OS specific and Mio can only\n/// guarantee cross-platform behaviour if it can control the I/O.\n///\n/// [mio-aio]: https://github.com/asomers/mio-aio\n///\n/// *The following is **not** guaranteed, just a description of the current\n/// situation!* Mio is allowed to change the following without it being considered\n/// a breaking change, don't depend on this, it's just here to inform the user.\n/// Currently the kqueue and epoll implementation support direct I/O operations\n/// on the fd without Mio's knowledge. Windows however needs **all** I/O\n/// operations to go through Mio otherwise it is not able to update it's\n/// internal state properly and won't generate events.\n///\n/// ### Polling without registering event sources\n///\n///\n/// *The following is **not** guaranteed, just a description of the current\n/// situation!* Mio is allowed to change the following without it being\n/// considered a breaking change, don't depend on this, it's just here to inform\n/// the user. On platforms that use epoll, kqueue or IOCP (see implementation\n/// notes below) polling without previously registering [event sources] will\n/// result in sleeping forever, only a process signal will be able to wake up\n/// the thread.\n///\n/// On WASM/WASI this is different as it doesn't support process signals,\n/// furthermore the WASI specification doesn't specify a behaviour in this\n/// situation, thus it's up to the implementation what to do here. As an\n/// example, the wasmtime runtime will return `EINVAL` in this situation, but\n/// different runtimes may return different results. If you have further\n/// insights or thoughts about this situation (and/or how Mio should handle it)\n/// please add you comment to [pull request#1580].\n///\n/// [event sources]: crate::event::Source\n/// [pull request#1580]: https://github.com/tokio-rs/mio/pull/1580\n///\n/// # Implementation notes\n///\n/// `Poll` is backed by the selector provided by the operating system.\n///\n/// |      OS       |  Selector |\n/// |---------------|-----------|\n/// | Android       | [epoll]   |\n/// | DragonFly BSD | [kqueue]  |\n/// | FreeBSD       | [kqueue]  |\n/// | iOS           | [kqueue]  |\n/// | illumos       | [epoll]   |\n/// | Linux         | [epoll]   |\n/// | NetBSD        | [kqueue]  |\n/// | OpenBSD       | [kqueue]  |\n/// | Windows       | [IOCP]    |\n/// | macOS         | [kqueue]  |\n///\n/// On all supported platforms, socket operations are handled by using the\n/// system selector. Platform specific extensions (e.g. [`SourceFd`]) allow\n/// accessing other features provided by individual system selectors. For\n/// example, Linux's [`signalfd`] feature can be used by registering the FD with\n/// `Poll` via [`SourceFd`].\n///\n/// On all platforms except windows, a call to [`Poll::poll`] is mostly just a\n/// direct call to the system selector. However, [IOCP] uses a completion model\n/// instead of a readiness model. In this case, `Poll` must adapt the completion\n/// model Mio's API. While non-trivial, the bridge layer is still quite\n/// efficient. The most expensive part being calls to `read` and `write` require\n/// data to be copied into an intermediate buffer before it is passed to the\n/// kernel.\n///\n/// [epoll]: https://man7.org/linux/man-pages/man7/epoll.7.html\n/// [kqueue]: https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\n/// [IOCP]: https://docs.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports\n/// [`signalfd`]: https://man7.org/linux/man-pages/man2/signalfd.2.html\n/// [`SourceFd`]: unix/struct.SourceFd.html\n/// [`Poll::poll`]: struct.Poll.html#method.poll\npub struct Poll {\n    registry: Registry,\n}","Real(LocalPath(\"src/poll.rs\"))"],"poll::Poll::poll":["/// Wait for readiness events\n///\n/// Blocks the current thread and waits for readiness events for any of the\n/// [`event::Source`]s that have been registered with this `Poll` instance.\n/// The function will block until either at least one readiness event has\n/// been received or `timeout` has elapsed. A `timeout` of `None` means that\n/// `poll` will block until a readiness event has been received.\n///\n/// The supplied `events` will be cleared and newly received readiness events\n/// will be pushed onto the end. At most `events.capacity()` events will be\n/// returned. If there are further pending readiness events, they will be\n/// returned on the next call to `poll`.\n///\n/// A single call to `poll` may result in multiple readiness events being\n/// returned for a single event source. For example, if a TCP socket becomes\n/// both readable and writable, it may be possible for a single readiness\n/// event to be returned with both [`readable`] and [`writable`] readiness\n/// **OR** two separate events may be returned, one with [`readable`] set\n/// and one with [`writable`] set.\n///\n/// Note that the `timeout` will be rounded up to the system clock\n/// granularity (usually 1ms), and kernel scheduling delays mean that\n/// the blocking interval may be overrun by a small amount.\n///\n/// See the [struct] level documentation for a higher level discussion of\n/// polling.\n///\n/// [`event::Source`]: ./event/trait.Source.html\n/// [`readable`]: struct.Interest.html#associatedconstant.READABLE\n/// [`writable`]: struct.Interest.html#associatedconstant.WRITABLE\n/// [struct]: struct.Poll.html\n/// [`iter`]: ./event/struct.Events.html#method.iter\n///\n/// # Notes\n///\n/// This returns any errors without attempting to retry, previous versions\n/// of Mio would automatically retry the poll call if it was interrupted\n/// (if `EINTR` was returned).\n///\n/// Currently if the `timeout` elapses without any readiness events\n/// triggering this will return `Ok(())`. However we're not guaranteeing\n/// this behaviour as this depends on the OS.\n///\n/// # Examples\n///\n/// A basic example -- establishing a `TcpStream` connection.\n///\ndoc = \"```ignore\"\n/// # use std::error::Error;\n/// # fn main() -> Result<(), Box<dyn Error>> {\n/// use mio::{Events, Poll, Interest, Token};\n/// use mio::net::TcpStream;\n///\n/// use std::net::{TcpListener, SocketAddr};\n/// use std::thread;\n///\n/// // Bind a server socket to connect to.\n/// let addr: SocketAddr = \"127.0.0.1:0\".parse()?;\n/// let server = TcpListener::bind(addr)?;\n/// let addr = server.local_addr()?.clone();\n///\n/// // Spawn a thread to accept the socket\n/// thread::spawn(move || {\n///     let _ = server.accept();\n/// });\n///\n/// // Construct a new `Poll` handle as well as the `Events` we'll store into\n/// let mut poll = Poll::new()?;\n/// let mut events = Events::with_capacity(1024);\n///\n/// // Connect the stream\n/// let mut stream = TcpStream::connect(addr)?;\n///\n/// // Register the stream with `Poll`\n/// poll.registry().register(\n///     &mut stream,\n///     Token(0),\n///     Interest::READABLE | Interest::WRITABLE)?;\n///\n/// // Wait for the socket to become ready. This has to happens in a loop to\n/// // handle spurious wakeups.\n/// loop {\n///     poll.poll(&mut events, None)?;\n///\n///     for event in &events {\n///         if event.token() == Token(0) && event.is_writable() {\n///             // The socket connected (probably, it could still be a spurious\n///             // wakeup)\n///             return Ok(());\n///         }\n///     }\n/// }\n/// # }\n/// ```\n///\n/// [struct]: #\npub fn poll(&mut self, events: &mut Events, timeout: Option<Duration>) -> io::Result<()>{\n        self.registry.selector.select(events.sys(), timeout)\n    }","Real(LocalPath(\"src/poll.rs\"))"],"poll::Poll::registry":["/// Create a separate `Registry` which can be used to register\n/// `event::Source`s.\npub fn registry(&self) -> &Registry{\n        &self.registry\n    }","Real(LocalPath(\"src/poll.rs\"))"],"poll::Registry":["/// Registers I/O resources.\npub struct Registry {\n    selector: sys::Selector,\n}","Real(LocalPath(\"src/poll.rs\"))"],"poll::Registry::deregister":["/// Deregister an [`event::Source`] with the `Poll` instance.\n///\n/// When an event source is deregistered, the `Poll` instance will no longer\n/// monitor it for readiness state changes. Deregistering clears up any\n/// internal resources needed to track the handle.  After an explicit call\n/// to this method completes, it is guaranteed that the token previously\n/// registered to this handle will not be returned by a future poll, so long\n/// as a happens-before relationship is established between this call and\n/// the poll.\n///\n/// The event source must have previously been registered with this instance\n/// of `Poll`, otherwise the behavior is unspecified.\n///\n/// A handle can be passed back to `register` after it has been\n/// deregistered; however, it must be passed back to the **same** `Poll`\n/// instance, otherwise the behavior is unspecified.\n///\n/// # Examples\n///\ndoc = \"```ignore\"\n/// # use std::error::Error;\n/// # use std::net;\n/// # fn main() -> Result<(), Box<dyn Error>> {\n/// use mio::{Events, Poll, Interest, Token};\n/// use mio::net::TcpStream;\n/// use std::net::SocketAddr;\n/// use std::time::Duration;\n///\n/// let mut poll = Poll::new()?;\n///\n/// let address: SocketAddr = \"127.0.0.1:0\".parse()?;\n/// let listener = net::TcpListener::bind(address)?;\n/// let mut socket = TcpStream::connect(listener.local_addr()?)?;\n///\n/// // Register the socket with `poll`\n/// poll.registry().register(\n///     &mut socket,\n///     Token(0),\n///     Interest::READABLE)?;\n///\n/// poll.registry().deregister(&mut socket)?;\n///\n/// let mut events = Events::with_capacity(1024);\n///\n/// // Set a timeout because this poll should never receive any events.\n/// poll.poll(&mut events, Some(Duration::from_secs(1)))?;\n/// assert!(events.is_empty());\n/// #     Ok(())\n/// # }\n/// ```\npub fn deregister<S>(&self, source: &mut S) -> io::Result<()>\n    where\n        S: event::Source + ?Sized,{\n        trace!(\"deregistering event source from poller\");\n        source.deregister(self)\n    }","Real(LocalPath(\"src/poll.rs\"))"],"poll::Registry::register":["/// Register an [`event::Source`] with the `Poll` instance.\n///\n/// Once registered, the `Poll` instance will monitor the event source for\n/// readiness state changes. When it notices a state change, it will return\n/// a readiness event for the handle the next time [`poll`] is called.\n///\n/// See [`Poll`] docs for a high level overview.\n///\n/// # Arguments\n///\n/// `source: &mut S: event::Source`: This is the source of events that the\n/// `Poll` instance should monitor for readiness state changes.\n///\n/// `token: Token`: The caller picks a token to associate with the socket.\n/// When [`poll`] returns an event for the handle, this token is included.\n/// This allows the caller to map the event to its source. The token\n/// associated with the `event::Source` can be changed at any time by\n/// calling [`reregister`].\n///\n/// See documentation on [`Token`] for an example showing how to pick\n/// [`Token`] values.\n///\n/// `interest: Interest`: Specifies which operations `Poll` should monitor\n/// for readiness. `Poll` will only return readiness events for operations\n/// specified by this argument.\n///\n/// If a socket is registered with readable interest and the socket becomes\n/// writable, no event will be returned from [`poll`].\n///\n/// The readiness interest for an `event::Source` can be changed at any time\n/// by calling [`reregister`].\n///\n/// # Notes\n///\n/// Callers must ensure that if a source being registered with a `Poll`\n/// instance was previously registered with that `Poll` instance, then a\n/// call to [`deregister`] has already occurred. Consecutive calls to\n/// `register` is unspecified behavior.\n///\n/// Unless otherwise specified, the caller should assume that once an event\n/// source is registered with a `Poll` instance, it is bound to that `Poll`\n/// instance for the lifetime of the event source. This remains true even\n/// if the event source is deregistered from the poll instance using\n/// [`deregister`].\n///\n/// [`event::Source`]: ./event/trait.Source.html\n/// [`poll`]: struct.Poll.html#method.poll\n/// [`reregister`]: struct.Registry.html#method.reregister\n/// [`deregister`]: struct.Registry.html#method.deregister\n/// [`Token`]: struct.Token.html\n///\n/// # Examples\n///\ndoc = \"```ignore\"\n/// # use std::error::Error;\n/// # use std::net;\n/// # fn main() -> Result<(), Box<dyn Error>> {\n/// use mio::{Events, Poll, Interest, Token};\n/// use mio::net::TcpStream;\n/// use std::net::SocketAddr;\n/// use std::time::{Duration, Instant};\n///\n/// let mut poll = Poll::new()?;\n///\n/// let address: SocketAddr = \"127.0.0.1:0\".parse()?;\n/// let listener = net::TcpListener::bind(address)?;\n/// let mut socket = TcpStream::connect(listener.local_addr()?)?;\n///\n/// // Register the socket with `poll`\n/// poll.registry().register(\n///     &mut socket,\n///     Token(0),\n///     Interest::READABLE | Interest::WRITABLE)?;\n///\n/// let mut events = Events::with_capacity(1024);\n/// let start = Instant::now();\n/// let timeout = Duration::from_millis(500);\n///\n/// loop {\n///     let elapsed = start.elapsed();\n///\n///     if elapsed >= timeout {\n///         // Connection timed out\n///         return Ok(());\n///     }\n///\n///     let remaining = timeout - elapsed;\n///     poll.poll(&mut events, Some(remaining))?;\n///\n///     for event in &events {\n///         if event.token() == Token(0) {\n///             // Something (probably) happened on the socket.\n///             return Ok(());\n///         }\n///     }\n/// }\n/// # }\n/// ```\npub fn register<S>(&self, source: &mut S, token: Token, interests: Interest) -> io::Result<()>\n    where\n        S: event::Source + ?Sized,{\n        trace!(\n            \"registering event source with poller: token={:?}, interests={:?}\",\n            token,\n            interests\n        );\n        source.register(self, token, interests)\n    }","Real(LocalPath(\"src/poll.rs\"))"],"poll::Registry::register_waker":["/// Internal check to ensure only a single `Waker` is active per [`Poll`]\n/// instance.\n#[cfg(all(debug_assertions, not(target_os = \"wasi\")))]\npub(crate) fn register_waker(&self){\n        assert!(\n            !self.selector.register_waker(),\n            \"Only a single `Waker` can be active per `Poll` instance\"\n        );\n    }","Real(LocalPath(\"src/poll.rs\"))"],"poll::Registry::reregister":["/// Re-register an [`event::Source`] with the `Poll` instance.\n///\n/// Re-registering an event source allows changing the details of the\n/// registration. Specifically, it allows updating the associated `token`\n/// and `interests` specified in previous `register` and `reregister` calls.\n///\n/// The `reregister` arguments fully override the previous values. In other\n/// words, if a socket is registered with [`readable`] interest and the call\n/// to `reregister` specifies [`writable`], then read interest is no longer\n/// requested for the handle.\n///\n/// The event source must have previously been registered with this instance\n/// of `Poll`, otherwise the behavior is unspecified.\n///\n/// See the [`register`] documentation for details about the function\n/// arguments and see the [`struct`] docs for a high level overview of\n/// polling.\n///\n/// # Examples\n///\ndoc = \"```ignore\"\n/// # use std::error::Error;\n/// # use std::net;\n/// # fn main() -> Result<(), Box<dyn Error>> {\n/// use mio::{Poll, Interest, Token};\n/// use mio::net::TcpStream;\n/// use std::net::SocketAddr;\n///\n/// let poll = Poll::new()?;\n///\n/// let address: SocketAddr = \"127.0.0.1:0\".parse()?;\n/// let listener = net::TcpListener::bind(address)?;\n/// let mut socket = TcpStream::connect(listener.local_addr()?)?;\n///\n/// // Register the socket with `poll`, requesting readable\n/// poll.registry().register(\n///     &mut socket,\n///     Token(0),\n///     Interest::READABLE)?;\n///\n/// // Reregister the socket specifying write interest instead. Even though\n/// // the token is the same it must be specified.\n/// poll.registry().reregister(\n///     &mut socket,\n///     Token(0),\n///     Interest::WRITABLE)?;\n/// #     Ok(())\n/// # }\n/// ```\n///\n/// [`event::Source`]: ./event/trait.Source.html\n/// [`struct`]: struct.Poll.html\n/// [`register`]: struct.Registry.html#method.register\n/// [`readable`]: ./event/struct.Event.html#is_readable\n/// [`writable`]: ./event/struct.Event.html#is_writable\npub fn reregister<S>(&self, source: &mut S, token: Token, interests: Interest) -> io::Result<()>\n    where\n        S: event::Source + ?Sized,{\n        trace!(\n            \"reregistering event source with poller: token={:?}, interests={:?}\",\n            token,\n            interests\n        );\n        source.reregister(self, token, interests)\n    }","Real(LocalPath(\"src/poll.rs\"))"],"poll::Registry::selector":["/// Get access to the `sys::Selector`.\n#[cfg(any(not(target_os = \"wasi\"), feature = \"net\"))]\npub(crate) fn selector(&self) -> &sys::Selector{\n        &self.selector\n    }","Real(LocalPath(\"src/poll.rs\"))"],"poll::Registry::try_clone":["/// Creates a new independently owned `Registry`.\n///\n/// Event sources registered with this `Registry` will be registered with\n/// the original `Registry` and `Poll` instance.\npub fn try_clone(&self) -> io::Result<Registry>{\n        self.selector\n            .try_clone()\n            .map(|selector| Registry { selector })\n    }","Real(LocalPath(\"src/poll.rs\"))"],"sys::shell::selector::Selector":["pub struct Selector {}","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::Selector::register_waker":["#[cfg(all(debug_assertions, not(target_os = \"wasi\")))]\npub fn register_waker(&self) -> bool{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::Selector::select":["pub fn select(&self, _: &mut Events, _: Option<Duration>) -> io::Result<()>{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::Selector::try_clone":["pub fn try_clone(&self) -> io::Result<Selector>{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::event::debug_details":["pub fn debug_details(_: &mut fmt::Formatter<'_>, _: &Event) -> fmt::Result{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::event::is_aio":["pub fn is_aio(_: &Event) -> bool{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::event::is_error":["pub fn is_error(_: &Event) -> bool{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::event::is_lio":["pub fn is_lio(_: &Event) -> bool{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::event::is_priority":["pub fn is_priority(_: &Event) -> bool{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::event::is_read_closed":["pub fn is_read_closed(_: &Event) -> bool{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::event::is_readable":["pub fn is_readable(_: &Event) -> bool{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::event::is_writable":["pub fn is_writable(_: &Event) -> bool{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::event::is_write_closed":["pub fn is_write_closed(_: &Event) -> bool{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::selector::event::token":["pub fn token(_: &Event) -> Token{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/selector.rs\"))"],"sys::shell::waker::Waker":["pub struct Waker {}","Real(LocalPath(\"src/sys/shell/waker.rs\"))"],"sys::shell::waker::Waker::new":["pub fn new(_: &Selector, _: Token) -> io::Result<Waker>{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/waker.rs\"))"],"sys::shell::waker::Waker::wake":["pub fn wake(&self) -> io::Result<()>{\n        os_required!();\n    }","Real(LocalPath(\"src/sys/shell/waker.rs\"))"],"token::<impl std::convert::From<token::Token> for usize>::from":["fn from(val: Token) -> usize{\n        val.0\n    }","Real(LocalPath(\"src/token.rs\"))"],"token::Token":["/// Associates readiness events with [`event::Source`]s.\n///\n/// `Token` is a wrapper around `usize` and is used as an argument to\n/// [`Registry::register`] and [`Registry::reregister`].\n///\n/// See [`Poll`] for more documentation on polling.\n///\n/// [`event::Source`]: ./event/trait.Source.html\n/// [`Poll`]: struct.Poll.html\n/// [`Registry::register`]: struct.Registry.html#method.register\n/// [`Registry::reregister`]: struct.Registry.html#method.reregister\n///\n/// # Example\n///\n/// Using `Token` to track which socket generated the event. In this example,\n/// `HashMap` is used, but usually something like [`slab`] is better.\n///\n/// [`slab`]: https://crates.io/crates/slab\n///\ndoc = \"```ignore\"\n/// # use std::error::Error;\n/// # fn main() -> Result<(), Box<dyn Error>> {\n/// use mio::{Events, Interest, Poll, Token};\n/// use mio::net::TcpListener;\n///\n/// use std::thread;\n/// use std::io::{self, Read};\n/// use std::collections::HashMap;\n///\n/// // After this number of sockets is accepted, the server will shutdown.\n/// const MAX_SOCKETS: usize = 32;\n///\n/// // Pick a token that will not be used by any other socket and use that one\n/// // for the listener.\n/// const LISTENER: Token = Token(1024);\n///\n/// // Used to store the sockets.\n/// let mut sockets = HashMap::new();\n///\n/// // This is used to generate a unique token for a socket\n/// let mut next_socket_index = 0;\n///\n/// // The `Poll` instance\n/// let mut poll = Poll::new()?;\n///\n/// // Tcp listener\n/// let mut listener = TcpListener::bind(\"127.0.0.1:0\".parse()?)?;\n///\n/// // Register the listener\n/// poll.registry().register(&mut listener, LISTENER, Interest::READABLE)?;\n///\n/// // Spawn a thread that will connect a bunch of sockets then close them\n/// let addr = listener.local_addr()?;\n/// thread::spawn(move || {\n///     use std::net::TcpStream;\n///\n///     // +1 here is to connect an extra socket to signal the socket to close\n///     for _ in 0..(MAX_SOCKETS+1) {\n///         // Connect then drop the socket\n///         let _ = TcpStream::connect(addr).unwrap();\n///     }\n/// });\n///\n/// // Event storage\n/// let mut events = Events::with_capacity(1024);\n///\n/// // Read buffer, this will never actually get filled\n/// let mut buf = [0; 256];\n///\n/// // The main event loop\n/// loop {\n///     // Wait for events\n///     poll.poll(&mut events, None)?;\n///\n///     for event in &events {\n///         match event.token() {\n///             LISTENER => {\n///                 // Perform operations in a loop until `WouldBlock` is\n///                 // encountered.\n///                 loop {\n///                     match listener.accept() {\n///                         Ok((mut socket, _)) => {\n///                             // Shutdown the server\n///                             if next_socket_index == MAX_SOCKETS {\n///                                 return Ok(());\n///                             }\n///\n///                             // Get the token for the socket\n///                             let token = Token(next_socket_index);\n///                             next_socket_index += 1;\n///\n///                             // Register the new socket w/ poll\n///                             poll.registry().register(&mut socket, token, Interest::READABLE)?;\n///\n///                             // Store the socket\n///                             sockets.insert(token, socket);\n///                         }\n///                         Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n///                             // Socket is not ready anymore, stop accepting\n///                             break;\n///                         }\n///                         e => panic!(\"err={:?}\", e), // Unexpected error\n///                     }\n///                 }\n///             }\n///             token => {\n///                 // Always operate in a loop\n///                 loop {\n///                     match sockets.get_mut(&token).unwrap().read(&mut buf) {\n///                         Ok(0) => {\n///                             // Socket is closed, remove it from the map\n///                             sockets.remove(&token);\n///                             break;\n///                         }\n///                         // Data is not actually sent in this example\n///                         Ok(_) => unreachable!(),\n///                         Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n///                             // Socket is not ready anymore, stop reading\n///                             break;\n///                         }\n///                         e => panic!(\"err={:?}\", e), // Unexpected error\n///                     }\n///                 }\n///             }\n///         }\n///     }\n/// }\n/// # }\n/// ```\npub struct Token(pub usize);","Real(LocalPath(\"src/token.rs\"))"],"waker::Waker":["/// Waker allows cross-thread waking of [`Poll`].\n///\n/// When created it will cause events with [`readable`] readiness and the\n/// provided `token` if [`wake`] is called, possibly from another thread.\n///\n/// [`Poll`]: struct.Poll.html\n/// [`readable`]: ./event/struct.Event.html#method.is_readable\n/// [`wake`]: struct.Waker.html#method.wake\n///\n/// # Notes\n///\n/// `Waker` events are only guaranteed to be delivered while the `Waker` value\n/// is alive.\n///\n/// Only a single `Waker` can be active per [`Poll`], if multiple threads need\n/// access to the `Waker` it can be shared via for example an `Arc`. What\n/// happens if multiple `Waker`s are registered with the same `Poll` is\n/// unspecified.\n///\n/// # Implementation notes\n///\n/// On platforms that support kqueue this will use the `EVFILT_USER` event\n/// filter, see [implementation notes of `Poll`] to see what platforms support\n/// kqueue. On Linux it uses [eventfd].\n///\n/// [implementation notes of `Poll`]: struct.Poll.html#implementation-notes\n/// [eventfd]: https://man7.org/linux/man-pages/man2/eventfd.2.html\n///\n/// # Examples\n///\n/// Wake a [`Poll`] instance from another thread.\n///\ndoc = \"```ignore\"\n/// # fn main() -> Result<(), Box<dyn std::error::Error>> {\n/// use std::thread;\n/// use std::time::Duration;\n/// use std::sync::Arc;\n///\n/// use mio::{Events, Token, Poll, Waker};\n///\n/// const WAKE_TOKEN: Token = Token(10);\n///\n/// let mut poll = Poll::new()?;\n/// let mut events = Events::with_capacity(2);\n///\n/// let waker = Arc::new(Waker::new(poll.registry(), WAKE_TOKEN)?);\n///\n/// // We need to keep the Waker alive, so we'll create a clone for the\n/// // thread we create below.\n/// let waker1 = waker.clone();\n/// let handle = thread::spawn(move || {\n///     // Working hard, or hardly working?\n///     thread::sleep(Duration::from_millis(500));\n///\n///     // Now we'll wake the queue on the other thread.\n///     waker1.wake().expect(\"unable to wake\");\n/// });\n///\n/// // On our current thread we'll poll for events, without a timeout.\n/// poll.poll(&mut events, None)?;\n///\n/// // After about 500 milliseconds we should be awoken by the other thread and\n/// // get a single event.\n/// assert!(!events.is_empty());\n/// let waker_event = events.iter().next().unwrap();\n/// assert!(waker_event.is_readable());\n/// assert_eq!(waker_event.token(), WAKE_TOKEN);\n/// # handle.join().unwrap();\n/// #     Ok(())\n/// # }\n/// ```\npub struct Waker {\n    inner: sys::Waker,\n}","Real(LocalPath(\"src/waker.rs\"))"],"waker::Waker::new":["/// Create a new `Waker`.\npub fn new(registry: &Registry, token: Token) -> io::Result<Waker>{\n        #[cfg(debug_assertions)]\n        registry.register_waker();\n        sys::Waker::new(registry.selector(), token).map(|inner| Waker { inner })\n    }","Real(LocalPath(\"src/waker.rs\"))"],"waker::Waker::wake":["/// Wake up the [`Poll`] associated with this `Waker`.\n///\n/// [`Poll`]: struct.Poll.html\npub fn wake(&self) -> io::Result<()>{\n        self.inner.wake()\n    }","Real(LocalPath(\"src/waker.rs\"))"]},"struct_constructor":{"&event::event::Event":["from_sys_event_ref"],"&poll::Registry":["registry"],"&sys::shell::selector::Selector":["selector"],"(usize, std::option::Option<usize>)":["size_hint"],"<&'a event::events::Events as std::iter::IntoIterator>::IntoIter":["into_iter"],"<event::events::Iter<'a> as std::iter::Iterator>::Item":["next"],"bool":["eq","is_aio","is_empty","is_error","is_lio","is_priority","is_read_closed","is_readable","is_writable","is_write_closed","register_waker"],"event::event::Event":["clone"],"event::events::Events":["with_capacity"],"event::events::Iter":["clone","iter"],"i32":["as_raw_fd"],"interest::Interest":["clone"],"poll::Registry":["try_clone"],"std::cmp::Ordering":["cmp","partial_cmp"],"sys::shell::selector::Selector":["try_clone"],"sys::shell::waker::Waker":["new"],"token::Token":["clone","token"],"usize":["capacity","count","from"],"waker::Waker":["new"]},"struct_to_trait":{"<event::event::Event as std::fmt::Debug>::fmt::EventDetails":["std::fmt::Debug"],"event::event::Event":["std::clone::Clone","std::fmt::Debug"],"event::events::Events":["std::fmt::Debug"],"event::events::Iter":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"interest::Interest":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::BitOr","std::ops::BitOrAssign"],"poll::Poll":["std::fmt::Debug","std::os::fd::AsRawFd"],"poll::Registry":["std::fmt::Debug","std::os::fd::AsRawFd"],"std::boxed::Box":["event::source::Source"],"sys::shell::selector::Selector":["std::fmt::Debug","std::os::fd::AsRawFd"],"sys::shell::waker::Waker":["std::fmt::Debug"],"token::Token":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"waker::Waker":["std::fmt::Debug"]},"targets":{"<&'a event::events::Events as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/event/events.rs\"))","std::iter::IntoIterator"],"<<event::event::Event as std::fmt::Debug>::fmt::EventDetails<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/event/event.rs\"))","std::fmt::Debug"],"<event::event::Event as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/event/event.rs\"))","std::fmt::Debug"],"<event::events::Events as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/event/events.rs\"))","std::fmt::Debug"],"<event::events::Iter<'a> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/event/events.rs\"))","std::iter::Iterator"],"<event::events::Iter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/event/events.rs\"))","std::iter::Iterator"],"<event::events::Iter<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/event/events.rs\"))","std::iter::Iterator"],"<interest::Interest as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/interest.rs\"))","std::fmt::Debug"],"<interest::Interest as std::ops::BitOr>::bitor":["bitor","Real(LocalPath(\"src/interest.rs\"))","std::ops::BitOr"],"<interest::Interest as std::ops::BitOrAssign>::bitor_assign":["bitor_assign","Real(LocalPath(\"src/interest.rs\"))","std::ops::BitOrAssign"],"<poll::Poll as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/poll.rs\"))","std::fmt::Debug"],"<poll::Poll as std::os::fd::AsRawFd>::as_raw_fd":["as_raw_fd","Real(LocalPath(\"src/poll.rs\"))","std::os::fd::AsRawFd"],"<poll::Registry as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/poll.rs\"))","std::fmt::Debug"],"<poll::Registry as std::os::fd::AsRawFd>::as_raw_fd":["as_raw_fd","Real(LocalPath(\"src/poll.rs\"))","std::os::fd::AsRawFd"],"<std::boxed::Box<T> as event::source::Source>::deregister":["deregister","Real(LocalPath(\"src/event/source.rs\"))","event::source::Source"],"<std::boxed::Box<T> as event::source::Source>::register":["register","Real(LocalPath(\"src/event/source.rs\"))","event::source::Source"],"<std::boxed::Box<T> as event::source::Source>::reregister":["reregister","Real(LocalPath(\"src/event/source.rs\"))","event::source::Source"],"<sys::shell::selector::Selector as std::os::fd::AsRawFd>::as_raw_fd":["as_raw_fd","Real(LocalPath(\"src/sys/shell/selector.rs\"))","std::os::fd::AsRawFd"],"event::event::Event::from_sys_event_ref":["from_sys_event_ref","Real(LocalPath(\"src/event/event.rs\"))",""],"event::event::Event::is_aio":["is_aio","Real(LocalPath(\"src/event/event.rs\"))",""],"event::event::Event::is_error":["is_error","Real(LocalPath(\"src/event/event.rs\"))",""],"event::event::Event::is_lio":["is_lio","Real(LocalPath(\"src/event/event.rs\"))",""],"event::event::Event::is_priority":["is_priority","Real(LocalPath(\"src/event/event.rs\"))",""],"event::event::Event::is_read_closed":["is_read_closed","Real(LocalPath(\"src/event/event.rs\"))",""],"event::event::Event::is_readable":["is_readable","Real(LocalPath(\"src/event/event.rs\"))",""],"event::event::Event::is_writable":["is_writable","Real(LocalPath(\"src/event/event.rs\"))",""],"event::event::Event::is_write_closed":["is_write_closed","Real(LocalPath(\"src/event/event.rs\"))",""],"event::event::Event::token":["token","Real(LocalPath(\"src/event/event.rs\"))",""],"event::events::Events::capacity":["capacity","Real(LocalPath(\"src/event/events.rs\"))",""],"event::events::Events::clear":["clear","Real(LocalPath(\"src/event/events.rs\"))",""],"event::events::Events::is_empty":["is_empty","Real(LocalPath(\"src/event/events.rs\"))",""],"event::events::Events::iter":["iter","Real(LocalPath(\"src/event/events.rs\"))",""],"event::events::Events::sys":["sys","Real(LocalPath(\"src/event/events.rs\"))",""],"event::events::Events::with_capacity":["with_capacity","Real(LocalPath(\"src/event/events.rs\"))",""],"interest::Interest::add":["add","Real(LocalPath(\"src/interest.rs\"))",""],"interest::Interest::is_aio":["is_aio","Real(LocalPath(\"src/interest.rs\"))",""],"interest::Interest::is_lio":["is_lio","Real(LocalPath(\"src/interest.rs\"))",""],"interest::Interest::is_priority":["is_priority","Real(LocalPath(\"src/interest.rs\"))",""],"interest::Interest::is_readable":["is_readable","Real(LocalPath(\"src/interest.rs\"))",""],"interest::Interest::is_writable":["is_writable","Real(LocalPath(\"src/interest.rs\"))",""],"interest::Interest::remove":["remove","Real(LocalPath(\"src/interest.rs\"))",""],"poll::Poll::poll":["poll","Real(LocalPath(\"src/poll.rs\"))",""],"poll::Poll::registry":["registry","Real(LocalPath(\"src/poll.rs\"))",""],"poll::Registry::deregister":["deregister","Real(LocalPath(\"src/poll.rs\"))",""],"poll::Registry::register":["register","Real(LocalPath(\"src/poll.rs\"))",""],"poll::Registry::register_waker":["register_waker","Real(LocalPath(\"src/poll.rs\"))",""],"poll::Registry::reregister":["reregister","Real(LocalPath(\"src/poll.rs\"))",""],"poll::Registry::selector":["selector","Real(LocalPath(\"src/poll.rs\"))",""],"poll::Registry::try_clone":["try_clone","Real(LocalPath(\"src/poll.rs\"))",""],"sys::shell::selector::Selector::register_waker":["register_waker","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::selector::Selector::select":["select","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::selector::Selector::try_clone":["try_clone","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::selector::event::debug_details":["debug_details","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::selector::event::is_aio":["is_aio","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::selector::event::is_error":["is_error","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::selector::event::is_lio":["is_lio","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::selector::event::is_priority":["is_priority","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::selector::event::is_read_closed":["is_read_closed","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::selector::event::is_readable":["is_readable","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::selector::event::is_writable":["is_writable","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::selector::event::is_write_closed":["is_write_closed","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::selector::event::token":["token","Real(LocalPath(\"src/sys/shell/selector.rs\"))",""],"sys::shell::waker::Waker::new":["new","Real(LocalPath(\"src/sys/shell/waker.rs\"))",""],"sys::shell::waker::Waker::wake":["wake","Real(LocalPath(\"src/sys/shell/waker.rs\"))",""],"token::<impl std::convert::From<token::Token> for usize>::from":["from","Real(LocalPath(\"src/token.rs\"))","std::convert::From"],"waker::Waker::new":["new","Real(LocalPath(\"src/waker.rs\"))",""],"waker::Waker::wake":["wake","Real(LocalPath(\"src/waker.rs\"))",""]},"trait_to_struct":{"event::source::Source":["std::boxed::Box"],"std::clone::Clone":["event::event::Event","event::events::Iter","interest::Interest","token::Token"],"std::cmp::Eq":["interest::Interest","token::Token"],"std::cmp::Ord":["interest::Interest","token::Token"],"std::cmp::PartialEq":["interest::Interest","token::Token"],"std::cmp::PartialOrd":["interest::Interest","token::Token"],"std::fmt::Debug":["<event::event::Event as std::fmt::Debug>::fmt::EventDetails","event::event::Event","event::events::Events","event::events::Iter","interest::Interest","poll::Poll","poll::Registry","sys::shell::selector::Selector","sys::shell::waker::Waker","token::Token","waker::Waker"],"std::hash::Hash":["token::Token"],"std::iter::Iterator":["event::events::Iter"],"std::marker::Copy":["interest::Interest","token::Token"],"std::marker::StructuralEq":["interest::Interest","token::Token"],"std::marker::StructuralPartialEq":["interest::Interest","token::Token"],"std::ops::BitOr":["interest::Interest"],"std::ops::BitOrAssign":["interest::Interest"],"std::os::fd::AsRawFd":["poll::Poll","poll::Registry","sys::shell::selector::Selector"]},"type_to_def_path":{"<event::event::Event as std::fmt::Debug>::fmt::EventDetails<'a>":"<event::event::Event as std::fmt::Debug>::fmt::EventDetails","event::event::Event":"event::event::Event","event::events::Events":"event::events::Events","event::events::Iter<'a>":"event::events::Iter","interest::Interest":"interest::Interest","poll::Poll":"poll::Poll","poll::Registry":"poll::Registry","sys::shell::selector::Selector":"sys::shell::selector::Selector","sys::shell::waker::Waker":"sys::shell::waker::Waker","token::Token":"token::Token","waker::Waker":"waker::Waker"}}