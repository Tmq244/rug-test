-----------------
src/error.rs error::make_error
deps:{"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::clone::Clone"]},"error::make_error":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"error::make_error":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+error::make_error(p0, p1);
+crate::error::make_error(p0, p1);
+crate::error::make_error(p0, p1);
-----------------
src/error.rs error::append_error
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::append_error":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"error::append_error":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","number::Endianness","error::ErrorKind","internal::Needed","internal::Err"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+error::append_error(p0, p1, p2);
+crate::error::append_error(p0, p1, p2);
+crate::error::append_error(p0, p1, p2);
-----------------
src/error.rs error::context
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"error::context":{"E":["std::marker::Sized","error::ContextError"],"F":["std::marker::Sized","internal::Parser"],"I":["std::clone::Clone","std::marker::Sized"],"O":["std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"error::context":{"E":["error::Error","error::VerboseError"],"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Map","internal::Into","std::boxed::Box","internal::Or"],"I":["error::VerboseErrorKind","internal::Needed","error::VerboseError","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Err"],"O":["RUG_ANY"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::Or","internal::And","std::boxed::Box","internal::Into","internal::AndThen"],"G":["<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Or","internal::FlatMap","internal::And","internal::Into","std::boxed::Box"]},"internal::AndThen":{"F":["internal::FlatMap","internal::Map","internal::Or","internal::AndThen","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into"],"G":["internal::Map","internal::FlatMap","internal::AndThen","internal::And","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","error::ErrorKind","internal::Needed","number::Endianness"]},"internal::FlatMap":{"F":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::Into","internal::FlatMap","std::boxed::Box","internal::And"],"G":["core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","u8","i8","<T as std::convert::From<T>>"],"F":["internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","std::boxed::Box","internal::And","internal::Map"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::And"],"G":["core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::And","internal::Into","internal::Map"],"G":["<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Into","internal::And","std::boxed::Box","internal::FlatMap","internal::Map"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = "sample"; // None+&str
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+error::context(&p0, p1);
+crate::error::context(&p0, p1);
+crate::error::context(&p0, p1);
-----------------
src/error.rs error::convert_error
deps:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"error::convert_error":{"I":["std::marker::Sized","std::ops::Deref"]}}
candidates:{"<&T as std::ops::Deref>":{},"<&mut T as std::ops::Deref>":{},"error::convert_error":{"I":["std::sys_common::remutex::ReentrantMutexGuard<'_, T>","std::sync::mpmc::utils::CachePadded<T>","std::cell::RefMut<'_, T>","std::string::String","std::cell::Ref<'_, T>","std::sync::Arc<T>","std::panic::AssertUnwindSafe<T>","std::sync::mpmc::counter::Sender<C>","std::sync::RwLockWriteGuard<'_, T>","std::backtrace_rs::symbolize::gimli::mmap::Mmap","std::collections::binary_heap::PeekMut<'_, T>","std::mem::ManuallyDrop<T>","std::boxed::Box<T, A>","std::vec::Vec<T, A>","std::sys_common::lazy_box::LazyBox<T>","std::borrow::Cow<'_, B>","std::sync::mpmc::counter::Receiver<C>","std::ffi::CString","std::pin::Pin<P>","std::boxed::ThinBox<T>","std::io::IoSliceMut<'a>","std::io::IoSlice<'a>","std::sync::MutexGuard<'_, T>","std::sync::RwLockReadGuard<'_, T>","std::rc::Rc<T>","<&mut T as std::ops::Deref>","std::ffi::OsString","<&T as std::ops::Deref>","std::ffi::VaList<'a, 'f>","std::sys_common::wtf8::Wtf8Buf","std::path::PathBuf","std::cell::LazyCell<T, F>","std::sync::LazyLock<T, F>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+error::convert_error(p0, p1);
+crate::error::convert_error(p0, p1);
+crate::error::convert_error(p0, p1);
-----------------
src/error.rs error::error_to_u32
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
+error::error_to_u32(p0);
+crate::error::error_to_u32(p0);
+crate::error::error_to_u32(p0);
-----------------
src/error.rs error::dbg_dmp
'a
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::dbg_dmp":{"E":["std::marker::Sized","std::fmt::Debug"],"F":["std::ops::Fn","std::marker::Sized"],"O":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"error::dbg_dmp":{"E":["<&T as std::fmt::Debug>","internal::Needed","error::Error","error::ErrorKind","number::Endianness","error::VerboseErrorKind","<*const T as std::fmt::Debug>","traits::CompareResult","error::VerboseError","internal::Err"],"F":["core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr"],"O":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = "sample"; // None+&str
+error::dbg_dmp(p0, &p1);
+crate::error::dbg_dmp(p0, &p1);
+crate::error::dbg_dmp(p0, &p1);
-----------------
src/branch/mod.rs branch::alt
deps:{"branch::alt":{"E":["error::ParseError","std::marker::Sized"],"I":["std::clone::Clone","std::marker::Sized"],"List":["std::marker::Sized","branch::Alt"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"branch::alt":{"E":["error::VerboseError","error::Error"],"I":["internal::Needed","internal::Err","error::VerboseError","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","error::VerboseErrorKind"],"List":[],"O":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // List
+branch::alt(p0);
+crate::branch::alt(p0);
+crate::branch::alt(p0);
-----------------
src/branch/mod.rs branch::permutation
deps:{"<*const T as std::fmt::Debug>":{},"branch::permutation":{"E":["std::marker::Sized","error::ParseError"],"I":["std::clone::Clone","std::marker::Sized"],"List":["std::marker::Sized","branch::Permutation"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"branch::permutation":{"E":["error::Error","error::VerboseError"],"I":["number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","error::VerboseErrorKind","internal::Needed","error::ErrorKind","internal::Err"],"List":[],"O":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // List
+branch::permutation(p0);
+crate::branch::permutation(p0);
+crate::branch::permutation(p0);
-----------------
src/combinator/mod.rs combinator::rest
deps:{"combinator::rest":{"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Slice","traits::InputLength"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"combinator::rest":{"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+combinator::rest(p0);
+crate::combinator::rest(p0);
+crate::combinator::rest(p0);
-----------------
src/combinator/mod.rs combinator::rest_len
deps:{"<*const T as std::fmt::Debug>":{},"combinator::rest_len":{"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::InputLength"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"combinator::rest_len":{"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed","number::Endianness","error::ErrorKind","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+combinator::rest_len(p0);
+crate::combinator::rest_len(p0);
+crate::combinator::rest_len(p0);
-----------------
src/combinator/mod.rs combinator::map
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::map":{"E":["std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::map":{"E":["RUG_ANY"],"F":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::And","internal::Map"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"internal::And":{"F":["internal::Or","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Into","internal::FlatMap"],"G":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::FlatMap","internal::And","std::boxed::Box"]},"internal::AndThen":{"F":["internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Or","std::boxed::Box","internal::Into"],"G":["internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Map","internal::Or","internal::And"],"O1":["RUG_ANY"]},"internal::FlatMap":{"F":["internal::Or","internal::Into","internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::And"],"G":["core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Or","internal::Into","internal::And","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Into"],"G":["core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","std::boxed::Box","internal::Map"],"G":["internal::FlatMap","internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Or"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+combinator::map(p0, p1);
+crate::combinator::map(p0, p1);
+crate::combinator::map(p0, p1);
-----------------
src/combinator/mod.rs combinator::map_res
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::map_res":{"E":["std::marker::Sized","error::FromExternalError"],"E2":["std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"],"I":["std::clone::Clone","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::map_res":{"E":["error::Error","error::VerboseError"],"E2":["RUG_ANY"],"F":["internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Map","internal::Or","internal::AndThen"],"G":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace"],"I":["std::clone::impls::<impl std::clone::Clone for &T>","internal::Needed","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","number::Endianness","error::ErrorKind","internal::Err"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Into","internal::AndThen","internal::Or","internal::And","std::boxed::Box","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>"],"G":["internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::And","internal::Or","internal::AndThen"]},"internal::AndThen":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","std::boxed::Box","internal::Into","internal::Map","internal::AndThen"],"G":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::FlatMap","internal::Into","internal::Map","internal::And"],"O1":["RUG_ANY"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","internal::Err","internal::Needed","number::Endianness","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::And","std::boxed::Box","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Or"],"G":["core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::Map","internal::Or","internal::AndThen","std::boxed::Box","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","std::boxed::Box","internal::Or","internal::Into"],"G":["core::slice::ascii::EscapeByte","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Map","internal::Into"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::Map","internal::Or","std::boxed::Box","internal::FlatMap","internal::And"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+combinator::map_res(p0, p1);
+crate::combinator::map_res(p0, p1);
+crate::combinator::map_res(p0, p1);
-----------------
src/combinator/mod.rs combinator::map_opt
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::map_opt":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"],"I":["std::clone::Clone","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::map_opt":{"E":["error::Error","error::VerboseError"],"F":["internal::Or","internal::Map","internal::AndThen","internal::FlatMap","internal::And","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>"],"G":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"],"I":["internal::Err","std::clone::impls::<impl std::clone::Clone for &T>","error::ErrorKind","number::Endianness","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Needed","error::VerboseErrorKind"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::AndThen","std::boxed::Box","internal::Or","internal::Into","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And"],"G":["std::boxed::Box","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Or","internal::Into"]},"internal::AndThen":{"F":["internal::Map","internal::AndThen","internal::Or","internal::Into","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And"],"G":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::AndThen","internal::Or","internal::And","internal::Into","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","number::Endianness","error::ErrorKind","internal::Needed","internal::Err"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","std::boxed::Box","internal::And","internal::FlatMap","internal::Into","internal::Or"],"G":["core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["internal::And","internal::AndThen","internal::FlatMap","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Map","internal::Or","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Into"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::FlatMap","internal::And","internal::AndThen","internal::Into","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map"],"G":["internal::And","internal::Into","internal::AndThen","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+combinator::map_opt(p0, p1);
+crate::combinator::map_opt(p0, p1);
+crate::combinator::map_opt(p0, p1);
-----------------
src/combinator/mod.rs combinator::map_parser
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::map_parser":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::map_parser":{"E":["error::VerboseError","error::Error"],"F":["internal::And","internal::AndThen","internal::Into","std::boxed::Box","internal::Or","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>"],"G":["internal::And","internal::Map","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::FlatMap"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Map","internal::And","internal::Into"],"G":["internal::Map","internal::FlatMap","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","std::boxed::Box"]},"internal::AndThen":{"F":["internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","std::boxed::Box","internal::And","internal::Map"],"G":["internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Or","internal::AndThen","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","number::Endianness"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::And","internal::Map"],"G":["core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::FlatMap","internal::Into","internal::Or","std::boxed::Box","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","internal::Or","internal::FlatMap","internal::Map","internal::Into","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Into","internal::Map","std::boxed::Box","internal::Or","internal::FlatMap"],"G":["internal::And","internal::FlatMap","std::boxed::Box","internal::Or","internal::AndThen","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+combinator::map_parser(p0, p1);
+crate::combinator::map_parser(p0, p1);
+crate::combinator::map_parser(p0, p1);
-----------------
src/combinator/mod.rs combinator::flat_map
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::flat_map":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::flat_map":{"E":["error::VerboseError","error::Error"],"F":["internal::Or","internal::AndThen","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Into"],"G":["core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"],"H":["internal::FlatMap","internal::AndThen","internal::Into","internal::Map","std::boxed::Box","internal::Or","internal::And","<F as internal::Parser<I, O, E>>"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","internal::And","internal::Or","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into"],"G":["internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","std::boxed::Box","internal::Or","internal::Map","internal::AndThen"]},"internal::AndThen":{"F":["internal::Into","std::boxed::Box","internal::Map","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::And"],"G":["internal::Map","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::And","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","<*const T as std::fmt::Debug>","number::Endianness","internal::Err","error::ErrorKind"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Map","std::boxed::Box","internal::And","internal::Into","internal::Or"],"G":["core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["internal::FlatMap","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","std::boxed::Box","internal::And"],"G":["core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::Or","std::boxed::Box","internal::Map"],"G":["<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","internal::Map","internal::And"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+combinator::flat_map(p0, p1);
+crate::combinator::flat_map(p0, p1);
+crate::combinator::flat_map(p0, p1);
-----------------
src/combinator/mod.rs combinator::opt
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::opt":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"I":["std::clone::Clone","std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::opt":{"E":["error::VerboseError","error::Error"],"F":["internal::And","std::boxed::Box","internal::FlatMap","internal::Into","internal::AndThen","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>"],"I":["std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","error::VerboseError","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","error::ErrorKind","number::Endianness"],"O":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","std::boxed::Box","internal::Into","internal::AndThen","internal::FlatMap"],"G":["internal::And","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Or","internal::Map"]},"internal::AndThen":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","std::boxed::Box","internal::Map","internal::And","internal::AndThen"],"G":["std::boxed::Box","internal::Map","internal::And","internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Needed","internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"internal::FlatMap":{"F":["internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::Into","internal::Map","std::boxed::Box"],"G":["core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","u8","<T as std::convert::From<!>>"],"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Into","std::boxed::Box","internal::And","internal::FlatMap"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::FlatMap","internal::Map","internal::AndThen","internal::Or","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>"],"G":["core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","std::boxed::Box","internal::And","internal::FlatMap","internal::AndThen"],"G":["internal::Map","internal::FlatMap","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::And"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::opt(p0);
+crate::combinator::opt(p0);
+crate::combinator::opt(p0);
-----------------
src/combinator/mod.rs combinator::cond
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::cond":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::cond":{"E":["error::VerboseError","error::Error"],"F":["internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Into"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","internal::And"],"G":["internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::And","internal::FlatMap","internal::Into"]},"internal::AndThen":{"F":["internal::Map","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Into","internal::And"],"G":["internal::FlatMap","internal::Or","internal::Map","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","number::Endianness"]},"internal::FlatMap":{"F":["internal::And","internal::Or","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Into"],"G":["core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::AndThen","internal::Or","internal::FlatMap","internal::And","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::And","internal::Map"],"G":["core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::Or","internal::AndThen","internal::Into"],"G":["internal::Into","internal::AndThen","internal::Map","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = true; // None+bool
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+combinator::cond(p0, p1);
+crate::combinator::cond(p0, p1);
+crate::combinator::cond(p0, p1);
-----------------
src/combinator/mod.rs combinator::peek
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::peek":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","std::clone::Clone"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::peek":{"E":["error::VerboseError","error::Error"],"F":["internal::Map","internal::Or","internal::Into","internal::And","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen"],"I":["internal::Needed","error::ErrorKind","error::VerboseErrorKind","internal::Err","error::VerboseError","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for &T>"],"O":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","std::boxed::Box","internal::AndThen"],"G":["internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Map"]},"internal::AndThen":{"F":["internal::Or","internal::Into","internal::And","internal::Map","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"G":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::FlatMap","internal::AndThen","internal::And","internal::Or","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::Into","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Or"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::And","internal::Map","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::Map","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::And"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::Into","std::boxed::Box","internal::Map","internal::FlatMap","internal::And"],"G":["internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Map","internal::Into","internal::Or","internal::And"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::peek(p0);
+crate::combinator::peek(p0);
+crate::combinator::peek(p0);
-----------------
src/combinator/mod.rs combinator::eof
deps:{"<*mut T as std::fmt::Debug>":{},"combinator::eof":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","std::clone::Clone","traits::InputLength"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"combinator::eof":{"E":["error::Error","error::VerboseError"],"I":["memchr::memmem::FinderRev<'n>","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderBuilder","memchr::memmem::Finder<'n>"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","internal::Needed","internal::Err","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+combinator::eof(p0);
+crate::combinator::eof(p0);
+crate::combinator::eof(p0);
-----------------
src/combinator/mod.rs combinator::complete
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::complete":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"I":["std::clone::Clone","std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::complete":{"E":["error::VerboseError","error::Error"],"F":["internal::Map","internal::FlatMap","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Or"],"I":["std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed","error::ErrorKind","error::VerboseError","internal::Err","number::Endianness","error::VerboseErrorKind"],"O":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::FlatMap","internal::Map","internal::Or","internal::And","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>"],"G":["internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","std::boxed::Box","internal::Into","internal::AndThen"]},"internal::AndThen":{"F":["internal::FlatMap","internal::AndThen","internal::Into","internal::And","internal::Map","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["internal::And","internal::AndThen","internal::Or","internal::Into","std::boxed::Box","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err","internal::Needed","number::Endianness","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Or","internal::FlatMap","std::boxed::Box"],"G":["core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","i8","u8","<T as std::convert::From<T>>"],"F":["internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Map","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Into","std::boxed::Box","internal::Or","internal::AndThen"],"G":["core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","std::boxed::Box","internal::And","internal::FlatMap","internal::Map"],"G":["internal::FlatMap","internal::And","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::complete(p0);
+crate::combinator::complete(p0);
+crate::combinator::complete(p0);
-----------------
src/combinator/mod.rs combinator::all_consuming
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::all_consuming":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"I":["traits::InputLength","std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::all_consuming":{"E":["error::Error","error::VerboseError"],"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Map","std::boxed::Box","internal::Into","internal::Or"],"I":[],"O":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","std::boxed::Box","internal::Into","internal::Map","internal::AndThen","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>"],"G":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::And","internal::FlatMap","internal::Into","internal::AndThen","internal::Or"]},"internal::AndThen":{"F":["internal::FlatMap","internal::And","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::Or"],"G":["<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Map","internal::Or","internal::AndThen","internal::FlatMap","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","number::Endianness","internal::Err","error::ErrorKind","internal::Needed"]},"internal::FlatMap":{"F":["internal::And","internal::Map","internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into"],"G":["core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<!>>","<T as std::convert::From<T>>"],"F":["internal::FlatMap","internal::Or","internal::Map","internal::And","internal::Into","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","internal::And"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::Or","internal::Into","internal::AndThen","internal::FlatMap"],"G":["internal::FlatMap","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::AndThen","internal::Or"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::all_consuming(p0);
+crate::combinator::all_consuming(p0);
+crate::combinator::all_consuming(p0);
-----------------
src/combinator/mod.rs combinator::verify
deps:{"<&A as std::alloc::Allocator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::borrow::Borrow<T>>":{},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::verify":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"I":["std::clone::Clone","std::marker::Sized"],"O1":["std::borrow::Borrow","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::boxed::Box<F, A>"]},"<T as std::borrow::Borrow<T>>":{},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::verify":{"E":["error::Error","error::VerboseError"],"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::AndThen","internal::Or","std::boxed::Box","internal::Map"],"G":["std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace"],"I":["error::ErrorKind","internal::Needed","internal::Err","error::VerboseErrorKind","error::VerboseError","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for &T>"],"O1":["std::vec::Vec<T, A>","std::path::PathBuf","std::string::String","<&T as std::borrow::Borrow<T>>","std::ffi::CString","std::ffi::OsString","std::borrow::Cow<'a, B>","std::boxed::Box<T, A>","std::sync::Arc<T>","std::rc::Rc<T>","<T as std::borrow::Borrow<T>>"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Map","internal::AndThen","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box"],"G":["internal::Into","internal::And","internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map"]},"internal::AndThen":{"F":["std::boxed::Box","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::And","internal::Map"],"G":["internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::And","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","number::Endianness"]},"internal::FlatMap":{"F":["internal::Map","internal::Or","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::FlatMap"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["std::boxed::Box","internal::Or","internal::And","internal::AndThen","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","internal::And","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Map"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","internal::Into","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","std::boxed::Box"],"G":["std::boxed::Box","internal::Or","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+combinator::verify(p0, p1);
+crate::combinator::verify(p0, p1);
+crate::combinator::verify(p0, p1);
-----------------
src/combinator/mod.rs combinator::value
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::value":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized","std::clone::Clone"],"O2":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::value":{"E":["error::Error","error::VerboseError"],"F":["internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Into","std::boxed::Box","internal::Map","internal::Or"],"I":["RUG_ANY"],"O1":["number::Endianness","internal::Err","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","error::ErrorKind"],"O2":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Or","internal::Into","internal::And","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap"],"G":["internal::Or","std::boxed::Box","internal::Into","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Map","internal::Into","internal::Or","internal::And"],"G":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Map","std::boxed::Box","internal::Or","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","number::Endianness","<*mut T as std::fmt::Debug>","internal::Err","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::AndThen","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::And","internal::Or"],"G":["core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["internal::Into","internal::Map","internal::And","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Or","internal::Map","internal::AndThen"],"G":["core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","internal::Into","internal::Or","internal::FlatMap","internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>"],"G":["internal::And","internal::Map","internal::AndThen","internal::Or","internal::Into","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // O1
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+combinator::value(p0, p1);
+crate::combinator::value(p0, p1);
+crate::combinator::value(p0, p1);
-----------------
src/combinator/mod.rs combinator::not
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"combinator::not":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","std::clone::Clone"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"combinator::not":{"E":["error::Error","error::VerboseError"],"F":["internal::And","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::Map","internal::AndThen"],"I":["error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","internal::Needed","number::Endianness","error::ErrorKind","internal::Err"],"O":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And","internal::FlatMap"],"G":["internal::Or","internal::Map","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Into"]},"internal::AndThen":{"F":["internal::Or","std::boxed::Box","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::AndThen"],"G":["internal::And","std::boxed::Box","internal::Or","internal::FlatMap","internal::Map","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","internal::Err","number::Endianness","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::Into","internal::FlatMap","internal::And","internal::AndThen"],"G":["core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["std::boxed::Box","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::FlatMap","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::And","internal::Map"],"G":["core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::AndThen","std::boxed::Box","internal::FlatMap"],"G":["internal::And","internal::Or","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::not(p0);
+crate::combinator::not(p0);
+crate::combinator::not(p0);
-----------------
src/combinator/mod.rs combinator::recognize
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::recognize":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"I":["std::clone::Clone","std::marker::Sized","traits::Slice","traits::Offset"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::recognize":{"E":["error::Error","error::VerboseError"],"F":["<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Into","internal::AndThen","internal::Or","internal::FlatMap","internal::And"],"O":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::And"],"G":["internal::Or","internal::AndThen","std::boxed::Box","internal::Map","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And"]},"internal::AndThen":{"F":["internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Into","internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>"],"G":["internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Or","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","number::Endianness"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen","internal::Into","internal::And","internal::Or"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::AndThen","internal::And","std::boxed::Box","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","internal::Or","internal::FlatMap","internal::Into","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::And"],"G":["core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","internal::Into","internal::AndThen","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map"],"G":["internal::Or","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","std::boxed::Box","internal::FlatMap"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::recognize(p0);
+crate::combinator::recognize(p0);
+crate::combinator::recognize(p0);
-----------------
src/combinator/mod.rs combinator::consumed
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::consumed":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","traits::Slice","std::clone::Clone","traits::Offset"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::consumed":{"E":["error::VerboseError","error::Error"],"F":["internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Or","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Into"],"O":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","internal::Into","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::AndThen"],"G":["std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::AndThen","internal::And","internal::Or"]},"internal::AndThen":{"F":["internal::Into","internal::Map","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::And"],"G":["internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::And","internal::Or","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","internal::Needed","internal::Err"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::And","internal::Map","internal::FlatMap"],"G":["std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::AndThen","internal::And","internal::FlatMap","std::boxed::Box","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::And","internal::Map","internal::AndThen","internal::FlatMap","internal::Or"],"G":["core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","internal::Or","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::FlatMap"],"G":["internal::Into","internal::AndThen","internal::And","internal::Map","internal::Or","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::consumed(p0);
+crate::combinator::consumed(p0);
+crate::combinator::consumed(p0);
-----------------
src/combinator/mod.rs combinator::cut
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::cut":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::cut":{"E":["error::Error","error::VerboseError"],"F":["internal::Into","internal::Or","internal::AndThen","internal::FlatMap","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","internal::Into","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::AndThen"],"G":["internal::Into","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::Map"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::And","std::boxed::Box","internal::Or","internal::Map","internal::AndThen"],"G":["internal::Map","internal::And","internal::Into","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","internal::Err","internal::Needed","error::ErrorKind","number::Endianness"]},"internal::FlatMap":{"F":["internal::And","internal::Or","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","std::boxed::Box"],"G":["core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Map","internal::And","internal::FlatMap","internal::Into","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","internal::Or","internal::And","internal::FlatMap","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map"],"G":["core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Into","internal::AndThen","std::boxed::Box"],"G":["<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into","internal::Map","internal::Or"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::cut(p0);
+crate::combinator::cut(p0);
+crate::combinator::cut(p0);
-----------------
src/combinator/mod.rs combinator::into
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"combinator::into":{"E1":["std::marker::Sized","std::convert::Into","error::ParseError"],"E2":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"],"O1":["std::convert::Into","std::marker::Sized"],"O2":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"combinator::into":{"E2":["error::Error","error::VerboseError"],"F":["internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Into","internal::And","internal::Or"],"I":["RUG_ANY"],"O1":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"],"O2":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::Map"],"G":["internal::Map","internal::AndThen","internal::Into","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box"]},"internal::AndThen":{"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::AndThen","internal::And","internal::FlatMap","internal::Or"],"G":["std::boxed::Box","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::AndThen","internal::Or"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","internal::Needed","internal::Err","number::Endianness"]},"internal::FlatMap":{"F":["internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And"],"G":["core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Into","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","internal::Into","internal::Or","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap"],"G":["core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::FlatMap","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::And"],"G":["internal::And","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+combinator::into(p0);
+crate::combinator::into(p0);
+crate::combinator::into(p0);
-----------------
src/combinator/mod.rs combinator::iterator
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"combinator::iterator":{"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized"],"Output":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"combinator::iterator":{"Error":["error::VerboseError","error::Error"],"F":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::FlatMap"],"Input":["RUG_ANY"],"Output":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::And"],"G":["internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Map"]},"internal::AndThen":{"F":["internal::Into","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Map"],"G":["internal::FlatMap","internal::And","internal::Map","std::boxed::Box","internal::AndThen","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err"]},"internal::FlatMap":{"F":["internal::AndThen","internal::Or","internal::And","internal::Map","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"G":["core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","u8","<T as std::convert::From<!>>","i8"],"F":["internal::Into","internal::Or","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::FlatMap"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Into","std::boxed::Box","internal::And","internal::Map"],"G":["std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Or","internal::Into","internal::And","internal::FlatMap","internal::Map"],"G":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::Into","internal::FlatMap","internal::And","internal::Or","internal::AndThen"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Input
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+combinator::iterator(p0, p1);
+crate::combinator::iterator(p0, p1);
+crate::combinator::iterator(p0, p1);
-----------------
src/combinator/mod.rs combinator::success
deps:{"combinator::success":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::clone::Clone","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"combinator::success":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"O":["error::ErrorKind","number::Endianness","internal::Needed","error::VerboseErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","internal::Needed","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // O
+combinator::success(p0);
+crate::combinator::success(p0);
+crate::combinator::success(p0);
-----------------
src/combinator/mod.rs combinator::fail
deps:{"combinator::fail":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"combinator::fail":{"E":["error::VerboseError","error::Error"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","internal::Err","number::Endianness","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+combinator::fail(p0);
+crate::combinator::fail(p0);
+crate::combinator::fail(p0);
-----------------
src/multi/mod.rs multi::many0
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"multi::many0":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"I":["std::clone::Clone","std::marker::Sized","traits::InputLength"],"O":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","std::boxed::Box","internal::AndThen","internal::Into","internal::FlatMap","internal::Or"],"G":["internal::Or","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::Map","internal::FlatMap"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::FlatMap","internal::Into","std::boxed::Box","internal::AndThen","internal::Or"],"G":["internal::Or","internal::Into","internal::AndThen","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","internal::Needed","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","number::Endianness"]},"internal::FlatMap":{"F":["internal::Into","std::boxed::Box","internal::And","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap"],"G":["core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["<F as internal::Parser<I, O, E>>","internal::Into","internal::And","std::boxed::Box","internal::Map","internal::FlatMap","internal::Or","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::AndThen","std::boxed::Box"],"G":["core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::Into","std::boxed::Box"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::And","internal::Or","internal::Into","internal::FlatMap","std::boxed::Box"]},"multi::many0":{"E":["error::Error","error::VerboseError"],"F":["internal::Into","internal::AndThen","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::And"],"I":["memchr::memmem::Finder<'n>","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderBuilder","memchr::memmem::FinderRev<'n>"],"O":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+multi::many0(p0);
+crate::multi::many0(p0);
+crate::multi::many0(p0);
-----------------
src/multi/mod.rs multi::many1
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"multi::many1":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"I":["traits::InputLength","std::marker::Sized","std::clone::Clone"],"O":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Into","internal::Or","internal::Map","internal::FlatMap"],"G":["internal::Into","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Map","internal::FlatMap","internal::Or"]},"internal::AndThen":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","std::boxed::Box","internal::Map","internal::AndThen","internal::Or"],"G":["internal::And","internal::Map","internal::FlatMap","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::AndThen","std::boxed::Box","internal::Into"],"G":["core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::Into","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::FlatMap","internal::Map"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::FlatMap","internal::Into","std::boxed::Box","internal::AndThen"],"G":["core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::Map","internal::And","internal::Into","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["internal::FlatMap","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::AndThen","internal::Into"]},"multi::many1":{"E":["error::Error","error::VerboseError"],"F":["internal::FlatMap","internal::And","internal::Or","internal::AndThen","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map"],"I":["memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder","memchr::memmem::Finder<'n>"],"O":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+multi::many1(p0);
+crate::multi::many1(p0);
+crate::multi::many1(p0);
-----------------
src/multi/mod.rs multi::many_till
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"multi::many_till":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"I":["std::clone::Clone","traits::InputLength","std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Into","std::boxed::Box","internal::AndThen"],"G":["internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Map","internal::And"]},"internal::AndThen":{"F":["internal::FlatMap","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Into","std::boxed::Box"],"G":["internal::Or","std::boxed::Box","internal::AndThen","internal::Into","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","number::Endianness","internal::Err"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::And","internal::AndThen","internal::Map","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>","<T as std::convert::From<!>>"],"F":["<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::AndThen","internal::FlatMap","internal::Map","internal::Into","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::Or","internal::AndThen","internal::And","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"G":["core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::FlatMap","internal::AndThen","internal::Map","internal::Or","internal::Into"],"G":["internal::Or","internal::Map","internal::And","internal::FlatMap","internal::Into","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>"]},"multi::many_till":{"E":["error::Error","error::VerboseError"],"F":["internal::Or","internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::And"],"G":["internal::Map","internal::Or","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","std::boxed::Box"],"I":["memchr::memmem::FinderRev<'n>","memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder","memchr::memmem::Finder<'n>","memchr::cow::CowBytes<'a>"],"O":["RUG_ANY"],"P":["RUG_ANY"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+multi::many_till(p0, p1);
+crate::multi::many_till(p0, p1);
+crate::multi::many_till(p0, p1);
-----------------
src/multi/mod.rs multi::separated_list0
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"multi::separated_list0":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"I":["std::clone::Clone","std::marker::Sized","traits::InputLength"],"O":["std::marker::Sized"],"O2":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::Map","internal::And","internal::AndThen","std::boxed::Box"],"G":["internal::Or","internal::And","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","std::boxed::Box"]},"internal::AndThen":{"F":["internal::And","internal::Map","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","std::boxed::Box"],"G":["internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Into","internal::And","std::boxed::Box","internal::Or"],"O1":["RUG_ANY"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","internal::Needed","error::ErrorKind","number::Endianness","internal::Err"]},"internal::FlatMap":{"F":["internal::Map","internal::And","internal::Or","internal::AndThen","internal::FlatMap","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","u8","i8","<T as std::convert::From<T>>"],"F":["internal::Map","internal::Into","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"G":["core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Or"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Map","internal::Or","internal::Into","internal::And","internal::FlatMap"]},"multi::separated_list0":{"E":["error::Error","error::VerboseError"],"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::Into","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Map"],"G":["<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::AndThen","internal::Into","internal::Map","internal::FlatMap","internal::And"],"I":["memchr::memmem::FinderBuilder","memchr::cow::Imp<'a>","memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::memmem::Finder<'n>"],"O":["RUG_ANY"],"O2":["RUG_ANY"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // G
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+multi::separated_list0(p0, p1);
+crate::multi::separated_list0(p0, p1);
+crate::multi::separated_list0(p0, p1);
-----------------
src/multi/mod.rs multi::separated_list1
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"multi::separated_list1":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","std::clone::Clone","traits::InputLength"],"O":["std::marker::Sized"],"O2":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::FlatMap","internal::And"],"G":["internal::Or","internal::FlatMap","internal::Into","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And"]},"internal::AndThen":{"F":["internal::Or","internal::Into","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::FlatMap"],"G":["internal::AndThen","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::And","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::ErrorKind"]},"internal::FlatMap":{"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::Map","internal::AndThen","internal::FlatMap","internal::And"],"G":["std::boxed::Box<F, A>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","u8","<T as std::convert::From<T>>","i8"],"F":["internal::And","internal::Map","std::boxed::Box","internal::AndThen","internal::Into","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","internal::Into","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Or"],"G":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::Into","internal::Map","internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or"],"G":["internal::And","internal::Into","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::AndThen"]},"multi::separated_list1":{"E":["error::VerboseError","error::Error"],"F":["internal::Or","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::AndThen","std::boxed::Box"],"G":["internal::Into","internal::FlatMap","internal::Map","internal::AndThen","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Or"],"I":["memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderRev<'n>"],"O":["RUG_ANY"],"O2":["RUG_ANY"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // G
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+multi::separated_list1(p0, p1);
+crate::multi::separated_list1(p0, p1);
+crate::multi::separated_list1(p0, p1);
-----------------
src/multi/mod.rs multi::many_m_n
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"multi::many_m_n":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"I":["traits::InputLength","std::clone::Clone","std::marker::Sized"],"O":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::And","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::Or","internal::Into"],"G":["<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::FlatMap","internal::Into","internal::Or","std::boxed::Box","internal::Map"]},"internal::AndThen":{"F":["internal::Map","std::boxed::Box","internal::And","internal::Into","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::AndThen","internal::Map","internal::Or","internal::And","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","internal::Err","number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","std::boxed::Box","internal::Or","internal::Into","internal::Map","internal::FlatMap"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","internal::And","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::FlatMap","internal::And","internal::Or","internal::Into"],"G":["core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Into","internal::Map","internal::AndThen","internal::FlatMap","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"G":["internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","std::boxed::Box","internal::AndThen","internal::And"]},"multi::many_m_n":{"E":["error::VerboseError","error::Error"],"F":["std::boxed::Box","internal::Or","internal::Map","internal::And","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into"],"I":["memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::memmem::FinderRev<'n>"],"O":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+multi::many_m_n(p0, p1, p2);
+crate::multi::many_m_n(p0, p1, p2);
+crate::multi::many_m_n(p0, p1, p2);
-----------------
src/multi/mod.rs multi::many0_count
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"multi::many0_count":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","std::clone::Clone","traits::InputLength"],"O":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::AndThen","internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::FlatMap"],"G":["internal::Into","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap"]},"internal::AndThen":{"F":["internal::Or","internal::And","internal::AndThen","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box"],"G":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::AndThen","internal::Or","std::boxed::Box","internal::FlatMap","internal::Into"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","internal::Err"]},"internal::FlatMap":{"F":["internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::And","internal::AndThen","internal::Into"],"G":["core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::AndThen","internal::And","internal::Or","internal::Map","internal::FlatMap"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::FlatMap","internal::Into"],"G":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::And","internal::Map","internal::Or","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Into","internal::And","std::boxed::Box"]},"multi::many0_count":{"E":["error::VerboseError","error::Error"],"F":["internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::FlatMap","std::boxed::Box","internal::Or"],"I":["memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderRev<'n>","memchr::memmem::FinderBuilder"],"O":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+multi::many0_count(p0);
+crate::multi::many0_count(p0);
+crate::multi::many0_count(p0);
-----------------
src/multi/mod.rs multi::many1_count
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"multi::many1_count":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","traits::InputLength","std::clone::Clone"],"O":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::FlatMap","internal::And","internal::AndThen","internal::Into","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>"],"G":["internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::AndThen","internal::And","internal::FlatMap","internal::Or"]},"internal::AndThen":{"F":["internal::Or","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Into","internal::FlatMap"],"G":["<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::Into","std::boxed::Box","internal::Map","internal::AndThen","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","number::Endianness","internal::Needed","internal::Err"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::Into","internal::And","std::boxed::Box"],"G":["core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Or","internal::Into","internal::Map","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","internal::Or","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::FlatMap"],"G":["core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","internal::Map","internal::AndThen","internal::Into","std::boxed::Box","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"G":["internal::Or","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::And","internal::Into"]},"multi::many1_count":{"E":["error::VerboseError","error::Error"],"F":["internal::FlatMap","internal::And","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::Into"],"I":["memchr::memmem::Finder<'n>","memchr::cow::Imp<'a>","memchr::memmem::FinderRev<'n>","memchr::memmem::FinderBuilder","memchr::cow::CowBytes<'a>"],"O":["RUG_ANY"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+multi::many1_count(p0);
+crate::multi::many1_count(p0);
+crate::multi::many1_count(p0);
-----------------
src/multi/mod.rs multi::count
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"multi::count":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"],"O":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::And","internal::Map","internal::Or","internal::Into","internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["internal::Into","internal::FlatMap","internal::Map","internal::AndThen","std::boxed::Box","internal::And","internal::Or","<F as internal::Parser<I, O, E>>"]},"internal::AndThen":{"F":["internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::AndThen","internal::Into"],"G":["internal::Map","internal::FlatMap","internal::Or","internal::AndThen","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","<*mut T as std::fmt::Debug>","error::ErrorKind","internal::Needed","number::Endianness"]},"internal::FlatMap":{"F":["internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::Into","internal::AndThen","std::boxed::Box"],"G":["core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","i8","<T as std::convert::From<!>>","<T as std::convert::From<T>>"],"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::AndThen","internal::Into","internal::And","internal::Map"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box"],"G":["core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","std::boxed::Box","internal::Into","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And"],"G":["internal::And","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","std::boxed::Box"]},"multi::count":{"E":["error::VerboseError","error::Error"],"F":["internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::FlatMap","internal::Into","internal::AndThen"],"I":["std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>","std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>","error::VerboseError","error::ErrorKind","error::VerboseErrorKind","number::Endianness","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err"],"O":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &mut A>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = 0usize; // None+usize
+multi::count(p0, p1);
+crate::multi::count(p0, p1);
+crate::multi::count(p0, p1);
-----------------
src/multi/mod.rs multi::fill
'a
deps:{"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"multi::fill":{"E":["std::marker::Sized","error::ParseError"],"F":["std::ops::Fn","std::marker::Sized"],"I":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"],"O":["std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","error::ErrorKind","internal::Needed"]},"multi::fill":{"E":["error::Error","error::VerboseError"],"F":["core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"I":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","error::VerboseError","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","error::ErrorKind"],"O":["RUG_ANY"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&B> for &mut A>":{},"std::cmp::impls::<impl std::cmp::PartialEq<&mut B> for &A>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // [O]
+multi::fill(p0, p1);
+crate::multi::fill(p0, p1);
+crate::multi::fill(p0, p1);
-----------------
src/multi/mod.rs multi::fold_many0
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"multi::fold_many0":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"],"H":["std::marker::Sized","std::ops::FnMut"],"I":["traits::InputLength","std::marker::Sized","std::clone::Clone"],"O":["std::marker::Sized"],"R":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Or","internal::Map","std::boxed::Box","internal::And"],"G":["internal::Into","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::FlatMap","internal::AndThen"]},"internal::AndThen":{"F":["internal::Map","internal::And","std::boxed::Box","internal::AndThen","internal::Or","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"G":["internal::AndThen","internal::Map","internal::And","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","number::Endianness","internal::Needed"]},"internal::FlatMap":{"F":["internal::Or","internal::Into","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::FlatMap"],"G":["core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<T>>","<T as std::convert::From<!>>","u8"],"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::And","internal::FlatMap","internal::Into","internal::Map","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::Map","internal::And"],"G":["core::str::CharEscapeDefault","core::str::IsWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Into","internal::Map","internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box"],"G":["std::boxed::Box","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Into","internal::And"]},"multi::fold_many0":{"E":["error::Error","error::VerboseError"],"F":["internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::Or","std::boxed::Box","internal::AndThen"],"G":["core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"],"H":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap"],"I":["memchr::memmem::FinderBuilder","memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderRev<'n>","memchr::memmem::Finder<'n>"],"O":["RUG_ANY"],"R":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // H
let mut p2 = MaybeUninit::uninit().assume_init(); // G
+multi::fold_many0(p0, p1, p2);
+crate::multi::fold_many0(p0, p1, p2);
+crate::multi::fold_many0(p0, p1, p2);
-----------------
src/multi/mod.rs multi::fold_many1
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"multi::fold_many1":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::FnMut","std::marker::Sized"],"H":["std::ops::FnMut","std::marker::Sized"],"I":["std::clone::Clone","std::marker::Sized","traits::InputLength"],"O":["std::marker::Sized"],"R":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::And","internal::AndThen","internal::Map","internal::FlatMap","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"G":["internal::Or","internal::Into","internal::AndThen","internal::Map","internal::And","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>"]},"internal::AndThen":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Into","internal::AndThen","std::boxed::Box","internal::Or"],"G":["internal::Map","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","std::boxed::Box","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed"]},"internal::FlatMap":{"F":["internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Into","internal::Map","internal::FlatMap"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Or","internal::Into","internal::AndThen","internal::And","internal::Map"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::And","internal::Into","internal::FlatMap","internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>"],"G":["core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::And"],"G":["internal::FlatMap","internal::And","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Map"]},"multi::fold_many1":{"E":["error::Error","error::VerboseError"],"F":["std::boxed::Box","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::And","internal::AndThen"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"],"H":["core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"],"I":["memchr::memmem::FinderRev<'n>","memchr::memmem::Finder<'n>","memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder","memchr::cow::CowBytes<'a>"],"O":["RUG_ANY"],"R":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // H
let mut p2 = MaybeUninit::uninit().assume_init(); // G
+multi::fold_many1(p0, p1, p2);
+crate::multi::fold_many1(p0, p1, p2);
+crate::multi::fold_many1(p0, p1, p2);
-----------------
src/multi/mod.rs multi::fold_many_m_n
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"multi::fold_many_m_n":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::FnMut"],"H":["std::ops::FnMut","std::marker::Sized"],"I":["std::marker::Sized","std::clone::Clone","traits::InputLength"],"O":["std::marker::Sized"],"R":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::FlatMap","std::boxed::Box","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::AndThen"],"G":["internal::Into","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Or","internal::AndThen"]},"internal::AndThen":{"F":["internal::Map","internal::Or","internal::FlatMap","internal::Into","internal::And","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["std::boxed::Box","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::Or","internal::Into"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","internal::Needed","number::Endianness","error::ErrorKind","<*mut T as std::fmt::Debug>"]},"internal::FlatMap":{"F":["internal::And","std::boxed::Box","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::AndThen"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::FlatMap","internal::Into","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::Map","std::boxed::Box","internal::Into","internal::Or"],"G":["core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Or","internal::Into","internal::Map"],"G":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::AndThen","std::boxed::Box","internal::And","internal::FlatMap"]},"multi::fold_many_m_n":{"E":["error::VerboseError","error::Error"],"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::AndThen","internal::FlatMap","internal::Or"],"G":["core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr"],"H":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty"],"I":["memchr::memmem::Finder<'n>","memchr::cow::Imp<'a>","memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderBuilder"],"O":["RUG_ANY"],"R":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // F
let mut p3 = MaybeUninit::uninit().assume_init(); // H
let mut p4 = MaybeUninit::uninit().assume_init(); // G
+multi::fold_many_m_n(p0, p1, p2, p3, p4);
+crate::multi::fold_many_m_n(p0, p1, p2, p3, p4);
+crate::multi::fold_many_m_n(p0, p1, p2, p3, p4);
-----------------
src/multi/mod.rs multi::length_data
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"multi::length_data":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"I":["traits::InputTake","std::marker::Sized","traits::InputLength"],"N":["std::marker::Sized","traits::ToUsize"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::IsWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::AndThen","internal::FlatMap","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::Map"],"G":["<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And","internal::Into","internal::AndThen","std::boxed::Box","internal::FlatMap"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::AndThen","internal::And","internal::FlatMap","internal::Or","internal::Into"],"G":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::AndThen","internal::Map","internal::FlatMap","internal::Or","internal::And"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","<*mut T as std::fmt::Debug>","error::ErrorKind","number::Endianness","internal::Err"]},"internal::FlatMap":{"F":["internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::FlatMap","internal::AndThen","internal::And"],"G":["core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","<T as std::convert::From<T>>","i8","u8"],"F":["internal::Or","internal::Into","std::boxed::Box","internal::FlatMap","internal::Map","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","internal::Map","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","std::boxed::Box"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","internal::FlatMap","internal::Map","std::boxed::Box","internal::Into","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>"],"G":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::AndThen","internal::Or","internal::Map","internal::Into","std::boxed::Box"]},"multi::length_data":{"E":["error::Error","error::VerboseError"],"F":["internal::Into","internal::AndThen","internal::Map","internal::And","internal::FlatMap","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>"],"I":[],"N":[]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+multi::length_data(p0);
+crate::multi::length_data(p0);
+crate::multi::length_data(p0);
-----------------
src/multi/mod.rs multi::length_value
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"multi::length_value":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"I":["std::clone::Clone","traits::InputTake","traits::InputLength","std::marker::Sized"],"N":["traits::ToUsize","std::marker::Sized"],"O":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Into","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::AndThen","internal::FlatMap"],"G":["internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Map","internal::And","std::boxed::Box"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","internal::And"],"G":["internal::Map","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::And","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","internal::Needed","error::ErrorKind","internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"internal::FlatMap":{"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::FlatMap","internal::Into","internal::Or","internal::AndThen"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<!>>","<T as std::convert::From<T>>","u8"],"F":["internal::AndThen","internal::Or","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","internal::FlatMap","internal::And","internal::Into","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map"],"G":["std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::FlatMap","internal::Into","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Map"],"G":["internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","internal::And","internal::Into"]},"multi::length_value":{"E":["error::VerboseError","error::Error"],"F":["std::boxed::Box","internal::FlatMap","internal::And","internal::AndThen","internal::Or","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>"],"G":["<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Map","internal::Into"],"N":[],"O":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+multi::length_value(p0, p1);
+crate::multi::length_value(p0, p1);
+crate::multi::length_value(p0, p1);
-----------------
src/multi/mod.rs multi::length_count
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"multi::length_count":{"E":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","std::clone::Clone"],"N":["std::marker::Sized","traits::ToUsize"],"O":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::Map","std::boxed::Box","internal::Or"],"G":["internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","std::boxed::Box","internal::FlatMap"]},"internal::AndThen":{"F":["internal::Map","internal::Into","internal::AndThen","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::FlatMap","internal::Map","internal::Into","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","internal::Err","internal::Needed"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::FlatMap","internal::And","internal::AndThen","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into"],"G":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::Or","internal::FlatMap","internal::And","internal::AndThen","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","internal::Or","std::boxed::Box","internal::And","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map"],"G":["std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Map","internal::AndThen","internal::Or"],"G":["internal::Into","internal::FlatMap","internal::And","internal::Or","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen"]},"multi::length_count":{"E":["error::VerboseError","error::Error"],"F":["internal::And","internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","std::boxed::Box"],"G":["internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::AndThen","std::boxed::Box","internal::Or"],"I":["number::Endianness","std::clone::impls::<impl std::clone::Clone for &mut T>","error::ErrorKind","internal::Needed","internal::Err","error::VerboseError","error::VerboseErrorKind"],"N":[],"O":["RUG_ANY"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+multi::length_count(p0, p1);
+crate::multi::length_count(p0, p1);
+crate::multi::length_count(p0, p1);
-----------------
src/sequence/mod.rs sequence::pair
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"sequence::pair":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["std::boxed::Box","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::Into","internal::AndThen"],"G":["internal::FlatMap","internal::And","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Into"]},"internal::AndThen":{"F":["std::boxed::Box","internal::Or","internal::FlatMap","internal::Map","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Into"],"G":["internal::And","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Map","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::Into","std::boxed::Box"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","<T as std::convert::From<T>>","i8","u8"],"F":["internal::FlatMap","std::boxed::Box","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::AndThen","internal::Or","std::boxed::Box","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And"],"G":["core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into","std::boxed::Box","internal::FlatMap","internal::Or","internal::And"],"G":["internal::FlatMap","internal::And","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::Into"]},"sequence::pair":{"E":["error::Error","error::VerboseError"],"F":["internal::AndThen","internal::FlatMap","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::Into"],"G":["internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+sequence::pair(p0, p1);
+crate::sequence::pair(p0, p1);
+crate::sequence::pair(p0, p1);
-----------------
src/sequence/mod.rs sequence::preceded
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"sequence::preceded":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::And","internal::Into","internal::AndThen","internal::Map","internal::FlatMap"],"G":["internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::AndThen","internal::Into","internal::And"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::And","std::boxed::Box","internal::Or","internal::FlatMap","internal::AndThen"],"G":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Map","internal::Or","internal::Into","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed"]},"internal::FlatMap":{"F":["internal::AndThen","internal::Into","internal::Map","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap"],"G":["core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["internal::Into","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::AndThen","internal::Or","internal::FlatMap"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","internal::And","internal::Into","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Map","std::boxed::Box","internal::FlatMap"],"G":["internal::Map","internal::AndThen","internal::Or","internal::Into","internal::And","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>"]},"sequence::preceded":{"E":["error::VerboseError","error::Error"],"F":["internal::AndThen","internal::And","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","std::boxed::Box"],"G":["internal::Or","internal::Into","internal::FlatMap","internal::AndThen","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+sequence::preceded(p0, p1);
+crate::sequence::preceded(p0, p1);
+crate::sequence::preceded(p0, p1);
-----------------
src/sequence/mod.rs sequence::terminated
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"sequence::terminated":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Into","internal::Or","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And"],"G":["internal::Or","internal::FlatMap","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into"]},"internal::AndThen":{"F":["internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Map","internal::AndThen","std::boxed::Box"],"G":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Into","internal::And"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","number::Endianness","error::ErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::AndThen","internal::Into","internal::FlatMap","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or"],"G":["core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["internal::And","std::boxed::Box","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","std::boxed::Box","internal::Or","internal::AndThen"],"G":["core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Into","internal::And","internal::Or","internal::AndThen","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["internal::AndThen","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","std::boxed::Box","internal::FlatMap"]},"sequence::terminated":{"E":["error::VerboseError","error::Error"],"F":["std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::And"],"G":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","std::boxed::Box","internal::AndThen","internal::Into","internal::Map","internal::Or"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+sequence::terminated(p0, p1);
+crate::sequence::terminated(p0, p1);
+crate::sequence::terminated(p0, p1);
-----------------
src/sequence/mod.rs sequence::separated_pair
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"sequence::separated_pair":{"E":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"H":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::FlatMap","internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","std::boxed::Box"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","std::boxed::Box","internal::Map","internal::AndThen","internal::Or"]},"internal::AndThen":{"F":["internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into","internal::Map"],"G":["<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::FlatMap","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>"]},"internal::FlatMap":{"F":["internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Into","internal::FlatMap","internal::Map","std::boxed::Box"],"G":["core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","<T as std::convert::From<!>>","u8","i8"],"F":["internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::And","internal::AndThen"],"G":["core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Map","internal::Or","internal::FlatMap"],"G":["std::boxed::Box","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::AndThen","internal::FlatMap"]},"sequence::separated_pair":{"E":["error::VerboseError","error::Error"],"F":["internal::Map","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","internal::And"],"G":["internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","std::boxed::Box","internal::Or","internal::Map"],"H":["internal::Map","internal::FlatMap","internal::Into","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
let mut p2 = MaybeUninit::uninit().assume_init(); // H
+sequence::separated_pair(p0, p1, p2);
+crate::sequence::separated_pair(p0, p1, p2);
+crate::sequence::separated_pair(p0, p1, p2);
-----------------
src/sequence/mod.rs sequence::delimited
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"sequence::delimited":{"E":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"],"O3":["std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","std::boxed::Box","internal::And"],"G":["internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Map","internal::And","std::boxed::Box"]},"internal::AndThen":{"F":["internal::Map","internal::FlatMap","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","std::boxed::Box"],"G":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::FlatMap","internal::And","internal::AndThen","internal::Or","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","internal::Err","error::ErrorKind","number::Endianness"]},"internal::FlatMap":{"F":["internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::Map"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<!>>","u8","<T as std::convert::From<T>>"],"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Or","internal::AndThen","internal::Map","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","std::boxed::Box","internal::Map","internal::FlatMap","internal::And"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","internal::Into","internal::AndThen","internal::And","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["internal::FlatMap","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::Map","internal::And"]},"sequence::delimited":{"E":["error::VerboseError","error::Error"],"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::Or","internal::FlatMap","internal::AndThen","internal::And"],"G":["internal::And","internal::Map","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Into"],"H":["internal::AndThen","internal::And","internal::Map","std::boxed::Box","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"],"O3":["RUG_ANY"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // G
let mut p2 = MaybeUninit::uninit().assume_init(); // H
+sequence::delimited(p0, p1, p2);
+crate::sequence::delimited(p0, p1, p2);
+crate::sequence::delimited(p0, p1, p2);
-----------------
src/sequence/mod.rs sequence::tuple
deps:{"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"sequence::tuple":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized"],"List":["std::marker::Sized","sequence::Tuple"],"O":["std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","internal::Needed","error::ErrorKind"]},"sequence::tuple":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"],"List":[],"O":["RUG_ANY"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // List
+sequence::tuple(p0);
+crate::sequence::tuple(p0);
+crate::sequence::tuple(p0);
-----------------
src/traits.rs traits::lowercase_byte
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+traits::lowercase_byte(p0);
+crate::traits::lowercase_byte(p0);
+crate::traits::lowercase_byte(p0);
-----------------
src/bits/complete.rs bits::complete::take
deps:{"bits::complete::take":{"C":["traits::ToUsize","std::marker::Sized"],"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","traits::InputLength","traits::InputIter","std::marker::Sized"],"O":["std::ops::AddAssign","std::marker::Sized","std::convert::From","std::ops::Shl","std::ops::Shr"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"bits::complete::take":{"C":[],"E":["error::Error","error::VerboseError"],"O":["std::simd::Mask<i8, LANES>","std::simd::Mask<i16, LANES>","std::simd::Mask<i64, LANES>","std::num::NonZeroI32","std::simd::Mask<i32, LANES>","std::ffi::CString","std::num::NonZeroU128","std::simd::Mask<isize, LANES>"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // C
+bits::complete::take(p0);
+crate::bits::complete::take(p0);
+crate::bits::complete::take(p0);
-----------------
src/bits/complete.rs bits::complete::tag
deps:{"<*const T as std::fmt::Debug>":{},"bits::complete::tag":{"C":["traits::ToUsize","std::marker::Sized"],"E":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","traits::InputLength","traits::InputIter","std::marker::Sized","std::clone::Clone"],"O":["std::marker::Sized","std::convert::From","std::ops::AddAssign","std::ops::Shr","std::cmp::PartialEq","std::ops::Shl"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bits::complete::tag":{"C":[],"E":["error::VerboseError","error::Error"],"O":["std::net::Ipv6Addr","std::ffi::CString","std::vec::Vec<T>","std::process::Stdio","std::num::NonZeroI32","std::num::NonZeroU128"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","internal::Err","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // O
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+bits::complete::tag(p0, p1);
+crate::bits::complete::tag(p0, p1);
+crate::bits::complete::tag(p0, p1);
-----------------
src/bits/complete.rs bits::complete::bool
deps:{"bits::complete::bool":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::InputLength","traits::InputIter","traits::Slice"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"bits::complete::bool":{"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","error::ErrorKind","internal::Needed","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (I, usize)
+bits::complete::bool(p0);
+crate::bits::complete::bool(p0);
+crate::bits::complete::bool(p0);
-----------------
src/bits/streaming.rs bits::streaming::take
deps:{"bits::streaming::take":{"C":["std::marker::Sized","traits::ToUsize"],"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","traits::InputIter","std::marker::Sized","traits::InputLength"],"O":["std::ops::AddAssign","std::ops::Shr","std::ops::Shl","std::marker::Sized","std::convert::From"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"bits::streaming::take":{"C":[],"E":["error::Error","error::VerboseError"],"O":["std::simd::Mask<i8, LANES>","std::simd::Mask<isize, LANES>","std::num::NonZeroI32","std::simd::Mask<i32, LANES>","std::simd::Mask<i64, LANES>","std::simd::Mask<i16, LANES>","std::num::NonZeroU128","std::ffi::CString"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed","number::Endianness","internal::Err","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // C
+bits::streaming::take(p0);
+crate::bits::streaming::take(p0);
+crate::bits::streaming::take(p0);
-----------------
src/bits/streaming.rs bits::streaming::tag
deps:{"<*const T as std::fmt::Debug>":{},"bits::streaming::tag":{"C":["std::marker::Sized","traits::ToUsize"],"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Slice","std::clone::Clone","traits::InputLength","traits::InputIter"],"O":["std::ops::AddAssign","std::convert::From","std::cmp::PartialEq","std::ops::Shr","std::ops::Shl","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bits::streaming::tag":{"C":[],"E":["error::VerboseError","error::Error"],"O":["std::net::Ipv6Addr","std::num::NonZeroU128","std::num::NonZeroI32","std::ffi::CString","std::vec::Vec<T>","std::process::Stdio"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","<*const T as std::fmt::Debug>","internal::Needed","error::ErrorKind","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // O
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+bits::streaming::tag(p0, p1);
+crate::bits::streaming::tag(p0, p1);
+crate::bits::streaming::tag(p0, p1);
-----------------
src/bits/streaming.rs bits::streaming::bool
deps:{"bits::streaming::bool":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","traits::Slice","traits::InputIter","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"bits::streaming::bool":{"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","number::Endianness","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (I, usize)
+bits::streaming::bool(p0);
+crate::bits::streaming::bool(p0);
+crate::bits::streaming::bool(p0);
-----------------
src/bits/mod.rs bits::bits
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"bits::bits":{"E1":["traits::ErrorConvert","std::marker::Sized","error::ParseError"],"E2":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Slice"],"O":["std::marker::Sized"],"P":["internal::Parser","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"bits::bits":{"E1":["error::VerboseError","error::Error"],"E2":["error::VerboseError","error::Error"],"O":["RUG_ANY"],"P":["internal::Or","internal::And","std::boxed::Box","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Or","internal::Into","std::boxed::Box","internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["internal::Into","internal::FlatMap","internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::Or"]},"internal::AndThen":{"F":["internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","internal::Or","internal::Into"],"G":["internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Or","internal::FlatMap","internal::Map","internal::And"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","<*mut T as std::fmt::Debug>","error::ErrorKind","number::Endianness","internal::Needed"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::Into","internal::Map","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Or"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<!>>","i8","<T as std::convert::From<T>>"],"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::And","internal::Or","internal::Into","internal::FlatMap","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Map","internal::And"],"G":["core::str::LinesAnyMap","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","internal::AndThen","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::And"],"G":["<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::AndThen","internal::And","internal::Map","std::boxed::Box","internal::FlatMap"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // P
+bits::bits(p0);
+crate::bits::bits(p0);
+crate::bits::bits(p0);
-----------------
src/bits/mod.rs bits::bytes
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"bits::bytes":{"E1":["traits::ErrorConvert","std::marker::Sized","error::ParseError"],"E2":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Slice","std::clone::Clone"],"O":["std::marker::Sized"],"P":["std::marker::Sized","internal::Parser"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"bits::bytes":{"E1":["error::VerboseError","error::Error"],"E2":["error::Error","error::VerboseError"],"I":["memchr::cow::Imp<'a>","memchr::cow::CowBytes<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::memmem::FinderRev<'n>"],"O":["RUG_ANY"],"P":["internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Into","internal::FlatMap","internal::Map"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::And","internal::AndThen","internal::Or"],"G":["internal::AndThen","internal::Map","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","std::boxed::Box"]},"internal::AndThen":{"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","internal::Or"],"G":["internal::AndThen","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::And","internal::Or"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","internal::Needed","error::ErrorKind","internal::Err"]},"internal::FlatMap":{"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","i8","<T as std::convert::From<T>>","u8"],"F":["internal::FlatMap","std::boxed::Box","internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::And","std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or"],"G":["core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","std::boxed::Box","internal::And","internal::Or","internal::AndThen"],"G":["internal::AndThen","std::boxed::Box","internal::Into","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // P
+bits::bytes(p0);
+crate::bits::bytes(p0);
+crate::bits::bytes(p0);
-----------------
src/bytes/complete.rs bytes::complete::tag
deps:{"bytes::complete::tag":{"Error":["std::marker::Sized","error::ParseError"],"Input":["traits::InputTake","traits::Compare","std::marker::Sized"],"T":["traits::InputLength","std::clone::Clone","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"bytes::complete::tag":{"Error":["error::VerboseError","error::Error"],"T":["memchr::memmem::Finder<'n>","memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::complete::tag(p0);
+crate::bytes::complete::tag(p0);
+crate::bytes::complete::tag(p0);
-----------------
src/bytes/complete.rs bytes::complete::tag_no_case
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"bytes::complete::tag_no_case":{"Error":["error::ParseError","std::marker::Sized"],"Input":["std::marker::Sized","traits::Compare","traits::InputTake"],"T":["std::marker::Sized","std::clone::Clone","traits::InputLength"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"bytes::complete::tag_no_case":{"Error":["error::Error","error::VerboseError"],"T":["memchr::cow::CowBytes<'a>","memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::memmem::FinderRev<'n>","memchr::cow::Imp<'a>"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","internal::Needed","<*mut T as std::fmt::Debug>","number::Endianness"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::complete::tag_no_case(p0);
+crate::bytes::complete::tag_no_case(p0);
+crate::bytes::complete::tag_no_case(p0);
-----------------
src/bytes/complete.rs bytes::complete::is_not
deps:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["traits::InputLength","std::clone::Clone","traits::UnspecializedInput","std::marker::Sized","traits::InputIter","traits::InputTake"]},"bytes::complete::is_not":{"Error":["std::marker::Sized","error::ParseError"],"Input":["traits::InputTakeAtPosition","std::marker::Sized"],"T":["std::marker::Sized","traits::FindToken"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"bytes::complete::is_not":{"Error":["error::Error","error::VerboseError"],"Input":["<T as traits::InputTakeAtPosition>"],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::complete::is_not(p0);
+crate::bytes::complete::is_not(p0);
+crate::bytes::complete::is_not(p0);
-----------------
src/bytes/complete.rs bytes::complete::is_a
deps:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["traits::UnspecializedInput","traits::InputTake","traits::InputIter","traits::InputLength","std::clone::Clone","std::marker::Sized"]},"bytes::complete::is_a":{"Error":["error::ParseError","std::marker::Sized"],"Input":["std::marker::Sized","traits::InputTakeAtPosition"],"T":["std::marker::Sized","traits::FindToken"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"bytes::complete::is_a":{"Error":["error::VerboseError","error::Error"],"Input":["<T as traits::InputTakeAtPosition>"],"T":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","internal::Err","<*const T as std::fmt::Debug>","number::Endianness"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::complete::is_a(p0);
+crate::bytes::complete::is_a(p0);
+crate::bytes::complete::is_a(p0);
-----------------
src/bytes/complete.rs bytes::complete::take_while
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputLength","traits::UnspecializedInput","std::marker::Sized","std::clone::Clone","traits::InputIter","traits::InputTake"]},"bytes::complete::take_while":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","std::ops::Fn"],"Input":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"bytes::complete::take_while":{"Error":["error::VerboseError","error::Error"],"F":["core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte"],"Input":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::ErrorKind","internal::Needed","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::complete::take_while(p0);
+crate::bytes::complete::take_while(p0);
+crate::bytes::complete::take_while(p0);
-----------------
src/bytes/complete.rs bytes::complete::take_while1
deps:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["std::marker::Sized","traits::InputTake","traits::InputLength","std::clone::Clone","traits::UnspecializedInput","traits::InputIter"]},"bytes::complete::take_while1":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::ops::Fn","std::marker::Sized"],"Input":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"bytes::complete::take_while1":{"Error":["error::VerboseError","error::Error"],"F":["core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>"],"Input":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::ErrorKind","number::Endianness","internal::Needed","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::complete::take_while1(p0);
+crate::bytes::complete::take_while1(p0);
+crate::bytes::complete::take_while1(p0);
-----------------
src/bytes/complete.rs bytes::complete::take_while_m_n
deps:{"bytes::complete::take_while_m_n":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","std::ops::Fn"],"Input":["traits::InputTake","traits::InputIter","std::marker::Sized","traits::InputLength","traits::Slice"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"bytes::complete::take_while_m_n":{"Error":["error::VerboseError","error::Error"],"F":["core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","number::Endianness","error::ErrorKind","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+bytes::complete::take_while_m_n(p0, p1, p2);
+crate::bytes::complete::take_while_m_n(p0, p1, p2);
+crate::bytes::complete::take_while_m_n(p0, p1, p2);
-----------------
src/bytes/complete.rs bytes::complete::take_till
deps:{"<T as traits::InputTakeAtPosition>":{"T":["std::clone::Clone","traits::InputLength","traits::InputIter","traits::InputTake","std::marker::Sized","traits::UnspecializedInput"]},"bytes::complete::take_till":{"Error":["error::ParseError","std::marker::Sized"],"F":["std::ops::Fn","std::marker::Sized"],"Input":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"bytes::complete::take_till":{"Error":["error::VerboseError","error::Error"],"F":["core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsNotEmpty"],"Input":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::complete::take_till(p0);
+crate::bytes::complete::take_till(p0);
+crate::bytes::complete::take_till(p0);
-----------------
src/bytes/complete.rs bytes::complete::take_till1
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputTake","traits::InputLength","std::marker::Sized","traits::InputIter","std::clone::Clone","traits::UnspecializedInput"]},"bytes::complete::take_till1":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::ops::Fn","std::marker::Sized"],"Input":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"bytes::complete::take_till1":{"Error":["error::VerboseError","error::Error"],"F":["core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>"],"Input":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","internal::Needed","number::Endianness"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::complete::take_till1(p0);
+crate::bytes::complete::take_till1(p0);
+crate::bytes::complete::take_till1(p0);
-----------------
src/bytes/complete.rs bytes::complete::take
deps:{"<*const T as std::fmt::Debug>":{},"bytes::complete::take":{"C":["std::marker::Sized","traits::ToUsize"],"Error":["std::marker::Sized","error::ParseError"],"Input":["std::marker::Sized","traits::InputIter","traits::InputTake"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bytes::complete::take":{"C":[],"Error":["error::Error","error::VerboseError"],"Input":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","internal::Needed","number::Endianness","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // C
+bytes::complete::take(p0);
+crate::bytes::complete::take(p0);
+crate::bytes::complete::take(p0);
-----------------
src/bytes/complete.rs bytes::complete::take_until
deps:{"<*const T as std::fmt::Debug>":{},"bytes::complete::take_until":{"Error":["std::marker::Sized","error::ParseError"],"Input":["traits::FindSubstring","traits::InputTake","std::marker::Sized"],"T":["std::marker::Sized","traits::InputLength","std::clone::Clone"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bytes::complete::take_until":{"Error":["error::Error","error::VerboseError"],"Input":[],"T":["memchr::cow::Imp<'a>","memchr::memmem::FinderBuilder","memchr::memmem::Finder<'n>","memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","number::Endianness","internal::Err","internal::Needed","error::ErrorKind"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::complete::take_until(p0);
+crate::bytes::complete::take_until(p0);
+crate::bytes::complete::take_until(p0);
-----------------
src/bytes/complete.rs bytes::complete::take_until1
deps:{"<*const T as std::fmt::Debug>":{},"bytes::complete::take_until1":{"Error":["std::marker::Sized","error::ParseError"],"Input":["std::marker::Sized","traits::InputTake","traits::FindSubstring"],"T":["std::clone::Clone","std::marker::Sized","traits::InputLength"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bytes::complete::take_until1":{"Error":["error::Error","error::VerboseError"],"Input":[],"T":["memchr::memmem::Finder<'n>","memchr::cow::Imp<'a>","memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::memmem::FinderBuilder"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::ErrorKind","internal::Needed","number::Endianness","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::complete::take_until1(p0);
+crate::bytes::complete::take_until1(p0);
+crate::bytes::complete::take_until1(p0);
-----------------
src/bytes/complete.rs bytes::complete::escaped
'a
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"bytes::complete::escaped":{"<Input as traits::InputIter>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"Input":["traits::InputTake","std::clone::Clone","traits::InputIter","std::marker::Sized","traits::Slice","traits::InputTakeAtPosition","traits::Offset","traits::InputLength"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"bytes::complete::escaped":{"<Input as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"],"F":["internal::Map","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::AndThen","internal::Into"],"G":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::And","internal::Or"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Map","internal::Or","internal::Into"],"G":["internal::Into","internal::And","internal::Map","internal::AndThen","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap"]},"internal::AndThen":{"F":["internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into","internal::And"],"G":["internal::Map","internal::FlatMap","internal::Into","std::boxed::Box","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","<*const T as std::fmt::Debug>","internal::Needed","error::ErrorKind","internal::Err"]},"internal::FlatMap":{"F":["internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::And","internal::Or","internal::AndThen"],"G":["core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<T>>","<T as std::convert::From<!>>","i8"],"F":["internal::Into","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::And","internal::Map"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::Or","internal::Map","internal::FlatMap","internal::And","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::Into","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Map"],"G":["internal::FlatMap","internal::Map","internal::Or","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = 'a'; // None+char
let mut p2 = MaybeUninit::uninit().assume_init(); // G
+bytes::complete::escaped(p0, p1, p2);
+crate::bytes::complete::escaped(p0, p1, p2);
+crate::bytes::complete::escaped(p0, p1, p2);
-----------------
src/bytes/complete.rs bytes::complete::escaped_transform
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"bytes::complete::escaped_transform":{"<Input as traits::InputIter>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"ExtendItem":["std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"Input":["traits::InputTakeAtPosition","traits::InputLength","traits::InputTake","traits::Offset","traits::ExtendInto","std::marker::Sized","std::clone::Clone","traits::Slice","traits::InputIter"],"O1":["std::marker::Sized","traits::ExtendInto"],"O2":["traits::ExtendInto","std::marker::Sized"],"Output":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::str::LinesAnyMap"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"bytes::complete::escaped_transform":{"<Input as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"],"ExtendItem":["RUG_ANY"],"F":["internal::FlatMap","internal::Into","internal::Or","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen"],"G":["internal::AndThen","internal::Into","internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box"],"O1":[],"O2":[],"Output":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","std::boxed::Box","internal::FlatMap","internal::Into","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen"],"G":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::AndThen","internal::And","internal::Or","internal::FlatMap"]},"internal::AndThen":{"F":["internal::Into","internal::Map","internal::AndThen","std::boxed::Box","internal::Or","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"G":["<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::AndThen","internal::And","internal::Into","internal::FlatMap","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","internal::Err","number::Endianness","error::ErrorKind","internal::Needed"]},"internal::FlatMap":{"F":["internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::FlatMap","internal::Into","internal::Map"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>","<T as std::convert::From<!>>"],"F":["std::boxed::Box","internal::Map","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::AndThen","internal::Map","internal::Or","internal::FlatMap","internal::And"],"G":["internal::FlatMap","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Or","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = 'a'; // None+char
let mut p2 = MaybeUninit::uninit().assume_init(); // G
+bytes::complete::escaped_transform(p0, p1, p2);
+crate::bytes::complete::escaped_transform(p0, p1, p2);
+crate::bytes::complete::escaped_transform(p0, p1, p2);
-----------------
src/bytes/streaming.rs bytes::streaming::tag
deps:{"<*const T as std::fmt::Debug>":{},"bytes::streaming::tag":{"Error":["std::marker::Sized","error::ParseError"],"Input":["std::marker::Sized","traits::Compare","traits::InputLength","traits::InputTake"],"T":["std::marker::Sized","std::clone::Clone","traits::InputLength"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bytes::streaming::tag":{"Error":["error::VerboseError","error::Error"],"T":["memchr::memmem::Finder<'n>","memchr::memmem::FinderRev<'n>","memchr::memmem::FinderBuilder","memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","<*const T as std::fmt::Debug>","number::Endianness","internal::Err"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::streaming::tag(p0);
+crate::bytes::streaming::tag(p0);
+crate::bytes::streaming::tag(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::tag_no_case
deps:{"bytes::streaming::tag_no_case":{"Error":["error::ParseError","std::marker::Sized"],"Input":["traits::InputLength","traits::InputTake","std::marker::Sized","traits::Compare"],"T":["std::clone::Clone","std::marker::Sized","traits::InputLength"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"bytes::streaming::tag_no_case":{"Error":["error::VerboseError","error::Error"],"T":["memchr::memmem::Finder<'n>","memchr::memmem::FinderBuilder","memchr::memmem::FinderRev<'n>","memchr::cow::CowBytes<'a>","memchr::cow::Imp<'a>"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::streaming::tag_no_case(p0);
+crate::bytes::streaming::tag_no_case(p0);
+crate::bytes::streaming::tag_no_case(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::is_not
deps:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["traits::InputIter","traits::UnspecializedInput","std::marker::Sized","traits::InputLength","std::clone::Clone","traits::InputTake"]},"bytes::streaming::is_not":{"Error":["std::marker::Sized","error::ParseError"],"Input":["std::marker::Sized","traits::InputTakeAtPosition"],"T":["traits::FindToken","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"bytes::streaming::is_not":{"Error":["error::VerboseError","error::Error"],"Input":["<T as traits::InputTakeAtPosition>"],"T":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::streaming::is_not(p0);
+crate::bytes::streaming::is_not(p0);
+crate::bytes::streaming::is_not(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::is_a
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputTake","traits::InputLength","traits::InputIter","std::marker::Sized","std::clone::Clone","traits::UnspecializedInput"]},"bytes::streaming::is_a":{"Error":["std::marker::Sized","error::ParseError"],"Input":["traits::InputTakeAtPosition","std::marker::Sized"],"T":["std::marker::Sized","traits::FindToken"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"bytes::streaming::is_a":{"Error":["error::Error","error::VerboseError"],"Input":["<T as traits::InputTakeAtPosition>"],"T":[]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::streaming::is_a(p0);
+crate::bytes::streaming::is_a(p0);
+crate::bytes::streaming::is_a(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take_while
deps:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["std::marker::Sized","traits::UnspecializedInput","traits::InputTake","std::clone::Clone","traits::InputLength","traits::InputIter"]},"bytes::streaming::take_while":{"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","std::ops::Fn"],"Input":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"bytes::streaming::take_while":{"Error":["error::VerboseError","error::Error"],"F":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode"],"Input":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::ErrorKind","number::Endianness","internal::Needed","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::streaming::take_while(p0);
+crate::bytes::streaming::take_while(p0);
+crate::bytes::streaming::take_while(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take_while1
deps:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["std::clone::Clone","traits::UnspecializedInput","traits::InputLength","std::marker::Sized","traits::InputTake","traits::InputIter"]},"bytes::streaming::take_while1":{"Error":["error::ParseError","std::marker::Sized"],"F":["std::ops::Fn","std::marker::Sized"],"Input":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"bytes::streaming::take_while1":{"Error":["error::VerboseError","error::Error"],"F":["core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap"],"Input":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","number::Endianness","<*const T as std::fmt::Debug>","internal::Needed","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::streaming::take_while1(p0);
+crate::bytes::streaming::take_while1(p0);
+crate::bytes::streaming::take_while1(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take_while_m_n
deps:{"<*const T as std::fmt::Debug>":{},"bytes::streaming::take_while_m_n":{"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","std::ops::Fn"],"Input":["traits::InputTake","traits::InputIter","std::marker::Sized","traits::InputLength"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"bytes::streaming::take_while_m_n":{"Error":["error::VerboseError","error::Error"],"F":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>"],"Input":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","internal::Needed","number::Endianness","error::ErrorKind"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = 0usize; // None+usize
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // F
+bytes::streaming::take_while_m_n(p0, p1, p2);
+crate::bytes::streaming::take_while_m_n(p0, p1, p2);
+crate::bytes::streaming::take_while_m_n(p0, p1, p2);
-----------------
src/bytes/streaming.rs bytes::streaming::take_till
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputLength","std::marker::Sized","traits::InputIter","std::clone::Clone","traits::UnspecializedInput","traits::InputTake"]},"bytes::streaming::take_till":{"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","std::ops::Fn"],"Input":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"bytes::streaming::take_till":{"Error":["error::VerboseError","error::Error"],"F":["core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue"],"Input":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed","number::Endianness"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::streaming::take_till(p0);
+crate::bytes::streaming::take_till(p0);
+crate::bytes::streaming::take_till(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take_till1
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::UnspecializedInput","std::marker::Sized","traits::InputIter","traits::InputTake","traits::InputLength","std::clone::Clone"]},"bytes::streaming::take_till1":{"Error":["error::ParseError","std::marker::Sized"],"F":["std::ops::Fn","std::marker::Sized"],"Input":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"bytes::streaming::take_till1":{"Error":["error::Error","error::VerboseError"],"F":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue"],"Input":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+bytes::streaming::take_till1(p0);
+crate::bytes::streaming::take_till1(p0);
+crate::bytes::streaming::take_till1(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take
deps:{"bytes::streaming::take":{"C":["std::marker::Sized","traits::ToUsize"],"Error":["std::marker::Sized","error::ParseError"],"Input":["traits::InputTake","std::marker::Sized","traits::InputLength","traits::InputIter"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"bytes::streaming::take":{"C":[],"Error":["error::Error","error::VerboseError"],"Input":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // C
+bytes::streaming::take(p0);
+crate::bytes::streaming::take(p0);
+crate::bytes::streaming::take(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take_until
deps:{"bytes::streaming::take_until":{"Error":["std::marker::Sized","error::ParseError"],"Input":["std::marker::Sized","traits::InputLength","traits::FindSubstring","traits::InputTake"],"T":["std::clone::Clone","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"bytes::streaming::take_until":{"Error":["error::Error","error::VerboseError"],"Input":[],"T":["number::Endianness","std::clone::impls::<impl std::clone::Clone for &T>","error::ErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseErrorKind","error::VerboseError","internal::Needed"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::streaming::take_until(p0);
+crate::bytes::streaming::take_until(p0);
+crate::bytes::streaming::take_until(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::take_until1
deps:{"bytes::streaming::take_until1":{"Error":["std::marker::Sized","error::ParseError"],"Input":["std::marker::Sized","traits::InputLength","traits::InputTake","traits::FindSubstring"],"T":["std::clone::Clone","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"bytes::streaming::take_until1":{"Error":["error::VerboseError","error::Error"],"Input":[],"T":["internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","error::VerboseError","internal::Err","number::Endianness"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","number::Endianness","internal::Err","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+bytes::streaming::take_until1(p0);
+crate::bytes::streaming::take_until1(p0);
+crate::bytes::streaming::take_until1(p0);
-----------------
src/bytes/streaming.rs bytes::streaming::escaped
deps:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"bytes::streaming::escaped":{"<Input as traits::InputIter>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"Input":["traits::InputIter","traits::InputTake","traits::InputLength","traits::Slice","std::clone::Clone","traits::Offset","traits::InputTakeAtPosition","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"bytes::streaming::escaped":{"<Input as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"],"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Into","internal::AndThen","internal::FlatMap","internal::Or","std::boxed::Box"],"G":["internal::Map","std::boxed::Box","internal::Or","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Into","std::boxed::Box","internal::And","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map"],"G":["<F as internal::Parser<I, O, E>>","internal::And","internal::Or","std::boxed::Box","internal::Map","internal::FlatMap","internal::Into","internal::AndThen"]},"internal::AndThen":{"F":["internal::Or","internal::And","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Map"],"G":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","std::boxed::Box","internal::AndThen","internal::Or","internal::FlatMap","internal::And"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","number::Endianness","<*mut T as std::fmt::Debug>","internal::Err"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Into","internal::And","internal::FlatMap","internal::AndThen","internal::Map"],"G":["core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","i8","u8","<T as std::convert::From<T>>"],"F":["std::boxed::Box","internal::Or","internal::FlatMap","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::Or","internal::Map","internal::And","internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::And","internal::FlatMap","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = 'a'; // None+char
let mut p2 = MaybeUninit::uninit().assume_init(); // G
+bytes::streaming::escaped(p0, p1, p2);
+crate::bytes::streaming::escaped(p0, p1, p2);
+crate::bytes::streaming::escaped(p0, p1, p2);
-----------------
src/bytes/streaming.rs bytes::streaming::escaped_transform
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"bytes::streaming::escaped_transform":{"<Input as traits::InputIter>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"ExtendItem":["std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"Input":["traits::InputTakeAtPosition","traits::Offset","traits::InputTake","traits::Slice","traits::InputLength","std::marker::Sized","traits::InputIter","std::clone::Clone","traits::ExtendInto"],"O1":["std::marker::Sized","traits::ExtendInto"],"O2":["std::marker::Sized","traits::ExtendInto"],"Output":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"bytes::streaming::escaped_transform":{"<Input as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"],"ExtendItem":["RUG_ANY"],"F":["internal::Or","internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I, O, E>>"],"G":["internal::Map","internal::FlatMap","internal::Or","internal::AndThen","internal::Into","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>"],"O1":[],"O2":[],"Output":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::Map","internal::Or","internal::And"],"G":["internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::And"],"G":["<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::FlatMap","std::boxed::Box","internal::Or","internal::AndThen","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","internal::Needed","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness"]},"internal::FlatMap":{"F":["internal::AndThen","internal::Into","internal::And","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::FlatMap","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","std::boxed::Box","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::Into","internal::FlatMap","internal::Map"],"G":["core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::FlatMap","internal::AndThen"],"G":["<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::AndThen","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
let mut p1 = 'a'; // None+char
let mut p2 = MaybeUninit::uninit().assume_init(); // G
+bytes::streaming::escaped_transform(p0, p1, p2);
+crate::bytes::streaming::escaped_transform(p0, p1, p2);
+crate::bytes::streaming::escaped_transform(p0, p1, p2);
-----------------
src/character/complete.rs character::complete::char
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::char":{"<I as traits::InputIter>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","traits::InputIter","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::char":{"<I as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed","internal::Err","error::ErrorKind","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = 'a'; // None+char
+character::complete::char(p0);
+crate::character::complete::char(p0);
+crate::character::complete::char(p0);
-----------------
src/character/complete.rs character::complete::satisfy
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::satisfy":{"<I as traits::InputIter>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::ops::Fn","std::marker::Sized"],"I":["traits::InputIter","std::marker::Sized","traits::Slice"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::satisfy":{"<I as traits::InputIter>::Item":[],"Error":["error::VerboseError","error::Error"],"F":["core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::LinesAnyMap"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","internal::Needed","number::Endianness","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+character::complete::satisfy(p0);
+crate::character::complete::satisfy(p0);
+crate::character::complete::satisfy(p0);
-----------------
src/character/complete.rs character::complete::one_of
deps:{"character::complete::one_of":{"<I as traits::InputIter>::Item":["std::marker::Copy","traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","std::marker::Sized","traits::InputIter"],"T":["std::marker::Sized","traits::FindToken"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"character::complete::one_of":{"<I as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed","internal::Err","error::ErrorKind","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::one_of(p0);
+crate::character::complete::one_of(p0);
+crate::character::complete::one_of(p0);
-----------------
src/character/complete.rs character::complete::none_of
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::none_of":{"<I as traits::InputIter>::Item":["traits::AsChar","std::marker::Copy"],"Error":["error::ParseError","std::marker::Sized"],"I":["traits::InputIter","traits::Slice","std::marker::Sized"],"T":["std::marker::Sized","traits::FindToken"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::none_of":{"<I as traits::InputIter>::Item":[],"Error":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","<*mut T as std::fmt::Debug>","error::ErrorKind","number::Endianness","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::none_of(p0);
+crate::character::complete::none_of(p0);
+crate::character::complete::none_of(p0);
-----------------
src/character/complete.rs character::complete::crlf
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"character::complete::crlf":{"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputIter","std::marker::Sized","traits::Slice","traits::Compare"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"character::complete::crlf":{"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","internal::Needed","number::Endianness","error::ErrorKind","<*mut T as std::fmt::Debug>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::crlf(p0);
+crate::character::complete::crlf(p0);
+crate::character::complete::crlf(p0);
-----------------
src/character/complete.rs character::complete::not_line_ending
deps:{"<*const T as std::fmt::Debug>":{},"character::complete::not_line_ending":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::Compare","std::marker::Sized","traits::InputIter","traits::Slice","traits::InputLength"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::complete::not_line_ending":{"<T as traits::InputIter>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","internal::Err","number::Endianness","<*const T as std::fmt::Debug>"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::not_line_ending(p0);
+crate::character::complete::not_line_ending(p0);
+crate::character::complete::not_line_ending(p0);
-----------------
src/character/complete.rs character::complete::line_ending
deps:{"character::complete::line_ending":{"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputLength","traits::Slice","traits::Compare","std::marker::Sized","traits::InputIter"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::complete::line_ending":{"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::line_ending(p0);
+crate::character::complete::line_ending(p0);
+crate::character::complete::line_ending(p0);
-----------------
src/character/complete.rs character::complete::newline
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::newline":{"<I as traits::InputIter>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","std::marker::Sized","traits::InputIter"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::newline":{"<I as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","<*mut T as std::fmt::Debug>","number::Endianness","internal::Err","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+character::complete::newline(p0);
+crate::character::complete::newline(p0);
+crate::character::complete::newline(p0);
-----------------
src/character/complete.rs character::complete::tab
deps:{"character::complete::tab":{"<I as traits::InputIter>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Slice","traits::InputIter"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::complete::tab":{"<I as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness","internal::Needed","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+character::complete::tab(p0);
+crate::character::complete::tab(p0);
+crate::character::complete::tab(p0);
-----------------
src/character/complete.rs character::complete::anychar
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"character::complete::anychar":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::InputLength","std::marker::Sized","traits::Slice","traits::InputIter"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"character::complete::anychar":{"<T as traits::InputIter>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Err","internal::Needed","<*const T as std::fmt::Debug>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::anychar(p0);
+crate::character::complete::anychar(p0);
+crate::character::complete::anychar(p0);
-----------------
src/character/complete.rs character::complete::alpha0
deps:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["std::marker::Sized","traits::InputIter","std::clone::Clone","traits::UnspecializedInput","traits::InputTake","traits::InputLength"]},"character::complete::alpha0":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"character::complete::alpha0":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::alpha0(p0);
+crate::character::complete::alpha0(p0);
+crate::character::complete::alpha0(p0);
-----------------
src/character/complete.rs character::complete::alpha1
deps:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["traits::UnspecializedInput","std::marker::Sized","traits::InputIter","traits::InputLength","traits::InputTake","std::clone::Clone"]},"character::complete::alpha1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"character::complete::alpha1":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","number::Endianness","<*mut T as std::fmt::Debug>","internal::Err","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::alpha1(p0);
+crate::character::complete::alpha1(p0);
+crate::character::complete::alpha1(p0);
-----------------
src/character/complete.rs character::complete::digit0
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputLength","traits::InputTake","std::clone::Clone","traits::UnspecializedInput","std::marker::Sized","traits::InputIter"]},"character::complete::digit0":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::complete::digit0":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","number::Endianness","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::digit0(p0);
+crate::character::complete::digit0(p0);
+crate::character::complete::digit0(p0);
-----------------
src/character/complete.rs character::complete::digit1
deps:{"<T as traits::InputTakeAtPosition>":{"T":["std::marker::Sized","traits::InputTake","std::clone::Clone","traits::InputLength","traits::InputIter","traits::UnspecializedInput"]},"character::complete::digit1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::complete::digit1":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","internal::Err","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::digit1(p0);
+crate::character::complete::digit1(p0);
+crate::character::complete::digit1(p0);
-----------------
src/character/complete.rs character::complete::hex_digit0
deps:{"<T as traits::InputTakeAtPosition>":{"T":["std::clone::Clone","traits::InputLength","traits::InputTake","traits::UnspecializedInput","traits::InputIter","std::marker::Sized"]},"character::complete::hex_digit0":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::complete::hex_digit0":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","number::Endianness","error::ErrorKind","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::hex_digit0(p0);
+crate::character::complete::hex_digit0(p0);
+crate::character::complete::hex_digit0(p0);
-----------------
src/character/complete.rs character::complete::hex_digit1
deps:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["traits::UnspecializedInput","std::marker::Sized","traits::InputLength","std::clone::Clone","traits::InputIter","traits::InputTake"]},"character::complete::hex_digit1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"character::complete::hex_digit1":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","<*mut T as std::fmt::Debug>","number::Endianness","internal::Err","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::hex_digit1(p0);
+crate::character::complete::hex_digit1(p0);
+crate::character::complete::hex_digit1(p0);
-----------------
src/character/complete.rs character::complete::oct_digit0
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputLength","std::marker::Sized","traits::InputTake","std::clone::Clone","traits::UnspecializedInput","traits::InputIter"]},"character::complete::oct_digit0":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::complete::oct_digit0":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","internal::Err","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::oct_digit0(p0);
+crate::character::complete::oct_digit0(p0);
+crate::character::complete::oct_digit0(p0);
-----------------
src/character/complete.rs character::complete::oct_digit1
deps:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["traits::InputTake","traits::InputIter","traits::InputLength","std::marker::Sized","traits::UnspecializedInput","std::clone::Clone"]},"character::complete::oct_digit1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"character::complete::oct_digit1":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Err","<*const T as std::fmt::Debug>","internal::Needed"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::oct_digit1(p0);
+crate::character::complete::oct_digit1(p0);
+crate::character::complete::oct_digit1(p0);
-----------------
src/character/complete.rs character::complete::alphanumeric0
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputTake","traits::UnspecializedInput","traits::InputIter","std::clone::Clone","traits::InputLength","std::marker::Sized"]},"character::complete::alphanumeric0":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::complete::alphanumeric0":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Needed","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::alphanumeric0(p0);
+crate::character::complete::alphanumeric0(p0);
+crate::character::complete::alphanumeric0(p0);
-----------------
src/character/complete.rs character::complete::alphanumeric1
deps:{"<T as traits::InputTakeAtPosition>":{"T":["std::clone::Clone","traits::UnspecializedInput","std::marker::Sized","traits::InputIter","traits::InputTake","traits::InputLength"]},"character::complete::alphanumeric1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::complete::alphanumeric1":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Err","internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::alphanumeric1(p0);
+crate::character::complete::alphanumeric1(p0);
+crate::character::complete::alphanumeric1(p0);
-----------------
src/character/complete.rs character::complete::space0
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputIter","std::clone::Clone","traits::InputTake","traits::UnspecializedInput","traits::InputLength","std::marker::Sized"]},"character::complete::space0":{"<T as traits::InputTakeAtPosition>::Item":["std::clone::Clone","traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::complete::space0":{"<T as traits::InputTakeAtPosition>::Item":["u8","char"],"E":["error::Error","error::VerboseError"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","internal::Err","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::space0(p0);
+crate::character::complete::space0(p0);
+crate::character::complete::space0(p0);
-----------------
src/character/complete.rs character::complete::space1
deps:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["traits::InputLength","std::clone::Clone","traits::InputTake","traits::InputIter","traits::UnspecializedInput","std::marker::Sized"]},"character::complete::space1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar","std::clone::Clone"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"character::complete::space1":{"<T as traits::InputTakeAtPosition>::Item":["char","u8"],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","internal::Err","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::space1(p0);
+crate::character::complete::space1(p0);
+crate::character::complete::space1(p0);
-----------------
src/character/complete.rs character::complete::multispace0
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputIter","traits::InputLength","std::clone::Clone","std::marker::Sized","traits::InputTake","traits::UnspecializedInput"]},"character::complete::multispace0":{"<T as traits::InputTakeAtPosition>::Item":["std::clone::Clone","traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::complete::multispace0":{"<T as traits::InputTakeAtPosition>::Item":["char","u8"],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::multispace0(p0);
+crate::character::complete::multispace0(p0);
+crate::character::complete::multispace0(p0);
-----------------
src/character/complete.rs character::complete::multispace1
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputLength","std::clone::Clone","traits::InputTake","traits::UnspecializedInput","traits::InputIter","std::marker::Sized"]},"character::complete::multispace1":{"<T as traits::InputTakeAtPosition>::Item":["std::clone::Clone","traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::complete::multispace1":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::multispace1(p0);
+crate::character::complete::multispace1(p0);
+crate::character::complete::multispace1(p0);
-----------------
src/character/complete.rs character::complete::sign
deps:{"character::complete::sign":{"E":["std::marker::Sized","error::ParseError"],"T":["traits::Compare","std::clone::Clone","traits::InputTake","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"character::complete::sign":{"E":["error::VerboseError","error::Error"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","internal::Err","number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::sign(p0);
+crate::character::complete::sign(p0);
+crate::character::complete::sign(p0);
-----------------
src/character/complete.rs character::complete::i8
deps:{"<*const T as std::fmt::Debug>":{},"character::complete::i8":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::Compare","std::clone::Clone","traits::InputTake","traits::InputLength","traits::InputIter","traits::Slice"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::complete::i8":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::i8(p0);
+crate::character::complete::i8(p0);
+crate::character::complete::i8(p0);
-----------------
src/character/complete.rs character::complete::i16
deps:{"character::complete::i16":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputLength","traits::InputTake","std::clone::Clone","traits::InputIter","traits::Compare","std::marker::Sized","traits::Slice"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::complete::i16":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","internal::Needed","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::i16(p0);
+crate::character::complete::i16(p0);
+crate::character::complete::i16(p0);
-----------------
src/character/complete.rs character::complete::i32
deps:{"<*const T as std::fmt::Debug>":{},"character::complete::i32":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::clone::Clone","traits::Compare","traits::Slice","traits::InputIter","std::marker::Sized","traits::InputLength","traits::InputTake"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::complete::i32":{"<T as traits::InputIter>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","error::ErrorKind","number::Endianness"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::i32(p0);
+crate::character::complete::i32(p0);
+crate::character::complete::i32(p0);
-----------------
src/character/complete.rs character::complete::i64
deps:{"character::complete::i64":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::Slice","traits::InputIter","traits::InputLength","std::clone::Clone","traits::InputTake","traits::Compare"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::complete::i64":{"<T as traits::InputIter>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::ErrorKind","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::i64(p0);
+crate::character::complete::i64(p0);
+crate::character::complete::i64(p0);
-----------------
src/character/complete.rs character::complete::i128
deps:{"<*const T as std::fmt::Debug>":{},"character::complete::i128":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::InputIter","traits::InputLength","traits::Compare","traits::Slice","std::marker::Sized","traits::InputTake","std::clone::Clone"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::complete::i128":{"<T as traits::InputIter>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","number::Endianness","error::ErrorKind","internal::Needed","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::i128(p0);
+crate::character::complete::i128(p0);
+crate::character::complete::i128(p0);
-----------------
src/character/complete.rs character::complete::u8
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::u8":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::InputIter","traits::Slice","traits::InputLength","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::u8":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::u8(p0);
+crate::character::complete::u8(p0);
+crate::character::complete::u8(p0);
-----------------
src/character/complete.rs character::complete::u16
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::u16":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::InputLength","traits::InputIter","std::marker::Sized","traits::Slice"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::u16":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","internal::Err","error::ErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::u16(p0);
+crate::character::complete::u16(p0);
+crate::character::complete::u16(p0);
-----------------
src/character/complete.rs character::complete::u32
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::u32":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Slice","traits::InputIter","traits::InputLength","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::u32":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness","error::ErrorKind","internal::Needed","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::u32(p0);
+crate::character::complete::u32(p0);
+crate::character::complete::u32(p0);
-----------------
src/character/complete.rs character::complete::u64
deps:{"character::complete::u64":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::InputLength","traits::InputIter","traits::Slice"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::complete::u64":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::u64(p0);
+crate::character::complete::u64(p0);
+crate::character::complete::u64(p0);
-----------------
src/character/complete.rs character::complete::u128
deps:{"<*mut T as std::fmt::Debug>":{},"character::complete::u128":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::InputIter","traits::InputLength","traits::Slice"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::complete::u128":{"<T as traits::InputIter>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","<*mut T as std::fmt::Debug>","internal::Needed","internal::Err","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::complete::u128(p0);
+crate::character::complete::u128(p0);
+crate::character::complete::u128(p0);
-----------------
src/character/streaming.rs character::streaming::char
deps:{"character::streaming::char":{"<I as traits::InputIter>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"I":["traits::InputLength","std::marker::Sized","traits::Slice","traits::InputIter"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"character::streaming::char":{"<I as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","internal::Needed","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = 'a'; // None+char
+character::streaming::char(p0);
+crate::character::streaming::char(p0);
+crate::character::streaming::char(p0);
-----------------
src/character/streaming.rs character::streaming::satisfy
deps:{"character::streaming::satisfy":{"<I as traits::InputIter>::Item":["traits::AsChar"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","std::ops::Fn"],"I":["traits::Slice","std::marker::Sized","traits::InputIter"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::streaming::satisfy":{"<I as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"],"F":["std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::LinesAnyMap"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","number::Endianness","error::ErrorKind","internal::Needed"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // F
+character::streaming::satisfy(p0);
+crate::character::streaming::satisfy(p0);
+crate::character::streaming::satisfy(p0);
-----------------
src/character/streaming.rs character::streaming::one_of
deps:{"character::streaming::one_of":{"<I as traits::InputIter>::Item":["traits::AsChar","std::marker::Copy"],"Error":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","std::marker::Sized","traits::InputIter"],"T":["std::marker::Sized","traits::FindToken"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"character::streaming::one_of":{"<I as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::one_of(p0);
+crate::character::streaming::one_of(p0);
+crate::character::streaming::one_of(p0);
-----------------
src/character/streaming.rs character::streaming::none_of
deps:{"character::streaming::none_of":{"<I as traits::InputIter>::Item":["traits::AsChar","std::marker::Copy"],"Error":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","std::marker::Sized","traits::InputIter"],"T":["traits::FindToken","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"character::streaming::none_of":{"<I as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Needed","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::none_of(p0);
+crate::character::streaming::none_of(p0);
+crate::character::streaming::none_of(p0);
-----------------
src/character/streaming.rs character::streaming::crlf
deps:{"character::streaming::crlf":{"E":["std::marker::Sized","error::ParseError"],"T":["traits::Slice","traits::Compare","std::marker::Sized","traits::InputIter"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::streaming::crlf":{"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","internal::Err","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::crlf(p0);
+crate::character::streaming::crlf(p0);
+crate::character::streaming::crlf(p0);
-----------------
src/character/streaming.rs character::streaming::not_line_ending
deps:{"character::streaming::not_line_ending":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputLength","traits::Compare","std::marker::Sized","traits::Slice","traits::InputIter"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::streaming::not_line_ending":{"<T as traits::InputIter>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::not_line_ending(p0);
+crate::character::streaming::not_line_ending(p0);
+crate::character::streaming::not_line_ending(p0);
-----------------
src/character/streaming.rs character::streaming::line_ending
deps:{"character::streaming::line_ending":{"E":["std::marker::Sized","error::ParseError"],"T":["traits::Compare","traits::Slice","std::marker::Sized","traits::InputIter","traits::InputLength"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::streaming::line_ending":{"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed","error::ErrorKind","internal::Err","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::line_ending(p0);
+crate::character::streaming::line_ending(p0);
+crate::character::streaming::line_ending(p0);
-----------------
src/character/streaming.rs character::streaming::newline
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::newline":{"<I as traits::InputIter>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::InputIter","traits::Slice","traits::InputLength"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::newline":{"<I as traits::InputIter>::Item":[],"Error":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Needed","internal::Err","<*const T as std::fmt::Debug>"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+character::streaming::newline(p0);
+crate::character::streaming::newline(p0);
+crate::character::streaming::newline(p0);
-----------------
src/character/streaming.rs character::streaming::tab
deps:{"character::streaming::tab":{"<I as traits::InputIter>::Item":["traits::AsChar"],"Error":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","std::marker::Sized","traits::Slice","traits::InputIter"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"character::streaming::tab":{"<I as traits::InputIter>::Item":[],"Error":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","internal::Needed","internal::Err","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+character::streaming::tab(p0);
+crate::character::streaming::tab(p0);
+crate::character::streaming::tab(p0);
-----------------
src/character/streaming.rs character::streaming::anychar
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::anychar":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputIter","traits::Slice","std::marker::Sized","traits::InputLength"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::anychar":{"<T as traits::InputIter>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Err","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::anychar(p0);
+crate::character::streaming::anychar(p0);
+crate::character::streaming::anychar(p0);
-----------------
src/character/streaming.rs character::streaming::alpha0
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputIter","std::marker::Sized","std::clone::Clone","traits::InputLength","traits::UnspecializedInput","traits::InputTake"]},"character::streaming::alpha0":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::streaming::alpha0":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","internal::Err","number::Endianness","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::alpha0(p0);
+crate::character::streaming::alpha0(p0);
+crate::character::streaming::alpha0(p0);
-----------------
src/character/streaming.rs character::streaming::alpha1
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputLength","traits::UnspecializedInput","std::clone::Clone","traits::InputTake","traits::InputIter","std::marker::Sized"]},"character::streaming::alpha1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::streaming::alpha1":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::alpha1(p0);
+crate::character::streaming::alpha1(p0);
+crate::character::streaming::alpha1(p0);
-----------------
src/character/streaming.rs character::streaming::digit0
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputLength","traits::InputTake","std::clone::Clone","traits::UnspecializedInput","std::marker::Sized","traits::InputIter"]},"character::streaming::digit0":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::streaming::digit0":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","number::Endianness","internal::Err","error::ErrorKind","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::digit0(p0);
+crate::character::streaming::digit0(p0);
+crate::character::streaming::digit0(p0);
-----------------
src/character/streaming.rs character::streaming::digit1
deps:{"<T as traits::InputTakeAtPosition>":{"T":["std::clone::Clone","traits::UnspecializedInput","std::marker::Sized","traits::InputLength","traits::InputIter","traits::InputTake"]},"character::streaming::digit1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::streaming::digit1":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","internal::Err","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::digit1(p0);
+crate::character::streaming::digit1(p0);
+crate::character::streaming::digit1(p0);
-----------------
src/character/streaming.rs character::streaming::hex_digit0
deps:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["std::clone::Clone","traits::InputLength","std::marker::Sized","traits::UnspecializedInput","traits::InputIter","traits::InputTake"]},"character::streaming::hex_digit0":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"character::streaming::hex_digit0":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","internal::Err","number::Endianness","error::ErrorKind","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::hex_digit0(p0);
+crate::character::streaming::hex_digit0(p0);
+crate::character::streaming::hex_digit0(p0);
-----------------
src/character/streaming.rs character::streaming::hex_digit1
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputTake","traits::InputLength","std::clone::Clone","traits::UnspecializedInput","traits::InputIter","std::marker::Sized"]},"character::streaming::hex_digit1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::streaming::hex_digit1":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind","internal::Needed","number::Endianness","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::hex_digit1(p0);
+crate::character::streaming::hex_digit1(p0);
+crate::character::streaming::hex_digit1(p0);
-----------------
src/character/streaming.rs character::streaming::oct_digit0
deps:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["traits::InputTake","std::clone::Clone","traits::UnspecializedInput","traits::InputIter","traits::InputLength","std::marker::Sized"]},"character::streaming::oct_digit0":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"character::streaming::oct_digit0":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::oct_digit0(p0);
+crate::character::streaming::oct_digit0(p0);
+crate::character::streaming::oct_digit0(p0);
-----------------
src/character/streaming.rs character::streaming::oct_digit1
deps:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["traits::InputLength","std::marker::Sized","std::clone::Clone","traits::UnspecializedInput","traits::InputIter","traits::InputTake"]},"character::streaming::oct_digit1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"character::streaming::oct_digit1":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","number::Endianness","<*mut T as std::fmt::Debug>","internal::Err","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::oct_digit1(p0);
+crate::character::streaming::oct_digit1(p0);
+crate::character::streaming::oct_digit1(p0);
-----------------
src/character/streaming.rs character::streaming::alphanumeric0
deps:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["std::clone::Clone","traits::UnspecializedInput","std::marker::Sized","traits::InputLength","traits::InputIter","traits::InputTake"]},"character::streaming::alphanumeric0":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"character::streaming::alphanumeric0":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","number::Endianness","<*const T as std::fmt::Debug>","internal::Needed","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::alphanumeric0(p0);
+crate::character::streaming::alphanumeric0(p0);
+crate::character::streaming::alphanumeric0(p0);
-----------------
src/character/streaming.rs character::streaming::alphanumeric1
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputIter","std::marker::Sized","traits::InputTake","traits::InputLength","std::clone::Clone","traits::UnspecializedInput"]},"character::streaming::alphanumeric1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::streaming::alphanumeric1":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::alphanumeric1(p0);
+crate::character::streaming::alphanumeric1(p0);
+crate::character::streaming::alphanumeric1(p0);
-----------------
src/character/streaming.rs character::streaming::space0
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputTake","std::clone::Clone","traits::InputLength","traits::UnspecializedInput","std::marker::Sized","traits::InputIter"]},"character::streaming::space0":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar","std::clone::Clone"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::streaming::space0":{"<T as traits::InputTakeAtPosition>::Item":["char","u8"],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","internal::Needed","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::space0(p0);
+crate::character::streaming::space0(p0);
+crate::character::streaming::space0(p0);
-----------------
src/character/streaming.rs character::streaming::space1
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["traits::InputIter","traits::InputLength","traits::UnspecializedInput","std::clone::Clone","std::marker::Sized","traits::InputTake"]},"character::streaming::space1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar","std::clone::Clone"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"character::streaming::space1":{"<T as traits::InputTakeAtPosition>::Item":["char","u8"],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","number::Endianness","internal::Err","error::ErrorKind","<*const T as std::fmt::Debug>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::space1(p0);
+crate::character::streaming::space1(p0);
+crate::character::streaming::space1(p0);
-----------------
src/character/streaming.rs character::streaming::multispace0
deps:{"<T as traits::InputTakeAtPosition>":{"T":["std::marker::Sized","std::clone::Clone","traits::InputLength","traits::UnspecializedInput","traits::InputIter","traits::InputTake"]},"character::streaming::multispace0":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar","std::clone::Clone"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::InputTakeAtPosition"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::streaming::multispace0":{"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","number::Endianness","error::ErrorKind","internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::multispace0(p0);
+crate::character::streaming::multispace0(p0);
+crate::character::streaming::multispace0(p0);
-----------------
src/character/streaming.rs character::streaming::multispace1
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputTake","traits::InputIter","std::clone::Clone","traits::UnspecializedInput","traits::InputLength","std::marker::Sized"]},"character::streaming::multispace1":{"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar","std::clone::Clone"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::InputTakeAtPosition","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"character::streaming::multispace1":{"<T as traits::InputTakeAtPosition>::Item":["char","u8"],"E":["error::VerboseError","error::Error"],"T":["<T as traits::InputTakeAtPosition>"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::multispace1(p0);
+crate::character::streaming::multispace1(p0);
+crate::character::streaming::multispace1(p0);
-----------------
src/character/streaming.rs character::streaming::sign
deps:{"<*mut T as std::fmt::Debug>":{},"character::streaming::sign":{"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputLength","std::marker::Sized","traits::InputTake","traits::Compare","std::clone::Clone"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::streaming::sign":{"E":["error::Error","error::VerboseError"],"T":[]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","<*mut T as std::fmt::Debug>","error::ErrorKind","internal::Needed","number::Endianness"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::sign(p0);
+crate::character::streaming::sign(p0);
+crate::character::streaming::sign(p0);
-----------------
src/character/streaming.rs character::streaming::i8
deps:{"character::streaming::i8":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Compare","traits::InputIter","traits::Slice","std::marker::Sized","traits::InputLength","traits::InputTake","std::clone::Clone"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::streaming::i8":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::i8(p0);
+crate::character::streaming::i8(p0);
+crate::character::streaming::i8(p0);
-----------------
src/character/streaming.rs character::streaming::i16
deps:{"<*const T as std::fmt::Debug>":{},"character::streaming::i16":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::marker::Sized","traits::InputTake","traits::InputIter","traits::Compare","traits::Slice","traits::InputLength","std::clone::Clone"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"character::streaming::i16":{"<T as traits::InputIter>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","internal::Err","internal::Needed","number::Endianness","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::i16(p0);
+crate::character::streaming::i16(p0);
+crate::character::streaming::i16(p0);
-----------------
src/character/streaming.rs character::streaming::i32
deps:{"character::streaming::i32":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputLength","std::marker::Sized","traits::InputIter","traits::Slice","traits::InputTake","std::clone::Clone","traits::Compare"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::streaming::i32":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","internal::Err","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::i32(p0);
+crate::character::streaming::i32(p0);
+crate::character::streaming::i32(p0);
-----------------
src/character/streaming.rs character::streaming::i64
deps:{"character::streaming::i64":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::clone::Clone","traits::Slice","std::marker::Sized","traits::InputLength","traits::InputTake","traits::Compare","traits::InputIter"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::streaming::i64":{"<T as traits::InputIter>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","error::ErrorKind","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::i64(p0);
+crate::character::streaming::i64(p0);
+crate::character::streaming::i64(p0);
-----------------
src/character/streaming.rs character::streaming::i128
deps:{"character::streaming::i128":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputLength","std::clone::Clone","traits::InputIter","traits::Compare","std::marker::Sized","traits::InputTake","traits::Slice"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::streaming::i128":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::i128(p0);
+crate::character::streaming::i128(p0);
+crate::character::streaming::i128(p0);
-----------------
src/character/streaming.rs character::streaming::u8
deps:{"character::streaming::u8":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Slice","std::marker::Sized","traits::InputIter","traits::InputLength"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"character::streaming::u8":{"<T as traits::InputIter>::Item":[],"E":["error::VerboseError","error::Error"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::u8(p0);
+crate::character::streaming::u8(p0);
+crate::character::streaming::u8(p0);
-----------------
src/character/streaming.rs character::streaming::u16
deps:{"character::streaming::u16":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputIter","std::marker::Sized","traits::Slice","traits::InputLength"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"character::streaming::u16":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","number::Endianness","internal::Err"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::u16(p0);
+crate::character::streaming::u16(p0);
+crate::character::streaming::u16(p0);
-----------------
src/character/streaming.rs character::streaming::u32
deps:{"character::streaming::u32":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputIter","traits::InputLength","std::marker::Sized","traits::Slice"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"character::streaming::u32":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::u32(p0);
+crate::character::streaming::u32(p0);
+crate::character::streaming::u32(p0);
-----------------
src/character/streaming.rs character::streaming::u64
deps:{"<*mut T as std::fmt::Debug>":{},"character::streaming::u64":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::InputIter","std::marker::Sized","traits::InputLength","traits::Slice"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::streaming::u64":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","number::Endianness","error::ErrorKind","internal::Err","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::u64(p0);
+crate::character::streaming::u64(p0);
+crate::character::streaming::u64(p0);
-----------------
src/character/streaming.rs character::streaming::u128
deps:{"<*mut T as std::fmt::Debug>":{},"character::streaming::u128":{"<T as traits::InputIter>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputLength","traits::Slice","std::marker::Sized","traits::InputIter"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"character::streaming::u128":{"<T as traits::InputIter>::Item":[],"E":["error::Error","error::VerboseError"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+character::streaming::u128(p0);
+crate::character::streaming::u128(p0);
+crate::character::streaming::u128(p0);
-----------------
src/character/mod.rs character::is_alphabetic
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_alphabetic(p0);
+crate::character::is_alphabetic(p0);
+crate::character::is_alphabetic(p0);
-----------------
src/character/mod.rs character::is_digit
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_digit(p0);
+crate::character::is_digit(p0);
+crate::character::is_digit(p0);
-----------------
src/character/mod.rs character::is_hex_digit
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_hex_digit(p0);
+crate::character::is_hex_digit(p0);
+crate::character::is_hex_digit(p0);
-----------------
src/character/mod.rs character::is_oct_digit
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_oct_digit(p0);
+crate::character::is_oct_digit(p0);
+crate::character::is_oct_digit(p0);
-----------------
src/character/mod.rs character::is_alphanumeric
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_alphanumeric(p0);
+crate::character::is_alphanumeric(p0);
+crate::character::is_alphanumeric(p0);
-----------------
src/character/mod.rs character::is_space
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_space(p0);
+crate::character::is_space(p0);
+crate::character::is_space(p0);
-----------------
src/character/mod.rs character::is_newline
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+character::is_newline(p0);
+crate::character::is_newline(p0);
+crate::character::is_newline(p0);
-----------------
src/number/complete.rs number::complete::be_u8
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"number::complete::be_u8":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","traits::Slice","traits::InputIter","std::marker::Sized"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","<*mut T as std::fmt::Debug>","number::Endianness","internal::Needed"]},"number::complete::be_u8":{"E":["error::Error","error::VerboseError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_u8(p0);
+crate::number::complete::be_u8(p0);
+crate::number::complete::be_u8(p0);
-----------------
src/number/complete.rs number::complete::be_u16
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"number::complete::be_u16":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputIter","traits::InputLength","std::marker::Sized","traits::Slice"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err"]},"number::complete::be_u16":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_u16(p0);
+crate::number::complete::be_u16(p0);
+crate::number::complete::be_u16(p0);
-----------------
src/number/complete.rs number::complete::be_u24
deps:{"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"number::complete::be_u24":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","traits::InputLength","std::marker::Sized","traits::InputIter"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness","error::ErrorKind"]},"number::complete::be_u24":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_u24(p0);
+crate::number::complete::be_u24(p0);
+crate::number::complete::be_u24(p0);
-----------------
src/number/complete.rs number::complete::be_u32
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::complete::be_u32":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::InputIter","traits::Slice","traits::InputLength"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","internal::Needed","number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"number::complete::be_u32":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_u32(p0);
+crate::number::complete::be_u32(p0);
+crate::number::complete::be_u32(p0);
-----------------
src/number/complete.rs number::complete::be_u64
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"number::complete::be_u64":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::InputIter","traits::Slice","traits::InputLength"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","internal::Needed","error::ErrorKind","number::Endianness"]},"number::complete::be_u64":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_u64(p0);
+crate::number::complete::be_u64(p0);
+crate::number::complete::be_u64(p0);
-----------------
src/number/complete.rs number::complete::be_u128
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"number::complete::be_u128":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputIter","traits::InputLength","std::marker::Sized","traits::Slice"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","number::Endianness","internal::Needed","error::ErrorKind","internal::Err"]},"number::complete::be_u128":{"E":["error::Error","error::VerboseError"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_u128(p0);
+crate::number::complete::be_u128(p0);
+crate::number::complete::be_u128(p0);
-----------------
src/number/complete.rs number::complete::be_i8
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"number::complete::be_i8":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Slice","traits::InputIter","traits::InputLength"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind"]},"number::complete::be_i8":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_i8(p0);
+crate::number::complete::be_i8(p0);
+crate::number::complete::be_i8(p0);
-----------------
src/number/complete.rs number::complete::be_i16
deps:{"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::complete::be_i16":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","traits::InputLength","std::marker::Sized","traits::InputIter"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","number::Endianness"]},"number::complete::be_i16":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_i16(p0);
+crate::number::complete::be_i16(p0);
+crate::number::complete::be_i16(p0);
-----------------
src/number/complete.rs number::complete::be_i24
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"number::complete::be_i24":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","traits::InputLength","std::marker::Sized","traits::InputIter"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Needed","<*mut T as std::fmt::Debug>","internal::Err"]},"number::complete::be_i24":{"E":["error::Error","error::VerboseError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_i24(p0);
+crate::number::complete::be_i24(p0);
+crate::number::complete::be_i24(p0);
-----------------
src/number/complete.rs number::complete::be_i32
deps:{"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"number::complete::be_i32":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::InputLength","traits::Slice","traits::InputIter"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","internal::Err","number::Endianness"]},"number::complete::be_i32":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_i32(p0);
+crate::number::complete::be_i32(p0);
+crate::number::complete::be_i32(p0);
-----------------
src/number/complete.rs number::complete::be_i64
deps:{"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"number::complete::be_i64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputIter","std::marker::Sized","traits::InputLength","traits::Slice"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness"]},"number::complete::be_i64":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_i64(p0);
+crate::number::complete::be_i64(p0);
+crate::number::complete::be_i64(p0);
-----------------
src/number/complete.rs number::complete::be_i128
deps:{"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"number::complete::be_i128":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Slice","traits::InputIter","traits::InputLength"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","number::Endianness","internal::Err"]},"number::complete::be_i128":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_i128(p0);
+crate::number::complete::be_i128(p0);
+crate::number::complete::be_i128(p0);
-----------------
src/number/complete.rs number::complete::le_u8
deps:{"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"number::complete::le_u8":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputLength","traits::Slice","traits::InputIter","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness","internal::Err"]},"number::complete::le_u8":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_u8(p0);
+crate::number::complete::le_u8(p0);
+crate::number::complete::le_u8(p0);
-----------------
src/number/complete.rs number::complete::le_u16
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"number::complete::le_u16":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputIter","std::marker::Sized","traits::Slice","traits::InputLength"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","internal::Needed","error::ErrorKind","number::Endianness","internal::Err"]},"number::complete::le_u16":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_u16(p0);
+crate::number::complete::le_u16(p0);
+crate::number::complete::le_u16(p0);
-----------------
src/number/complete.rs number::complete::le_u24
deps:{"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"number::complete::le_u24":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","std::marker::Sized","traits::Slice","traits::InputIter"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","internal::Needed"]},"number::complete::le_u24":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_u24(p0);
+crate::number::complete::le_u24(p0);
+crate::number::complete::le_u24(p0);
-----------------
src/number/complete.rs number::complete::le_u32
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"number::complete::le_u32":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Slice","traits::InputIter","traits::InputLength"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","internal::Err","number::Endianness","internal::Needed"]},"number::complete::le_u32":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_u32(p0);
+crate::number::complete::le_u32(p0);
+crate::number::complete::le_u32(p0);
-----------------
src/number/complete.rs number::complete::le_u64
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"number::complete::le_u64":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::InputLength","traits::Slice","traits::InputIter"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","<*mut T as std::fmt::Debug>","internal::Needed","internal::Err"]},"number::complete::le_u64":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_u64(p0);
+crate::number::complete::le_u64(p0);
+crate::number::complete::le_u64(p0);
-----------------
src/number/complete.rs number::complete::le_u128
deps:{"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"number::complete::le_u128":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","std::marker::Sized","traits::Slice","traits::InputIter"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed"]},"number::complete::le_u128":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_u128(p0);
+crate::number::complete::le_u128(p0);
+crate::number::complete::le_u128(p0);
-----------------
src/number/complete.rs number::complete::le_i8
deps:{"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"number::complete::le_i8":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Slice","traits::InputIter","traits::InputLength"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","internal::Needed","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"number::complete::le_i8":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_i8(p0);
+crate::number::complete::le_i8(p0);
+crate::number::complete::le_i8(p0);
-----------------
src/number/complete.rs number::complete::le_i16
deps:{"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"number::complete::le_i16":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::InputIter","traits::InputLength","traits::Slice"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err"]},"number::complete::le_i16":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_i16(p0);
+crate::number::complete::le_i16(p0);
+crate::number::complete::le_i16(p0);
-----------------
src/number/complete.rs number::complete::le_i24
deps:{"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"number::complete::le_i24":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputLength","traits::InputIter","traits::Slice","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err","internal::Needed","number::Endianness","error::ErrorKind"]},"number::complete::le_i24":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_i24(p0);
+crate::number::complete::le_i24(p0);
+crate::number::complete::le_i24(p0);
-----------------
src/number/complete.rs number::complete::le_i32
deps:{"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::complete::le_i32":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputIter","traits::InputLength","std::marker::Sized","traits::Slice"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","error::ErrorKind"]},"number::complete::le_i32":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_i32(p0);
+crate::number::complete::le_i32(p0);
+crate::number::complete::le_i32(p0);
-----------------
src/number/complete.rs number::complete::le_i64
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"number::complete::le_i64":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::InputIter","traits::Slice","traits::InputLength"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","<*const T as std::fmt::Debug>","internal::Err","internal::Needed"]},"number::complete::le_i64":{"E":["error::VerboseError","error::Error"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_i64(p0);
+crate::number::complete::le_i64(p0);
+crate::number::complete::le_i64(p0);
-----------------
src/number/complete.rs number::complete::le_i128
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"number::complete::le_i128":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputIter","traits::InputLength","std::marker::Sized","traits::Slice"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","internal::Err","<*const T as std::fmt::Debug>","error::ErrorKind","number::Endianness"]},"number::complete::le_i128":{"E":["error::VerboseError","error::Error"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_i128(p0);
+crate::number::complete::le_i128(p0);
+crate::number::complete::le_i128(p0);
-----------------
src/number/complete.rs number::complete::u8
deps:{"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"number::complete::u8":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","traits::InputIter","traits::InputLength","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","number::Endianness","error::ErrorKind","internal::Err"]},"number::complete::u8":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::u8(p0);
+crate::number::complete::u8(p0);
+crate::number::complete::u8(p0);
-----------------
src/number/complete.rs number::complete::u16
deps:{"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"number::complete::u16":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","std::marker::Sized","traits::InputLength","traits::InputIter"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","internal::Err","error::ErrorKind","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"number::complete::u16":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::u16(p0);
+crate::number::complete::u16(p0);
+crate::number::complete::u16(p0);
-----------------
src/number/complete.rs number::complete::u24
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"number::complete::u24":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","std::marker::Sized","traits::InputIter","traits::InputLength"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","internal::Err","internal::Needed","number::Endianness"]},"number::complete::u24":{"E":["error::VerboseError","error::Error"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::u24(p0);
+crate::number::complete::u24(p0);
+crate::number::complete::u24(p0);
-----------------
src/number/complete.rs number::complete::u32
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"number::complete::u32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","std::marker::Sized","traits::InputIter","traits::Slice"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Needed","<*mut T as std::fmt::Debug>","internal::Err"]},"number::complete::u32":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::u32(p0);
+crate::number::complete::u32(p0);
+crate::number::complete::u32(p0);
-----------------
src/number/complete.rs number::complete::u64
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"number::complete::u64":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::InputLength","traits::Slice","traits::InputIter"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","number::Endianness","internal::Err","error::ErrorKind","internal::Needed"]},"number::complete::u64":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::u64(p0);
+crate::number::complete::u64(p0);
+crate::number::complete::u64(p0);
-----------------
src/number/complete.rs number::complete::u128
deps:{"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"number::complete::u128":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::InputIter","traits::InputLength","traits::Slice"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err","error::ErrorKind","number::Endianness"]},"number::complete::u128":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::u128(p0);
+crate::number::complete::u128(p0);
+crate::number::complete::u128(p0);
-----------------
src/number/complete.rs number::complete::i8
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"number::complete::i8":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","traits::InputIter","std::marker::Sized","traits::Slice"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed","number::Endianness","error::ErrorKind","internal::Err"]},"number::complete::i8":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::i8(p0);
+crate::number::complete::i8(p0);
+crate::number::complete::i8(p0);
-----------------
src/number/complete.rs number::complete::i16
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"number::complete::i16":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","std::marker::Sized","traits::InputIter","traits::Slice"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","<*mut T as std::fmt::Debug>","internal::Err","error::ErrorKind","number::Endianness"]},"number::complete::i16":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::i16(p0);
+crate::number::complete::i16(p0);
+crate::number::complete::i16(p0);
-----------------
src/number/complete.rs number::complete::i24
deps:{"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"number::complete::i24":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputIter","traits::Slice","std::marker::Sized","traits::InputLength"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","number::Endianness"]},"number::complete::i24":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::i24(p0);
+crate::number::complete::i24(p0);
+crate::number::complete::i24(p0);
-----------------
src/number/complete.rs number::complete::i32
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::complete::i32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","traits::InputLength","std::marker::Sized","traits::InputIter"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness","error::ErrorKind"]},"number::complete::i32":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::i32(p0);
+crate::number::complete::i32(p0);
+crate::number::complete::i32(p0);
-----------------
src/number/complete.rs number::complete::i64
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"number::complete::i64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","traits::InputIter","traits::Slice","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","number::Endianness","internal::Needed","error::ErrorKind","internal::Err"]},"number::complete::i64":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::i64(p0);
+crate::number::complete::i64(p0);
+crate::number::complete::i64(p0);
-----------------
src/number/complete.rs number::complete::i128
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"number::complete::i128":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","traits::InputIter","traits::InputLength","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","number::Endianness","error::ErrorKind","internal::Needed","internal::Err"]},"number::complete::i128":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::i128(p0);
+crate::number::complete::i128(p0);
+crate::number::complete::i128(p0);
-----------------
src/number/complete.rs number::complete::be_f32
deps:{"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"number::complete::be_f32":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::InputIter","traits::Slice","traits::InputLength"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","error::ErrorKind","internal::Needed"]},"number::complete::be_f32":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_f32(p0);
+crate::number::complete::be_f32(p0);
+crate::number::complete::be_f32(p0);
-----------------
src/number/complete.rs number::complete::be_f64
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"number::complete::be_f64":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","std::marker::Sized","traits::InputIter","traits::InputLength"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::ErrorKind","number::Endianness"]},"number::complete::be_f64":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::be_f64(p0);
+crate::number::complete::be_f64(p0);
+crate::number::complete::be_f64(p0);
-----------------
src/number/complete.rs number::complete::le_f32
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"number::complete::le_f32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","traits::Slice","traits::InputIter","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","internal::Err","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed"]},"number::complete::le_f32":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_f32(p0);
+crate::number::complete::le_f32(p0);
+crate::number::complete::le_f32(p0);
-----------------
src/number/complete.rs number::complete::le_f64
deps:{"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"number::complete::le_f64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputIter","std::marker::Sized","traits::InputLength","traits::Slice"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","internal::Needed","number::Endianness","internal::Err"]},"number::complete::le_f64":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::complete::le_f64(p0);
+crate::number::complete::le_f64(p0);
+crate::number::complete::le_f64(p0);
-----------------
src/number/complete.rs number::complete::f32
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"number::complete::f32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputIter","std::marker::Sized","traits::InputLength","traits::Slice"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err"]},"number::complete::f32":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::f32(p0);
+crate::number::complete::f32(p0);
+crate::number::complete::f32(p0);
-----------------
src/number/complete.rs number::complete::f64
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::complete::f64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","traits::InputIter","std::marker::Sized","traits::InputLength"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err","error::ErrorKind","internal::Needed","number::Endianness"]},"number::complete::f64":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::complete::f64(p0);
+crate::number::complete::f64(p0);
+crate::number::complete::f64(p0);
-----------------
src/number/complete.rs number::complete::hex_u32
'a
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"number::complete::hex_u32":{"E":["error::ParseError","std::marker::Sized"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","internal::Needed","number::Endianness","internal::Err","error::ErrorKind"]},"number::complete::hex_u32":{"E":["error::VerboseError","error::Error"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+number::complete::hex_u32(p0);
+crate::number::complete::hex_u32(p0);
+crate::number::complete::hex_u32(p0);
-----------------
src/number/complete.rs number::complete::recognize_float
deps:{"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"number::complete::recognize_float":{"<T as traits::InputIter>::Item":["traits::AsChar"],"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputTakeAtPosition","std::marker::Sized","traits::Offset","traits::Slice","traits::InputIter","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>"]},"number::complete::recognize_float":{"<T as traits::InputIter>::Item":[],"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::complete::recognize_float(p0);
+crate::number::complete::recognize_float(p0);
+crate::number::complete::recognize_float(p0);
-----------------
src/number/complete.rs number::complete::recognize_float_or_exceptions
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"number::complete::recognize_float_or_exceptions":{"<T as traits::InputIter>::Item":["traits::AsChar"],"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::clone::Clone","traits::InputTake","traits::InputIter","std::marker::Sized","traits::Offset","traits::Slice","traits::Compare","traits::InputTakeAtPosition"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","internal::Err","error::ErrorKind","internal::Needed"]},"number::complete::recognize_float_or_exceptions":{"<T as traits::InputIter>::Item":[],"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::complete::recognize_float_or_exceptions(p0);
+crate::number::complete::recognize_float_or_exceptions(p0);
+crate::number::complete::recognize_float_or_exceptions(p0);
-----------------
src/number/complete.rs number::complete::recognize_float_parts
deps:{"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"number::complete::recognize_float_parts":{"<T as traits::InputIter>::Item":["std::marker::Copy","traits::AsChar"],"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["std::clone::Clone","traits::Offset","traits::InputLength","traits::AsBytes","traits::Compare","traits::InputTakeAtPosition","std::marker::Sized","traits::Slice","traits::InputIter","traits::InputTake"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"number::complete::recognize_float_parts":{"<T as traits::InputIter>::Item":[],"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::complete::recognize_float_parts(p0);
+crate::number::complete::recognize_float_parts(p0);
+crate::number::complete::recognize_float_parts(p0);
-----------------
src/number/complete.rs number::complete::float
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"number::complete::float":{"<T as traits::InputIter>::Item":["std::marker::Copy","traits::AsChar"],"<T as traits::InputIter>::IterElem":["std::clone::Clone"],"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputIter","traits::AsBytes","traits::Compare","traits::Slice","std::marker::Sized","traits::ParseTo","traits::InputLength","traits::InputTake","traits::InputTakeAtPosition","traits::Offset","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","internal::Needed","<*mut T as std::fmt::Debug>","number::Endianness"]},"number::complete::float":{"<T as traits::InputIter>::Item":[],"<T as traits::InputIter>::IterElem":["internal::Needed","error::VerboseError","error::ErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","internal::Err"],"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::complete::float(p0);
+crate::number::complete::float(p0);
+crate::number::complete::float(p0);
-----------------
src/number/complete.rs number::complete::double
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"number::complete::double":{"<T as traits::InputIter>::Item":["traits::AsChar","std::marker::Copy"],"<T as traits::InputIter>::IterElem":["std::clone::Clone"],"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["std::marker::Sized","traits::InputLength","traits::Compare","traits::InputTake","traits::InputTakeAtPosition","traits::ParseTo","traits::Slice","std::clone::Clone","traits::InputIter","traits::AsBytes","traits::Offset"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::ErrorKind","internal::Needed","internal::Err","number::Endianness"]},"number::complete::double":{"<T as traits::InputIter>::Item":[],"<T as traits::InputIter>::IterElem":["internal::Err","internal::Needed","number::Endianness","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseErrorKind","error::ErrorKind"],"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::complete::double(p0);
+crate::number::complete::double(p0);
+crate::number::complete::double(p0);
-----------------
src/number/streaming.rs number::streaming::be_u8
deps:{"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"number::streaming::be_u8":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputLength","std::marker::Sized","traits::Slice","traits::InputIter"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind"]},"number::streaming::be_u8":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_u8(p0);
+crate::number::streaming::be_u8(p0);
+crate::number::streaming::be_u8(p0);
-----------------
src/number/streaming.rs number::streaming::be_u16
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"number::streaming::be_u16":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputLength","traits::InputIter","std::marker::Sized","traits::Slice"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","<*mut T as std::fmt::Debug>","internal::Needed","internal::Err","number::Endianness"]},"number::streaming::be_u16":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_u16(p0);
+crate::number::streaming::be_u16(p0);
+crate::number::streaming::be_u16(p0);
-----------------
src/number/streaming.rs number::streaming::be_u24
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]},"number::streaming::be_u24":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Slice","traits::InputIter","traits::InputLength"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","number::Endianness","internal::Err","internal::Needed","error::ErrorKind"]},"number::streaming::be_u24":{"E":["error::Error","error::VerboseError"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_u24(p0);
+crate::number::streaming::be_u24(p0);
+crate::number::streaming::be_u24(p0);
-----------------
src/number/streaming.rs number::streaming::be_u32
deps:{"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"number::streaming::be_u32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","std::marker::Sized","traits::InputIter","traits::Slice"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed"]},"number::streaming::be_u32":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_u32(p0);
+crate::number::streaming::be_u32(p0);
+crate::number::streaming::be_u32(p0);
-----------------
src/number/streaming.rs number::streaming::be_u64
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"number::streaming::be_u64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","traits::InputIter","traits::Slice","std::marker::Sized"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","<*mut T as std::fmt::Debug>","internal::Needed","error::ErrorKind","number::Endianness"]},"number::streaming::be_u64":{"E":["error::VerboseError","error::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_u64(p0);
+crate::number::streaming::be_u64(p0);
+crate::number::streaming::be_u64(p0);
-----------------
src/number/streaming.rs number::streaming::be_u128
deps:{"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"number::streaming::be_u128":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::Slice","traits::InputIter","traits::InputLength"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed"]},"number::streaming::be_u128":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_u128(p0);
+crate::number::streaming::be_u128(p0);
+crate::number::streaming::be_u128(p0);
-----------------
src/number/streaming.rs number::streaming::be_i8
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"number::streaming::be_i8":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::InputLength","traits::InputIter","traits::Slice"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","number::Endianness","internal::Err","<*mut T as std::fmt::Debug>"]},"number::streaming::be_i8":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_i8(p0);
+crate::number::streaming::be_i8(p0);
+crate::number::streaming::be_i8(p0);
-----------------
src/number/streaming.rs number::streaming::be_i16
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"number::streaming::be_i16":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputIter","traits::InputLength","traits::Slice","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","internal::Needed"]},"number::streaming::be_i16":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_i16(p0);
+crate::number::streaming::be_i16(p0);
+crate::number::streaming::be_i16(p0);
-----------------
src/number/streaming.rs number::streaming::be_i24
deps:{"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq"]},"number::streaming::be_i24":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::Slice","traits::InputLength","traits::InputIter"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness","internal::Err"]},"number::streaming::be_i24":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_i24(p0);
+crate::number::streaming::be_i24(p0);
+crate::number::streaming::be_i24(p0);
-----------------
src/number/streaming.rs number::streaming::be_i32
deps:{"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"number::streaming::be_i32":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputIter","traits::Slice","std::marker::Sized","traits::InputLength"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind"]},"number::streaming::be_i32":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_i32(p0);
+crate::number::streaming::be_i32(p0);
+crate::number::streaming::be_i32(p0);
-----------------
src/number/streaming.rs number::streaming::be_i64
deps:{"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"number::streaming::be_i64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","std::marker::Sized","traits::InputIter","traits::Slice"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","internal::Err"]},"number::streaming::be_i64":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_i64(p0);
+crate::number::streaming::be_i64(p0);
+crate::number::streaming::be_i64(p0);
-----------------
src/number/streaming.rs number::streaming::be_i128
deps:{"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"number::streaming::be_i128":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","std::marker::Sized","traits::InputLength","traits::InputIter"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","internal::Err"]},"number::streaming::be_i128":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_i128(p0);
+crate::number::streaming::be_i128(p0);
+crate::number::streaming::be_i128(p0);
-----------------
src/number/streaming.rs number::streaming::le_u8
deps:{"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"number::streaming::le_u8":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::InputIter","traits::Slice","traits::InputLength"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","internal::Needed","internal::Err","error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>"]},"number::streaming::le_u8":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_u8(p0);
+crate::number::streaming::le_u8(p0);
+crate::number::streaming::le_u8(p0);
-----------------
src/number/streaming.rs number::streaming::le_u16
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"number::streaming::le_u16":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputLength","std::marker::Sized","traits::Slice","traits::InputIter"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err"]},"number::streaming::le_u16":{"E":["error::VerboseError","error::Error"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_u16(p0);
+crate::number::streaming::le_u16(p0);
+crate::number::streaming::le_u16(p0);
-----------------
src/number/streaming.rs number::streaming::le_u24
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"number::streaming::le_u24":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","std::marker::Sized","traits::InputIter","traits::InputLength"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed"]},"number::streaming::le_u24":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_u24(p0);
+crate::number::streaming::le_u24(p0);
+crate::number::streaming::le_u24(p0);
-----------------
src/number/streaming.rs number::streaming::le_u32
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"number::streaming::le_u32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputIter","std::marker::Sized","traits::Slice","traits::InputLength"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","internal::Err","number::Endianness","<*mut T as std::fmt::Debug>"]},"number::streaming::le_u32":{"E":["error::VerboseError","error::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_u32(p0);
+crate::number::streaming::le_u32(p0);
+crate::number::streaming::le_u32(p0);
-----------------
src/number/streaming.rs number::streaming::le_u64
deps:{"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"number::streaming::le_u64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","traits::InputLength","traits::InputIter","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","number::Endianness","internal::Needed","error::ErrorKind"]},"number::streaming::le_u64":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_u64(p0);
+crate::number::streaming::le_u64(p0);
+crate::number::streaming::le_u64(p0);
-----------------
src/number/streaming.rs number::streaming::le_u128
deps:{"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"number::streaming::le_u128":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputLength","traits::InputIter","std::marker::Sized","traits::Slice"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed","number::Endianness"]},"number::streaming::le_u128":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_u128(p0);
+crate::number::streaming::le_u128(p0);
+crate::number::streaming::le_u128(p0);
-----------------
src/number/streaming.rs number::streaming::le_i8
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug"]},"number::streaming::le_i8":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","std::marker::Sized","traits::InputLength","traits::InputIter"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","<*mut T as std::fmt::Debug>","internal::Needed","internal::Err","number::Endianness"]},"number::streaming::le_i8":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_i8(p0);
+crate::number::streaming::le_i8(p0);
+crate::number::streaming::le_i8(p0);
-----------------
src/number/streaming.rs number::streaming::le_i16
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"number::streaming::le_i16":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","traits::InputIter","std::marker::Sized","traits::InputLength"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","internal::Err","number::Endianness","<*const T as std::fmt::Debug>"]},"number::streaming::le_i16":{"E":["error::Error","error::VerboseError"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_i16(p0);
+crate::number::streaming::le_i16(p0);
+crate::number::streaming::le_i16(p0);
-----------------
src/number/streaming.rs number::streaming::le_i24
deps:{"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"number::streaming::le_i24":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","std::marker::Sized","traits::InputIter","traits::InputLength"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness","internal::Err","error::ErrorKind","internal::Needed"]},"number::streaming::le_i24":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_i24(p0);
+crate::number::streaming::le_i24(p0);
+crate::number::streaming::le_i24(p0);
-----------------
src/number/streaming.rs number::streaming::le_i32
deps:{"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"number::streaming::le_i32":{"E":["error::ParseError","std::marker::Sized"],"I":["std::marker::Sized","traits::InputLength","traits::Slice","traits::InputIter"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","number::Endianness"]},"number::streaming::le_i32":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_i32(p0);
+crate::number::streaming::le_i32(p0);
+crate::number::streaming::le_i32(p0);
-----------------
src/number/streaming.rs number::streaming::le_i64
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"number::streaming::le_i64":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputLength","std::marker::Sized","traits::Slice","traits::InputIter"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","number::Endianness","internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"number::streaming::le_i64":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_i64(p0);
+crate::number::streaming::le_i64(p0);
+crate::number::streaming::le_i64(p0);
-----------------
src/number/streaming.rs number::streaming::le_i128
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"number::streaming::le_i128":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::InputLength","traits::InputIter","traits::Slice"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","internal::Needed","error::ErrorKind","number::Endianness","internal::Err"]},"number::streaming::le_i128":{"E":["error::VerboseError","error::Error"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_i128(p0);
+crate::number::streaming::le_i128(p0);
+crate::number::streaming::le_i128(p0);
-----------------
src/number/streaming.rs number::streaming::u8
deps:{"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"number::streaming::u8":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","std::marker::Sized","traits::InputLength","traits::InputIter"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::ErrorKind"]},"number::streaming::u8":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::u8(p0);
+crate::number::streaming::u8(p0);
+crate::number::streaming::u8(p0);
-----------------
src/number/streaming.rs number::streaming::u16
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::u16":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputLength","traits::InputIter","std::marker::Sized","traits::Slice"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness","internal::Err","internal::Needed","error::ErrorKind"]},"number::streaming::u16":{"E":["error::Error","error::VerboseError"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::u16(p0);
+crate::number::streaming::u16(p0);
+crate::number::streaming::u16(p0);
-----------------
src/number/streaming.rs number::streaming::u24
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"number::streaming::u24":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","traits::InputIter","traits::Slice","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::ErrorKind","number::Endianness"]},"number::streaming::u24":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::u24(p0);
+crate::number::streaming::u24(p0);
+crate::number::streaming::u24(p0);
-----------------
src/number/streaming.rs number::streaming::u32
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::u32":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::InputLength","traits::Slice","traits::InputIter"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness","internal::Needed","internal::Err"]},"number::streaming::u32":{"E":["error::Error","error::VerboseError"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::u32(p0);
+crate::number::streaming::u32(p0);
+crate::number::streaming::u32(p0);
-----------------
src/number/streaming.rs number::streaming::u64
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"number::streaming::u64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","traits::InputIter","traits::InputLength","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","internal::Needed","number::Endianness"]},"number::streaming::u64":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::u64(p0);
+crate::number::streaming::u64(p0);
+crate::number::streaming::u64(p0);
-----------------
src/number/streaming.rs number::streaming::u128
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"number::streaming::u128":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","traits::InputIter","traits::Slice","std::marker::Sized"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","number::Endianness","<*mut T as std::fmt::Debug>","internal::Err"]},"number::streaming::u128":{"E":["error::VerboseError","error::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::u128(p0);
+crate::number::streaming::u128(p0);
+crate::number::streaming::u128(p0);
-----------------
src/number/streaming.rs number::streaming::i8
deps:{"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"number::streaming::i8":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputIter","traits::Slice","traits::InputLength","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err"]},"number::streaming::i8":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::i8(p0);
+crate::number::streaming::i8(p0);
+crate::number::streaming::i8(p0);
-----------------
src/number/streaming.rs number::streaming::i16
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"number::streaming::i16":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","traits::InputLength","traits::InputIter","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","internal::Needed","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness"]},"number::streaming::i16":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::i16(p0);
+crate::number::streaming::i16(p0);
+crate::number::streaming::i16(p0);
-----------------
src/number/streaming.rs number::streaming::i24
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::i24":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","std::marker::Sized","traits::InputIter","traits::InputLength"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","internal::Needed","number::Endianness"]},"number::streaming::i24":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::i24(p0);
+crate::number::streaming::i24(p0);
+crate::number::streaming::i24(p0);
-----------------
src/number/streaming.rs number::streaming::i32
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq"]},"number::streaming::i32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputIter","traits::InputLength","std::marker::Sized","traits::Slice"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Needed","internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>"]},"number::streaming::i32":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::i32(p0);
+crate::number::streaming::i32(p0);
+crate::number::streaming::i32(p0);
-----------------
src/number/streaming.rs number::streaming::i64
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"number::streaming::i64":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::InputLength","traits::Slice","traits::InputIter"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","number::Endianness","internal::Needed","internal::Err"]},"number::streaming::i64":{"E":["error::Error","error::VerboseError"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::i64(p0);
+crate::number::streaming::i64(p0);
+crate::number::streaming::i64(p0);
-----------------
src/number/streaming.rs number::streaming::i128
deps:{"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::i128":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputLength","traits::Slice","traits::InputIter","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","internal::Needed","error::ErrorKind","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>"]},"number::streaming::i128":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::i128(p0);
+crate::number::streaming::i128(p0);
+crate::number::streaming::i128(p0);
-----------------
src/number/streaming.rs number::streaming::be_f32
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"number::streaming::be_f32":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized","traits::InputLength","traits::Slice","traits::InputIter"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","number::Endianness","internal::Needed","internal::Err"]},"number::streaming::be_f32":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_f32(p0);
+crate::number::streaming::be_f32(p0);
+crate::number::streaming::be_f32(p0);
-----------------
src/number/streaming.rs number::streaming::be_f64
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::be_f64":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputIter","traits::Slice","std::marker::Sized","traits::InputLength"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","internal::Err","error::ErrorKind","<*mut T as std::fmt::Debug>","number::Endianness"]},"number::streaming::be_f64":{"E":["error::Error","error::VerboseError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::be_f64(p0);
+crate::number::streaming::be_f64(p0);
+crate::number::streaming::be_f64(p0);
-----------------
src/number/streaming.rs number::streaming::le_f32
deps:{"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq"]},"number::streaming::le_f32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::Slice","std::marker::Sized","traits::InputIter","traits::InputLength"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","internal::Err","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>"]},"number::streaming::le_f32":{"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_f32(p0);
+crate::number::streaming::le_f32(p0);
+crate::number::streaming::le_f32(p0);
-----------------
src/number/streaming.rs number::streaming::le_f64
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"number::streaming::le_f64":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::Slice","std::marker::Sized","traits::InputLength","traits::InputIter"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::ErrorKind","number::Endianness","internal::Err","internal::Needed"]},"number::streaming::le_f64":{"E":["error::Error","error::VerboseError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+number::streaming::le_f64(p0);
+crate::number::streaming::le_f64(p0);
+crate::number::streaming::le_f64(p0);
-----------------
src/number/streaming.rs number::streaming::f32
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::f32":{"E":["std::marker::Sized","error::ParseError"],"I":["traits::InputLength","traits::Slice","traits::InputIter","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","number::Endianness","error::ErrorKind","internal::Err","<*mut T as std::fmt::Debug>"]},"number::streaming::f32":{"E":["error::Error","error::VerboseError"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::f32(p0);
+crate::number::streaming::f32(p0);
+crate::number::streaming::f32(p0);
-----------------
src/number/streaming.rs number::streaming::f64
deps:{"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"number::streaming::f64":{"E":["error::ParseError","std::marker::Sized"],"I":["traits::InputIter","std::marker::Sized","traits::InputLength","traits::Slice"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed"]},"number::streaming::f64":{"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Endianness
+number::streaming::f64(p0);
+crate::number::streaming::f64(p0);
+crate::number::streaming::f64(p0);
-----------------
src/number/streaming.rs number::streaming::hex_u32
'a
deps:{"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"number::streaming::hex_u32":{"E":["std::marker::Sized","error::ParseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","internal::Err","error::ErrorKind"]},"number::streaming::hex_u32":{"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+number::streaming::hex_u32(p0);
+crate::number::streaming::hex_u32(p0);
+crate::number::streaming::hex_u32(p0);
-----------------
src/number/streaming.rs number::streaming::recognize_float
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"number::streaming::recognize_float":{"<T as traits::InputIter>::Item":["traits::AsChar"],"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::Offset","traits::InputIter","traits::InputTakeAtPosition","traits::InputLength","traits::Slice","std::marker::Sized","std::clone::Clone"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Err","<*const T as std::fmt::Debug>","internal::Needed"]},"number::streaming::recognize_float":{"<T as traits::InputIter>::Item":[],"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::streaming::recognize_float(p0);
+crate::number::streaming::recognize_float(p0);
+crate::number::streaming::recognize_float(p0);
-----------------
src/number/streaming.rs number::streaming::recognize_float_or_exceptions
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::recognize_float_or_exceptions":{"<T as traits::InputIter>::Item":["traits::AsChar"],"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputTakeAtPosition","traits::InputIter","traits::Offset","std::marker::Sized","traits::Compare","traits::InputLength","traits::InputTake","traits::Slice","std::clone::Clone"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","internal::Needed","error::ErrorKind","number::Endianness","<*const T as std::fmt::Debug>"]},"number::streaming::recognize_float_or_exceptions":{"<T as traits::InputIter>::Item":[],"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::streaming::recognize_float_or_exceptions(p0);
+crate::number::streaming::recognize_float_or_exceptions(p0);
+crate::number::streaming::recognize_float_or_exceptions(p0);
-----------------
src/number/streaming.rs number::streaming::recognize_float_parts
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug"]},"number::streaming::recognize_float_parts":{"<T as traits::InputIter>::Item":["traits::AsChar"],"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::InputTakeAtPosition","std::marker::Sized","traits::InputLength","traits::AsBytes","traits::Compare","traits::Offset","traits::InputTake","traits::ParseTo","std::clone::Clone","traits::Slice","traits::InputIter"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","number::Endianness","error::ErrorKind","internal::Needed","internal::Err"]},"number::streaming::recognize_float_parts":{"<T as traits::InputIter>::Item":[],"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::streaming::recognize_float_parts(p0);
+crate::number::streaming::recognize_float_parts(p0);
+crate::number::streaming::recognize_float_parts(p0);
-----------------
src/number/streaming.rs number::streaming::float
deps:{"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"number::streaming::float":{"<T as traits::InputIter>::Item":["traits::AsChar"],"<T as traits::InputIter>::IterElem":["std::clone::Clone"],"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["std::marker::Sized","error::ParseError"],"T":["traits::Slice","traits::AsBytes","traits::Offset","traits::InputLength","std::clone::Clone","std::marker::Sized","traits::InputIter","traits::ParseTo","traits::InputTake","traits::Compare","traits::InputTakeAtPosition"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","error::ErrorKind","internal::Err","internal::Needed"]},"number::streaming::float":{"<T as traits::InputIter>::Item":[],"<T as traits::InputIter>::IterElem":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","error::ErrorKind","internal::Err","error::VerboseErrorKind","internal::Needed","number::Endianness"],"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::Error","error::VerboseError"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::streaming::float(p0);
+crate::number::streaming::float(p0);
+crate::number::streaming::float(p0);
-----------------
src/number/streaming.rs number::streaming::double
deps:{"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"number::streaming::double":{"<T as traits::InputIter>::Item":["traits::AsChar"],"<T as traits::InputIter>::IterElem":["std::clone::Clone"],"<T as traits::InputTakeAtPosition>::Item":["traits::AsChar"],"E":["error::ParseError","std::marker::Sized"],"T":["traits::InputIter","traits::AsBytes","traits::InputTake","traits::ParseTo","std::marker::Sized","traits::Slice","traits::Compare","std::clone::Clone","traits::Offset","traits::InputTakeAtPosition","traits::InputLength"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","internal::Needed","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err","error::ErrorKind"]},"number::streaming::double":{"<T as traits::InputIter>::Item":[],"<T as traits::InputIter>::IterElem":["std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","error::ErrorKind","error::VerboseErrorKind","internal::Err","number::Endianness","internal::Needed"],"<T as traits::InputTakeAtPosition>::Item":[],"E":["error::VerboseError","error::Error"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+number::streaming::double(p0);
+crate::number::streaming::double(p0);
+crate::number::streaming::double(p0);
-----------------
src/error.rs error::ParseError::from_error_kind
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::ParseError::from_error_kind":{"I":["std::marker::Sized"],"Self":["std::marker::Sized","error::ParseError"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::ParseError::from_error_kind":{"I":["RUG_ANY"],"Self":["error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","<*mut T as std::fmt::Debug>","error::ErrorKind","internal::Needed","number::Endianness"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+error::ParseError::from_error_kind(p0, p1);
+crate::error::ParseError::from_error_kind(p0, p1);
+crate::error::ParseError::from_error_kind(p0, p1);
-----------------
src/error.rs error::ParseError::append
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::ParseError::append":{"I":["std::marker::Sized"],"Self":["std::marker::Sized","error::ParseError"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::ParseError::append":{"I":["RUG_ANY"],"Self":["error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","number::Endianness","internal::Needed","<*mut T as std::fmt::Debug>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // Self
+error::ParseError::append(p0, p1, p2);
+crate::error::ParseError::append(p0, p1, p2);
+crate::error::ParseError::append(p0, p1, p2);
-----------------
src/error.rs error::ParseError::from_char
deps:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::ParseError::from_char":{"I":["std::marker::Sized"],"Self":["error::ParseError","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::ParseError::from_char":{"I":["RUG_ANY"],"Self":["error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","internal::Needed","<*const T as std::fmt::Debug>","number::Endianness"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = 'a'; // None+char
+error::ParseError::from_char(p0, p1);
+crate::error::ParseError::from_char(p0, p1);
+crate::error::ParseError::from_char(p0, p1);
-----------------
src/error.rs error::ParseError::or
deps:{"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::ParseError::or":{"I":["std::marker::Sized"],"Self":["error::ParseError","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::ParseError::or":{"I":["RUG_ANY"],"Self":["error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","internal::Err","internal::Needed","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // Self
+p0.or(p1);
+error::ParseError::or(p0, p1);
+crate::error::ParseError::or(p0, p1);
+crate::error::ParseError::or(p0, p1);
-----------------
src/error.rs error::ContextError::add_context
deps:{"<*mut T as std::fmt::Debug>":{},"error::ContextError::add_context":{"I":["std::marker::Sized"],"Self":["std::marker::Sized","error::ContextError"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::ContextError::add_context":{"I":["RUG_ANY"],"Self":["error::VerboseError","error::Error"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","internal::Needed","internal::Err","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // Self
+error::ContextError::add_context(p0, &p1, p2);
+crate::error::ContextError::add_context(p0, &p1, p2);
+crate::error::ContextError::add_context(p0, &p1, p2);
-----------------
src/error.rs error::FromExternalError::from_external_error
deps:{"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::FromExternalError::from_external_error":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"Self":["error::FromExternalError"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::FromExternalError::from_external_error":{"E":["RUG_ANY"],"I":["RUG_ANY"],"Self":["error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Needed","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+error::FromExternalError::from_external_error(p0, p1, p2);
+crate::error::FromExternalError::from_external_error(p0, p1, p2);
+crate::error::FromExternalError::from_external_error(p0, p1, p2);
-----------------
src/branch/mod.rs branch::Alt::choice
deps:{"branch::Alt::choice":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"Self":["branch::Alt"]}}
candidates:{"branch::Alt::choice":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"],"Self":[]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.choice(p1);
+branch::Alt::choice(p0, p1);
+crate::branch::Alt::choice(p0, p1);
+crate::branch::Alt::choice(p0, p1);
-----------------
src/branch/mod.rs branch::Permutation::permutation
deps:{"branch::Permutation::permutation":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"Self":["branch::Permutation"]}}
candidates:{"branch::Permutation::permutation":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"],"Self":[]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.permutation(p1);
+branch::Permutation::permutation(p0, p1);
+crate::branch::Permutation::permutation(p0, p1);
+crate::branch::Permutation::permutation(p0, p1);
-----------------
src/internal.rs internal::Finish::finish
deps:{"internal::Finish::finish":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"Self":["internal::Finish"]},"internal::IResult":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]}}
candidates:{"internal::Finish::finish":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"],"Self":["internal::IResult"]},"internal::IResult":{"E":["error::Error<I>","RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.finish();
+internal::Finish::finish(p0);
+crate::internal::Finish::finish(p0);
+crate::internal::Finish::finish(p0);
-----------------
src/internal.rs internal::Parser::parse
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Parser::parse":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"Self":["internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"internal::And":{"F":["std::boxed::Box","internal::FlatMap","internal::Into","internal::Map","internal::AndThen","internal::And","internal::Or","<F as internal::Parser<I, O, E>>"],"G":["<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::Into","internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen"]},"internal::AndThen":{"F":["internal::And","std::boxed::Box","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::FlatMap"],"G":["<F as internal::Parser<I, O, E>>","internal::And","internal::Or","std::boxed::Box","internal::Into","internal::FlatMap","internal::Map","internal::AndThen"],"O1":["RUG_ANY"]},"internal::FlatMap":{"F":["internal::Map","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::FlatMap","internal::And"],"G":["core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>","<T as std::convert::From<!>>"],"F":["internal::And","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::AndThen","internal::Map"],"G":["core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::Map","internal::Into","internal::FlatMap","internal::Or","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>"],"G":["internal::And","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Or","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>"]},"internal::Parser::parse":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"],"Self":["internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::And","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+internal::Parser::parse(p0, p1);
+crate::internal::Parser::parse(p0, p1);
+crate::internal::Parser::parse(p0, p1);
-----------------
src/internal.rs internal::Parser::map
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Parser::map":{"E":["std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"O2":["std::marker::Sized"],"Self":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"internal::And":{"F":["internal::AndThen","internal::Or","std::boxed::Box","internal::FlatMap","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into"],"G":["internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::FlatMap","internal::Or","internal::Into","std::boxed::Box"]},"internal::AndThen":{"F":["internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::Map","internal::AndThen","internal::FlatMap"],"G":["internal::AndThen","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Map","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::And","internal::Into"],"G":["core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::AndThen","internal::And","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And","internal::AndThen","internal::FlatMap","internal::Into"],"G":["core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Into","internal::Map","internal::AndThen","internal::And","internal::FlatMap"],"G":["<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::Or","internal::And","internal::Map","internal::AndThen","internal::FlatMap"]},"internal::Parser::map":{"E":["RUG_ANY"],"G":["core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte"],"I":["RUG_ANY"],"O":["RUG_ANY"],"O2":["RUG_ANY"],"Self":["<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::Or","std::boxed::Box","internal::And","internal::Into","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+p0.map(p1);
+internal::Parser::map(p0, p1);
+crate::internal::Parser::map(p0, p1);
+crate::internal::Parser::map(p0, p1);
-----------------
src/internal.rs internal::Parser::flat_map
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Parser::flat_map":{"E":["std::marker::Sized"],"G":["std::ops::FnMut","std::marker::Sized"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"O2":["std::marker::Sized"],"Self":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"internal::And":{"F":["internal::FlatMap","internal::Map","std::boxed::Box","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::Or"],"G":["internal::AndThen","internal::Or","internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::Or","std::boxed::Box","internal::Map","internal::AndThen","internal::FlatMap"],"G":["internal::Into","internal::And","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen"],"O1":["RUG_ANY"]},"internal::FlatMap":{"F":["internal::Into","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Map","std::boxed::Box"],"G":["core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::LinesAnyMap"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["std::boxed::Box","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::Map","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","internal::Into","internal::And"],"G":["core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::And","std::boxed::Box","internal::FlatMap","internal::Map","internal::Or"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","std::boxed::Box","internal::FlatMap","internal::Map","internal::Into","internal::Or"]},"internal::Parser::flat_map":{"E":["RUG_ANY"],"G":["core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::boxed::Box<F, A>"],"H":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Or","internal::Map","internal::And","internal::Into"],"I":["RUG_ANY"],"O":["RUG_ANY"],"O2":["RUG_ANY"],"Self":["internal::Into","internal::Or","internal::And","internal::FlatMap","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+p0.flat_map(p1);
+internal::Parser::flat_map(p0, p1);
+crate::internal::Parser::flat_map(p0, p1);
+crate::internal::Parser::flat_map(p0, p1);
-----------------
src/internal.rs internal::Parser::and_then
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Parser::and_then":{"E":["std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"O2":["std::marker::Sized"],"Self":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"internal::And":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Map","internal::Or","internal::And","internal::AndThen"],"G":["internal::Or","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen"]},"internal::AndThen":{"F":["internal::FlatMap","internal::Into","std::boxed::Box","internal::And","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map"],"G":["internal::AndThen","internal::And","internal::Into","internal::Or","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"]},"internal::FlatMap":{"F":["internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","std::boxed::Box","internal::And","internal::AndThen"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::Map","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Or","internal::Into","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::AndThen","internal::Or"],"G":["core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","internal::Or","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::FlatMap"],"G":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen"]},"internal::Parser::and_then":{"E":["RUG_ANY"],"G":["internal::AndThen","internal::Or","internal::Map","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box"],"I":["RUG_ANY"],"O":["RUG_ANY"],"O2":["RUG_ANY"],"Self":["internal::Into","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Or","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+p0.and_then(p1);
+internal::Parser::and_then(p0, p1);
+crate::internal::Parser::and_then(p0, p1);
+crate::internal::Parser::and_then(p0, p1);
-----------------
src/internal.rs internal::Parser::and
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::Parser::and":{"E":["std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"O2":["std::marker::Sized"],"Self":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::FlatMap","internal::Or","internal::AndThen","std::boxed::Box","internal::And"],"G":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Map","internal::Or","internal::FlatMap","internal::Into","internal::AndThen"]},"internal::AndThen":{"F":["internal::Or","internal::Map","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::AndThen"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::And","std::boxed::Box","internal::Or","internal::FlatMap","internal::Into"],"O1":["RUG_ANY"]},"internal::FlatMap":{"F":["internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::Map","internal::AndThen","std::boxed::Box"],"G":["core::str::IsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<!>>","<T as std::convert::From<T>>","u8"],"F":["std::boxed::Box","internal::AndThen","internal::Into","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::Map","internal::AndThen"],"G":["core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::Map","internal::And","internal::AndThen"],"G":["internal::Map","internal::And","internal::FlatMap","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or"]},"internal::Parser::and":{"E":["RUG_ANY"],"G":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::AndThen","internal::And","internal::Or","internal::Into"],"I":["RUG_ANY"],"O":["RUG_ANY"],"O2":["RUG_ANY"],"Self":["internal::And","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::FlatMap","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+p0.and(p1);
+internal::Parser::and(p0, p1);
+crate::internal::Parser::and(p0, p1);
+crate::internal::Parser::and(p0, p1);
-----------------
src/internal.rs internal::Parser::or
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::Parser::or":{"E":["std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"Self":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"internal::And":{"F":["internal::Map","internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","std::boxed::Box"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into","internal::And","internal::Or","internal::FlatMap","std::boxed::Box"]},"internal::AndThen":{"F":["internal::FlatMap","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","std::boxed::Box","internal::Map"],"G":["internal::FlatMap","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::AndThen","internal::Or"],"O1":["RUG_ANY"]},"internal::FlatMap":{"F":["internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Into","std::boxed::Box","internal::Or"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::AndThen","internal::Or","internal::Into","internal::FlatMap","std::boxed::Box","internal::Map","internal::And","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::And","internal::Or","internal::FlatMap"],"G":["core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","internal::FlatMap","std::boxed::Box","internal::Or","internal::And","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>"],"G":["internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Or","internal::Map","std::boxed::Box","internal::And"]},"internal::Parser::or":{"E":["RUG_ANY"],"G":["std::boxed::Box","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Map","internal::FlatMap"],"I":["RUG_ANY"],"O":["RUG_ANY"],"Self":["internal::AndThen","internal::FlatMap","internal::And","internal::Or","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // G
+p0.or(p1);
+internal::Parser::or(p0, p1);
+crate::internal::Parser::or(p0, p1);
+crate::internal::Parser::or(p0, p1);
-----------------
src/internal.rs internal::Parser::into
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::Parser::into":{"E":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"],"Self":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"internal::And":{"F":["internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Into","internal::FlatMap","internal::Or"],"G":["internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Into","internal::AndThen","std::boxed::Box","internal::And"]},"internal::AndThen":{"F":["internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Map"],"G":["std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::Into","internal::AndThen","internal::Map"],"O1":["RUG_ANY"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Or","std::boxed::Box","internal::FlatMap","internal::Into","internal::And"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<!>>","<T as std::convert::From<T>>","u8"],"F":["internal::And","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::FlatMap","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::Into","std::boxed::Box","internal::Map","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","internal::FlatMap","internal::Map","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box"],"G":["internal::And","internal::Map","internal::FlatMap","std::boxed::Box","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen"]},"internal::Parser::into":{"E":["RUG_ANY"],"E2":["char"],"I":["RUG_ANY"],"O":["RUG_ANY"],"O2":["char"],"Self":["internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Into","internal::And","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.into();
+internal::Parser::into(p0);
+crate::internal::Parser::into(p0);
+crate::internal::Parser::into(p0);
-----------------
src/sequence/mod.rs sequence::Tuple::parse
deps:{"sequence::Tuple::parse":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"],"Self":["sequence::Tuple"]}}
candidates:{"sequence::Tuple::parse":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"],"Self":[]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+sequence::Tuple::parse(p0, p1);
+crate::sequence::Tuple::parse(p0, p1);
+crate::sequence::Tuple::parse(p0, p1);
-----------------
src/traits.rs traits::InputLength::input_len
deps:{"traits::InputLength::input_len":{"Self":["traits::InputLength"]}}
candidates:{"traits::InputLength::input_len":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.input_len();
+traits::InputLength::input_len(p0);
+crate::traits::InputLength::input_len(p0);
+crate::traits::InputLength::input_len(p0);
-----------------
src/traits.rs traits::Offset::offset
deps:{"traits::Offset::offset":{"Self":["traits::Offset"]}}
candidates:{"traits::Offset::offset":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // Self
+p0.offset(p1);
+traits::Offset::offset(p0, p1);
+crate::traits::Offset::offset(p0, p1);
+crate::traits::Offset::offset(p0, p1);
-----------------
src/traits.rs traits::AsBytes::as_bytes
deps:{"traits::AsBytes::as_bytes":{"Self":["traits::AsBytes"]}}
candidates:{"traits::AsBytes::as_bytes":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.as_bytes();
+traits::AsBytes::as_bytes(p0);
+crate::traits::AsBytes::as_bytes(p0);
+crate::traits::AsBytes::as_bytes(p0);
-----------------
src/traits.rs traits::AsChar::as_char
deps:{"traits::AsChar::as_char":{"Self":["traits::AsChar"]}}
candidates:{"traits::AsChar::as_char":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.as_char();
+traits::AsChar::as_char(p0);
+crate::traits::AsChar::as_char(p0);
+crate::traits::AsChar::as_char(p0);
-----------------
src/traits.rs traits::AsChar::is_alpha
deps:{"traits::AsChar::is_alpha":{"Self":["traits::AsChar"]}}
candidates:{"traits::AsChar::is_alpha":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_alpha();
+traits::AsChar::is_alpha(p0);
+crate::traits::AsChar::is_alpha(p0);
+crate::traits::AsChar::is_alpha(p0);
-----------------
src/traits.rs traits::AsChar::is_alphanum
deps:{"traits::AsChar::is_alphanum":{"Self":["traits::AsChar"]}}
candidates:{"traits::AsChar::is_alphanum":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_alphanum();
+traits::AsChar::is_alphanum(p0);
+crate::traits::AsChar::is_alphanum(p0);
+crate::traits::AsChar::is_alphanum(p0);
-----------------
src/traits.rs traits::AsChar::is_dec_digit
deps:{"traits::AsChar::is_dec_digit":{"Self":["traits::AsChar"]}}
candidates:{"traits::AsChar::is_dec_digit":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_dec_digit();
+traits::AsChar::is_dec_digit(p0);
+crate::traits::AsChar::is_dec_digit(p0);
+crate::traits::AsChar::is_dec_digit(p0);
-----------------
src/traits.rs traits::AsChar::is_hex_digit
deps:{"traits::AsChar::is_hex_digit":{"Self":["traits::AsChar"]}}
candidates:{"traits::AsChar::is_hex_digit":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_hex_digit();
+traits::AsChar::is_hex_digit(p0);
+crate::traits::AsChar::is_hex_digit(p0);
+crate::traits::AsChar::is_hex_digit(p0);
-----------------
src/traits.rs traits::AsChar::is_oct_digit
deps:{"traits::AsChar::is_oct_digit":{"Self":["traits::AsChar"]}}
candidates:{"traits::AsChar::is_oct_digit":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.is_oct_digit();
+traits::AsChar::is_oct_digit(p0);
+crate::traits::AsChar::is_oct_digit(p0);
+crate::traits::AsChar::is_oct_digit(p0);
-----------------
src/traits.rs traits::AsChar::len
deps:{"traits::AsChar::len":{"Self":["traits::AsChar"]}}
candidates:{"traits::AsChar::len":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.len();
+traits::AsChar::len(p0);
+crate::traits::AsChar::len(p0);
+crate::traits::AsChar::len(p0);
-----------------
src/traits.rs traits::InputIter::iter_indices
deps:{"traits::InputIter::iter_indices":{"Self":["traits::InputIter"]}}
candidates:{"traits::InputIter::iter_indices":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.iter_indices();
+traits::InputIter::iter_indices(p0);
+crate::traits::InputIter::iter_indices(p0);
+crate::traits::InputIter::iter_indices(p0);
-----------------
src/traits.rs traits::InputIter::iter_elements
deps:{"traits::InputIter::iter_elements":{"Self":["traits::InputIter"]}}
candidates:{"traits::InputIter::iter_elements":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.iter_elements();
+traits::InputIter::iter_elements(p0);
+crate::traits::InputIter::iter_elements(p0);
+crate::traits::InputIter::iter_elements(p0);
-----------------
src/traits.rs traits::InputIter::position
deps:{"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"traits::InputIter::position":{"P":["std::ops::Fn","std::marker::Sized"],"Self":["traits::InputIter"]}}
candidates:{"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"traits::InputIter::position":{"P":["core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+traits::InputIter::position(p0, p1);
+crate::traits::InputIter::position(p0, p1);
+crate::traits::InputIter::position(p0, p1);
-----------------
src/traits.rs traits::InputIter::slice_index
deps:{"traits::InputIter::slice_index":{"Self":["traits::InputIter"]}}
candidates:{"traits::InputIter::slice_index":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+traits::InputIter::slice_index(p0, p1);
+crate::traits::InputIter::slice_index(p0, p1);
+crate::traits::InputIter::slice_index(p0, p1);
-----------------
src/traits.rs traits::InputTake::take
deps:{"traits::InputTake::take":{"Self":["std::marker::Sized","traits::InputTake"]}}
candidates:{"traits::InputTake::take":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.take(p1);
+traits::InputTake::take(p0, p1);
+crate::traits::InputTake::take(p0, p1);
+crate::traits::InputTake::take(p0, p1);
-----------------
src/traits.rs traits::InputTake::take_split
deps:{"traits::InputTake::take_split":{"Self":["traits::InputTake","std::marker::Sized"]}}
candidates:{"traits::InputTake::take_split":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.take_split(p1);
+traits::InputTake::take_split(p0, p1);
+crate::traits::InputTake::take_split(p0, p1);
+crate::traits::InputTake::take_split(p0, p1);
-----------------
src/traits.rs traits::InputTakeAtPosition::split_at_position
deps:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["std::marker::Sized","traits::UnspecializedInput","traits::InputLength","traits::InputIter","std::clone::Clone","traits::InputTake"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"traits::InputTakeAtPosition::split_at_position":{"E":["std::marker::Sized","error::ParseError"],"P":["std::marker::Sized","std::ops::Fn"],"Self":["traits::InputTakeAtPosition","std::marker::Sized"]}}
candidates:{"<*const T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind","internal::Needed","number::Endianness"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"traits::InputTakeAtPosition::split_at_position":{"E":["error::Error","error::VerboseError"],"P":["core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::slice::ascii::EscapeByte"],"Self":["<T as traits::InputTakeAtPosition>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position(p1);
+traits::InputTakeAtPosition::split_at_position(p0, p1);
+crate::traits::InputTakeAtPosition::split_at_position(p0, p1);
+crate::traits::InputTakeAtPosition::split_at_position(p0, p1);
-----------------
src/traits.rs traits::InputTakeAtPosition::split_at_position1
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputIter","traits::InputLength","std::clone::Clone","std::marker::Sized","traits::UnspecializedInput","traits::InputTake"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"traits::InputTakeAtPosition::split_at_position1":{"E":["error::ParseError","std::marker::Sized"],"P":["std::ops::Fn","std::marker::Sized"],"Self":["std::marker::Sized","traits::InputTakeAtPosition"]}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","internal::Err","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"traits::InputTakeAtPosition::split_at_position1":{"E":["error::Error","error::VerboseError"],"P":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::CharEscapeUnicode"],"Self":["<T as traits::InputTakeAtPosition>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1(p1, p2);
+traits::InputTakeAtPosition::split_at_position1(p0, p1, p2);
+crate::traits::InputTakeAtPosition::split_at_position1(p0, p1, p2);
+crate::traits::InputTakeAtPosition::split_at_position1(p0, p1, p2);
-----------------
src/traits.rs traits::InputTakeAtPosition::split_at_position_complete
deps:{"<T as traits::InputTakeAtPosition>":{"T":["traits::InputIter","std::clone::Clone","std::marker::Sized","traits::InputTake","traits::UnspecializedInput","traits::InputLength"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"traits::InputTakeAtPosition::split_at_position_complete":{"E":["std::marker::Sized","error::ParseError"],"P":["std::marker::Sized","std::ops::Fn"],"Self":["traits::InputTakeAtPosition","std::marker::Sized"]}}
candidates:{"<T as traits::InputTakeAtPosition>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness","error::ErrorKind","internal::Needed","internal::Err"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{},"traits::InputTakeAtPosition::split_at_position_complete":{"E":["error::Error","error::VerboseError"],"P":["std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty"],"Self":["<T as traits::InputTakeAtPosition>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position_complete(p1);
+traits::InputTakeAtPosition::split_at_position_complete(p0, p1);
+crate::traits::InputTakeAtPosition::split_at_position_complete(p0, p1);
+crate::traits::InputTakeAtPosition::split_at_position_complete(p0, p1);
-----------------
src/traits.rs traits::InputTakeAtPosition::split_at_position1_complete
deps:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{"T":["traits::InputTake","traits::InputLength","std::marker::Sized","std::clone::Clone","traits::InputIter","traits::UnspecializedInput"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"traits::InputTakeAtPosition::split_at_position1_complete":{"E":["std::marker::Sized","error::ParseError"],"P":["std::ops::Fn","std::marker::Sized"],"Self":["std::marker::Sized","traits::InputTakeAtPosition"]}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>":{},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","internal::Needed","number::Endianness","error::ErrorKind","<*mut T as std::fmt::Debug>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"traits::InputTakeAtPosition::split_at_position1_complete":{"E":["error::VerboseError","error::Error"],"P":["std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::LinesAnyMap"],"Self":["<T as traits::InputTakeAtPosition>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1_complete(p1, p2);
+traits::InputTakeAtPosition::split_at_position1_complete(p0, p1, p2);
+crate::traits::InputTakeAtPosition::split_at_position1_complete(p0, p1, p2);
+crate::traits::InputTakeAtPosition::split_at_position1_complete(p0, p1, p2);
-----------------
src/traits.rs traits::Compare::compare
deps:{"<T as traits::Compare<O>>":{"T":["traits::InputLength","traits::InputTake","traits::UnspecializedInput","traits::InputIter","std::marker::Sized"]},"traits::Compare::compare":{"Self":["traits::Compare"],"T":["std::marker::Sized"]}}
candidates:{"<T as traits::Compare<O>>":{},"traits::Compare::compare":{"Self":["<T as traits::Compare<O>>"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.compare(p1);
+traits::Compare::compare(p0, p1);
+crate::traits::Compare::compare(p0, p1);
+crate::traits::Compare::compare(p0, p1);
-----------------
src/traits.rs traits::Compare::compare_no_case
deps:{"<T as traits::Compare<O>>":{"T":["traits::InputLength","traits::InputIter","traits::InputTake","traits::UnspecializedInput","std::marker::Sized"]},"traits::Compare::compare_no_case":{"Self":["traits::Compare"],"T":["std::marker::Sized"]}}
candidates:{"<T as traits::Compare<O>>":{},"traits::Compare::compare_no_case":{"Self":["<T as traits::Compare<O>>"],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.compare_no_case(p1);
+traits::Compare::compare_no_case(p0, p1);
+crate::traits::Compare::compare_no_case(p0, p1);
+crate::traits::Compare::compare_no_case(p0, p1);
-----------------
src/traits.rs traits::FindToken::find_token
deps:{"traits::FindToken::find_token":{"Self":["traits::FindToken"],"T":["std::marker::Sized"]}}
candidates:{"traits::FindToken::find_token":{"Self":[],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.find_token(p1);
+traits::FindToken::find_token(p0, p1);
+crate::traits::FindToken::find_token(p0, p1);
+crate::traits::FindToken::find_token(p0, p1);
-----------------
src/traits.rs traits::FindSubstring::find_substring
deps:{"traits::FindSubstring::find_substring":{"Self":["traits::FindSubstring"],"T":["std::marker::Sized"]}}
candidates:{"traits::FindSubstring::find_substring":{"Self":[],"T":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.find_substring(p1);
+traits::FindSubstring::find_substring(p0, p1);
+crate::traits::FindSubstring::find_substring(p0, p1);
+crate::traits::FindSubstring::find_substring(p0, p1);
-----------------
src/traits.rs traits::ParseTo::parse_to
deps:{"traits::ParseTo::parse_to":{"R":["std::marker::Sized"],"Self":["traits::ParseTo"]}}
candidates:{"traits::ParseTo::parse_to":{"R":["RUG_ANY"],"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.parse_to();
+traits::ParseTo::parse_to(p0);
+crate::traits::ParseTo::parse_to(p0);
+crate::traits::ParseTo::parse_to(p0);
-----------------
src/traits.rs traits::Slice::slice
deps:{"traits::Slice::slice":{"R":["std::marker::Sized"],"Self":["traits::Slice"]}}
candidates:{"traits::Slice::slice":{"R":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = MaybeUninit::uninit().assume_init(); // R
+p0.slice(p1);
+traits::Slice::slice(p0, p1);
+crate::traits::Slice::slice(p0, p1);
+crate::traits::Slice::slice(p0, p1);
-----------------
src/traits.rs traits::ExtendInto::new_builder
deps:{"traits::ExtendInto::new_builder":{"Self":["traits::ExtendInto"]}}
candidates:{"traits::ExtendInto::new_builder":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.new_builder();
+traits::ExtendInto::new_builder(p0);
+crate::traits::ExtendInto::new_builder(p0);
+crate::traits::ExtendInto::new_builder(p0);
-----------------
src/traits.rs traits::ExtendInto::extend_into
deps:{"traits::ExtendInto::extend_into":{"Self":["traits::ExtendInto"]}}
candidates:{"traits::ExtendInto::extend_into":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // <Self as traits::ExtendInto>::Extender
+p0.extend_into(p1);
+traits::ExtendInto::extend_into(p0, p1);
+crate::traits::ExtendInto::extend_into(p0, p1);
+crate::traits::ExtendInto::extend_into(p0, p1);
-----------------
src/traits.rs traits::ToUsize::to_usize
deps:{"traits::ToUsize::to_usize":{"Self":["traits::ToUsize"]}}
candidates:{"traits::ToUsize::to_usize":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.to_usize();
+traits::ToUsize::to_usize(p0);
+crate::traits::ToUsize::to_usize(p0);
+crate::traits::ToUsize::to_usize(p0);
-----------------
src/traits.rs traits::ErrorConvert::convert
deps:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"traits::ErrorConvert::convert":{"E":["std::marker::Sized"],"Self":["traits::ErrorConvert"]}}
candidates:{"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","internal::Needed","error::ErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"traits::ErrorConvert::convert":{"E":["RUG_ANY"],"Self":["error::VerboseError","error::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.convert();
+traits::ErrorConvert::convert(p0);
+crate::traits::ErrorConvert::convert(p0);
+crate::traits::ErrorConvert::convert(p0);
-----------------
src/traits.rs traits::HexDisplay::to_hex
deps:{"traits::HexDisplay::to_hex":{"Self":["traits::HexDisplay"]}}
candidates:{"traits::HexDisplay::to_hex":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.to_hex(p1);
+traits::HexDisplay::to_hex(p0, p1);
+crate::traits::HexDisplay::to_hex(p0, p1);
+crate::traits::HexDisplay::to_hex(p0, p1);
-----------------
src/traits.rs traits::HexDisplay::to_hex_from
deps:{"traits::HexDisplay::to_hex_from":{"Self":["traits::HexDisplay"]}}
candidates:{"traits::HexDisplay::to_hex_from":{"Self":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.to_hex_from(p1, p2);
+traits::HexDisplay::to_hex_from(p0, p1, p2);
+crate::traits::HexDisplay::to_hex_from(p0, p1, p2);
+crate::traits::HexDisplay::to_hex_from(p0, p1, p2);
-----------------
src/error.rs <error::Error<I> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::Error<I> as std::fmt::Debug>::fmt":{"I":["std::fmt::Debug","std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::Error<I> as std::fmt::Debug>::fmt":{"I":["number::Endianness","internal::Needed","traits::CompareResult","error::ErrorKind","error::VerboseError","error::VerboseErrorKind","<*mut T as std::fmt::Debug>","error::Error","<*const T as std::fmt::Debug>","internal::Err"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","error::ErrorKind","internal::Err","number::Endianness"]},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Error<I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Error<I> as std::fmt::Debug>::fmt(p0, p1);
+<error::Error<I>>::fmt(p0, p1);
-----------------
src/error.rs <error::Error<I> as std::cmp::PartialEq>::eq
deps:{"<*mut T as std::fmt::Debug>":{},"<error::Error<I> as std::cmp::PartialEq>::eq":{"I":["std::marker::Sized","std::cmp::PartialEq"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<error::Error<I> as std::cmp::PartialEq>::eq":{"I":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseError","traits::CompareResult","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","number::Endianness","error::ErrorKind","error::Error","internal::Needed","error::VerboseErrorKind"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","<*mut T as std::fmt::Debug>","internal::Err","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::Error<I>
+p0.eq(p1);
+<error::Error<I> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::Error<I> as std::cmp::PartialEq>::eq(p0, p1);
+<error::Error<I>>::eq(p0, p1);
-----------------
src/error.rs error::Error::<I>::new
deps:{"error::Error::<I>::new":{"I":["std::marker::Sized"]}}
candidates:{"error::Error::<I>::new":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+error::Error::<I>::new(p0, p1);
+crate::error::Error::<I>::new(p0, p1);
+<error::Error<I>>::new(p0, p1);
-----------------
src/error.rs <error::Error<I> as error::ParseError<I>>::from_error_kind
deps:{"<error::Error<I> as error::ParseError<I>>::from_error_kind":{"I":["std::marker::Sized"]}}
candidates:{"<error::Error<I> as error::ParseError<I>>::from_error_kind":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+<error::Error<I> as error::ParseError<I>>::from_error_kind(p0, p1);
+crate::<error::Error<I> as error::ParseError<I>>::from_error_kind(p0, p1);
+<error::Error<I>>::from_error_kind(p0, p1);
-----------------
src/error.rs <error::Error<I> as error::ParseError<I>>::append
deps:{"<error::Error<I> as error::ParseError<I>>::append":{"I":["std::marker::Sized"]}}
candidates:{"<error::Error<I> as error::ParseError<I>>::append":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // error::Error<I>
+<error::Error<I> as error::ParseError<I>>::append(p0, p1, p2);
+crate::<error::Error<I> as error::ParseError<I>>::append(p0, p1, p2);
+<error::Error<I>>::append(p0, p1, p2);
-----------------
src/error.rs <error::Error<I> as error::FromExternalError<I, E>>::from_external_error
deps:{"<error::Error<I> as error::FromExternalError<I, E>>::from_external_error":{"E":["std::marker::Sized"],"I":["std::marker::Sized"]}}
candidates:{"<error::Error<I> as error::FromExternalError<I, E>>::from_external_error":{"E":["RUG_ANY"],"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+<error::Error<I> as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+crate::<error::Error<I> as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+<error::Error<I>>::from_external_error(p0, p1, p2);
-----------------
src/error.rs <error::Error<I> as std::fmt::Display>::fmt
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<error::Error<I> as std::fmt::Display>::fmt":{"I":["std::fmt::Display","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<error::Error<I> as std::fmt::Display>::fmt":{"I":["<&T as std::fmt::Display>","internal::Err","error::Error","error::VerboseError"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","internal::Needed","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind"]},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Error<I> as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Error<I> as std::fmt::Display>::fmt(p0, p1);
+<error::Error<I>>::fmt(p0, p1);
-----------------
src/error.rs <(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind
deps:{"<(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind":{"I":["std::marker::Sized"]}}
candidates:{"<(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+<(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind(p0, p1);
+crate::<(I, error::ErrorKind) as error::ParseError<I>>::from_error_kind(p0, p1);
+<(I, error::ErrorKind)>::from_error_kind(p0, p1);
-----------------
src/error.rs <(I, error::ErrorKind) as error::ParseError<I>>::append
deps:{"<(I, error::ErrorKind) as error::ParseError<I>>::append":{"I":["std::marker::Sized"]}}
candidates:{"<(I, error::ErrorKind) as error::ParseError<I>>::append":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // (I, error::ErrorKind)
+<(I, error::ErrorKind) as error::ParseError<I>>::append(p0, p1, p2);
+crate::<(I, error::ErrorKind) as error::ParseError<I>>::append(p0, p1, p2);
+<(I, error::ErrorKind)>::append(p0, p1, p2);
-----------------
src/error.rs <(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error
deps:{"<(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error":{"E":["std::marker::Sized"],"I":["std::marker::Sized"]}}
candidates:{"<(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error":{"E":["RUG_ANY"],"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+<(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+crate::<(I, error::ErrorKind) as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+<(I, error::ErrorKind)>::from_external_error(p0, p1, p2);
-----------------
src/error.rs <() as error::ParseError<I>>::from_error_kind
deps:{"<() as error::ParseError<I>>::from_error_kind":{"I":["std::marker::Sized"]}}
candidates:{"<() as error::ParseError<I>>::from_error_kind":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+<() as error::ParseError<I>>::from_error_kind(p0, p1);
+crate::<() as error::ParseError<I>>::from_error_kind(p0, p1);
+<()>::from_error_kind(p0, p1);
-----------------
src/error.rs <() as error::ParseError<I>>::append
deps:{"<() as error::ParseError<I>>::append":{"I":["std::marker::Sized"]}}
candidates:{"<() as error::ParseError<I>>::append":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = (); // None+()
+<() as error::ParseError<I>>::append(p0, p1, p2);
+crate::<() as error::ParseError<I>>::append(p0, p1, p2);
+<()>::append(p0, p1, p2);
-----------------
src/error.rs <() as error::FromExternalError<I, E>>::from_external_error
deps:{"<() as error::FromExternalError<I, E>>::from_external_error":{"E":["std::marker::Sized"],"I":["std::marker::Sized"]}}
candidates:{"<() as error::FromExternalError<I, E>>::from_external_error":{"E":["RUG_ANY"],"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+<() as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+crate::<() as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+<()>::from_external_error(p0, p1, p2);
-----------------
src/error.rs <error::VerboseError<I> as std::clone::Clone>::clone
deps:{"<error::VerboseError<I> as std::clone::Clone>::clone":{"I":["std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<error::VerboseError<I> as std::clone::Clone>::clone":{"I":["internal::Needed","std::clone::impls::<impl std::clone::Clone for &mut T>","error::ErrorKind","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::VerboseError","number::Endianness"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","internal::Needed","number::Endianness","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+p0.clone();
+<error::VerboseError<I> as std::clone::Clone>::clone(p0);
+crate::<error::VerboseError<I> as std::clone::Clone>::clone(p0);
+<error::VerboseError<I>>::clone(p0);
-----------------
src/error.rs <error::VerboseError<I> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::VerboseError<I> as std::fmt::Debug>::fmt":{"I":["std::marker::Sized","std::fmt::Debug"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<error::VerboseError<I> as std::fmt::Debug>::fmt":{"I":["error::Error","<*const T as std::fmt::Debug>","number::Endianness","error::VerboseErrorKind","error::VerboseError","internal::Err","traits::CompareResult","<&mut T as std::fmt::Debug>","error::ErrorKind","internal::Needed"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::VerboseError<I> as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::VerboseError<I> as std::fmt::Debug>::fmt(p0, p1);
+<error::VerboseError<I>>::fmt(p0, p1);
-----------------
src/error.rs <error::VerboseError<I> as std::cmp::PartialEq>::eq
deps:{"<*mut T as std::fmt::Debug>":{},"<error::VerboseError<I> as std::cmp::PartialEq>::eq":{"I":["std::cmp::PartialEq","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<error::VerboseError<I> as std::cmp::PartialEq>::eq":{"I":["traits::CompareResult","error::ErrorKind","error::VerboseError","internal::Needed","internal::Err","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::Error","error::VerboseErrorKind"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","<*mut T as std::fmt::Debug>","internal::Err","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+p0.eq(p1);
+<error::VerboseError<I> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::VerboseError<I> as std::cmp::PartialEq>::eq(p0, p1);
+<error::VerboseError<I>>::eq(p0, p1);
-----------------
src/error.rs <error::VerboseErrorKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseErrorKind
+p0.clone();
+<error::VerboseErrorKind as std::clone::Clone>::clone(p0);
+crate::<error::VerboseErrorKind as std::clone::Clone>::clone(p0);
+<error::VerboseErrorKind>::clone(p0);
-----------------
src/error.rs <error::VerboseErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::VerboseErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::VerboseErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<error::VerboseErrorKind>::fmt(p0, p1);
-----------------
src/error.rs <error::VerboseErrorKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseErrorKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::VerboseErrorKind
+p0.eq(p1);
+<error::VerboseErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::VerboseErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+<error::VerboseErrorKind>::eq(p0, p1);
-----------------
src/error.rs <error::VerboseError<I> as error::ParseError<I>>::from_error_kind
deps:{"<error::VerboseError<I> as error::ParseError<I>>::from_error_kind":{"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<I> as error::ParseError<I>>::from_error_kind":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+<error::VerboseError<I> as error::ParseError<I>>::from_error_kind(p0, p1);
+crate::<error::VerboseError<I> as error::ParseError<I>>::from_error_kind(p0, p1);
+<error::VerboseError<I>>::from_error_kind(p0, p1);
-----------------
src/error.rs <error::VerboseError<I> as error::ParseError<I>>::append
deps:{"<error::VerboseError<I> as error::ParseError<I>>::append":{"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<I> as error::ParseError<I>>::append":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+<error::VerboseError<I> as error::ParseError<I>>::append(p0, p1, p2);
+crate::<error::VerboseError<I> as error::ParseError<I>>::append(p0, p1, p2);
+<error::VerboseError<I>>::append(p0, p1, p2);
-----------------
src/error.rs <error::VerboseError<I> as error::ParseError<I>>::from_char
deps:{"<error::VerboseError<I> as error::ParseError<I>>::from_char":{"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<I> as error::ParseError<I>>::from_char":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = 'a'; // None+char
+<error::VerboseError<I> as error::ParseError<I>>::from_char(p0, p1);
+crate::<error::VerboseError<I> as error::ParseError<I>>::from_char(p0, p1);
+<error::VerboseError<I>>::from_char(p0, p1);
-----------------
src/error.rs <error::VerboseError<I> as error::ContextError<I>>::add_context
deps:{"<error::VerboseError<I> as error::ContextError<I>>::add_context":{"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<I> as error::ContextError<I>>::add_context":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+<error::VerboseError<I> as error::ContextError<I>>::add_context(p0, &p1, p2);
+crate::<error::VerboseError<I> as error::ContextError<I>>::add_context(p0, &p1, p2);
+<error::VerboseError<I>>::add_context(p0, &p1, p2);
-----------------
src/error.rs <error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error
deps:{"<error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error":{"E":["std::marker::Sized"],"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error":{"E":["RUG_ANY"],"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p2 = MaybeUninit::uninit().assume_init(); // E
+<error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+crate::<error::VerboseError<I> as error::FromExternalError<I, E>>::from_external_error(p0, p1, p2);
+<error::VerboseError<I>>::from_external_error(p0, p1, p2);
-----------------
src/error.rs <error::VerboseError<I> as std::fmt::Display>::fmt
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<error::VerboseError<I> as std::fmt::Display>::fmt":{"I":["std::fmt::Display","std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<*const T as std::fmt::Debug>":{},"<error::VerboseError<I> as std::fmt::Display>::fmt":{"I":["error::VerboseError","error::Error","internal::Err","<&T as std::fmt::Display>","<&mut T as std::fmt::Display>"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed"]},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::VerboseError<I> as std::fmt::Display>::fmt(p0, p1);
+crate::<error::VerboseError<I> as std::fmt::Display>::fmt(p0, p1);
+<error::VerboseError<I>>::fmt(p0, p1);
-----------------
src/error.rs <error::ErrorKind as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::ErrorKind as std::fmt::Debug>::fmt(p0, p1);
+<error::ErrorKind>::fmt(p0, p1);
-----------------
src/error.rs <error::ErrorKind as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.eq(p1);
+<error::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::ErrorKind as std::cmp::PartialEq>::eq(p0, p1);
+<error::ErrorKind>::eq(p0, p1);
-----------------
src/error.rs <error::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.assert_receiver_is_total_eq();
+<error::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::ErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::ErrorKind>::assert_receiver_is_total_eq(p0);
-----------------
src/error.rs <error::ErrorKind as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<error::ErrorKind as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<error::ErrorKind as std::hash::Hash>::hash":{"__H":["<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher","std::boxed::Box<T, A>","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<error::ErrorKind as std::hash::Hash>::hash(p0, p1);
+crate::<error::ErrorKind as std::hash::Hash>::hash(p0, p1);
+<error::ErrorKind>::hash(p0, p1);
-----------------
src/error.rs <error::ErrorKind as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.clone();
+<error::ErrorKind as std::clone::Clone>::clone(p0);
+crate::<error::ErrorKind as std::clone::Clone>::clone(p0);
+<error::ErrorKind>::clone(p0);
-----------------
src/error.rs error::ErrorKind::description
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.description();
+error::ErrorKind::description(p0);
+crate::error::ErrorKind::description(p0);
+<error::ErrorKind>::description(p0);
-----------------
src/branch/mod.rs <(A, B) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::Into"],"B":["internal::And","internal::AndThen","std::boxed::Box","internal::Into","internal::Map","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"Error":["error::Error","error::VerboseError"],"Input":["internal::Err","internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","number::Endianness","error::VerboseErrorKind"],"Output":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::IsWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Into","internal::FlatMap","std::boxed::Box","internal::Map","internal::And","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>"],"G":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And","std::boxed::Box","internal::Into","internal::AndThen"]},"internal::AndThen":{"F":["internal::Or","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::And","internal::Into"],"G":["internal::FlatMap","internal::And","internal::Or","std::boxed::Box","internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","number::Endianness","internal::Err"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Into","internal::Or","internal::FlatMap","internal::And","internal::AndThen"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","i8","<T as std::convert::From<T>>","<T as std::convert::From<!>>"],"F":["internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","std::boxed::Box","internal::Map","internal::And","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","std::boxed::Box","internal::Into","internal::Or","internal::And","internal::FlatMap"],"G":["std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","internal::AndThen","internal::Or","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into"],"G":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::And","internal::FlatMap","internal::Or","internal::AndThen"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["std::marker::Sized","internal::Parser"],"C":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"Input":["std::marker::Sized","std::clone::Clone"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Map","internal::Or","internal::And","std::boxed::Box","internal::Into","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"B":["internal::Into","internal::AndThen","internal::Or","internal::FlatMap","internal::And","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"C":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::AndThen","internal::Or","internal::And","std::boxed::Box"],"Error":["error::Error","error::VerboseError"],"Input":["internal::Err","number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","error::ErrorKind"],"Output":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::And","internal::AndThen","internal::Map","internal::Into","std::boxed::Box","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"G":["internal::Or","internal::Map","std::boxed::Box","internal::AndThen","internal::Into","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>"]},"internal::AndThen":{"F":["internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Map","internal::Or"],"G":["internal::Map","internal::And","internal::Or","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Err","internal::Needed"]},"internal::FlatMap":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::And","internal::Map","std::boxed::Box","internal::AndThen"],"G":["core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["internal::Or","internal::FlatMap","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","internal::FlatMap","internal::Into","internal::And","internal::Map","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::And","internal::FlatMap","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map"],"G":["internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::Into","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"Input":["std::marker::Sized","std::clone::Clone"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice":{"A":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::FlatMap","internal::Or","internal::And","std::boxed::Box","internal::Into"],"B":["internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::FlatMap","internal::Or","internal::Into","std::boxed::Box"],"C":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Map","internal::Into","internal::AndThen","internal::FlatMap"],"D":["internal::Map","std::boxed::Box","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::AndThen"],"Error":["error::Error","error::VerboseError"],"Input":["error::VerboseError","internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","error::VerboseErrorKind","internal::Err","number::Endianness"],"Output":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["std::boxed::Box","internal::And","internal::FlatMap","internal::Or","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map"],"G":["std::boxed::Box","internal::And","internal::Map","internal::FlatMap","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::FlatMap","internal::Map","internal::AndThen","internal::Into","internal::Or"],"G":["<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Map","internal::Into","internal::Or","std::boxed::Box","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed","internal::Err"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::AndThen","internal::And","internal::Or","internal::FlatMap","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>"],"G":["core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<T>>","u8","<T as std::convert::From<!>>"],"F":["<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::And","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Map","internal::AndThen","std::boxed::Box","internal::Or"],"G":["core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::Into","internal::Or","std::boxed::Box","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["internal::FlatMap","internal::AndThen","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::And"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["std::marker::Sized","internal::Parser"],"C":["std::marker::Sized","internal::Parser"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"Input":["std::marker::Sized","std::clone::Clone"],"Output":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::And","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::FlatMap","internal::Map"],"B":["internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::And","internal::FlatMap"],"C":["internal::Map","std::boxed::Box","internal::Or","internal::Into","internal::FlatMap","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>"],"D":["internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::FlatMap","internal::And","std::boxed::Box","internal::Into"],"E":["internal::Or","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","std::boxed::Box"],"Error":["error::Error","error::VerboseError"],"Input":["internal::Needed","number::Endianness","error::ErrorKind","error::VerboseError","internal::Err","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseErrorKind"],"Output":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::Map","internal::And","internal::AndThen","std::boxed::Box"],"G":["internal::Into","internal::Or","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::Map"]},"internal::AndThen":{"F":["internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::Map","internal::AndThen","internal::And"],"G":["internal::Into","internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err","error::ErrorKind","internal::Needed","number::Endianness"]},"internal::FlatMap":{"F":["internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Or","internal::Map","std::boxed::Box","internal::AndThen"],"G":["core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Or","std::boxed::Box","internal::FlatMap"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::Map","internal::And","internal::Or","internal::FlatMap","internal::AndThen"],"G":["core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","internal::Or","std::boxed::Box","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","std::boxed::Box","internal::FlatMap","internal::Or","internal::AndThen"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["std::marker::Sized","internal::Parser"],"C":["std::marker::Sized","internal::Parser"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::FlatMap","internal::And","internal::Map","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box"],"B":["internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::FlatMap","internal::Into","internal::And","internal::AndThen"],"C":["<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Map","internal::AndThen","internal::Into","std::boxed::Box","internal::FlatMap"],"D":["internal::And","internal::FlatMap","internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box"],"E":["internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::Or","internal::And","internal::AndThen","internal::Map"],"Error":["error::Error","error::VerboseError"],"F":["internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Or","internal::Map","internal::AndThen"],"Input":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","error::VerboseError","error::VerboseErrorKind"],"Output":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::And","internal::Into","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen"],"G":["internal::And","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","std::boxed::Box","internal::Or"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::Map","internal::Into","internal::AndThen","internal::Or","std::boxed::Box"],"G":["internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","internal::Err","number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"internal::FlatMap":{"F":["internal::FlatMap","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::And","internal::Map"],"G":["core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["internal::FlatMap","internal::Into","internal::Map","internal::Or","internal::And","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","internal::Map","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Or"],"G":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::Or","std::boxed::Box","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::And","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["internal::Parser","std::marker::Sized"],"C":["std::marker::Sized","internal::Parser"],"D":["std::marker::Sized","internal::Parser"],"E":["internal::Parser","std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"],"Output":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice":{"A":["<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Into","internal::Or","internal::And"],"B":["internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::And","std::boxed::Box"],"C":["internal::Into","internal::And","std::boxed::Box","internal::Map","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or"],"D":["std::boxed::Box","internal::Or","internal::AndThen","internal::Map","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::And"],"E":["internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::Map","std::boxed::Box","internal::And"],"Error":["error::VerboseError","error::Error"],"F":["internal::AndThen","internal::And","internal::Map","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into"],"G":["internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","std::boxed::Box","internal::Into","internal::Map"],"Input":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","internal::Needed","error::VerboseErrorKind","error::VerboseError","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>"],"Output":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Into","internal::FlatMap"],"G":["internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Into","std::boxed::Box","internal::AndThen"]},"internal::AndThen":{"F":["internal::AndThen","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Or","internal::Map"],"G":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","std::boxed::Box","internal::Or","internal::And","internal::FlatMap","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err","error::ErrorKind","number::Endianness"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::FlatMap","internal::And","internal::Or","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","<T as std::convert::From<!>>","u8"],"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::And","internal::Into","internal::Or","internal::Map"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","std::boxed::Box","internal::Or","internal::And","internal::FlatMap","internal::Into"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::AndThen","internal::Or","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap"],"G":["internal::Into","internal::Map","internal::Or","internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["std::marker::Sized","internal::Parser"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"H":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::And","internal::Into","internal::Or","std::boxed::Box"],"B":["internal::And","internal::Into","internal::Map","internal::Or","internal::AndThen","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"C":["internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::And","internal::AndThen","internal::Or"],"D":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::Map","std::boxed::Box","internal::Into","internal::And","internal::FlatMap"],"E":["std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into","internal::FlatMap","internal::Or"],"Error":["error::Error","error::VerboseError"],"F":["internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::Map","std::boxed::Box","internal::FlatMap","internal::Or"],"G":["internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Into","internal::And","std::boxed::Box"],"H":["internal::And","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::Into","internal::AndThen"],"Input":["error::VerboseError","error::VerboseErrorKind","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","internal::Err","internal::Needed"],"Output":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","std::boxed::Box","internal::Or","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map"],"G":["internal::AndThen","std::boxed::Box","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::Or"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","std::boxed::Box","internal::Map","internal::Or","internal::AndThen","internal::And"],"G":["internal::Into","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::Map","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","number::Endianness","internal::Err"]},"internal::FlatMap":{"F":["internal::AndThen","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::And","std::boxed::Box"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["internal::And","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","std::boxed::Box","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::And","internal::Map","internal::Into"],"G":["core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Map","internal::Or","internal::Into","internal::And","<F as internal::Parser<I, O, E>>"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Or","internal::Map","std::boxed::Box","internal::Into"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["std::marker::Sized","internal::Parser"],"E":["internal::Parser","std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"],"Output":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Map","internal::Or","internal::And","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into"],"B":["internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into","internal::FlatMap","std::boxed::Box","internal::And"],"C":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::FlatMap","internal::And","internal::Into","internal::Map"],"D":["internal::Or","internal::FlatMap","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::AndThen"],"E":["internal::Map","std::boxed::Box","internal::AndThen","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into"],"Error":["error::VerboseError","error::Error"],"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::And","internal::Into","std::boxed::Box","internal::Or"],"G":["internal::Into","internal::Map","internal::AndThen","internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And"],"H":["internal::FlatMap","internal::And","std::boxed::Box","internal::Map","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or"],"I":["internal::Map","internal::FlatMap","std::boxed::Box","internal::And","internal::Into","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>"],"Input":["error::VerboseError","error::VerboseErrorKind","internal::Err","error::ErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for &T>","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed"],"Output":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Into","internal::Or","internal::Map","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","internal::And","internal::Into","internal::Or"]},"internal::AndThen":{"F":["internal::FlatMap","std::boxed::Box","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Or"],"G":["internal::Into","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::And","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::ErrorKind","internal::Err","number::Endianness","internal::Needed"]},"internal::FlatMap":{"F":["internal::And","internal::Into","internal::FlatMap","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or"],"G":["std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::And","internal::Or","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Or","internal::AndThen","std::boxed::Box","internal::And","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::AndThen","internal::Map","internal::FlatMap","internal::Into","std::boxed::Box"],"G":["internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::Or","internal::AndThen","internal::And"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["std::marker::Sized","internal::Parser"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"H":["internal::Parser","std::marker::Sized"],"I":["internal::Parser","std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized","internal::Parser"],"Output":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::boxed::Box","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::Into","internal::FlatMap"],"B":["internal::FlatMap","internal::Into","internal::AndThen","internal::And","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map"],"C":["internal::FlatMap","internal::AndThen","internal::Or","internal::And","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map"],"D":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::FlatMap","std::boxed::Box","internal::And","internal::Into"],"E":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::Into","internal::And","internal::Map","internal::AndThen","std::boxed::Box"],"Error":["error::VerboseError","error::Error"],"F":["internal::Into","internal::Map","internal::FlatMap","internal::Or","std::boxed::Box","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>"],"G":["internal::AndThen","internal::FlatMap","internal::Into","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::And"],"H":["internal::AndThen","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::Map","internal::FlatMap"],"I":["internal::AndThen","internal::Map","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","std::boxed::Box"],"Input":["error::ErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind"],"J":["std::boxed::Box","internal::Or","internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into"],"Output":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::And","internal::Or","internal::Into"],"G":["<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::AndThen","internal::Or","internal::Into","internal::FlatMap","internal::Map"]},"internal::AndThen":{"F":["internal::Or","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","std::boxed::Box","internal::Map"],"G":["internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","std::boxed::Box","internal::Into","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed","error::ErrorKind","internal::Err"]},"internal::FlatMap":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Or","internal::And","internal::FlatMap","internal::AndThen"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","i8","u8","<T as std::convert::From<T>>"],"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","std::boxed::Box","internal::Or","internal::FlatMap","internal::Into","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::FlatMap","internal::Or","internal::And","internal::AndThen","std::boxed::Box"],"G":["core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","internal::Or","std::boxed::Box","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into"],"G":["internal::FlatMap","internal::And","internal::Into","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["std::marker::Sized","internal::Parser"],"E":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["internal::Parser","std::marker::Sized"],"K":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::AndThen","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","std::boxed::Box","internal::Or"],"B":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::And"],"C":["internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::Map","std::boxed::Box"],"D":["internal::FlatMap","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","std::boxed::Box","internal::Into"],"E":["internal::Or","internal::And","internal::Map","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap"],"Error":["error::Error","error::VerboseError"],"F":["internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Or","internal::FlatMap","internal::AndThen"],"G":["internal::Into","internal::FlatMap","internal::AndThen","internal::Map","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And"],"H":["<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into","internal::And"],"I":["internal::AndThen","internal::FlatMap","internal::And","internal::Into","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"Input":["number::Endianness","error::VerboseErrorKind","error::VerboseError","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Err","internal::Needed"],"J":["internal::Into","internal::And","internal::Or","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen"],"K":["internal::FlatMap","internal::Into","std::boxed::Box","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or"],"Output":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsWhitespace"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Into","internal::And","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","std::boxed::Box"],"G":["internal::Map","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","std::boxed::Box","internal::And"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","std::boxed::Box","internal::Map","internal::Or","internal::AndThen","internal::Into"],"G":["std::boxed::Box","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Or"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","number::Endianness"]},"internal::FlatMap":{"F":["internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Into"],"G":["core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["internal::Into","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::Map","internal::FlatMap","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen"],"G":["core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","std::boxed::Box","internal::Into","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap"],"G":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Map","internal::Into","internal::AndThen","internal::Or"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["std::marker::Sized","internal::Parser"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"H":["internal::Parser","std::marker::Sized"],"I":["internal::Parser","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["internal::Parser","std::marker::Sized"],"K":["std::marker::Sized","internal::Parser"],"L":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::Map","std::boxed::Box","internal::FlatMap"],"B":["internal::Map","internal::Into","std::boxed::Box","internal::And","internal::Or","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"C":["internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::And","internal::FlatMap","internal::Into","std::boxed::Box"],"D":["internal::And","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::Or","internal::Map","internal::AndThen","internal::FlatMap"],"E":["internal::FlatMap","internal::Or","internal::Map","internal::Into","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"Error":["error::VerboseError","error::Error"],"F":["internal::And","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::AndThen","internal::Into"],"G":["internal::Into","internal::FlatMap","internal::AndThen","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box"],"H":["internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::Or","internal::Map"],"I":["internal::Or","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Map"],"Input":["error::ErrorKind","internal::Err","internal::Needed","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseErrorKind","number::Endianness","error::VerboseError"],"J":["<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::And","internal::Map","internal::Or","internal::Into","internal::AndThen"],"K":["internal::FlatMap","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::AndThen","internal::Or"],"L":["internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","std::boxed::Box","internal::Or","internal::AndThen"],"Output":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::And","internal::Into","internal::Or","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap"],"G":["internal::Into","internal::Map","std::boxed::Box","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap"]},"internal::AndThen":{"F":["internal::Into","internal::Map","internal::And","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or"],"G":["internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Map","internal::And"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","internal::Needed","<*mut T as std::fmt::Debug>","error::ErrorKind","number::Endianness"]},"internal::FlatMap":{"F":["internal::Map","internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["internal::Map","internal::AndThen","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::And","internal::Map","std::boxed::Box","internal::Or","internal::AndThen"],"G":["core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Into","internal::Or","internal::Map","internal::And"],"G":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::And","internal::Into","internal::FlatMap","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["std::marker::Sized","internal::Parser"],"C":["std::marker::Sized","internal::Parser"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"H":["std::marker::Sized","internal::Parser"],"I":["internal::Parser","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized","internal::Parser"],"K":["internal::Parser","std::marker::Sized"],"L":["std::marker::Sized","internal::Parser"],"M":["std::marker::Sized","internal::Parser"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into"],"B":["std::boxed::Box","internal::Into","internal::Map","internal::And","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or"],"C":["std::boxed::Box","internal::Map","internal::Or","internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Into"],"D":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::And","internal::FlatMap","internal::AndThen","internal::Or","std::boxed::Box"],"E":["internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::And","internal::Map","internal::Into","internal::FlatMap"],"Error":["error::Error","error::VerboseError"],"F":["internal::FlatMap","internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::Map"],"G":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::AndThen","internal::Into","internal::Map","internal::Or"],"H":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into","internal::FlatMap","internal::Or","internal::And","std::boxed::Box"],"I":["internal::AndThen","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","std::boxed::Box","internal::And"],"Input":["internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","internal::Needed","error::VerboseError","error::VerboseErrorKind","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>"],"J":["std::boxed::Box","internal::Or","internal::FlatMap","internal::Map","internal::Into","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>"],"K":["<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::AndThen","internal::Or","internal::Map","std::boxed::Box","internal::FlatMap"],"L":["internal::FlatMap","internal::And","std::boxed::Box","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map"],"M":["internal::Into","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box"],"Output":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::And","std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::AndThen"],"G":["internal::Or","internal::Map","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::FlatMap"]},"internal::AndThen":{"F":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Or"],"G":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::AndThen","internal::Or","std::boxed::Box","internal::Into"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","internal::Err","number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>"]},"internal::FlatMap":{"F":["internal::FlatMap","std::boxed::Box","internal::Into","internal::And","internal::Map","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>"],"G":["core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::Map","internal::Into","internal::Or","internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::Map","internal::And"],"G":["core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::Or","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::Into"],"G":["internal::And","internal::AndThen","std::boxed::Box","internal::Map","internal::FlatMap","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["std::marker::Sized","internal::Parser"],"C":["internal::Parser","std::marker::Sized"],"D":["std::marker::Sized","internal::Parser"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"H":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["internal::Parser","std::marker::Sized"],"K":["std::marker::Sized","internal::Parser"],"L":["internal::Parser","std::marker::Sized"],"M":["std::marker::Sized","internal::Parser"],"N":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice":{"A":["<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::AndThen"],"B":["internal::AndThen","internal::Or","internal::FlatMap","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box"],"C":["std::boxed::Box","internal::And","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::FlatMap"],"D":["internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::AndThen","internal::And","internal::Into"],"E":["internal::Into","std::boxed::Box","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Map"],"Error":["error::Error","error::VerboseError"],"F":["std::boxed::Box","internal::Into","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::AndThen"],"G":["internal::Or","internal::Into","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And"],"H":["internal::FlatMap","internal::AndThen","internal::Map","internal::And","internal::Into","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"I":["internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","std::boxed::Box","internal::FlatMap","internal::Into","internal::Or"],"Input":["error::VerboseError","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","error::ErrorKind","number::Endianness","internal::Err"],"J":["internal::Or","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::FlatMap","internal::And"],"K":["<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::Into","std::boxed::Box","internal::AndThen","internal::And","internal::Or"],"L":["internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::And"],"M":["internal::Map","internal::AndThen","internal::Or","internal::FlatMap","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into"],"N":["internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::And","internal::FlatMap","internal::AndThen"],"Output":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Or","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::AndThen","internal::FlatMap"],"G":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::And","std::boxed::Box","internal::AndThen"]},"internal::AndThen":{"F":["internal::FlatMap","internal::Map","internal::Into","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And"],"G":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::AndThen","internal::And","internal::Into","internal::Or","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed"]},"internal::FlatMap":{"F":["internal::AndThen","internal::Into","internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box"],"G":["std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["std::boxed::Box","internal::And","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Into","internal::AndThen","internal::And","internal::Map","internal::FlatMap"],"G":["core::str::IsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","internal::AndThen","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Into"],"G":["std::boxed::Box","internal::Or","internal::AndThen","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["std::marker::Sized","internal::Parser"],"D":["std::marker::Sized","internal::Parser"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized","internal::Parser"],"K":["std::marker::Sized","internal::Parser"],"L":["std::marker::Sized","internal::Parser"],"M":["internal::Parser","std::marker::Sized"],"N":["std::marker::Sized","internal::Parser"],"O":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::Map","internal::Or","std::boxed::Box"],"B":["internal::Map","internal::FlatMap","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::AndThen"],"C":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::And","internal::FlatMap","internal::Or"],"D":["std::boxed::Box","internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Or"],"E":["internal::Map","internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Or"],"Error":["error::VerboseError","error::Error"],"F":["internal::FlatMap","internal::And","std::boxed::Box","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into"],"G":["internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Map","internal::And","internal::AndThen","internal::FlatMap"],"H":["internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::AndThen","internal::FlatMap","internal::Into"],"I":["internal::AndThen","internal::Into","internal::Or","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box"],"Input":["error::VerboseError","error::VerboseErrorKind","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for &mut T>"],"J":["internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","std::boxed::Box","internal::Map","internal::FlatMap"],"K":["internal::Map","internal::FlatMap","internal::And","internal::AndThen","internal::Into","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>"],"L":["internal::Map","internal::Into","internal::FlatMap","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And"],"M":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::Or","internal::And","internal::AndThen","internal::Map","std::boxed::Box"],"N":["internal::Into","internal::Or","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","std::boxed::Box"],"O":["<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::FlatMap","internal::Or","internal::And","internal::Map","internal::AndThen"],"Output":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","std::boxed::Box","internal::Or","internal::Into","internal::AndThen","internal::Map"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into","internal::Or","internal::Map"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::Or"],"G":["internal::And","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Or","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind","number::Endianness"]},"internal::FlatMap":{"F":["internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Into","internal::FlatMap","internal::Map","internal::Or"],"G":["core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<!>>","u8"],"F":["internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::And","internal::AndThen","internal::FlatMap","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::And","std::boxed::Box","internal::AndThen","internal::Into","internal::Map"],"G":["core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Or","internal::Into","internal::Map","internal::AndThen","internal::FlatMap"],"G":["internal::And","std::boxed::Box","internal::Into","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"H":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized","internal::Parser"],"K":["internal::Parser","std::marker::Sized"],"L":["std::marker::Sized","internal::Parser"],"M":["std::marker::Sized","internal::Parser"],"N":["internal::Parser","std::marker::Sized"],"O":["std::marker::Sized","internal::Parser"],"Output":["std::marker::Sized"],"P":["std::marker::Sized","internal::Parser"]},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Map","internal::AndThen","internal::Or","std::boxed::Box","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"B":["internal::FlatMap","internal::And","internal::Map","std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or"],"C":["internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::FlatMap","internal::Or","internal::Map"],"D":["internal::And","std::boxed::Box","internal::FlatMap","internal::Into","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map"],"E":["internal::FlatMap","internal::AndThen","internal::Into","internal::And","internal::Or","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"Error":["error::Error","error::VerboseError"],"F":["internal::FlatMap","internal::AndThen","internal::Into","internal::And","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>"],"G":["internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::FlatMap","internal::And","internal::Map"],"H":["std::boxed::Box","internal::FlatMap","internal::Or","internal::Map","internal::And","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>"],"I":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::And"],"Input":["error::ErrorKind","error::VerboseErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>"],"J":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::And","internal::FlatMap","internal::AndThen","internal::Into","internal::Or"],"K":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::AndThen","std::boxed::Box","internal::Into","internal::Or","internal::FlatMap"],"L":["internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::Or"],"M":["internal::Or","std::boxed::Box","internal::Map","internal::AndThen","internal::FlatMap","internal::And","internal::Into","<F as internal::Parser<I, O, E>>"],"N":["internal::And","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::FlatMap","internal::Into","internal::AndThen"],"O":["internal::Into","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::And","internal::FlatMap"],"Output":["RUG_ANY"],"P":["internal::Into","internal::Map","std::boxed::Box","internal::Or","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Map","internal::FlatMap","internal::Or","internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"G":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::Into","std::boxed::Box","internal::And","internal::FlatMap","internal::AndThen"]},"internal::AndThen":{"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen"],"G":["internal::Map","internal::Or","internal::Into","internal::And","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Needed"]},"internal::FlatMap":{"F":["internal::Map","std::boxed::Box","internal::And","internal::FlatMap","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen"],"G":["core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","<T as std::convert::From<!>>","i8","u8"],"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::FlatMap","internal::Or","internal::AndThen","std::boxed::Box","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::Or","internal::Map","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Into","internal::And","internal::FlatMap","std::boxed::Box"],"G":["internal::Into","std::boxed::Box","internal::Or","internal::AndThen","internal::Map","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["std::marker::Sized","internal::Parser"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"H":["internal::Parser","std::marker::Sized"],"I":["internal::Parser","std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["internal::Parser","std::marker::Sized"],"K":["internal::Parser","std::marker::Sized"],"L":["std::marker::Sized","internal::Parser"],"M":["internal::Parser","std::marker::Sized"],"N":["internal::Parser","std::marker::Sized"],"O":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"],"P":["internal::Parser","std::marker::Sized"],"Q":["internal::Parser","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Into","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","std::boxed::Box"],"B":["internal::AndThen","internal::Into","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::And"],"C":["internal::FlatMap","internal::Into","internal::AndThen","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box"],"D":["internal::Map","std::boxed::Box","internal::FlatMap","internal::Into","internal::Or","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>"],"E":["internal::Or","internal::AndThen","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::FlatMap"],"Error":["error::Error","error::VerboseError"],"F":["internal::And","internal::Or","internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into"],"G":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","std::boxed::Box","internal::AndThen","internal::Or","internal::FlatMap","internal::And"],"H":["internal::AndThen","internal::Map","internal::FlatMap","internal::And","internal::Into","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>"],"I":["<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::AndThen","internal::Map","internal::FlatMap","internal::Or","std::boxed::Box"],"Input":["error::VerboseError","error::VerboseErrorKind","number::Endianness","internal::Needed","internal::Err","std::clone::impls::<impl std::clone::Clone for &mut T>","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>"],"J":["std::boxed::Box","internal::And","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::Or"],"K":["internal::AndThen","internal::And","internal::FlatMap","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into"],"L":["std::boxed::Box","internal::And","internal::FlatMap","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or"],"M":["internal::FlatMap","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Map","internal::And"],"N":["<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","internal::AndThen","internal::Or","internal::And"],"O":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::And","std::boxed::Box","internal::Into","internal::Or"],"Output":["RUG_ANY"],"P":["std::boxed::Box","internal::Into","internal::Map","internal::And","internal::AndThen","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"Q":["internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::LinesAnyMap"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Map","internal::Into","internal::And","std::boxed::Box","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or"],"G":["internal::Into","internal::FlatMap","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::And"]},"internal::AndThen":{"F":["internal::AndThen","internal::Or","internal::And","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into"],"G":["internal::Or","internal::Map","internal::Into","internal::And","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","internal::Err","number::Endianness","<*mut T as std::fmt::Debug>"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::Into","internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or"],"G":["core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::FlatMap","internal::And","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Map","internal::FlatMap","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","std::boxed::Box"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::AndThen","internal::And","internal::Or","internal::Into"],"G":["internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::Map","internal::FlatMap","internal::Or"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["std::marker::Sized","internal::Parser"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["internal::Parser","std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"H":["internal::Parser","std::marker::Sized"],"I":["internal::Parser","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["internal::Parser","std::marker::Sized"],"K":["internal::Parser","std::marker::Sized"],"L":["std::marker::Sized","internal::Parser"],"M":["std::marker::Sized","internal::Parser"],"N":["internal::Parser","std::marker::Sized"],"O":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"],"P":["std::marker::Sized","internal::Parser"],"Q":["std::marker::Sized","internal::Parser"],"R":["std::marker::Sized","internal::Parser"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","std::boxed::Box","internal::FlatMap","internal::Map","internal::AndThen"],"B":["internal::Into","internal::And","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::FlatMap"],"C":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::Map","internal::And","internal::Or","internal::FlatMap"],"D":["internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Into"],"E":["internal::Or","internal::And","internal::Into","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map"],"Error":["error::Error","error::VerboseError"],"F":["internal::Or","internal::Into","std::boxed::Box","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::Map"],"G":["internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","std::boxed::Box","internal::AndThen","internal::Map","internal::And"],"H":["internal::Into","std::boxed::Box","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::FlatMap"],"I":["internal::Map","internal::Into","internal::FlatMap","std::boxed::Box","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen"],"Input":["error::VerboseErrorKind","internal::Needed","number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::VerboseError"],"J":["internal::And","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Map","internal::Into"],"K":["std::boxed::Box","internal::Map","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::And"],"L":["<F as internal::Parser<I, O, E>>","internal::And","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","internal::Into"],"M":["internal::Map","internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::AndThen"],"N":["internal::Map","std::boxed::Box","internal::Or","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::Into"],"O":["internal::FlatMap","internal::Map","std::boxed::Box","internal::AndThen","internal::Or","internal::And","internal::Into","<F as internal::Parser<I, O, E>>"],"Output":["RUG_ANY"],"P":["internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::FlatMap","std::boxed::Box","internal::Or"],"Q":["<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Into","internal::Map","internal::FlatMap","internal::Or","internal::And"],"R":["internal::FlatMap","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Into","internal::Map"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","internal::AndThen","internal::And","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box"],"G":["internal::FlatMap","internal::And","internal::Map","internal::Into","internal::AndThen","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>"]},"internal::AndThen":{"F":["internal::FlatMap","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::Map","internal::AndThen"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","internal::Into","internal::Or"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","internal::Err","error::ErrorKind","number::Endianness","<*mut T as std::fmt::Debug>"]},"internal::FlatMap":{"F":["internal::Into","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::FlatMap","std::boxed::Box"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","i8","<T as std::convert::From<T>>","u8"],"F":["internal::Map","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box","internal::AndThen","internal::Into","internal::And"],"G":["std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box"],"G":["internal::FlatMap","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","std::boxed::Box","internal::Or"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["std::marker::Sized","internal::Parser"],"C":["std::marker::Sized","internal::Parser"],"D":["std::marker::Sized","internal::Parser"],"E":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["internal::Parser","std::marker::Sized"],"K":["std::marker::Sized","internal::Parser"],"L":["std::marker::Sized","internal::Parser"],"M":["internal::Parser","std::marker::Sized"],"N":["std::marker::Sized","internal::Parser"],"O":["std::marker::Sized","internal::Parser"],"Output":["std::marker::Sized"],"P":["std::marker::Sized","internal::Parser"],"Q":["internal::Parser","std::marker::Sized"],"R":["std::marker::Sized","internal::Parser"],"S":["internal::Parser","std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::AndThen","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::Map","std::boxed::Box"],"B":["internal::Map","internal::FlatMap","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Or"],"C":["internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","std::boxed::Box","internal::Map","internal::And"],"D":["internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Or","internal::AndThen","internal::Map","internal::Into"],"E":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::FlatMap","internal::And","internal::Or","std::boxed::Box"],"Error":["error::Error","error::VerboseError"],"F":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::FlatMap","internal::Map","std::boxed::Box","internal::Or"],"G":["internal::FlatMap","internal::Map","internal::And","internal::Into","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or"],"H":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Into","internal::Or","internal::Map","internal::And"],"I":["internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::And","internal::Into","internal::Or"],"Input":["error::VerboseErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for &mut T>","error::ErrorKind","number::Endianness","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &T>","internal::Err"],"J":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Into","internal::Or","internal::AndThen","internal::Map"],"K":["std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::And","internal::Or","internal::Map"],"L":["internal::Into","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::And"],"M":["<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","std::boxed::Box","internal::And","internal::Into","internal::Map","internal::FlatMap"],"N":["std::boxed::Box","internal::AndThen","internal::And","internal::Into","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or"],"O":["internal::FlatMap","internal::Map","internal::Into","internal::Or","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"Output":["RUG_ANY"],"P":["internal::Or","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::FlatMap","internal::AndThen"],"Q":["std::boxed::Box","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::FlatMap","internal::Map"],"R":["internal::Into","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>"],"S":["std::boxed::Box","internal::FlatMap","internal::Into","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Into","internal::Or","internal::AndThen","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap"],"G":["internal::And","internal::AndThen","internal::Into","internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map"]},"internal::AndThen":{"F":["internal::Map","std::boxed::Box","internal::FlatMap","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or"],"G":["std::boxed::Box","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::FlatMap","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","number::Endianness","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Or","std::boxed::Box","internal::Map"],"G":["core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::AndThen","internal::And","internal::Map","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>"],"G":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Or","std::boxed::Box","internal::FlatMap","internal::Into","internal::Map"],"G":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Map","internal::And","internal::FlatMap","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::marker::Sized","internal::Parser"],"B":["internal::Parser","std::marker::Sized"],"C":["internal::Parser","std::marker::Sized"],"D":["internal::Parser","std::marker::Sized"],"E":["std::marker::Sized","internal::Parser"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"H":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized","internal::Parser"],"K":["internal::Parser","std::marker::Sized"],"L":["std::marker::Sized","internal::Parser"],"M":["std::marker::Sized","internal::Parser"],"N":["std::marker::Sized","internal::Parser"],"O":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"],"P":["std::marker::Sized","internal::Parser"],"Q":["internal::Parser","std::marker::Sized"],"R":["internal::Parser","std::marker::Sized"],"S":["internal::Parser","std::marker::Sized"],"T":["std::marker::Sized","internal::Parser"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice":{"A":["std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Or","internal::And","internal::Into"],"B":["<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::AndThen","internal::Into","internal::FlatMap","internal::Map","internal::And"],"C":["internal::Or","internal::Map","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Into"],"D":["internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::And","internal::Into","internal::Map"],"E":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::AndThen","internal::Map","internal::Or","internal::FlatMap","internal::And"],"Error":["error::VerboseError","error::Error"],"F":["internal::Map","internal::Into","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::AndThen"],"G":["<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::And","std::boxed::Box","internal::Or","internal::FlatMap","internal::Into"],"H":["internal::And","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::Into","internal::AndThen"],"I":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Or","internal::FlatMap","internal::Into","internal::Map","std::boxed::Box"],"Input":["error::ErrorKind","error::VerboseError","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","internal::Needed","error::VerboseErrorKind"],"J":["internal::FlatMap","internal::Or","internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::Into"],"K":["std::boxed::Box","internal::Or","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Into"],"L":["<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Map","internal::Into","internal::And","internal::FlatMap","internal::Or"],"M":["internal::Or","internal::Map","std::boxed::Box","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap"],"N":["internal::Or","internal::AndThen","internal::Map","std::boxed::Box","internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>"],"O":["internal::AndThen","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::Into","internal::And"],"Output":["RUG_ANY"],"P":["std::boxed::Box","internal::Map","internal::FlatMap","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into"],"Q":["internal::Or","internal::Map","internal::And","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap"],"R":["internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Map","internal::AndThen","internal::Into","internal::Or"],"S":["internal::Map","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::Into","std::boxed::Box"],"T":["std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Or","internal::Map","internal::Into","internal::And","<F as internal::Parser<I, O, E>>"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::AndThen","internal::Map","std::boxed::Box","internal::And","internal::FlatMap"],"G":["internal::FlatMap","internal::Map","internal::Or","internal::Into","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen"]},"internal::AndThen":{"F":["internal::And","std::boxed::Box","internal::Into","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen"],"G":["internal::And","internal::AndThen","internal::Or","std::boxed::Box","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Needed","internal::Err","<*mut T as std::fmt::Debug>"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Into","internal::Map","internal::Or","std::boxed::Box","internal::AndThen"],"G":["std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<T>>","i8"],"F":["internal::Map","internal::AndThen","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::AndThen","std::boxed::Box","internal::Into","internal::Or","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>"],"G":["core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::FlatMap","internal::Into","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::AndThen"],"G":["<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::AndThen","internal::And","internal::Into","internal::Or","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"B":["internal::Parser","std::marker::Sized"],"C":["std::marker::Sized","internal::Parser"],"D":["std::marker::Sized","internal::Parser"],"E":["std::marker::Sized","internal::Parser"],"Error":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"H":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized","internal::Parser"],"K":["internal::Parser","std::marker::Sized"],"L":["internal::Parser","std::marker::Sized"],"M":["std::marker::Sized","internal::Parser"],"N":["internal::Parser","std::marker::Sized"],"O":["internal::Parser","std::marker::Sized"],"Output":["std::marker::Sized"],"P":["internal::Parser","std::marker::Sized"],"Q":["internal::Parser","std::marker::Sized"],"R":["internal::Parser","std::marker::Sized"],"S":["internal::Parser","std::marker::Sized"],"T":["internal::Parser","std::marker::Sized"],"U":["std::marker::Sized","internal::Parser"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Map","internal::And","internal::Or","std::boxed::Box","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into"],"B":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::Map","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::And"],"C":["internal::Or","internal::And","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Map"],"D":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","std::boxed::Box","internal::AndThen","internal::Or"],"E":["internal::FlatMap","internal::And","internal::Or","internal::AndThen","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into"],"Error":["error::Error","error::VerboseError"],"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::And","std::boxed::Box","internal::Or","internal::AndThen"],"G":["internal::AndThen","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::And","internal::FlatMap"],"H":["internal::Map","std::boxed::Box","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::AndThen"],"I":["internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::FlatMap","internal::Map","std::boxed::Box"],"Input":["error::VerboseErrorKind","internal::Err","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","internal::Needed"],"J":["internal::Into","std::boxed::Box","internal::FlatMap","internal::Or","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Map"],"K":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Map","internal::AndThen","internal::FlatMap","internal::Or"],"L":["internal::Or","internal::Into","std::boxed::Box","internal::AndThen","internal::Map","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>"],"M":["internal::And","internal::Map","internal::Or","internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"N":["internal::Or","internal::FlatMap","internal::And","internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"O":["internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::And","std::boxed::Box","internal::AndThen"],"Output":["RUG_ANY"],"P":["internal::Map","std::boxed::Box","internal::AndThen","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into"],"Q":["internal::FlatMap","internal::AndThen","internal::And","internal::Or","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"R":["internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::FlatMap","internal::Into","internal::AndThen","std::boxed::Box"],"S":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","internal::Or"],"T":["internal::Or","std::boxed::Box","internal::Map","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen"],"U":["std::boxed::Box","internal::Or","internal::FlatMap","internal::Into","internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I, O, E>>"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","std::boxed::Box","internal::Or"],"G":["internal::And","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::AndThen","internal::Or"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Into","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Or"],"G":["internal::Map","internal::Or","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","number::Endianness","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>"]},"internal::FlatMap":{"F":["internal::Into","internal::Map","internal::AndThen","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box"],"G":["core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<T>>","i8","<T as std::convert::From<!>>"],"F":["internal::FlatMap","internal::Map","internal::Into","internal::Or","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Or","internal::AndThen","internal::Into"],"G":["std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Map"],"G":["internal::AndThen","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Into","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(A,) as branch::Alt<Input, Output, Error>>::choice
deps:{"<&A as std::alloc::Allocator>":{},"<(A,) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Parser","std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"Input":["std::marker::Sized"],"Output":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(A,) as branch::Alt<Input, Output, Error>>::choice":{"A":["internal::Or","internal::FlatMap","internal::And","internal::Into","internal::AndThen","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"Error":["error::VerboseError","error::Error"],"Input":["RUG_ANY"],"Output":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Map","internal::AndThen","std::boxed::Box"],"G":["internal::And","internal::AndThen","internal::Map","std::boxed::Box","internal::FlatMap","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>"]},"internal::AndThen":{"F":["internal::Into","internal::Or","internal::FlatMap","internal::AndThen","internal::And","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["internal::AndThen","internal::FlatMap","internal::Into","std::boxed::Box","internal::Or","internal::Map","internal::And","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","internal::Needed","error::ErrorKind","internal::Err","<*const T as std::fmt::Debug>"]},"internal::FlatMap":{"F":["internal::Into","internal::AndThen","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Or"],"G":["core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Map","internal::AndThen","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::Map","internal::Or","internal::Into","internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","internal::And","std::boxed::Box","internal::Map","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen"],"G":["internal::And","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Into"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (A,)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.choice(p1);
+<(A,) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+crate::<(A,) as branch::Alt<Input, Output, Error>>::choice(p0, p1);
+<(A,)>::choice(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"FnA":["internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::AndThen","internal::Into","internal::And"],"FnB":["internal::Map","internal::FlatMap","internal::Into","internal::And","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or"],"Input":["number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","error::VerboseErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err"]},"<F as internal::Parser<I, O, E>>":{"F":["std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::And","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::FlatMap","internal::AndThen"],"G":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::Or"]},"internal::AndThen":{"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::AndThen","internal::Map","internal::FlatMap","internal::Into"],"G":["internal::Or","internal::FlatMap","internal::Into","internal::Map","internal::And","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","internal::Needed","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Or","internal::AndThen","std::boxed::Box"],"G":["core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Or","std::boxed::Box","internal::AndThen","internal::Map"],"G":["core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::Into","std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And"],"G":["std::boxed::Box","internal::Map","internal::Or","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB) as branch::Permutation<Input, (A, B), Error>>::permutation(p0, p1);
+<(FnA, FnB)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"FnA":["std::boxed::Box","internal::AndThen","internal::And","internal::Into","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map"],"FnB":["internal::And","internal::FlatMap","internal::Or","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into"],"FnC":["internal::Map","std::boxed::Box","internal::AndThen","internal::Or","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"Input":["error::VerboseErrorKind","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","error::VerboseError"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Map","internal::AndThen","internal::Into"],"G":["internal::And","internal::AndThen","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","std::boxed::Box"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::And","internal::Map","internal::AndThen","internal::Into","internal::Or"],"G":["internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::FlatMap","std::boxed::Box","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","number::Endianness","error::ErrorKind","internal::Needed","internal::Err"]},"internal::FlatMap":{"F":["internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::AndThen","internal::FlatMap","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<!>>","i8"],"F":["internal::And","internal::AndThen","internal::Or","internal::Into","internal::Map","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::And","internal::Map"],"G":["core::str::LinesAnyMap","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::AndThen","internal::Or","internal::And","std::boxed::Box"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Map","internal::FlatMap","internal::Or","std::boxed::Box","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC) as branch::Permutation<Input, (A, B, C), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"FnA":["internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::And"],"FnB":["internal::And","internal::Map","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::AndThen"],"FnC":["internal::And","internal::Into","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::AndThen"],"FnD":["internal::AndThen","internal::Into","internal::Map","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Or"],"Input":["number::Endianness","error::VerboseErrorKind","error::ErrorKind","error::VerboseError","internal::Needed","std::clone::impls::<impl std::clone::Clone for &T>","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>"]},"<F as internal::Parser<I, O, E>>":{"F":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::Map","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::AndThen"],"G":["internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::AndThen","std::boxed::Box","internal::Or"]},"internal::AndThen":{"F":["std::boxed::Box","internal::Map","internal::FlatMap","internal::Into","internal::And","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>"],"G":["internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::And","internal::AndThen","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","internal::Needed","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Map","internal::And","std::boxed::Box","internal::Into"],"G":["core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<T>>","u8","<T as std::convert::From<!>>"],"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::AndThen","std::boxed::Box","internal::Into","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::AndThen","internal::FlatMap"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["internal::Into","internal::And","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD) as branch::Permutation<Input, (A, B, C, D), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"Input":["std::clone::Clone","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"FnA":["std::boxed::Box","internal::AndThen","internal::Or","internal::Into","internal::Map","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>"],"FnB":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","std::boxed::Box","internal::AndThen","internal::Map","internal::And"],"FnC":["internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::AndThen","internal::Or","internal::FlatMap","std::boxed::Box"],"FnD":["internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Into","internal::Map","internal::FlatMap","std::boxed::Box"],"FnE":["std::boxed::Box","internal::And","internal::AndThen","internal::Or","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into"],"Input":["error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseErrorKind","internal::Err","error::VerboseError","internal::Needed","number::Endianness"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::LinesAnyMap","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["std::boxed::Box","internal::AndThen","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::Or"],"G":["internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::And"]},"internal::AndThen":{"F":["internal::Into","internal::FlatMap","internal::Or","internal::And","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen"],"G":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::Map","std::boxed::Box","internal::Into","internal::Or","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","internal::Err","internal::Needed","error::ErrorKind","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"internal::FlatMap":{"F":["internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Or","internal::Into","internal::Map"],"G":["core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Into","internal::And","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","internal::Or","internal::And","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into"],"G":["core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Map","internal::Or","internal::And","internal::Into"],"G":["internal::Map","std::boxed::Box","internal::Into","internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE) as branch::Permutation<Input, (A, B, C, D, E), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::FlatMap","internal::Or","internal::AndThen","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into"],"FnB":["internal::Map","internal::Or","internal::FlatMap","internal::And","internal::Into","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>"],"FnC":["internal::FlatMap","internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::Into"],"FnD":["std::boxed::Box","internal::AndThen","internal::Map","internal::And","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"FnE":["std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::Map","internal::AndThen","internal::Into"],"FnF":["std::boxed::Box","internal::AndThen","internal::Or","internal::Into","internal::FlatMap","internal::Map","internal::And","<F as internal::Parser<I, O, E>>"],"Input":["internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","number::Endianness","error::VerboseErrorKind"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","std::boxed::Box","internal::Into","internal::And","internal::Or","internal::FlatMap"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Or","internal::Into","internal::FlatMap","internal::AndThen"]},"internal::AndThen":{"F":["internal::And","internal::Into","internal::Map","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap"],"G":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Or","internal::And","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","internal::Err","number::Endianness","error::ErrorKind","internal::Needed"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Into","internal::Map","internal::And","std::boxed::Box","internal::AndThen"],"G":["core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<!>>","<T as std::convert::From<T>>"],"F":["internal::Into","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","std::boxed::Box","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Or","std::boxed::Box","internal::Map","internal::Into"],"G":["core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","internal::And","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>"],"G":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Into","internal::AndThen","std::boxed::Box","internal::Map"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF) as branch::Permutation<Input, (A, B, C, D, E, F), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"]},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::Or","internal::Into","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::And"],"FnB":["internal::Into","internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::And"],"FnC":["internal::Map","std::boxed::Box","internal::Into","internal::And","internal::Or","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"FnD":["<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::FlatMap","internal::Or","internal::Map","std::boxed::Box","internal::Into"],"FnE":["std::boxed::Box","internal::FlatMap","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::AndThen"],"FnF":["internal::Into","std::boxed::Box","internal::And","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap"],"FnG":["internal::Into","internal::AndThen","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::And"],"G":["RUG_ANY"],"Input":["error::VerboseErrorKind","internal::Err","internal::Needed","error::ErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Or","internal::FlatMap","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::And"],"G":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Map","internal::Or","internal::AndThen","internal::And","internal::Into"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Map","internal::Or","internal::Into","internal::And","internal::AndThen"],"G":["internal::FlatMap","internal::Or","internal::And","std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","internal::Needed"]},"internal::FlatMap":{"F":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Or","internal::FlatMap","internal::Into","internal::Map"],"G":["core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","i8","<T as std::convert::From<T>>","u8"],"F":["internal::Or","internal::And","internal::FlatMap","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Into","internal::Map","internal::FlatMap","std::boxed::Box","internal::Or"],"G":["std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Or","internal::Map","internal::Into"],"G":["internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Into","internal::And","std::boxed::Box","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as branch::Permutation<Input, (A, B, C, D, E, F, G), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Map","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Into","internal::Or","internal::And","<F as internal::Parser<I, O, E>>"],"FnB":["internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Map","internal::FlatMap","internal::Into","std::boxed::Box"],"FnC":["internal::AndThen","internal::Map","internal::FlatMap","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And"],"FnD":["internal::Into","internal::FlatMap","internal::Or","std::boxed::Box","internal::Map","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>"],"FnE":["internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::AndThen","internal::Into","internal::FlatMap"],"FnF":["internal::Map","std::boxed::Box","internal::FlatMap","internal::Into","internal::AndThen","internal::Or","internal::And","<F as internal::Parser<I, O, E>>"],"FnG":["internal::And","std::boxed::Box","internal::FlatMap","internal::Map","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or"],"FnH":["internal::And","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Or","internal::Into"],"G":["RUG_ANY"],"H":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","internal::Needed","error::ErrorKind","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","internal::Err"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::And","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or"],"G":["internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Map","internal::And","internal::FlatMap","internal::AndThen"]},"internal::AndThen":{"F":["internal::Or","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box"],"G":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Or","internal::And","internal::Map","internal::Into"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","<*const T as std::fmt::Debug>","number::Endianness","internal::Err","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Into","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Map","internal::FlatMap"],"G":["core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["std::boxed::Box","internal::FlatMap","internal::Or","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Map","internal::FlatMap","internal::Into","internal::AndThen","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And"],"G":["core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","std::boxed::Box","internal::Or","internal::FlatMap"],"G":["internal::Or","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as branch::Permutation<Input, (A, B, C, D, E, F, G, H), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::Map","std::boxed::Box","internal::AndThen","internal::FlatMap"],"FnB":["internal::AndThen","internal::And","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Or"],"FnC":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::AndThen","internal::FlatMap","internal::Map","internal::And"],"FnD":["internal::FlatMap","internal::Into","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Or"],"FnE":["internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Map","internal::Or","internal::Into"],"FnF":["internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::And","internal::Map","internal::Into"],"FnG":["internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Into"],"FnH":["internal::And","internal::Or","internal::FlatMap","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen"],"FnI":["internal::Into","internal::FlatMap","std::boxed::Box","internal::Map","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","internal::Needed","error::ErrorKind","internal::Err"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::And"],"G":["internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Or","internal::AndThen","std::boxed::Box"]},"internal::AndThen":{"F":["internal::Or","internal::FlatMap","internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And"],"G":["internal::AndThen","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","std::boxed::Box","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","number::Endianness","internal::Err"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::AndThen","internal::And","std::boxed::Box","internal::FlatMap","internal::Or"],"G":["core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::AndThen","internal::Into","internal::FlatMap","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into","internal::And","internal::Or"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","internal::FlatMap","std::boxed::Box","internal::Into","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::And","std::boxed::Box","internal::Into","internal::Or","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::And","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Into","std::boxed::Box"],"FnB":["internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Into","internal::Or","internal::AndThen"],"FnC":["internal::And","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::FlatMap","internal::Into"],"FnD":["internal::Into","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::FlatMap","internal::Or"],"FnE":["<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::And","internal::AndThen","internal::Map","std::boxed::Box","internal::FlatMap"],"FnF":["std::boxed::Box","internal::And","internal::AndThen","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap"],"FnG":["internal::Into","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::FlatMap","internal::Map"],"FnH":["<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","std::boxed::Box","internal::Into","internal::Map","internal::Or","internal::FlatMap"],"FnI":["internal::Or","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::And"],"FnJ":["internal::FlatMap","internal::Or","internal::Map","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseErrorKind","number::Endianness","error::ErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &T>","internal::Err","internal::Needed"],"J":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::AndThen","internal::Or","std::boxed::Box","internal::Into","internal::Map"],"G":["internal::AndThen","std::boxed::Box","internal::And","internal::Or","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Into","internal::And","internal::Map","internal::FlatMap","internal::Or"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::FlatMap","std::boxed::Box","internal::Or","internal::And","internal::Into"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed","number::Endianness","internal::Err","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Or","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::FlatMap","internal::Into"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","<T as std::convert::From<!>>","u8","i8"],"F":["internal::Into","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Or","internal::Map"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::And","internal::Map","internal::AndThen","std::boxed::Box","internal::Or"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::FlatMap","internal::Into","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::AndThen"],"G":["std::boxed::Box","internal::Map","internal::And","internal::FlatMap","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box","internal::AndThen","internal::Into"],"FnB":["std::boxed::Box","internal::Or","internal::Into","internal::And","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"FnC":["std::boxed::Box","internal::Map","internal::And","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or"],"FnD":["<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Into","internal::Or","internal::And"],"FnE":["internal::And","internal::FlatMap","internal::Into","std::boxed::Box","internal::Or","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>"],"FnF":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Map","std::boxed::Box","internal::FlatMap","internal::Into","internal::Or"],"FnG":["internal::Into","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::FlatMap","internal::Map"],"FnH":["internal::Map","internal::And","internal::AndThen","internal::FlatMap","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"FnI":["internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::AndThen","internal::Into","internal::Or","internal::And"],"FnJ":["internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::AndThen","internal::And","internal::Into","internal::Or"],"FnK":["internal::Into","internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::AndThen"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseErrorKind","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","internal::Needed","std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","internal::Err"],"J":["RUG_ANY"],"K":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["std::boxed::Box","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::Into","internal::FlatMap"],"G":["<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","std::boxed::Box","internal::And","internal::AndThen","internal::Into","internal::FlatMap"]},"internal::AndThen":{"F":["internal::Map","internal::FlatMap","internal::And","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box"],"G":["internal::FlatMap","internal::AndThen","internal::Or","internal::Into","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","error::ErrorKind","internal::Needed","number::Endianness","internal::Err"]},"internal::FlatMap":{"F":["internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","std::boxed::Box","internal::AndThen","internal::Or"],"G":["core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","<T as std::convert::From<!>>","i8","u8"],"F":["internal::Map","internal::Into","internal::Or","internal::And","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Or","internal::AndThen","internal::Into","internal::FlatMap"],"G":["core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","std::boxed::Box","internal::And","internal::Map","internal::Into","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>"],"G":["internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Or","internal::Into","internal::And"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Into","internal::And","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map"],"FnB":["internal::And","internal::Map","internal::AndThen","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or"],"FnC":["internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Into","std::boxed::Box"],"FnD":["internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Into","internal::Map","std::boxed::Box"],"FnE":["std::boxed::Box","internal::And","internal::Into","internal::AndThen","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"FnF":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::Into","internal::And","internal::AndThen","std::boxed::Box"],"FnG":["internal::AndThen","internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","std::boxed::Box"],"FnH":["<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Or","std::boxed::Box","internal::Into","internal::Map","internal::FlatMap"],"FnI":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::AndThen","internal::Map","internal::Into","std::boxed::Box","internal::And"],"FnJ":["<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Map","internal::FlatMap","internal::AndThen","internal::Into","std::boxed::Box"],"FnK":["internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Into","internal::And"],"FnL":["internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","std::boxed::Box","internal::FlatMap"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["internal::Needed","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","error::VerboseErrorKind"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Or","internal::Map","internal::Into"],"G":["internal::Or","internal::And","internal::AndThen","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Into","internal::Map","internal::And"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Into","internal::Or","internal::AndThen","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","<*mut T as std::fmt::Debug>","internal::Needed","error::ErrorKind","internal::Err"]},"internal::FlatMap":{"F":["internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Map","internal::FlatMap","internal::And"],"G":["core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<!>>","u8","<T as std::convert::From<T>>"],"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::And","std::boxed::Box","internal::Or","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","internal::AndThen","internal::Or","internal::Into","internal::Map","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>"],"G":["core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Or","internal::Map","internal::AndThen","std::boxed::Box"],"G":["<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Map","internal::Into","internal::AndThen","internal::Or","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["internal::Parser","std::marker::Sized"],"FnM":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Or","internal::And","internal::Into","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"FnB":["internal::FlatMap","internal::Map","internal::Into","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or"],"FnC":["std::boxed::Box","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Map","internal::And"],"FnD":["internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::FlatMap","internal::Or"],"FnE":["internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Or","internal::Into","internal::And"],"FnF":["internal::AndThen","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","internal::And","internal::Or","<F as internal::Parser<I, O, E>>"],"FnG":["internal::Into","internal::And","internal::Or","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map"],"FnH":["internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::AndThen","internal::FlatMap","internal::Into"],"FnI":["internal::And","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into"],"FnJ":["internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::And","internal::FlatMap","internal::Or","internal::Into"],"FnK":["internal::And","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::Into","std::boxed::Box"],"FnL":["<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Or","internal::FlatMap","internal::And","internal::Into","internal::Map"],"FnM":["internal::And","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Into","internal::Map"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["internal::Err","error::VerboseErrorKind","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","internal::Needed","error::VerboseError"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::str::LinesAnyMap"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Map","internal::Or","internal::AndThen","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And"],"G":["<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","internal::Or","internal::And","internal::AndThen"]},"internal::AndThen":{"F":["internal::Into","internal::AndThen","std::boxed::Box","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap"],"G":["std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::And","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","<*mut T as std::fmt::Debug>","number::Endianness","internal::Needed","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Or","internal::FlatMap","internal::Into","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen"],"G":["core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::Map","internal::Or","internal::AndThen","internal::And"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::Or","internal::AndThen","internal::And"],"G":["core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Into"],"G":["internal::Into","internal::Map","std::boxed::Box","internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Map","std::boxed::Box","internal::Or","internal::AndThen","internal::FlatMap"],"FnB":["internal::Map","internal::FlatMap","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::And"],"FnC":["internal::And","internal::AndThen","internal::Into","std::boxed::Box","internal::Map","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"FnD":["internal::And","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map"],"FnE":["internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::And","internal::Into","internal::Or"],"FnF":["internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::FlatMap","internal::Or","std::boxed::Box","internal::AndThen"],"FnG":["std::boxed::Box","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::Map","internal::And"],"FnH":["internal::AndThen","internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::FlatMap"],"FnI":["internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Into","internal::And"],"FnJ":["<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::Or","internal::AndThen","internal::And","internal::Map","internal::FlatMap"],"FnK":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::Map","internal::Into"],"FnL":["internal::Map","internal::AndThen","internal::Or","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And"],"FnM":["internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Or","internal::And","internal::Into"],"FnN":["<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::And","internal::FlatMap","internal::Or","internal::Into","internal::Map"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &T>","internal::Err","error::ErrorKind"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::And","std::boxed::Box","internal::Into","internal::Or","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>"],"G":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::And","internal::AndThen","internal::Into","internal::Map","internal::FlatMap"]},"internal::AndThen":{"F":["internal::And","internal::FlatMap","internal::Map","internal::Into","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Into","internal::Map","internal::And","internal::Or"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Needed","number::Endianness","internal::Err","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Map","internal::Or","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::And"],"G":["core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<!>>","<T as std::convert::From<T>>"],"F":["internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::FlatMap","internal::Or","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::AndThen","internal::Into","std::boxed::Box","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::And"],"G":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Into","internal::And","internal::FlatMap","std::boxed::Box","internal::Or","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>"],"G":["internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::And","internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Into"],"FnB":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::And","internal::Into","internal::FlatMap","internal::Map","internal::AndThen"],"FnC":["internal::AndThen","std::boxed::Box","internal::Into","internal::Or","internal::FlatMap","internal::And","internal::Map","<F as internal::Parser<I, O, E>>"],"FnD":["internal::Into","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::And","internal::FlatMap"],"FnE":["std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::FlatMap","internal::Or","internal::Map"],"FnF":["internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::And","internal::AndThen","internal::Into"],"FnG":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Map","internal::And","internal::Or","internal::Into","internal::FlatMap"],"FnH":["<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Map","internal::Or","internal::And"],"FnI":["internal::And","internal::Map","internal::FlatMap","internal::Into","internal::AndThen","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"FnJ":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Or","internal::And","internal::Into","internal::Map"],"FnK":["<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::And","internal::FlatMap","internal::Or","std::boxed::Box","internal::Into"],"FnL":["internal::Or","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","std::boxed::Box","internal::And"],"FnM":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::FlatMap","internal::AndThen","internal::Map","internal::Into"],"FnN":["internal::FlatMap","internal::AndThen","internal::Into","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box"],"FnO":["internal::And","internal::AndThen","std::boxed::Box","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Err","error::VerboseErrorKind","number::Endianness","error::ErrorKind"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::And","internal::Or","internal::Into","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen"],"G":["std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Map","internal::Or","internal::FlatMap"]},"internal::AndThen":{"F":["internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","std::boxed::Box","internal::AndThen","internal::Map"],"G":["internal::Into","internal::FlatMap","internal::And","internal::Or","internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","internal::Err","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"internal::FlatMap":{"F":["internal::And","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::Or"],"G":["core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","i8","<T as std::convert::From<T>>","u8"],"F":["internal::And","internal::FlatMap","internal::Or","std::boxed::Box","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::And","std::boxed::Box"],"G":["core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::Map","std::boxed::Box","internal::And","internal::FlatMap"],"G":["internal::AndThen","internal::Map","std::boxed::Box","internal::Into","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["internal::Parser","std::marker::Sized"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["std::marker::Sized","internal::Parser"],"FnP":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::And","internal::Or"],"FnB":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::Or","internal::FlatMap","internal::And","std::boxed::Box"],"FnC":["internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::Or","internal::Map","internal::FlatMap","internal::AndThen"],"FnD":["internal::Or","internal::Map","internal::FlatMap","internal::Into","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"FnE":["internal::Into","internal::Map","internal::AndThen","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap"],"FnF":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::And","internal::Map","internal::Into","internal::AndThen","internal::Or"],"FnG":["std::boxed::Box","internal::And","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::AndThen"],"FnH":["<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Into","internal::Map","std::boxed::Box","internal::And","internal::AndThen"],"FnI":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into","std::boxed::Box","internal::Or","internal::And","internal::FlatMap"],"FnJ":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::And","internal::AndThen","std::boxed::Box","internal::Or","internal::FlatMap"],"FnK":["std::boxed::Box","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Or","internal::AndThen"],"FnL":["internal::Or","std::boxed::Box","internal::FlatMap","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen"],"FnM":["internal::Or","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::And","std::boxed::Box"],"FnN":["internal::And","internal::Or","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"FnO":["internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","std::boxed::Box","internal::Into","internal::AndThen"],"FnP":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::And","std::boxed::Box","internal::Into","internal::Map","internal::FlatMap"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["internal::Err","error::VerboseError","internal::Needed","number::Endianness","std::clone::impls::<impl std::clone::Clone for &T>","error::ErrorKind","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::Into","internal::FlatMap"],"G":["internal::Into","internal::AndThen","internal::Or","internal::Map","internal::FlatMap","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>"]},"internal::AndThen":{"F":["internal::Or","internal::And","std::boxed::Box","internal::FlatMap","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen"],"G":["<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::AndThen","internal::Or","internal::FlatMap","internal::And","internal::Into"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","<*mut T as std::fmt::Debug>","internal::Needed","error::ErrorKind","internal::Err"]},"internal::FlatMap":{"F":["internal::Or","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Into","internal::And"],"G":["core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["internal::And","internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Map"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or"],"G":["core::str::IsWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Into","internal::And","internal::Or","std::boxed::Box","internal::AndThen"],"G":["internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::Into","std::boxed::Box","internal::Map"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["std::marker::Sized","internal::Parser"],"FnQ":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::FlatMap","std::boxed::Box","internal::Into","internal::AndThen","internal::And"],"FnB":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box","internal::Into"],"FnC":["internal::Map","internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::FlatMap"],"FnD":["internal::Map","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Into","internal::And"],"FnE":["<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::AndThen","internal::Map","internal::Into","internal::Or","std::boxed::Box"],"FnF":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::AndThen","internal::Map","std::boxed::Box","internal::Into","internal::And"],"FnG":["std::boxed::Box","internal::AndThen","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::FlatMap"],"FnH":["internal::Or","internal::Map","internal::And","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into"],"FnI":["internal::FlatMap","internal::And","std::boxed::Box","internal::Map","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into"],"FnJ":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::Into","internal::AndThen","std::boxed::Box","internal::And"],"FnK":["internal::Or","internal::And","std::boxed::Box","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map"],"FnL":["internal::FlatMap","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Or","internal::Into"],"FnM":["internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::And","internal::AndThen","internal::Map"],"FnN":["internal::FlatMap","std::boxed::Box","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::And"],"FnO":["internal::FlatMap","internal::Or","internal::AndThen","internal::Map","internal::Into","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"FnP":["internal::Into","internal::Map","internal::Or","internal::And","std::boxed::Box","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>"],"FnQ":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::Or","std::boxed::Box","internal::Map","internal::And"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","number::Endianness","error::ErrorKind","internal::Needed","error::VerboseError","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","internal::AndThen","internal::Into","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap"],"G":["internal::And","internal::AndThen","internal::Map","internal::FlatMap","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or"]},"internal::AndThen":{"F":["std::boxed::Box","internal::And","internal::Map","internal::Into","internal::Or","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"G":["internal::FlatMap","internal::Into","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","number::Endianness","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","std::boxed::Box","internal::FlatMap","internal::Or"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","u8","i8"],"F":["internal::Or","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::And","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Map","internal::And","internal::FlatMap"],"G":["core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Into","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And","std::boxed::Box"],"G":["std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Or","internal::FlatMap","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["std::marker::Sized","internal::Parser"],"FnP":["internal::Parser","std::marker::Sized"],"FnQ":["internal::Parser","std::marker::Sized"],"FnR":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Map","std::boxed::Box","internal::Into","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And"],"FnB":["internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::And","internal::Into","internal::AndThen","internal::Map"],"FnC":["internal::Into","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Or","internal::AndThen","internal::Map","internal::FlatMap"],"FnD":["std::boxed::Box","internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::And"],"FnE":["internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::FlatMap","internal::Map","internal::And","std::boxed::Box"],"FnF":["internal::Into","internal::Map","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Or"],"FnG":["internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::Or","internal::FlatMap","internal::And"],"FnH":["internal::Map","internal::Or","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Into"],"FnI":["internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box"],"FnJ":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::Or","internal::And","std::boxed::Box","internal::Map"],"FnK":["internal::Into","internal::Or","internal::AndThen","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And"],"FnL":["internal::Into","internal::And","internal::Or","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box"],"FnM":["internal::Or","internal::And","internal::Into","std::boxed::Box","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map"],"FnN":["internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Or","internal::And"],"FnO":["std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::AndThen","internal::And","internal::Into"],"FnP":["<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Map","internal::Or","internal::AndThen","std::boxed::Box","internal::And"],"FnQ":["internal::FlatMap","internal::Into","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::AndThen"],"FnR":["internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","std::boxed::Box","internal::Or","internal::Into"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","error::VerboseError","error::ErrorKind","internal::Err","error::VerboseErrorKind"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::And","internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map"],"G":["std::boxed::Box","internal::AndThen","internal::Or","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map"]},"internal::AndThen":{"F":["std::boxed::Box","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Or","internal::AndThen"],"G":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::FlatMap","internal::Or","internal::And","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","internal::Needed","error::ErrorKind","number::Endianness","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"]},"internal::FlatMap":{"F":["internal::Into","std::boxed::Box","internal::AndThen","internal::Or","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And"],"G":["core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["internal::Map","internal::Into","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::And","std::boxed::Box","internal::AndThen"],"G":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::AndThen","internal::FlatMap"],"G":["internal::And","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["internal::Parser","std::marker::Sized"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["std::marker::Sized","internal::Parser"],"FnQ":["internal::Parser","std::marker::Sized"],"FnR":["internal::Parser","std::marker::Sized"],"FnS":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::Or","internal::Into","internal::AndThen","internal::And","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"FnB":["internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Into","internal::And","internal::FlatMap","internal::Map"],"FnC":["<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Into","internal::Or","internal::Map"],"FnD":["internal::Or","internal::Into","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Map"],"FnE":["internal::And","internal::FlatMap","internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into"],"FnF":["internal::Or","internal::AndThen","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Into"],"FnG":["internal::Map","internal::FlatMap","internal::Into","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And"],"FnH":["internal::Into","internal::AndThen","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And"],"FnI":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::And"],"FnJ":["internal::Map","internal::AndThen","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::And"],"FnK":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::Map","internal::FlatMap","internal::Or","internal::AndThen","internal::And"],"FnL":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Or","internal::AndThen","internal::Map","internal::Into","internal::FlatMap"],"FnM":["internal::Into","internal::Or","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","std::boxed::Box"],"FnN":["std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Into","internal::Or","internal::FlatMap"],"FnO":["<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Into","internal::FlatMap","internal::Map","internal::And","std::boxed::Box"],"FnP":["internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::FlatMap","std::boxed::Box","internal::Map"],"FnQ":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::FlatMap","internal::Into","internal::Or","internal::Map"],"FnR":["std::boxed::Box","internal::And","internal::Or","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap"],"FnS":["internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","std::boxed::Box","internal::Into","internal::AndThen"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseError","internal::Err","error::ErrorKind","number::Endianness","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Needed","error::VerboseErrorKind"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"],"S":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Map","internal::Or","std::boxed::Box","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen"],"G":["internal::AndThen","internal::And","internal::FlatMap","internal::Or","internal::Into","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>"]},"internal::AndThen":{"F":["internal::Map","internal::Or","internal::Into","internal::AndThen","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["internal::FlatMap","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Or","internal::Into"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","number::Endianness"]},"internal::FlatMap":{"F":["internal::Into","internal::And","internal::FlatMap","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","u8","<T as std::convert::From<T>>","i8"],"F":["internal::AndThen","std::boxed::Box","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::Map","internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box"],"G":["core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::FlatMap","internal::Into","internal::Or","internal::Map","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>"],"G":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::Or","internal::Into","internal::And","internal::AndThen"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["internal::Parser","std::marker::Sized"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["internal::Parser","std::marker::Sized"],"FnO":["std::marker::Sized","internal::Parser"],"FnP":["std::marker::Sized","internal::Parser"],"FnQ":["internal::Parser","std::marker::Sized"],"FnR":["std::marker::Sized","internal::Parser"],"FnS":["std::marker::Sized","internal::Parser"],"FnT":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized"],"T":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Map","internal::Into","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::And"],"FnB":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::And","internal::Map","std::boxed::Box","internal::Or"],"FnC":["internal::AndThen","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","std::boxed::Box","internal::And"],"FnD":["internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And"],"FnE":["internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Map"],"FnF":["internal::Into","internal::Or","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Map"],"FnG":["internal::Into","internal::Or","internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box"],"FnH":["internal::And","internal::Or","internal::Map","internal::FlatMap","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen"],"FnI":["internal::And","internal::Into","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Or"],"FnJ":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Or","internal::Into","std::boxed::Box","internal::And"],"FnK":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Map","internal::FlatMap","internal::Into","internal::And","internal::AndThen"],"FnL":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Or","internal::Into","internal::AndThen","std::boxed::Box","internal::And"],"FnM":["internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::Into","internal::Or","internal::AndThen"],"FnN":["internal::FlatMap","internal::AndThen","internal::Into","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::And"],"FnO":["std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::And","internal::FlatMap","internal::AndThen"],"FnP":["internal::FlatMap","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","std::boxed::Box","internal::Map"],"FnQ":["internal::AndThen","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Or","internal::FlatMap"],"FnR":["internal::And","internal::Into","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>"],"FnS":["internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","std::boxed::Box","internal::Into"],"FnT":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::And","internal::Into","internal::FlatMap","internal::Map","std::boxed::Box"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","error::ErrorKind","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","error::VerboseError"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"],"S":["RUG_ANY"],"T":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Into","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Map","internal::AndThen"],"G":["internal::FlatMap","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::AndThen","internal::Map"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Map","internal::And","internal::Or","internal::Into","internal::FlatMap"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Or","internal::Into","std::boxed::Box","internal::Map","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","number::Endianness","internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Into","internal::FlatMap","internal::Or","internal::And"],"G":["core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","u8","<T as std::convert::From<!>>"],"F":["internal::Into","std::boxed::Box","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::FlatMap"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::And","internal::Into","internal::AndThen","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"G":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::Map","internal::And","internal::AndThen","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or"],"G":["internal::AndThen","internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT)>::permutation(p0, p1);
-----------------
src/branch/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["std::marker::Sized","internal::Parser"],"FnQ":["std::marker::Sized","internal::Parser"],"FnR":["internal::Parser","std::marker::Sized"],"FnS":["internal::Parser","std::marker::Sized"],"FnT":["std::marker::Sized","internal::Parser"],"FnU":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::Or","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::AndThen","std::boxed::Box"],"FnB":["std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And","internal::AndThen","internal::FlatMap"],"FnC":["internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Map","internal::And"],"FnD":["internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Into"],"FnE":["internal::Map","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Or","internal::FlatMap"],"FnF":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Into","internal::Map","std::boxed::Box","internal::Or"],"FnG":["internal::Map","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","std::boxed::Box","internal::FlatMap"],"FnH":["internal::Map","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Into","internal::AndThen"],"FnI":["internal::And","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or"],"FnJ":["internal::Into","internal::FlatMap","internal::And","internal::Or","std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>"],"FnK":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::Or","internal::FlatMap","internal::And","std::boxed::Box"],"FnL":["internal::Map","internal::And","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::Into"],"FnM":["internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::Into","std::boxed::Box","internal::FlatMap"],"FnN":["internal::Into","internal::FlatMap","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Or"],"FnO":["internal::AndThen","internal::And","internal::Map","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or"],"FnP":["<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Or","internal::Map","internal::And","internal::AndThen","std::boxed::Box"],"FnQ":["internal::Map","internal::Into","std::boxed::Box","internal::AndThen","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And"],"FnR":["std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Map","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::And"],"FnS":["internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::And","internal::AndThen"],"FnT":["internal::FlatMap","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Map","internal::Or"],"FnU":["internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Into","internal::Map","internal::And","<F as internal::Parser<I, O, E>>"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","error::VerboseErrorKind"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"],"S":["RUG_ANY"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Or","internal::Map","internal::Into"],"G":["std::boxed::Box","internal::And","internal::Into","internal::AndThen","internal::Map","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>"]},"internal::AndThen":{"F":["std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::Or","internal::And","internal::FlatMap"],"G":["internal::Or","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","internal::Err","number::Endianness","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","std::boxed::Box","internal::AndThen","internal::Map"],"G":["core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","u8","i8"],"F":["internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Or","internal::AndThen","internal::FlatMap"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Map","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::And","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>"],"G":["core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::Or","internal::And","std::boxed::Box","internal::Map","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>"],"G":["internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","std::boxed::Box","internal::Or","internal::Into"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.permutation(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as branch::Permutation<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::permutation(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU)>::permutation(p0, p1);
-----------------
src/combinator/mod.rs combinator::ParserIterator::<I, E, F>::finish
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"combinator::ParserIterator::<I, E, F>::finish":{"E":["std::marker::Sized"],"F":["std::marker::Sized"],"I":["std::marker::Sized","std::clone::Clone"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"combinator::ParserIterator::<I, E, F>::finish":{"E":["RUG_ANY"],"F":["RUG_ANY"],"I":["std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","error::ErrorKind","error::VerboseError","internal::Err","internal::Needed","error::VerboseErrorKind"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Needed","internal::Err","<*const T as std::fmt::Debug>","error::ErrorKind","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // combinator::ParserIterator<I, E, F>
+p0.finish();
+combinator::ParserIterator::<I, E, F>::finish(p0);
+crate::combinator::ParserIterator::<I, E, F>::finish(p0);
+<combinator::ParserIterator<I, E, F>>::finish(p0);
-----------------
src/combinator/mod.rs <&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next
'a
deps:{"<&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next":{"Error":["std::marker::Sized"],"F":["std::marker::Sized","std::ops::FnMut"],"Input":["std::marker::Sized","std::clone::Clone"],"Output":["std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next":{"Error":["RUG_ANY"],"F":["core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty"],"Input":["internal::Needed","std::clone::impls::<impl std::clone::Clone for &mut T>","number::Endianness","internal::Err","error::VerboseErrorKind","error::ErrorKind","error::VerboseError"],"Output":["RUG_ANY"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","number::Endianness","error::ErrorKind","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // combinator::ParserIterator<Input, Error, F>
+p0.next();
+<&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next(p0);
+crate::<&'a mut combinator::ParserIterator<Input, Error, F> as std::iter::Iterator>::next(p0);
+<&'a mut combinator::ParserIterator<Input, Error, F>>::next(p0);
-----------------
src/internal.rs <std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish
deps:{"<std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]}}
candidates:{"<std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::result::Result<(I, O), internal::Err<E>>
+p0.finish();
+<std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish(p0);
+crate::<std::result::Result<(I, O), internal::Err<E>> as internal::Finish<I, O, E>>::finish(p0);
+<std::result::Result<(I, O), internal::Err<E>>>::finish(p0);
-----------------
src/internal.rs <internal::Needed as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Needed
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<internal::Needed as std::fmt::Debug>::fmt(p0, p1);
+crate::<internal::Needed as std::fmt::Debug>::fmt(p0, p1);
+<internal::Needed>::fmt(p0, p1);
-----------------
src/internal.rs <internal::Needed as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Needed
let mut p1 = & MaybeUninit::uninit().assume_init(); // internal::Needed
+p0.eq(p1);
+<internal::Needed as std::cmp::PartialEq>::eq(p0, p1);
+crate::<internal::Needed as std::cmp::PartialEq>::eq(p0, p1);
+<internal::Needed>::eq(p0, p1);
-----------------
src/internal.rs <internal::Needed as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Needed
+p0.assert_receiver_is_total_eq();
+<internal::Needed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<internal::Needed as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<internal::Needed>::assert_receiver_is_total_eq(p0);
-----------------
src/internal.rs <internal::Needed as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Needed
+p0.clone();
+<internal::Needed as std::clone::Clone>::clone(p0);
+crate::<internal::Needed as std::clone::Clone>::clone(p0);
+<internal::Needed>::clone(p0);
-----------------
src/internal.rs internal::Needed::new
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+internal::Needed::new(p0);
+crate::internal::Needed::new(p0);
+<internal::Needed>::new(p0);
-----------------
src/internal.rs internal::Needed::is_known
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Needed
+p0.is_known();
+internal::Needed::is_known(p0);
+crate::internal::Needed::is_known(p0);
+<internal::Needed>::is_known(p0);
-----------------
src/internal.rs internal::Needed::map
deps:{"internal::Needed::map":{"F":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"internal::Needed::map":{"F":["std::boxed::Box<F, A>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Needed
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map(p1);
+internal::Needed::map(p0, p1);
+crate::internal::Needed::map(p0, p1);
+<internal::Needed>::map(p0, p1);
-----------------
src/internal.rs <internal::Err<E> as std::fmt::Debug>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<internal::Err<E> as std::fmt::Debug>::fmt":{"E":["std::marker::Sized","std::fmt::Debug"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::Eq"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<internal::Err<E> as std::fmt::Debug>::fmt":{"E":["error::VerboseErrorKind","number::Endianness","<*const T as std::fmt::Debug>","error::Error","internal::Err","error::ErrorKind","internal::Needed","traits::CompareResult","<&T as std::fmt::Debug>","error::VerboseError"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","number::Endianness","internal::Err","internal::Needed"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<internal::Err<E> as std::fmt::Debug>::fmt(p0, p1);
+crate::<internal::Err<E> as std::fmt::Debug>::fmt(p0, p1);
+<internal::Err<E>>::fmt(p0, p1);
-----------------
src/internal.rs <internal::Err<E> as std::clone::Clone>::clone
deps:{"<internal::Err<E> as std::clone::Clone>::clone":{"E":["std::clone::Clone","std::marker::Sized"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<internal::Err<E> as std::clone::Clone>::clone":{"E":["error::ErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","internal::Needed","error::VerboseErrorKind","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","number::Endianness","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
+p0.clone();
+<internal::Err<E> as std::clone::Clone>::clone(p0);
+crate::<internal::Err<E> as std::clone::Clone>::clone(p0);
+<internal::Err<E>>::clone(p0);
-----------------
src/internal.rs <internal::Err<E> as std::cmp::PartialEq>::eq
deps:{"<internal::Err<E> as std::cmp::PartialEq>::eq":{"E":["std::marker::Sized","std::cmp::PartialEq"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<internal::Err<E> as std::cmp::PartialEq>::eq":{"E":["number::Endianness","traits::CompareResult","error::Error","error::VerboseErrorKind","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","error::VerboseError","error::ErrorKind","internal::Err"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","internal::Needed","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
let mut p1 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
+p0.eq(p1);
+<internal::Err<E> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<internal::Err<E> as std::cmp::PartialEq>::eq(p0, p1);
+<internal::Err<E>>::eq(p0, p1);
-----------------
src/internal.rs internal::Err::<E>::is_incomplete
deps:{"internal::Err::<E>::is_incomplete":{"E":["std::marker::Sized"]}}
candidates:{"internal::Err::<E>::is_incomplete":{"E":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
+p0.is_incomplete();
+internal::Err::<E>::is_incomplete(p0);
+crate::internal::Err::<E>::is_incomplete(p0);
+<internal::Err<E>>::is_incomplete(p0);
-----------------
src/internal.rs internal::Err::<E>::map
deps:{"internal::Err::<E>::map":{"E":["std::marker::Sized"],"E2":["std::marker::Sized"],"F":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"internal::Err::<E>::map":{"E":["RUG_ANY"],"E2":["RUG_ANY"],"F":["core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<E>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map(p1);
+internal::Err::<E>::map(p0, p1);
+crate::internal::Err::<E>::map(p0, p1);
+<internal::Err<E>>::map(p0, p1);
-----------------
src/internal.rs internal::Err::<E>::convert
deps:{"internal::Err::<E>::convert":{"E":["std::marker::Sized","std::convert::From"],"F":["std::marker::Sized"]}}
candidates:{"internal::Err::<E>::convert":{"E":["char"],"F":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<F>
+internal::Err::<E>::convert(p0);
+crate::internal::Err::<E>::convert(p0);
+<internal::Err<E>>::convert(p0);
-----------------
src/internal.rs internal::Err::<(T, error::ErrorKind)>::map_input
deps:{"internal::Err::<(T, error::ErrorKind)>::map_input":{"F":["std::marker::Sized","std::ops::FnOnce"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"internal::Err::<(T, error::ErrorKind)>::map_input":{"F":["core::str::UnsafeBytesToStr","std::panic::AssertUnwindSafe<F>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::IsAsciiWhitespace"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<(T, error::ErrorKind)>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map_input(p1);
+internal::Err::<(T, error::ErrorKind)>::map_input(p0, p1);
+crate::internal::Err::<(T, error::ErrorKind)>::map_input(p0, p1);
+<internal::Err<(T, error::ErrorKind)>>::map_input(p0, p1);
-----------------
src/internal.rs internal::Err::<error::Error<T>>::map_input
deps:{"internal::Err::<error::Error<T>>::map_input":{"F":["std::marker::Sized","std::ops::FnOnce"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"internal::Err::<error::Error<T>>::map_input":{"F":["core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","std::panic::AssertUnwindSafe<F>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<error::Error<T>>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.map_input(p1);
+internal::Err::<error::Error<T>>::map_input(p0, p1);
+crate::internal::Err::<error::Error<T>>::map_input(p0, p1);
+<internal::Err<error::Error<T>>>::map_input(p0, p1);
-----------------
src/internal.rs internal::Err::<(&[u8], error::ErrorKind)>::to_owned
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<(&[u8], error::ErrorKind)>
+p0.to_owned();
+internal::Err::<(&[u8], error::ErrorKind)>::to_owned(p0);
+crate::internal::Err::<(&[u8], error::ErrorKind)>::to_owned(p0);
+<internal::Err<(&[u8], error::ErrorKind)>>::to_owned(p0);
-----------------
src/internal.rs internal::Err::<(&str, error::ErrorKind)>::to_owned
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<(&str, error::ErrorKind)>
+p0.to_owned();
+internal::Err::<(&str, error::ErrorKind)>::to_owned(p0);
+crate::internal::Err::<(&str, error::ErrorKind)>::to_owned(p0);
+<internal::Err<(&str, error::ErrorKind)>>::to_owned(p0);
-----------------
src/internal.rs internal::Err::<error::Error<&[u8]>>::to_owned
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<error::Error<&[u8]>>
+p0.to_owned();
+internal::Err::<error::Error<&[u8]>>::to_owned(p0);
+crate::internal::Err::<error::Error<&[u8]>>::to_owned(p0);
+<internal::Err<error::Error<&[u8]>>>::to_owned(p0);
-----------------
src/internal.rs internal::Err::<error::Error<&str>>::to_owned
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // internal::Err<error::Error<&str>>
+p0.to_owned();
+internal::Err::<error::Error<&str>>::to_owned(p0);
+crate::internal::Err::<error::Error<&str>>::to_owned(p0);
+<internal::Err<error::Error<&str>>>::to_owned(p0);
-----------------
src/internal.rs <internal::Err<E> as std::fmt::Display>::fmt
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<internal::Err<E> as std::fmt::Display>::fmt":{"E":["std::marker::Sized","std::fmt::Debug"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::fmt::Debug"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<internal::Err<E> as std::fmt::Display>::fmt":{"E":["<&mut T as std::fmt::Debug>","error::VerboseError","error::VerboseErrorKind","<*const T as std::fmt::Debug>","error::Error","traits::CompareResult","internal::Needed","number::Endianness","error::ErrorKind","internal::Err"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","number::Endianness","internal::Err","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<internal::Err<E> as std::fmt::Display>::fmt(p0, p1);
+crate::<internal::Err<E> as std::fmt::Display>::fmt(p0, p1);
+<internal::Err<E>>::fmt(p0, p1);
-----------------
src/internal.rs <internal::Err<E> as std::error::Error>::source
deps:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<internal::Err<E> as std::error::Error>::source":{"E":["std::marker::Sized","std::fmt::Debug"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]}}
candidates:{"<&T as std::fmt::Debug>":{},"<&mut T as std::fmt::Debug>":{},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<internal::Err<E> as std::error::Error>::source":{"E":["traits::CompareResult","internal::Err","error::VerboseErrorKind","<&T as std::fmt::Debug>","internal::Needed","error::ErrorKind","error::VerboseError","number::Endianness","error::Error"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","internal::Needed","<*const T as std::fmt::Debug>","error::ErrorKind","internal::Err"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // internal::Err<E>
+p0.source();
+<internal::Err<E> as std::error::Error>::source(p0);
+crate::<internal::Err<E> as std::error::Error>::source(p0);
+<internal::Err<E>>::source(p0);
-----------------
src/internal.rs <F as internal::Parser<I, O, E>>::parse
'a
deps:{"<F as internal::Parser<I, O, E>>::parse":{"E":["std::marker::Sized"],"F":["std::marker::Sized","std::ops::FnMut"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<F as internal::Parser<I, O, E>>::parse":{"E":["RUG_ANY"],"F":["core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte"],"I":["RUG_ANY"],"O":["RUG_ANY"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // F
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<F as internal::Parser<I, O, E>>::parse(p0, p1);
+crate::<F as internal::Parser<I, O, E>>::parse(p0, p1);
+<F>::parse(p0, p1);
-----------------
src/internal.rs <std::boxed::Box<(dyn internal::Parser<I, O, E> + 'a)> as internal::Parser<I, O, E>>::parse
'a
deps:{"<std::boxed::Box<(dyn internal::Parser<I, O, E> + 'a)> as internal::Parser<I, O, E>>::parse":{"E":["std::marker::Sized"],"I":["std::marker::Sized"],"O":["std::marker::Sized"]}}
candidates:{"<std::boxed::Box<(dyn internal::Parser<I, O, E> + 'a)> as internal::Parser<I, O, E>>::parse":{"E":["RUG_ANY"],"I":["RUG_ANY"],"O":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::boxed::Box<(dyn internal::Parser<I, O, E> + 'a)>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<std::boxed::Box<(dyn internal::Parser<I, O, E> + 'a)> as internal::Parser<I, O, E>>::parse(p0, p1);
+crate::<std::boxed::Box<(dyn internal::Parser<I, O, E> + 'a)> as internal::Parser<I, O, E>>::parse(p0, p1);
+<std::boxed::Box<(dyn internal::Parser<I, O, E> + 'a)>>::parse(p0, p1);
-----------------
src/internal.rs <internal::Map<F, G, O1> as internal::Parser<I, O2, E>>::parse
'a
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<internal::Map<F, G, O1> as internal::Parser<I, O2, E>>::parse":{"E":["std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<internal::Map<F, G, O1> as internal::Parser<I, O2, E>>::parse":{"E":["RUG_ANY"],"F":["internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::FlatMap","internal::Or"],"G":["core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"internal::And":{"F":["internal::FlatMap","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Into","internal::Or"],"G":["internal::And","internal::Or","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::AndThen"]},"internal::AndThen":{"F":["internal::Or","internal::AndThen","internal::Map","internal::And","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into"],"G":["internal::Into","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And"],"O1":["RUG_ANY"]},"internal::FlatMap":{"F":["internal::Or","internal::Map","internal::FlatMap","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box"],"G":["core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::Into","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::AndThen","internal::Into","internal::Map","internal::Or"],"G":["core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::Into","internal::FlatMap","internal::Or","internal::Map","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>"],"G":["<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::FlatMap","internal::Or","std::boxed::Box","internal::Into","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::Map<F, G, O1>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::Map<F, G, O1> as internal::Parser<I, O2, E>>::parse(p0, p1);
+crate::<internal::Map<F, G, O1> as internal::Parser<I, O2, E>>::parse(p0, p1);
+<internal::Map<F, G, O1>>::parse(p0, p1);
-----------------
src/internal.rs <internal::FlatMap<F, G, O1> as internal::Parser<I, O2, E>>::parse
'a
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<internal::FlatMap<F, G, O1> as internal::Parser<I, O2, E>>::parse":{"E":["std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"H":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<internal::FlatMap<F, G, O1> as internal::Parser<I, O2, E>>::parse":{"E":["RUG_ANY"],"F":["internal::AndThen","std::boxed::Box","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Into"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace"],"H":["internal::Into","internal::And","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::AndThen"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Map","internal::AndThen","internal::Or","std::boxed::Box","internal::Into"],"G":["internal::Or","std::boxed::Box","internal::Into","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen"]},"internal::AndThen":{"F":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Or"],"G":["std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::Map","internal::And","internal::Or"],"O1":["RUG_ANY"]},"internal::FlatMap":{"F":["internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","std::boxed::Box","internal::Into"],"G":["core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<T>>","u8","<T as std::convert::From<!>>"],"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::Into","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Or","internal::Map"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::Or","internal::Map"],"G":["core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::And","internal::FlatMap","internal::Into","internal::AndThen","internal::Map"],"G":["internal::And","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::FlatMap","internal::AndThen"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::FlatMap<F, G, O1>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::FlatMap<F, G, O1> as internal::Parser<I, O2, E>>::parse(p0, p1);
+crate::<internal::FlatMap<F, G, O1> as internal::Parser<I, O2, E>>::parse(p0, p1);
+<internal::FlatMap<F, G, O1>>::parse(p0, p1);
-----------------
src/internal.rs <internal::AndThen<F, G, O1> as internal::Parser<I, O2, E>>::parse
'a
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<internal::AndThen<F, G, O1> as internal::Parser<I, O2, E>>::parse":{"E":["std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<internal::AndThen<F, G, O1> as internal::Parser<I, O2, E>>::parse":{"E":["RUG_ANY"],"F":["internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen","internal::Into"],"G":["internal::Or","internal::AndThen","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Map"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"internal::And":{"F":["internal::AndThen","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::And","internal::Or"],"G":["internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::AndThen","std::boxed::Box","internal::Map","internal::And"]},"internal::AndThen":{"F":["internal::Or","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And"],"G":["<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::And","internal::Map","internal::AndThen","std::boxed::Box","internal::Into"],"O1":["RUG_ANY"]},"internal::FlatMap":{"F":["internal::Into","internal::Map","internal::FlatMap","internal::And","internal::AndThen","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","u8","<T as std::convert::From<T>>","i8"],"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::AndThen","internal::FlatMap","internal::And","internal::Or","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::AndThen","std::boxed::Box","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map"],"G":["core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","std::boxed::Box","internal::FlatMap","internal::And","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::Map","std::boxed::Box","internal::AndThen","internal::Or"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::AndThen<F, G, O1>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::AndThen<F, G, O1> as internal::Parser<I, O2, E>>::parse(p0, p1);
+crate::<internal::AndThen<F, G, O1> as internal::Parser<I, O2, E>>::parse(p0, p1);
+<internal::AndThen<F, G, O1>>::parse(p0, p1);
-----------------
src/internal.rs <internal::And<F, G> as internal::Parser<I, (O1, O2), E>>::parse
'a
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<internal::And<F, G> as internal::Parser<I, (O1, O2), E>>::parse":{"E":["std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<internal::And<F, G> as internal::Parser<I, (O1, O2), E>>::parse":{"E":["RUG_ANY"],"F":["internal::FlatMap","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::AndThen","internal::Into"],"G":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Into","internal::And"],"I":["RUG_ANY"],"O1":["RUG_ANY"],"O2":["RUG_ANY"]},"internal::And":{"F":["internal::And","internal::Map","internal::AndThen","internal::FlatMap","internal::Into","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>"],"G":["std::boxed::Box","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Into","internal::Or"]},"internal::AndThen":{"F":["std::boxed::Box","internal::Or","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::AndThen"],"G":["std::boxed::Box","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Map","internal::Into"],"O1":["RUG_ANY"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::FlatMap","internal::And","internal::Map","std::boxed::Box","internal::Into"],"G":["core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["std::boxed::Box","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::AndThen","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Map"],"G":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Or"],"G":["internal::Into","internal::And","internal::AndThen","internal::Or","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::And<F, G>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::And<F, G> as internal::Parser<I, (O1, O2), E>>::parse(p0, p1);
+crate::<internal::And<F, G> as internal::Parser<I, (O1, O2), E>>::parse(p0, p1);
+<internal::And<F, G>>::parse(p0, p1);
-----------------
src/internal.rs <internal::Or<F, G> as internal::Parser<I, O, E>>::parse
'a
deps:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<internal::Or<F, G> as internal::Parser<I, O, E>>::parse":{"E":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"I":["std::marker::Sized","std::clone::Clone"],"O":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<internal::Or<F, G> as internal::Parser<I, O, E>>::parse":{"E":["error::VerboseError","error::Error"],"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::FlatMap","internal::Into","internal::And","internal::Map"],"G":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::AndThen","internal::Or","internal::And","std::boxed::Box"],"I":["std::clone::impls::<impl std::clone::Clone for *mut T>","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError","internal::Needed","number::Endianness","internal::Err","error::ErrorKind"],"O":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Or","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into"],"G":["internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Or"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","std::boxed::Box","internal::Into","internal::Or","internal::AndThen","internal::And"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","std::boxed::Box","internal::Into","internal::FlatMap","internal::Or"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","number::Endianness"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Map","internal::Or","std::boxed::Box","internal::Into","internal::FlatMap"],"G":["core::str::LinesAnyMap","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Into","internal::Or","internal::Map","internal::FlatMap"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::And","internal::Or","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen"],"G":["core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Map","internal::Into","std::boxed::Box","internal::Or"],"G":["internal::Map","internal::FlatMap","std::boxed::Box","internal::Or","internal::Into","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::Or<F, G>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::Or<F, G> as internal::Parser<I, O, E>>::parse(p0, p1);
+crate::<internal::Or<F, G> as internal::Parser<I, O, E>>::parse(p0, p1);
+<internal::Or<F, G>>::parse(p0, p1);
-----------------
src/internal.rs <internal::Into<F, O1, O2, E1, E2> as internal::Parser<I, O2, E2>>::parse
'a
deps:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"<internal::Into<F, O1, O2, E1, E2> as internal::Parser<I, O2, E2>>::parse":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"I":["std::marker::Sized","std::clone::Clone"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"<internal::Into<F, O1, O2, E1, E2> as internal::Parser<I, O2, E2>>::parse":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","u8","<T as std::convert::From<T>>","i8"],"F":["internal::And","internal::AndThen","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::FlatMap"],"I":["error::VerboseError","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","error::VerboseErrorKind","error::ErrorKind","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>"],"O1":["RUG_ANY"],"O2":["char"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Into","internal::AndThen","internal::Map"],"G":["internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box","internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>"]},"internal::AndThen":{"F":["internal::FlatMap","internal::Or","internal::Map","internal::AndThen","internal::And","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["internal::Or","internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::ErrorKind","internal::Needed","number::Endianness"]},"internal::FlatMap":{"F":["internal::Into","std::boxed::Box","internal::Map","internal::AndThen","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","i8","<T as std::convert::From<T>>"],"F":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::Map","std::boxed::Box","internal::And","internal::FlatMap","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","internal::Into","internal::And","internal::FlatMap"],"G":["core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::FlatMap","internal::Map","internal::Or"],"G":["internal::FlatMap","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Or","internal::And"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // internal::Into<F, O1, O2, E1, E2>
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<internal::Into<F, O1, O2, E1, E2> as internal::Parser<I, O2, E2>>::parse(p0, p1);
+crate::<internal::Into<F, O1, O2, E1, E2> as internal::Parser<I, O2, E2>>::parse(p0, p1);
+<internal::Into<F, O1, O2, E1, E2>>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(F,) as sequence::Tuple<Input, (Output,), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(F,) as sequence::Tuple<Input, (Output,), Error>>::parse":{"Error":["std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"Input":["std::marker::Sized"],"Output":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::cmp::PartialEq","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(F,) as sequence::Tuple<Input, (Output,), Error>>::parse":{"Error":["error::Error","error::VerboseError"],"F":["internal::Into","internal::Map","std::boxed::Box","internal::And","internal::AndThen","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>"],"Input":["RUG_ANY"],"Output":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Into","internal::And","internal::AndThen","internal::FlatMap","internal::Map"],"G":["std::boxed::Box","internal::Map","internal::Or","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Map","internal::FlatMap","internal::AndThen","internal::And","internal::Into"],"G":["internal::Into","internal::Map","internal::FlatMap","internal::AndThen","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","internal::Needed"]},"internal::FlatMap":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","std::boxed::Box","internal::Map","internal::And","internal::Or"],"G":["core::str::LinesAnyMap","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","u8","<T as std::convert::From<!>>"],"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::Into","internal::And","internal::Map","std::boxed::Box","internal::FlatMap"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","internal::And"],"G":["core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","std::boxed::Box","internal::Map","internal::And","internal::FlatMap","internal::Into"],"G":["internal::Or","internal::Into","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::And"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (F,)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(F,) as sequence::Tuple<Input, (Output,), Error>>::parse(p0, p1);
+crate::<(F,) as sequence::Tuple<Input, (Output,), Error>>::parse(p0, p1);
+<(F,)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"FnA":["internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::AndThen","internal::Map","internal::Or","internal::Into"],"FnB":["internal::Into","internal::Or","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Map"],"Input":["internal::Err","internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &mut T>","number::Endianness","error::ErrorKind"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::AndThen","internal::And"],"G":["internal::Or","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map"]},"internal::AndThen":{"F":["internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Or","internal::AndThen","internal::Into"],"G":["std::boxed::Box","internal::FlatMap","internal::And","internal::Map","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","<*mut T as std::fmt::Debug>","internal::Needed","number::Endianness"]},"internal::FlatMap":{"F":["internal::Into","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Or","std::boxed::Box"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<T>>","i8","<T as std::convert::From<!>>"],"F":["internal::Into","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","internal::FlatMap","internal::Map","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Map","internal::AndThen","std::boxed::Box","internal::Into","internal::Or"],"G":["internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","std::boxed::Box","internal::Map","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse(p0, p1);
+crate::<(FnA, FnB) as sequence::Tuple<Input, (A, B), Error>>::parse(p0, p1);
+<(FnA, FnB)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"Input":["std::marker::Sized","std::clone::Clone"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::marker::Sized","std::clone::Clone"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"FnA":["internal::AndThen","internal::FlatMap","internal::Into","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Or"],"FnB":["internal::Or","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::Map","internal::Into"],"FnC":["internal::AndThen","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Or","internal::Map"],"Input":["number::Endianness","error::VerboseErrorKind","error::VerboseError","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed","std::clone::impls::<impl std::clone::Clone for &T>","error::ErrorKind"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And","internal::AndThen"],"G":["std::boxed::Box","internal::AndThen","internal::Map","internal::Into","internal::FlatMap","internal::And","internal::Or","<F as internal::Parser<I, O, E>>"]},"internal::AndThen":{"F":["internal::FlatMap","internal::Map","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","std::boxed::Box"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","std::boxed::Box","internal::Or","internal::Map","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","number::Endianness","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::And","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Map","internal::Into","internal::FlatMap"],"G":["core::str::IsAsciiWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<T>>","<T as std::convert::From<!>>","i8"],"F":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And","internal::AndThen","std::boxed::Box","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","std::boxed::Box","internal::FlatMap","internal::Map"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::And","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::AndThen"],"G":["internal::Map","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::And","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC) as sequence::Tuple<Input, (A, B, C), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"FnA":["std::boxed::Box","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Map","internal::Into"],"FnB":["internal::Or","internal::And","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","std::boxed::Box"],"FnC":["internal::FlatMap","internal::Into","internal::And","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or"],"FnD":["internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map"],"Input":["error::VerboseErrorKind","error::VerboseError","error::ErrorKind","number::Endianness","internal::Needed","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for *mut T>"]},"<F as internal::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsAsciiWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::FlatMap","internal::AndThen","internal::Map","internal::And"],"G":["internal::FlatMap","internal::AndThen","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Or"]},"internal::AndThen":{"F":["internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Or","internal::Into","internal::Map","internal::And","<F as internal::Parser<I, O, E>>"],"G":["internal::Map","std::boxed::Box","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Err","number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed"]},"internal::FlatMap":{"F":["internal::And","internal::FlatMap","internal::Into","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>"],"G":["core::str::UnsafeBytesToStr","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","i8","<T as std::convert::From<!>>"],"F":["internal::Map","internal::Into","internal::AndThen","std::boxed::Box","internal::Or","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into","internal::FlatMap","std::boxed::Box","internal::And"],"G":["core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","std::boxed::Box","internal::And","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map"],"G":["internal::Into","internal::FlatMap","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::And"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD) as sequence::Tuple<Input, (A, B, C, D), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"FnA":["internal::FlatMap","internal::AndThen","internal::And","internal::Into","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"FnB":["internal::FlatMap","internal::Into","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Map"],"FnC":["internal::Or","internal::Into","internal::Map","internal::And","internal::AndThen","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"FnD":["<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::FlatMap","internal::AndThen"],"FnE":["internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Into","internal::And","internal::Map"],"Input":["number::Endianness","error::VerboseError","internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseErrorKind"]},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::FlatMap","internal::Or","std::boxed::Box","internal::Into"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","internal::FlatMap","internal::And","internal::Into"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Map","internal::Or","internal::And","internal::Into","internal::FlatMap"],"G":["internal::And","std::boxed::Box","internal::FlatMap","internal::Into","internal::Map","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","internal::Needed"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::And","internal::Or","internal::Map"],"G":["core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","<T as std::convert::From<!>>","u8"],"F":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","std::boxed::Box","internal::And","internal::Or","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","std::boxed::Box","internal::Map","internal::Into","internal::AndThen","internal::And"],"G":["core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","std::boxed::Box","internal::FlatMap","internal::Or","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Into"],"G":["internal::And","internal::Map","internal::Or","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE) as sequence::Tuple<Input, (A, B, C, D, E), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::AndThen","internal::Into","internal::Or","internal::FlatMap","internal::Map"],"FnB":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::AndThen","std::boxed::Box","internal::Map","internal::FlatMap","internal::And"],"FnC":["std::boxed::Box","internal::And","internal::AndThen","internal::FlatMap","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into"],"FnD":["<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Or","internal::And","internal::AndThen","std::boxed::Box","internal::Map"],"FnE":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::Or","std::boxed::Box","internal::Map","internal::And"],"FnF":["std::boxed::Box","internal::Into","internal::FlatMap","internal::And","internal::Or","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>"],"Input":["internal::Needed","error::VerboseError","error::VerboseErrorKind","error::ErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["std::boxed::Box","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::And","internal::Into"],"G":["internal::AndThen","internal::FlatMap","internal::Into","internal::And","internal::Map","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Into","internal::Or","internal::AndThen","internal::FlatMap","internal::And"],"G":["internal::FlatMap","internal::And","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","internal::Needed","error::ErrorKind","<*const T as std::fmt::Debug>","number::Endianness"]},"internal::FlatMap":{"F":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","std::boxed::Box","internal::FlatMap","internal::Or","internal::Into"],"G":["core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<T>>","u8","<T as std::convert::From<!>>"],"F":["internal::And","internal::Into","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Map","internal::Into","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Or"],"G":["core::str::LinesAnyMap","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::FlatMap","std::boxed::Box","internal::Or","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen"],"G":["std::boxed::Box","internal::AndThen","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","internal::And"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF) as sequence::Tuple<Input, (A, B, C, D, E, F), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::fmt::Display"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::And"],"FnB":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::Into","internal::Or","internal::AndThen","internal::And"],"FnC":["internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Into","internal::FlatMap","internal::And"],"FnD":["internal::Or","internal::FlatMap","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::And"],"FnE":["internal::And","internal::Map","internal::Or","std::boxed::Box","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen"],"FnF":["internal::Map","internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"FnG":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::AndThen","internal::Or","internal::Into","internal::Map","std::boxed::Box"],"G":["RUG_ANY"],"Input":["internal::Needed","error::ErrorKind","error::VerboseErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseError"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Map","internal::AndThen","internal::And"],"G":["std::boxed::Box","internal::Into","internal::And","internal::Map","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen"]},"internal::AndThen":{"F":["internal::Map","internal::Or","internal::FlatMap","std::boxed::Box","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen"],"G":["internal::AndThen","std::boxed::Box","internal::Into","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map"],"O1":["RUG_ANY"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","<*const T as std::fmt::Debug>","number::Endianness","internal::Err"]},"internal::FlatMap":{"F":["internal::And","internal::Map","internal::Into","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>"],"G":["core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<T>>","u8"],"F":["internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Or","internal::Map","std::boxed::Box","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::AndThen","internal::And","internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map"],"G":["core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::FlatMap","internal::And"],"G":["<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::FlatMap","internal::Or","internal::Map","std::boxed::Box","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG) as sequence::Tuple<Input, (A, B, C, D, E, F, G), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"error::VerboseError":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::FlatMap","internal::Map","internal::And","std::boxed::Box","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or"],"FnB":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::Map","internal::AndThen","internal::Or","std::boxed::Box"],"FnC":["internal::Into","internal::And","internal::AndThen","internal::Map","internal::FlatMap","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"FnD":["internal::Into","internal::Or","internal::AndThen","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And"],"FnE":["internal::Map","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::AndThen","internal::FlatMap"],"FnF":["internal::And","internal::Or","internal::Into","internal::Map","internal::AndThen","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"FnG":["<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::AndThen","internal::Into","internal::Map","internal::FlatMap","std::boxed::Box"],"FnH":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::And","std::boxed::Box","internal::Into","internal::Map"],"G":["RUG_ANY"],"H":["RUG_ANY"],"Input":["internal::Needed","internal::Err","error::ErrorKind","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","number::Endianness"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","std::boxed::Box<F, A>"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Or","internal::AndThen","internal::Map","internal::And","std::boxed::Box"],"G":["<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::FlatMap","std::boxed::Box","internal::Into","internal::Map","internal::AndThen"]},"internal::AndThen":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::And","internal::Or","internal::Map"],"G":["internal::And","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::Map","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","internal::Err","error::ErrorKind","internal::Needed"]},"internal::FlatMap":{"F":["internal::And","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::FlatMap","internal::Or","internal::Map","std::boxed::Box"],"G":["core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","u8"],"F":["internal::FlatMap","internal::Into","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","std::boxed::Box"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::FlatMap","internal::Map","internal::Into","std::boxed::Box","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Or"],"G":["core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::Into","internal::FlatMap","internal::And","std::boxed::Box","internal::AndThen"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","std::boxed::Box","internal::Or","internal::AndThen","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"]},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["std::boxed::Box","internal::FlatMap","internal::AndThen","internal::And","internal::Into","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>"],"FnB":["std::boxed::Box","internal::AndThen","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Map"],"FnC":["internal::Or","std::boxed::Box","internal::AndThen","internal::Map","internal::FlatMap","internal::And","internal::Into","<F as internal::Parser<I, O, E>>"],"FnD":["std::boxed::Box","internal::FlatMap","internal::Or","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen"],"FnE":["internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::And"],"FnF":["<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::FlatMap","internal::Into","internal::AndThen","internal::And","internal::Or"],"FnG":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","std::boxed::Box","internal::Or","internal::Into","internal::FlatMap","internal::And"],"FnH":["internal::Map","internal::Or","internal::Into","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen"],"FnI":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","std::boxed::Box","internal::And","internal::FlatMap","internal::Map"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::ErrorKind","internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","number::Endianness","error::VerboseError","internal::Err","std::clone::impls::<impl std::clone::Clone for &mut T>"]},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::And","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Or","internal::Map"],"G":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Or","internal::AndThen","internal::FlatMap","std::boxed::Box","internal::Into"]},"internal::AndThen":{"F":["internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Or","internal::Map"],"G":["internal::And","internal::Or","std::boxed::Box","internal::Into","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","number::Endianness","internal::Needed","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::And","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::AndThen"],"G":["core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","i8","u8"],"F":["internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","std::boxed::Box","internal::And","internal::Map"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","std::boxed::Box","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Into"],"G":["core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Or","internal::And","std::boxed::Box","internal::Into","internal::FlatMap"],"G":["internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Map","internal::Into","std::boxed::Box"]},"std::boxed::Box":{"A":["std::alloc::Global","<&A as std::alloc::Allocator>","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","std::marker::Sized","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::AndThen","std::boxed::Box","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Into"],"FnB":["internal::Map","internal::And","internal::FlatMap","internal::Into","std::boxed::Box","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>"],"FnC":["<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Or","internal::AndThen","std::boxed::Box","internal::Map","internal::And"],"FnD":["internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Map","std::boxed::Box","internal::AndThen"],"FnE":["std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::AndThen","internal::Into","internal::FlatMap"],"FnF":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","std::boxed::Box","internal::Or","internal::And","internal::FlatMap"],"FnG":["internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::And","internal::AndThen","internal::FlatMap"],"FnH":["std::boxed::Box","internal::Into","internal::FlatMap","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::Or"],"FnI":["internal::Into","internal::AndThen","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::Map"],"FnJ":["internal::Into","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::Map","internal::AndThen"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseErrorKind","error::VerboseError","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for &T>","internal::Err","number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>"],"J":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Or","internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::Into"],"G":["internal::AndThen","internal::Into","std::boxed::Box","internal::And","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map"]},"internal::AndThen":{"F":["std::boxed::Box","internal::Map","internal::Into","internal::Or","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And"],"G":["internal::Or","internal::FlatMap","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","internal::Err","internal::Needed"]},"internal::FlatMap":{"F":["std::boxed::Box","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::Or","internal::And"],"G":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","u8","<T as std::convert::From<!>>"],"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Into","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Map","internal::Into","internal::And","internal::Or","internal::AndThen","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"G":["core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::Map","internal::FlatMap"],"G":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Into","internal::AndThen","internal::FlatMap","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::Map","internal::Or","internal::AndThen","std::boxed::Box","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And"],"FnB":["internal::Map","internal::And","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","std::boxed::Box"],"FnC":["internal::AndThen","internal::Or","internal::Into","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap"],"FnD":["internal::AndThen","std::boxed::Box","internal::And","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into"],"FnE":["internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::And","internal::Into","internal::FlatMap"],"FnF":["internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::Into","std::boxed::Box"],"FnG":["internal::FlatMap","internal::Or","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Into"],"FnH":["internal::AndThen","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Or","internal::And"],"FnI":["internal::Map","internal::Or","internal::And","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into"],"FnJ":["std::boxed::Box","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::Map","internal::Or"],"FnK":["internal::Into","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Or","internal::And"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Err","error::ErrorKind","number::Endianness","error::VerboseErrorKind","error::VerboseError","internal::Needed","std::clone::impls::<impl std::clone::Clone for *const T>"],"J":["RUG_ANY"],"K":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsWhitespace"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Map","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Or","internal::Into"],"G":["internal::And","std::boxed::Box","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::FlatMap"]},"internal::AndThen":{"F":["internal::Map","internal::FlatMap","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::And"],"G":["internal::FlatMap","internal::Map","internal::Or","internal::And","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","internal::Needed","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","error::ErrorKind","internal::Err"]},"internal::FlatMap":{"F":["internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map"],"G":["core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","u8","<T as std::convert::From<T>>","i8"],"F":["internal::Map","internal::And","internal::AndThen","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::FlatMap","internal::AndThen","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::And"],"G":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsNotEmpty"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::FlatMap","std::boxed::Box","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into"],"G":["internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Into","internal::Or","internal::Map"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::convert::From","error::ParseError","std::marker::Sized"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box","internal::FlatMap","internal::Or","internal::AndThen","internal::And"],"FnB":["internal::Into","std::boxed::Box","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Or"],"FnC":["std::boxed::Box","internal::AndThen","internal::Or","internal::FlatMap","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map"],"FnD":["std::boxed::Box","internal::And","internal::Or","internal::FlatMap","internal::Map","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>"],"FnE":["internal::AndThen","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::And","internal::Or"],"FnF":["internal::Or","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Map","internal::Into"],"FnG":["std::boxed::Box","internal::Into","internal::And","internal::Or","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map"],"FnH":["internal::Or","internal::Into","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And"],"FnI":["<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","std::boxed::Box","internal::And","internal::Or","internal::FlatMap","internal::Into"],"FnJ":["internal::And","internal::FlatMap","internal::Map","internal::AndThen","internal::Into","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"FnK":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::And","internal::Map","internal::FlatMap","internal::Or","internal::AndThen"],"FnL":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Map","std::boxed::Box","internal::AndThen","internal::And"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["number::Endianness","internal::Needed","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","error::ErrorKind","internal::Err","error::VerboseErrorKind"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::UnsafeBytesToStr"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::AndThen","internal::FlatMap","internal::Into","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And"],"G":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Into","internal::Or"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::Or","std::boxed::Box","internal::Into","internal::AndThen","internal::FlatMap","internal::Map"],"G":["internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Map","internal::Or","internal::Into","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","error::ErrorKind","number::Endianness","internal::Needed"]},"internal::FlatMap":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::AndThen","std::boxed::Box","internal::Or","internal::FlatMap","internal::Map"],"G":["core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<T>>","<T as std::convert::From<!>>","i8"],"F":["internal::Map","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["std::boxed::Box","internal::Into","internal::And","internal::AndThen","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or"],"G":["core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeUnicode"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::AndThen","internal::Map","internal::Into","internal::FlatMap"],"G":["internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::Into","std::boxed::Box","internal::AndThen"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone","std::cmp::Eq","std::marker::Sized"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::AndThen","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::Or","internal::Into"],"FnB":["<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::FlatMap","internal::Map","internal::And","internal::AndThen","std::boxed::Box"],"FnC":["<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Into","internal::Map","internal::Or","internal::And"],"FnD":["<F as internal::Parser<I, O, E>>","internal::And","internal::Into","std::boxed::Box","internal::AndThen","internal::Map","internal::FlatMap","internal::Or"],"FnE":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::Map","internal::AndThen","std::boxed::Box","internal::And"],"FnF":["internal::And","internal::Or","internal::FlatMap","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into"],"FnG":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::And","internal::Into","internal::Map","internal::Or","std::boxed::Box"],"FnH":["internal::FlatMap","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Into","internal::AndThen"],"FnI":["internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or"],"FnJ":["internal::Into","internal::And","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Or"],"FnK":["internal::Into","internal::FlatMap","internal::And","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or"],"FnL":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::And","internal::Or","std::boxed::Box","internal::FlatMap"],"FnM":["internal::FlatMap","internal::Map","internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["internal::Needed","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","error::ErrorKind","number::Endianness","error::VerboseError"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::CharEscapeUnicode","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::FlatMap","internal::Into","std::boxed::Box","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or"],"G":["internal::FlatMap","internal::Map","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::And"]},"internal::AndThen":{"F":["internal::Into","std::boxed::Box","internal::Map","internal::Or","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["internal::Map","internal::Or","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Err","internal::Needed","number::Endianness","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::Or"],"G":["core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","<T as std::convert::From<!>>","<T as std::convert::From<T>>","i8"],"F":["internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::Map","std::boxed::Box","internal::And","internal::FlatMap"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","std::boxed::Box","internal::And","internal::Map"],"G":["core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::And","internal::AndThen","std::boxed::Box"],"G":["internal::Map","std::boxed::Box","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Into"]},"std::boxed::Box":{"A":["std::alloc::System","<&A as std::alloc::Allocator>","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["internal::Parser","std::marker::Sized"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::convert::From","std::marker::Sized"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","internal::FlatMap","internal::And","internal::Into","std::boxed::Box"],"FnB":["internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::FlatMap","internal::Or","internal::AndThen"],"FnC":["internal::Into","internal::Or","internal::And","internal::Map","std::boxed::Box","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>"],"FnD":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Into","internal::Map","internal::FlatMap","internal::AndThen","internal::And"],"FnE":["internal::FlatMap","internal::And","internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::Or"],"FnF":["internal::FlatMap","internal::And","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::AndThen"],"FnG":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::And","internal::Map","internal::FlatMap","std::boxed::Box"],"FnH":["internal::Map","internal::Into","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::FlatMap"],"FnI":["std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::And","internal::Or","internal::AndThen"],"FnJ":["internal::Or","internal::Into","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::AndThen"],"FnK":["internal::AndThen","internal::And","std::boxed::Box","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or"],"FnL":["internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::AndThen","internal::Map","internal::And","internal::Or","internal::Into"],"FnM":["internal::Into","internal::Map","internal::AndThen","internal::FlatMap","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"FnN":["internal::Or","internal::And","internal::Map","internal::Into","std::boxed::Box","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["internal::Err","number::Endianness","error::ErrorKind","error::VerboseError","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","internal::Needed","std::clone::impls::<impl std::clone::Clone for &T>"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::Map","internal::Into","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen"],"G":["<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Or","internal::Into","internal::Map","internal::And","internal::FlatMap"]},"internal::AndThen":{"F":["internal::Map","internal::AndThen","internal::FlatMap","internal::And","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or"],"G":["internal::Into","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::AndThen","std::boxed::Box","internal::Map","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","internal::Needed","error::ErrorKind","number::Endianness","<*const T as std::fmt::Debug>"]},"internal::FlatMap":{"F":["internal::AndThen","internal::Map","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::And"],"G":["core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Map","internal::FlatMap","internal::AndThen","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::And","internal::AndThen","internal::Map","internal::FlatMap","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::And","std::boxed::Box","internal::Into","internal::Or","internal::FlatMap"],"G":["internal::And","internal::FlatMap","internal::Into","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug"]},"error::VerboseError":{"I":["std::clone::Clone","std::fmt::Display","std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::Map","internal::AndThen","internal::And","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or"],"FnB":["internal::Into","internal::Or","internal::Map","internal::FlatMap","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen"],"FnC":["<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::FlatMap","internal::Map","std::boxed::Box","internal::And","internal::AndThen"],"FnD":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::AndThen","internal::FlatMap","internal::Or"],"FnE":["std::boxed::Box","internal::Or","internal::FlatMap","internal::Into","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map"],"FnF":["internal::Or","internal::And","internal::AndThen","std::boxed::Box","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"FnG":["internal::And","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::FlatMap","internal::Into"],"FnH":["internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::And","internal::FlatMap","internal::Into","std::boxed::Box"],"FnI":["internal::AndThen","internal::FlatMap","std::boxed::Box","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into"],"FnJ":["internal::Into","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Or","internal::And"],"FnK":["internal::Into","internal::And","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","std::boxed::Box"],"FnL":["internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into","internal::AndThen","internal::Map","std::boxed::Box"],"FnM":["internal::FlatMap","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Into","internal::Or"],"FnN":["internal::Or","internal::And","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into"],"FnO":["internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","std::boxed::Box","internal::Into","internal::Map","internal::Or"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseError","std::clone::impls::<impl std::clone::Clone for &mut T>","std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","error::ErrorKind","internal::Needed","number::Endianness","internal::Err"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Map","internal::And","internal::FlatMap","internal::AndThen","internal::Into","internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>"],"G":["internal::And","internal::FlatMap","internal::AndThen","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into"]},"internal::AndThen":{"F":["internal::Or","std::boxed::Box","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::Map","internal::And"],"G":["internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Map","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::Map","std::boxed::Box","internal::And","internal::AndThen","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>"],"G":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","<T as std::convert::From<T>>","u8","<T as std::convert::From<!>>"],"F":["internal::Map","internal::AndThen","internal::And","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into","internal::And","std::boxed::Box"],"G":["core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::FlatMap","internal::AndThen","std::boxed::Box"],"G":["std::boxed::Box","internal::Map","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::Global","std::alloc::System","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["internal::Parser","std::marker::Sized"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["std::marker::Sized","internal::Parser"],"FnP":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"internal::And":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","std::convert::From","error::ParseError"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["internal::Parser","std::marker::Sized"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And","internal::AndThen","internal::Into","std::boxed::Box"],"FnB":["<F as internal::Parser<I, O, E>>","internal::And","internal::Into","internal::AndThen","internal::Map","std::boxed::Box","internal::FlatMap","internal::Or"],"FnC":["std::boxed::Box","internal::And","internal::Into","internal::Map","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen"],"FnD":["internal::Or","internal::And","std::boxed::Box","internal::FlatMap","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map"],"FnE":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::And","std::boxed::Box","internal::Map","internal::Into","internal::Or"],"FnF":["internal::Or","internal::AndThen","internal::And","internal::FlatMap","std::boxed::Box","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>"],"FnG":["internal::AndThen","std::boxed::Box","internal::Into","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or"],"FnH":["internal::FlatMap","internal::Map","internal::Or","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","std::boxed::Box"],"FnI":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::Map","std::boxed::Box","internal::Into","internal::AndThen","internal::And"],"FnJ":["internal::Or","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::FlatMap","internal::Map","internal::And"],"FnK":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::And","internal::Map","internal::Or","internal::Into"],"FnL":["internal::Into","internal::Or","internal::Map","internal::AndThen","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"FnM":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Into","std::boxed::Box","internal::Or","internal::And","internal::Map"],"FnN":["internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::FlatMap","std::boxed::Box","internal::Into"],"FnO":["std::boxed::Box","internal::FlatMap","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::Map"],"FnP":["internal::Or","internal::Map","internal::FlatMap","internal::And","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Needed","internal::Err","number::Endianness","error::VerboseError","error::ErrorKind"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["internal::Or","internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::And","std::boxed::Box"],"G":["internal::Or","internal::And","internal::Map","internal::AndThen","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap"]},"internal::AndThen":{"F":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Map","internal::Into","internal::Or","internal::FlatMap","internal::AndThen"],"G":["internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::AndThen","internal::Map","std::boxed::Box","internal::FlatMap"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","number::Endianness","internal::Needed","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Into","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","std::boxed::Box","internal::FlatMap"],"G":["core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::Or","internal::And","std::boxed::Box","internal::FlatMap","internal::AndThen"],"G":["std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::IsWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["std::boxed::Box","internal::Into","internal::Or","internal::Map","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::Into","std::boxed::Box","internal::AndThen","internal::Map"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::Global","std::alloc::System"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["std::marker::Sized","internal::Parser"],"FnQ":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["std::marker::Sized","error::ParseError","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["internal::Map","internal::And","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>"],"FnB":["internal::And","internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map"],"FnC":["internal::Into","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::FlatMap","std::boxed::Box"],"FnD":["internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::FlatMap","internal::Map","std::boxed::Box","internal::And"],"FnE":["<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Map","internal::Or","std::boxed::Box","internal::AndThen","internal::Into"],"FnF":["internal::AndThen","internal::Map","std::boxed::Box","internal::Or","internal::And","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Into"],"FnG":["internal::FlatMap","internal::AndThen","internal::Or","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box"],"FnH":["internal::AndThen","internal::FlatMap","internal::Into","internal::Map","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box"],"FnI":["internal::AndThen","internal::FlatMap","internal::Into","internal::And","std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>"],"FnJ":["internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Into"],"FnK":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Into","internal::Map","internal::And","std::boxed::Box","internal::Or"],"FnL":["<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::AndThen"],"FnM":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::And","internal::Map","internal::Into","internal::Or","std::boxed::Box"],"FnN":["internal::And","internal::Into","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::AndThen","internal::Or","internal::Map"],"FnO":["internal::Into","internal::And","internal::FlatMap","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or"],"FnP":["std::boxed::Box","internal::And","internal::FlatMap","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into"],"FnQ":["internal::Into","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap","internal::Or","internal::And"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["error::ErrorKind","error::VerboseError","number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Needed","error::VerboseErrorKind"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["internal::Into","internal::Or","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Map"],"G":["internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Into","internal::AndThen","internal::And","internal::Or"]},"internal::AndThen":{"F":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::FlatMap","internal::Into","internal::AndThen","internal::And"],"G":["std::boxed::Box","internal::And","internal::Into","internal::FlatMap","internal::Map","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","internal::Err","error::ErrorKind","number::Endianness","<*mut T as std::fmt::Debug>"]},"internal::FlatMap":{"F":["internal::AndThen","internal::Or","internal::Map","internal::Into","std::boxed::Box","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>"],"G":["core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<!>>","i8","u8","<T as std::convert::From<T>>"],"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::AndThen","std::boxed::Box","internal::And","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::AndThen","internal::FlatMap","internal::And","std::boxed::Box","internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map"],"G":["std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Map","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::FlatMap","internal::Into"],"G":["internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","internal::And","internal::Into","std::boxed::Box","internal::AndThen"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["std::marker::Sized","internal::Parser"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["internal::Parser","std::marker::Sized"],"FnP":["std::marker::Sized","internal::Parser"],"FnQ":["std::marker::Sized","internal::Parser"],"FnR":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::convert::From","std::marker::Sized"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::VerboseError","error::Error"],"F":["RUG_ANY"],"FnA":["std::boxed::Box","internal::Or","internal::FlatMap","internal::Into","internal::Map","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>"],"FnB":["internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::Or","internal::Into","internal::Map"],"FnC":["<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","std::boxed::Box","internal::And","internal::Map","internal::FlatMap","internal::AndThen"],"FnD":["std::boxed::Box","internal::Map","internal::FlatMap","internal::AndThen","internal::And","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>"],"FnE":["internal::AndThen","internal::Or","internal::Map","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","std::boxed::Box"],"FnF":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::FlatMap","internal::AndThen","internal::Or","std::boxed::Box","internal::Into"],"FnG":["internal::FlatMap","internal::Map","internal::And","internal::AndThen","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>","internal::Or"],"FnH":["std::boxed::Box","internal::FlatMap","internal::Into","internal::AndThen","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::And"],"FnI":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::And","internal::Or","internal::Into","std::boxed::Box","internal::Map"],"FnJ":["internal::FlatMap","internal::And","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::Map","internal::AndThen"],"FnK":["internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Into","std::boxed::Box","internal::AndThen","internal::Or"],"FnL":["internal::And","internal::Into","internal::FlatMap","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box"],"FnM":["internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","std::boxed::Box","internal::Map","internal::FlatMap"],"FnN":["internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","internal::Or"],"FnO":["internal::Or","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::AndThen","std::boxed::Box"],"FnP":["<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box","internal::Map","internal::AndThen","internal::Into","internal::And","internal::FlatMap"],"FnQ":["internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::And","internal::Into","internal::FlatMap"],"FnR":["internal::AndThen","internal::Or","internal::FlatMap","internal::Into","internal::Map","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for *const T>","error::VerboseErrorKind","number::Endianness","error::ErrorKind","internal::Err","std::clone::impls::<impl std::clone::Clone for &mut T>","error::VerboseError","internal::Needed"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::IsWhitespace","core::str::CharEscapeDebugContinue"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","error::Error","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Into","internal::FlatMap"],"G":["internal::Into","internal::FlatMap","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::AndThen","internal::Or"]},"internal::AndThen":{"F":["std::boxed::Box","internal::Map","internal::And","internal::Or","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap","internal::AndThen"],"G":["std::boxed::Box","internal::FlatMap","internal::Map","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","error::ErrorKind","internal::Err","std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed"]},"internal::FlatMap":{"F":["internal::Map","internal::And","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","std::boxed::Box","internal::AndThen"],"G":["core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<T>>"],"F":["internal::Into","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Or"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::FlatMap","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","std::boxed::Box","internal::Map"],"G":["core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","std::boxed::Box","internal::Map","internal::AndThen","internal::And","internal::Or"],"G":["std::boxed::Box","internal::Into","internal::And","internal::FlatMap","internal::AndThen","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["std::marker::Sized","error::ParseError"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["internal::Parser","std::marker::Sized"],"FnD":["internal::Parser","std::marker::Sized"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["internal::Parser","std::marker::Sized"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["internal::Parser","std::marker::Sized"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["std::marker::Sized","internal::Parser"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["std::marker::Sized","internal::Parser"],"FnP":["std::marker::Sized","internal::Parser"],"FnQ":["std::marker::Sized","internal::Parser"],"FnR":["std::marker::Sized","internal::Parser"],"FnS":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::clone::Clone","std::marker::Sized"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["std::marker::Sized","std::ops::FnMut"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::marker::Sized","std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::cmp::Eq","std::clone::Clone"]},"internal::FlatMap":{"F":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"std::boxed::Box":{"A":["std::alloc::Allocator","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","internal::Or","std::boxed::Box","internal::Into"],"FnB":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::And","internal::Into","std::boxed::Box","internal::AndThen","internal::FlatMap"],"FnC":["internal::AndThen","internal::Into","std::boxed::Box","internal::FlatMap","internal::And","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>"],"FnD":["internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::Into","std::boxed::Box","internal::FlatMap"],"FnE":["internal::AndThen","std::boxed::Box","internal::Into","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap"],"FnF":["internal::Into","internal::AndThen","std::boxed::Box","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap"],"FnG":["internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Or","internal::FlatMap","internal::Into"],"FnH":["internal::FlatMap","internal::And","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Or","std::boxed::Box"],"FnI":["internal::AndThen","std::boxed::Box","internal::Map","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::And"],"FnJ":["internal::Or","std::boxed::Box","internal::And","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::Into","internal::FlatMap"],"FnK":["internal::Into","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::AndThen","internal::FlatMap"],"FnL":["<F as internal::Parser<I, O, E>>","internal::Or","internal::AndThen","internal::FlatMap","internal::Into","internal::And","std::boxed::Box","internal::Map"],"FnM":["internal::And","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","std::boxed::Box","internal::Map","internal::FlatMap","internal::Or"],"FnN":["internal::Into","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::FlatMap","std::boxed::Box"],"FnO":["<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::Map","internal::And","std::boxed::Box","internal::AndThen","internal::FlatMap"],"FnP":["internal::AndThen","internal::Or","internal::Into","internal::Map","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::And"],"FnQ":["<F as internal::Parser<I, O, E>>","internal::Or","internal::And","std::boxed::Box","internal::FlatMap","internal::Map","internal::AndThen","internal::Into"],"FnR":["internal::Into","internal::AndThen","internal::Or","std::boxed::Box","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And"],"FnS":["internal::And","internal::Into","internal::Or","internal::Map","internal::FlatMap","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for &mut T>","internal::Needed","error::VerboseError","std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseErrorKind","number::Endianness","internal::Err","error::ErrorKind"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"],"S":["RUG_ANY"]},"<*mut T as std::fmt::Debug>":{},"<F as internal::Parser<I, O, E>>":{"F":["core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::slice::ascii::EscapeByte"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::Into","internal::Or","std::boxed::Box","internal::AndThen","internal::FlatMap"],"G":["internal::And","internal::FlatMap","internal::Or","internal::Map","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into"]},"internal::AndThen":{"F":["internal::Into","internal::Or","internal::FlatMap","internal::Map","internal::AndThen","std::boxed::Box","internal::And","<F as internal::Parser<I, O, E>>"],"G":["internal::Or","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::Into","internal::AndThen","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Needed","internal::Err","error::ErrorKind"]},"internal::FlatMap":{"F":["internal::Into","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::FlatMap","internal::And","std::boxed::Box"],"G":["core::str::IsWhitespace","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["<T as std::convert::From<T>>","i8","u8","<T as std::convert::From<!>>"],"F":["internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::AndThen","internal::Into"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::And","internal::Into","std::boxed::Box","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::FlatMap"],"G":["core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::AndThen","std::boxed::Box","internal::Into"],"G":["std::boxed::Box","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::And","internal::FlatMap","internal::Into","internal::Map"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["internal::Parser","std::marker::Sized"],"FnB":["std::marker::Sized","internal::Parser"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["std::marker::Sized","internal::Parser"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["std::marker::Sized","internal::Parser"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["std::marker::Sized","internal::Parser"],"FnK":["std::marker::Sized","internal::Parser"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["std::marker::Sized","internal::Parser"],"FnP":["std::marker::Sized","internal::Parser"],"FnQ":["std::marker::Sized","internal::Parser"],"FnR":["std::marker::Sized","internal::Parser"],"FnS":["std::marker::Sized","internal::Parser"],"FnT":["internal::Parser","std::marker::Sized"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized"],"T":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Display","std::fmt::Debug","std::clone::Clone"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Into","internal::And","internal::Map","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or"],"FnB":["internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::AndThen","std::boxed::Box","internal::Into","internal::Map","internal::Or"],"FnC":["<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Map","std::boxed::Box","internal::And","internal::Into","internal::AndThen"],"FnD":["std::boxed::Box","internal::AndThen","internal::Or","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::And","internal::Map","internal::Into"],"FnE":["internal::FlatMap","internal::AndThen","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::Or","internal::Map"],"FnF":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Or","internal::Map","std::boxed::Box","internal::Into","internal::And"],"FnG":["internal::Into","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::And","internal::AndThen"],"FnH":["internal::FlatMap","internal::Into","internal::AndThen","std::boxed::Box","internal::Map","internal::And","<F as internal::Parser<I, O, E>>","internal::Or"],"FnI":["internal::FlatMap","internal::And","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box","internal::Into"],"FnJ":["internal::And","internal::AndThen","internal::Or","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","std::boxed::Box"],"FnK":["internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::Or","internal::AndThen","internal::And","internal::FlatMap"],"FnL":["internal::FlatMap","internal::Or","internal::AndThen","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box"],"FnM":["internal::Into","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::And","std::boxed::Box"],"FnN":["internal::Into","internal::FlatMap","std::boxed::Box","internal::And","internal::AndThen","internal::Or","internal::Map","<F as internal::Parser<I, O, E>>"],"FnO":["internal::Or","internal::And","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into","internal::Map","std::boxed::Box"],"FnP":["internal::Or","internal::AndThen","std::boxed::Box","internal::Map","internal::And","internal::Into","internal::FlatMap","<F as internal::Parser<I, O, E>>"],"FnQ":["internal::Into","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or","internal::And","internal::Map","std::boxed::Box"],"FnR":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::AndThen","internal::Into","internal::Or","internal::FlatMap","std::boxed::Box"],"FnS":["internal::Or","internal::AndThen","internal::And","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Into","internal::FlatMap"],"FnT":["internal::AndThen","std::boxed::Box","internal::Or","internal::Map","internal::And","internal::Into","<F as internal::Parser<I, O, E>>","internal::FlatMap"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for &T>","error::VerboseError","internal::Needed","error::ErrorKind","error::VerboseErrorKind","internal::Err","number::Endianness"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"],"S":["RUG_ANY"],"T":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::And":{"F":["<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Map","internal::Or","internal::And","internal::AndThen","internal::Into","std::boxed::Box"],"G":["internal::FlatMap","internal::Map","internal::Or","internal::AndThen","internal::And","std::boxed::Box","internal::Into","<F as internal::Parser<I, O, E>>"]},"internal::AndThen":{"F":["internal::And","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","internal::FlatMap","internal::AndThen"],"G":["<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Into","internal::And","internal::Or","internal::Map","internal::AndThen"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","number::Endianness"]},"internal::FlatMap":{"F":["internal::And","internal::FlatMap","internal::Or","internal::Map","internal::Into","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>"],"G":["core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["i8","u8","<T as std::convert::From<!>>"],"F":["internal::FlatMap","internal::And","internal::Map","internal::Or","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Or","internal::Into","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::AndThen","internal::Map","internal::And"],"G":["core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace"],"O1":["RUG_ANY"]},"internal::Or":{"F":["internal::AndThen","internal::Or","internal::FlatMap","internal::Into","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","std::boxed::Box"],"G":["internal::Map","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::Or","internal::FlatMap"]},"std::boxed::Box":{"A":["std::alloc::System","std::alloc::Global","<&A as std::alloc::Allocator>"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse
deps:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse":{"A":["std::marker::Sized"],"B":["std::marker::Sized"],"C":["std::marker::Sized"],"D":["std::marker::Sized"],"E":["std::marker::Sized"],"Error":["error::ParseError","std::marker::Sized"],"F":["std::marker::Sized"],"FnA":["std::marker::Sized","internal::Parser"],"FnB":["internal::Parser","std::marker::Sized"],"FnC":["std::marker::Sized","internal::Parser"],"FnD":["std::marker::Sized","internal::Parser"],"FnE":["internal::Parser","std::marker::Sized"],"FnF":["internal::Parser","std::marker::Sized"],"FnG":["std::marker::Sized","internal::Parser"],"FnH":["internal::Parser","std::marker::Sized"],"FnI":["std::marker::Sized","internal::Parser"],"FnJ":["internal::Parser","std::marker::Sized"],"FnK":["internal::Parser","std::marker::Sized"],"FnL":["std::marker::Sized","internal::Parser"],"FnM":["internal::Parser","std::marker::Sized"],"FnN":["std::marker::Sized","internal::Parser"],"FnO":["std::marker::Sized","internal::Parser"],"FnP":["internal::Parser","std::marker::Sized"],"FnQ":["std::marker::Sized","internal::Parser"],"FnR":["std::marker::Sized","internal::Parser"],"FnS":["std::marker::Sized","internal::Parser"],"FnT":["std::marker::Sized","internal::Parser"],"FnU":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized"],"H":["std::marker::Sized"],"I":["std::marker::Sized"],"Input":["std::marker::Sized","std::clone::Clone"],"J":["std::marker::Sized"],"K":["std::marker::Sized"],"L":["std::marker::Sized"],"M":["std::marker::Sized"],"N":["std::marker::Sized"],"O":["std::marker::Sized"],"P":["std::marker::Sized"],"Q":["std::marker::Sized"],"R":["std::marker::Sized"],"S":["std::marker::Sized"],"T":["std::marker::Sized"],"U":["std::marker::Sized"]},"<F as internal::Parser<I, O, E>>":{"F":["std::ops::FnMut","std::marker::Sized"]},"<T as std::convert::From<!>>":{"T":["std::marker::Sized"]},"<T as std::convert::From<T>>":{"T":["std::marker::Sized"]},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::clone::Clone","std::marker::Sized"]},"internal::And":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","internal::Parser"]},"internal::AndThen":{"F":["std::marker::Sized","internal::Parser"],"G":["internal::Parser","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Err":{"E":["std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug"]},"internal::FlatMap":{"F":["std::marker::Sized","internal::Parser"],"G":["std::marker::Sized","std::ops::Fn"],"O1":["std::marker::Sized"]},"internal::Into":{"E1":["std::marker::Sized"],"E2":["error::ParseError","std::marker::Sized","std::convert::From"],"F":["std::marker::Sized","internal::Parser"],"O1":["std::marker::Sized"],"O2":["std::marker::Sized","std::convert::From"]},"internal::Map":{"F":["std::marker::Sized","internal::Parser"],"G":["std::ops::Fn","std::marker::Sized"],"O1":["std::marker::Sized"]},"internal::Or":{"F":["internal::Parser","std::marker::Sized"],"G":["internal::Parser","std::marker::Sized"]},"std::boxed::Box":{"A":["std::marker::Sized","std::alloc::Allocator"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&A as std::alloc::Allocator>":{},"<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse":{"A":["RUG_ANY"],"B":["RUG_ANY"],"C":["RUG_ANY"],"D":["RUG_ANY"],"E":["RUG_ANY"],"Error":["error::Error","error::VerboseError"],"F":["RUG_ANY"],"FnA":["internal::Map","internal::AndThen","internal::Into","<F as internal::Parser<I, O, E>>","internal::And","std::boxed::Box","internal::FlatMap","internal::Or"],"FnB":["<F as internal::Parser<I, O, E>>","internal::Map","internal::Or","internal::AndThen","internal::Into","internal::FlatMap","std::boxed::Box","internal::And"],"FnC":["internal::Into","internal::Or","internal::FlatMap","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::And","internal::Map"],"FnD":["<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into","internal::FlatMap","internal::Or","std::boxed::Box","internal::And","internal::Map"],"FnE":["internal::FlatMap","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::And","internal::AndThen","internal::Into"],"FnF":["internal::Into","std::boxed::Box","internal::AndThen","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::FlatMap","internal::Or"],"FnG":["internal::And","internal::Into","std::boxed::Box","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Map","internal::Or"],"FnH":["internal::And","std::boxed::Box","internal::Map","internal::Or","internal::AndThen","internal::FlatMap","<F as internal::Parser<I, O, E>>","internal::Into"],"FnI":["internal::Into","internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::FlatMap","internal::Map","internal::AndThen","internal::Or"],"FnJ":["internal::Or","internal::Into","internal::FlatMap","internal::And","internal::Map","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen"],"FnK":["internal::Into","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::And","internal::Map","internal::FlatMap"],"FnL":["std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Map","internal::Into","internal::FlatMap","internal::Or","internal::And"],"FnM":["<F as internal::Parser<I, O, E>>","internal::Or","internal::FlatMap","internal::Into","internal::And","internal::AndThen","internal::Map","std::boxed::Box"],"FnN":["internal::Or","std::boxed::Box","internal::FlatMap","internal::And","<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","internal::Into"],"FnO":["std::boxed::Box","internal::And","internal::Into","internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","internal::Map","internal::FlatMap"],"FnP":["internal::AndThen","internal::Or","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Into","internal::FlatMap","internal::Map","internal::And"],"FnQ":["internal::And","std::boxed::Box","internal::FlatMap","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>","internal::AndThen","internal::Into"],"FnR":["internal::AndThen","internal::Into","internal::And","internal::FlatMap","internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","std::boxed::Box"],"FnS":["internal::Or","std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Into","internal::And","internal::Map","internal::FlatMap"],"FnT":["<F as internal::Parser<I, O, E>>","internal::Map","internal::AndThen","std::boxed::Box","internal::FlatMap","internal::And","internal::Or","internal::Into"],"FnU":["internal::Map","internal::FlatMap","internal::And","internal::Into","internal::AndThen","std::boxed::Box","<F as internal::Parser<I, O, E>>","internal::Or"],"G":["RUG_ANY"],"H":["RUG_ANY"],"I":["RUG_ANY"],"Input":["std::clone::impls::<impl std::clone::Clone for &T>","error::ErrorKind","error::VerboseError","number::Endianness","error::VerboseErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Needed","internal::Err"],"J":["RUG_ANY"],"K":["RUG_ANY"],"L":["RUG_ANY"],"M":["RUG_ANY"],"N":["RUG_ANY"],"O":["RUG_ANY"],"P":["RUG_ANY"],"Q":["RUG_ANY"],"R":["RUG_ANY"],"S":["RUG_ANY"],"T":["RUG_ANY"],"U":["RUG_ANY"]},"<F as internal::Parser<I, O, E>>":{"F":["core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","std::ops::function::impls::<impl std::ops::FnMut<A> for &F>","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeUnicode"]},"<T as std::convert::From<!>>":{"T":["RUG_ANY"]},"<T as std::convert::From<T>>":{"T":["RUG_ANY"]},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::And":{"F":["std::boxed::Box","internal::Or","internal::Into","internal::Map","internal::FlatMap","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::And"],"G":["internal::And","internal::Into","internal::AndThen","internal::Map","std::boxed::Box","internal::Or","<F as internal::Parser<I, O, E>>","internal::FlatMap"]},"internal::AndThen":{"F":["std::boxed::Box","internal::AndThen","<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::Or","internal::FlatMap","internal::Into"],"G":["<F as internal::Parser<I, O, E>>","internal::Map","internal::And","internal::FlatMap","internal::Or","internal::Into","internal::AndThen","std::boxed::Box"],"O1":["RUG_ANY"]},"internal::Err":{"E":["internal::Needed","number::Endianness","error::ErrorKind","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err"]},"internal::FlatMap":{"F":["internal::FlatMap","internal::And","internal::Into","internal::AndThen","std::boxed::Box","internal::Map","internal::Or","<F as internal::Parser<I, O, E>>"],"G":["core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"],"O1":["RUG_ANY"]},"internal::Into":{"E1":["RUG_ANY"],"E2":["u8","i8","<T as std::convert::From<!>>","<T as std::convert::From<T>>"],"F":["internal::And","<F as internal::Parser<I, O, E>>","std::boxed::Box","internal::Or","internal::Into","internal::AndThen","internal::FlatMap","internal::Map"],"O1":["RUG_ANY"],"O2":["char"]},"internal::Map":{"F":["internal::Into","internal::Or","internal::FlatMap","std::boxed::Box","internal::And","internal::Map","<F as internal::Parser<I, O, E>>","internal::AndThen"],"G":["core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue"],"O1":["RUG_ANY"]},"internal::Or":{"F":["<F as internal::Parser<I, O, E>>","internal::Or","internal::Map","std::boxed::Box","internal::And","internal::AndThen","internal::Into","internal::FlatMap"],"G":["internal::Map","<F as internal::Parser<I, O, E>>","internal::Or","internal::Into","internal::AndThen","std::boxed::Box","internal::And","internal::FlatMap"]},"std::boxed::Box":{"A":["<&A as std::alloc::Allocator>","std::alloc::System","std::alloc::Global"]},"std::clone::impls::<impl std::clone::Clone for &T>":{},"std::clone::impls::<impl std::clone::Clone for &mut T>":{},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // (FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU)
let mut p1 = MaybeUninit::uninit().assume_init(); // Input
+p0.parse(p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse(p0, p1);
+crate::<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU) as sequence::Tuple<Input, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U), Error>>::parse(p0, p1);
+<(FnA, FnB, FnC, FnD, FnE, FnF, FnG, FnH, FnI, FnJ, FnK, FnL, FnM, FnN, FnO, FnP, FnQ, FnR, FnS, FnT, FnU)>::parse(p0, p1);
-----------------
src/sequence/mod.rs <() as sequence::Tuple<I, (), E>>::parse
deps:{"<() as sequence::Tuple<I, (), E>>::parse":{"E":["std::marker::Sized","error::ParseError"],"I":["std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Display","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Display","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug"]}}
candidates:{"<() as sequence::Tuple<I, (), E>>::parse":{"E":["error::Error","error::VerboseError"],"I":["RUG_ANY"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","internal::Err","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["internal::Err","<*const T as std::fmt::Debug>","internal::Needed","error::ErrorKind","number::Endianness"]}}
let mut p0 = &mut (); // None+()
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.parse(p1);
+<() as sequence::Tuple<I, (), E>>::parse(p0, p1);
+crate::<() as sequence::Tuple<I, (), E>>::parse(p0, p1);
+<()>::parse(p0, p1);
-----------------
src/traits.rs <&'a [T] as traits::InputLength>::input_len
'a
deps:{"<&'a [T] as traits::InputLength>::input_len":{"T":["std::marker::Sized"]}}
candidates:{"<&'a [T] as traits::InputLength>::input_len":{"T":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // [T]
+p0.input_len();
+<&'a [T] as traits::InputLength>::input_len(p0);
+crate::<&'a [T] as traits::InputLength>::input_len(p0);
+<&'a [T]>::input_len(p0);
-----------------
src/traits.rs <&'a str as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
+p0.input_len();
+<&'a str as traits::InputLength>::input_len(p0);
+crate::<&'a str as traits::InputLength>::input_len(p0);
+<&'a str>::input_len(p0);
-----------------
src/traits.rs <(&'a [u8], usize) as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (&'a [u8], usize)
+p0.input_len();
+<(&'a [u8], usize) as traits::InputLength>::input_len(p0);
+crate::<(&'a [u8], usize) as traits::InputLength>::input_len(p0);
+<(&'a [u8], usize)>::input_len(p0);
-----------------
src/traits.rs <[u8] as traits::Offset>::offset
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.offset(p1);
+<[u8] as traits::Offset>::offset(p0, p1);
+crate::<[u8] as traits::Offset>::offset(p0, p1);
+<[u8]>::offset(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Offset>::offset
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8].as_mut_slice(); // None+&'a [u8]
+p0.offset(p1);
+<&'a [u8] as traits::Offset>::offset(p0, p1);
+crate::<&'a [u8] as traits::Offset>::offset(p0, p1);
+<&'a [u8]>::offset(p0, p1);
-----------------
src/traits.rs <str as traits::Offset>::offset
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = "sample"; // None+&str
+p0.offset(&p1);
+<str as traits::Offset>::offset(&p0, &p1);
+crate::<str as traits::Offset>::offset(&p0, &p1);
+<str>::offset(&p0, &p1);
-----------------
src/traits.rs <&'a str as traits::Offset>::offset
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & "a"; // None+&'a str
+p0.offset(p1);
+<&'a str as traits::Offset>::offset(p0, p1);
+crate::<&'a str as traits::Offset>::offset(p0, p1);
+<&'a str>::offset(p0, p1);
-----------------
src/traits.rs <&'a str as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
+p0.as_bytes();
+<&'a str as traits::AsBytes>::as_bytes(p0);
+crate::<&'a str as traits::AsBytes>::as_bytes(p0);
+<&'a str>::as_bytes(p0);
-----------------
src/traits.rs <str as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+p0.as_bytes();
+<str as traits::AsBytes>::as_bytes(&p0);
+crate::<str as traits::AsBytes>::as_bytes(&p0);
+<str>::as_bytes(&p0);
-----------------
src/traits.rs <&'a [u8] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
+p0.as_bytes();
+<&'a [u8] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8]>::as_bytes(p0);
-----------------
src/traits.rs <[u8] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.as_bytes();
+<[u8] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8] as traits::AsBytes>::as_bytes(p0);
+<[u8]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 0] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 0]
+p0.as_bytes();
+<&'a [u8; 0] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 0] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 0]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 0] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 0]
+p0.as_bytes();
+<[u8; 0] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 0] as traits::AsBytes>::as_bytes(p0);
+<[u8; 0]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 1] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 1]
+p0.as_bytes();
+<&'a [u8; 1] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 1] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 1]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 1] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 1]
+p0.as_bytes();
+<[u8; 1] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 1] as traits::AsBytes>::as_bytes(p0);
+<[u8; 1]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 2] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 2]
+p0.as_bytes();
+<&'a [u8; 2] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 2] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 2]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 2] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 2]
+p0.as_bytes();
+<[u8; 2] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 2] as traits::AsBytes>::as_bytes(p0);
+<[u8; 2]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 3] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 3]
+p0.as_bytes();
+<&'a [u8; 3] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 3] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 3]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 3] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 3]
+p0.as_bytes();
+<[u8; 3] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 3] as traits::AsBytes>::as_bytes(p0);
+<[u8; 3]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 4] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 4]
+p0.as_bytes();
+<&'a [u8; 4] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 4] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 4]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 4] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 4]
+p0.as_bytes();
+<[u8; 4] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 4] as traits::AsBytes>::as_bytes(p0);
+<[u8; 4]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 5] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 5]
+p0.as_bytes();
+<&'a [u8; 5] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 5] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 5]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 5] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 5]
+p0.as_bytes();
+<[u8; 5] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 5] as traits::AsBytes>::as_bytes(p0);
+<[u8; 5]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 6] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 6]
+p0.as_bytes();
+<&'a [u8; 6] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 6] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 6]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 6] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 6]
+p0.as_bytes();
+<[u8; 6] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 6] as traits::AsBytes>::as_bytes(p0);
+<[u8; 6]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 7] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 7]
+p0.as_bytes();
+<&'a [u8; 7] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 7] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 7]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 7] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 7]
+p0.as_bytes();
+<[u8; 7] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 7] as traits::AsBytes>::as_bytes(p0);
+<[u8; 7]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 8] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 8]
+p0.as_bytes();
+<&'a [u8; 8] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 8] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 8]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 8] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 8]
+p0.as_bytes();
+<[u8; 8] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 8] as traits::AsBytes>::as_bytes(p0);
+<[u8; 8]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 9] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 9]
+p0.as_bytes();
+<&'a [u8; 9] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 9] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 9]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 9] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 9]
+p0.as_bytes();
+<[u8; 9] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 9] as traits::AsBytes>::as_bytes(p0);
+<[u8; 9]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 10] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 10]
+p0.as_bytes();
+<&'a [u8; 10] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 10] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 10]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 10] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 10]
+p0.as_bytes();
+<[u8; 10] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 10] as traits::AsBytes>::as_bytes(p0);
+<[u8; 10]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 11] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 11]
+p0.as_bytes();
+<&'a [u8; 11] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 11] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 11]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 11] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 11]
+p0.as_bytes();
+<[u8; 11] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 11] as traits::AsBytes>::as_bytes(p0);
+<[u8; 11]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 12] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 12]
+p0.as_bytes();
+<&'a [u8; 12] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 12] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 12]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 12] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 12]
+p0.as_bytes();
+<[u8; 12] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 12] as traits::AsBytes>::as_bytes(p0);
+<[u8; 12]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 13] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 13]
+p0.as_bytes();
+<&'a [u8; 13] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 13] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 13]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 13] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 13]
+p0.as_bytes();
+<[u8; 13] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 13] as traits::AsBytes>::as_bytes(p0);
+<[u8; 13]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 14] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 14]
+p0.as_bytes();
+<&'a [u8; 14] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 14] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 14]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 14] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 14]
+p0.as_bytes();
+<[u8; 14] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 14] as traits::AsBytes>::as_bytes(p0);
+<[u8; 14]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 15] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 15]
+p0.as_bytes();
+<&'a [u8; 15] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 15] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 15]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 15] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 15]
+p0.as_bytes();
+<[u8; 15] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 15] as traits::AsBytes>::as_bytes(p0);
+<[u8; 15]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 16] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 16]
+p0.as_bytes();
+<&'a [u8; 16] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 16] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 16]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 16] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 16]
+p0.as_bytes();
+<[u8; 16] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 16] as traits::AsBytes>::as_bytes(p0);
+<[u8; 16]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 17] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 17]
+p0.as_bytes();
+<&'a [u8; 17] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 17] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 17]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 17] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 17]
+p0.as_bytes();
+<[u8; 17] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 17] as traits::AsBytes>::as_bytes(p0);
+<[u8; 17]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 18] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 18]
+p0.as_bytes();
+<&'a [u8; 18] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 18] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 18]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 18] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 18]
+p0.as_bytes();
+<[u8; 18] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 18] as traits::AsBytes>::as_bytes(p0);
+<[u8; 18]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 19] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 19]
+p0.as_bytes();
+<&'a [u8; 19] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 19] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 19]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 19] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 19]
+p0.as_bytes();
+<[u8; 19] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 19] as traits::AsBytes>::as_bytes(p0);
+<[u8; 19]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 20] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 20]
+p0.as_bytes();
+<&'a [u8; 20] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 20] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 20]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 20] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 20]
+p0.as_bytes();
+<[u8; 20] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 20] as traits::AsBytes>::as_bytes(p0);
+<[u8; 20]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 21] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 21]
+p0.as_bytes();
+<&'a [u8; 21] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 21] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 21]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 21] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 21]
+p0.as_bytes();
+<[u8; 21] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 21] as traits::AsBytes>::as_bytes(p0);
+<[u8; 21]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 22] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 22]
+p0.as_bytes();
+<&'a [u8; 22] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 22] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 22]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 22] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 22]
+p0.as_bytes();
+<[u8; 22] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 22] as traits::AsBytes>::as_bytes(p0);
+<[u8; 22]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 23] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 23]
+p0.as_bytes();
+<&'a [u8; 23] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 23] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 23]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 23] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 23]
+p0.as_bytes();
+<[u8; 23] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 23] as traits::AsBytes>::as_bytes(p0);
+<[u8; 23]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 24] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 24]
+p0.as_bytes();
+<&'a [u8; 24] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 24] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 24]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 24] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 24]
+p0.as_bytes();
+<[u8; 24] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 24] as traits::AsBytes>::as_bytes(p0);
+<[u8; 24]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 25] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 25]
+p0.as_bytes();
+<&'a [u8; 25] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 25] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 25]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 25] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 25]
+p0.as_bytes();
+<[u8; 25] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 25] as traits::AsBytes>::as_bytes(p0);
+<[u8; 25]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 26] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 26]
+p0.as_bytes();
+<&'a [u8; 26] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 26] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 26]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 26] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 26]
+p0.as_bytes();
+<[u8; 26] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 26] as traits::AsBytes>::as_bytes(p0);
+<[u8; 26]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 27] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 27]
+p0.as_bytes();
+<&'a [u8; 27] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 27] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 27]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 27] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 27]
+p0.as_bytes();
+<[u8; 27] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 27] as traits::AsBytes>::as_bytes(p0);
+<[u8; 27]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 28] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 28]
+p0.as_bytes();
+<&'a [u8; 28] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 28] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 28]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 28] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 28]
+p0.as_bytes();
+<[u8; 28] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 28] as traits::AsBytes>::as_bytes(p0);
+<[u8; 28]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 29] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 29]
+p0.as_bytes();
+<&'a [u8; 29] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 29] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 29]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 29] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 29]
+p0.as_bytes();
+<[u8; 29] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 29] as traits::AsBytes>::as_bytes(p0);
+<[u8; 29]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 30] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 30]
+p0.as_bytes();
+<&'a [u8; 30] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 30] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 30]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 30] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 30]
+p0.as_bytes();
+<[u8; 30] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 30] as traits::AsBytes>::as_bytes(p0);
+<[u8; 30]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 31] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 31]
+p0.as_bytes();
+<&'a [u8; 31] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 31] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 31]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 31] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 31]
+p0.as_bytes();
+<[u8; 31] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 31] as traits::AsBytes>::as_bytes(p0);
+<[u8; 31]>::as_bytes(p0);
-----------------
src/traits.rs <&'a [u8; 32] as traits::AsBytes>::as_bytes
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 32]
+p0.as_bytes();
+<&'a [u8; 32] as traits::AsBytes>::as_bytes(p0);
+crate::<&'a [u8; 32] as traits::AsBytes>::as_bytes(p0);
+<&'a [u8; 32]>::as_bytes(p0);
-----------------
src/traits.rs <[u8; 32] as traits::AsBytes>::as_bytes
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 32]
+p0.as_bytes();
+<[u8; 32] as traits::AsBytes>::as_bytes(p0);
+crate::<[u8; 32] as traits::AsBytes>::as_bytes(p0);
+<[u8; 32]>::as_bytes(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::as_char
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.as_char();
+<u8 as traits::AsChar>::as_char(p0);
+crate::<u8 as traits::AsChar>::as_char(p0);
+<u8>::as_char(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::is_alpha
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.is_alpha();
+<u8 as traits::AsChar>::is_alpha(p0);
+crate::<u8 as traits::AsChar>::is_alpha(p0);
+<u8>::is_alpha(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::is_alphanum
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.is_alphanum();
+<u8 as traits::AsChar>::is_alphanum(p0);
+crate::<u8 as traits::AsChar>::is_alphanum(p0);
+<u8>::is_alphanum(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::is_dec_digit
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.is_dec_digit();
+<u8 as traits::AsChar>::is_dec_digit(p0);
+crate::<u8 as traits::AsChar>::is_dec_digit(p0);
+<u8>::is_dec_digit(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::is_hex_digit
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.is_hex_digit();
+<u8 as traits::AsChar>::is_hex_digit(p0);
+crate::<u8 as traits::AsChar>::is_hex_digit(p0);
+<u8>::is_hex_digit(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::is_oct_digit
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.is_oct_digit();
+<u8 as traits::AsChar>::is_oct_digit(p0);
+crate::<u8 as traits::AsChar>::is_oct_digit(p0);
+<u8>::is_oct_digit(p0);
-----------------
src/traits.rs <u8 as traits::AsChar>::len
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+p0.len();
+<u8 as traits::AsChar>::len(p0);
+crate::<u8 as traits::AsChar>::len(p0);
+<u8>::len(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::as_char
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.as_char();
+<&'a u8 as traits::AsChar>::as_char(p0);
+crate::<&'a u8 as traits::AsChar>::as_char(p0);
+<&'a u8>::as_char(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::is_alpha
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.is_alpha();
+<&'a u8 as traits::AsChar>::is_alpha(p0);
+crate::<&'a u8 as traits::AsChar>::is_alpha(p0);
+<&'a u8>::is_alpha(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::is_alphanum
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.is_alphanum();
+<&'a u8 as traits::AsChar>::is_alphanum(p0);
+crate::<&'a u8 as traits::AsChar>::is_alphanum(p0);
+<&'a u8>::is_alphanum(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::is_dec_digit
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.is_dec_digit();
+<&'a u8 as traits::AsChar>::is_dec_digit(p0);
+crate::<&'a u8 as traits::AsChar>::is_dec_digit(p0);
+<&'a u8>::is_dec_digit(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::is_hex_digit
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.is_hex_digit();
+<&'a u8 as traits::AsChar>::is_hex_digit(p0);
+crate::<&'a u8 as traits::AsChar>::is_hex_digit(p0);
+<&'a u8>::is_hex_digit(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::is_oct_digit
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.is_oct_digit();
+<&'a u8 as traits::AsChar>::is_oct_digit(p0);
+crate::<&'a u8 as traits::AsChar>::is_oct_digit(p0);
+<&'a u8>::is_oct_digit(p0);
-----------------
src/traits.rs <&'a u8 as traits::AsChar>::len
'a
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.len();
+<&'a u8 as traits::AsChar>::len(p0);
+crate::<&'a u8 as traits::AsChar>::len(p0);
+<&'a u8>::len(p0);
-----------------
src/traits.rs <char as traits::AsChar>::as_char
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.as_char();
+<char as traits::AsChar>::as_char(p0);
+crate::<char as traits::AsChar>::as_char(p0);
+<char>::as_char(p0);
-----------------
src/traits.rs <char as traits::AsChar>::is_alpha
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_alpha();
+<char as traits::AsChar>::is_alpha(p0);
+crate::<char as traits::AsChar>::is_alpha(p0);
+<char>::is_alpha(p0);
-----------------
src/traits.rs <char as traits::AsChar>::is_alphanum
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_alphanum();
+<char as traits::AsChar>::is_alphanum(p0);
+crate::<char as traits::AsChar>::is_alphanum(p0);
+<char>::is_alphanum(p0);
-----------------
src/traits.rs <char as traits::AsChar>::is_dec_digit
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_dec_digit();
+<char as traits::AsChar>::is_dec_digit(p0);
+crate::<char as traits::AsChar>::is_dec_digit(p0);
+<char>::is_dec_digit(p0);
-----------------
src/traits.rs <char as traits::AsChar>::is_hex_digit
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_hex_digit();
+<char as traits::AsChar>::is_hex_digit(p0);
+crate::<char as traits::AsChar>::is_hex_digit(p0);
+<char>::is_hex_digit(p0);
-----------------
src/traits.rs <char as traits::AsChar>::is_oct_digit
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.is_oct_digit();
+<char as traits::AsChar>::is_oct_digit(p0);
+crate::<char as traits::AsChar>::is_oct_digit(p0);
+<char>::is_oct_digit(p0);
-----------------
src/traits.rs <char as traits::AsChar>::len
deps:{}
candidates:{}
let mut p0 = 'a'; // None+char
+p0.len();
+<char as traits::AsChar>::len(p0);
+crate::<char as traits::AsChar>::len(p0);
+<char>::len(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::as_char
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.as_char();
+<&'a char as traits::AsChar>::as_char(p0);
+crate::<&'a char as traits::AsChar>::as_char(p0);
+<&'a char>::as_char(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::is_alpha
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.is_alpha();
+<&'a char as traits::AsChar>::is_alpha(p0);
+crate::<&'a char as traits::AsChar>::is_alpha(p0);
+<&'a char>::is_alpha(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::is_alphanum
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.is_alphanum();
+<&'a char as traits::AsChar>::is_alphanum(p0);
+crate::<&'a char as traits::AsChar>::is_alphanum(p0);
+<&'a char>::is_alphanum(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::is_dec_digit
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.is_dec_digit();
+<&'a char as traits::AsChar>::is_dec_digit(p0);
+crate::<&'a char as traits::AsChar>::is_dec_digit(p0);
+<&'a char>::is_dec_digit(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::is_hex_digit
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.is_hex_digit();
+<&'a char as traits::AsChar>::is_hex_digit(p0);
+crate::<&'a char as traits::AsChar>::is_hex_digit(p0);
+<&'a char>::is_hex_digit(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::is_oct_digit
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.is_oct_digit();
+<&'a char as traits::AsChar>::is_oct_digit(p0);
+crate::<&'a char as traits::AsChar>::is_oct_digit(p0);
+<&'a char>::is_oct_digit(p0);
-----------------
src/traits.rs <&'a char as traits::AsChar>::len
'a
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.len();
+<&'a char as traits::AsChar>::len(p0);
+crate::<&'a char as traits::AsChar>::len(p0);
+<&'a char>::len(p0);
-----------------
src/traits.rs <&'a [u8] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
+p0.iter_indices();
+<&'a [u8] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8] as traits::InputIter>::iter_indices(p0);
+<&'a [u8]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
+p0.iter_elements();
+<&'a [u8] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8] as traits::InputIter>::iter_elements(p0);
+<&'a [u8]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8] as traits::InputIter>::position
'a
deps:{"<&'a [u8] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8] as traits::InputIter>::position":{"P":["core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsWhitespace"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8] as traits::InputIter>::position(p0, p1);
+<&'a [u8]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::InputTake>::take
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = 0usize; // None+usize
+p0.take(p1);
+<&'a [u8] as traits::InputTake>::take(p0, p1);
+crate::<&'a [u8] as traits::InputTake>::take(p0, p1);
+<&'a [u8]>::take(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::InputTake>::take_split
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = 0usize; // None+usize
+p0.take_split(p1);
+<&'a [u8] as traits::InputTake>::take_split(p0, p1);
+crate::<&'a [u8] as traits::InputTake>::take_split(p0, p1);
+<&'a [u8]>::take_split(p0, p1);
-----------------
src/traits.rs <&'a str as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
+p0.iter_indices();
+<&'a str as traits::InputIter>::iter_indices(p0);
+crate::<&'a str as traits::InputIter>::iter_indices(p0);
+<&'a str>::iter_indices(p0);
-----------------
src/traits.rs <&'a str as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
+p0.iter_elements();
+<&'a str as traits::InputIter>::iter_elements(p0);
+crate::<&'a str as traits::InputIter>::iter_elements(p0);
+<&'a str>::iter_elements(p0);
-----------------
src/traits.rs <&'a str as traits::InputIter>::position
'a
deps:{"<&'a str as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a str as traits::InputIter>::position":{"P":["core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a str as traits::InputIter>::position(p0, p1);
+crate::<&'a str as traits::InputIter>::position(p0, p1);
+<&'a str>::position(p0, p1);
-----------------
src/traits.rs <&'a str as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a str as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a str as traits::InputIter>::slice_index(p0, p1);
+<&'a str>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a str as traits::InputTake>::take
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = 0usize; // None+usize
+p0.take(p1);
+<&'a str as traits::InputTake>::take(p0, p1);
+crate::<&'a str as traits::InputTake>::take(p0, p1);
+<&'a str>::take(p0, p1);
-----------------
src/traits.rs <&'a str as traits::InputTake>::take_split
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = 0usize; // None+usize
+p0.take_split(p1);
+<&'a str as traits::InputTake>::take_split(p0, p1);
+crate::<&'a str as traits::InputTake>::take_split(p0, p1);
+<&'a str>::take_split(p0, p1);
-----------------
src/traits.rs <T as traits::InputTakeAtPosition>::split_at_position
deps:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>::split_at_position":{"E":["error::ParseError","std::marker::Sized"],"P":["std::marker::Sized","std::ops::Fn"],"T":["std::clone::Clone","traits::InputLength","traits::InputIter","traits::InputTake","traits::UnspecializedInput","std::marker::Sized"]},"error::Error":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::clone::Clone"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>::split_at_position":{"E":["error::VerboseError","error::Error"],"P":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","error::ErrorKind","number::Endianness","internal::Needed","<*mut T as std::fmt::Debug>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position(p1);
+<T as traits::InputTakeAtPosition>::split_at_position(p0, p1);
+crate::<T as traits::InputTakeAtPosition>::split_at_position(p0, p1);
+<T>::split_at_position(p0, p1);
-----------------
src/traits.rs <T as traits::InputTakeAtPosition>::split_at_position1
deps:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>::split_at_position1":{"E":["std::marker::Sized","error::ParseError"],"P":["std::ops::Fn","std::marker::Sized"],"T":["traits::InputLength","std::marker::Sized","traits::InputIter","traits::InputTake","traits::UnspecializedInput","std::clone::Clone"]},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Display","std::marker::Sized","std::fmt::Debug"]},"internal::Err":{"E":["std::cmp::Eq","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<*mut T as std::fmt::Debug>":{},"<T as traits::InputTakeAtPosition>::split_at_position1":{"E":["error::Error","error::VerboseError"],"P":["core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::CharEscapeDefault"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["number::Endianness","std::clone::impls::<impl std::clone::Clone for *const T>","internal::Err","error::ErrorKind","internal::Needed"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1(p1, p2);
+<T as traits::InputTakeAtPosition>::split_at_position1(p0, p1, p2);
+crate::<T as traits::InputTakeAtPosition>::split_at_position1(p0, p1, p2);
+<T>::split_at_position1(p0, p1, p2);
-----------------
src/traits.rs <T as traits::InputTakeAtPosition>::split_at_position_complete
deps:{"<T as traits::InputTakeAtPosition>::split_at_position_complete":{"E":["std::marker::Sized","error::ParseError"],"P":["std::ops::Fn","std::marker::Sized"],"T":["std::marker::Sized","std::clone::Clone","traits::InputLength","traits::InputTake","traits::UnspecializedInput","traits::InputIter"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<T as traits::InputTakeAtPosition>::split_at_position_complete":{"E":["error::VerboseError","error::Error"],"P":["core::str::UnsafeBytesToStr","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Needed","std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>","error::ErrorKind","internal::Err","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position_complete(p1);
+<T as traits::InputTakeAtPosition>::split_at_position_complete(p0, p1);
+crate::<T as traits::InputTakeAtPosition>::split_at_position_complete(p0, p1);
+<T>::split_at_position_complete(p0, p1);
-----------------
src/traits.rs <T as traits::InputTakeAtPosition>::split_at_position1_complete
deps:{"<T as traits::InputTakeAtPosition>::split_at_position1_complete":{"E":["std::marker::Sized","error::ParseError"],"P":["std::marker::Sized","std::ops::Fn"],"T":["traits::UnspecializedInput","traits::InputLength","traits::InputIter","traits::InputTake","std::marker::Sized","std::clone::Clone"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::cmp::PartialEq","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::Eq","std::fmt::Debug","std::cmp::PartialEq","std::clone::Clone","std::marker::Sized"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<T as traits::InputTakeAtPosition>::split_at_position1_complete":{"E":["error::Error","error::VerboseError"],"P":["core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["number::Endianness","std::clone::impls::<impl std::clone::Clone for *mut T>","internal::Err","internal::Needed","error::ErrorKind"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1_complete(p1, p2);
+<T as traits::InputTakeAtPosition>::split_at_position1_complete(p0, p1, p2);
+crate::<T as traits::InputTakeAtPosition>::split_at_position1_complete(p0, p1, p2);
+<T>::split_at_position1_complete(p0, p1, p2);
-----------------
src/traits.rs <&'a [u8] as traits::InputTakeAtPosition>::split_at_position
'a
deps:{"<&'a [u8] as traits::InputTakeAtPosition>::split_at_position":{"E":["std::marker::Sized","error::ParseError"],"P":["std::marker::Sized","std::ops::Fn"]},"error::Error":{"I":["std::fmt::Debug","std::fmt::Display","std::marker::Sized","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&'a [u8] as traits::InputTakeAtPosition>::split_at_position":{"E":["error::VerboseError","error::Error"],"P":["core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["error::ErrorKind","number::Endianness","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","internal::Needed","internal::Err"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position(p1);
+<&'a [u8] as traits::InputTakeAtPosition>::split_at_position(p0, p1);
+crate::<&'a [u8] as traits::InputTakeAtPosition>::split_at_position(p0, p1);
+<&'a [u8]>::split_at_position(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::InputTakeAtPosition>::split_at_position1
'a
deps:{"<&'a [u8] as traits::InputTakeAtPosition>::split_at_position1":{"E":["error::ParseError","std::marker::Sized"],"P":["std::marker::Sized","std::ops::Fn"]},"error::Error":{"I":["std::fmt::Debug","std::marker::Sized","std::fmt::Display","std::cmp::PartialEq"]},"error::VerboseError":{"I":["std::fmt::Display","std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&'a [u8] as traits::InputTakeAtPosition>::split_at_position1":{"E":["error::VerboseError","error::Error"],"P":["core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap"]},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>","internal::Needed","error::ErrorKind","number::Endianness","internal::Err"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1(p1, p2);
+<&'a [u8] as traits::InputTakeAtPosition>::split_at_position1(p0, p1, p2);
+crate::<&'a [u8] as traits::InputTakeAtPosition>::split_at_position1(p0, p1, p2);
+<&'a [u8]>::split_at_position1(p0, p1, p2);
-----------------
src/traits.rs <&'a [u8] as traits::InputTakeAtPosition>::split_at_position_complete
'a
deps:{"<&'a [u8] as traits::InputTakeAtPosition>::split_at_position_complete":{"E":["std::marker::Sized","error::ParseError"],"P":["std::marker::Sized","std::ops::Fn"]},"error::Error":{"I":["std::marker::Sized","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::marker::Sized","std::clone::Clone","std::fmt::Debug","std::cmp::PartialEq"]},"internal::Err":{"E":["std::cmp::PartialEq","std::marker::Sized","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&'a [u8] as traits::InputTakeAtPosition>::split_at_position_complete":{"E":["error::Error","error::VerboseError"],"P":["core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte"]},"error::Error":{"I":["internal::Err","error::VerboseError","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","std::clone::impls::<impl std::clone::Clone for *mut T>","error::ErrorKind","internal::Needed","number::Endianness"]},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position_complete(p1);
+<&'a [u8] as traits::InputTakeAtPosition>::split_at_position_complete(p0, p1);
+crate::<&'a [u8] as traits::InputTakeAtPosition>::split_at_position_complete(p0, p1);
+<&'a [u8]>::split_at_position_complete(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::InputTakeAtPosition>::split_at_position1_complete
'a
deps:{"<&'a [u8] as traits::InputTakeAtPosition>::split_at_position1_complete":{"E":["error::ParseError","std::marker::Sized"],"P":["std::ops::Fn","std::marker::Sized"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::fmt::Display","std::fmt::Debug","std::clone::Clone","std::marker::Sized"]},"internal::Err":{"E":["std::cmp::PartialEq","std::clone::Clone","std::fmt::Debug","std::cmp::Eq","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8] as traits::InputTakeAtPosition>::split_at_position1_complete":{"E":["error::Error","error::VerboseError"],"P":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault"]},"<*const T as std::fmt::Debug>":{},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["internal::Err","error::Error","error::VerboseError"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*const T as std::fmt::Debug>","number::Endianness","error::ErrorKind","internal::Needed","internal::Err"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1_complete(p1, p2);
+<&'a [u8] as traits::InputTakeAtPosition>::split_at_position1_complete(p0, p1, p2);
+crate::<&'a [u8] as traits::InputTakeAtPosition>::split_at_position1_complete(p0, p1, p2);
+<&'a [u8]>::split_at_position1_complete(p0, p1, p2);
-----------------
src/traits.rs <&'a str as traits::InputTakeAtPosition>::split_at_position
'a
deps:{"<&'a str as traits::InputTakeAtPosition>::split_at_position":{"E":["error::ParseError","std::marker::Sized"],"P":["std::marker::Sized","std::ops::Fn"]},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Display","std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::cmp::PartialEq"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::clone::Clone"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
candidates:{"<&'a str as traits::InputTakeAtPosition>::split_at_position":{"E":["error::VerboseError","error::Error"],"P":["core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue"]},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","internal::Err","number::Endianness"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{}}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position(p1);
+<&'a str as traits::InputTakeAtPosition>::split_at_position(p0, p1);
+crate::<&'a str as traits::InputTakeAtPosition>::split_at_position(p0, p1);
+<&'a str>::split_at_position(p0, p1);
-----------------
src/traits.rs <&'a str as traits::InputTakeAtPosition>::split_at_position1
'a
deps:{"<&'a str as traits::InputTakeAtPosition>::split_at_position1":{"E":["std::marker::Sized","error::ParseError"],"P":["std::marker::Sized","std::ops::Fn"]},"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["std::cmp::PartialEq","std::fmt::Debug","std::marker::Sized","std::fmt::Display"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::clone::Clone","std::fmt::Display","std::cmp::PartialEq"]},"internal::Err":{"E":["std::fmt::Debug","std::cmp::PartialEq","std::cmp::Eq","std::clone::Clone","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
candidates:{"<&'a str as traits::InputTakeAtPosition>::split_at_position1":{"E":["error::Error","error::VerboseError"],"P":["core::str::IsWhitespace","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr"]},"<*const T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["internal::Err","error::VerboseError"]},"internal::Err":{"E":["internal::Err","internal::Needed","error::ErrorKind","number::Endianness","<*const T as std::fmt::Debug>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::mut_ptr::<impl std::cmp::PartialEq for *mut T>":{}}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1(p1, p2);
+<&'a str as traits::InputTakeAtPosition>::split_at_position1(p0, p1, p2);
+crate::<&'a str as traits::InputTakeAtPosition>::split_at_position1(p0, p1, p2);
+<&'a str>::split_at_position1(p0, p1, p2);
-----------------
src/traits.rs <&'a str as traits::InputTakeAtPosition>::split_at_position_complete
'a
deps:{"<&'a str as traits::InputTakeAtPosition>::split_at_position_complete":{"E":["std::marker::Sized","error::ParseError"],"P":["std::ops::Fn","std::marker::Sized"]},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["std::marker::Sized","std::fmt::Debug","std::cmp::PartialEq","std::fmt::Display"]},"error::VerboseError":{"I":["std::cmp::PartialEq","std::marker::Sized","std::fmt::Debug","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::cmp::PartialEq","std::cmp::Eq","std::marker::Sized","std::fmt::Debug","std::clone::Clone"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
candidates:{"<&'a str as traits::InputTakeAtPosition>::split_at_position_complete":{"E":["error::VerboseError","error::Error"],"P":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue"]},"<*mut T as std::fmt::Debug>":{},"error::Error":{"I":["error::VerboseError","internal::Err","error::Error"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["<*mut T as std::fmt::Debug>","internal::Needed","number::Endianness","error::ErrorKind","internal::Err"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{},"std::ptr::const_ptr::<impl std::cmp::PartialEq for *const T>":{}}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.split_at_position_complete(p1);
+<&'a str as traits::InputTakeAtPosition>::split_at_position_complete(p0, p1);
+crate::<&'a str as traits::InputTakeAtPosition>::split_at_position_complete(p0, p1);
+<&'a str>::split_at_position_complete(p0, p1);
-----------------
src/traits.rs <&'a str as traits::InputTakeAtPosition>::split_at_position1_complete
'a
deps:{"<&'a str as traits::InputTakeAtPosition>::split_at_position1_complete":{"E":["error::ParseError","std::marker::Sized"],"P":["std::marker::Sized","std::ops::Fn"]},"error::Error":{"I":["std::fmt::Display","std::fmt::Debug","std::cmp::PartialEq","std::marker::Sized"]},"error::VerboseError":{"I":["std::fmt::Debug","std::marker::Sized","std::cmp::PartialEq","std::clone::Clone","std::fmt::Display"]},"internal::Err":{"E":["std::marker::Sized","std::cmp::PartialEq","std::cmp::Eq","std::fmt::Debug","std::clone::Clone"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a str as traits::InputTakeAtPosition>::split_at_position1_complete":{"E":["error::VerboseError","error::Error"],"P":["core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::BytesIsNotEmpty"]},"error::Error":{"I":["error::Error","error::VerboseError","internal::Err"]},"error::VerboseError":{"I":["error::VerboseError","internal::Err"]},"internal::Err":{"E":["error::ErrorKind","internal::Needed","number::Endianness","internal::Err","std::clone::impls::<impl std::clone::Clone for *const T>"]},"std::clone::impls::<impl std::clone::Clone for *const T>":{},"std::clone::impls::<impl std::clone::Clone for *mut T>":{},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // P
let mut p2 = MaybeUninit::uninit().assume_init(); // error::ErrorKind
+p0.split_at_position1_complete(p1, p2);
+<&'a str as traits::InputTakeAtPosition>::split_at_position1_complete(p0, p1, p2);
+crate::<&'a str as traits::InputTakeAtPosition>::split_at_position1_complete(p0, p1, p2);
+<&'a str>::split_at_position1_complete(p0, p1, p2);
-----------------
src/traits.rs <traits::CompareResult as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // traits::CompareResult
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<traits::CompareResult as std::fmt::Debug>::fmt(p0, p1);
+crate::<traits::CompareResult as std::fmt::Debug>::fmt(p0, p1);
+<traits::CompareResult>::fmt(p0, p1);
-----------------
src/traits.rs <traits::CompareResult as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // traits::CompareResult
let mut p1 = & MaybeUninit::uninit().assume_init(); // traits::CompareResult
+p0.eq(p1);
+<traits::CompareResult as std::cmp::PartialEq>::eq(p0, p1);
+crate::<traits::CompareResult as std::cmp::PartialEq>::eq(p0, p1);
+<traits::CompareResult>::eq(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <T as traits::Compare<O>>::compare
deps:{"<T as traits::Compare<O>>::compare":{"O":["traits::InputIter","traits::InputLength","std::marker::Sized","traits::InputTake"],"T":["traits::InputLength","traits::InputIter","traits::UnspecializedInput","std::marker::Sized","traits::InputTake"]}}
candidates:{"<T as traits::Compare<O>>::compare":{"O":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // O
+p0.compare(p1);
+<T as traits::Compare<O>>::compare(p0, p1);
+crate::<T as traits::Compare<O>>::compare(p0, p1);
+<T>::compare(p0, p1);
-----------------
src/traits.rs <T as traits::Compare<O>>::compare_no_case
deps:{"<T as traits::Compare<O>>::compare_no_case":{"O":["traits::InputIter","std::marker::Sized","traits::InputTake","traits::InputLength"],"T":["traits::InputTake","traits::UnspecializedInput","traits::InputIter","std::marker::Sized","traits::InputLength"]}}
candidates:{"<T as traits::Compare<O>>::compare_no_case":{"O":[]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
let mut p1 = MaybeUninit::uninit().assume_init(); // O
+p0.compare_no_case(p1);
+<T as traits::Compare<O>>::compare_no_case(p0, p1);
+crate::<T as traits::Compare<O>>::compare_no_case(p0, p1);
+<T>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b str>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = "sample"; // None+&str
+p0.compare(&p1);
+<&'a [u8] as traits::Compare<&'b str>>::compare(p0, &p1);
+crate::<&'a [u8] as traits::Compare<&'b str>>::compare(p0, &p1);
+<&'a [u8]>::compare(p0, &p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b str>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = "sample"; // None+&str
+p0.compare_no_case(&p1);
+<&'a [u8] as traits::Compare<&'b str>>::compare_no_case(p0, &p1);
+crate::<&'a [u8] as traits::Compare<&'b str>>::compare_no_case(p0, &p1);
+<&'a [u8]>::compare_no_case(p0, &p1);
-----------------
src/traits.rs <&'a str as traits::Compare<&'b str>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = "sample"; // None+&str
+p0.compare(&p1);
+<&'a str as traits::Compare<&'b str>>::compare(p0, &p1);
+crate::<&'a str as traits::Compare<&'b str>>::compare(p0, &p1);
+<&'a str>::compare(p0, &p1);
-----------------
src/traits.rs <&'a str as traits::Compare<&'b str>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = "sample"; // None+&str
+p0.compare_no_case(&p1);
+<&'a str as traits::Compare<&'b str>>::compare_no_case(p0, &p1);
+crate::<&'a str as traits::Compare<&'b str>>::compare_no_case(p0, &p1);
+<&'a str>::compare_no_case(p0, &p1);
-----------------
src/traits.rs <&'a str as traits::Compare<&'b [u8]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.compare(p1);
+<&'a str as traits::Compare<&'b [u8]>>::compare(p0, p1);
+crate::<&'a str as traits::Compare<&'b [u8]>>::compare(p0, p1);
+<&'a str>::compare(p0, p1);
-----------------
src/traits.rs <&'a str as traits::Compare<&'b [u8]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.compare_no_case(p1);
+<&'a str as traits::Compare<&'b [u8]>>::compare_no_case(p0, p1);
+crate::<&'a str as traits::Compare<&'b [u8]>>::compare_no_case(p0, p1);
+<&'a str>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::FindToken<u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<&'a [u8] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<&'a [u8] as traits::FindToken<u8>>::find_token(p0, p1);
+<&'a [u8]>::find_token(p0, p1);
-----------------
src/traits.rs <&'a str as traits::FindToken<u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<&'a str as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<&'a str as traits::FindToken<u8>>::find_token(p0, p1);
+<&'a str>::find_token(p0, p1);
-----------------
src/traits.rs <&'b [u8] as traits::FindToken<&'a u8>>::find_token
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'b [u8]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<&'b [u8] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<&'b [u8] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<&'b [u8]>::find_token(p0, p1);
-----------------
src/traits.rs <&'b str as traits::FindToken<&'a u8>>::find_token
'a,'b
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'b str
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<&'b str as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<&'b str as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<&'b str>::find_token(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::FindToken<char>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = 'a'; // None+char
+p0.find_token(p1);
+<&'a [u8] as traits::FindToken<char>>::find_token(p0, p1);
+crate::<&'a [u8] as traits::FindToken<char>>::find_token(p0, p1);
+<&'a [u8]>::find_token(p0, p1);
-----------------
src/traits.rs <&'a str as traits::FindToken<char>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = 'a'; // None+char
+p0.find_token(p1);
+<&'a str as traits::FindToken<char>>::find_token(p0, p1);
+crate::<&'a str as traits::FindToken<char>>::find_token(p0, p1);
+<&'a str>::find_token(p0, p1);
-----------------
src/traits.rs <&'a [char] as traits::FindToken<char>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & ['a'].as_mut_slice(); // None+&'a [char]
let mut p1 = 'a'; // None+char
+p0.find_token(p1);
+<&'a [char] as traits::FindToken<char>>::find_token(p0, p1);
+crate::<&'a [char] as traits::FindToken<char>>::find_token(p0, p1);
+<&'a [char]>::find_token(p0, p1);
-----------------
src/traits.rs <&'b [char] as traits::FindToken<&'a char>>::find_token
'a,'b
deps:{}
candidates:{}
let mut p0 = & ['a'].as_mut_slice(); // None+&'b [char]
let mut p1 = & 'a'; // None+char
+p0.find_token(p1);
+<&'b [char] as traits::FindToken<&'a char>>::find_token(p0, p1);
+crate::<&'b [char] as traits::FindToken<&'a char>>::find_token(p0, p1);
+<&'b [char]>::find_token(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::FindSubstring<&'b [u8]>>::find_substring
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.find_substring(p1);
+<&'a [u8] as traits::FindSubstring<&'b [u8]>>::find_substring(p0, p1);
+crate::<&'a [u8] as traits::FindSubstring<&'b [u8]>>::find_substring(p0, p1);
+<&'a [u8]>::find_substring(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::FindSubstring<&'b str>>::find_substring
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = "sample"; // None+&str
+p0.find_substring(&p1);
+<&'a [u8] as traits::FindSubstring<&'b str>>::find_substring(p0, &p1);
+crate::<&'a [u8] as traits::FindSubstring<&'b str>>::find_substring(p0, &p1);
+<&'a [u8]>::find_substring(p0, &p1);
-----------------
src/traits.rs <&'a str as traits::FindSubstring<&'b str>>::find_substring
'a,'b
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = "sample"; // None+&str
+p0.find_substring(&p1);
+<&'a str as traits::FindSubstring<&'b str>>::find_substring(p0, &p1);
+crate::<&'a str as traits::FindSubstring<&'b str>>::find_substring(p0, &p1);
+<&'a str>::find_substring(p0, &p1);
-----------------
src/traits.rs <&'a [u8] as traits::ParseTo<R>>::parse_to
'a
deps:{"<&'a [u8] as traits::ParseTo<R>>::parse_to":{"R":["std::marker::Sized","std::str::FromStr"]}}
candidates:{"<&'a [u8] as traits::ParseTo<R>>::parse_to":{"R":["i16","u8","i64","u64","usize","u32","bool","u16","i8","i32","char"]}}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
+p0.parse_to();
+<&'a [u8] as traits::ParseTo<R>>::parse_to(p0);
+crate::<&'a [u8] as traits::ParseTo<R>>::parse_to(p0);
+<&'a [u8]>::parse_to(p0);
-----------------
src/traits.rs <&'a str as traits::ParseTo<R>>::parse_to
'a
deps:{"<&'a str as traits::ParseTo<R>>::parse_to":{"R":["std::str::FromStr","std::marker::Sized"]}}
candidates:{"<&'a str as traits::ParseTo<R>>::parse_to":{"R":["i16","i64","i8","i32","u64","char","u8","usize","bool","u16","u32"]}}
let mut p0 = & "a"; // None+&'a str
+p0.parse_to();
+<&'a str as traits::ParseTo<R>>::parse_to(p0);
+crate::<&'a str as traits::ParseTo<R>>::parse_to(p0);
+<&'a str>::parse_to(p0);
-----------------
src/traits.rs <&'a str as traits::Slice<std::ops::Range<usize>>>::slice
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.slice(p1);
+<&'a str as traits::Slice<std::ops::Range<usize>>>::slice(p0, p1);
+crate::<&'a str as traits::Slice<std::ops::Range<usize>>>::slice(p0, p1);
+<&'a str>::slice(p0, p1);
-----------------
src/traits.rs <&'a str as traits::Slice<std::ops::RangeTo<usize>>>::slice
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::RangeTo<usize>
+p0.slice(p1);
+<&'a str as traits::Slice<std::ops::RangeTo<usize>>>::slice(p0, p1);
+crate::<&'a str as traits::Slice<std::ops::RangeTo<usize>>>::slice(p0, p1);
+<&'a str>::slice(p0, p1);
-----------------
src/traits.rs <&'a str as traits::Slice<std::ops::RangeFrom<usize>>>::slice
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::RangeFrom<usize>
+p0.slice(p1);
+<&'a str as traits::Slice<std::ops::RangeFrom<usize>>>::slice(p0, p1);
+crate::<&'a str as traits::Slice<std::ops::RangeFrom<usize>>>::slice(p0, p1);
+<&'a str>::slice(p0, p1);
-----------------
src/traits.rs <&'a str as traits::Slice<std::ops::RangeFull>>::slice
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::RangeFull
+p0.slice(p1);
+<&'a str as traits::Slice<std::ops::RangeFull>>::slice(p0, p1);
+crate::<&'a str as traits::Slice<std::ops::RangeFull>>::slice(p0, p1);
+<&'a str>::slice(p0, p1);
-----------------
src/traits.rs <&'a [T] as traits::Slice<std::ops::Range<usize>>>::slice
'a
deps:{"<&'a [T] as traits::Slice<std::ops::Range<usize>>>::slice":{"T":["std::marker::Sized"]}}
candidates:{"<&'a [T] as traits::Slice<std::ops::Range<usize>>>::slice":{"T":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // [T]
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::Range<usize>
+p0.slice(p1);
+<&'a [T] as traits::Slice<std::ops::Range<usize>>>::slice(p0, p1);
+crate::<&'a [T] as traits::Slice<std::ops::Range<usize>>>::slice(p0, p1);
+<&'a [T]>::slice(p0, p1);
-----------------
src/traits.rs <&'a [T] as traits::Slice<std::ops::RangeTo<usize>>>::slice
'a
deps:{"<&'a [T] as traits::Slice<std::ops::RangeTo<usize>>>::slice":{"T":["std::marker::Sized"]}}
candidates:{"<&'a [T] as traits::Slice<std::ops::RangeTo<usize>>>::slice":{"T":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // [T]
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::RangeTo<usize>
+p0.slice(p1);
+<&'a [T] as traits::Slice<std::ops::RangeTo<usize>>>::slice(p0, p1);
+crate::<&'a [T] as traits::Slice<std::ops::RangeTo<usize>>>::slice(p0, p1);
+<&'a [T]>::slice(p0, p1);
-----------------
src/traits.rs <&'a [T] as traits::Slice<std::ops::RangeFrom<usize>>>::slice
'a
deps:{"<&'a [T] as traits::Slice<std::ops::RangeFrom<usize>>>::slice":{"T":["std::marker::Sized"]}}
candidates:{"<&'a [T] as traits::Slice<std::ops::RangeFrom<usize>>>::slice":{"T":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // [T]
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::RangeFrom<usize>
+p0.slice(p1);
+<&'a [T] as traits::Slice<std::ops::RangeFrom<usize>>>::slice(p0, p1);
+crate::<&'a [T] as traits::Slice<std::ops::RangeFrom<usize>>>::slice(p0, p1);
+<&'a [T]>::slice(p0, p1);
-----------------
src/traits.rs <&'a [T] as traits::Slice<std::ops::RangeFull>>::slice
'a
deps:{"<&'a [T] as traits::Slice<std::ops::RangeFull>>::slice":{"T":["std::marker::Sized"]}}
candidates:{"<&'a [T] as traits::Slice<std::ops::RangeFull>>::slice":{"T":["RUG_ANY"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // [T]
let mut p1 = MaybeUninit::uninit().assume_init(); // std::ops::RangeFull
+p0.slice(p1);
+<&'a [T] as traits::Slice<std::ops::RangeFull>>::slice(p0, p1);
+crate::<&'a [T] as traits::Slice<std::ops::RangeFull>>::slice(p0, p1);
+<&'a [T]>::slice(p0, p1);
-----------------
src/traits.rs <[u8; 0] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 0]
+p0.input_len();
+<[u8; 0] as traits::InputLength>::input_len(p0);
+crate::<[u8; 0] as traits::InputLength>::input_len(p0);
+<[u8; 0]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 0] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 0]
+p0.input_len();
+<&'a [u8; 0] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 0] as traits::InputLength>::input_len(p0);
+<&'a [u8; 0]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 0] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 0]
+p0.iter_indices();
+<&'a [u8; 0] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 0] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 0]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 0] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 0]
+p0.iter_elements();
+<&'a [u8; 0] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 0] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 0]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 0] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 0] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 0] as traits::InputIter>::position":{"P":["core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::LinesAnyMap"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 0]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 0] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 0] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 0]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 0] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 0]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 0] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 0] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 0]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 0]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 0]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 0]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 0]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 0]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 0]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 0]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 0]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 0]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 0]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 0]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 0]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 0]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 0]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 0]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 0]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 0] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 0]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 0] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 0] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 0]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 0] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 0]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 0] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 0] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 0]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 1] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 1]
+p0.input_len();
+<[u8; 1] as traits::InputLength>::input_len(p0);
+crate::<[u8; 1] as traits::InputLength>::input_len(p0);
+<[u8; 1]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 1] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 1]
+p0.input_len();
+<&'a [u8; 1] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 1] as traits::InputLength>::input_len(p0);
+<&'a [u8; 1]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 1] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 1]
+p0.iter_indices();
+<&'a [u8; 1] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 1] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 1]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 1] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 1]
+p0.iter_elements();
+<&'a [u8; 1] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 1] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 1]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 1] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 1] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 1] as traits::InputIter>::position":{"P":["std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 1]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 1] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 1] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 1]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 1] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 1]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 1] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 1] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 1]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 1]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 1]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 1]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 1]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 1]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 1]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 1]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 1]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 1]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 1]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 1]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 1]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 1]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 1]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 1]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 1]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 1] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 1]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 1] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 1] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 1]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 1] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 1]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 1] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 1] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 1]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 2] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 2]
+p0.input_len();
+<[u8; 2] as traits::InputLength>::input_len(p0);
+crate::<[u8; 2] as traits::InputLength>::input_len(p0);
+<[u8; 2]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 2] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 2]
+p0.input_len();
+<&'a [u8; 2] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 2] as traits::InputLength>::input_len(p0);
+<&'a [u8; 2]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 2] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 2]
+p0.iter_indices();
+<&'a [u8; 2] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 2] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 2]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 2] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 2]
+p0.iter_elements();
+<&'a [u8; 2] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 2] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 2]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 2] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 2] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 2] as traits::InputIter>::position":{"P":["core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::IsNotEmpty"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 2]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 2] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 2] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 2]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 2] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 2]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 2] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 2] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 2]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 2]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 2]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 2]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 2]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 2]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 2]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 2]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 2]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 2]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 2]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 2]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 2]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 2]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 2]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 2]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 2]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 2] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 2]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 2] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 2] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 2]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 2] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 2]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 2] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 2] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 2]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 3] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 3]
+p0.input_len();
+<[u8; 3] as traits::InputLength>::input_len(p0);
+crate::<[u8; 3] as traits::InputLength>::input_len(p0);
+<[u8; 3]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 3] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 3]
+p0.input_len();
+<&'a [u8; 3] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 3] as traits::InputLength>::input_len(p0);
+<&'a [u8; 3]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 3] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 3]
+p0.iter_indices();
+<&'a [u8; 3] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 3] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 3]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 3] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 3]
+p0.iter_elements();
+<&'a [u8; 3] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 3] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 3]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 3] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 3] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 3] as traits::InputIter>::position":{"P":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::IsWhitespace","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 3]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 3] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 3] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 3]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 3] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 3]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 3] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 3] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 3]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 3]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 3]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 3]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 3]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 3]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 3]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 3]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 3]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 3]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 3]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 3]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 3]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 3]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 3]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 3]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 3]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 3] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 3]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 3] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 3] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 3]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 3] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 3]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 3] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 3] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 3]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 4] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 4]
+p0.input_len();
+<[u8; 4] as traits::InputLength>::input_len(p0);
+crate::<[u8; 4] as traits::InputLength>::input_len(p0);
+<[u8; 4]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 4] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 4]
+p0.input_len();
+<&'a [u8; 4] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 4] as traits::InputLength>::input_len(p0);
+<&'a [u8; 4]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 4] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 4]
+p0.iter_indices();
+<&'a [u8; 4] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 4] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 4]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 4] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 4]
+p0.iter_elements();
+<&'a [u8; 4] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 4] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 4]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 4] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 4] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 4] as traits::InputIter>::position":{"P":["core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 4]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 4] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 4] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 4]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 4] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 4]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 4] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 4] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 4]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 4]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 4]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 4]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 4]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 4]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 4]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 4]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 4]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 4]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 4]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 4]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 4]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 4]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 4]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 4]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 4]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 4] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 4]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 4] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 4] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 4]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 4] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 4]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 4] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 4] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 4]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 5] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 5]
+p0.input_len();
+<[u8; 5] as traits::InputLength>::input_len(p0);
+crate::<[u8; 5] as traits::InputLength>::input_len(p0);
+<[u8; 5]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 5] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 5]
+p0.input_len();
+<&'a [u8; 5] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 5] as traits::InputLength>::input_len(p0);
+<&'a [u8; 5]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 5] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 5]
+p0.iter_indices();
+<&'a [u8; 5] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 5] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 5]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 5] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 5]
+p0.iter_elements();
+<&'a [u8; 5] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 5] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 5]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 5] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 5] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 5] as traits::InputIter>::position":{"P":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::str::UnsafeBytesToStr"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 5]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 5] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 5] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 5]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 5] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 5]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 5] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 5] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 5]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 5]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 5]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 5]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 5]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 5]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 5]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 5]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 5]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 5]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 5]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 5]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 5]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 5]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 5]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 5]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 5]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 5] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 5]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 5] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 5] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 5]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 5] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 5]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 5] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 5] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 5]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 6] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 6]
+p0.input_len();
+<[u8; 6] as traits::InputLength>::input_len(p0);
+crate::<[u8; 6] as traits::InputLength>::input_len(p0);
+<[u8; 6]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 6] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 6]
+p0.input_len();
+<&'a [u8; 6] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 6] as traits::InputLength>::input_len(p0);
+<&'a [u8; 6]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 6] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 6]
+p0.iter_indices();
+<&'a [u8; 6] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 6] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 6]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 6] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 6]
+p0.iter_elements();
+<&'a [u8; 6] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 6] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 6]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 6] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 6] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 6] as traits::InputIter>::position":{"P":["core::str::CharEscapeDefault","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 6]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 6] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 6] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 6]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 6] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 6]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 6] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 6] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 6]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 6]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 6]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 6]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 6]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 6]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 6]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 6]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 6]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 6]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 6]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 6]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 6]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 6]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 6]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 6]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 6]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 6] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 6]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 6] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 6] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 6]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 6] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 6]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 6] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 6] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 6]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 7] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 7]
+p0.input_len();
+<[u8; 7] as traits::InputLength>::input_len(p0);
+crate::<[u8; 7] as traits::InputLength>::input_len(p0);
+<[u8; 7]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 7] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 7]
+p0.input_len();
+<&'a [u8; 7] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 7] as traits::InputLength>::input_len(p0);
+<&'a [u8; 7]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 7] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 7]
+p0.iter_indices();
+<&'a [u8; 7] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 7] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 7]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 7] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 7]
+p0.iter_elements();
+<&'a [u8; 7] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 7] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 7]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 7] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 7] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 7] as traits::InputIter>::position":{"P":["core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::BytesIsNotEmpty"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 7]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 7] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 7] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 7]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 7] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 7]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 7] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 7] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 7]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 7]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 7]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 7]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 7]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 7]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 7]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 7]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 7]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 7]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 7]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 7]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 7]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 7]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 7]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 7]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 7]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 7] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 7]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 7] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 7] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 7]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 7] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 7]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 7] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 7] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 7]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 8] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 8]
+p0.input_len();
+<[u8; 8] as traits::InputLength>::input_len(p0);
+crate::<[u8; 8] as traits::InputLength>::input_len(p0);
+<[u8; 8]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 8] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 8]
+p0.input_len();
+<&'a [u8; 8] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 8] as traits::InputLength>::input_len(p0);
+<&'a [u8; 8]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 8] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 8]
+p0.iter_indices();
+<&'a [u8; 8] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 8] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 8]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 8] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 8]
+p0.iter_elements();
+<&'a [u8; 8] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 8] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 8]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 8] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 8] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 8] as traits::InputIter>::position":{"P":["core::str::IsWhitespace","core::str::LinesAnyMap","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 8]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 8] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 8] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 8]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 8] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 8]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 8] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 8] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 8]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 8]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 8]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 8]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 8]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 8]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 8]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 8]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 8]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 8]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 8]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 8]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 8]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 8]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 8]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 8]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 8]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 8] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 8]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 8] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 8] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 8]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 8] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 8]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 8] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 8] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 8]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 9] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 9]
+p0.input_len();
+<[u8; 9] as traits::InputLength>::input_len(p0);
+crate::<[u8; 9] as traits::InputLength>::input_len(p0);
+<[u8; 9]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 9] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 9]
+p0.input_len();
+<&'a [u8; 9] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 9] as traits::InputLength>::input_len(p0);
+<&'a [u8; 9]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 9] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 9]
+p0.iter_indices();
+<&'a [u8; 9] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 9] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 9]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 9] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 9]
+p0.iter_elements();
+<&'a [u8; 9] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 9] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 9]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 9] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 9] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 9] as traits::InputIter>::position":{"P":["core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 9]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 9] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 9] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 9]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 9] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 9]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 9] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 9] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 9]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 9]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 9]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 9]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 9]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 9]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 9]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 9]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 9]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 9]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 9]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 9]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 9]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 9]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 9]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 9]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 9]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 9] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 9]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 9] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 9] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 9]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 9] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 9]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 9] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 9] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 9]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 10] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 10]
+p0.input_len();
+<[u8; 10] as traits::InputLength>::input_len(p0);
+crate::<[u8; 10] as traits::InputLength>::input_len(p0);
+<[u8; 10]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 10] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 10]
+p0.input_len();
+<&'a [u8; 10] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 10] as traits::InputLength>::input_len(p0);
+<&'a [u8; 10]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 10] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 10]
+p0.iter_indices();
+<&'a [u8; 10] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 10] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 10]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 10] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 10]
+p0.iter_elements();
+<&'a [u8; 10] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 10] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 10]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 10] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 10] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 10] as traits::InputIter>::position":{"P":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 10]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 10] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 10] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 10]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 10] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 10]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 10] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 10] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 10]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 10]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 10]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 10]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 10]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 10]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 10]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 10]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 10]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 10]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 10]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 10]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 10]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 10]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 10]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 10]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 10]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 10] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 10]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 10] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 10] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 10]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 10] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 10]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 10] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 10] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 10]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 11] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 11]
+p0.input_len();
+<[u8; 11] as traits::InputLength>::input_len(p0);
+crate::<[u8; 11] as traits::InputLength>::input_len(p0);
+<[u8; 11]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 11] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 11]
+p0.input_len();
+<&'a [u8; 11] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 11] as traits::InputLength>::input_len(p0);
+<&'a [u8; 11]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 11] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 11]
+p0.iter_indices();
+<&'a [u8; 11] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 11] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 11]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 11] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 11]
+p0.iter_elements();
+<&'a [u8; 11] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 11] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 11]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 11] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 11] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 11] as traits::InputIter>::position":{"P":["core::str::CharEscapeDefault","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 11]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 11] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 11] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 11]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 11] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 11]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 11] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 11] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 11]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 11]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 11]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 11]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 11]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 11]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 11]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 11]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 11]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 11]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 11]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 11]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 11]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 11]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 11]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 11]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 11]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 11] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 11]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 11] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 11] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 11]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 11] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 11]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 11] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 11] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 11]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 12] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 12]
+p0.input_len();
+<[u8; 12] as traits::InputLength>::input_len(p0);
+crate::<[u8; 12] as traits::InputLength>::input_len(p0);
+<[u8; 12]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 12] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 12]
+p0.input_len();
+<&'a [u8; 12] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 12] as traits::InputLength>::input_len(p0);
+<&'a [u8; 12]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 12] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 12]
+p0.iter_indices();
+<&'a [u8; 12] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 12] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 12]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 12] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 12]
+p0.iter_elements();
+<&'a [u8; 12] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 12] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 12]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 12] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 12] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 12] as traits::InputIter>::position":{"P":["core::str::CharEscapeDefault","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 12]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 12] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 12] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 12]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 12] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 12]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 12] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 12] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 12]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 12]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 12]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 12]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 12]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 12]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 12]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 12]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 12]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 12]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 12]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 12]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 12]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 12]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 12]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 12]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 12]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 12] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 12]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 12] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 12] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 12]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 12] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 12]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 12] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 12] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 12]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 13] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 13]
+p0.input_len();
+<[u8; 13] as traits::InputLength>::input_len(p0);
+crate::<[u8; 13] as traits::InputLength>::input_len(p0);
+<[u8; 13]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 13] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 13]
+p0.input_len();
+<&'a [u8; 13] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 13] as traits::InputLength>::input_len(p0);
+<&'a [u8; 13]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 13] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 13]
+p0.iter_indices();
+<&'a [u8; 13] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 13] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 13]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 13] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 13]
+p0.iter_elements();
+<&'a [u8; 13] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 13] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 13]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 13] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 13] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 13] as traits::InputIter>::position":{"P":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::IsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 13]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 13] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 13] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 13]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 13] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 13]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 13] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 13] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 13]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 13]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 13]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 13]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 13]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 13]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 13]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 13]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 13]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 13]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 13]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 13]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 13]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 13]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 13]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 13]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 13]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 13] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 13]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 13] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 13] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 13]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 13] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 13]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 13] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 13] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 13]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 14] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 14]
+p0.input_len();
+<[u8; 14] as traits::InputLength>::input_len(p0);
+crate::<[u8; 14] as traits::InputLength>::input_len(p0);
+<[u8; 14]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 14] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 14]
+p0.input_len();
+<&'a [u8; 14] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 14] as traits::InputLength>::input_len(p0);
+<&'a [u8; 14]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 14] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 14]
+p0.iter_indices();
+<&'a [u8; 14] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 14] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 14]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 14] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 14]
+p0.iter_elements();
+<&'a [u8; 14] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 14] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 14]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 14] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 14] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 14] as traits::InputIter>::position":{"P":["core::str::LinesAnyMap","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDebugContinue"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 14]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 14] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 14] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 14]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 14] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 14]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 14] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 14] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 14]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 14]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 14]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 14]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 14]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 14]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 14]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 14]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 14]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 14]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 14]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 14]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 14]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 14]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 14]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 14]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 14]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 14] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 14]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 14] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 14] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 14]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 14] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 14]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 14] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 14] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 14]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 15] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 15]
+p0.input_len();
+<[u8; 15] as traits::InputLength>::input_len(p0);
+crate::<[u8; 15] as traits::InputLength>::input_len(p0);
+<[u8; 15]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 15] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 15]
+p0.input_len();
+<&'a [u8; 15] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 15] as traits::InputLength>::input_len(p0);
+<&'a [u8; 15]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 15] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 15]
+p0.iter_indices();
+<&'a [u8; 15] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 15] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 15]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 15] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 15]
+p0.iter_elements();
+<&'a [u8; 15] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 15] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 15]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 15] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 15] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 15] as traits::InputIter>::position":{"P":["std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::str::IsWhitespace","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","core::str::IsAsciiWhitespace"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 15]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 15] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 15] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 15]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 15] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 15]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 15] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 15] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 15]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 15]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 15]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 15]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 15]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 15]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 15]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 15]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 15]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 15]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 15]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 15]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 15]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 15]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 15]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 15]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 15]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 15] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 15]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 15] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 15] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 15]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 15] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 15]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 15] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 15] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 15]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 16] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 16]
+p0.input_len();
+<[u8; 16] as traits::InputLength>::input_len(p0);
+crate::<[u8; 16] as traits::InputLength>::input_len(p0);
+<[u8; 16]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 16] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 16]
+p0.input_len();
+<&'a [u8; 16] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 16] as traits::InputLength>::input_len(p0);
+<&'a [u8; 16]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 16] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 16]
+p0.iter_indices();
+<&'a [u8; 16] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 16] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 16]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 16] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 16]
+p0.iter_elements();
+<&'a [u8; 16] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 16] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 16]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 16] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 16] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 16] as traits::InputIter>::position":{"P":["core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::IsWhitespace","std::boxed::Box<F, A>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 16]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 16] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 16] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 16]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 16] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 16]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 16] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 16] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 16]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 16]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 16]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 16]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 16]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 16]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 16]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 16]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 16]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 16]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 16]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 16]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 16]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 16]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 16]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 16]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 16]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 16] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 16]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 16] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 16] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 16]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 16] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 16]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 16] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 16] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 16]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 17] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 17]
+p0.input_len();
+<[u8; 17] as traits::InputLength>::input_len(p0);
+crate::<[u8; 17] as traits::InputLength>::input_len(p0);
+<[u8; 17]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 17] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 17]
+p0.input_len();
+<&'a [u8; 17] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 17] as traits::InputLength>::input_len(p0);
+<&'a [u8; 17]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 17] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 17]
+p0.iter_indices();
+<&'a [u8; 17] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 17] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 17]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 17] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 17]
+p0.iter_elements();
+<&'a [u8; 17] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 17] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 17]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 17] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 17] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 17] as traits::InputIter>::position":{"P":["core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::CharEscapeUnicode"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 17]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 17] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 17] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 17]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 17] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 17]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 17] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 17] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 17]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 17]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 17]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 17]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 17]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 17]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 17]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 17]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 17]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 17]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 17]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 17]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 17]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 17]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 17]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 17]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 17]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 17] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 17]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 17] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 17] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 17]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 17] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 17]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 17] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 17] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 17]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 18] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 18]
+p0.input_len();
+<[u8; 18] as traits::InputLength>::input_len(p0);
+crate::<[u8; 18] as traits::InputLength>::input_len(p0);
+<[u8; 18]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 18] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 18]
+p0.input_len();
+<&'a [u8; 18] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 18] as traits::InputLength>::input_len(p0);
+<&'a [u8; 18]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 18] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 18]
+p0.iter_indices();
+<&'a [u8; 18] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 18] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 18]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 18] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 18]
+p0.iter_elements();
+<&'a [u8; 18] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 18] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 18]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 18] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 18] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 18] as traits::InputIter>::position":{"P":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::slice::ascii::EscapeByte"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 18]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 18] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 18] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 18]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 18] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 18]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 18] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 18] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 18]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 18]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 18]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 18]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 18]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 18]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 18]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 18]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 18]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 18]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 18]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 18]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 18]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 18]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 18]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 18]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 18]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 18] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 18]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 18] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 18] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 18]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 18] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 18]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 18] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 18] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 18]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 19] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 19]
+p0.input_len();
+<[u8; 19] as traits::InputLength>::input_len(p0);
+crate::<[u8; 19] as traits::InputLength>::input_len(p0);
+<[u8; 19]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 19] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 19]
+p0.input_len();
+<&'a [u8; 19] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 19] as traits::InputLength>::input_len(p0);
+<&'a [u8; 19]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 19] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 19]
+p0.iter_indices();
+<&'a [u8; 19] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 19] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 19]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 19] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 19]
+p0.iter_elements();
+<&'a [u8; 19] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 19] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 19]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 19] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 19] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 19] as traits::InputIter>::position":{"P":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::LinesAnyMap"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 19]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 19] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 19] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 19]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 19] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 19]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 19] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 19] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 19]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 19]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 19]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 19]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 19]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 19]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 19]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 19]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 19]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 19]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 19]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 19]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 19]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 19]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 19]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 19]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 19]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 19] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 19]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 19] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 19] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 19]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 19] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 19]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 19] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 19] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 19]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 20] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 20]
+p0.input_len();
+<[u8; 20] as traits::InputLength>::input_len(p0);
+crate::<[u8; 20] as traits::InputLength>::input_len(p0);
+<[u8; 20]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 20] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 20]
+p0.input_len();
+<&'a [u8; 20] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 20] as traits::InputLength>::input_len(p0);
+<&'a [u8; 20]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 20] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 20]
+p0.iter_indices();
+<&'a [u8; 20] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 20] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 20]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 20] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 20]
+p0.iter_elements();
+<&'a [u8; 20] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 20] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 20]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 20] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 20] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 20] as traits::InputIter>::position":{"P":["core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","core::str::LinesAnyMap","core::str::IsNotEmpty"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 20]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 20] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 20] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 20]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 20] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 20]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 20] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 20] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 20]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 20]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 20]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 20]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 20]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 20]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 20]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 20]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 20]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 20]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 20]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 20]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 20]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 20]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 20]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 20]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 20]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 20] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 20]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 20] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 20] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 20]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 20] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 20]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 20] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 20] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 20]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 21] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 21]
+p0.input_len();
+<[u8; 21] as traits::InputLength>::input_len(p0);
+crate::<[u8; 21] as traits::InputLength>::input_len(p0);
+<[u8; 21]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 21] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 21]
+p0.input_len();
+<&'a [u8; 21] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 21] as traits::InputLength>::input_len(p0);
+<&'a [u8; 21]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 21] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 21]
+p0.iter_indices();
+<&'a [u8; 21] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 21] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 21]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 21] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 21]
+p0.iter_elements();
+<&'a [u8; 21] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 21] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 21]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 21] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 21] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 21] as traits::InputIter>::position":{"P":["core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsNotEmpty","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::LinesAnyMap","std::boxed::Box<F, A>","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 21]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 21] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 21] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 21]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 21] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 21]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 21] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 21] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 21]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 21]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 21]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 21]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 21]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 21]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 21]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 21]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 21]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 21]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 21]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 21]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 21]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 21]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 21]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 21]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 21]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 21] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 21]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 21] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 21] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 21]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 21] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 21]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 21] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 21] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 21]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 22] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 22]
+p0.input_len();
+<[u8; 22] as traits::InputLength>::input_len(p0);
+crate::<[u8; 22] as traits::InputLength>::input_len(p0);
+<[u8; 22]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 22] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 22]
+p0.input_len();
+<&'a [u8; 22] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 22] as traits::InputLength>::input_len(p0);
+<&'a [u8; 22]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 22] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 22]
+p0.iter_indices();
+<&'a [u8; 22] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 22] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 22]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 22] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 22]
+p0.iter_elements();
+<&'a [u8; 22] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 22] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 22]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 22] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 22] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 22] as traits::InputIter>::position":{"P":["core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::BytesIsNotEmpty","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::IsNotEmpty"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 22]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 22] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 22] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 22]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 22] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 22]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 22] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 22] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 22]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 22]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 22]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 22]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 22]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 22]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 22]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 22]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 22]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 22]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 22]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 22]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 22]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 22]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 22]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 22]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 22]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 22] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 22]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 22] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 22] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 22]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 22] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 22]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 22] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 22] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 22]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 23] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 23]
+p0.input_len();
+<[u8; 23] as traits::InputLength>::input_len(p0);
+crate::<[u8; 23] as traits::InputLength>::input_len(p0);
+<[u8; 23]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 23] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 23]
+p0.input_len();
+<&'a [u8; 23] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 23] as traits::InputLength>::input_len(p0);
+<&'a [u8; 23]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 23] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 23]
+p0.iter_indices();
+<&'a [u8; 23] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 23] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 23]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 23] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 23]
+p0.iter_elements();
+<&'a [u8; 23] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 23] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 23]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 23] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 23] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 23] as traits::InputIter>::position":{"P":["core::str::IsNotEmpty","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 23]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 23] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 23] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 23]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 23] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 23]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 23] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 23] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 23]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 23]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 23]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 23]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 23]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 23]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 23]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 23]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 23]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 23]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 23]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 23]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 23]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 23]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 23]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 23]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 23]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 23] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 23]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 23] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 23] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 23]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 23] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 23]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 23] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 23] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 23]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 24] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 24]
+p0.input_len();
+<[u8; 24] as traits::InputLength>::input_len(p0);
+crate::<[u8; 24] as traits::InputLength>::input_len(p0);
+<[u8; 24]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 24] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 24]
+p0.input_len();
+<&'a [u8; 24] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 24] as traits::InputLength>::input_len(p0);
+<&'a [u8; 24]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 24] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 24]
+p0.iter_indices();
+<&'a [u8; 24] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 24] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 24]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 24] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 24]
+p0.iter_elements();
+<&'a [u8; 24] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 24] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 24]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 24] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 24] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 24] as traits::InputIter>::position":{"P":["core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","core::str::LinesAnyMap","core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsWhitespace"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 24]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 24] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 24] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 24]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 24] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 24]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 24] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 24] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 24]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 24]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 24]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 24]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 24]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 24]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 24]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 24]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 24]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 24]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 24]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 24]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 24]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 24]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 24]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 24]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 24]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 24] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 24]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 24] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 24] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 24]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 24] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 24]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 24] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 24] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 24]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 25] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 25]
+p0.input_len();
+<[u8; 25] as traits::InputLength>::input_len(p0);
+crate::<[u8; 25] as traits::InputLength>::input_len(p0);
+<[u8; 25]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 25] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 25]
+p0.input_len();
+<&'a [u8; 25] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 25] as traits::InputLength>::input_len(p0);
+<&'a [u8; 25]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 25] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 25]
+p0.iter_indices();
+<&'a [u8; 25] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 25] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 25]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 25] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 25]
+p0.iter_elements();
+<&'a [u8; 25] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 25] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 25]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 25] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 25] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 25] as traits::InputIter>::position":{"P":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsWhitespace","core::str::CharEscapeDefault","core::str::UnsafeBytesToStr","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","std::boxed::Box<F, A>","core::str::LinesAnyMap","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::str::CharEscapeUnicode","core::str::IsNotEmpty"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 25]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 25] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 25] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 25]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 25] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 25]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 25] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 25] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 25]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 25]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 25]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 25]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 25]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 25]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 25]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 25]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 25]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 25]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 25]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 25]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 25]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 25]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 25]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 25]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 25]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 25] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 25]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 25] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 25] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 25]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 25] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 25]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 25] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 25] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 25]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 26] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 26]
+p0.input_len();
+<[u8; 26] as traits::InputLength>::input_len(p0);
+crate::<[u8; 26] as traits::InputLength>::input_len(p0);
+<[u8; 26]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 26] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 26]
+p0.input_len();
+<&'a [u8; 26] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 26] as traits::InputLength>::input_len(p0);
+<&'a [u8; 26]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 26] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 26]
+p0.iter_indices();
+<&'a [u8; 26] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 26] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 26]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 26] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 26]
+p0.iter_elements();
+<&'a [u8; 26] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 26] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 26]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 26] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 26] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 26] as traits::InputIter>::position":{"P":["core::str::CharEscapeDebugContinue","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","std::boxed::Box<F, A>","core::str::IsWhitespace","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::str::CharEscapeUnicode","core::str::LinesAnyMap"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 26]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 26] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 26] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 26]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 26] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 26]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 26] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 26] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 26]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 26]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 26]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 26]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 26]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 26]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 26]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 26]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 26]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 26]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 26]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 26]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 26]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 26]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 26]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 26]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 26]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 26] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 26]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 26] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 26] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 26]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 26] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 26]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 26] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 26] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 26]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 27] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 27]
+p0.input_len();
+<[u8; 27] as traits::InputLength>::input_len(p0);
+crate::<[u8; 27] as traits::InputLength>::input_len(p0);
+<[u8; 27]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 27] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 27]
+p0.input_len();
+<&'a [u8; 27] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 27] as traits::InputLength>::input_len(p0);
+<&'a [u8; 27]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 27] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 27]
+p0.iter_indices();
+<&'a [u8; 27] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 27] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 27]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 27] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 27]
+p0.iter_elements();
+<&'a [u8; 27] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 27] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 27]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 27] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 27] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 27] as traits::InputIter>::position":{"P":["core::str::CharEscapeUnicode","core::str::BytesIsNotEmpty","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","core::str::IsWhitespace","core::slice::ascii::EscapeByte","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::IsAsciiWhitespace","std::boxed::Box<F, A>","core::str::IsNotEmpty"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 27]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 27] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 27] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 27]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 27] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 27]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 27] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 27] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 27]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 27]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 27]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 27]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 27]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 27]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 27]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 27]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 27]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 27]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 27]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 27]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 27]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 27]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 27]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 27]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 27]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 27] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 27]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 27] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 27] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 27]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 27] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 27]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 27] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 27] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 27]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 28] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 28]
+p0.input_len();
+<[u8; 28] as traits::InputLength>::input_len(p0);
+crate::<[u8; 28] as traits::InputLength>::input_len(p0);
+<[u8; 28]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 28] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 28]
+p0.input_len();
+<&'a [u8; 28] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 28] as traits::InputLength>::input_len(p0);
+<&'a [u8; 28]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 28] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 28]
+p0.iter_indices();
+<&'a [u8; 28] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 28] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 28]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 28] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 28]
+p0.iter_elements();
+<&'a [u8; 28] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 28] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 28]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 28] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 28] as traits::InputIter>::position":{"P":["std::marker::Sized","std::ops::Fn"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 28] as traits::InputIter>::position":{"P":["core::str::IsAsciiWhitespace","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::CharEscapeUnicode","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::LinesAnyMap","core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 28]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 28] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 28] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 28]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 28] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 28]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 28] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 28] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 28]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 28]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 28]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 28]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 28]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 28]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 28]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 28]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 28]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 28]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 28]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 28]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 28]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 28]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 28]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 28]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 28]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 28] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 28]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 28] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 28] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 28]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 28] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 28]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 28] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 28] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 28]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 29] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 29]
+p0.input_len();
+<[u8; 29] as traits::InputLength>::input_len(p0);
+crate::<[u8; 29] as traits::InputLength>::input_len(p0);
+<[u8; 29]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 29] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 29]
+p0.input_len();
+<&'a [u8; 29] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 29] as traits::InputLength>::input_len(p0);
+<&'a [u8; 29]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 29] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 29]
+p0.iter_indices();
+<&'a [u8; 29] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 29] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 29]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 29] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 29]
+p0.iter_elements();
+<&'a [u8; 29] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 29] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 29]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 29] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 29] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 29] as traits::InputIter>::position":{"P":["core::str::UnsafeBytesToStr","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeUnicode","std::boxed::Box<F, A>","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::str::CharEscapeDefault","core::str::IsNotEmpty","core::str::IsWhitespace","core::str::IsAsciiWhitespace"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 29]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 29] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 29] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 29]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 29] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 29]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 29] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 29] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 29]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 29]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 29]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 29]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 29]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 29]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 29]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 29]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 29]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 29]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 29]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 29]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 29]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 29]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 29]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 29]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 29]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 29] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 29]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 29] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 29] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 29]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 29] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 29]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 29] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 29] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 29]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 30] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 30]
+p0.input_len();
+<[u8; 30] as traits::InputLength>::input_len(p0);
+crate::<[u8; 30] as traits::InputLength>::input_len(p0);
+<[u8; 30]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 30] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 30]
+p0.input_len();
+<&'a [u8; 30] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 30] as traits::InputLength>::input_len(p0);
+<&'a [u8; 30]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 30] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 30]
+p0.iter_indices();
+<&'a [u8; 30] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 30] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 30]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 30] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 30]
+p0.iter_elements();
+<&'a [u8; 30] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 30] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 30]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 30] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 30] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 30] as traits::InputIter>::position":{"P":["core::slice::ascii::EscapeByte","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","core::str::IsWhitespace","core::str::LinesAnyMap","core::str::UnsafeBytesToStr","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::str::IsNotEmpty","core::str::CharEscapeUnicode","std::boxed::Box<F, A>"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 30]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 30] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 30] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 30]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 30] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 30]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 30] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 30] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 30]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 30]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 30]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 30]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 30]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 30]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 30]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 30]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 30]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 30]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 30]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 30]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 30]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 30]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 30]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 30]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 30]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 30] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 30]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 30] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 30] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 30]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 30] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 30]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 30] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 30] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 30]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 31] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 31]
+p0.input_len();
+<[u8; 31] as traits::InputLength>::input_len(p0);
+crate::<[u8; 31] as traits::InputLength>::input_len(p0);
+<[u8; 31]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 31] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 31]
+p0.input_len();
+<&'a [u8; 31] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 31] as traits::InputLength>::input_len(p0);
+<&'a [u8; 31]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 31] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 31]
+p0.iter_indices();
+<&'a [u8; 31] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 31] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 31]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 31] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 31]
+p0.iter_elements();
+<&'a [u8; 31] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 31] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 31]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 31] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 31] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 31] as traits::InputIter>::position":{"P":["std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::BytesIsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::CharEscapeDebugContinue","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::str::UnsafeBytesToStr","core::str::IsNotEmpty","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode","core::str::IsWhitespace"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 31]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 31] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 31] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 31]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 31] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 31]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 31] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 31] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 31]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 31]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 31]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 31]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 31]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 31]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 31]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 31]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 31]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 31]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 31]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 31]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 31]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 31]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 31]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 31]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 31]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 31] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 31]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 31] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 31] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 31]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 31] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 31]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 31] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 31] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 31]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 32] as traits::InputLength>::input_len
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 32]
+p0.input_len();
+<[u8; 32] as traits::InputLength>::input_len(p0);
+crate::<[u8; 32] as traits::InputLength>::input_len(p0);
+<[u8; 32]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 32] as traits::InputLength>::input_len
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 32]
+p0.input_len();
+<&'a [u8; 32] as traits::InputLength>::input_len(p0);
+crate::<&'a [u8; 32] as traits::InputLength>::input_len(p0);
+<&'a [u8; 32]>::input_len(p0);
-----------------
src/traits.rs <&'a [u8; 32] as traits::InputIter>::iter_indices
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 32]
+p0.iter_indices();
+<&'a [u8; 32] as traits::InputIter>::iter_indices(p0);
+crate::<&'a [u8; 32] as traits::InputIter>::iter_indices(p0);
+<&'a [u8; 32]>::iter_indices(p0);
-----------------
src/traits.rs <&'a [u8; 32] as traits::InputIter>::iter_elements
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 32]
+p0.iter_elements();
+<&'a [u8; 32] as traits::InputIter>::iter_elements(p0);
+crate::<&'a [u8; 32] as traits::InputIter>::iter_elements(p0);
+<&'a [u8; 32]>::iter_elements(p0);
-----------------
src/traits.rs <&'a [u8; 32] as traits::InputIter>::position
'a
deps:{"<&'a [u8; 32] as traits::InputIter>::position":{"P":["std::ops::Fn","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
candidates:{"<&'a [u8; 32] as traits::InputIter>::position":{"P":["core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::Fn<A> for &F>","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeUnicode","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::IsNotEmpty","core::slice::ascii::EscapeByte","core::str::BytesIsNotEmpty"]},"std::ops::function::impls::<impl std::ops::Fn<A> for &F>":{}}
let mut p0 = & [0u8;1]; // None+&'a [u8; 32]
let mut p1 = MaybeUninit::uninit().assume_init(); // P
+p0.position(p1);
+<&'a [u8; 32] as traits::InputIter>::position(p0, p1);
+crate::<&'a [u8; 32] as traits::InputIter>::position(p0, p1);
+<&'a [u8; 32]>::position(p0, p1);
-----------------
src/traits.rs <&'a [u8; 32] as traits::InputIter>::slice_index
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+&'a [u8; 32]
let mut p1 = 0usize; // None+usize
+p0.slice_index(p1);
+<&'a [u8; 32] as traits::InputIter>::slice_index(p0, p1);
+crate::<&'a [u8; 32] as traits::InputIter>::slice_index(p0, p1);
+<&'a [u8; 32]>::slice_index(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 32]>>::compare
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 32]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<[u8; 32]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 32]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<[u8; 32]>>::compare_no_case
'a
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = [0u8;1]; // None+[u8; 32]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<[u8; 32]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<[u8; 32]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 32]>>::compare
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 32]
+p0.compare(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 32]>>::compare(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 32]>>::compare(p0, p1);
+<&'a [u8]>::compare(p0, p1);
-----------------
src/traits.rs <&'a [u8] as traits::Compare<&'b [u8; 32]>>::compare_no_case
'a,'b
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&'a [u8]
let mut p1 = & [0u8;1]; // None+[u8; 32]
+p0.compare_no_case(p1);
+<&'a [u8] as traits::Compare<&'b [u8; 32]>>::compare_no_case(p0, p1);
+crate::<&'a [u8] as traits::Compare<&'b [u8; 32]>>::compare_no_case(p0, p1);
+<&'a [u8]>::compare_no_case(p0, p1);
-----------------
src/traits.rs <[u8; 32] as traits::FindToken<u8>>::find_token
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 32]
let mut p1 = 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 32] as traits::FindToken<u8>>::find_token(p0, p1);
+crate::<[u8; 32] as traits::FindToken<u8>>::find_token(p0, p1);
+<[u8; 32]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8; 32] as traits::FindToken<&'a u8>>::find_token
'a
deps:{}
candidates:{}
let mut p0 = & [0u8;1]; // None+[u8; 32]
let mut p1 = & 0u8; // None+u8
+p0.find_token(p1);
+<[u8; 32] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+crate::<[u8; 32] as traits::FindToken<&'a u8>>::find_token(p0, p1);
+<[u8; 32]>::find_token(p0, p1);
-----------------
src/traits.rs <[u8] as traits::ExtendInto>::new_builder
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.new_builder();
+<[u8] as traits::ExtendInto>::new_builder(p0);
+crate::<[u8] as traits::ExtendInto>::new_builder(p0);
+<[u8]>::new_builder(p0);
-----------------
src/traits.rs <[u8] as traits::ExtendInto>::extend_into
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.extend_into(p1);
+<[u8] as traits::ExtendInto>::extend_into(p0, p1);
+crate::<[u8] as traits::ExtendInto>::extend_into(p0, p1);
+<[u8]>::extend_into(p0, p1);
-----------------
src/traits.rs <&[u8] as traits::ExtendInto>::new_builder
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&[u8]
+p0.new_builder();
+<&[u8] as traits::ExtendInto>::new_builder(p0);
+crate::<&[u8] as traits::ExtendInto>::new_builder(p0);
+<&[u8]>::new_builder(p0);
-----------------
src/traits.rs <&[u8] as traits::ExtendInto>::extend_into
deps:{}
candidates:{}
let mut p0 = & [0u8].as_mut_slice(); // None+&[u8]
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.extend_into(p1);
+<&[u8] as traits::ExtendInto>::extend_into(p0, p1);
+crate::<&[u8] as traits::ExtendInto>::extend_into(p0, p1);
+<&[u8]>::extend_into(p0, p1);
-----------------
src/traits.rs <str as traits::ExtendInto>::new_builder
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+p0.new_builder();
+<str as traits::ExtendInto>::new_builder(&p0);
+crate::<str as traits::ExtendInto>::new_builder(&p0);
+<str>::new_builder(&p0);
-----------------
src/traits.rs <str as traits::ExtendInto>::extend_into
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut std::string::String::new(); // None+std::string::String
+p0.extend_into(p1);
+<str as traits::ExtendInto>::extend_into(&p0, p1);
+crate::<str as traits::ExtendInto>::extend_into(&p0, p1);
+<str>::extend_into(&p0, p1);
-----------------
src/traits.rs <&str as traits::ExtendInto>::new_builder
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&str
+p0.new_builder();
+<&str as traits::ExtendInto>::new_builder(p0);
+crate::<&str as traits::ExtendInto>::new_builder(p0);
+<&str>::new_builder(p0);
-----------------
src/traits.rs <&str as traits::ExtendInto>::extend_into
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&str
let mut p1 = &mut std::string::String::new(); // None+std::string::String
+p0.extend_into(p1);
+<&str as traits::ExtendInto>::extend_into(p0, p1);
+crate::<&str as traits::ExtendInto>::extend_into(p0, p1);
+<&str>::extend_into(p0, p1);
-----------------
src/traits.rs <char as traits::ExtendInto>::new_builder
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
+p0.new_builder();
+<char as traits::ExtendInto>::new_builder(p0);
+crate::<char as traits::ExtendInto>::new_builder(p0);
+<char>::new_builder(p0);
-----------------
src/traits.rs <char as traits::ExtendInto>::extend_into
deps:{}
candidates:{}
let mut p0 = & 'a'; // None+char
let mut p1 = &mut std::string::String::new(); // None+std::string::String
+p0.extend_into(p1);
+<char as traits::ExtendInto>::extend_into(p0, p1);
+crate::<char as traits::ExtendInto>::extend_into(p0, p1);
+<char>::extend_into(p0, p1);
-----------------
src/traits.rs <u8 as traits::ToUsize>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
+p0.to_usize();
+<u8 as traits::ToUsize>::to_usize(p0);
+crate::<u8 as traits::ToUsize>::to_usize(p0);
+<u8>::to_usize(p0);
-----------------
src/traits.rs <u16 as traits::ToUsize>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
+p0.to_usize();
+<u16 as traits::ToUsize>::to_usize(p0);
+crate::<u16 as traits::ToUsize>::to_usize(p0);
+<u16>::to_usize(p0);
-----------------
src/traits.rs <usize as traits::ToUsize>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
+p0.to_usize();
+<usize as traits::ToUsize>::to_usize(p0);
+crate::<usize as traits::ToUsize>::to_usize(p0);
+<usize>::to_usize(p0);
-----------------
src/traits.rs <u32 as traits::ToUsize>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
+p0.to_usize();
+<u32 as traits::ToUsize>::to_usize(p0);
+crate::<u32 as traits::ToUsize>::to_usize(p0);
+<u32>::to_usize(p0);
-----------------
src/traits.rs <u64 as traits::ToUsize>::to_usize
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
+p0.to_usize();
+<u64 as traits::ToUsize>::to_usize(p0);
+crate::<u64 as traits::ToUsize>::to_usize(p0);
+<u64>::to_usize(p0);
-----------------
src/traits.rs <((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert
deps:{"<((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert":{"I":["std::marker::Sized"]}}
candidates:{"<((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ((I, usize), error::ErrorKind)
+p0.convert();
+<((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert(p0);
+crate::<((I, usize), error::ErrorKind) as traits::ErrorConvert<(I, error::ErrorKind)>>::convert(p0);
+<((I, usize), error::ErrorKind)>::convert(p0);
-----------------
src/traits.rs <(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert
deps:{"<(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert":{"I":["std::marker::Sized"]}}
candidates:{"<(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // (I, error::ErrorKind)
+p0.convert();
+<(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert(p0);
+crate::<(I, error::ErrorKind) as traits::ErrorConvert<((I, usize), error::ErrorKind)>>::convert(p0);
+<(I, error::ErrorKind)>::convert(p0);
-----------------
src/traits.rs <error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert
deps:{"<error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert":{"I":["std::marker::Sized"]}}
candidates:{"<error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::Error<(I, usize)>
+p0.convert();
+<error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert(p0);
+crate::<error::Error<(I, usize)> as traits::ErrorConvert<error::Error<I>>>::convert(p0);
+<error::Error<(I, usize)>>::convert(p0);
-----------------
src/traits.rs <error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert
deps:{"<error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert":{"I":["std::marker::Sized"]}}
candidates:{"<error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::Error<I>
+p0.convert();
+<error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert(p0);
+crate::<error::Error<I> as traits::ErrorConvert<error::Error<(I, usize)>>>::convert(p0);
+<error::Error<I>>::convert(p0);
-----------------
src/traits.rs <error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert
deps:{"<error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert":{"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::VerboseError<(I, usize)>
+p0.convert();
+<error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert(p0);
+crate::<error::VerboseError<(I, usize)> as traits::ErrorConvert<error::VerboseError<I>>>::convert(p0);
+<error::VerboseError<(I, usize)>>::convert(p0);
-----------------
src/traits.rs <error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert
deps:{"<error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert":{"I":["std::marker::Sized"]}}
candidates:{"<error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert":{"I":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::VerboseError<I>
+p0.convert();
+<error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert(p0);
+crate::<error::VerboseError<I> as traits::ErrorConvert<error::VerboseError<(I, usize)>>>::convert(p0);
+<error::VerboseError<I>>::convert(p0);
-----------------
src/traits.rs <() as traits::ErrorConvert<()>>::convert
deps:{}
candidates:{}
let mut p0 = (); // None+()
+p0.convert();
+<() as traits::ErrorConvert<()>>::convert(p0);
+crate::<() as traits::ErrorConvert<()>>::convert(p0);
+<()>::convert(p0);
-----------------
src/traits.rs <[u8] as traits::HexDisplay>::to_hex
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = 0usize; // None+usize
+p0.to_hex(p1);
+<[u8] as traits::HexDisplay>::to_hex(p0, p1);
+crate::<[u8] as traits::HexDisplay>::to_hex(p0, p1);
+<[u8]>::to_hex(p0, p1);
-----------------
src/traits.rs <[u8] as traits::HexDisplay>::to_hex_from
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.to_hex_from(p1, p2);
+<[u8] as traits::HexDisplay>::to_hex_from(p0, p1, p2);
+crate::<[u8] as traits::HexDisplay>::to_hex_from(p0, p1, p2);
+<[u8]>::to_hex_from(p0, p1, p2);
-----------------
src/traits.rs <str as traits::HexDisplay>::to_hex
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0usize; // None+usize
+p0.to_hex(p1);
+<str as traits::HexDisplay>::to_hex(&p0, p1);
+crate::<str as traits::HexDisplay>::to_hex(&p0, p1);
+<str>::to_hex(&p0, p1);
-----------------
src/traits.rs <str as traits::HexDisplay>::to_hex_from
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+p0.to_hex_from(p1, p2);
+<str as traits::HexDisplay>::to_hex_from(&p0, p1, p2);
+crate::<str as traits::HexDisplay>::to_hex_from(&p0, p1, p2);
+<str>::to_hex_from(&p0, p1, p2);
-----------------
src/number/mod.rs <number::Endianness as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Endianness
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<number::Endianness as std::fmt::Debug>::fmt(p0, p1);
+crate::<number::Endianness as std::fmt::Debug>::fmt(p0, p1);
+<number::Endianness>::fmt(p0, p1);
-----------------
src/number/mod.rs <number::Endianness as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Endianness
let mut p1 = & MaybeUninit::uninit().assume_init(); // number::Endianness
+p0.eq(p1);
+<number::Endianness as std::cmp::PartialEq>::eq(p0, p1);
+crate::<number::Endianness as std::cmp::PartialEq>::eq(p0, p1);
+<number::Endianness>::eq(p0, p1);
-----------------
src/number/mod.rs <number::Endianness as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Endianness
+p0.assert_receiver_is_total_eq();
+<number::Endianness as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<number::Endianness as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<number::Endianness>::assert_receiver_is_total_eq(p0);
-----------------
src/number/mod.rs <number::Endianness as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Endianness
+p0.clone();
+<number::Endianness as std::clone::Clone>::clone(p0);
+crate::<number::Endianness as std::clone::Clone>::clone(p0);
+<number::Endianness>::clone(p0);