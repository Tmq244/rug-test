-----------------
src/features/impl_alloc.rs features::impl_alloc::encode_to_vec
deps:{"features::impl_alloc::encode_to_vec":{"C":["core::marker::Sized","config::Config"],"E":["enc::Encode","core::marker::Sized"]}}
candidates:{"features::impl_alloc::encode_to_vec":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // E
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+features::impl_alloc::encode_to_vec(p0, p1);
+crate::features::impl_alloc::encode_to_vec(p0, p1);
+crate::features::impl_alloc::encode_to_vec(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::decode_from_std_read
deps:{"features::impl_std::decode_from_std_read":{"C":["core::marker::Sized","config::Config"],"D":["core::marker::Sized","de::Decode"],"R":["core::marker::Sized","std::io::Read"]}}
candidates:{"features::impl_std::decode_from_std_read":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+features::impl_std::decode_from_std_read(p0, p1);
+crate::features::impl_std::decode_from_std_read(p0, p1);
+crate::features::impl_std::decode_from_std_read(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::encode_into_std_write
deps:{"features::impl_std::encode_into_std_write":{"C":["config::Config","core::marker::Sized"],"E":["core::marker::Sized","enc::Encode"],"W":["core::marker::Sized","std::io::Write"]}}
candidates:{"features::impl_std::encode_into_std_write":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // E
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = MaybeUninit::uninit().assume_init(); // C
+features::impl_std::encode_into_std_write(p0, p1, p2);
+crate::features::impl_std::encode_into_std_write(p0, p1, p2);
+crate::features::impl_std::encode_into_std_write(p0, p1, p2);
-----------------
src/varint/decode_signed.rs varint::decode_signed::varint_decode_i16
deps:{"varint::decode_signed::varint_decode_i16":{"R":["de::read::Reader","core::marker::Sized"]}}
candidates:{"varint::decode_signed::varint_decode_i16":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_signed::varint_decode_i16(p0, p1);
+crate::varint::decode_signed::varint_decode_i16(p0, p1);
+crate::varint::decode_signed::varint_decode_i16(p0, p1);
-----------------
src/varint/decode_signed.rs varint::decode_signed::varint_decode_i32
deps:{"varint::decode_signed::varint_decode_i32":{"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"varint::decode_signed::varint_decode_i32":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_signed::varint_decode_i32(p0, p1);
+crate::varint::decode_signed::varint_decode_i32(p0, p1);
+crate::varint::decode_signed::varint_decode_i32(p0, p1);
-----------------
src/varint/decode_signed.rs varint::decode_signed::varint_decode_i64
deps:{"varint::decode_signed::varint_decode_i64":{"R":["de::read::Reader","core::marker::Sized"]}}
candidates:{"varint::decode_signed::varint_decode_i64":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_signed::varint_decode_i64(p0, p1);
+crate::varint::decode_signed::varint_decode_i64(p0, p1);
+crate::varint::decode_signed::varint_decode_i64(p0, p1);
-----------------
src/varint/decode_signed.rs varint::decode_signed::varint_decode_i128
deps:{"varint::decode_signed::varint_decode_i128":{"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"varint::decode_signed::varint_decode_i128":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_signed::varint_decode_i128(p0, p1);
+crate::varint::decode_signed::varint_decode_i128(p0, p1);
+crate::varint::decode_signed::varint_decode_i128(p0, p1);
-----------------
src/varint/decode_signed.rs varint::decode_signed::varint_decode_isize
deps:{"varint::decode_signed::varint_decode_isize":{"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"varint::decode_signed::varint_decode_isize":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_signed::varint_decode_isize(p0, p1);
+crate::varint::decode_signed::varint_decode_isize(p0, p1);
+crate::varint::decode_signed::varint_decode_isize(p0, p1);
-----------------
src/varint/decode_unsigned.rs varint::decode_unsigned::deserialize_varint_cold_u16
deps:{"varint::decode_unsigned::deserialize_varint_cold_u16":{"R":["de::read::Reader","core::marker::Sized"]}}
candidates:{"varint::decode_unsigned::deserialize_varint_cold_u16":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_unsigned::deserialize_varint_cold_u16(p0, p1);
+crate::varint::decode_unsigned::deserialize_varint_cold_u16(p0, p1);
+crate::varint::decode_unsigned::deserialize_varint_cold_u16(p0, p1);
-----------------
src/varint/decode_unsigned.rs varint::decode_unsigned::deserialize_varint_cold_u32
deps:{"varint::decode_unsigned::deserialize_varint_cold_u32":{"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"varint::decode_unsigned::deserialize_varint_cold_u32":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_unsigned::deserialize_varint_cold_u32(p0, p1);
+crate::varint::decode_unsigned::deserialize_varint_cold_u32(p0, p1);
+crate::varint::decode_unsigned::deserialize_varint_cold_u32(p0, p1);
-----------------
src/varint/decode_unsigned.rs varint::decode_unsigned::deserialize_varint_cold_u64
deps:{"varint::decode_unsigned::deserialize_varint_cold_u64":{"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"varint::decode_unsigned::deserialize_varint_cold_u64":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_unsigned::deserialize_varint_cold_u64(p0, p1);
+crate::varint::decode_unsigned::deserialize_varint_cold_u64(p0, p1);
+crate::varint::decode_unsigned::deserialize_varint_cold_u64(p0, p1);
-----------------
src/varint/decode_unsigned.rs varint::decode_unsigned::deserialize_varint_cold_usize
deps:{"varint::decode_unsigned::deserialize_varint_cold_usize":{"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"varint::decode_unsigned::deserialize_varint_cold_usize":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_unsigned::deserialize_varint_cold_usize(p0, p1);
+crate::varint::decode_unsigned::deserialize_varint_cold_usize(p0, p1);
+crate::varint::decode_unsigned::deserialize_varint_cold_usize(p0, p1);
-----------------
src/varint/decode_unsigned.rs varint::decode_unsigned::deserialize_varint_cold_u128
deps:{"varint::decode_unsigned::deserialize_varint_cold_u128":{"R":["de::read::Reader","core::marker::Sized"]}}
candidates:{"varint::decode_unsigned::deserialize_varint_cold_u128":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_unsigned::deserialize_varint_cold_u128(p0, p1);
+crate::varint::decode_unsigned::deserialize_varint_cold_u128(p0, p1);
+crate::varint::decode_unsigned::deserialize_varint_cold_u128(p0, p1);
-----------------
src/varint/decode_unsigned.rs varint::decode_unsigned::invalid_varint_discriminant
deps:{"varint::decode_unsigned::invalid_varint_discriminant":{"T":["core::marker::Sized"]}}
candidates:{"varint::decode_unsigned::invalid_varint_discriminant":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::IntegerType
let mut p1 = MaybeUninit::uninit().assume_init(); // error::IntegerType
+varint::decode_unsigned::invalid_varint_discriminant(p0, p1);
+crate::varint::decode_unsigned::invalid_varint_discriminant(p0, p1);
+crate::varint::decode_unsigned::invalid_varint_discriminant(p0, p1);
-----------------
src/varint/decode_unsigned.rs varint::decode_unsigned::varint_decode_u16
deps:{"varint::decode_unsigned::varint_decode_u16":{"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"varint::decode_unsigned::varint_decode_u16":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_unsigned::varint_decode_u16(p0, p1);
+crate::varint::decode_unsigned::varint_decode_u16(p0, p1);
+crate::varint::decode_unsigned::varint_decode_u16(p0, p1);
-----------------
src/varint/decode_unsigned.rs varint::decode_unsigned::varint_decode_u32
deps:{"varint::decode_unsigned::varint_decode_u32":{"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"varint::decode_unsigned::varint_decode_u32":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_unsigned::varint_decode_u32(p0, p1);
+crate::varint::decode_unsigned::varint_decode_u32(p0, p1);
+crate::varint::decode_unsigned::varint_decode_u32(p0, p1);
-----------------
src/varint/decode_unsigned.rs varint::decode_unsigned::varint_decode_u64
deps:{"varint::decode_unsigned::varint_decode_u64":{"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"varint::decode_unsigned::varint_decode_u64":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_unsigned::varint_decode_u64(p0, p1);
+crate::varint::decode_unsigned::varint_decode_u64(p0, p1);
+crate::varint::decode_unsigned::varint_decode_u64(p0, p1);
-----------------
src/varint/decode_unsigned.rs varint::decode_unsigned::varint_decode_usize
deps:{"varint::decode_unsigned::varint_decode_usize":{"R":["de::read::Reader","core::marker::Sized"]}}
candidates:{"varint::decode_unsigned::varint_decode_usize":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_unsigned::varint_decode_usize(p0, p1);
+crate::varint::decode_unsigned::varint_decode_usize(p0, p1);
+crate::varint::decode_unsigned::varint_decode_usize(p0, p1);
-----------------
src/varint/decode_unsigned.rs varint::decode_unsigned::varint_decode_u128
deps:{"varint::decode_unsigned::varint_decode_u128":{"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"varint::decode_unsigned::varint_decode_u128":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
+varint::decode_unsigned::varint_decode_u128(p0, p1);
+crate::varint::decode_unsigned::varint_decode_u128(p0, p1);
+crate::varint::decode_unsigned::varint_decode_u128(p0, p1);
-----------------
src/varint/encode_signed.rs varint::encode_signed::varint_encode_i16
deps:{"varint::encode_signed::varint_encode_i16":{"W":["core::marker::Sized","enc::write::Writer"]}}
candidates:{"varint::encode_signed::varint_encode_i16":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
let mut p2 = 0i16; // None+i16
+varint::encode_signed::varint_encode_i16(p0, p1, p2);
+crate::varint::encode_signed::varint_encode_i16(p0, p1, p2);
+crate::varint::encode_signed::varint_encode_i16(p0, p1, p2);
-----------------
src/varint/encode_signed.rs varint::encode_signed::varint_encode_i32
deps:{"varint::encode_signed::varint_encode_i32":{"W":["core::marker::Sized","enc::write::Writer"]}}
candidates:{"varint::encode_signed::varint_encode_i32":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
let mut p2 = 0i32; // None+i32
+varint::encode_signed::varint_encode_i32(p0, p1, p2);
+crate::varint::encode_signed::varint_encode_i32(p0, p1, p2);
+crate::varint::encode_signed::varint_encode_i32(p0, p1, p2);
-----------------
src/varint/encode_signed.rs varint::encode_signed::varint_encode_i64
deps:{"varint::encode_signed::varint_encode_i64":{"W":["enc::write::Writer","core::marker::Sized"]}}
candidates:{"varint::encode_signed::varint_encode_i64":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
let mut p2 = 0i64; // None+i64
+varint::encode_signed::varint_encode_i64(p0, p1, p2);
+crate::varint::encode_signed::varint_encode_i64(p0, p1, p2);
+crate::varint::encode_signed::varint_encode_i64(p0, p1, p2);
-----------------
src/varint/encode_signed.rs varint::encode_signed::varint_encode_i128
deps:{"varint::encode_signed::varint_encode_i128":{"W":["core::marker::Sized","enc::write::Writer"]}}
candidates:{"varint::encode_signed::varint_encode_i128":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
let mut p2 = 0i128; // None+i128
+varint::encode_signed::varint_encode_i128(p0, p1, p2);
+crate::varint::encode_signed::varint_encode_i128(p0, p1, p2);
+crate::varint::encode_signed::varint_encode_i128(p0, p1, p2);
-----------------
src/varint/encode_signed.rs varint::encode_signed::varint_encode_isize
deps:{"varint::encode_signed::varint_encode_isize":{"W":["core::marker::Sized","enc::write::Writer"]}}
candidates:{"varint::encode_signed::varint_encode_isize":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
let mut p2 = 0isize; // None+isize
+varint::encode_signed::varint_encode_isize(p0, p1, p2);
+crate::varint::encode_signed::varint_encode_isize(p0, p1, p2);
+crate::varint::encode_signed::varint_encode_isize(p0, p1, p2);
-----------------
src/varint/encode_unsigned.rs varint::encode_unsigned::varint_encode_u16
deps:{"varint::encode_unsigned::varint_encode_u16":{"W":["core::marker::Sized","enc::write::Writer"]}}
candidates:{"varint::encode_unsigned::varint_encode_u16":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
let mut p2 = 0u16; // None+u16
+varint::encode_unsigned::varint_encode_u16(p0, p1, p2);
+crate::varint::encode_unsigned::varint_encode_u16(p0, p1, p2);
+crate::varint::encode_unsigned::varint_encode_u16(p0, p1, p2);
-----------------
src/varint/encode_unsigned.rs varint::encode_unsigned::varint_encode_u32
deps:{"varint::encode_unsigned::varint_encode_u32":{"W":["core::marker::Sized","enc::write::Writer"]}}
candidates:{"varint::encode_unsigned::varint_encode_u32":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
let mut p2 = 0u32; // None+u32
+varint::encode_unsigned::varint_encode_u32(p0, p1, p2);
+crate::varint::encode_unsigned::varint_encode_u32(p0, p1, p2);
+crate::varint::encode_unsigned::varint_encode_u32(p0, p1, p2);
-----------------
src/varint/encode_unsigned.rs varint::encode_unsigned::varint_encode_u64
deps:{"varint::encode_unsigned::varint_encode_u64":{"W":["core::marker::Sized","enc::write::Writer"]}}
candidates:{"varint::encode_unsigned::varint_encode_u64":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
let mut p2 = 0u64; // None+u64
+varint::encode_unsigned::varint_encode_u64(p0, p1, p2);
+crate::varint::encode_unsigned::varint_encode_u64(p0, p1, p2);
+crate::varint::encode_unsigned::varint_encode_u64(p0, p1, p2);
-----------------
src/varint/encode_unsigned.rs varint::encode_unsigned::varint_encode_u128
deps:{"varint::encode_unsigned::varint_encode_u128":{"W":["enc::write::Writer","core::marker::Sized"]}}
candidates:{"varint::encode_unsigned::varint_encode_u128":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
let mut p2 = 0u128; // None+u128
+varint::encode_unsigned::varint_encode_u128(p0, p1, p2);
+crate::varint::encode_unsigned::varint_encode_u128(p0, p1, p2);
+crate::varint::encode_unsigned::varint_encode_u128(p0, p1, p2);
-----------------
src/varint/encode_unsigned.rs varint::encode_unsigned::varint_encode_usize
deps:{"varint::encode_unsigned::varint_encode_usize":{"W":["core::marker::Sized","enc::write::Writer"]}}
candidates:{"varint::encode_unsigned::varint_encode_usize":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = MaybeUninit::uninit().assume_init(); // config::internal::Endian
let mut p2 = 0usize; // None+usize
+varint::encode_unsigned::varint_encode_usize(p0, p1, p2);
+crate::varint::encode_unsigned::varint_encode_usize(p0, p1, p2);
+crate::varint::encode_unsigned::varint_encode_usize(p0, p1, p2);
-----------------
src/config.rs config::standard
deps:{}
candidates:{}
+config::standard();
+crate::config::standard();
+crate::config::standard();
-----------------
src/config.rs config::legacy
deps:{}
candidates:{}
+config::legacy();
+crate::config::legacy();
+crate::config::legacy();
-----------------
src/config.rs config::generate
deps:{"config::generate":{"E":["core::marker::Sized"],"I":["core::marker::Sized"],"L":["core::marker::Sized"]}}
candidates:{"config::generate":{}}
+config::generate();
+crate::config::generate();
+crate::config::generate();
-----------------
src/de/impl_core.rs de::impl_core::collect_into_array
deps:{"de::impl_core::collect_into_array":{"E":["core::marker::Sized"],"I":["core::iter::Iterator","core::marker::Sized"],"T":["core::marker::Sized"]}}
candidates:{"de::impl_core::collect_into_array":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // I
+de::impl_core::collect_into_array(p0);
+crate::de::impl_core::collect_into_array(p0);
+crate::de::impl_core::collect_into_array(p0);
-----------------
src/de/impl_core.rs de::impl_core::slice_assume_init_mut
deps:{"de::impl_core::slice_assume_init_mut":{"T":["core::marker::Sized"]}}
candidates:{"de::impl_core::slice_assume_init_mut":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // [core::mem::MaybeUninit<T>]
+de::impl_core::slice_assume_init_mut(p0);
+crate::de::impl_core::slice_assume_init_mut(p0);
+crate::de::impl_core::slice_assume_init_mut(p0);
-----------------
src/de/impl_core.rs de::impl_core::uninit_array
deps:{"de::impl_core::uninit_array":{"T":["core::marker::Sized"]}}
candidates:{"de::impl_core::uninit_array":{}}
+de::impl_core::uninit_array();
+crate::de::impl_core::uninit_array();
+crate::de::impl_core::uninit_array();
-----------------
src/de/impl_core.rs de::impl_core::array_assume_init
deps:{"de::impl_core::array_assume_init":{"T":["core::marker::Sized"]}}
candidates:{"de::impl_core::array_assume_init":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // [core::mem::MaybeUninit<T>; N]
+de::impl_core::array_assume_init(p0);
+crate::de::impl_core::array_assume_init(p0);
+crate::de::impl_core::array_assume_init(p0);
-----------------
src/de/impls.rs de::impls::utf8_char_width
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+de::impls::utf8_char_width(p0);
+crate::de::impls::utf8_char_width(p0);
+crate::de::impls::utf8_char_width(p0);
-----------------
src/de/mod.rs de::decode_option_variant
deps:{"de::decode_option_variant":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::decode_option_variant":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
let mut p1 = "sample"; // None+&str
+de::decode_option_variant(p0, &p1);
+crate::de::decode_option_variant(p0, &p1);
+crate::de::decode_option_variant(p0, &p1);
-----------------
src/de/mod.rs de::decode_slice_len
deps:{"de::decode_slice_len":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::decode_slice_len":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::decode_slice_len(p0);
+crate::de::decode_slice_len(p0);
+crate::de::decode_slice_len(p0);
-----------------
src/enc/impls.rs enc::impls::encode_utf8
deps:{"enc::impls::encode_utf8":{"impl Writer":["enc::write::Writer","core::marker::Sized"]}}
candidates:{"enc::impls::encode_utf8":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // impl Writer
let mut p1 = 'a'; // None+char
+enc::impls::encode_utf8(p0, p1);
+crate::enc::impls::encode_utf8(p0, p1);
+crate::enc::impls::encode_utf8(p0, p1);
-----------------
src/enc/mod.rs enc::encode_option_variant
deps:{"enc::encode_option_variant":{"E":["core::marker::Sized","enc::Encoder"],"T":["core::marker::Sized"]}}
candidates:{"enc::encode_option_variant":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // E
let mut p1 = & MaybeUninit::uninit().assume_init(); // core::option::Option<T>
+enc::encode_option_variant(p0, p1);
+crate::enc::encode_option_variant(p0, p1);
+crate::enc::encode_option_variant(p0, p1);
-----------------
src/enc/mod.rs enc::encode_slice_len
deps:{"enc::encode_slice_len":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::encode_slice_len":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // E
let mut p1 = 0usize; // None+usize
+enc::encode_slice_len(p0, p1);
+crate::enc::encode_slice_len(p0, p1);
+crate::enc::encode_slice_len(p0, p1);
-----------------
src/lib.rs encode_into_slice
deps:{"encode_into_slice":{"C":["config::Config","core::marker::Sized"],"E":["enc::Encode","core::marker::Sized"]}}
candidates:{"encode_into_slice":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // E
let mut p1 = &mut [0u8].as_mut_slice(); // None+[u8]
let mut p2 = MaybeUninit::uninit().assume_init(); // C
+encode_into_slice(p0, p1, p2);
+crate::encode_into_slice(p0, p1, p2);
+crate::encode_into_slice(p0, p1, p2);
-----------------
src/lib.rs encode_into_writer
deps:{"encode_into_writer":{"C":["core::marker::Sized","config::Config"],"E":["enc::Encode","core::marker::Sized"],"W":["enc::write::Writer","core::marker::Sized"]}}
candidates:{"encode_into_writer":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // E
let mut p1 = MaybeUninit::uninit().assume_init(); // W
let mut p2 = MaybeUninit::uninit().assume_init(); // C
+encode_into_writer(p0, p1, p2);
+crate::encode_into_writer(p0, p1, p2);
+crate::encode_into_writer(p0, p1, p2);
-----------------
src/lib.rs decode_from_slice
deps:{"decode_from_slice":{"C":["core::marker::Sized","config::Config"],"D":["de::Decode","core::marker::Sized"]}}
candidates:{"decode_from_slice":{}}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+decode_from_slice(p0, p1);
+crate::decode_from_slice(p0, p1);
+crate::decode_from_slice(p0, p1);
-----------------
src/lib.rs borrow_decode_from_slice
'a
deps:{"borrow_decode_from_slice":{"C":["core::marker::Sized","config::Config"],"D":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"borrow_decode_from_slice":{}}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+borrow_decode_from_slice(p0, p1);
+crate::borrow_decode_from_slice(p0, p1);
+crate::borrow_decode_from_slice(p0, p1);
-----------------
src/lib.rs decode_from_reader
deps:{"decode_from_reader":{"C":["core::marker::Sized","config::Config"],"D":["de::Decode","core::marker::Sized"],"R":["de::read::Reader","core::marker::Sized"]}}
candidates:{"decode_from_reader":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+decode_from_reader(p0, p1);
+crate::decode_from_reader(p0, p1);
+crate::decode_from_reader(p0, p1);
-----------------
src/de/read.rs de::read::Reader::read
deps:{"<&mut T as de::read::Reader>":{},"de::read::Reader::read":{"Self":["de::read::Reader"]},"features::impl_std::IoReader":{"R":["std::io::Read","core::marker::Sized"]},"std::io::BufReader":{"R":["core::marker::Sized","std::io::Read"]}}
candidates:{"<&mut T as de::read::Reader>":{},"de::read::Reader::read":{"Self":["<&mut T as de::read::Reader>","features::impl_std::IoReader","de::read::SliceReader","std::io::BufReader"]},"features::impl_std::IoReader":{},"std::io::BufReader":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut [0u8].as_mut_slice(); // None+[u8]
+p0.read(p1);
+de::read::Reader::read(p0, p1);
+crate::de::read::Reader::read(p0, p1);
+crate::de::read::Reader::read(p0, p1);
-----------------
src/de/read.rs de::read::Reader::peek_read
deps:{"<&mut T as de::read::Reader>":{},"de::read::Reader::peek_read":{"Self":["de::read::Reader"]},"features::impl_std::IoReader":{"R":["std::io::Read","core::marker::Sized"]},"std::io::BufReader":{"R":["std::io::Read","core::marker::Sized"]}}
candidates:{"<&mut T as de::read::Reader>":{},"de::read::Reader::peek_read":{"Self":["de::read::SliceReader","<&mut T as de::read::Reader>","std::io::BufReader","features::impl_std::IoReader"]},"features::impl_std::IoReader":{},"std::io::BufReader":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.peek_read(p1);
+de::read::Reader::peek_read(p0, p1);
+crate::de::read::Reader::peek_read(p0, p1);
+crate::de::read::Reader::peek_read(p0, p1);
-----------------
src/de/read.rs de::read::Reader::consume
deps:{"<&mut T as de::read::Reader>":{},"de::read::Reader::consume":{"Self":["de::read::Reader"]},"features::impl_std::IoReader":{"R":["std::io::Read","core::marker::Sized"]},"std::io::BufReader":{"R":["core::marker::Sized","std::io::Read"]}}
candidates:{"<&mut T as de::read::Reader>":{},"de::read::Reader::consume":{"Self":["<&mut T as de::read::Reader>","features::impl_std::IoReader","de::read::SliceReader","std::io::BufReader"]},"features::impl_std::IoReader":{},"std::io::BufReader":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.consume(p1);
+de::read::Reader::consume(p0, p1);
+crate::de::read::Reader::consume(p0, p1);
+crate::de::read::Reader::consume(p0, p1);
-----------------
src/de/read.rs de::read::BorrowReader::take_bytes
'storage
deps:{"de::read::BorrowReader::take_bytes":{"Self":["de::read::Reader","de::read::BorrowReader"]}}
candidates:{"de::read::BorrowReader::take_bytes":{"Self":["de::read::SliceReader"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.take_bytes(p1);
+de::read::BorrowReader::take_bytes(p0, p1);
+crate::de::read::BorrowReader::take_bytes(p0, p1);
+crate::de::read::BorrowReader::take_bytes(p0, p1);
-----------------
src/de/mod.rs de::Decode::decode
deps:{"de::Decode::decode":{"D":["de::Decoder","core::marker::Sized"],"Self":["core::marker::Sized","de::Decode"]}}
candidates:{"de::Decode::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::Decode::decode(p0);
+crate::de::Decode::decode(p0);
+crate::de::Decode::decode(p0);
-----------------
src/de/mod.rs de::BorrowDecode::borrow_decode
'de
deps:{"de::BorrowDecode::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"Self":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::BorrowDecode::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::BorrowDecode::borrow_decode(p0);
+crate::de::BorrowDecode::borrow_decode(p0);
+crate::de::BorrowDecode::borrow_decode(p0);
-----------------
src/de/mod.rs de::Decoder::reader
deps:{"<&'a mut T as de::Decoder>":{},"de::Decoder::reader":{"Self":["utils::Sealed","de::Decoder"]},"de::decoder::DecoderImpl":{"C":["core::marker::Sized","config::Config"],"R":["de::read::BorrowReader","core::marker::Sized","de::read::Reader"]}}
candidates:{"<&'a mut T as de::Decoder>":{},"de::Decoder::reader":{"Self":["<&'a mut T as de::Decoder>","de::decoder::DecoderImpl"]},"de::decoder::DecoderImpl":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.reader();
+de::Decoder::reader(p0);
+crate::de::Decoder::reader(p0);
+crate::de::Decoder::reader(p0);
-----------------
src/de/mod.rs de::Decoder::config
deps:{"<&'a mut T as utils::Sealed>":{},"de::Decoder::config":{"Self":["utils::Sealed","de::Decoder"]},"de::decoder::DecoderImpl":{"C":["core::marker::Sized","config::Config"],"R":["de::read::Reader","core::marker::Sized","de::read::BorrowReader"]}}
candidates:{"<&'a mut T as utils::Sealed>":{},"de::Decoder::config":{"Self":["<&'a mut T as utils::Sealed>","de::decoder::DecoderImpl"]},"de::decoder::DecoderImpl":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.config();
+de::Decoder::config(p0);
+crate::de::Decoder::config(p0);
+crate::de::Decoder::config(p0);
-----------------
src/de/mod.rs de::Decoder::claim_bytes_read
deps:{"<&'a mut T as de::Decoder>":{},"<&'a mut T as utils::Sealed>":{},"de::Decoder::claim_bytes_read":{"Self":["utils::Sealed","de::Decoder"]},"de::decoder::DecoderImpl":{"C":["core::marker::Sized","config::Config"],"R":["de::read::BorrowReader","de::read::Reader","core::marker::Sized"]}}
candidates:{"<&'a mut T as de::Decoder>":{},"<&'a mut T as utils::Sealed>":{},"de::Decoder::claim_bytes_read":{"Self":["<&'a mut T as de::Decoder>","<&'a mut T as utils::Sealed>","de::decoder::DecoderImpl"]},"de::decoder::DecoderImpl":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.claim_bytes_read(p1);
+de::Decoder::claim_bytes_read(p0, p1);
+crate::de::Decoder::claim_bytes_read(p0, p1);
+crate::de::Decoder::claim_bytes_read(p0, p1);
-----------------
src/de/mod.rs de::Decoder::claim_container_read
deps:{"<&'a mut T as utils::Sealed>":{},"de::Decoder::claim_container_read":{"Self":["utils::Sealed","de::Decoder"],"T":["core::marker::Sized"]},"de::decoder::DecoderImpl":{"C":["config::Config","core::marker::Sized"],"R":["de::read::BorrowReader","core::marker::Sized","de::read::Reader"]}}
candidates:{"<&'a mut T as utils::Sealed>":{},"de::Decoder::claim_container_read":{"Self":["de::decoder::DecoderImpl","<&'a mut T as utils::Sealed>"]},"de::decoder::DecoderImpl":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.claim_container_read(p1);
+de::Decoder::claim_container_read(p0, p1);
+crate::de::Decoder::claim_container_read(p0, p1);
+crate::de::Decoder::claim_container_read(p0, p1);
-----------------
src/de/mod.rs de::Decoder::unclaim_bytes_read
deps:{"<&'a mut T as de::Decoder>":{},"<&'a mut T as utils::Sealed>":{},"de::Decoder::unclaim_bytes_read":{"Self":["utils::Sealed","de::Decoder"]},"de::decoder::DecoderImpl":{"C":["core::marker::Sized","config::Config"],"R":["de::read::BorrowReader","core::marker::Sized","de::read::Reader"]}}
candidates:{"<&'a mut T as de::Decoder>":{},"<&'a mut T as utils::Sealed>":{},"de::Decoder::unclaim_bytes_read":{"Self":["<&'a mut T as utils::Sealed>","<&'a mut T as de::Decoder>","de::decoder::DecoderImpl"]},"de::decoder::DecoderImpl":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = 0usize; // None+usize
+p0.unclaim_bytes_read(p1);
+de::Decoder::unclaim_bytes_read(p0, p1);
+crate::de::Decoder::unclaim_bytes_read(p0, p1);
+crate::de::Decoder::unclaim_bytes_read(p0, p1);
-----------------
src/de/mod.rs de::BorrowDecoder::borrow_reader
'de
deps:{"<&'a mut T as de::BorrowDecoder<'de>>":{},"de::BorrowDecoder::borrow_reader":{"Self":["de::Decoder","de::BorrowDecoder"]},"de::decoder::DecoderImpl":{"C":["core::marker::Sized","config::Config"],"R":["de::read::Reader","core::marker::Sized","de::read::BorrowReader"]}}
candidates:{"<&'a mut T as de::BorrowDecoder<'de>>":{},"de::BorrowDecoder::borrow_reader":{"Self":["<&'a mut T as de::BorrowDecoder<'de>>","de::decoder::DecoderImpl"]},"de::decoder::DecoderImpl":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.borrow_reader();
+de::BorrowDecoder::borrow_reader(p0);
+crate::de::BorrowDecoder::borrow_reader(p0);
+crate::de::BorrowDecoder::borrow_reader(p0);
-----------------
src/enc/write.rs enc::write::Writer::write
deps:{"<&mut T as enc::write::Writer>":{},"enc::write::Writer::write":{"Self":["enc::write::Writer"]},"features::impl_std::IoWriter":{"W":["core::marker::Sized","std::io::Write"]}}
candidates:{"<&mut T as enc::write::Writer>":{},"enc::write::Writer::write":{"Self":["<&mut T as enc::write::Writer>","features::impl_std::IoWriter","enc::write::SizeWriter","features::impl_alloc::VecWriter","enc::write::SliceWriter"]},"features::impl_std::IoWriter":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.write(p1);
+enc::write::Writer::write(p0, p1);
+crate::enc::write::Writer::write(p0, p1);
+crate::enc::write::Writer::write(p0, p1);
-----------------
src/enc/mod.rs enc::Encode::encode
deps:{"<T as alloc::borrow::ToOwned>":{"T":["core::marker::Sized","core::clone::Clone"]},"alloc::borrow::Cow":{"B":["alloc::borrow::ToOwned"]},"alloc::boxed::Box":{"A":["core::alloc::Allocator","core::marker::Sized"]},"alloc::collections::BTreeMap":{"A":["core::marker::Sized","core::alloc::Allocator","core::clone::Clone"],"K":["de::BorrowDecode","core::cmp::Ord","enc::Encode","core::marker::Sized","de::Decode"],"V":["de::Decode","enc::Encode","de::BorrowDecode","core::marker::Sized"]},"alloc::collections::BTreeSet":{"A":["core::marker::Sized","core::clone::Clone","core::alloc::Allocator"],"T":["core::marker::Sized","de::Decode","core::cmp::Ord","de::BorrowDecode","enc::Encode"]},"alloc::collections::BinaryHeap":{"T":["core::marker::Sized","core::cmp::Ord","de::Decode","enc::Encode","de::BorrowDecode"]},"alloc::collections::VecDeque":{"A":["core::marker::Sized","core::alloc::Allocator"],"T":["core::marker::Sized","de::BorrowDecode","enc::Encode","de::Decode"]},"alloc::vec::Vec":{"A":["core::marker::Sized","core::alloc::Allocator"],"T":["core::marker::Sized","de::Decode","enc::Encode","de::BorrowDecode"]},"core::ops::Bound":{"T":["core::marker::Sized","enc::Encode","de::Decode","de::BorrowDecode"]},"core::ops::Range":{"Idx":["core::marker::Sized"]},"core::ops::RangeInclusive":{"Idx":["core::marker::Sized"]},"core::option::Option":{"T":["de::Decode","core::marker::Sized","de::BorrowDecode","enc::Encode"]},"core::result::Result":{"E":["core::marker::Sized"],"T":["de::Decode","core::marker::Sized","enc::Encode","de::BorrowDecode"]},"enc::Encode::encode":{"E":["core::marker::Sized","enc::Encoder"],"Self":["enc::Encode"]},"enc::impls::<impl enc::Encode for &'a T>":{},"std::collections::HashMap":{"K":["core::marker::Sized","core::cmp::Eq","de::Decode","de::BorrowDecode","enc::Encode","core::hash::Hash"],"S":["core::default::Default","core::hash::BuildHasher","core::marker::Sized"],"V":["core::marker::Sized","enc::Encode","de::Decode","de::BorrowDecode"]},"std::collections::HashSet":{"S":["core::hash::BuildHasher","core::marker::Sized","core::default::Default"],"T":["core::marker::Sized","de::Decode","enc::Encode","core::hash::Hash","core::cmp::Eq","de::BorrowDecode"]}}
candidates:{"<T as alloc::borrow::ToOwned>":{},"alloc::borrow::Cow":{"B":["std::path::Path","std::ffi::OsStr","core::ffi::CStr","<T as alloc::borrow::ToOwned>"]},"alloc::boxed::Box":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeMap":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeSet":{"A":["alloc::alloc::Global"]},"alloc::collections::BinaryHeap":{},"alloc::collections::VecDeque":{"A":["alloc::alloc::Global"]},"alloc::vec::Vec":{"A":["alloc::alloc::Global"]},"core::ops::Bound":{},"core::ops::Range":{},"core::ops::RangeInclusive":{},"core::option::Option":{},"core::result::Result":{},"enc::Encode::encode":{"Self":["core::ops::Bound","core::sync::atomic::AtomicU64","alloc::ffi::CString","core::num::NonZeroUsize","core::cell::Cell","alloc::vec::Vec","core::ops::RangeInclusive","std::net::IpAddr","core::result::Result","core::sync::atomic::AtomicBool","core::sync::atomic::AtomicI64","core::sync::atomic::AtomicI8","core::num::NonZeroI64","core::sync::atomic::AtomicU16","core::sync::atomic::AtomicU32","alloc::sync::Arc","core::cell::RefCell","core::sync::atomic::AtomicU8","core::num::NonZeroI32","core::option::Option","core::sync::atomic::AtomicI16","std::sync::Mutex","core::num::NonZeroU32","core::marker::PhantomData","core::ops::Range","core::num::NonZeroI8","core::num::NonZeroU16","alloc::collections::BTreeSet","core::num::NonZeroU8","std::net::SocketAddrV4","std::sync::RwLock","core::num::NonZeroU128","std::net::SocketAddrV6","alloc::rc::Rc","alloc::collections::BinaryHeap","std::path::PathBuf","alloc::collections::VecDeque","core::sync::atomic::AtomicUsize","std::net::Ipv6Addr","std::time::SystemTime","alloc::collections::BTreeMap","core::num::NonZeroI16","std::net::SocketAddr","core::num::NonZeroI128","core::num::NonZeroIsize","core::num::NonZeroU64","enc::impls::<impl enc::Encode for &'a T>","core::sync::atomic::AtomicI32","std::collections::HashSet","alloc::borrow::Cow","core::sync::atomic::AtomicIsize","core::time::Duration","alloc::string::String","alloc::boxed::Box","std::net::Ipv4Addr","std::collections::HashMap"]},"enc::impls::<impl enc::Encode for &'a T>":{},"std::collections::HashMap":{"S":["std::collections::hash_map::RandomState"]},"std::collections::HashSet":{"S":["std::collections::hash_map::RandomState"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::Encode::encode(p0, p1);
+crate::enc::Encode::encode(p0, p1);
+crate::enc::Encode::encode(p0, p1);
-----------------
src/enc/mod.rs enc::Encoder::writer
deps:{"<&'a mut T as utils::Sealed>":{},"enc::Encoder::writer":{"Self":["enc::Encoder","utils::Sealed"]},"enc::encoder::EncoderImpl":{"C":["config::Config","core::marker::Sized"],"W":["enc::write::Writer","core::marker::Sized"]}}
candidates:{"<&'a mut T as utils::Sealed>":{},"enc::Encoder::writer":{"Self":["enc::encoder::EncoderImpl","<&'a mut T as utils::Sealed>"]},"enc::encoder::EncoderImpl":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.writer();
+enc::Encoder::writer(p0);
+crate::enc::Encoder::writer(p0);
+crate::enc::Encoder::writer(p0);
-----------------
src/enc/mod.rs enc::Encoder::config
deps:{"<&'a mut T as utils::Sealed>":{},"enc::Encoder::config":{"Self":["enc::Encoder","utils::Sealed"]},"enc::encoder::EncoderImpl":{"C":["config::Config","core::marker::Sized"],"W":["core::marker::Sized","enc::write::Writer"]}}
candidates:{"<&'a mut T as utils::Sealed>":{},"enc::Encoder::config":{"Self":["<&'a mut T as utils::Sealed>","enc::encoder::EncoderImpl"]},"enc::encoder::EncoderImpl":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.config();
+enc::Encoder::config(p0);
+crate::enc::Encoder::config(p0);
+crate::enc::Encoder::config(p0);
-----------------
src/atomic.rs atomic::<impl enc::Encode for core::sync::atomic::AtomicBool>::encode
deps:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicBool>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicBool>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::sync::atomic::AtomicBool
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+atomic::<impl enc::Encode for core::sync::atomic::AtomicBool>::encode(p0, p1);
+crate::atomic::<impl enc::Encode for core::sync::atomic::AtomicBool>::encode(p0, p1);
+<core::sync::atomic::AtomicBool>::encode(p0, p1);
-----------------
src/atomic.rs atomic::<impl de::Decode for core::sync::atomic::AtomicBool>::decode
deps:{"atomic::<impl de::Decode for core::sync::atomic::AtomicBool>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"atomic::<impl de::Decode for core::sync::atomic::AtomicBool>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::Decode for core::sync::atomic::AtomicBool>::decode(p0);
+crate::atomic::<impl de::Decode for core::sync::atomic::AtomicBool>::decode(p0);
+<core::sync::atomic::AtomicBool>::decode(p0);
-----------------
src/de/mod.rs atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicBool>::borrow_decode
'de
deps:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicBool>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicBool>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicBool>::borrow_decode(p0);
+crate::atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicBool>::borrow_decode(p0);
+<core::sync::atomic::AtomicBool>::borrow_decode(p0);
-----------------
src/atomic.rs atomic::<impl enc::Encode for core::sync::atomic::AtomicU8>::encode
deps:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicU8>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicU8>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::sync::atomic::AtomicU8
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+atomic::<impl enc::Encode for core::sync::atomic::AtomicU8>::encode(p0, p1);
+crate::atomic::<impl enc::Encode for core::sync::atomic::AtomicU8>::encode(p0, p1);
+<core::sync::atomic::AtomicU8>::encode(p0, p1);
-----------------
src/atomic.rs atomic::<impl de::Decode for core::sync::atomic::AtomicU8>::decode
deps:{"atomic::<impl de::Decode for core::sync::atomic::AtomicU8>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"atomic::<impl de::Decode for core::sync::atomic::AtomicU8>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::Decode for core::sync::atomic::AtomicU8>::decode(p0);
+crate::atomic::<impl de::Decode for core::sync::atomic::AtomicU8>::decode(p0);
+<core::sync::atomic::AtomicU8>::decode(p0);
-----------------
src/de/mod.rs atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU8>::borrow_decode
'de
deps:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU8>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU8>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU8>::borrow_decode(p0);
+crate::atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU8>::borrow_decode(p0);
+<core::sync::atomic::AtomicU8>::borrow_decode(p0);
-----------------
src/atomic.rs atomic::<impl enc::Encode for core::sync::atomic::AtomicU16>::encode
deps:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicU16>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicU16>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::sync::atomic::AtomicU16
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+atomic::<impl enc::Encode for core::sync::atomic::AtomicU16>::encode(p0, p1);
+crate::atomic::<impl enc::Encode for core::sync::atomic::AtomicU16>::encode(p0, p1);
+<core::sync::atomic::AtomicU16>::encode(p0, p1);
-----------------
src/atomic.rs atomic::<impl de::Decode for core::sync::atomic::AtomicU16>::decode
deps:{"atomic::<impl de::Decode for core::sync::atomic::AtomicU16>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"atomic::<impl de::Decode for core::sync::atomic::AtomicU16>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::Decode for core::sync::atomic::AtomicU16>::decode(p0);
+crate::atomic::<impl de::Decode for core::sync::atomic::AtomicU16>::decode(p0);
+<core::sync::atomic::AtomicU16>::decode(p0);
-----------------
src/de/mod.rs atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU16>::borrow_decode
'de
deps:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU16>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU16>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU16>::borrow_decode(p0);
+crate::atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU16>::borrow_decode(p0);
+<core::sync::atomic::AtomicU16>::borrow_decode(p0);
-----------------
src/atomic.rs atomic::<impl enc::Encode for core::sync::atomic::AtomicU32>::encode
deps:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicU32>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicU32>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::sync::atomic::AtomicU32
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+atomic::<impl enc::Encode for core::sync::atomic::AtomicU32>::encode(p0, p1);
+crate::atomic::<impl enc::Encode for core::sync::atomic::AtomicU32>::encode(p0, p1);
+<core::sync::atomic::AtomicU32>::encode(p0, p1);
-----------------
src/atomic.rs atomic::<impl de::Decode for core::sync::atomic::AtomicU32>::decode
deps:{"atomic::<impl de::Decode for core::sync::atomic::AtomicU32>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"atomic::<impl de::Decode for core::sync::atomic::AtomicU32>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::Decode for core::sync::atomic::AtomicU32>::decode(p0);
+crate::atomic::<impl de::Decode for core::sync::atomic::AtomicU32>::decode(p0);
+<core::sync::atomic::AtomicU32>::decode(p0);
-----------------
src/de/mod.rs atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU32>::borrow_decode
'de
deps:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU32>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU32>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU32>::borrow_decode(p0);
+crate::atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU32>::borrow_decode(p0);
+<core::sync::atomic::AtomicU32>::borrow_decode(p0);
-----------------
src/atomic.rs atomic::<impl enc::Encode for core::sync::atomic::AtomicU64>::encode
deps:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicU64>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicU64>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::sync::atomic::AtomicU64
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+atomic::<impl enc::Encode for core::sync::atomic::AtomicU64>::encode(p0, p1);
+crate::atomic::<impl enc::Encode for core::sync::atomic::AtomicU64>::encode(p0, p1);
+<core::sync::atomic::AtomicU64>::encode(p0, p1);
-----------------
src/atomic.rs atomic::<impl de::Decode for core::sync::atomic::AtomicU64>::decode
deps:{"atomic::<impl de::Decode for core::sync::atomic::AtomicU64>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"atomic::<impl de::Decode for core::sync::atomic::AtomicU64>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::Decode for core::sync::atomic::AtomicU64>::decode(p0);
+crate::atomic::<impl de::Decode for core::sync::atomic::AtomicU64>::decode(p0);
+<core::sync::atomic::AtomicU64>::decode(p0);
-----------------
src/de/mod.rs atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU64>::borrow_decode
'de
deps:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU64>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU64>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU64>::borrow_decode(p0);
+crate::atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU64>::borrow_decode(p0);
+<core::sync::atomic::AtomicU64>::borrow_decode(p0);
-----------------
src/atomic.rs atomic::<impl enc::Encode for core::sync::atomic::AtomicUsize>::encode
deps:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicUsize>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicUsize>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::sync::atomic::AtomicUsize
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+atomic::<impl enc::Encode for core::sync::atomic::AtomicUsize>::encode(p0, p1);
+crate::atomic::<impl enc::Encode for core::sync::atomic::AtomicUsize>::encode(p0, p1);
+<core::sync::atomic::AtomicUsize>::encode(p0, p1);
-----------------
src/atomic.rs atomic::<impl de::Decode for core::sync::atomic::AtomicUsize>::decode
deps:{"atomic::<impl de::Decode for core::sync::atomic::AtomicUsize>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"atomic::<impl de::Decode for core::sync::atomic::AtomicUsize>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::Decode for core::sync::atomic::AtomicUsize>::decode(p0);
+crate::atomic::<impl de::Decode for core::sync::atomic::AtomicUsize>::decode(p0);
+<core::sync::atomic::AtomicUsize>::decode(p0);
-----------------
src/de/mod.rs atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicUsize>::borrow_decode
'de
deps:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicUsize>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicUsize>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicUsize>::borrow_decode(p0);
+crate::atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicUsize>::borrow_decode(p0);
+<core::sync::atomic::AtomicUsize>::borrow_decode(p0);
-----------------
src/atomic.rs atomic::<impl enc::Encode for core::sync::atomic::AtomicI8>::encode
deps:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicI8>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicI8>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::sync::atomic::AtomicI8
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+atomic::<impl enc::Encode for core::sync::atomic::AtomicI8>::encode(p0, p1);
+crate::atomic::<impl enc::Encode for core::sync::atomic::AtomicI8>::encode(p0, p1);
+<core::sync::atomic::AtomicI8>::encode(p0, p1);
-----------------
src/atomic.rs atomic::<impl de::Decode for core::sync::atomic::AtomicI8>::decode
deps:{"atomic::<impl de::Decode for core::sync::atomic::AtomicI8>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"atomic::<impl de::Decode for core::sync::atomic::AtomicI8>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::Decode for core::sync::atomic::AtomicI8>::decode(p0);
+crate::atomic::<impl de::Decode for core::sync::atomic::AtomicI8>::decode(p0);
+<core::sync::atomic::AtomicI8>::decode(p0);
-----------------
src/de/mod.rs atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI8>::borrow_decode
'de
deps:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI8>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI8>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI8>::borrow_decode(p0);
+crate::atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI8>::borrow_decode(p0);
+<core::sync::atomic::AtomicI8>::borrow_decode(p0);
-----------------
src/atomic.rs atomic::<impl enc::Encode for core::sync::atomic::AtomicI16>::encode
deps:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicI16>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicI16>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::sync::atomic::AtomicI16
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+atomic::<impl enc::Encode for core::sync::atomic::AtomicI16>::encode(p0, p1);
+crate::atomic::<impl enc::Encode for core::sync::atomic::AtomicI16>::encode(p0, p1);
+<core::sync::atomic::AtomicI16>::encode(p0, p1);
-----------------
src/atomic.rs atomic::<impl de::Decode for core::sync::atomic::AtomicI16>::decode
deps:{"atomic::<impl de::Decode for core::sync::atomic::AtomicI16>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"atomic::<impl de::Decode for core::sync::atomic::AtomicI16>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::Decode for core::sync::atomic::AtomicI16>::decode(p0);
+crate::atomic::<impl de::Decode for core::sync::atomic::AtomicI16>::decode(p0);
+<core::sync::atomic::AtomicI16>::decode(p0);
-----------------
src/de/mod.rs atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI16>::borrow_decode
'de
deps:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI16>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI16>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI16>::borrow_decode(p0);
+crate::atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI16>::borrow_decode(p0);
+<core::sync::atomic::AtomicI16>::borrow_decode(p0);
-----------------
src/atomic.rs atomic::<impl enc::Encode for core::sync::atomic::AtomicI32>::encode
deps:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicI32>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicI32>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::sync::atomic::AtomicI32
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+atomic::<impl enc::Encode for core::sync::atomic::AtomicI32>::encode(p0, p1);
+crate::atomic::<impl enc::Encode for core::sync::atomic::AtomicI32>::encode(p0, p1);
+<core::sync::atomic::AtomicI32>::encode(p0, p1);
-----------------
src/atomic.rs atomic::<impl de::Decode for core::sync::atomic::AtomicI32>::decode
deps:{"atomic::<impl de::Decode for core::sync::atomic::AtomicI32>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"atomic::<impl de::Decode for core::sync::atomic::AtomicI32>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::Decode for core::sync::atomic::AtomicI32>::decode(p0);
+crate::atomic::<impl de::Decode for core::sync::atomic::AtomicI32>::decode(p0);
+<core::sync::atomic::AtomicI32>::decode(p0);
-----------------
src/de/mod.rs atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI32>::borrow_decode
'de
deps:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI32>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI32>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI32>::borrow_decode(p0);
+crate::atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI32>::borrow_decode(p0);
+<core::sync::atomic::AtomicI32>::borrow_decode(p0);
-----------------
src/atomic.rs atomic::<impl enc::Encode for core::sync::atomic::AtomicI64>::encode
deps:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicI64>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicI64>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::sync::atomic::AtomicI64
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+atomic::<impl enc::Encode for core::sync::atomic::AtomicI64>::encode(p0, p1);
+crate::atomic::<impl enc::Encode for core::sync::atomic::AtomicI64>::encode(p0, p1);
+<core::sync::atomic::AtomicI64>::encode(p0, p1);
-----------------
src/atomic.rs atomic::<impl de::Decode for core::sync::atomic::AtomicI64>::decode
deps:{"atomic::<impl de::Decode for core::sync::atomic::AtomicI64>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"atomic::<impl de::Decode for core::sync::atomic::AtomicI64>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::Decode for core::sync::atomic::AtomicI64>::decode(p0);
+crate::atomic::<impl de::Decode for core::sync::atomic::AtomicI64>::decode(p0);
+<core::sync::atomic::AtomicI64>::decode(p0);
-----------------
src/de/mod.rs atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI64>::borrow_decode
'de
deps:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI64>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI64>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI64>::borrow_decode(p0);
+crate::atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI64>::borrow_decode(p0);
+<core::sync::atomic::AtomicI64>::borrow_decode(p0);
-----------------
src/atomic.rs atomic::<impl enc::Encode for core::sync::atomic::AtomicIsize>::encode
deps:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicIsize>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"atomic::<impl enc::Encode for core::sync::atomic::AtomicIsize>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::sync::atomic::AtomicIsize
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+atomic::<impl enc::Encode for core::sync::atomic::AtomicIsize>::encode(p0, p1);
+crate::atomic::<impl enc::Encode for core::sync::atomic::AtomicIsize>::encode(p0, p1);
+<core::sync::atomic::AtomicIsize>::encode(p0, p1);
-----------------
src/atomic.rs atomic::<impl de::Decode for core::sync::atomic::AtomicIsize>::decode
deps:{"atomic::<impl de::Decode for core::sync::atomic::AtomicIsize>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"atomic::<impl de::Decode for core::sync::atomic::AtomicIsize>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::Decode for core::sync::atomic::AtomicIsize>::decode(p0);
+crate::atomic::<impl de::Decode for core::sync::atomic::AtomicIsize>::decode(p0);
+<core::sync::atomic::AtomicIsize>::decode(p0);
-----------------
src/de/mod.rs atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicIsize>::borrow_decode
'de
deps:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicIsize>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicIsize>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicIsize>::borrow_decode(p0);
+crate::atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicIsize>::borrow_decode(p0);
+<core::sync::atomic::AtomicIsize>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs <features::impl_alloc::VecWriter as core::default::Default>::default
deps:{}
candidates:{}
+<features::impl_alloc::VecWriter as core::default::Default>::default();
+crate::<features::impl_alloc::VecWriter as core::default::Default>::default();
+<features::impl_alloc::VecWriter>::default();
-----------------
src/features/impl_alloc.rs features::impl_alloc::VecWriter::with_capacity
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+features::impl_alloc::VecWriter::with_capacity(p0);
+crate::features::impl_alloc::VecWriter::with_capacity(p0);
+<features::impl_alloc::VecWriter>::with_capacity(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::VecWriter::collect
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // features::impl_alloc::VecWriter
+p0.collect();
+features::impl_alloc::VecWriter::collect(p0);
+crate::features::impl_alloc::VecWriter::collect(p0);
+<features::impl_alloc::VecWriter>::collect(p0);
-----------------
src/features/impl_alloc.rs <features::impl_alloc::VecWriter as enc::write::Writer>::write
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // features::impl_alloc::VecWriter
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.write(p1);
+<features::impl_alloc::VecWriter as enc::write::Writer>::write(p0, p1);
+crate::<features::impl_alloc::VecWriter as enc::write::Writer>::write(p0, p1);
+<features::impl_alloc::VecWriter>::write(p0, p1);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::collections::BinaryHeap<T>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::collections::BinaryHeap<T>>::decode":{"D":["core::marker::Sized","de::Decoder"],"T":["core::marker::Sized","de::Decode","core::cmp::Ord"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::collections::BinaryHeap<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::collections::BinaryHeap<T>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::collections::BinaryHeap<T>>::decode(p0);
+<alloc::collections::BinaryHeap<T>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BinaryHeap<T>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BinaryHeap<T>>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"],"T":["core::marker::Sized","de::BorrowDecode","core::cmp::Ord"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BinaryHeap<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BinaryHeap<T>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BinaryHeap<T>>::borrow_decode(p0);
+<alloc::collections::BinaryHeap<T>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl enc::Encode for alloc::collections::BinaryHeap<T>>::encode
deps:{"features::impl_alloc::<impl enc::Encode for alloc::collections::BinaryHeap<T>>::encode":{"E":["core::marker::Sized","enc::Encoder"],"T":["core::cmp::Ord","core::marker::Sized","enc::Encode"]}}
candidates:{"features::impl_alloc::<impl enc::Encode for alloc::collections::BinaryHeap<T>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // alloc::collections::BinaryHeap<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_alloc::<impl enc::Encode for alloc::collections::BinaryHeap<T>>::encode(p0, p1);
+crate::features::impl_alloc::<impl enc::Encode for alloc::collections::BinaryHeap<T>>::encode(p0, p1);
+<alloc::collections::BinaryHeap<T>>::encode(p0, p1);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::collections::BTreeMap<K, V>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::collections::BTreeMap<K, V>>::decode":{"D":["core::marker::Sized","de::Decoder"],"K":["de::Decode","core::marker::Sized","core::cmp::Ord"],"V":["core::marker::Sized","de::Decode"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::collections::BTreeMap<K, V>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::collections::BTreeMap<K, V>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::collections::BTreeMap<K, V>>::decode(p0);
+<alloc::collections::BTreeMap<K, V>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeMap<K, V>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeMap<K, V>>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"],"K":["core::cmp::Ord","core::marker::Sized","de::BorrowDecode"],"V":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeMap<K, V>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeMap<K, V>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeMap<K, V>>::borrow_decode(p0);
+<alloc::collections::BTreeMap<K, V>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeMap<K, V>>::encode
deps:{"features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeMap<K, V>>::encode":{"E":["core::marker::Sized","enc::Encoder"],"K":["core::marker::Sized","core::cmp::Ord","enc::Encode"],"V":["enc::Encode","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeMap<K, V>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // alloc::collections::BTreeMap<K, V>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeMap<K, V>>::encode(p0, p1);
+crate::features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeMap<K, V>>::encode(p0, p1);
+<alloc::collections::BTreeMap<K, V>>::encode(p0, p1);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::collections::BTreeSet<T>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::collections::BTreeSet<T>>::decode":{"D":["de::Decoder","core::marker::Sized"],"T":["core::marker::Sized","de::Decode","core::cmp::Ord"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::collections::BTreeSet<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::collections::BTreeSet<T>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::collections::BTreeSet<T>>::decode(p0);
+<alloc::collections::BTreeSet<T>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeSet<T>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeSet<T>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"T":["de::BorrowDecode","core::cmp::Ord","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeSet<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeSet<T>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeSet<T>>::borrow_decode(p0);
+<alloc::collections::BTreeSet<T>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeSet<T>>::encode
deps:{"features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeSet<T>>::encode":{"E":["core::marker::Sized","enc::Encoder"],"T":["enc::Encode","core::cmp::Ord","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeSet<T>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // alloc::collections::BTreeSet<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeSet<T>>::encode(p0, p1);
+crate::features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeSet<T>>::encode(p0, p1);
+<alloc::collections::BTreeSet<T>>::encode(p0, p1);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::collections::VecDeque<T>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::collections::VecDeque<T>>::decode":{"D":["core::marker::Sized","de::Decoder"],"T":["core::marker::Sized","de::Decode"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::collections::VecDeque<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::collections::VecDeque<T>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::collections::VecDeque<T>>::decode(p0);
+<alloc::collections::VecDeque<T>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::VecDeque<T>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::VecDeque<T>>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"],"T":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::VecDeque<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::VecDeque<T>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::VecDeque<T>>::borrow_decode(p0);
+<alloc::collections::VecDeque<T>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl enc::Encode for alloc::collections::VecDeque<T>>::encode
deps:{"features::impl_alloc::<impl enc::Encode for alloc::collections::VecDeque<T>>::encode":{"E":["enc::Encoder","core::marker::Sized"],"T":["enc::Encode","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl enc::Encode for alloc::collections::VecDeque<T>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // alloc::collections::VecDeque<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_alloc::<impl enc::Encode for alloc::collections::VecDeque<T>>::encode(p0, p1);
+crate::features::impl_alloc::<impl enc::Encode for alloc::collections::VecDeque<T>>::encode(p0, p1);
+<alloc::collections::VecDeque<T>>::encode(p0, p1);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::vec::Vec<T>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::vec::Vec<T>>::decode":{"D":["core::marker::Sized","de::Decoder"],"T":["de::Decode","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::vec::Vec<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::vec::Vec<T>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::vec::Vec<T>>::decode(p0);
+<alloc::vec::Vec<T>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::vec::Vec<T>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::vec::Vec<T>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"T":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::vec::Vec<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::vec::Vec<T>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::vec::Vec<T>>::borrow_decode(p0);
+<alloc::vec::Vec<T>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl enc::Encode for alloc::vec::Vec<T>>::encode
deps:{"features::impl_alloc::<impl enc::Encode for alloc::vec::Vec<T>>::encode":{"E":["enc::Encoder","core::marker::Sized"],"T":["enc::Encode","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl enc::Encode for alloc::vec::Vec<T>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // alloc::vec::Vec<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_alloc::<impl enc::Encode for alloc::vec::Vec<T>>::encode(p0, p1);
+crate::features::impl_alloc::<impl enc::Encode for alloc::vec::Vec<T>>::encode(p0, p1);
+<alloc::vec::Vec<T>>::encode(p0, p1);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::string::String>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::string::String>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::string::String>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::string::String>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::string::String>::decode(p0);
+<alloc::string::String>::decode(p0);
-----------------
src/de/mod.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::string::String>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::string::String>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::string::String>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::string::String>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::string::String>::borrow_decode(p0);
+<alloc::string::String>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::boxed::Box<str>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<str>>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<str>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::boxed::Box<str>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::boxed::Box<str>>::decode(p0);
+<alloc::boxed::Box<str>>::decode(p0);
-----------------
src/de/mod.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<str>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<str>>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<str>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<str>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<str>>::borrow_decode(p0);
+<alloc::boxed::Box<str>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl enc::Encode for alloc::string::String>::encode
deps:{"features::impl_alloc::<impl enc::Encode for alloc::string::String>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl enc::Encode for alloc::string::String>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // alloc::string::String
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_alloc::<impl enc::Encode for alloc::string::String>::encode(p0, p1);
+crate::features::impl_alloc::<impl enc::Encode for alloc::string::String>::encode(p0, p1);
+<alloc::string::String>::encode(p0, p1);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::boxed::Box<T>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<T>>::decode":{"D":["de::Decoder","core::marker::Sized"],"T":["de::Decode","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::boxed::Box<T>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::boxed::Box<T>>::decode(p0);
+<alloc::boxed::Box<T>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<T>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<T>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"T":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<T>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<T>>::borrow_decode(p0);
+<alloc::boxed::Box<T>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl enc::Encode for alloc::boxed::Box<T>>::encode
deps:{"<T as alloc::borrow::ToOwned>":{"T":["core::clone::Clone","core::marker::Sized"]},"alloc::borrow::Cow":{"B":["alloc::borrow::ToOwned"]},"alloc::boxed::Box":{"A":["core::alloc::Allocator","core::marker::Sized"]},"alloc::collections::BTreeMap":{"A":["core::marker::Sized","core::alloc::Allocator","core::clone::Clone"],"K":["core::cmp::Ord","de::Decode","core::marker::Sized","de::BorrowDecode","enc::Encode"],"V":["core::marker::Sized","de::Decode","enc::Encode","de::BorrowDecode"]},"alloc::collections::BTreeSet":{"A":["core::clone::Clone","core::marker::Sized","core::alloc::Allocator"],"T":["core::marker::Sized","de::Decode","de::BorrowDecode","core::cmp::Ord","enc::Encode"]},"alloc::collections::BinaryHeap":{"T":["enc::Encode","de::BorrowDecode","core::marker::Sized","de::Decode","core::cmp::Ord"]},"alloc::collections::VecDeque":{"A":["core::marker::Sized","core::alloc::Allocator"],"T":["de::BorrowDecode","de::Decode","enc::Encode","core::marker::Sized"]},"alloc::vec::Vec":{"A":["core::alloc::Allocator","core::marker::Sized"],"T":["core::marker::Sized","de::Decode","enc::Encode","de::BorrowDecode"]},"core::ops::Bound":{"T":["core::marker::Sized","de::Decode","enc::Encode","de::BorrowDecode"]},"core::ops::Range":{"Idx":["core::marker::Sized"]},"core::ops::RangeInclusive":{"Idx":["core::marker::Sized"]},"core::option::Option":{"T":["enc::Encode","de::Decode","core::marker::Sized","de::BorrowDecode"]},"core::result::Result":{"E":["core::marker::Sized"],"T":["enc::Encode","de::BorrowDecode","de::Decode","core::marker::Sized"]},"enc::impls::<impl enc::Encode for &'a T>":{},"features::impl_alloc::<impl enc::Encode for alloc::boxed::Box<T>>::encode":{"E":["enc::Encoder","core::marker::Sized"],"T":["enc::Encode"]},"std::collections::HashMap":{"K":["de::BorrowDecode","core::marker::Sized","de::Decode","core::hash::Hash","enc::Encode","core::cmp::Eq"],"S":["core::hash::BuildHasher","core::default::Default","core::marker::Sized"],"V":["de::BorrowDecode","enc::Encode","de::Decode","core::marker::Sized"]},"std::collections::HashSet":{"S":["core::marker::Sized","core::hash::BuildHasher","core::default::Default"],"T":["core::cmp::Eq","core::marker::Sized","de::Decode","de::BorrowDecode","enc::Encode","core::hash::Hash"]}}
candidates:{"<T as alloc::borrow::ToOwned>":{},"alloc::borrow::Cow":{"B":["core::ffi::CStr","<T as alloc::borrow::ToOwned>","std::path::Path","std::ffi::OsStr"]},"alloc::boxed::Box":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeMap":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeSet":{"A":["alloc::alloc::Global"]},"alloc::collections::BinaryHeap":{},"alloc::collections::VecDeque":{"A":["alloc::alloc::Global"]},"alloc::vec::Vec":{"A":["alloc::alloc::Global"]},"core::ops::Bound":{},"core::ops::Range":{},"core::ops::RangeInclusive":{},"core::option::Option":{},"core::result::Result":{},"enc::impls::<impl enc::Encode for &'a T>":{},"features::impl_alloc::<impl enc::Encode for alloc::boxed::Box<T>>::encode":{"T":["core::num::NonZeroU8","alloc::collections::BTreeSet","core::num::NonZeroI8","std::net::Ipv6Addr","core::time::Duration","std::net::IpAddr","core::num::NonZeroU128","std::net::SocketAddrV6","alloc::collections::VecDeque","std::collections::HashSet","core::marker::PhantomData","core::result::Result","core::num::NonZeroI128","core::option::Option","core::num::NonZeroI32","core::sync::atomic::AtomicUsize","std::sync::Mutex","core::sync::atomic::AtomicIsize","core::num::NonZeroU16","std::time::SystemTime","std::net::SocketAddrV4","alloc::string::String","core::sync::atomic::AtomicI64","core::sync::atomic::AtomicBool","core::sync::atomic::AtomicU16","core::sync::atomic::AtomicU32","core::ops::Bound","core::num::NonZeroUsize","core::ops::RangeInclusive","enc::impls::<impl enc::Encode for &'a T>","alloc::borrow::Cow","core::sync::atomic::AtomicU8","core::sync::atomic::AtomicU64","core::num::NonZeroI64","alloc::boxed::Box","core::cell::RefCell","core::sync::atomic::AtomicI8","alloc::collections::BinaryHeap","core::num::NonZeroU32","alloc::ffi::CString","std::sync::RwLock","alloc::rc::Rc","core::num::NonZeroU64","core::sync::atomic::AtomicI16","alloc::collections::BTreeMap","core::ops::Range","std::path::PathBuf","alloc::vec::Vec","core::num::NonZeroI16","core::num::NonZeroIsize","alloc::sync::Arc","std::collections::HashMap","core::cell::Cell","std::net::Ipv4Addr","std::net::SocketAddr","core::sync::atomic::AtomicI32"]},"std::collections::HashMap":{"S":["std::collections::hash_map::RandomState"]},"std::collections::HashSet":{"S":["std::collections::hash_map::RandomState"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // alloc::boxed::Box<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_alloc::<impl enc::Encode for alloc::boxed::Box<T>>::encode(p0, p1);
+crate::features::impl_alloc::<impl enc::Encode for alloc::boxed::Box<T>>::encode(p0, p1);
+<alloc::boxed::Box<T>>::encode(p0, p1);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::boxed::Box<[T]>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<[T]>>::decode":{"D":["core::marker::Sized","de::Decoder"],"T":["de::Decode","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<[T]>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::boxed::Box<[T]>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::boxed::Box<[T]>>::decode(p0);
+<alloc::boxed::Box<[T]>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<[T]>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<[T]>>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"],"T":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<[T]>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<[T]>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<[T]>>::borrow_decode(p0);
+<alloc::boxed::Box<[T]>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::borrow::Cow<'cow, T>>::decode
'cow
deps:{"<T as alloc::borrow::ToOwned>":{"T":["core::marker::Sized","core::clone::Clone"]},"alloc::borrow::Cow":{"B":["alloc::borrow::ToOwned"]},"alloc::boxed::Box":{"A":["core::marker::Sized","core::alloc::Allocator"]},"alloc::collections::BTreeMap":{"A":["core::marker::Sized","core::clone::Clone","core::alloc::Allocator"],"K":["enc::Encode","core::marker::Sized","de::Decode","de::BorrowDecode","core::cmp::Ord"],"V":["core::marker::Sized","de::BorrowDecode","enc::Encode","de::Decode"]},"alloc::collections::BTreeSet":{"A":["core::marker::Sized","core::alloc::Allocator","core::clone::Clone"],"T":["core::marker::Sized","de::Decode","enc::Encode","de::BorrowDecode","core::cmp::Ord"]},"alloc::collections::BinaryHeap":{"T":["core::cmp::Ord","de::Decode","de::BorrowDecode","core::marker::Sized","enc::Encode"]},"alloc::collections::VecDeque":{"A":["core::alloc::Allocator","core::marker::Sized"],"T":["de::Decode","de::BorrowDecode","enc::Encode","core::marker::Sized"]},"alloc::vec::Vec":{"A":["core::marker::Sized","core::alloc::Allocator"],"T":["de::BorrowDecode","core::marker::Sized","de::Decode","enc::Encode"]},"core::ops::Bound":{"T":["enc::Encode","de::BorrowDecode","core::marker::Sized","de::Decode"]},"core::ops::Range":{"Idx":["core::marker::Sized"]},"core::ops::RangeInclusive":{"Idx":["core::marker::Sized"]},"core::option::Option":{"T":["enc::Encode","core::marker::Sized","de::Decode","de::BorrowDecode"]},"core::result::Result":{"E":["core::marker::Sized"],"T":["de::BorrowDecode","enc::Encode","core::marker::Sized","de::Decode"]},"features::impl_alloc::<impl de::Decode for alloc::borrow::Cow<'cow, T>>::decode":{"<T as alloc::borrow::ToOwned>::Owned":["de::Decode"],"D":["de::Decoder","core::marker::Sized"],"T":["alloc::borrow::ToOwned"]},"std::collections::HashMap":{"K":["core::marker::Sized","enc::Encode","core::cmp::Eq","core::hash::Hash","de::BorrowDecode","de::Decode"],"S":["core::default::Default","core::hash::BuildHasher","core::marker::Sized"],"V":["core::marker::Sized","de::Decode","enc::Encode","de::BorrowDecode"]},"std::collections::HashSet":{"S":["core::hash::BuildHasher","core::default::Default","core::marker::Sized"],"T":["de::BorrowDecode","core::hash::Hash","de::Decode","enc::Encode","core::marker::Sized","core::cmp::Eq"]}}
candidates:{"<T as alloc::borrow::ToOwned>":{},"alloc::borrow::Cow":{"B":["std::ffi::OsStr","core::ffi::CStr","std::path::Path","<T as alloc::borrow::ToOwned>"]},"alloc::boxed::Box":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeMap":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeSet":{"A":["alloc::alloc::Global"]},"alloc::collections::BinaryHeap":{},"alloc::collections::VecDeque":{"A":["alloc::alloc::Global"]},"alloc::vec::Vec":{"A":["alloc::alloc::Global"]},"core::ops::Bound":{},"core::ops::Range":{},"core::ops::RangeInclusive":{},"core::option::Option":{},"core::result::Result":{},"features::impl_alloc::<impl de::Decode for alloc::borrow::Cow<'cow, T>>::decode":{"<T as alloc::borrow::ToOwned>::Owned":["std::sync::Mutex","core::result::Result","std::time::SystemTime","core::sync::atomic::AtomicU16","core::marker::PhantomData","std::collections::HashSet","alloc::string::String","core::num::NonZeroI64","std::net::SocketAddr","core::sync::atomic::AtomicU8","alloc::collections::BTreeMap","core::num::NonZeroU16","std::sync::RwLock","alloc::collections::VecDeque","std::net::SocketAddrV6","core::num::NonZeroI8","alloc::vec::Vec","alloc::rc::Rc","core::num::NonZeroU32","core::num::NonZeroI16","core::sync::atomic::AtomicI8","core::sync::atomic::AtomicUsize","core::num::NonZeroU8","alloc::sync::Arc","core::cell::RefCell","core::num::NonZeroUsize","core::ops::Bound","std::net::SocketAddrV4","core::num::NonZeroI32","core::time::Duration","alloc::borrow::Cow","alloc::collections::BTreeSet","core::ops::RangeInclusive","core::sync::atomic::AtomicI64","core::num::NonZeroIsize","std::net::Ipv6Addr","core::cell::Cell","core::num::NonZeroU128","core::sync::atomic::AtomicI16","core::sync::atomic::AtomicBool","core::sync::atomic::AtomicU32","std::collections::HashMap","core::sync::atomic::AtomicU64","core::sync::atomic::AtomicI32","core::option::Option","core::num::NonZeroI128","alloc::boxed::Box","core::ops::Range","core::num::NonZeroU64","alloc::ffi::CString","alloc::collections::BinaryHeap","std::net::IpAddr","std::path::PathBuf","std::net::Ipv4Addr","core::sync::atomic::AtomicIsize"],"T":["core::ffi::CStr","std::ffi::OsStr","<T as alloc::borrow::ToOwned>","std::path::Path"]},"std::collections::HashMap":{"S":["std::collections::hash_map::RandomState"]},"std::collections::HashSet":{"S":["std::collections::hash_map::RandomState"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::borrow::Cow<'cow, T>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::borrow::Cow<'cow, T>>::decode(p0);
+<alloc::borrow::Cow<'cow, T>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'cow> for alloc::borrow::Cow<'cow, T>>::borrow_decode
'cow
deps:{"<T as alloc::borrow::ToOwned>":{"T":["core::clone::Clone","core::marker::Sized"]},"alloc::borrow::Cow":{"B":["alloc::borrow::ToOwned"]},"alloc::boxed::Box":{"A":["core::marker::Sized","core::alloc::Allocator"]},"alloc::collections::BTreeMap":{"A":["core::alloc::Allocator","core::clone::Clone","core::marker::Sized"],"K":["de::BorrowDecode","de::Decode","enc::Encode","core::cmp::Ord","core::marker::Sized"],"V":["core::marker::Sized","de::Decode","enc::Encode","de::BorrowDecode"]},"alloc::collections::BTreeSet":{"A":["core::alloc::Allocator","core::clone::Clone","core::marker::Sized"],"T":["core::marker::Sized","de::BorrowDecode","de::Decode","core::cmp::Ord","enc::Encode"]},"alloc::collections::BinaryHeap":{"T":["de::Decode","core::marker::Sized","core::cmp::Ord","de::BorrowDecode","enc::Encode"]},"alloc::collections::VecDeque":{"A":["core::marker::Sized","core::alloc::Allocator"],"T":["de::Decode","enc::Encode","de::BorrowDecode","core::marker::Sized"]},"alloc::vec::Vec":{"A":["core::alloc::Allocator","core::marker::Sized"],"T":["core::marker::Sized","de::Decode","de::BorrowDecode","enc::Encode"]},"core::ops::Bound":{"T":["de::Decode","enc::Encode","de::BorrowDecode","core::marker::Sized"]},"core::ops::Range":{"Idx":["core::marker::Sized"]},"core::ops::RangeInclusive":{"Idx":["core::marker::Sized"]},"core::option::Option":{"T":["de::BorrowDecode","core::marker::Sized","enc::Encode","de::Decode"]},"core::result::Result":{"E":["core::marker::Sized"],"T":["enc::Encode","core::marker::Sized","de::Decode","de::BorrowDecode"]},"features::impl_alloc::<impl de::BorrowDecode<'cow> for alloc::borrow::Cow<'cow, T>>::borrow_decode":{"&'cow T":["de::BorrowDecode"],"D":["de::BorrowDecoder","core::marker::Sized"],"T":["alloc::borrow::ToOwned"]},"std::collections::HashMap":{"K":["enc::Encode","core::marker::Sized","de::BorrowDecode","core::hash::Hash","core::cmp::Eq","de::Decode"],"S":["core::default::Default","core::hash::BuildHasher","core::marker::Sized"],"V":["core::marker::Sized","de::Decode","enc::Encode","de::BorrowDecode"]},"std::collections::HashSet":{"S":["core::hash::BuildHasher","core::default::Default","core::marker::Sized"],"T":["enc::Encode","core::hash::Hash","de::Decode","de::BorrowDecode","core::cmp::Eq","core::marker::Sized"]}}
candidates:{"<T as alloc::borrow::ToOwned>":{},"alloc::borrow::Cow":{"B":["core::ffi::CStr","std::path::Path","<T as alloc::borrow::ToOwned>","std::ffi::OsStr"]},"alloc::boxed::Box":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeMap":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeSet":{"A":["alloc::alloc::Global"]},"alloc::collections::BinaryHeap":{},"alloc::collections::VecDeque":{"A":["alloc::alloc::Global"]},"alloc::vec::Vec":{"A":["alloc::alloc::Global"]},"core::ops::Bound":{},"core::ops::Range":{},"core::ops::RangeInclusive":{},"core::option::Option":{},"core::result::Result":{},"features::impl_alloc::<impl de::BorrowDecode<'cow> for alloc::borrow::Cow<'cow, T>>::borrow_decode":{"&'cow T":["core::sync::atomic::AtomicI8","core::option::Option","core::num::NonZeroI16","alloc::borrow::Cow","alloc::vec::Vec","alloc::string::String","std::time::SystemTime","std::sync::RwLock","alloc::sync::Arc","core::result::Result","core::num::NonZeroI128","core::num::NonZeroU16","core::sync::atomic::AtomicIsize","core::time::Duration","core::sync::atomic::AtomicUsize","alloc::rc::Rc","alloc::boxed::Box","core::sync::atomic::AtomicI32","core::sync::atomic::AtomicI64","core::ops::Range","core::sync::atomic::AtomicBool","core::num::NonZeroI32","std::collections::HashSet","core::sync::atomic::AtomicU8","core::sync::atomic::AtomicU16","core::ops::RangeInclusive","alloc::collections::BTreeMap","core::ops::Bound","core::num::NonZeroIsize","core::cell::RefCell","std::collections::HashMap","core::num::NonZeroU32","core::num::NonZeroI8","core::sync::atomic::AtomicI16","std::net::SocketAddrV6","core::num::NonZeroUsize","core::marker::PhantomData","core::num::NonZeroU8","std::sync::Mutex","core::sync::atomic::AtomicU64","core::num::NonZeroU64","std::path::PathBuf","core::sync::atomic::AtomicU32","core::cell::Cell","std::net::IpAddr","std::net::Ipv4Addr","alloc::collections::VecDeque","alloc::ffi::CString","alloc::collections::BTreeSet","std::net::Ipv6Addr","core::num::NonZeroU128","alloc::collections::BinaryHeap","std::net::SocketAddr","std::net::SocketAddrV4","core::num::NonZeroI64"],"T":["<T as alloc::borrow::ToOwned>","std::ffi::OsStr","core::ffi::CStr","std::path::Path"]},"std::collections::HashMap":{"S":["std::collections::hash_map::RandomState"]},"std::collections::HashSet":{"S":["std::collections::hash_map::RandomState"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'cow> for alloc::borrow::Cow<'cow, T>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'cow> for alloc::borrow::Cow<'cow, T>>::borrow_decode(p0);
+<alloc::borrow::Cow<'cow, T>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl enc::Encode for alloc::borrow::Cow<'cow, T>>::encode
'cow
deps:{"<T as alloc::borrow::ToOwned>":{"T":["core::marker::Sized","core::clone::Clone"]},"alloc::borrow::Cow":{"B":["alloc::borrow::ToOwned"]},"alloc::boxed::Box":{"A":["core::marker::Sized","core::alloc::Allocator"]},"alloc::collections::BTreeMap":{"A":["core::alloc::Allocator","core::clone::Clone","core::marker::Sized"],"K":["core::cmp::Ord","core::marker::Sized","de::BorrowDecode","de::Decode","enc::Encode"],"V":["core::marker::Sized","de::BorrowDecode","de::Decode","enc::Encode"]},"alloc::collections::BTreeSet":{"A":["core::alloc::Allocator","core::clone::Clone","core::marker::Sized"],"T":["core::cmp::Ord","de::Decode","core::marker::Sized","de::BorrowDecode","enc::Encode"]},"alloc::collections::BinaryHeap":{"T":["de::BorrowDecode","enc::Encode","core::cmp::Ord","de::Decode","core::marker::Sized"]},"alloc::collections::VecDeque":{"A":["core::alloc::Allocator","core::marker::Sized"],"T":["core::marker::Sized","enc::Encode","de::BorrowDecode","de::Decode"]},"alloc::vec::Vec":{"A":["core::marker::Sized","core::alloc::Allocator"],"T":["core::marker::Sized","enc::Encode","de::Decode","de::BorrowDecode"]},"core::ops::Bound":{"T":["core::marker::Sized","de::BorrowDecode","enc::Encode","de::Decode"]},"core::ops::Range":{"Idx":["core::marker::Sized"]},"core::ops::RangeInclusive":{"Idx":["core::marker::Sized"]},"core::option::Option":{"T":["de::Decode","de::BorrowDecode","core::marker::Sized","enc::Encode"]},"core::result::Result":{"E":["core::marker::Sized"],"T":["de::BorrowDecode","enc::Encode","de::Decode","core::marker::Sized"]},"enc::impls::<impl enc::Encode for &'a T>":{},"features::impl_alloc::<impl enc::Encode for alloc::borrow::Cow<'cow, T>>::encode":{"&'a T":["enc::Encode"],"E":["enc::Encoder","core::marker::Sized"],"T":["alloc::borrow::ToOwned"]},"std::collections::HashMap":{"K":["core::cmp::Eq","de::BorrowDecode","de::Decode","core::hash::Hash","enc::Encode","core::marker::Sized"],"S":["core::hash::BuildHasher","core::default::Default","core::marker::Sized"],"V":["enc::Encode","de::Decode","core::marker::Sized","de::BorrowDecode"]},"std::collections::HashSet":{"S":["core::default::Default","core::marker::Sized","core::hash::BuildHasher"],"T":["de::Decode","core::marker::Sized","core::cmp::Eq","de::BorrowDecode","core::hash::Hash","enc::Encode"]}}
candidates:{"<T as alloc::borrow::ToOwned>":{},"alloc::borrow::Cow":{"B":["<T as alloc::borrow::ToOwned>","std::path::Path","std::ffi::OsStr","core::ffi::CStr"]},"alloc::boxed::Box":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeMap":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeSet":{"A":["alloc::alloc::Global"]},"alloc::collections::BinaryHeap":{},"alloc::collections::VecDeque":{"A":["alloc::alloc::Global"]},"alloc::vec::Vec":{"A":["alloc::alloc::Global"]},"core::ops::Bound":{},"core::ops::Range":{},"core::ops::RangeInclusive":{},"core::option::Option":{},"core::result::Result":{},"enc::impls::<impl enc::Encode for &'a T>":{},"features::impl_alloc::<impl enc::Encode for alloc::borrow::Cow<'cow, T>>::encode":{"&'a T":["core::num::NonZeroI128","std::net::Ipv6Addr","alloc::string::String","std::collections::HashSet","core::sync::atomic::AtomicU32","core::ops::Range","alloc::collections::BinaryHeap","core::num::NonZeroUsize","alloc::borrow::Cow","alloc::sync::Arc","core::marker::PhantomData","core::result::Result","core::sync::atomic::AtomicI16","alloc::collections::BTreeSet","std::net::IpAddr","core::cell::Cell","core::sync::atomic::AtomicBool","core::sync::atomic::AtomicI8","core::cell::RefCell","core::sync::atomic::AtomicU8","alloc::collections::VecDeque","alloc::collections::BTreeMap","std::sync::RwLock","core::num::NonZeroU128","core::sync::atomic::AtomicI32","core::num::NonZeroI8","std::path::PathBuf","core::num::NonZeroI32","core::num::NonZeroU8","enc::impls::<impl enc::Encode for &'a T>","alloc::ffi::CString","std::collections::HashMap","std::sync::Mutex","core::sync::atomic::AtomicUsize","std::time::SystemTime","core::num::NonZeroU16","std::net::SocketAddr","std::net::SocketAddrV6","std::net::Ipv4Addr","core::sync::atomic::AtomicIsize","core::ops::Bound","std::net::SocketAddrV4","alloc::vec::Vec","alloc::boxed::Box","core::option::Option","core::num::NonZeroI64","core::num::NonZeroI16","core::time::Duration","core::sync::atomic::AtomicU64","core::num::NonZeroU32","core::ops::RangeInclusive","core::num::NonZeroIsize","alloc::rc::Rc","core::sync::atomic::AtomicU16","core::num::NonZeroU64","core::sync::atomic::AtomicI64"],"T":["<T as alloc::borrow::ToOwned>","std::path::Path","core::ffi::CStr","std::ffi::OsStr"]},"std::collections::HashMap":{"S":["std::collections::hash_map::RandomState"]},"std::collections::HashSet":{"S":["std::collections::hash_map::RandomState"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // alloc::borrow::Cow<'cow, T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_alloc::<impl enc::Encode for alloc::borrow::Cow<'cow, T>>::encode(p0, p1);
+crate::features::impl_alloc::<impl enc::Encode for alloc::borrow::Cow<'cow, T>>::encode(p0, p1);
+<alloc::borrow::Cow<'cow, T>>::encode(p0, p1);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::rc::Rc<T>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::rc::Rc<T>>::decode":{"D":["de::Decoder","core::marker::Sized"],"T":["de::Decode","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::rc::Rc<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::rc::Rc<T>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::rc::Rc<T>>::decode(p0);
+<alloc::rc::Rc<T>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<T>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<T>>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"],"T":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<T>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<T>>::borrow_decode(p0);
+<alloc::rc::Rc<T>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl enc::Encode for alloc::rc::Rc<T>>::encode
deps:{"<T as alloc::borrow::ToOwned>":{"T":["core::marker::Sized","core::clone::Clone"]},"alloc::borrow::Cow":{"B":["alloc::borrow::ToOwned"]},"alloc::boxed::Box":{"A":["core::alloc::Allocator","core::marker::Sized"]},"alloc::collections::BTreeMap":{"A":["core::marker::Sized","core::alloc::Allocator","core::clone::Clone"],"K":["de::BorrowDecode","core::marker::Sized","core::cmp::Ord","de::Decode","enc::Encode"],"V":["enc::Encode","de::Decode","core::marker::Sized","de::BorrowDecode"]},"alloc::collections::BTreeSet":{"A":["core::marker::Sized","core::alloc::Allocator","core::clone::Clone"],"T":["core::cmp::Ord","core::marker::Sized","de::Decode","de::BorrowDecode","enc::Encode"]},"alloc::collections::BinaryHeap":{"T":["de::Decode","de::BorrowDecode","enc::Encode","core::marker::Sized","core::cmp::Ord"]},"alloc::collections::VecDeque":{"A":["core::alloc::Allocator","core::marker::Sized"],"T":["core::marker::Sized","de::BorrowDecode","enc::Encode","de::Decode"]},"alloc::vec::Vec":{"A":["core::marker::Sized","core::alloc::Allocator"],"T":["enc::Encode","de::BorrowDecode","de::Decode","core::marker::Sized"]},"core::ops::Bound":{"T":["de::BorrowDecode","de::Decode","enc::Encode","core::marker::Sized"]},"core::ops::Range":{"Idx":["core::marker::Sized"]},"core::ops::RangeInclusive":{"Idx":["core::marker::Sized"]},"core::option::Option":{"T":["de::Decode","de::BorrowDecode","enc::Encode","core::marker::Sized"]},"core::result::Result":{"E":["core::marker::Sized"],"T":["de::Decode","core::marker::Sized","enc::Encode","de::BorrowDecode"]},"enc::impls::<impl enc::Encode for &'a T>":{},"features::impl_alloc::<impl enc::Encode for alloc::rc::Rc<T>>::encode":{"E":["enc::Encoder","core::marker::Sized"],"T":["enc::Encode"]},"std::collections::HashMap":{"K":["core::hash::Hash","de::Decode","core::cmp::Eq","core::marker::Sized","enc::Encode","de::BorrowDecode"],"S":["core::marker::Sized","core::hash::BuildHasher","core::default::Default"],"V":["core::marker::Sized","de::BorrowDecode","enc::Encode","de::Decode"]},"std::collections::HashSet":{"S":["core::marker::Sized","core::hash::BuildHasher","core::default::Default"],"T":["enc::Encode","de::BorrowDecode","core::cmp::Eq","core::marker::Sized","de::Decode","core::hash::Hash"]}}
candidates:{"<T as alloc::borrow::ToOwned>":{},"alloc::borrow::Cow":{"B":["core::ffi::CStr","<T as alloc::borrow::ToOwned>","std::path::Path","std::ffi::OsStr"]},"alloc::boxed::Box":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeMap":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeSet":{"A":["alloc::alloc::Global"]},"alloc::collections::BinaryHeap":{},"alloc::collections::VecDeque":{"A":["alloc::alloc::Global"]},"alloc::vec::Vec":{"A":["alloc::alloc::Global"]},"core::ops::Bound":{},"core::ops::Range":{},"core::ops::RangeInclusive":{},"core::option::Option":{},"core::result::Result":{},"enc::impls::<impl enc::Encode for &'a T>":{},"features::impl_alloc::<impl enc::Encode for alloc::rc::Rc<T>>::encode":{"T":["core::num::NonZeroIsize","core::num::NonZeroI16","core::marker::PhantomData","std::path::PathBuf","std::time::SystemTime","std::collections::HashMap","core::num::NonZeroI64","std::net::SocketAddrV6","core::result::Result","core::num::NonZeroUsize","core::num::NonZeroI128","alloc::sync::Arc","core::time::Duration","core::sync::atomic::AtomicI32","core::sync::atomic::AtomicI16","core::sync::atomic::AtomicU64","alloc::collections::BTreeMap","core::ops::Range","std::net::Ipv4Addr","core::sync::atomic::AtomicIsize","alloc::borrow::Cow","core::sync::atomic::AtomicU32","alloc::rc::Rc","alloc::collections::BTreeSet","core::num::NonZeroI32","std::net::Ipv6Addr","alloc::boxed::Box","core::sync::atomic::AtomicBool","core::sync::atomic::AtomicUsize","enc::impls::<impl enc::Encode for &'a T>","alloc::collections::VecDeque","core::sync::atomic::AtomicU8","core::num::NonZeroI8","core::ops::RangeInclusive","core::sync::atomic::AtomicI64","alloc::collections::BinaryHeap","core::num::NonZeroU64","core::sync::atomic::AtomicI8","core::ops::Bound","alloc::ffi::CString","std::collections::HashSet","core::cell::RefCell","std::net::SocketAddr","core::num::NonZeroU8","alloc::vec::Vec","std::sync::RwLock","core::sync::atomic::AtomicU16","std::sync::Mutex","std::net::SocketAddrV4","core::option::Option","core::num::NonZeroU32","std::net::IpAddr","alloc::string::String","core::cell::Cell","core::num::NonZeroU128","core::num::NonZeroU16"]},"std::collections::HashMap":{"S":["std::collections::hash_map::RandomState"]},"std::collections::HashSet":{"S":["std::collections::hash_map::RandomState"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // alloc::rc::Rc<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_alloc::<impl enc::Encode for alloc::rc::Rc<T>>::encode(p0, p1);
+crate::features::impl_alloc::<impl enc::Encode for alloc::rc::Rc<T>>::encode(p0, p1);
+<alloc::rc::Rc<T>>::encode(p0, p1);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::rc::Rc<[T]>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::rc::Rc<[T]>>::decode":{"D":["de::Decoder","core::marker::Sized"],"T":["core::marker::Sized","de::Decode"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::rc::Rc<[T]>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::rc::Rc<[T]>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::rc::Rc<[T]>>::decode(p0);
+<alloc::rc::Rc<[T]>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<[T]>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<[T]>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"T":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<[T]>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<[T]>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<[T]>>::borrow_decode(p0);
+<alloc::rc::Rc<[T]>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::sync::Arc<T>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<T>>::decode":{"D":["de::Decoder","core::marker::Sized"],"T":["core::marker::Sized","de::Decode"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::sync::Arc<T>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::sync::Arc<T>>::decode(p0);
+<alloc::sync::Arc<T>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::sync::Arc<str>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<str>>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<str>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::sync::Arc<str>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::sync::Arc<str>>::decode(p0);
+<alloc::sync::Arc<str>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<T>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<T>>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"],"T":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<T>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<T>>::borrow_decode(p0);
+<alloc::sync::Arc<T>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<str>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<str>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<str>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<str>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<str>>::borrow_decode(p0);
+<alloc::sync::Arc<str>>::borrow_decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl enc::Encode for alloc::sync::Arc<T>>::encode
deps:{"<T as alloc::borrow::ToOwned>":{"T":["core::clone::Clone","core::marker::Sized"]},"alloc::borrow::Cow":{"B":["alloc::borrow::ToOwned"]},"alloc::boxed::Box":{"A":["core::alloc::Allocator","core::marker::Sized"]},"alloc::collections::BTreeMap":{"A":["core::marker::Sized","core::alloc::Allocator","core::clone::Clone"],"K":["core::cmp::Ord","core::marker::Sized","de::BorrowDecode","enc::Encode","de::Decode"],"V":["core::marker::Sized","de::Decode","de::BorrowDecode","enc::Encode"]},"alloc::collections::BTreeSet":{"A":["core::alloc::Allocator","core::marker::Sized","core::clone::Clone"],"T":["de::BorrowDecode","core::cmp::Ord","core::marker::Sized","de::Decode","enc::Encode"]},"alloc::collections::BinaryHeap":{"T":["core::cmp::Ord","de::BorrowDecode","core::marker::Sized","de::Decode","enc::Encode"]},"alloc::collections::VecDeque":{"A":["core::alloc::Allocator","core::marker::Sized"],"T":["core::marker::Sized","de::BorrowDecode","de::Decode","enc::Encode"]},"alloc::vec::Vec":{"A":["core::alloc::Allocator","core::marker::Sized"],"T":["de::Decode","core::marker::Sized","enc::Encode","de::BorrowDecode"]},"core::ops::Bound":{"T":["de::Decode","enc::Encode","core::marker::Sized","de::BorrowDecode"]},"core::ops::Range":{"Idx":["core::marker::Sized"]},"core::ops::RangeInclusive":{"Idx":["core::marker::Sized"]},"core::option::Option":{"T":["core::marker::Sized","de::Decode","enc::Encode","de::BorrowDecode"]},"core::result::Result":{"E":["core::marker::Sized"],"T":["de::BorrowDecode","enc::Encode","de::Decode","core::marker::Sized"]},"enc::impls::<impl enc::Encode for &'a T>":{},"features::impl_alloc::<impl enc::Encode for alloc::sync::Arc<T>>::encode":{"E":["core::marker::Sized","enc::Encoder"],"T":["enc::Encode"]},"std::collections::HashMap":{"K":["enc::Encode","de::Decode","core::cmp::Eq","de::BorrowDecode","core::hash::Hash","core::marker::Sized"],"S":["core::marker::Sized","core::hash::BuildHasher","core::default::Default"],"V":["enc::Encode","de::Decode","de::BorrowDecode","core::marker::Sized"]},"std::collections::HashSet":{"S":["core::default::Default","core::marker::Sized","core::hash::BuildHasher"],"T":["enc::Encode","de::Decode","core::cmp::Eq","core::hash::Hash","core::marker::Sized","de::BorrowDecode"]}}
candidates:{"<T as alloc::borrow::ToOwned>":{},"alloc::borrow::Cow":{"B":["<T as alloc::borrow::ToOwned>","core::ffi::CStr","std::path::Path","std::ffi::OsStr"]},"alloc::boxed::Box":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeMap":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeSet":{"A":["alloc::alloc::Global"]},"alloc::collections::BinaryHeap":{},"alloc::collections::VecDeque":{"A":["alloc::alloc::Global"]},"alloc::vec::Vec":{"A":["alloc::alloc::Global"]},"core::ops::Bound":{},"core::ops::Range":{},"core::ops::RangeInclusive":{},"core::option::Option":{},"core::result::Result":{},"enc::impls::<impl enc::Encode for &'a T>":{},"features::impl_alloc::<impl enc::Encode for alloc::sync::Arc<T>>::encode":{"T":["std::collections::HashSet","alloc::collections::BTreeMap","core::num::NonZeroI128","alloc::borrow::Cow","std::sync::RwLock","std::net::IpAddr","std::net::SocketAddr","core::ops::RangeInclusive","alloc::collections::BTreeSet","core::num::NonZeroU128","enc::impls::<impl enc::Encode for &'a T>","core::result::Result","core::option::Option","core::sync::atomic::AtomicI8","alloc::ffi::CString","core::sync::atomic::AtomicU8","core::sync::atomic::AtomicBool","core::cell::RefCell","core::ops::Range","std::time::SystemTime","alloc::collections::VecDeque","alloc::string::String","core::sync::atomic::AtomicUsize","core::num::NonZeroIsize","alloc::sync::Arc","std::net::Ipv4Addr","core::num::NonZeroI8","core::num::NonZeroUsize","core::num::NonZeroU16","core::num::NonZeroU32","core::sync::atomic::AtomicI64","core::sync::atomic::AtomicU16","core::num::NonZeroI64","core::sync::atomic::AtomicIsize","std::net::Ipv6Addr","core::ops::Bound","core::cell::Cell","alloc::rc::Rc","std::net::SocketAddrV6","core::sync::atomic::AtomicI32","std::path::PathBuf","core::sync::atomic::AtomicU64","alloc::boxed::Box","core::num::NonZeroU8","core::num::NonZeroU64","std::net::SocketAddrV4","std::sync::Mutex","core::num::NonZeroI32","core::sync::atomic::AtomicU32","core::time::Duration","core::num::NonZeroI16","alloc::collections::BinaryHeap","alloc::vec::Vec","core::marker::PhantomData","core::sync::atomic::AtomicI16","std::collections::HashMap"]},"std::collections::HashMap":{"S":["std::collections::hash_map::RandomState"]},"std::collections::HashSet":{"S":["std::collections::hash_map::RandomState"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // alloc::sync::Arc<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_alloc::<impl enc::Encode for alloc::sync::Arc<T>>::encode(p0, p1);
+crate::features::impl_alloc::<impl enc::Encode for alloc::sync::Arc<T>>::encode(p0, p1);
+<alloc::sync::Arc<T>>::encode(p0, p1);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::Decode for alloc::sync::Arc<[T]>>::decode
deps:{"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<[T]>>::decode":{"D":["core::marker::Sized","de::Decoder"],"T":["de::Decode","core::marker::Sized"]}}
candidates:{"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<[T]>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::Decode for alloc::sync::Arc<[T]>>::decode(p0);
+crate::features::impl_alloc::<impl de::Decode for alloc::sync::Arc<[T]>>::decode(p0);
+<alloc::sync::Arc<[T]>>::decode(p0);
-----------------
src/features/impl_alloc.rs features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<[T]>>::borrow_decode
'de
deps:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<[T]>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"T":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<[T]>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<[T]>>::borrow_decode(p0);
+crate::features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<[T]>>::borrow_decode(p0);
+<alloc::sync::Arc<[T]>>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::IoReader::<R>::new
deps:{"features::impl_std::IoReader::<R>::new":{"R":["core::marker::Sized"]}}
candidates:{"features::impl_std::IoReader::<R>::new":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // R
+features::impl_std::IoReader::<R>::new(p0);
+crate::features::impl_std::IoReader::<R>::new(p0);
+<features::impl_std::IoReader<R>>::new(p0);
-----------------
src/features/impl_std.rs <features::impl_std::IoReader<R> as de::read::Reader>::read
deps:{"<features::impl_std::IoReader<R> as de::read::Reader>::read":{"R":["std::io::Read","core::marker::Sized"]}}
candidates:{"<features::impl_std::IoReader<R> as de::read::Reader>::read":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // features::impl_std::IoReader<R>
let mut p1 = &mut [0u8].as_mut_slice(); // None+[u8]
+p0.read(p1);
+<features::impl_std::IoReader<R> as de::read::Reader>::read(p0, p1);
+crate::<features::impl_std::IoReader<R> as de::read::Reader>::read(p0, p1);
+<features::impl_std::IoReader<R>>::read(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::read
deps:{"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::read":{"R":["std::io::Read","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::read":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::io::BufReader<R>
let mut p1 = &mut [0u8].as_mut_slice(); // None+[u8]
+p0.read(p1);
+features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::read(p0, p1);
+crate::features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::read(p0, p1);
+<std::io::BufReader<R>>::read(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::peek_read
deps:{"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::peek_read":{"R":["core::marker::Sized","std::io::Read"]}}
candidates:{"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::peek_read":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::io::BufReader<R>
let mut p1 = 0usize; // None+usize
+p0.peek_read(p1);
+features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::peek_read(p0, p1);
+crate::features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::peek_read(p0, p1);
+<std::io::BufReader<R>>::peek_read(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::consume
deps:{"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::consume":{"R":["core::marker::Sized","std::io::Read"]}}
candidates:{"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::consume":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::io::BufReader<R>
let mut p1 = 0usize; // None+usize
+p0.consume(p1);
+features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::consume(p0, p1);
+crate::features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::consume(p0, p1);
+<std::io::BufReader<R>>::consume(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::IoWriter::<'a, W>::new
'a
deps:{"features::impl_std::IoWriter::<'a, W>::new":{"W":["std::io::Write","core::marker::Sized"]}}
candidates:{"features::impl_std::IoWriter::<'a, W>::new":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
+features::impl_std::IoWriter::<'a, W>::new(p0);
+crate::features::impl_std::IoWriter::<'a, W>::new(p0);
+<features::impl_std::IoWriter<'a, W>>::new(p0);
-----------------
src/features/impl_std.rs features::impl_std::IoWriter::<'a, W>::bytes_written
'a
deps:{"features::impl_std::IoWriter::<'a, W>::bytes_written":{"W":["std::io::Write","core::marker::Sized"]}}
candidates:{"features::impl_std::IoWriter::<'a, W>::bytes_written":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // features::impl_std::IoWriter<'a, W>
+p0.bytes_written();
+features::impl_std::IoWriter::<'a, W>::bytes_written(p0);
+crate::features::impl_std::IoWriter::<'a, W>::bytes_written(p0);
+<features::impl_std::IoWriter<'a, W>>::bytes_written(p0);
-----------------
src/features/impl_std.rs <features::impl_std::IoWriter<'storage, W> as enc::write::Writer>::write
'storage
deps:{"<features::impl_std::IoWriter<'storage, W> as enc::write::Writer>::write":{"W":["std::io::Write","core::marker::Sized"]}}
candidates:{"<features::impl_std::IoWriter<'storage, W> as enc::write::Writer>::write":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // features::impl_std::IoWriter<'storage, W>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.write(p1);
+<features::impl_std::IoWriter<'storage, W> as enc::write::Writer>::write(p0, p1);
+crate::<features::impl_std::IoWriter<'storage, W> as enc::write::Writer>::write(p0, p1);
+<features::impl_std::IoWriter<'storage, W>>::write(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for &'a core::ffi::CStr>::encode
'a
deps:{"features::impl_std::<impl enc::Encode for &'a core::ffi::CStr>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl enc::Encode for &'a core::ffi::CStr>::encode":{}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // core::ffi::CStr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for &'a core::ffi::CStr>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for &'a core::ffi::CStr>::encode(p0, p1);
+<&'a core::ffi::CStr>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for alloc::ffi::CString>::encode
deps:{"features::impl_std::<impl enc::Encode for alloc::ffi::CString>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"features::impl_std::<impl enc::Encode for alloc::ffi::CString>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // alloc::ffi::CString
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for alloc::ffi::CString>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for alloc::ffi::CString>::encode(p0, p1);
+<alloc::ffi::CString>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for alloc::ffi::CString>::decode
deps:{"features::impl_std::<impl de::Decode for alloc::ffi::CString>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::Decode for alloc::ffi::CString>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for alloc::ffi::CString>::decode(p0);
+crate::features::impl_std::<impl de::Decode for alloc::ffi::CString>::decode(p0);
+<alloc::ffi::CString>::decode(p0);
-----------------
src/de/mod.rs features::impl_std::<impl de::BorrowDecode<'de> for alloc::ffi::CString>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for alloc::ffi::CString>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for alloc::ffi::CString>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for alloc::ffi::CString>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for alloc::ffi::CString>::borrow_decode(p0);
+<alloc::ffi::CString>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for std::sync::Mutex<T>>::encode
deps:{"features::impl_std::<impl enc::Encode for std::sync::Mutex<T>>::encode":{"E":["enc::Encoder","core::marker::Sized"],"T":["enc::Encode","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl enc::Encode for std::sync::Mutex<T>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::Mutex<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for std::sync::Mutex<T>>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for std::sync::Mutex<T>>::encode(p0, p1);
+<std::sync::Mutex<T>>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for std::sync::Mutex<T>>::decode
deps:{"features::impl_std::<impl de::Decode for std::sync::Mutex<T>>::decode":{"D":["core::marker::Sized","de::Decoder"],"T":["core::marker::Sized","de::Decode"]}}
candidates:{"features::impl_std::<impl de::Decode for std::sync::Mutex<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for std::sync::Mutex<T>>::decode(p0);
+crate::features::impl_std::<impl de::Decode for std::sync::Mutex<T>>::decode(p0);
+<std::sync::Mutex<T>>::decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::BorrowDecode<'de> for std::sync::Mutex<T>>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for std::sync::Mutex<T>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"T":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for std::sync::Mutex<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for std::sync::Mutex<T>>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for std::sync::Mutex<T>>::borrow_decode(p0);
+<std::sync::Mutex<T>>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for std::sync::RwLock<T>>::encode
deps:{"features::impl_std::<impl enc::Encode for std::sync::RwLock<T>>::encode":{"E":["core::marker::Sized","enc::Encoder"],"T":["core::marker::Sized","enc::Encode"]}}
candidates:{"features::impl_std::<impl enc::Encode for std::sync::RwLock<T>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::sync::RwLock<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for std::sync::RwLock<T>>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for std::sync::RwLock<T>>::encode(p0, p1);
+<std::sync::RwLock<T>>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for std::sync::RwLock<T>>::decode
deps:{"features::impl_std::<impl de::Decode for std::sync::RwLock<T>>::decode":{"D":["core::marker::Sized","de::Decoder"],"T":["de::Decode","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::Decode for std::sync::RwLock<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for std::sync::RwLock<T>>::decode(p0);
+crate::features::impl_std::<impl de::Decode for std::sync::RwLock<T>>::decode(p0);
+<std::sync::RwLock<T>>::decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::BorrowDecode<'de> for std::sync::RwLock<T>>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for std::sync::RwLock<T>>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"],"T":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for std::sync::RwLock<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for std::sync::RwLock<T>>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for std::sync::RwLock<T>>::borrow_decode(p0);
+<std::sync::RwLock<T>>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for std::time::SystemTime>::encode
deps:{"features::impl_std::<impl enc::Encode for std::time::SystemTime>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"features::impl_std::<impl enc::Encode for std::time::SystemTime>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::time::SystemTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for std::time::SystemTime>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for std::time::SystemTime>::encode(p0, p1);
+<std::time::SystemTime>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for std::time::SystemTime>::decode
deps:{"features::impl_std::<impl de::Decode for std::time::SystemTime>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::Decode for std::time::SystemTime>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for std::time::SystemTime>::decode(p0);
+crate::features::impl_std::<impl de::Decode for std::time::SystemTime>::decode(p0);
+<std::time::SystemTime>::decode(p0);
-----------------
src/de/mod.rs features::impl_std::<impl de::BorrowDecode<'de> for std::time::SystemTime>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for std::time::SystemTime>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for std::time::SystemTime>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for std::time::SystemTime>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for std::time::SystemTime>::borrow_decode(p0);
+<std::time::SystemTime>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for &std::path::Path>::encode
deps:{"features::impl_std::<impl enc::Encode for &std::path::Path>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"features::impl_std::<impl enc::Encode for &std::path::Path>::encode":{}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // std::path::Path
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for &std::path::Path>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for &std::path::Path>::encode(p0, p1);
+<&std::path::Path>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::BorrowDecode<'de> for &'de std::path::Path>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for &'de std::path::Path>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for &'de std::path::Path>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for &'de std::path::Path>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for &'de std::path::Path>::borrow_decode(p0);
+<&'de std::path::Path>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for std::path::PathBuf>::encode
deps:{"features::impl_std::<impl enc::Encode for std::path::PathBuf>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl enc::Encode for std::path::PathBuf>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::path::PathBuf
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for std::path::PathBuf>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for std::path::PathBuf>::encode(p0, p1);
+<std::path::PathBuf>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for std::path::PathBuf>::decode
deps:{"features::impl_std::<impl de::Decode for std::path::PathBuf>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"features::impl_std::<impl de::Decode for std::path::PathBuf>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for std::path::PathBuf>::decode(p0);
+crate::features::impl_std::<impl de::Decode for std::path::PathBuf>::decode(p0);
+<std::path::PathBuf>::decode(p0);
-----------------
src/de/mod.rs features::impl_std::<impl de::BorrowDecode<'de> for std::path::PathBuf>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for std::path::PathBuf>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for std::path::PathBuf>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for std::path::PathBuf>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for std::path::PathBuf>::borrow_decode(p0);
+<std::path::PathBuf>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for std::net::IpAddr>::encode
deps:{"features::impl_std::<impl enc::Encode for std::net::IpAddr>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"features::impl_std::<impl enc::Encode for std::net::IpAddr>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::net::IpAddr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for std::net::IpAddr>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for std::net::IpAddr>::encode(p0, p1);
+<std::net::IpAddr>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for std::net::IpAddr>::decode
deps:{"features::impl_std::<impl de::Decode for std::net::IpAddr>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"features::impl_std::<impl de::Decode for std::net::IpAddr>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for std::net::IpAddr>::decode(p0);
+crate::features::impl_std::<impl de::Decode for std::net::IpAddr>::decode(p0);
+<std::net::IpAddr>::decode(p0);
-----------------
src/de/mod.rs features::impl_std::<impl de::BorrowDecode<'de> for std::net::IpAddr>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for std::net::IpAddr>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for std::net::IpAddr>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for std::net::IpAddr>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for std::net::IpAddr>::borrow_decode(p0);
+<std::net::IpAddr>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for std::net::Ipv4Addr>::encode
deps:{"features::impl_std::<impl enc::Encode for std::net::Ipv4Addr>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"features::impl_std::<impl enc::Encode for std::net::Ipv4Addr>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::net::Ipv4Addr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for std::net::Ipv4Addr>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for std::net::Ipv4Addr>::encode(p0, p1);
+<std::net::Ipv4Addr>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for std::net::Ipv4Addr>::decode
deps:{"features::impl_std::<impl de::Decode for std::net::Ipv4Addr>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::Decode for std::net::Ipv4Addr>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for std::net::Ipv4Addr>::decode(p0);
+crate::features::impl_std::<impl de::Decode for std::net::Ipv4Addr>::decode(p0);
+<std::net::Ipv4Addr>::decode(p0);
-----------------
src/de/mod.rs features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv4Addr>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv4Addr>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv4Addr>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv4Addr>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv4Addr>::borrow_decode(p0);
+<std::net::Ipv4Addr>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for std::net::Ipv6Addr>::encode
deps:{"features::impl_std::<impl enc::Encode for std::net::Ipv6Addr>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"features::impl_std::<impl enc::Encode for std::net::Ipv6Addr>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::net::Ipv6Addr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for std::net::Ipv6Addr>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for std::net::Ipv6Addr>::encode(p0, p1);
+<std::net::Ipv6Addr>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for std::net::Ipv6Addr>::decode
deps:{"features::impl_std::<impl de::Decode for std::net::Ipv6Addr>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"features::impl_std::<impl de::Decode for std::net::Ipv6Addr>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for std::net::Ipv6Addr>::decode(p0);
+crate::features::impl_std::<impl de::Decode for std::net::Ipv6Addr>::decode(p0);
+<std::net::Ipv6Addr>::decode(p0);
-----------------
src/de/mod.rs features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv6Addr>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv6Addr>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv6Addr>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv6Addr>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv6Addr>::borrow_decode(p0);
+<std::net::Ipv6Addr>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for std::net::SocketAddr>::encode
deps:{"features::impl_std::<impl enc::Encode for std::net::SocketAddr>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"features::impl_std::<impl enc::Encode for std::net::SocketAddr>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::net::SocketAddr
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for std::net::SocketAddr>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for std::net::SocketAddr>::encode(p0, p1);
+<std::net::SocketAddr>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for std::net::SocketAddr>::decode
deps:{"features::impl_std::<impl de::Decode for std::net::SocketAddr>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"features::impl_std::<impl de::Decode for std::net::SocketAddr>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for std::net::SocketAddr>::decode(p0);
+crate::features::impl_std::<impl de::Decode for std::net::SocketAddr>::decode(p0);
+<std::net::SocketAddr>::decode(p0);
-----------------
src/de/mod.rs features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddr>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddr>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddr>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddr>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddr>::borrow_decode(p0);
+<std::net::SocketAddr>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for std::net::SocketAddrV4>::encode
deps:{"features::impl_std::<impl enc::Encode for std::net::SocketAddrV4>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"features::impl_std::<impl enc::Encode for std::net::SocketAddrV4>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::net::SocketAddrV4
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for std::net::SocketAddrV4>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for std::net::SocketAddrV4>::encode(p0, p1);
+<std::net::SocketAddrV4>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for std::net::SocketAddrV4>::decode
deps:{"features::impl_std::<impl de::Decode for std::net::SocketAddrV4>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::Decode for std::net::SocketAddrV4>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for std::net::SocketAddrV4>::decode(p0);
+crate::features::impl_std::<impl de::Decode for std::net::SocketAddrV4>::decode(p0);
+<std::net::SocketAddrV4>::decode(p0);
-----------------
src/de/mod.rs features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV4>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV4>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV4>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV4>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV4>::borrow_decode(p0);
+<std::net::SocketAddrV4>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for std::net::SocketAddrV6>::encode
deps:{"features::impl_std::<impl enc::Encode for std::net::SocketAddrV6>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"features::impl_std::<impl enc::Encode for std::net::SocketAddrV6>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::net::SocketAddrV6
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for std::net::SocketAddrV6>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for std::net::SocketAddrV6>::encode(p0, p1);
+<std::net::SocketAddrV6>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for std::net::SocketAddrV6>::decode
deps:{"features::impl_std::<impl de::Decode for std::net::SocketAddrV6>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::Decode for std::net::SocketAddrV6>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for std::net::SocketAddrV6>::decode(p0);
+crate::features::impl_std::<impl de::Decode for std::net::SocketAddrV6>::decode(p0);
+<std::net::SocketAddrV6>::decode(p0);
-----------------
src/de/mod.rs features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV6>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV6>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV6>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV6>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV6>::borrow_decode(p0);
+<std::net::SocketAddrV6>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl core::error::Error for error::EncodeError>::source
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::EncodeError
+p0.source();
+features::impl_std::<impl core::error::Error for error::EncodeError>::source(p0);
+crate::features::impl_std::<impl core::error::Error for error::EncodeError>::source(p0);
+<error::EncodeError>::source(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl core::error::Error for error::DecodeError>::source
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::DecodeError
+p0.source();
+features::impl_std::<impl core::error::Error for error::DecodeError>::source(p0);
+crate::features::impl_std::<impl core::error::Error for error::DecodeError>::source(p0);
+<error::DecodeError>::source(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for std::collections::HashMap<K, V, S>>::encode
deps:{"features::impl_std::<impl enc::Encode for std::collections::HashMap<K, V, S>>::encode":{"E":["enc::Encoder","core::marker::Sized"],"K":["core::marker::Sized","enc::Encode"],"S":["core::marker::Sized"],"V":["core::marker::Sized","enc::Encode"]}}
candidates:{"features::impl_std::<impl enc::Encode for std::collections::HashMap<K, V, S>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::collections::HashMap<K, V, S>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for std::collections::HashMap<K, V, S>>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for std::collections::HashMap<K, V, S>>::encode(p0, p1);
+<std::collections::HashMap<K, V, S>>::encode(p0, p1);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for std::collections::HashMap<K, V, S>>::decode
deps:{"features::impl_std::<impl de::Decode for std::collections::HashMap<K, V, S>>::decode":{"D":["core::marker::Sized","de::Decoder"],"K":["core::marker::Sized","de::Decode","core::cmp::Eq","core::hash::Hash"],"S":["core::default::Default","core::marker::Sized","core::hash::BuildHasher"],"V":["core::marker::Sized","de::Decode"]}}
candidates:{"features::impl_std::<impl de::Decode for std::collections::HashMap<K, V, S>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for std::collections::HashMap<K, V, S>>::decode(p0);
+crate::features::impl_std::<impl de::Decode for std::collections::HashMap<K, V, S>>::decode(p0);
+<std::collections::HashMap<K, V, S>>::decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashMap<K, V, S>>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashMap<K, V, S>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"K":["de::BorrowDecode","core::hash::Hash","core::cmp::Eq","core::marker::Sized"],"S":["core::marker::Sized","core::hash::BuildHasher","core::default::Default"],"V":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashMap<K, V, S>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashMap<K, V, S>>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashMap<K, V, S>>::borrow_decode(p0);
+<std::collections::HashMap<K, V, S>>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::Decode for std::collections::HashSet<T, S>>::decode
deps:{"features::impl_std::<impl de::Decode for std::collections::HashSet<T, S>>::decode":{"D":["de::Decoder","core::marker::Sized"],"S":["core::hash::BuildHasher","core::marker::Sized","core::default::Default"],"T":["de::Decode","core::hash::Hash","core::cmp::Eq","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::Decode for std::collections::HashSet<T, S>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::Decode for std::collections::HashSet<T, S>>::decode(p0);
+crate::features::impl_std::<impl de::Decode for std::collections::HashSet<T, S>>::decode(p0);
+<std::collections::HashSet<T, S>>::decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashSet<T, S>>::borrow_decode
'de
deps:{"features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashSet<T, S>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"S":["core::marker::Sized","core::hash::BuildHasher","core::default::Default"],"T":["core::hash::Hash","core::cmp::Eq","de::BorrowDecode","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashSet<T, S>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashSet<T, S>>::borrow_decode(p0);
+crate::features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashSet<T, S>>::borrow_decode(p0);
+<std::collections::HashSet<T, S>>::borrow_decode(p0);
-----------------
src/features/impl_std.rs features::impl_std::<impl enc::Encode for std::collections::HashSet<T, S>>::encode
deps:{"features::impl_std::<impl enc::Encode for std::collections::HashSet<T, S>>::encode":{"E":["core::marker::Sized","enc::Encoder"],"S":["core::marker::Sized"],"T":["enc::Encode","core::marker::Sized"]}}
candidates:{"features::impl_std::<impl enc::Encode for std::collections::HashSet<T, S>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::collections::HashSet<T, S>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+features::impl_std::<impl enc::Encode for std::collections::HashSet<T, S>>::encode(p0, p1);
+crate::features::impl_std::<impl enc::Encode for std::collections::HashSet<T, S>>::encode(p0, p1);
+<std::collections::HashSet<T, S>>::encode(p0, p1);
-----------------
src/config.rs <config::Configuration<E, I, L> as core::clone::Clone>::clone
deps:{"<config::Configuration<E, I, L> as core::clone::Clone>::clone":{"E":["core::marker::Sized","core::clone::Clone"],"I":["core::marker::Sized","core::clone::Clone"],"L":["core::clone::Clone","core::marker::Sized"]}}
candidates:{"<config::Configuration<E, I, L> as core::clone::Clone>::clone":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // config::Configuration<E, I, L>
+p0.clone();
+<config::Configuration<E, I, L> as core::clone::Clone>::clone(p0);
+crate::<config::Configuration<E, I, L> as core::clone::Clone>::clone(p0);
+<config::Configuration<E, I, L>>::clone(p0);
-----------------
src/config.rs <config::Configuration<E, I, L> as core::default::Default>::default
deps:{"<config::Configuration<E, I, L> as core::default::Default>::default":{"E":["core::marker::Sized"],"I":["core::marker::Sized"],"L":["core::marker::Sized"]}}
candidates:{"<config::Configuration<E, I, L> as core::default::Default>::default":{}}
+<config::Configuration<E, I, L> as core::default::Default>::default();
+crate::<config::Configuration<E, I, L> as core::default::Default>::default();
+<config::Configuration<E, I, L>>::default();
-----------------
src/config.rs config::Configuration::<E, I, L>::with_big_endian
deps:{"config::Configuration::<E, I, L>::with_big_endian":{"E":["core::marker::Sized"],"I":["core::marker::Sized"],"L":["core::marker::Sized"]}}
candidates:{"config::Configuration::<E, I, L>::with_big_endian":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // config::Configuration<E, I, L>
+p0.with_big_endian();
+config::Configuration::<E, I, L>::with_big_endian(p0);
+crate::config::Configuration::<E, I, L>::with_big_endian(p0);
+<config::Configuration<E, I, L>>::with_big_endian(p0);
-----------------
src/config.rs config::Configuration::<E, I, L>::with_little_endian
deps:{"config::Configuration::<E, I, L>::with_little_endian":{"E":["core::marker::Sized"],"I":["core::marker::Sized"],"L":["core::marker::Sized"]}}
candidates:{"config::Configuration::<E, I, L>::with_little_endian":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // config::Configuration<E, I, L>
+p0.with_little_endian();
+config::Configuration::<E, I, L>::with_little_endian(p0);
+crate::config::Configuration::<E, I, L>::with_little_endian(p0);
+<config::Configuration<E, I, L>>::with_little_endian(p0);
-----------------
src/config.rs config::Configuration::<E, I, L>::with_variable_int_encoding
deps:{"config::Configuration::<E, I, L>::with_variable_int_encoding":{"E":["core::marker::Sized"],"I":["core::marker::Sized"],"L":["core::marker::Sized"]}}
candidates:{"config::Configuration::<E, I, L>::with_variable_int_encoding":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // config::Configuration<E, I, L>
+p0.with_variable_int_encoding();
+config::Configuration::<E, I, L>::with_variable_int_encoding(p0);
+crate::config::Configuration::<E, I, L>::with_variable_int_encoding(p0);
+<config::Configuration<E, I, L>>::with_variable_int_encoding(p0);
-----------------
src/config.rs config::Configuration::<E, I, L>::with_fixed_int_encoding
deps:{"config::Configuration::<E, I, L>::with_fixed_int_encoding":{"E":["core::marker::Sized"],"I":["core::marker::Sized"],"L":["core::marker::Sized"]}}
candidates:{"config::Configuration::<E, I, L>::with_fixed_int_encoding":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // config::Configuration<E, I, L>
+p0.with_fixed_int_encoding();
+config::Configuration::<E, I, L>::with_fixed_int_encoding(p0);
+crate::config::Configuration::<E, I, L>::with_fixed_int_encoding(p0);
+<config::Configuration<E, I, L>>::with_fixed_int_encoding(p0);
-----------------
src/config.rs config::Configuration::<E, I, L>::with_limit
deps:{"config::Configuration::<E, I, L>::with_limit":{"E":["core::marker::Sized"],"I":["core::marker::Sized"],"L":["core::marker::Sized"]}}
candidates:{"config::Configuration::<E, I, L>::with_limit":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // config::Configuration<E, I, L>
+p0.with_limit();
+config::Configuration::<E, I, L>::with_limit(p0);
+crate::config::Configuration::<E, I, L>::with_limit(p0);
+<config::Configuration<E, I, L>>::with_limit(p0);
-----------------
src/config.rs config::Configuration::<E, I, L>::with_no_limit
deps:{"config::Configuration::<E, I, L>::with_no_limit":{"E":["core::marker::Sized"],"I":["core::marker::Sized"],"L":["core::marker::Sized"]}}
candidates:{"config::Configuration::<E, I, L>::with_no_limit":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // config::Configuration<E, I, L>
+p0.with_no_limit();
+config::Configuration::<E, I, L>::with_no_limit(p0);
+crate::config::Configuration::<E, I, L>::with_no_limit(p0);
+<config::Configuration<E, I, L>>::with_no_limit(p0);
-----------------
src/config.rs <config::BigEndian as core::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // config::BigEndian
+p0.clone();
+<config::BigEndian as core::clone::Clone>::clone(p0);
+crate::<config::BigEndian as core::clone::Clone>::clone(p0);
+<config::BigEndian>::clone(p0);
-----------------
src/config.rs <config::LittleEndian as core::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // config::LittleEndian
+p0.clone();
+<config::LittleEndian as core::clone::Clone>::clone(p0);
+crate::<config::LittleEndian as core::clone::Clone>::clone(p0);
+<config::LittleEndian>::clone(p0);
-----------------
src/config.rs <config::Fixint as core::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // config::Fixint
+p0.clone();
+<config::Fixint as core::clone::Clone>::clone(p0);
+crate::<config::Fixint as core::clone::Clone>::clone(p0);
+<config::Fixint>::clone(p0);
-----------------
src/config.rs <config::Varint as core::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // config::Varint
+p0.clone();
+<config::Varint as core::clone::Clone>::clone(p0);
+crate::<config::Varint as core::clone::Clone>::clone(p0);
+<config::Varint>::clone(p0);
-----------------
src/config.rs <config::NoLimit as core::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // config::NoLimit
+p0.clone();
+<config::NoLimit as core::clone::Clone>::clone(p0);
+crate::<config::NoLimit as core::clone::Clone>::clone(p0);
+<config::NoLimit>::clone(p0);
-----------------
src/config.rs <config::Limit<N> as core::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // config::Limit<N>
+p0.clone();
+<config::Limit<N> as core::clone::Clone>::clone(p0);
+crate::<config::Limit<N> as core::clone::Clone>::clone(p0);
+<config::Limit<N>>::clone(p0);
-----------------
src/config.rs <config::internal::Endian as core::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // config::internal::Endian
let mut p1 = & MaybeUninit::uninit().assume_init(); // config::internal::Endian
+p0.eq(p1);
+<config::internal::Endian as core::cmp::PartialEq>::eq(p0, p1);
+crate::<config::internal::Endian as core::cmp::PartialEq>::eq(p0, p1);
+<config::internal::Endian>::eq(p0, p1);
-----------------
src/config.rs <config::internal::Endian as core::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // config::internal::Endian
+p0.assert_receiver_is_total_eq();
+<config::internal::Endian as core::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<config::internal::Endian as core::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<config::internal::Endian>::assert_receiver_is_total_eq(p0);
-----------------
src/config.rs <config::internal::IntEncoding as core::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // config::internal::IntEncoding
let mut p1 = & MaybeUninit::uninit().assume_init(); // config::internal::IntEncoding
+p0.eq(p1);
+<config::internal::IntEncoding as core::cmp::PartialEq>::eq(p0, p1);
+crate::<config::internal::IntEncoding as core::cmp::PartialEq>::eq(p0, p1);
+<config::internal::IntEncoding>::eq(p0, p1);
-----------------
src/config.rs <config::internal::IntEncoding as core::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // config::internal::IntEncoding
+p0.assert_receiver_is_total_eq();
+<config::internal::IntEncoding as core::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<config::internal::IntEncoding as core::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<config::internal::IntEncoding>::assert_receiver_is_total_eq(p0);
-----------------
src/de/decoder.rs de::decoder::DecoderImpl::<R, C>::new
deps:{"de::decoder::DecoderImpl::<R, C>::new":{"C":["core::marker::Sized","config::Config"],"R":["de::read::Reader","core::marker::Sized"]}}
candidates:{"de::decoder::DecoderImpl::<R, C>::new":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+de::decoder::DecoderImpl::<R, C>::new(p0, p1);
+crate::de::decoder::DecoderImpl::<R, C>::new(p0, p1);
+<de::decoder::DecoderImpl<R, C>>::new(p0, p1);
-----------------
src/de/decoder.rs <de::decoder::DecoderImpl<R, C> as de::BorrowDecoder<'de>>::borrow_reader
'de
deps:{"<de::decoder::DecoderImpl<R, C> as de::BorrowDecoder<'de>>::borrow_reader":{"C":["core::marker::Sized","config::Config"],"R":["core::marker::Sized","de::read::BorrowReader"]}}
candidates:{"<de::decoder::DecoderImpl<R, C> as de::BorrowDecoder<'de>>::borrow_reader":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::decoder::DecoderImpl<R, C>
+p0.borrow_reader();
+<de::decoder::DecoderImpl<R, C> as de::BorrowDecoder<'de>>::borrow_reader(p0);
+crate::<de::decoder::DecoderImpl<R, C> as de::BorrowDecoder<'de>>::borrow_reader(p0);
+<de::decoder::DecoderImpl<R, C>>::borrow_reader(p0);
-----------------
src/de/decoder.rs <de::decoder::DecoderImpl<R, C> as de::Decoder>::reader
deps:{"<de::decoder::DecoderImpl<R, C> as de::Decoder>::reader":{"C":["core::marker::Sized","config::Config"],"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"<de::decoder::DecoderImpl<R, C> as de::Decoder>::reader":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::decoder::DecoderImpl<R, C>
+p0.reader();
+<de::decoder::DecoderImpl<R, C> as de::Decoder>::reader(p0);
+crate::<de::decoder::DecoderImpl<R, C> as de::Decoder>::reader(p0);
+<de::decoder::DecoderImpl<R, C>>::reader(p0);
-----------------
src/de/decoder.rs <de::decoder::DecoderImpl<R, C> as de::Decoder>::config
deps:{"<de::decoder::DecoderImpl<R, C> as de::Decoder>::config":{"C":["core::marker::Sized","config::Config"],"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"<de::decoder::DecoderImpl<R, C> as de::Decoder>::config":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::decoder::DecoderImpl<R, C>
+p0.config();
+<de::decoder::DecoderImpl<R, C> as de::Decoder>::config(p0);
+crate::<de::decoder::DecoderImpl<R, C> as de::Decoder>::config(p0);
+<de::decoder::DecoderImpl<R, C>>::config(p0);
-----------------
src/de/decoder.rs <de::decoder::DecoderImpl<R, C> as de::Decoder>::claim_bytes_read
deps:{"<de::decoder::DecoderImpl<R, C> as de::Decoder>::claim_bytes_read":{"C":["core::marker::Sized","config::Config"],"R":["de::read::Reader","core::marker::Sized"]}}
candidates:{"<de::decoder::DecoderImpl<R, C> as de::Decoder>::claim_bytes_read":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::decoder::DecoderImpl<R, C>
let mut p1 = 0usize; // None+usize
+p0.claim_bytes_read(p1);
+<de::decoder::DecoderImpl<R, C> as de::Decoder>::claim_bytes_read(p0, p1);
+crate::<de::decoder::DecoderImpl<R, C> as de::Decoder>::claim_bytes_read(p0, p1);
+<de::decoder::DecoderImpl<R, C>>::claim_bytes_read(p0, p1);
-----------------
src/de/decoder.rs <de::decoder::DecoderImpl<R, C> as de::Decoder>::unclaim_bytes_read
deps:{"<de::decoder::DecoderImpl<R, C> as de::Decoder>::unclaim_bytes_read":{"C":["config::Config","core::marker::Sized"],"R":["core::marker::Sized","de::read::Reader"]}}
candidates:{"<de::decoder::DecoderImpl<R, C> as de::Decoder>::unclaim_bytes_read":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::decoder::DecoderImpl<R, C>
let mut p1 = 0usize; // None+usize
+p0.unclaim_bytes_read(p1);
+<de::decoder::DecoderImpl<R, C> as de::Decoder>::unclaim_bytes_read(p0, p1);
+crate::<de::decoder::DecoderImpl<R, C> as de::Decoder>::unclaim_bytes_read(p0, p1);
+<de::decoder::DecoderImpl<R, C>>::unclaim_bytes_read(p0, p1);
-----------------
src/de/impl_core.rs <de::impl_core::collect_into_array::Guard<'_, T, N> as core::ops::Drop>::drop
deps:{"<de::impl_core::collect_into_array::Guard<'_, T, N> as core::ops::Drop>::drop":{"T":["core::marker::Sized"]}}
candidates:{"<de::impl_core::collect_into_array::Guard<'_, T, N> as core::ops::Drop>::drop":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::impl_core::collect_into_array::Guard<'_, T, N>
+p0.drop();
+<de::impl_core::collect_into_array::Guard<'_, T, N> as core::ops::Drop>::drop(p0);
+crate::<de::impl_core::collect_into_array::Guard<'_, T, N> as core::ops::Drop>::drop(p0);
+<de::impl_core::collect_into_array::Guard<'_, T, N>>::drop(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A,)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A,)>::borrow_decode":{"A":["de::BorrowDecode","core::marker::Sized"],"BD":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A,)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A,)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A,)>::borrow_decode(p0);
+<(A,)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A,)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A,)>::decode":{"A":["de::Decode","core::marker::Sized"],"DE":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A,)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A,)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A,)>::decode(p0);
+<(A,)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B)>::borrow_decode":{"A":["core::marker::Sized","de::BorrowDecode"],"B":["core::marker::Sized","de::BorrowDecode"],"BD":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B)>::borrow_decode(p0);
+<(A, B)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B)>::decode":{"A":["de::Decode","core::marker::Sized"],"B":["core::marker::Sized","de::Decode"],"DE":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B)>::decode(p0);
+<(A, B)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C)>::borrow_decode":{"A":["core::marker::Sized","de::BorrowDecode"],"B":["de::BorrowDecode","core::marker::Sized"],"BD":["core::marker::Sized","de::BorrowDecoder"],"C":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C)>::borrow_decode(p0);
+<(A, B, C)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C)>::decode":{"A":["core::marker::Sized","de::Decode"],"B":["de::Decode","core::marker::Sized"],"C":["core::marker::Sized","de::Decode"],"DE":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C)>::decode(p0);
+<(A, B, C)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D)>::borrow_decode":{"A":["core::marker::Sized","de::BorrowDecode"],"B":["core::marker::Sized","de::BorrowDecode"],"BD":["core::marker::Sized","de::BorrowDecoder"],"C":["core::marker::Sized","de::BorrowDecode"],"D":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D)>::borrow_decode(p0);
+<(A, B, C, D)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D)>::decode":{"A":["core::marker::Sized","de::Decode"],"B":["core::marker::Sized","de::Decode"],"C":["de::Decode","core::marker::Sized"],"D":["de::Decode","core::marker::Sized"],"DE":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D)>::decode(p0);
+<(A, B, C, D)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E)>::borrow_decode":{"A":["core::marker::Sized","de::BorrowDecode"],"B":["de::BorrowDecode","core::marker::Sized"],"BD":["core::marker::Sized","de::BorrowDecoder"],"C":["core::marker::Sized","de::BorrowDecode"],"D":["core::marker::Sized","de::BorrowDecode"],"E":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E)>::borrow_decode(p0);
+<(A, B, C, D, E)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D, E)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E)>::decode":{"A":["de::Decode","core::marker::Sized"],"B":["core::marker::Sized","de::Decode"],"C":["core::marker::Sized","de::Decode"],"D":["core::marker::Sized","de::Decode"],"DE":["core::marker::Sized","de::Decoder"],"E":["core::marker::Sized","de::Decode"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D, E)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D, E)>::decode(p0);
+<(A, B, C, D, E)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F)>::borrow_decode":{"A":["de::BorrowDecode","core::marker::Sized"],"B":["de::BorrowDecode","core::marker::Sized"],"BD":["de::BorrowDecoder","core::marker::Sized"],"C":["core::marker::Sized","de::BorrowDecode"],"D":["de::BorrowDecode","core::marker::Sized"],"E":["core::marker::Sized","de::BorrowDecode"],"F":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F)>::borrow_decode(p0);
+<(A, B, C, D, E, F)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F)>::decode":{"A":["de::Decode","core::marker::Sized"],"B":["de::Decode","core::marker::Sized"],"C":["core::marker::Sized","de::Decode"],"D":["core::marker::Sized","de::Decode"],"DE":["de::Decoder","core::marker::Sized"],"E":["de::Decode","core::marker::Sized"],"F":["core::marker::Sized","de::Decode"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F)>::decode(p0);
+<(A, B, C, D, E, F)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G)>::borrow_decode":{"A":["core::marker::Sized","de::BorrowDecode"],"B":["core::marker::Sized","de::BorrowDecode"],"BD":["core::marker::Sized","de::BorrowDecoder"],"C":["core::marker::Sized","de::BorrowDecode"],"D":["core::marker::Sized","de::BorrowDecode"],"E":["core::marker::Sized","de::BorrowDecode"],"F":["core::marker::Sized","de::BorrowDecode"],"G":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G)>::borrow_decode(p0);
+<(A, B, C, D, E, F, G)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G)>::decode":{"A":["de::Decode","core::marker::Sized"],"B":["core::marker::Sized","de::Decode"],"C":["core::marker::Sized","de::Decode"],"D":["core::marker::Sized","de::Decode"],"DE":["de::Decoder","core::marker::Sized"],"E":["core::marker::Sized","de::Decode"],"F":["core::marker::Sized","de::Decode"],"G":["core::marker::Sized","de::Decode"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G)>::decode(p0);
+<(A, B, C, D, E, F, G)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H)>::borrow_decode":{"A":["de::BorrowDecode","core::marker::Sized"],"B":["de::BorrowDecode","core::marker::Sized"],"BD":["core::marker::Sized","de::BorrowDecoder"],"C":["de::BorrowDecode","core::marker::Sized"],"D":["core::marker::Sized","de::BorrowDecode"],"E":["core::marker::Sized","de::BorrowDecode"],"F":["core::marker::Sized","de::BorrowDecode"],"G":["de::BorrowDecode","core::marker::Sized"],"H":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H)>::borrow_decode(p0);
+<(A, B, C, D, E, F, G, H)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H)>::decode":{"A":["de::Decode","core::marker::Sized"],"B":["de::Decode","core::marker::Sized"],"C":["core::marker::Sized","de::Decode"],"D":["de::Decode","core::marker::Sized"],"DE":["core::marker::Sized","de::Decoder"],"E":["de::Decode","core::marker::Sized"],"F":["core::marker::Sized","de::Decode"],"G":["core::marker::Sized","de::Decode"],"H":["core::marker::Sized","de::Decode"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H)>::decode(p0);
+<(A, B, C, D, E, F, G, H)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I)>::borrow_decode":{"A":["de::BorrowDecode","core::marker::Sized"],"B":["de::BorrowDecode","core::marker::Sized"],"BD":["de::BorrowDecoder","core::marker::Sized"],"C":["de::BorrowDecode","core::marker::Sized"],"D":["core::marker::Sized","de::BorrowDecode"],"E":["core::marker::Sized","de::BorrowDecode"],"F":["core::marker::Sized","de::BorrowDecode"],"G":["de::BorrowDecode","core::marker::Sized"],"H":["de::BorrowDecode","core::marker::Sized"],"I":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I)>::borrow_decode(p0);
+<(A, B, C, D, E, F, G, H, I)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I)>::decode":{"A":["core::marker::Sized","de::Decode"],"B":["de::Decode","core::marker::Sized"],"C":["core::marker::Sized","de::Decode"],"D":["core::marker::Sized","de::Decode"],"DE":["core::marker::Sized","de::Decoder"],"E":["core::marker::Sized","de::Decode"],"F":["core::marker::Sized","de::Decode"],"G":["de::Decode","core::marker::Sized"],"H":["de::Decode","core::marker::Sized"],"I":["de::Decode","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I)>::decode(p0);
+<(A, B, C, D, E, F, G, H, I)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J)>::borrow_decode":{"A":["core::marker::Sized","de::BorrowDecode"],"B":["core::marker::Sized","de::BorrowDecode"],"BD":["core::marker::Sized","de::BorrowDecoder"],"C":["core::marker::Sized","de::BorrowDecode"],"D":["core::marker::Sized","de::BorrowDecode"],"E":["de::BorrowDecode","core::marker::Sized"],"F":["core::marker::Sized","de::BorrowDecode"],"G":["core::marker::Sized","de::BorrowDecode"],"H":["de::BorrowDecode","core::marker::Sized"],"I":["core::marker::Sized","de::BorrowDecode"],"J":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J)>::borrow_decode(p0);
+<(A, B, C, D, E, F, G, H, I, J)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J)>::decode":{"A":["core::marker::Sized","de::Decode"],"B":["de::Decode","core::marker::Sized"],"C":["core::marker::Sized","de::Decode"],"D":["core::marker::Sized","de::Decode"],"DE":["de::Decoder","core::marker::Sized"],"E":["de::Decode","core::marker::Sized"],"F":["core::marker::Sized","de::Decode"],"G":["de::Decode","core::marker::Sized"],"H":["core::marker::Sized","de::Decode"],"I":["core::marker::Sized","de::Decode"],"J":["de::Decode","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J)>::decode(p0);
+<(A, B, C, D, E, F, G, H, I, J)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K)>::borrow_decode":{"A":["de::BorrowDecode","core::marker::Sized"],"B":["de::BorrowDecode","core::marker::Sized"],"BD":["de::BorrowDecoder","core::marker::Sized"],"C":["de::BorrowDecode","core::marker::Sized"],"D":["core::marker::Sized","de::BorrowDecode"],"E":["de::BorrowDecode","core::marker::Sized"],"F":["core::marker::Sized","de::BorrowDecode"],"G":["de::BorrowDecode","core::marker::Sized"],"H":["core::marker::Sized","de::BorrowDecode"],"I":["core::marker::Sized","de::BorrowDecode"],"J":["core::marker::Sized","de::BorrowDecode"],"K":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K)>::borrow_decode(p0);
+<(A, B, C, D, E, F, G, H, I, J, K)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K)>::decode":{"A":["core::marker::Sized","de::Decode"],"B":["de::Decode","core::marker::Sized"],"C":["de::Decode","core::marker::Sized"],"D":["de::Decode","core::marker::Sized"],"DE":["de::Decoder","core::marker::Sized"],"E":["core::marker::Sized","de::Decode"],"F":["de::Decode","core::marker::Sized"],"G":["core::marker::Sized","de::Decode"],"H":["core::marker::Sized","de::Decode"],"I":["core::marker::Sized","de::Decode"],"J":["de::Decode","core::marker::Sized"],"K":["de::Decode","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K)>::decode(p0);
+<(A, B, C, D, E, F, G, H, I, J, K)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L)>::borrow_decode":{"A":["core::marker::Sized","de::BorrowDecode"],"B":["core::marker::Sized","de::BorrowDecode"],"BD":["de::BorrowDecoder","core::marker::Sized"],"C":["core::marker::Sized","de::BorrowDecode"],"D":["de::BorrowDecode","core::marker::Sized"],"E":["core::marker::Sized","de::BorrowDecode"],"F":["de::BorrowDecode","core::marker::Sized"],"G":["core::marker::Sized","de::BorrowDecode"],"H":["core::marker::Sized","de::BorrowDecode"],"I":["core::marker::Sized","de::BorrowDecode"],"J":["core::marker::Sized","de::BorrowDecode"],"K":["core::marker::Sized","de::BorrowDecode"],"L":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L)>::borrow_decode(p0);
+<(A, B, C, D, E, F, G, H, I, J, K, L)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L)>::decode":{"A":["core::marker::Sized","de::Decode"],"B":["core::marker::Sized","de::Decode"],"C":["core::marker::Sized","de::Decode"],"D":["core::marker::Sized","de::Decode"],"DE":["core::marker::Sized","de::Decoder"],"E":["de::Decode","core::marker::Sized"],"F":["core::marker::Sized","de::Decode"],"G":["core::marker::Sized","de::Decode"],"H":["core::marker::Sized","de::Decode"],"I":["core::marker::Sized","de::Decode"],"J":["de::Decode","core::marker::Sized"],"K":["de::Decode","core::marker::Sized"],"L":["core::marker::Sized","de::Decode"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L)>::decode(p0);
+<(A, B, C, D, E, F, G, H, I, J, K, L)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::borrow_decode":{"A":["de::BorrowDecode","core::marker::Sized"],"B":["de::BorrowDecode","core::marker::Sized"],"BD":["de::BorrowDecoder","core::marker::Sized"],"C":["core::marker::Sized","de::BorrowDecode"],"D":["core::marker::Sized","de::BorrowDecode"],"E":["core::marker::Sized","de::BorrowDecode"],"F":["core::marker::Sized","de::BorrowDecode"],"G":["core::marker::Sized","de::BorrowDecode"],"H":["core::marker::Sized","de::BorrowDecode"],"I":["core::marker::Sized","de::BorrowDecode"],"J":["core::marker::Sized","de::BorrowDecode"],"K":["core::marker::Sized","de::BorrowDecode"],"L":["core::marker::Sized","de::BorrowDecode"],"M":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::borrow_decode(p0);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::decode":{"A":["core::marker::Sized","de::Decode"],"B":["core::marker::Sized","de::Decode"],"C":["core::marker::Sized","de::Decode"],"D":["core::marker::Sized","de::Decode"],"DE":["core::marker::Sized","de::Decoder"],"E":["de::Decode","core::marker::Sized"],"F":["core::marker::Sized","de::Decode"],"G":["de::Decode","core::marker::Sized"],"H":["core::marker::Sized","de::Decode"],"I":["core::marker::Sized","de::Decode"],"J":["de::Decode","core::marker::Sized"],"K":["core::marker::Sized","de::Decode"],"L":["de::Decode","core::marker::Sized"],"M":["core::marker::Sized","de::Decode"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::decode(p0);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::borrow_decode":{"A":["de::BorrowDecode","core::marker::Sized"],"B":["de::BorrowDecode","core::marker::Sized"],"BD":["de::BorrowDecoder","core::marker::Sized"],"C":["de::BorrowDecode","core::marker::Sized"],"D":["core::marker::Sized","de::BorrowDecode"],"E":["de::BorrowDecode","core::marker::Sized"],"F":["de::BorrowDecode","core::marker::Sized"],"G":["core::marker::Sized","de::BorrowDecode"],"H":["core::marker::Sized","de::BorrowDecode"],"I":["de::BorrowDecode","core::marker::Sized"],"J":["core::marker::Sized","de::BorrowDecode"],"K":["de::BorrowDecode","core::marker::Sized"],"L":["de::BorrowDecode","core::marker::Sized"],"M":["core::marker::Sized","de::BorrowDecode"],"N":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::borrow_decode(p0);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::decode":{"A":["core::marker::Sized","de::Decode"],"B":["de::Decode","core::marker::Sized"],"C":["core::marker::Sized","de::Decode"],"D":["core::marker::Sized","de::Decode"],"DE":["core::marker::Sized","de::Decoder"],"E":["core::marker::Sized","de::Decode"],"F":["core::marker::Sized","de::Decode"],"G":["core::marker::Sized","de::Decode"],"H":["de::Decode","core::marker::Sized"],"I":["core::marker::Sized","de::Decode"],"J":["core::marker::Sized","de::Decode"],"K":["de::Decode","core::marker::Sized"],"L":["de::Decode","core::marker::Sized"],"M":["core::marker::Sized","de::Decode"],"N":["de::Decode","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::decode(p0);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::borrow_decode":{"A":["core::marker::Sized","de::BorrowDecode"],"B":["core::marker::Sized","de::BorrowDecode"],"BD":["core::marker::Sized","de::BorrowDecoder"],"C":["de::BorrowDecode","core::marker::Sized"],"D":["core::marker::Sized","de::BorrowDecode"],"E":["de::BorrowDecode","core::marker::Sized"],"F":["de::BorrowDecode","core::marker::Sized"],"G":["core::marker::Sized","de::BorrowDecode"],"H":["de::BorrowDecode","core::marker::Sized"],"I":["core::marker::Sized","de::BorrowDecode"],"J":["core::marker::Sized","de::BorrowDecode"],"K":["core::marker::Sized","de::BorrowDecode"],"L":["de::BorrowDecode","core::marker::Sized"],"M":["core::marker::Sized","de::BorrowDecode"],"N":["core::marker::Sized","de::BorrowDecode"],"O":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::borrow_decode(p0);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::decode":{"A":["de::Decode","core::marker::Sized"],"B":["core::marker::Sized","de::Decode"],"C":["de::Decode","core::marker::Sized"],"D":["core::marker::Sized","de::Decode"],"DE":["core::marker::Sized","de::Decoder"],"E":["core::marker::Sized","de::Decode"],"F":["de::Decode","core::marker::Sized"],"G":["core::marker::Sized","de::Decode"],"H":["de::Decode","core::marker::Sized"],"I":["core::marker::Sized","de::Decode"],"J":["core::marker::Sized","de::Decode"],"K":["de::Decode","core::marker::Sized"],"L":["core::marker::Sized","de::Decode"],"M":["core::marker::Sized","de::Decode"],"N":["de::Decode","core::marker::Sized"],"O":["core::marker::Sized","de::Decode"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::decode(p0);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::borrow_decode
'de
deps:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::borrow_decode":{"A":["core::marker::Sized","de::BorrowDecode"],"B":["de::BorrowDecode","core::marker::Sized"],"BD":["core::marker::Sized","de::BorrowDecoder"],"C":["core::marker::Sized","de::BorrowDecode"],"D":["de::BorrowDecode","core::marker::Sized"],"E":["de::BorrowDecode","core::marker::Sized"],"F":["core::marker::Sized","de::BorrowDecode"],"G":["core::marker::Sized","de::BorrowDecode"],"H":["core::marker::Sized","de::BorrowDecode"],"I":["de::BorrowDecode","core::marker::Sized"],"J":["de::BorrowDecode","core::marker::Sized"],"K":["core::marker::Sized","de::BorrowDecode"],"L":["core::marker::Sized","de::BorrowDecode"],"M":["de::BorrowDecode","core::marker::Sized"],"N":["core::marker::Sized","de::BorrowDecode"],"O":["core::marker::Sized","de::BorrowDecode"],"P":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // BD
+de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::borrow_decode(p0);
+crate::de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::borrow_decode(p0);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::borrow_decode(p0);
-----------------
src/de/impl_tuples.rs de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::decode
deps:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::decode":{"A":["core::marker::Sized","de::Decode"],"B":["core::marker::Sized","de::Decode"],"C":["de::Decode","core::marker::Sized"],"D":["core::marker::Sized","de::Decode"],"DE":["core::marker::Sized","de::Decoder"],"E":["de::Decode","core::marker::Sized"],"F":["de::Decode","core::marker::Sized"],"G":["core::marker::Sized","de::Decode"],"H":["de::Decode","core::marker::Sized"],"I":["de::Decode","core::marker::Sized"],"J":["core::marker::Sized","de::Decode"],"K":["core::marker::Sized","de::Decode"],"L":["core::marker::Sized","de::Decode"],"M":["core::marker::Sized","de::Decode"],"N":["core::marker::Sized","de::Decode"],"O":["core::marker::Sized","de::Decode"],"P":["de::Decode","core::marker::Sized"]}}
candidates:{"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // DE
+de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::decode(p0);
+crate::de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::decode(p0);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for bool>::decode
deps:{"de::impls::<impl de::Decode for bool>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for bool>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for bool>::decode(p0);
+crate::de::impls::<impl de::Decode for bool>::decode(p0);
+<bool>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for bool>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for bool>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for bool>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for bool>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for bool>::borrow_decode(p0);
+<bool>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for u8>::decode
deps:{"de::impls::<impl de::Decode for u8>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for u8>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for u8>::decode(p0);
+crate::de::impls::<impl de::Decode for u8>::decode(p0);
+<u8>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for u8>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for u8>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for u8>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for u8>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for u8>::borrow_decode(p0);
+<u8>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::num::NonZeroU8>::decode
deps:{"de::impls::<impl de::Decode for core::num::NonZeroU8>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for core::num::NonZeroU8>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::num::NonZeroU8>::decode(p0);
+crate::de::impls::<impl de::Decode for core::num::NonZeroU8>::decode(p0);
+<core::num::NonZeroU8>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU8>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU8>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU8>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU8>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU8>::borrow_decode(p0);
+<core::num::NonZeroU8>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for u16>::decode
deps:{"de::impls::<impl de::Decode for u16>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for u16>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for u16>::decode(p0);
+crate::de::impls::<impl de::Decode for u16>::decode(p0);
+<u16>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for u16>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for u16>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for u16>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for u16>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for u16>::borrow_decode(p0);
+<u16>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::num::NonZeroU16>::decode
deps:{"de::impls::<impl de::Decode for core::num::NonZeroU16>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for core::num::NonZeroU16>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::num::NonZeroU16>::decode(p0);
+crate::de::impls::<impl de::Decode for core::num::NonZeroU16>::decode(p0);
+<core::num::NonZeroU16>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU16>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU16>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU16>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU16>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU16>::borrow_decode(p0);
+<core::num::NonZeroU16>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for u32>::decode
deps:{"de::impls::<impl de::Decode for u32>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for u32>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for u32>::decode(p0);
+crate::de::impls::<impl de::Decode for u32>::decode(p0);
+<u32>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for u32>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for u32>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for u32>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for u32>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for u32>::borrow_decode(p0);
+<u32>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::num::NonZeroU32>::decode
deps:{"de::impls::<impl de::Decode for core::num::NonZeroU32>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for core::num::NonZeroU32>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::num::NonZeroU32>::decode(p0);
+crate::de::impls::<impl de::Decode for core::num::NonZeroU32>::decode(p0);
+<core::num::NonZeroU32>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU32>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU32>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU32>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU32>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU32>::borrow_decode(p0);
+<core::num::NonZeroU32>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for u64>::decode
deps:{"de::impls::<impl de::Decode for u64>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for u64>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for u64>::decode(p0);
+crate::de::impls::<impl de::Decode for u64>::decode(p0);
+<u64>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for u64>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for u64>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for u64>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for u64>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for u64>::borrow_decode(p0);
+<u64>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::num::NonZeroU64>::decode
deps:{"de::impls::<impl de::Decode for core::num::NonZeroU64>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for core::num::NonZeroU64>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::num::NonZeroU64>::decode(p0);
+crate::de::impls::<impl de::Decode for core::num::NonZeroU64>::decode(p0);
+<core::num::NonZeroU64>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU64>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU64>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU64>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU64>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU64>::borrow_decode(p0);
+<core::num::NonZeroU64>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for u128>::decode
deps:{"de::impls::<impl de::Decode for u128>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for u128>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for u128>::decode(p0);
+crate::de::impls::<impl de::Decode for u128>::decode(p0);
+<u128>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for u128>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for u128>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for u128>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for u128>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for u128>::borrow_decode(p0);
+<u128>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::num::NonZeroU128>::decode
deps:{"de::impls::<impl de::Decode for core::num::NonZeroU128>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for core::num::NonZeroU128>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::num::NonZeroU128>::decode(p0);
+crate::de::impls::<impl de::Decode for core::num::NonZeroU128>::decode(p0);
+<core::num::NonZeroU128>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU128>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU128>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU128>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU128>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU128>::borrow_decode(p0);
+<core::num::NonZeroU128>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for usize>::decode
deps:{"de::impls::<impl de::Decode for usize>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for usize>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for usize>::decode(p0);
+crate::de::impls::<impl de::Decode for usize>::decode(p0);
+<usize>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for usize>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for usize>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for usize>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for usize>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for usize>::borrow_decode(p0);
+<usize>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::num::NonZeroUsize>::decode
deps:{"de::impls::<impl de::Decode for core::num::NonZeroUsize>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for core::num::NonZeroUsize>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::num::NonZeroUsize>::decode(p0);
+crate::de::impls::<impl de::Decode for core::num::NonZeroUsize>::decode(p0);
+<core::num::NonZeroUsize>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroUsize>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroUsize>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroUsize>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroUsize>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroUsize>::borrow_decode(p0);
+<core::num::NonZeroUsize>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for i8>::decode
deps:{"de::impls::<impl de::Decode for i8>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for i8>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for i8>::decode(p0);
+crate::de::impls::<impl de::Decode for i8>::decode(p0);
+<i8>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for i8>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for i8>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for i8>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for i8>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for i8>::borrow_decode(p0);
+<i8>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::num::NonZeroI8>::decode
deps:{"de::impls::<impl de::Decode for core::num::NonZeroI8>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for core::num::NonZeroI8>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::num::NonZeroI8>::decode(p0);
+crate::de::impls::<impl de::Decode for core::num::NonZeroI8>::decode(p0);
+<core::num::NonZeroI8>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI8>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI8>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI8>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI8>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI8>::borrow_decode(p0);
+<core::num::NonZeroI8>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for i16>::decode
deps:{"de::impls::<impl de::Decode for i16>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for i16>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for i16>::decode(p0);
+crate::de::impls::<impl de::Decode for i16>::decode(p0);
+<i16>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for i16>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for i16>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for i16>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for i16>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for i16>::borrow_decode(p0);
+<i16>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::num::NonZeroI16>::decode
deps:{"de::impls::<impl de::Decode for core::num::NonZeroI16>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for core::num::NonZeroI16>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::num::NonZeroI16>::decode(p0);
+crate::de::impls::<impl de::Decode for core::num::NonZeroI16>::decode(p0);
+<core::num::NonZeroI16>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI16>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI16>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI16>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI16>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI16>::borrow_decode(p0);
+<core::num::NonZeroI16>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for i32>::decode
deps:{"de::impls::<impl de::Decode for i32>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for i32>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for i32>::decode(p0);
+crate::de::impls::<impl de::Decode for i32>::decode(p0);
+<i32>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for i32>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for i32>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for i32>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for i32>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for i32>::borrow_decode(p0);
+<i32>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::num::NonZeroI32>::decode
deps:{"de::impls::<impl de::Decode for core::num::NonZeroI32>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for core::num::NonZeroI32>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::num::NonZeroI32>::decode(p0);
+crate::de::impls::<impl de::Decode for core::num::NonZeroI32>::decode(p0);
+<core::num::NonZeroI32>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI32>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI32>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI32>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI32>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI32>::borrow_decode(p0);
+<core::num::NonZeroI32>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for i64>::decode
deps:{"de::impls::<impl de::Decode for i64>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for i64>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for i64>::decode(p0);
+crate::de::impls::<impl de::Decode for i64>::decode(p0);
+<i64>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for i64>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for i64>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for i64>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for i64>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for i64>::borrow_decode(p0);
+<i64>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::num::NonZeroI64>::decode
deps:{"de::impls::<impl de::Decode for core::num::NonZeroI64>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for core::num::NonZeroI64>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::num::NonZeroI64>::decode(p0);
+crate::de::impls::<impl de::Decode for core::num::NonZeroI64>::decode(p0);
+<core::num::NonZeroI64>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI64>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI64>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI64>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI64>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI64>::borrow_decode(p0);
+<core::num::NonZeroI64>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for i128>::decode
deps:{"de::impls::<impl de::Decode for i128>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for i128>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for i128>::decode(p0);
+crate::de::impls::<impl de::Decode for i128>::decode(p0);
+<i128>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for i128>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for i128>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for i128>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for i128>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for i128>::borrow_decode(p0);
+<i128>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::num::NonZeroI128>::decode
deps:{"de::impls::<impl de::Decode for core::num::NonZeroI128>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for core::num::NonZeroI128>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::num::NonZeroI128>::decode(p0);
+crate::de::impls::<impl de::Decode for core::num::NonZeroI128>::decode(p0);
+<core::num::NonZeroI128>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI128>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI128>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI128>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI128>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI128>::borrow_decode(p0);
+<core::num::NonZeroI128>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for isize>::decode
deps:{"de::impls::<impl de::Decode for isize>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for isize>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for isize>::decode(p0);
+crate::de::impls::<impl de::Decode for isize>::decode(p0);
+<isize>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for isize>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for isize>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for isize>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for isize>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for isize>::borrow_decode(p0);
+<isize>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::num::NonZeroIsize>::decode
deps:{"de::impls::<impl de::Decode for core::num::NonZeroIsize>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for core::num::NonZeroIsize>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::num::NonZeroIsize>::decode(p0);
+crate::de::impls::<impl de::Decode for core::num::NonZeroIsize>::decode(p0);
+<core::num::NonZeroIsize>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroIsize>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroIsize>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroIsize>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroIsize>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroIsize>::borrow_decode(p0);
+<core::num::NonZeroIsize>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for f32>::decode
deps:{"de::impls::<impl de::Decode for f32>::decode":{"D":["de::Decoder","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for f32>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for f32>::decode(p0);
+crate::de::impls::<impl de::Decode for f32>::decode(p0);
+<f32>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for f32>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for f32>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for f32>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for f32>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for f32>::borrow_decode(p0);
+<f32>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for f64>::decode
deps:{"de::impls::<impl de::Decode for f64>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for f64>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for f64>::decode(p0);
+crate::de::impls::<impl de::Decode for f64>::decode(p0);
+<f64>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for f64>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for f64>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for f64>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for f64>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for f64>::borrow_decode(p0);
+<f64>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for char>::decode
deps:{"de::impls::<impl de::Decode for char>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for char>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for char>::decode(p0);
+crate::de::impls::<impl de::Decode for char>::decode(p0);
+<char>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for char>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for char>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for char>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for char>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for char>::borrow_decode(p0);
+<char>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::BorrowDecode<'de> for &'a [u8]>::borrow_decode
'a,'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for &'a [u8]>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for &'a [u8]>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for &'a [u8]>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for &'a [u8]>::borrow_decode(p0);
+<&'a [u8]>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::BorrowDecode<'de> for &'a str>::borrow_decode
'a,'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for &'a str>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for &'a str>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for &'a str>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for &'a str>::borrow_decode(p0);
+<&'a str>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for [T; N]>::decode
deps:{"de::impls::<impl de::Decode for [T; N]>::decode":{"D":["de::Decoder","core::marker::Sized"],"T":["core::marker::Sized","de::Decode"]}}
candidates:{"de::impls::<impl de::Decode for [T; N]>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for [T; N]>::decode(p0);
+crate::de::impls::<impl de::Decode for [T; N]>::decode(p0);
+<[T; N]>::decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::BorrowDecode<'de> for [T; N]>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for [T; N]>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"T":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for [T; N]>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for [T; N]>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for [T; N]>::borrow_decode(p0);
+<[T; N]>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for ()>::decode
deps:{"de::impls::<impl de::Decode for ()>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for ()>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for ()>::decode(p0);
+crate::de::impls::<impl de::Decode for ()>::decode(p0);
+<()>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for ()>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for ()>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for ()>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for ()>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for ()>::borrow_decode(p0);
+<()>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::marker::PhantomData<T>>::decode
deps:{"de::impls::<impl de::Decode for core::marker::PhantomData<T>>::decode":{"D":["de::Decoder","core::marker::Sized"],"T":["core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for core::marker::PhantomData<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::marker::PhantomData<T>>::decode(p0);
+crate::de::impls::<impl de::Decode for core::marker::PhantomData<T>>::decode(p0);
+<core::marker::PhantomData<T>>::decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::BorrowDecode<'de> for core::marker::PhantomData<T>>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::marker::PhantomData<T>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"T":["core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::marker::PhantomData<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::marker::PhantomData<T>>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::marker::PhantomData<T>>::borrow_decode(p0);
+<core::marker::PhantomData<T>>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::option::Option<T>>::decode
deps:{"de::impls::<impl de::Decode for core::option::Option<T>>::decode":{"D":["core::marker::Sized","de::Decoder"],"T":["de::Decode","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for core::option::Option<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::option::Option<T>>::decode(p0);
+crate::de::impls::<impl de::Decode for core::option::Option<T>>::decode(p0);
+<core::option::Option<T>>::decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::BorrowDecode<'de> for core::option::Option<T>>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::option::Option<T>>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"],"T":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::option::Option<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::option::Option<T>>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::option::Option<T>>::borrow_decode(p0);
+<core::option::Option<T>>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::result::Result<T, U>>::decode
deps:{"de::impls::<impl de::Decode for core::result::Result<T, U>>::decode":{"D":["core::marker::Sized","de::Decoder"],"T":["de::Decode","core::marker::Sized"],"U":["core::marker::Sized","de::Decode"]}}
candidates:{"de::impls::<impl de::Decode for core::result::Result<T, U>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::result::Result<T, U>>::decode(p0);
+crate::de::impls::<impl de::Decode for core::result::Result<T, U>>::decode(p0);
+<core::result::Result<T, U>>::decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::BorrowDecode<'de> for core::result::Result<T, U>>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::result::Result<T, U>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"T":["core::marker::Sized","de::BorrowDecode"],"U":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::result::Result<T, U>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::result::Result<T, U>>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::result::Result<T, U>>::borrow_decode(p0);
+<core::result::Result<T, U>>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::cell::Cell<T>>::decode
deps:{"de::impls::<impl de::Decode for core::cell::Cell<T>>::decode":{"D":["core::marker::Sized","de::Decoder"],"T":["de::Decode","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for core::cell::Cell<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::cell::Cell<T>>::decode(p0);
+crate::de::impls::<impl de::Decode for core::cell::Cell<T>>::decode(p0);
+<core::cell::Cell<T>>::decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::BorrowDecode<'de> for core::cell::Cell<T>>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::cell::Cell<T>>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"],"T":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::cell::Cell<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::cell::Cell<T>>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::cell::Cell<T>>::borrow_decode(p0);
+<core::cell::Cell<T>>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::cell::RefCell<T>>::decode
deps:{"de::impls::<impl de::Decode for core::cell::RefCell<T>>::decode":{"D":["de::Decoder","core::marker::Sized"],"T":["core::marker::Sized","de::Decode"]}}
candidates:{"de::impls::<impl de::Decode for core::cell::RefCell<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::cell::RefCell<T>>::decode(p0);
+crate::de::impls::<impl de::Decode for core::cell::RefCell<T>>::decode(p0);
+<core::cell::RefCell<T>>::decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::BorrowDecode<'de> for core::cell::RefCell<T>>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::cell::RefCell<T>>::borrow_decode":{"D":["de::BorrowDecoder","core::marker::Sized"],"T":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::cell::RefCell<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::cell::RefCell<T>>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::cell::RefCell<T>>::borrow_decode(p0);
+<core::cell::RefCell<T>>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::time::Duration>::decode
deps:{"de::impls::<impl de::Decode for core::time::Duration>::decode":{"D":["core::marker::Sized","de::Decoder"]}}
candidates:{"de::impls::<impl de::Decode for core::time::Duration>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::time::Duration>::decode(p0);
+crate::de::impls::<impl de::Decode for core::time::Duration>::decode(p0);
+<core::time::Duration>::decode(p0);
-----------------
src/de/mod.rs de::impls::<impl de::BorrowDecode<'de> for core::time::Duration>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::time::Duration>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::time::Duration>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::time::Duration>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::time::Duration>::borrow_decode(p0);
+<core::time::Duration>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::ops::Range<T>>::decode
deps:{"de::impls::<impl de::Decode for core::ops::Range<T>>::decode":{"D":["de::Decoder","core::marker::Sized"],"T":["core::marker::Sized","de::Decode"]}}
candidates:{"de::impls::<impl de::Decode for core::ops::Range<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::ops::Range<T>>::decode(p0);
+crate::de::impls::<impl de::Decode for core::ops::Range<T>>::decode(p0);
+<core::ops::Range<T>>::decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::BorrowDecode<'de> for core::ops::Range<T>>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::ops::Range<T>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"T":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::ops::Range<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::ops::Range<T>>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::ops::Range<T>>::borrow_decode(p0);
+<core::ops::Range<T>>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::ops::RangeInclusive<T>>::decode
deps:{"de::impls::<impl de::Decode for core::ops::RangeInclusive<T>>::decode":{"D":["de::Decoder","core::marker::Sized"],"T":["de::Decode","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for core::ops::RangeInclusive<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::ops::RangeInclusive<T>>::decode(p0);
+crate::de::impls::<impl de::Decode for core::ops::RangeInclusive<T>>::decode(p0);
+<core::ops::RangeInclusive<T>>::decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::BorrowDecode<'de> for core::ops::RangeInclusive<T>>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::ops::RangeInclusive<T>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"T":["core::marker::Sized","de::BorrowDecode"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::ops::RangeInclusive<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::ops::RangeInclusive<T>>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::ops::RangeInclusive<T>>::borrow_decode(p0);
+<core::ops::RangeInclusive<T>>::borrow_decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::Decode for core::ops::Bound<T>>::decode
deps:{"de::impls::<impl de::Decode for core::ops::Bound<T>>::decode":{"D":["de::Decoder","core::marker::Sized"],"T":["de::Decode","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::Decode for core::ops::Bound<T>>::decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::Decode for core::ops::Bound<T>>::decode(p0);
+crate::de::impls::<impl de::Decode for core::ops::Bound<T>>::decode(p0);
+<core::ops::Bound<T>>::decode(p0);
-----------------
src/de/impls.rs de::impls::<impl de::BorrowDecode<'de> for core::ops::Bound<T>>::borrow_decode
'de
deps:{"de::impls::<impl de::BorrowDecode<'de> for core::ops::Bound<T>>::borrow_decode":{"D":["core::marker::Sized","de::BorrowDecoder"],"T":["de::BorrowDecode","core::marker::Sized"]}}
candidates:{"de::impls::<impl de::BorrowDecode<'de> for core::ops::Bound<T>>::borrow_decode":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // D
+de::impls::<impl de::BorrowDecode<'de> for core::ops::Bound<T>>::borrow_decode(p0);
+crate::de::impls::<impl de::BorrowDecode<'de> for core::ops::Bound<T>>::borrow_decode(p0);
+<core::ops::Bound<T>>::borrow_decode(p0);
-----------------
src/de/read.rs <&mut T as de::read::Reader>::read
deps:{"<&mut T as de::read::Reader>::read":{"T":["de::read::Reader","core::marker::Sized"]}}
candidates:{"<&mut T as de::read::Reader>::read":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // T
let mut p1 = &mut [0u8].as_mut_slice(); // None+[u8]
+p0.read(p1);
+<&mut T as de::read::Reader>::read(p0, p1);
+crate::<&mut T as de::read::Reader>::read(p0, p1);
+<&mut T>::read(p0, p1);
-----------------
src/de/read.rs <&mut T as de::read::Reader>::peek_read
deps:{"<&mut T as de::read::Reader>::peek_read":{"T":["de::read::Reader","core::marker::Sized"]}}
candidates:{"<&mut T as de::read::Reader>::peek_read":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0usize; // None+usize
+p0.peek_read(p1);
+<&mut T as de::read::Reader>::peek_read(p0, p1);
+crate::<&mut T as de::read::Reader>::peek_read(p0, p1);
+<&mut T>::peek_read(p0, p1);
-----------------
src/de/read.rs <&mut T as de::read::Reader>::consume
deps:{"<&mut T as de::read::Reader>::consume":{"T":["core::marker::Sized","de::read::Reader"]}}
candidates:{"<&mut T as de::read::Reader>::consume":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0usize; // None+usize
+p0.consume(p1);
+<&mut T as de::read::Reader>::consume(p0, p1);
+crate::<&mut T as de::read::Reader>::consume(p0, p1);
+<&mut T>::consume(p0, p1);
-----------------
src/de/read.rs de::read::SliceReader::<'storage>::new
'storage
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+de::read::SliceReader::<'storage>::new(p0);
+crate::de::read::SliceReader::<'storage>::new(p0);
+<de::read::SliceReader<'storage>>::new(p0);
-----------------
src/de/read.rs <de::read::SliceReader<'storage> as de::read::Reader>::read
'storage
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::read::SliceReader<'storage>
let mut p1 = &mut [0u8].as_mut_slice(); // None+[u8]
+p0.read(p1);
+<de::read::SliceReader<'storage> as de::read::Reader>::read(p0, p1);
+crate::<de::read::SliceReader<'storage> as de::read::Reader>::read(p0, p1);
+<de::read::SliceReader<'storage>>::read(p0, p1);
-----------------
src/de/read.rs <de::read::SliceReader<'storage> as de::read::Reader>::peek_read
'storage
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::read::SliceReader<'storage>
let mut p1 = 0usize; // None+usize
+p0.peek_read(p1);
+<de::read::SliceReader<'storage> as de::read::Reader>::peek_read(p0, p1);
+crate::<de::read::SliceReader<'storage> as de::read::Reader>::peek_read(p0, p1);
+<de::read::SliceReader<'storage>>::peek_read(p0, p1);
-----------------
src/de/read.rs <de::read::SliceReader<'storage> as de::read::Reader>::consume
'storage
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::read::SliceReader<'storage>
let mut p1 = 0usize; // None+usize
+p0.consume(p1);
+<de::read::SliceReader<'storage> as de::read::Reader>::consume(p0, p1);
+crate::<de::read::SliceReader<'storage> as de::read::Reader>::consume(p0, p1);
+<de::read::SliceReader<'storage>>::consume(p0, p1);
-----------------
src/de/read.rs <de::read::SliceReader<'storage> as de::read::BorrowReader<'storage>>::take_bytes
'storage
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::read::SliceReader<'storage>
let mut p1 = 0usize; // None+usize
+p0.take_bytes(p1);
+<de::read::SliceReader<'storage> as de::read::BorrowReader<'storage>>::take_bytes(p0, p1);
+crate::<de::read::SliceReader<'storage> as de::read::BorrowReader<'storage>>::take_bytes(p0, p1);
+<de::read::SliceReader<'storage>>::take_bytes(p0, p1);
-----------------
src/de/mod.rs <&'a mut T as de::Decoder>::reader
'a
deps:{"<&'a mut T as de::Decoder>::reader":{"T":["de::Decoder","core::marker::Sized"]}}
candidates:{"<&'a mut T as de::Decoder>::reader":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // T
+p0.reader();
+<&'a mut T as de::Decoder>::reader(p0);
+crate::<&'a mut T as de::Decoder>::reader(p0);
+<&'a mut T>::reader(p0);
-----------------
src/de/mod.rs <&'a mut T as de::Decoder>::config
'a
deps:{"<&'a mut T as de::Decoder>::config":{"T":["core::marker::Sized","de::Decoder"]}}
candidates:{"<&'a mut T as de::Decoder>::config":{}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
+p0.config();
+<&'a mut T as de::Decoder>::config(p0);
+crate::<&'a mut T as de::Decoder>::config(p0);
+<&'a mut T>::config(p0);
-----------------
src/de/mod.rs <&'a mut T as de::Decoder>::claim_bytes_read
'a
deps:{"<&'a mut T as de::Decoder>::claim_bytes_read":{"T":["core::marker::Sized","de::Decoder"]}}
candidates:{"<&'a mut T as de::Decoder>::claim_bytes_read":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0usize; // None+usize
+p0.claim_bytes_read(p1);
+<&'a mut T as de::Decoder>::claim_bytes_read(p0, p1);
+crate::<&'a mut T as de::Decoder>::claim_bytes_read(p0, p1);
+<&'a mut T>::claim_bytes_read(p0, p1);
-----------------
src/de/mod.rs <&'a mut T as de::Decoder>::unclaim_bytes_read
'a
deps:{"<&'a mut T as de::Decoder>::unclaim_bytes_read":{"T":["core::marker::Sized","de::Decoder"]}}
candidates:{"<&'a mut T as de::Decoder>::unclaim_bytes_read":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // T
let mut p1 = 0usize; // None+usize
+p0.unclaim_bytes_read(p1);
+<&'a mut T as de::Decoder>::unclaim_bytes_read(p0, p1);
+crate::<&'a mut T as de::Decoder>::unclaim_bytes_read(p0, p1);
+<&'a mut T>::unclaim_bytes_read(p0, p1);
-----------------
src/de/mod.rs <&'a mut T as de::BorrowDecoder<'de>>::borrow_reader
'a,'de
deps:{"<&'a mut T as de::BorrowDecoder<'de>>::borrow_reader":{"T":["core::marker::Sized","de::BorrowDecoder"]}}
candidates:{"<&'a mut T as de::BorrowDecoder<'de>>::borrow_reader":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // T
+p0.borrow_reader();
+<&'a mut T as de::BorrowDecoder<'de>>::borrow_reader(p0);
+crate::<&'a mut T as de::BorrowDecoder<'de>>::borrow_reader(p0);
+<&'a mut T>::borrow_reader(p0);
-----------------
src/enc/encoder.rs enc::encoder::EncoderImpl::<W, C>::new
deps:{"enc::encoder::EncoderImpl::<W, C>::new":{"C":["config::Config","core::marker::Sized"],"W":["enc::write::Writer","core::marker::Sized"]}}
candidates:{"enc::encoder::EncoderImpl::<W, C>::new":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // W
let mut p1 = MaybeUninit::uninit().assume_init(); // C
+enc::encoder::EncoderImpl::<W, C>::new(p0, p1);
+crate::enc::encoder::EncoderImpl::<W, C>::new(p0, p1);
+<enc::encoder::EncoderImpl<W, C>>::new(p0, p1);
-----------------
src/enc/encoder.rs enc::encoder::EncoderImpl::<W, C>::into_writer
deps:{"enc::encoder::EncoderImpl::<W, C>::into_writer":{"C":["core::marker::Sized","config::Config"],"W":["core::marker::Sized","enc::write::Writer"]}}
candidates:{"enc::encoder::EncoderImpl::<W, C>::into_writer":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // enc::encoder::EncoderImpl<W, C>
+p0.into_writer();
+enc::encoder::EncoderImpl::<W, C>::into_writer(p0);
+crate::enc::encoder::EncoderImpl::<W, C>::into_writer(p0);
+<enc::encoder::EncoderImpl<W, C>>::into_writer(p0);
-----------------
src/enc/encoder.rs <enc::encoder::EncoderImpl<W, C> as enc::Encoder>::writer
deps:{"<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::writer":{"C":["config::Config","core::marker::Sized"],"W":["enc::write::Writer","core::marker::Sized"]}}
candidates:{"<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::writer":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // enc::encoder::EncoderImpl<W, C>
+p0.writer();
+<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::writer(p0);
+crate::<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::writer(p0);
+<enc::encoder::EncoderImpl<W, C>>::writer(p0);
-----------------
src/enc/encoder.rs <enc::encoder::EncoderImpl<W, C> as enc::Encoder>::config
deps:{"<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::config":{"C":["config::Config","core::marker::Sized"],"W":["core::marker::Sized","enc::write::Writer"]}}
candidates:{"<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::config":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // enc::encoder::EncoderImpl<W, C>
+p0.config();
+<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::config(p0);
+crate::<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::config(p0);
+<enc::encoder::EncoderImpl<W, C>>::config(p0);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A,)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A,)>::encode":{"A":["core::marker::Sized","enc::Encode"],"_E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A,)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A,)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A,)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A,)>::encode(p0, p1);
+<(A,)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B)>::encode":{"A":["enc::Encode","core::marker::Sized"],"B":["enc::Encode","core::marker::Sized"],"_E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B)>::encode(p0, p1);
+<(A, B)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C)>::encode":{"A":["core::marker::Sized","enc::Encode"],"B":["enc::Encode","core::marker::Sized"],"C":["core::marker::Sized","enc::Encode"],"_E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C)>::encode(p0, p1);
+<(A, B, C)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D)>::encode":{"A":["enc::Encode","core::marker::Sized"],"B":["core::marker::Sized","enc::Encode"],"C":["enc::Encode","core::marker::Sized"],"D":["enc::Encode","core::marker::Sized"],"_E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D)>::encode(p0, p1);
+<(A, B, C, D)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E)>::encode":{"A":["enc::Encode","core::marker::Sized"],"B":["core::marker::Sized","enc::Encode"],"C":["core::marker::Sized","enc::Encode"],"D":["core::marker::Sized","enc::Encode"],"E":["core::marker::Sized","enc::Encode"],"_E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D, E)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E)>::encode(p0, p1);
+<(A, B, C, D, E)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F)>::encode":{"A":["core::marker::Sized","enc::Encode"],"B":["enc::Encode","core::marker::Sized"],"C":["core::marker::Sized","enc::Encode"],"D":["enc::Encode","core::marker::Sized"],"E":["enc::Encode","core::marker::Sized"],"F":["enc::Encode","core::marker::Sized"],"_E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F)>::encode(p0, p1);
+<(A, B, C, D, E, F)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G)>::encode":{"A":["core::marker::Sized","enc::Encode"],"B":["enc::Encode","core::marker::Sized"],"C":["core::marker::Sized","enc::Encode"],"D":["core::marker::Sized","enc::Encode"],"E":["core::marker::Sized","enc::Encode"],"F":["enc::Encode","core::marker::Sized"],"G":["core::marker::Sized","enc::Encode"],"_E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G)>::encode(p0, p1);
+<(A, B, C, D, E, F, G)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H)>::encode":{"A":["core::marker::Sized","enc::Encode"],"B":["core::marker::Sized","enc::Encode"],"C":["core::marker::Sized","enc::Encode"],"D":["enc::Encode","core::marker::Sized"],"E":["enc::Encode","core::marker::Sized"],"F":["enc::Encode","core::marker::Sized"],"G":["core::marker::Sized","enc::Encode"],"H":["core::marker::Sized","enc::Encode"],"_E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H)>::encode(p0, p1);
+<(A, B, C, D, E, F, G, H)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I)>::encode":{"A":["core::marker::Sized","enc::Encode"],"B":["enc::Encode","core::marker::Sized"],"C":["core::marker::Sized","enc::Encode"],"D":["enc::Encode","core::marker::Sized"],"E":["core::marker::Sized","enc::Encode"],"F":["enc::Encode","core::marker::Sized"],"G":["core::marker::Sized","enc::Encode"],"H":["enc::Encode","core::marker::Sized"],"I":["enc::Encode","core::marker::Sized"],"_E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I)>::encode(p0, p1);
+<(A, B, C, D, E, F, G, H, I)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J)>::encode":{"A":["enc::Encode","core::marker::Sized"],"B":["core::marker::Sized","enc::Encode"],"C":["core::marker::Sized","enc::Encode"],"D":["enc::Encode","core::marker::Sized"],"E":["enc::Encode","core::marker::Sized"],"F":["core::marker::Sized","enc::Encode"],"G":["enc::Encode","core::marker::Sized"],"H":["core::marker::Sized","enc::Encode"],"I":["core::marker::Sized","enc::Encode"],"J":["enc::Encode","core::marker::Sized"],"_E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J)>::encode(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K)>::encode":{"A":["core::marker::Sized","enc::Encode"],"B":["core::marker::Sized","enc::Encode"],"C":["core::marker::Sized","enc::Encode"],"D":["core::marker::Sized","enc::Encode"],"E":["core::marker::Sized","enc::Encode"],"F":["core::marker::Sized","enc::Encode"],"G":["core::marker::Sized","enc::Encode"],"H":["enc::Encode","core::marker::Sized"],"I":["core::marker::Sized","enc::Encode"],"J":["enc::Encode","core::marker::Sized"],"K":["enc::Encode","core::marker::Sized"],"_E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K)>::encode(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L)>::encode":{"A":["core::marker::Sized","enc::Encode"],"B":["enc::Encode","core::marker::Sized"],"C":["enc::Encode","core::marker::Sized"],"D":["enc::Encode","core::marker::Sized"],"E":["core::marker::Sized","enc::Encode"],"F":["enc::Encode","core::marker::Sized"],"G":["core::marker::Sized","enc::Encode"],"H":["enc::Encode","core::marker::Sized"],"I":["core::marker::Sized","enc::Encode"],"J":["enc::Encode","core::marker::Sized"],"K":["enc::Encode","core::marker::Sized"],"L":["enc::Encode","core::marker::Sized"],"_E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L)>::encode(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::encode":{"A":["core::marker::Sized","enc::Encode"],"B":["core::marker::Sized","enc::Encode"],"C":["core::marker::Sized","enc::Encode"],"D":["enc::Encode","core::marker::Sized"],"E":["core::marker::Sized","enc::Encode"],"F":["enc::Encode","core::marker::Sized"],"G":["enc::Encode","core::marker::Sized"],"H":["core::marker::Sized","enc::Encode"],"I":["enc::Encode","core::marker::Sized"],"J":["enc::Encode","core::marker::Sized"],"K":["core::marker::Sized","enc::Encode"],"L":["core::marker::Sized","enc::Encode"],"M":["core::marker::Sized","enc::Encode"],"_E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::encode(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::encode":{"A":["core::marker::Sized","enc::Encode"],"B":["core::marker::Sized","enc::Encode"],"C":["core::marker::Sized","enc::Encode"],"D":["core::marker::Sized","enc::Encode"],"E":["enc::Encode","core::marker::Sized"],"F":["core::marker::Sized","enc::Encode"],"G":["core::marker::Sized","enc::Encode"],"H":["core::marker::Sized","enc::Encode"],"I":["core::marker::Sized","enc::Encode"],"J":["enc::Encode","core::marker::Sized"],"K":["enc::Encode","core::marker::Sized"],"L":["core::marker::Sized","enc::Encode"],"M":["enc::Encode","core::marker::Sized"],"N":["enc::Encode","core::marker::Sized"],"_E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::encode(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::encode":{"A":["enc::Encode","core::marker::Sized"],"B":["core::marker::Sized","enc::Encode"],"C":["enc::Encode","core::marker::Sized"],"D":["enc::Encode","core::marker::Sized"],"E":["core::marker::Sized","enc::Encode"],"F":["enc::Encode","core::marker::Sized"],"G":["core::marker::Sized","enc::Encode"],"H":["core::marker::Sized","enc::Encode"],"I":["enc::Encode","core::marker::Sized"],"J":["enc::Encode","core::marker::Sized"],"K":["enc::Encode","core::marker::Sized"],"L":["enc::Encode","core::marker::Sized"],"M":["enc::Encode","core::marker::Sized"],"N":["core::marker::Sized","enc::Encode"],"O":["enc::Encode","core::marker::Sized"],"_E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::encode(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::encode(p0, p1);
-----------------
src/enc/impl_tuples.rs enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::encode
deps:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::encode":{"A":["enc::Encode","core::marker::Sized"],"B":["enc::Encode","core::marker::Sized"],"C":["core::marker::Sized","enc::Encode"],"D":["enc::Encode","core::marker::Sized"],"E":["core::marker::Sized","enc::Encode"],"F":["enc::Encode","core::marker::Sized"],"G":["enc::Encode","core::marker::Sized"],"H":["core::marker::Sized","enc::Encode"],"I":["core::marker::Sized","enc::Encode"],"J":["core::marker::Sized","enc::Encode"],"K":["core::marker::Sized","enc::Encode"],"L":["enc::Encode","core::marker::Sized"],"M":["enc::Encode","core::marker::Sized"],"N":["enc::Encode","core::marker::Sized"],"O":["enc::Encode","core::marker::Sized"],"P":["core::marker::Sized","enc::Encode"],"_E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // _E
+p0.encode(p1);
+enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::encode(p0, p1);
+crate::enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::encode(p0, p1);
+<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for ()>::encode
deps:{"enc::impls::<impl enc::Encode for ()>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for ()>::encode":{}}
let mut p0 = & (); // None+()
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for ()>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for ()>::encode(p0, p1);
+<()>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::marker::PhantomData<T>>::encode
deps:{"enc::impls::<impl enc::Encode for core::marker::PhantomData<T>>::encode":{"E":["core::marker::Sized","enc::Encoder"],"T":["core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for core::marker::PhantomData<T>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::marker::PhantomData<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::marker::PhantomData<T>>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::marker::PhantomData<T>>::encode(p0, p1);
+<core::marker::PhantomData<T>>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for bool>::encode
deps:{"enc::impls::<impl enc::Encode for bool>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for bool>::encode":{}}
let mut p0 = & true; // None+bool
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for bool>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for bool>::encode(p0, p1);
+<bool>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for u8>::encode
deps:{"enc::impls::<impl enc::Encode for u8>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for u8>::encode":{}}
let mut p0 = & 0u8; // None+u8
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for u8>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for u8>::encode(p0, p1);
+<u8>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::num::NonZeroU8>::encode
deps:{"enc::impls::<impl enc::Encode for core::num::NonZeroU8>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for core::num::NonZeroU8>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::num::NonZeroU8
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::num::NonZeroU8>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::num::NonZeroU8>::encode(p0, p1);
+<core::num::NonZeroU8>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for u16>::encode
deps:{"enc::impls::<impl enc::Encode for u16>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for u16>::encode":{}}
let mut p0 = & 0u16; // None+u16
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for u16>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for u16>::encode(p0, p1);
+<u16>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::num::NonZeroU16>::encode
deps:{"enc::impls::<impl enc::Encode for core::num::NonZeroU16>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for core::num::NonZeroU16>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::num::NonZeroU16
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::num::NonZeroU16>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::num::NonZeroU16>::encode(p0, p1);
+<core::num::NonZeroU16>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for u32>::encode
deps:{"enc::impls::<impl enc::Encode for u32>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for u32>::encode":{}}
let mut p0 = & 0u32; // None+u32
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for u32>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for u32>::encode(p0, p1);
+<u32>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::num::NonZeroU32>::encode
deps:{"enc::impls::<impl enc::Encode for core::num::NonZeroU32>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for core::num::NonZeroU32>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::num::NonZeroU32
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::num::NonZeroU32>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::num::NonZeroU32>::encode(p0, p1);
+<core::num::NonZeroU32>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for u64>::encode
deps:{"enc::impls::<impl enc::Encode for u64>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for u64>::encode":{}}
let mut p0 = & 0u64; // None+u64
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for u64>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for u64>::encode(p0, p1);
+<u64>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::num::NonZeroU64>::encode
deps:{"enc::impls::<impl enc::Encode for core::num::NonZeroU64>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for core::num::NonZeroU64>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::num::NonZeroU64
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::num::NonZeroU64>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::num::NonZeroU64>::encode(p0, p1);
+<core::num::NonZeroU64>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for u128>::encode
deps:{"enc::impls::<impl enc::Encode for u128>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for u128>::encode":{}}
let mut p0 = & 0u128; // None+u128
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for u128>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for u128>::encode(p0, p1);
+<u128>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::num::NonZeroU128>::encode
deps:{"enc::impls::<impl enc::Encode for core::num::NonZeroU128>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for core::num::NonZeroU128>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::num::NonZeroU128
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::num::NonZeroU128>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::num::NonZeroU128>::encode(p0, p1);
+<core::num::NonZeroU128>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for usize>::encode
deps:{"enc::impls::<impl enc::Encode for usize>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for usize>::encode":{}}
let mut p0 = & 0usize; // None+usize
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for usize>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for usize>::encode(p0, p1);
+<usize>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::num::NonZeroUsize>::encode
deps:{"enc::impls::<impl enc::Encode for core::num::NonZeroUsize>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for core::num::NonZeroUsize>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::num::NonZeroUsize
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::num::NonZeroUsize>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::num::NonZeroUsize>::encode(p0, p1);
+<core::num::NonZeroUsize>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for i8>::encode
deps:{"enc::impls::<impl enc::Encode for i8>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for i8>::encode":{}}
let mut p0 = & 0i8; // None+i8
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for i8>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for i8>::encode(p0, p1);
+<i8>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::num::NonZeroI8>::encode
deps:{"enc::impls::<impl enc::Encode for core::num::NonZeroI8>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for core::num::NonZeroI8>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::num::NonZeroI8
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::num::NonZeroI8>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::num::NonZeroI8>::encode(p0, p1);
+<core::num::NonZeroI8>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for i16>::encode
deps:{"enc::impls::<impl enc::Encode for i16>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for i16>::encode":{}}
let mut p0 = & 0i16; // None+i16
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for i16>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for i16>::encode(p0, p1);
+<i16>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::num::NonZeroI16>::encode
deps:{"enc::impls::<impl enc::Encode for core::num::NonZeroI16>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for core::num::NonZeroI16>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::num::NonZeroI16
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::num::NonZeroI16>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::num::NonZeroI16>::encode(p0, p1);
+<core::num::NonZeroI16>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for i32>::encode
deps:{"enc::impls::<impl enc::Encode for i32>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for i32>::encode":{}}
let mut p0 = & 0i32; // None+i32
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for i32>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for i32>::encode(p0, p1);
+<i32>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::num::NonZeroI32>::encode
deps:{"enc::impls::<impl enc::Encode for core::num::NonZeroI32>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for core::num::NonZeroI32>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::num::NonZeroI32
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::num::NonZeroI32>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::num::NonZeroI32>::encode(p0, p1);
+<core::num::NonZeroI32>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for i64>::encode
deps:{"enc::impls::<impl enc::Encode for i64>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for i64>::encode":{}}
let mut p0 = & 0i64; // None+i64
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for i64>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for i64>::encode(p0, p1);
+<i64>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::num::NonZeroI64>::encode
deps:{"enc::impls::<impl enc::Encode for core::num::NonZeroI64>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for core::num::NonZeroI64>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::num::NonZeroI64
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::num::NonZeroI64>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::num::NonZeroI64>::encode(p0, p1);
+<core::num::NonZeroI64>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for i128>::encode
deps:{"enc::impls::<impl enc::Encode for i128>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for i128>::encode":{}}
let mut p0 = & 0i128; // None+i128
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for i128>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for i128>::encode(p0, p1);
+<i128>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::num::NonZeroI128>::encode
deps:{"enc::impls::<impl enc::Encode for core::num::NonZeroI128>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for core::num::NonZeroI128>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::num::NonZeroI128
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::num::NonZeroI128>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::num::NonZeroI128>::encode(p0, p1);
+<core::num::NonZeroI128>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for isize>::encode
deps:{"enc::impls::<impl enc::Encode for isize>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for isize>::encode":{}}
let mut p0 = & 0isize; // None+isize
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for isize>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for isize>::encode(p0, p1);
+<isize>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::num::NonZeroIsize>::encode
deps:{"enc::impls::<impl enc::Encode for core::num::NonZeroIsize>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for core::num::NonZeroIsize>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::num::NonZeroIsize
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::num::NonZeroIsize>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::num::NonZeroIsize>::encode(p0, p1);
+<core::num::NonZeroIsize>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for f32>::encode
deps:{"enc::impls::<impl enc::Encode for f32>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for f32>::encode":{}}
let mut p0 = & 0f32; // None+f32
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for f32>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for f32>::encode(p0, p1);
+<f32>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for f64>::encode
deps:{"enc::impls::<impl enc::Encode for f64>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for f64>::encode":{}}
let mut p0 = & 0f64; // None+f64
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for f64>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for f64>::encode(p0, p1);
+<f64>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for char>::encode
deps:{"enc::impls::<impl enc::Encode for char>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for char>::encode":{}}
let mut p0 = & 'a'; // None+char
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for char>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for char>::encode(p0, p1);
+<char>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for [T]>::encode
deps:{"enc::impls::<impl enc::Encode for [T]>::encode":{"E":["core::marker::Sized","enc::Encoder"],"T":["core::marker::Sized","enc::Encode"]}}
candidates:{"enc::impls::<impl enc::Encode for [T]>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T]
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for [T]>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for [T]>::encode(p0, p1);
+<[T]>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for str>::encode
deps:{"enc::impls::<impl enc::Encode for str>::encode":{"E":["core::marker::Sized","enc::Encoder"]}}
candidates:{"enc::impls::<impl enc::Encode for str>::encode":{}}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for str>::encode(&p0, p1);
+crate::enc::impls::<impl enc::Encode for str>::encode(&p0, p1);
+<str>::encode(&p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for [T; N]>::encode
deps:{"enc::impls::<impl enc::Encode for [T; N]>::encode":{"E":["enc::Encoder","core::marker::Sized"],"T":["core::marker::Sized","enc::Encode"]}}
candidates:{"enc::impls::<impl enc::Encode for [T; N]>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T; N]
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for [T; N]>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for [T; N]>::encode(p0, p1);
+<[T; N]>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::option::Option<T>>::encode
deps:{"enc::impls::<impl enc::Encode for core::option::Option<T>>::encode":{"E":["enc::Encoder","core::marker::Sized"],"T":["core::marker::Sized","enc::Encode"]}}
candidates:{"enc::impls::<impl enc::Encode for core::option::Option<T>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::option::Option<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::option::Option<T>>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::option::Option<T>>::encode(p0, p1);
+<core::option::Option<T>>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::result::Result<T, U>>::encode
deps:{"enc::impls::<impl enc::Encode for core::result::Result<T, U>>::encode":{"E":["core::marker::Sized","enc::Encoder"],"T":["core::marker::Sized","enc::Encode"],"U":["enc::Encode","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for core::result::Result<T, U>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::result::Result<T, U>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::result::Result<T, U>>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::result::Result<T, U>>::encode(p0, p1);
+<core::result::Result<T, U>>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::cell::Cell<T>>::encode
deps:{"enc::impls::<impl enc::Encode for core::cell::Cell<T>>::encode":{"E":["enc::Encoder","core::marker::Sized"],"T":["core::marker::Sized","core::marker::Copy","enc::Encode"]}}
candidates:{"enc::impls::<impl enc::Encode for core::cell::Cell<T>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::cell::Cell<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::cell::Cell<T>>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::cell::Cell<T>>::encode(p0, p1);
+<core::cell::Cell<T>>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::cell::RefCell<T>>::encode
deps:{"<T as alloc::borrow::ToOwned>":{"T":["core::marker::Sized","core::clone::Clone"]},"alloc::borrow::Cow":{"B":["alloc::borrow::ToOwned"]},"alloc::boxed::Box":{"A":["core::alloc::Allocator","core::marker::Sized"]},"alloc::collections::BTreeMap":{"A":["core::alloc::Allocator","core::marker::Sized","core::clone::Clone"],"K":["de::Decode","core::cmp::Ord","core::marker::Sized","de::BorrowDecode","enc::Encode"],"V":["core::marker::Sized","enc::Encode","de::BorrowDecode","de::Decode"]},"alloc::collections::BTreeSet":{"A":["core::marker::Sized","core::alloc::Allocator","core::clone::Clone"],"T":["core::cmp::Ord","core::marker::Sized","de::Decode","enc::Encode","de::BorrowDecode"]},"alloc::collections::BinaryHeap":{"T":["core::marker::Sized","de::Decode","core::cmp::Ord","de::BorrowDecode","enc::Encode"]},"alloc::collections::VecDeque":{"A":["core::alloc::Allocator","core::marker::Sized"],"T":["enc::Encode","de::BorrowDecode","core::marker::Sized","de::Decode"]},"alloc::vec::Vec":{"A":["core::alloc::Allocator","core::marker::Sized"],"T":["core::marker::Sized","enc::Encode","de::Decode","de::BorrowDecode"]},"core::ops::Bound":{"T":["de::BorrowDecode","core::marker::Sized","enc::Encode","de::Decode"]},"core::ops::Range":{"Idx":["core::marker::Sized"]},"core::ops::RangeInclusive":{"Idx":["core::marker::Sized"]},"core::option::Option":{"T":["de::BorrowDecode","de::Decode","enc::Encode","core::marker::Sized"]},"core::result::Result":{"E":["core::marker::Sized"],"T":["de::BorrowDecode","de::Decode","enc::Encode","core::marker::Sized"]},"enc::impls::<impl enc::Encode for &'a T>":{},"enc::impls::<impl enc::Encode for core::cell::RefCell<T>>::encode":{"E":["core::marker::Sized","enc::Encoder"],"T":["enc::Encode"]},"std::collections::HashMap":{"K":["core::cmp::Eq","enc::Encode","core::hash::Hash","de::BorrowDecode","de::Decode","core::marker::Sized"],"S":["core::hash::BuildHasher","core::default::Default","core::marker::Sized"],"V":["core::marker::Sized","enc::Encode","de::BorrowDecode","de::Decode"]},"std::collections::HashSet":{"S":["core::hash::BuildHasher","core::marker::Sized","core::default::Default"],"T":["core::hash::Hash","de::Decode","core::cmp::Eq","core::marker::Sized","de::BorrowDecode","enc::Encode"]}}
candidates:{"<T as alloc::borrow::ToOwned>":{},"alloc::borrow::Cow":{"B":["<T as alloc::borrow::ToOwned>","core::ffi::CStr","std::path::Path","std::ffi::OsStr"]},"alloc::boxed::Box":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeMap":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeSet":{"A":["alloc::alloc::Global"]},"alloc::collections::BinaryHeap":{},"alloc::collections::VecDeque":{"A":["alloc::alloc::Global"]},"alloc::vec::Vec":{"A":["alloc::alloc::Global"]},"core::ops::Bound":{},"core::ops::Range":{},"core::ops::RangeInclusive":{},"core::option::Option":{},"core::result::Result":{},"enc::impls::<impl enc::Encode for &'a T>":{},"enc::impls::<impl enc::Encode for core::cell::RefCell<T>>::encode":{"T":["core::cell::Cell","core::num::NonZeroU8","std::sync::RwLock","core::time::Duration","std::net::Ipv6Addr","std::time::SystemTime","std::net::IpAddr","alloc::sync::Arc","core::sync::atomic::AtomicIsize","alloc::collections::VecDeque","core::sync::atomic::AtomicI32","core::cell::RefCell","core::num::NonZeroU16","alloc::rc::Rc","core::ops::Range","core::num::NonZeroI16","core::sync::atomic::AtomicU16","std::sync::Mutex","core::sync::atomic::AtomicU64","alloc::borrow::Cow","alloc::collections::BTreeSet","core::ops::RangeInclusive","std::collections::HashSet","core::marker::PhantomData","core::sync::atomic::AtomicUsize","std::net::SocketAddr","core::sync::atomic::AtomicI64","core::num::NonZeroU32","std::net::SocketAddrV6","core::num::NonZeroIsize","std::net::SocketAddrV4","core::sync::atomic::AtomicI16","alloc::string::String","core::sync::atomic::AtomicU32","alloc::collections::BTreeMap","core::num::NonZeroI8","core::sync::atomic::AtomicBool","core::result::Result","std::net::Ipv4Addr","alloc::ffi::CString","alloc::collections::BinaryHeap","core::sync::atomic::AtomicI8","core::num::NonZeroU64","std::collections::HashMap","alloc::vec::Vec","core::num::NonZeroI128","std::path::PathBuf","core::option::Option","core::num::NonZeroUsize","alloc::boxed::Box","core::sync::atomic::AtomicU8","core::num::NonZeroU128","core::ops::Bound","core::num::NonZeroI32","enc::impls::<impl enc::Encode for &'a T>","core::num::NonZeroI64"]},"std::collections::HashMap":{"S":["std::collections::hash_map::RandomState"]},"std::collections::HashSet":{"S":["std::collections::hash_map::RandomState"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::cell::RefCell<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::cell::RefCell<T>>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::cell::RefCell<T>>::encode(p0, p1);
+<core::cell::RefCell<T>>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::time::Duration>::encode
deps:{"enc::impls::<impl enc::Encode for core::time::Duration>::encode":{"E":["enc::Encoder","core::marker::Sized"]}}
candidates:{"enc::impls::<impl enc::Encode for core::time::Duration>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::time::Duration
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::time::Duration>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::time::Duration>::encode(p0, p1);
+<core::time::Duration>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::ops::Range<T>>::encode
deps:{"enc::impls::<impl enc::Encode for core::ops::Range<T>>::encode":{"E":["enc::Encoder","core::marker::Sized"],"T":["core::marker::Sized","enc::Encode"]}}
candidates:{"enc::impls::<impl enc::Encode for core::ops::Range<T>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::ops::Range<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::ops::Range<T>>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::ops::Range<T>>::encode(p0, p1);
+<core::ops::Range<T>>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::ops::RangeInclusive<T>>::encode
deps:{"enc::impls::<impl enc::Encode for core::ops::RangeInclusive<T>>::encode":{"E":["core::marker::Sized","enc::Encoder"],"T":["core::marker::Sized","enc::Encode"]}}
candidates:{"enc::impls::<impl enc::Encode for core::ops::RangeInclusive<T>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::ops::RangeInclusive<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::ops::RangeInclusive<T>>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::ops::RangeInclusive<T>>::encode(p0, p1);
+<core::ops::RangeInclusive<T>>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for core::ops::Bound<T>>::encode
deps:{"enc::impls::<impl enc::Encode for core::ops::Bound<T>>::encode":{"E":["enc::Encoder","core::marker::Sized"],"T":["core::marker::Sized","enc::Encode"]}}
candidates:{"enc::impls::<impl enc::Encode for core::ops::Bound<T>>::encode":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // core::ops::Bound<T>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for core::ops::Bound<T>>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for core::ops::Bound<T>>::encode(p0, p1);
+<core::ops::Bound<T>>::encode(p0, p1);
-----------------
src/enc/impls.rs enc::impls::<impl enc::Encode for &'a T>::encode
'a
deps:{"<T as alloc::borrow::ToOwned>":{"T":["core::clone::Clone","core::marker::Sized"]},"alloc::borrow::Cow":{"B":["alloc::borrow::ToOwned"]},"alloc::boxed::Box":{"A":["core::alloc::Allocator","core::marker::Sized"]},"alloc::collections::BTreeMap":{"A":["core::alloc::Allocator","core::marker::Sized","core::clone::Clone"],"K":["enc::Encode","de::Decode","core::cmp::Ord","de::BorrowDecode","core::marker::Sized"],"V":["core::marker::Sized","enc::Encode","de::Decode","de::BorrowDecode"]},"alloc::collections::BTreeSet":{"A":["core::marker::Sized","core::alloc::Allocator","core::clone::Clone"],"T":["enc::Encode","de::BorrowDecode","core::marker::Sized","core::cmp::Ord","de::Decode"]},"alloc::collections::BinaryHeap":{"T":["core::cmp::Ord","de::BorrowDecode","core::marker::Sized","de::Decode","enc::Encode"]},"alloc::collections::VecDeque":{"A":["core::marker::Sized","core::alloc::Allocator"],"T":["de::Decode","core::marker::Sized","de::BorrowDecode","enc::Encode"]},"alloc::vec::Vec":{"A":["core::marker::Sized","core::alloc::Allocator"],"T":["de::BorrowDecode","de::Decode","core::marker::Sized","enc::Encode"]},"core::ops::Bound":{"T":["de::BorrowDecode","de::Decode","enc::Encode","core::marker::Sized"]},"core::ops::Range":{"Idx":["core::marker::Sized"]},"core::ops::RangeInclusive":{"Idx":["core::marker::Sized"]},"core::option::Option":{"T":["de::Decode","core::marker::Sized","enc::Encode","de::BorrowDecode"]},"core::result::Result":{"E":["core::marker::Sized"],"T":["de::Decode","de::BorrowDecode","enc::Encode","core::marker::Sized"]},"enc::impls::<impl enc::Encode for &'a T>":{},"enc::impls::<impl enc::Encode for &'a T>::encode":{"E":["enc::Encoder","core::marker::Sized"],"T":["enc::Encode"]},"std::collections::HashMap":{"K":["core::cmp::Eq","de::BorrowDecode","de::Decode","core::marker::Sized","enc::Encode","core::hash::Hash"],"S":["core::default::Default","core::marker::Sized","core::hash::BuildHasher"],"V":["de::BorrowDecode","enc::Encode","core::marker::Sized","de::Decode"]},"std::collections::HashSet":{"S":["core::hash::BuildHasher","core::marker::Sized","core::default::Default"],"T":["de::BorrowDecode","core::cmp::Eq","de::Decode","core::marker::Sized","core::hash::Hash","enc::Encode"]}}
candidates:{"<T as alloc::borrow::ToOwned>":{},"alloc::borrow::Cow":{"B":["std::path::Path","core::ffi::CStr","<T as alloc::borrow::ToOwned>","std::ffi::OsStr"]},"alloc::boxed::Box":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeMap":{"A":["alloc::alloc::Global"]},"alloc::collections::BTreeSet":{"A":["alloc::alloc::Global"]},"alloc::collections::BinaryHeap":{},"alloc::collections::VecDeque":{"A":["alloc::alloc::Global"]},"alloc::vec::Vec":{"A":["alloc::alloc::Global"]},"core::ops::Bound":{},"core::ops::Range":{},"core::ops::RangeInclusive":{},"core::option::Option":{},"core::result::Result":{},"enc::impls::<impl enc::Encode for &'a T>":{},"enc::impls::<impl enc::Encode for &'a T>::encode":{"T":["alloc::collections::BinaryHeap","alloc::collections::BTreeMap","core::sync::atomic::AtomicU8","core::ops::Bound","core::ops::RangeInclusive","core::sync::atomic::AtomicUsize","std::path::PathBuf","alloc::collections::VecDeque","std::sync::RwLock","std::net::SocketAddrV6","std::net::SocketAddrV4","core::num::NonZeroU16","alloc::ffi::CString","core::num::NonZeroI16","core::sync::atomic::AtomicBool","alloc::string::String","core::result::Result","alloc::sync::Arc","alloc::boxed::Box","core::num::NonZeroI128","std::net::Ipv6Addr","alloc::rc::Rc","core::ops::Range","std::net::Ipv4Addr","core::sync::atomic::AtomicU32","core::option::Option","core::sync::atomic::AtomicI32","alloc::borrow::Cow","core::sync::atomic::AtomicI8","alloc::collections::BTreeSet","core::sync::atomic::AtomicIsize","core::num::NonZeroIsize","std::collections::HashMap","enc::impls::<impl enc::Encode for &'a T>","core::num::NonZeroU32","core::num::NonZeroU64","core::num::NonZeroI32","std::collections::HashSet","core::cell::Cell","core::time::Duration","alloc::vec::Vec","core::num::NonZeroU8","std::sync::Mutex","std::time::SystemTime","core::num::NonZeroUsize","core::num::NonZeroI64","core::num::NonZeroI8","std::net::SocketAddr","core::sync::atomic::AtomicI16","core::marker::PhantomData","core::num::NonZeroU128","core::cell::RefCell","core::sync::atomic::AtomicU16","std::net::IpAddr","core::sync::atomic::AtomicU64","core::sync::atomic::AtomicI64"]},"std::collections::HashMap":{"S":["std::collections::hash_map::RandomState"]},"std::collections::HashSet":{"S":["std::collections::hash_map::RandomState"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // E
+p0.encode(p1);
+enc::impls::<impl enc::Encode for &'a T>::encode(p0, p1);
+crate::enc::impls::<impl enc::Encode for &'a T>::encode(p0, p1);
+<&'a T>::encode(p0, p1);
-----------------
src/enc/write.rs <&mut T as enc::write::Writer>::write
deps:{"<&mut T as enc::write::Writer>::write":{"T":["core::marker::Sized","enc::write::Writer"]}}
candidates:{"<&mut T as enc::write::Writer>::write":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // T
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.write(p1);
+<&mut T as enc::write::Writer>::write(p0, p1);
+crate::<&mut T as enc::write::Writer>::write(p0, p1);
+<&mut T>::write(p0, p1);
-----------------
src/enc/write.rs enc::write::SliceWriter::<'storage>::new
'storage
deps:{}
candidates:{}
let mut p0 = &mut [0u8].as_mut_slice(); // None+[u8]
+enc::write::SliceWriter::<'storage>::new(p0);
+crate::enc::write::SliceWriter::<'storage>::new(p0);
+<enc::write::SliceWriter<'storage>>::new(p0);
-----------------
src/enc/write.rs enc::write::SliceWriter::<'storage>::bytes_written
'storage
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // enc::write::SliceWriter<'storage>
+p0.bytes_written();
+enc::write::SliceWriter::<'storage>::bytes_written(p0);
+crate::enc::write::SliceWriter::<'storage>::bytes_written(p0);
+<enc::write::SliceWriter<'storage>>::bytes_written(p0);
-----------------
src/enc/write.rs <enc::write::SliceWriter<'storage> as enc::write::Writer>::write
'storage
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // enc::write::SliceWriter<'storage>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.write(p1);
+<enc::write::SliceWriter<'storage> as enc::write::Writer>::write(p0, p1);
+crate::<enc::write::SliceWriter<'storage> as enc::write::Writer>::write(p0, p1);
+<enc::write::SliceWriter<'storage>>::write(p0, p1);
-----------------
src/enc/write.rs <enc::write::SizeWriter as core::default::Default>::default
deps:{}
candidates:{}
+<enc::write::SizeWriter as core::default::Default>::default();
+crate::<enc::write::SizeWriter as core::default::Default>::default();
+<enc::write::SizeWriter>::default();
-----------------
src/enc/write.rs <enc::write::SizeWriter as enc::write::Writer>::write
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // enc::write::SizeWriter
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.write(p1);
+<enc::write::SizeWriter as enc::write::Writer>::write(p0, p1);
+crate::<enc::write::SizeWriter as enc::write::Writer>::write(p0, p1);
+<enc::write::SizeWriter>::write(p0, p1);
-----------------
src/enc/mod.rs <&'a mut T as enc::Encoder>::writer
'a
deps:{"<&'a mut T as enc::Encoder>::writer":{"T":["core::marker::Sized","enc::Encoder"]}}
candidates:{"<&'a mut T as enc::Encoder>::writer":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // T
+p0.writer();
+<&'a mut T as enc::Encoder>::writer(p0);
+crate::<&'a mut T as enc::Encoder>::writer(p0);
+<&'a mut T>::writer(p0);
-----------------
src/enc/mod.rs <&'a mut T as enc::Encoder>::config
'a
deps:{"<&'a mut T as enc::Encoder>::config":{"T":["core::marker::Sized","enc::Encoder"]}}
candidates:{"<&'a mut T as enc::Encoder>::config":{}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
+p0.config();
+<&'a mut T as enc::Encoder>::config(p0);
+crate::<&'a mut T as enc::Encoder>::config(p0);
+<&'a mut T>::config(p0);
-----------------
src/error.rs <error::EncodeError as core::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::EncodeError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // core::fmt::Formatter<'_>
+p0.fmt(p1);
+<error::EncodeError as core::fmt::Debug>::fmt(p0, p1);
+crate::<error::EncodeError as core::fmt::Debug>::fmt(p0, p1);
+<error::EncodeError>::fmt(p0, p1);
-----------------
src/error.rs <error::EncodeError as core::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::EncodeError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // core::fmt::Formatter<'_>
+p0.fmt(p1);
+<error::EncodeError as core::fmt::Display>::fmt(p0, p1);
+crate::<error::EncodeError as core::fmt::Display>::fmt(p0, p1);
+<error::EncodeError>::fmt(p0, p1);
-----------------
src/error.rs <error::DecodeError as core::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::DecodeError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // core::fmt::Formatter<'_>
+p0.fmt(p1);
+<error::DecodeError as core::fmt::Debug>::fmt(p0, p1);
+crate::<error::DecodeError as core::fmt::Debug>::fmt(p0, p1);
+<error::DecodeError>::fmt(p0, p1);
-----------------
src/error.rs <error::DecodeError as core::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::DecodeError
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // core::fmt::Formatter<'_>
+p0.fmt(p1);
+<error::DecodeError as core::fmt::Display>::fmt(p0, p1);
+crate::<error::DecodeError as core::fmt::Display>::fmt(p0, p1);
+<error::DecodeError>::fmt(p0, p1);
-----------------
src/error.rs error::DecodeError::change_integer_type_to_signed
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::DecodeError
+p0.change_integer_type_to_signed();
+error::DecodeError::change_integer_type_to_signed(p0);
+crate::error::DecodeError::change_integer_type_to_signed(p0);
+<error::DecodeError>::change_integer_type_to_signed(p0);
-----------------
src/error.rs <error::AllowedEnumVariants as core::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::AllowedEnumVariants
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // core::fmt::Formatter<'_>
+p0.fmt(p1);
+<error::AllowedEnumVariants as core::fmt::Debug>::fmt(p0, p1);
+crate::<error::AllowedEnumVariants as core::fmt::Debug>::fmt(p0, p1);
+<error::AllowedEnumVariants>::fmt(p0, p1);
-----------------
src/error.rs <error::AllowedEnumVariants as core::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::AllowedEnumVariants
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::AllowedEnumVariants
+p0.eq(p1);
+<error::AllowedEnumVariants as core::cmp::PartialEq>::eq(p0, p1);
+crate::<error::AllowedEnumVariants as core::cmp::PartialEq>::eq(p0, p1);
+<error::AllowedEnumVariants>::eq(p0, p1);
-----------------
src/error.rs <error::AllowedEnumVariants as core::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::AllowedEnumVariants
+p0.assert_receiver_is_total_eq();
+<error::AllowedEnumVariants as core::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::AllowedEnumVariants as core::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::AllowedEnumVariants>::assert_receiver_is_total_eq(p0);
-----------------
src/error.rs <error::IntegerType as core::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::IntegerType
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // core::fmt::Formatter<'_>
+p0.fmt(p1);
+<error::IntegerType as core::fmt::Debug>::fmt(p0, p1);
+crate::<error::IntegerType as core::fmt::Debug>::fmt(p0, p1);
+<error::IntegerType>::fmt(p0, p1);
-----------------
src/error.rs <error::IntegerType as core::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::IntegerType
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::IntegerType
+p0.eq(p1);
+<error::IntegerType as core::cmp::PartialEq>::eq(p0, p1);
+crate::<error::IntegerType as core::cmp::PartialEq>::eq(p0, p1);
+<error::IntegerType>::eq(p0, p1);
-----------------
src/error.rs <error::IntegerType as core::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::IntegerType
+p0.assert_receiver_is_total_eq();
+<error::IntegerType as core::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::IntegerType as core::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::IntegerType>::assert_receiver_is_total_eq(p0);
-----------------
src/error.rs error::IntegerType::into_signed
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::IntegerType
+p0.into_signed();
+error::IntegerType::into_signed(p0);
+crate::error::IntegerType::into_signed(p0);
+<error::IntegerType>::into_signed(p0);