{"dependencies":{"<&'a mut T as de::BorrowDecoder<'de>>::borrow_reader":[],"<&'a mut T as de::Decoder>::claim_bytes_read":["core::marker::Sized","core::result::Result"],"<&'a mut T as de::Decoder>::config":[],"<&'a mut T as de::Decoder>::reader":[],"<&'a mut T as de::Decoder>::unclaim_bytes_read":[],"<&'a mut T as enc::Encoder>::config":[],"<&'a mut T as enc::Encoder>::writer":[],"<&mut T as de::read::Reader>::consume":[],"<&mut T as de::read::Reader>::peek_read":["core::marker::Sized","core::option::Option"],"<&mut T as de::read::Reader>::read":["core::marker::Sized","core::result::Result"],"<&mut T as enc::write::Writer>::write":["core::marker::Sized","core::result::Result"],"<config::BigEndian as core::clone::Clone>::clone":["config::BigEndian"],"<config::Configuration<E, I, L> as core::clone::Clone>::clone":["config::Configuration","core::marker::PhantomData","core::marker::Sized"],"<config::Configuration<E, I, L> as core::default::Default>::default":["config::Configuration","core::marker::PhantomData","core::marker::Sized"],"<config::Fixint as core::clone::Clone>::clone":["config::Fixint"],"<config::Limit<N> as core::clone::Clone>::clone":["config::Limit"],"<config::LittleEndian as core::clone::Clone>::clone":["config::LittleEndian"],"<config::NoLimit as core::clone::Clone>::clone":["config::NoLimit"],"<config::Varint as core::clone::Clone>::clone":["config::Varint"],"<config::internal::Endian as core::cmp::Eq>::assert_receiver_is_total_eq":["config::internal::Endian"],"<config::internal::Endian as core::cmp::PartialEq>::eq":["config::internal::Endian"],"<config::internal::IntEncoding as core::cmp::Eq>::assert_receiver_is_total_eq":["config::internal::IntEncoding"],"<config::internal::IntEncoding as core::cmp::PartialEq>::eq":["config::internal::IntEncoding"],"<de::decoder::DecoderImpl<R, C> as de::BorrowDecoder<'de>>::borrow_reader":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","de::decoder::DecoderImpl"],"<de::decoder::DecoderImpl<R, C> as de::Decoder>::claim_bytes_read":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::decoder::DecoderImpl"],"<de::decoder::DecoderImpl<R, C> as de::Decoder>::config":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","de::decoder::DecoderImpl"],"<de::decoder::DecoderImpl<R, C> as de::Decoder>::reader":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","de::decoder::DecoderImpl"],"<de::decoder::DecoderImpl<R, C> as de::Decoder>::unclaim_bytes_read":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","de::decoder::DecoderImpl"],"<de::impl_core::collect_into_array::Guard<'_, T, N> as core::ops::Drop>::drop":["core::marker::Sized","core::mem::MaybeUninit","de::impl_core::collect_into_array::Guard"],"<de::read::SliceReader<'storage> as de::read::BorrowReader<'storage>>::take_bytes":["core::marker::Sized","core::result::Result","de::read::SliceReader"],"<de::read::SliceReader<'storage> as de::read::Reader>::consume":["de::read::SliceReader"],"<de::read::SliceReader<'storage> as de::read::Reader>::peek_read":["core::marker::Sized","core::option::Option","de::read::SliceReader"],"<de::read::SliceReader<'storage> as de::read::Reader>::read":["core::marker::Sized","core::result::Result","de::read::SliceReader"],"<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::config":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::writer":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"<enc::write::SizeWriter as core::default::Default>::default":["enc::write::SizeWriter"],"<enc::write::SizeWriter as enc::write::Writer>::write":["core::marker::Sized","core::result::Result","enc::write::SizeWriter"],"<enc::write::SliceWriter<'storage> as enc::write::Writer>::write":["core::marker::Sized","core::result::Result","enc::write::SliceWriter"],"<error::AllowedEnumVariants as core::cmp::Eq>::assert_receiver_is_total_eq":["error::AllowedEnumVariants"],"<error::AllowedEnumVariants as core::cmp::PartialEq>::eq":["error::AllowedEnumVariants"],"<error::AllowedEnumVariants as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","error::AllowedEnumVariants"],"<error::DecodeError as core::fmt::Debug>::fmt":["alloc::string::String","core::fmt::Formatter","core::marker::Sized","core::result::Result","core::str::Utf8Error","core::time::Duration","error::AllowedEnumVariants","error::DecodeError","error::IntegerType","std::io::Error"],"<error::DecodeError as core::fmt::Display>::fmt":["alloc::string::String","core::fmt::Formatter","core::marker::Sized","core::result::Result","core::str::Utf8Error","core::time::Duration","error::AllowedEnumVariants","error::DecodeError","error::IntegerType","std::io::Error"],"<error::EncodeError as core::fmt::Debug>::fmt":["alloc::boxed::Box","alloc::string::String","core::alloc::Allocator","core::cell::BorrowError","core::fmt::Formatter","core::marker::Sized","core::result::Result","error::EncodeError","std::io::Error","std::time::SystemTimeError"],"<error::EncodeError as core::fmt::Display>::fmt":["alloc::boxed::Box","alloc::string::String","core::alloc::Allocator","core::cell::BorrowError","core::fmt::Formatter","core::marker::Sized","core::result::Result","error::EncodeError","std::io::Error","std::time::SystemTimeError"],"<error::IntegerType as core::cmp::Eq>::assert_receiver_is_total_eq":["error::IntegerType"],"<error::IntegerType as core::cmp::PartialEq>::eq":["error::IntegerType"],"<error::IntegerType as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","error::IntegerType"],"<features::impl_alloc::VecWriter as core::default::Default>::default":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","features::impl_alloc::VecWriter"],"<features::impl_alloc::VecWriter as enc::write::Writer>::write":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","core::result::Result","features::impl_alloc::VecWriter"],"<features::impl_std::IoReader<R> as de::read::Reader>::read":["core::marker::Sized","core::result::Result","features::impl_std::IoReader"],"<features::impl_std::IoWriter<'storage, W> as enc::write::Writer>::write":["core::marker::Sized","core::result::Result","features::impl_std::IoWriter","std::io::Write"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicBool>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI16>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI32>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI64>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI8>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicIsize>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU16>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU32>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU64>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU8>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicUsize>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"atomic::<impl de::Decode for core::sync::atomic::AtomicBool>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"atomic::<impl de::Decode for core::sync::atomic::AtomicI16>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"atomic::<impl de::Decode for core::sync::atomic::AtomicI32>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"atomic::<impl de::Decode for core::sync::atomic::AtomicI64>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"atomic::<impl de::Decode for core::sync::atomic::AtomicI8>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"atomic::<impl de::Decode for core::sync::atomic::AtomicIsize>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"atomic::<impl de::Decode for core::sync::atomic::AtomicU16>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"atomic::<impl de::Decode for core::sync::atomic::AtomicU32>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"atomic::<impl de::Decode for core::sync::atomic::AtomicU64>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"atomic::<impl de::Decode for core::sync::atomic::AtomicU8>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"atomic::<impl de::Decode for core::sync::atomic::AtomicUsize>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicBool>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","core::sync::atomic::AtomicBool","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicI16>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","core::sync::atomic::AtomicI16","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicI32>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","core::sync::atomic::AtomicI32","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicI64>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","core::sync::atomic::AtomicI64","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicI8>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","core::sync::atomic::AtomicI8","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicIsize>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","core::sync::atomic::AtomicIsize","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicU16>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","core::sync::atomic::AtomicU16","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicU32>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","core::sync::atomic::AtomicU32","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicU64>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","core::sync::atomic::AtomicU64","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicU8>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","core::sync::atomic::AtomicU8","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicUsize>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","core::sync::atomic::AtomicUsize","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"borrow_decode_from_slice":["<T as config::Config>::T","alloc::borrow::Cow","config::Config","core::marker::Sized","core::result::Result","de::BorrowDecode"],"config::BigEndian":["config::BigEndian"],"config::Configuration":["config::Configuration","core::marker::PhantomData","core::marker::Sized"],"config::Configuration::<E, I, L>::with_big_endian":["config::Configuration","core::marker::PhantomData","core::marker::Sized"],"config::Configuration::<E, I, L>::with_fixed_int_encoding":["config::Configuration","core::marker::PhantomData","core::marker::Sized"],"config::Configuration::<E, I, L>::with_limit":["config::Configuration","core::marker::PhantomData","core::marker::Sized"],"config::Configuration::<E, I, L>::with_little_endian":["config::Configuration","core::marker::PhantomData","core::marker::Sized"],"config::Configuration::<E, I, L>::with_no_limit":["config::Configuration","core::marker::PhantomData","core::marker::Sized"],"config::Configuration::<E, I, L>::with_variable_int_encoding":["config::Configuration","core::marker::PhantomData","core::marker::Sized"],"config::Fixint":["config::Fixint"],"config::Limit":["config::Limit"],"config::LittleEndian":["config::LittleEndian"],"config::NoLimit":["config::NoLimit"],"config::Varint":["config::Varint"],"config::generate":["config::Configuration","core::marker::PhantomData","core::marker::Sized"],"config::internal::Endian":["config::internal::Endian"],"config::internal::IntEncoding":["config::internal::IntEncoding"],"config::legacy":["config::Configuration","core::marker::PhantomData","core::marker::Sized"],"config::standard":["config::Configuration","core::marker::PhantomData","core::marker::Sized"],"de::BorrowDecode::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::BorrowDecoder::borrow_reader":[],"de::Decode::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::Decoder::claim_bytes_read":["core::marker::Sized","core::result::Result"],"de::Decoder::claim_container_read":["core::marker::Sized","core::result::Result"],"de::Decoder::config":[],"de::Decoder::reader":[],"de::Decoder::unclaim_bytes_read":[],"de::decode_option_variant":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::decode_slice_len":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::decoder::DecoderImpl":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","de::decoder::DecoderImpl"],"de::decoder::DecoderImpl::<R, C>::new":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","de::decoder::DecoderImpl"],"de::impl_core::array_assume_init":["core::marker::Sized","core::mem::MaybeUninit"],"de::impl_core::collect_into_array":["core::iter::Iterator","core::marker::Sized","core::option::Option"],"de::impl_core::collect_into_array::Guard":["core::marker::Sized","core::mem::MaybeUninit","de::impl_core::collect_into_array::Guard"],"de::impl_core::slice_assume_init_mut":["core::marker::Sized","core::mem::MaybeUninit"],"de::impl_core::uninit_array":["core::marker::Sized","core::mem::MaybeUninit"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A,)>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impl_tuples::<impl de::Decode for (A,)>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for &'a [u8]>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for &'a str>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for ()>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for [T; N]>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for bool>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for char>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::cell::Cell<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::cell::RefCell<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::marker::PhantomData<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI128>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI16>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI32>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI64>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI8>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroIsize>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU128>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU16>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU32>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU64>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU8>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroUsize>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::ops::Bound<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::ops::Range<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::ops::RangeInclusive<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::option::Option<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::result::Result<T, U>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for core::time::Duration>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for f32>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for f64>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for i128>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for i16>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for i32>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for i64>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for i8>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for isize>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for u128>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for u16>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for u32>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for u64>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for u8>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::BorrowDecode<'de> for usize>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for ()>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for [T; N]>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for bool>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for char>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::cell::Cell<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::cell::RefCell<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::marker::PhantomData<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::num::NonZeroI128>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::num::NonZeroI16>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::num::NonZeroI32>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::num::NonZeroI64>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::num::NonZeroI8>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::num::NonZeroIsize>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::num::NonZeroU128>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::num::NonZeroU16>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::num::NonZeroU32>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::num::NonZeroU64>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::num::NonZeroU8>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::num::NonZeroUsize>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::ops::Bound<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::ops::Range<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::ops::RangeInclusive<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::option::Option<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::result::Result<T, U>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for core::time::Duration>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for f32>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for f64>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for i128>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for i16>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for i32>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for i64>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for i8>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for isize>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for u128>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for u16>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for u32>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for u64>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for u8>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::<impl de::Decode for usize>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"de::impls::utf8_char_width":[],"de::read::BorrowReader::take_bytes":["core::marker::Sized","core::result::Result"],"de::read::Reader::consume":[],"de::read::Reader::peek_read":["core::marker::Sized","core::option::Option"],"de::read::Reader::read":["core::marker::Sized","core::result::Result"],"de::read::SliceReader":["de::read::SliceReader"],"de::read::SliceReader::<'storage>::new":["de::read::SliceReader"],"decode_from_reader":["<T as config::Config>::T","alloc::borrow::Cow","config::Config","core::marker::Sized","core::result::Result","de::Decode","de::read::Reader","de::read::SliceReader"],"decode_from_slice":["<T as config::Config>::T","alloc::borrow::Cow","config::Config","core::marker::Sized","core::result::Result","de::Decode"],"enc::Encode::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::Encoder::config":[],"enc::Encoder::writer":[],"enc::encode_option_variant":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::option::Option","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::encode_slice_len":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::encoder::EncoderImpl":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::encoder::EncoderImpl::<W, C>::into_writer":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::encoder::EncoderImpl::<W, C>::new":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impl_tuples::<impl enc::Encode for (A,)>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for &'a T>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for ()>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for [T; N]>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for [T]>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for bool>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for char>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::cell::Cell<T>>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::cell::Cell","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::cell::RefCell<T>>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::cell::RefCell","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::marker::PhantomData<T>>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::num::NonZeroI128>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::num::NonZeroI128","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::num::NonZeroI16>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::num::NonZeroI16","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::num::NonZeroI32>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::num::NonZeroI32","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::num::NonZeroI64>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::num::NonZeroI64","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::num::NonZeroI8>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::num::NonZeroI8","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::num::NonZeroIsize>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::num::NonZeroIsize","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::num::NonZeroU128>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::num::NonZeroU128","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::num::NonZeroU16>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::num::NonZeroU16","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::num::NonZeroU32>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::num::NonZeroU32","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::num::NonZeroU64>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::num::NonZeroU64","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::num::NonZeroU8>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::num::NonZeroU8","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::num::NonZeroUsize>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::num::NonZeroUsize","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::ops::Bound<T>>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::ops::Bound","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::ops::Range<T>>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::ops::Range","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::ops::RangeInclusive<T>>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::ops::RangeInclusive","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::option::Option<T>>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::option::Option","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::result::Result<T, U>>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for core::time::Duration>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","core::time::Duration","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for f32>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for f64>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for i128>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for i16>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for i32>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for i64>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for i8>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for isize>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for str>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for u128>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for u16>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for u32>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for u64>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for u8>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::<impl enc::Encode for usize>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"enc::impls::encode_utf8":["core::marker::Sized","core::result::Result","enc::write::SizeWriter","enc::write::Writer"],"enc::write::SizeWriter":["enc::write::SizeWriter"],"enc::write::SliceWriter":["enc::write::SliceWriter"],"enc::write::SliceWriter::<'storage>::bytes_written":["enc::write::SliceWriter"],"enc::write::SliceWriter::<'storage>::new":["enc::write::SliceWriter"],"enc::write::Writer::write":["core::marker::Sized","core::result::Result"],"encode_into_slice":["<T as config::Config>::T","alloc::borrow::Cow","config::Config","core::marker::Sized","core::result::Result","enc::Encode"],"encode_into_writer":["<T as config::Config>::T","alloc::borrow::Cow","config::Config","core::marker::Sized","core::result::Result","enc::Encode","enc::write::SizeWriter","enc::write::Writer"],"error::AllowedEnumVariants":["error::AllowedEnumVariants"],"error::DecodeError":["alloc::string::String","core::str::Utf8Error","core::time::Duration","error::AllowedEnumVariants","error::DecodeError","error::IntegerType","std::io::Error"],"error::DecodeError::change_integer_type_to_signed":["alloc::string::String","core::str::Utf8Error","core::time::Duration","error::AllowedEnumVariants","error::DecodeError","error::IntegerType","std::io::Error"],"error::EncodeError":["alloc::boxed::Box","alloc::string::String","core::alloc::Allocator","core::cell::BorrowError","core::marker::Sized","error::EncodeError","std::io::Error","std::time::SystemTimeError"],"error::IntegerType":["error::IntegerType"],"error::IntegerType::into_signed":["error::IntegerType"],"features::impl_alloc::<impl de::BorrowDecode<'cow> for alloc::borrow::Cow<'cow, T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<[T]>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<str>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeMap<K, V>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeSet<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BinaryHeap<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::VecDeque<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<[T]>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::string::String>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<[T]>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<str>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::vec::Vec<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::borrow::Cow<'cow, T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<[T]>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<str>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::collections::BTreeMap<K, V>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::collections::BTreeSet<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::collections::BinaryHeap<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::collections::VecDeque<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::rc::Rc<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::rc::Rc<[T]>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::string::String>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<[T]>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<str>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl de::Decode for alloc::vec::Vec<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_alloc::<impl enc::Encode for alloc::borrow::Cow<'cow, T>>::encode":["<T as config::Config>::T","alloc::borrow::Cow","alloc::borrow::ToOwned","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"features::impl_alloc::<impl enc::Encode for alloc::boxed::Box<T>>::encode":["<T as config::Config>::T","alloc::boxed::Box","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::alloc::Allocator","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeMap<K, V>>::encode":["<T as config::Config>::T","alloc::collections::BTreeMap","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::alloc::Allocator","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeSet<T>>::encode":["<T as config::Config>::T","alloc::collections::BTreeSet","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::alloc::Allocator","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"features::impl_alloc::<impl enc::Encode for alloc::collections::BinaryHeap<T>>::encode":["<T as config::Config>::T","alloc::collections::BinaryHeap","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"features::impl_alloc::<impl enc::Encode for alloc::collections::VecDeque<T>>::encode":["<T as config::Config>::T","alloc::collections::VecDeque","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::alloc::Allocator","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"features::impl_alloc::<impl enc::Encode for alloc::rc::Rc<T>>::encode":["<T as config::Config>::T","alloc::rc::Rc","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"features::impl_alloc::<impl enc::Encode for alloc::string::String>::encode":["<T as config::Config>::T","alloc::string::String","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"features::impl_alloc::<impl enc::Encode for alloc::sync::Arc<T>>::encode":["<T as config::Config>::T","alloc::sync::Arc","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"features::impl_alloc::<impl enc::Encode for alloc::vec::Vec<T>>::encode":["<T as config::Config>::T","alloc::vec::Vec","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::alloc::Allocator","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"features::impl_alloc::VecWriter":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","features::impl_alloc::VecWriter"],"features::impl_alloc::VecWriter::collect":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","features::impl_alloc::VecWriter"],"features::impl_alloc::VecWriter::with_capacity":["alloc::vec::Vec","core::alloc::Allocator","core::marker::Sized","features::impl_alloc::VecWriter"],"features::impl_alloc::encode_to_vec":["<T as config::Config>::T","alloc::borrow::Cow","config::Config","core::marker::Sized","core::result::Result","enc::Encode"],"features::impl_std::<impl core::error::Error for error::DecodeError>::source":["alloc::string::String","core::marker::Sized","core::option::Option","core::str::Utf8Error","core::time::Duration","error::AllowedEnumVariants","error::DecodeError","error::IntegerType","std::io::Error"],"features::impl_std::<impl core::error::Error for error::EncodeError>::source":["alloc::boxed::Box","alloc::string::String","core::alloc::Allocator","core::cell::BorrowError","core::marker::Sized","core::option::Option","error::EncodeError","std::io::Error","std::time::SystemTimeError"],"features::impl_std::<impl de::BorrowDecode<'de> for &'de std::path::Path>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for alloc::ffi::CString>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashMap<K, V, S>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashSet<T, S>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::IpAddr>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv4Addr>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv6Addr>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddr>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV4>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV6>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for std::path::PathBuf>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for std::sync::Mutex<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for std::sync::RwLock<T>>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::BorrowDecode<'de> for std::time::SystemTime>::borrow_decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::BorrowDecoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for alloc::ffi::CString>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for std::collections::HashMap<K, V, S>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for std::collections::HashSet<T, S>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for std::net::IpAddr>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for std::net::Ipv4Addr>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for std::net::Ipv6Addr>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for std::net::SocketAddr>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for std::net::SocketAddrV4>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for std::net::SocketAddrV6>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for std::path::PathBuf>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for std::sync::Mutex<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for std::sync::RwLock<T>>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::Decode for std::time::SystemTime>::decode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","de::Decoder","de::decoder::DecoderImpl"],"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::consume":["core::marker::Sized","std::io::BufReader"],"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::peek_read":["core::marker::Sized","core::option::Option","std::io::BufReader"],"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::read":["core::marker::Sized","core::result::Result","std::io::BufReader"],"features::impl_std::<impl enc::Encode for &'a core::ffi::CStr>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::ffi::CStr","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"features::impl_std::<impl enc::Encode for &std::path::Path>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::path::Path"],"features::impl_std::<impl enc::Encode for alloc::ffi::CString>::encode":["<T as config::Config>::T","alloc::ffi::CString","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer"],"features::impl_std::<impl enc::Encode for std::collections::HashMap<K, V, S>>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::collections::HashMap"],"features::impl_std::<impl enc::Encode for std::collections::HashSet<T, S>>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::collections::HashSet"],"features::impl_std::<impl enc::Encode for std::net::IpAddr>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::net::IpAddr"],"features::impl_std::<impl enc::Encode for std::net::Ipv4Addr>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::net::Ipv4Addr"],"features::impl_std::<impl enc::Encode for std::net::Ipv6Addr>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::net::Ipv6Addr"],"features::impl_std::<impl enc::Encode for std::net::SocketAddr>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::net::SocketAddr"],"features::impl_std::<impl enc::Encode for std::net::SocketAddrV4>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::net::SocketAddrV4"],"features::impl_std::<impl enc::Encode for std::net::SocketAddrV6>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::net::SocketAddrV6"],"features::impl_std::<impl enc::Encode for std::path::PathBuf>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::path::PathBuf"],"features::impl_std::<impl enc::Encode for std::sync::Mutex<T>>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::sync::Mutex"],"features::impl_std::<impl enc::Encode for std::sync::RwLock<T>>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::sync::RwLock"],"features::impl_std::<impl enc::Encode for std::time::SystemTime>::encode":["<T as config::Config>::T","config::BigEndian","config::Config","config::Configuration","config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy","core::marker::PhantomData","core::marker::Sized","core::result::Result","enc::Encoder","enc::encoder::EncoderImpl","enc::write::SizeWriter","enc::write::Writer","std::time::SystemTime"],"features::impl_std::IoReader":["core::marker::Sized","features::impl_std::IoReader"],"features::impl_std::IoReader::<R>::new":["core::marker::Sized","features::impl_std::IoReader"],"features::impl_std::IoWriter":["core::marker::Sized","features::impl_std::IoWriter","std::io::Write"],"features::impl_std::IoWriter::<'a, W>::bytes_written":["core::marker::Sized","features::impl_std::IoWriter","std::io::Write"],"features::impl_std::IoWriter::<'a, W>::new":["core::marker::Sized","features::impl_std::IoWriter","std::io::Write"],"features::impl_std::decode_from_std_read":["<T as config::Config>::T","alloc::borrow::Cow","config::Config","core::marker::Sized","core::result::Result","de::Decode","std::io::Read"],"features::impl_std::encode_into_std_write":["<T as config::Config>::T","alloc::borrow::Cow","config::Config","core::marker::Sized","core::result::Result","enc::Encode","std::io::Write"],"varint::decode_signed::varint_decode_i128":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_signed::varint_decode_i16":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_signed::varint_decode_i32":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_signed::varint_decode_i64":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_signed::varint_decode_isize":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_unsigned::deserialize_varint_cold_u128":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_unsigned::deserialize_varint_cold_u16":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_unsigned::deserialize_varint_cold_u32":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_unsigned::deserialize_varint_cold_u64":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_unsigned::deserialize_varint_cold_usize":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_unsigned::invalid_varint_discriminant":["core::marker::Sized","core::result::Result","error::IntegerType"],"varint::decode_unsigned::varint_decode_u128":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_unsigned::varint_decode_u16":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_unsigned::varint_decode_u32":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_unsigned::varint_decode_u64":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::decode_unsigned::varint_decode_usize":["config::internal::Endian","core::marker::Sized","core::result::Result","de::read::Reader","de::read::SliceReader"],"varint::encode_signed::varint_encode_i128":["config::internal::Endian","core::marker::Sized","core::result::Result","enc::write::SizeWriter","enc::write::Writer"],"varint::encode_signed::varint_encode_i16":["config::internal::Endian","core::marker::Sized","core::result::Result","enc::write::SizeWriter","enc::write::Writer"],"varint::encode_signed::varint_encode_i32":["config::internal::Endian","core::marker::Sized","core::result::Result","enc::write::SizeWriter","enc::write::Writer"],"varint::encode_signed::varint_encode_i64":["config::internal::Endian","core::marker::Sized","core::result::Result","enc::write::SizeWriter","enc::write::Writer"],"varint::encode_signed::varint_encode_isize":["config::internal::Endian","core::marker::Sized","core::result::Result","enc::write::SizeWriter","enc::write::Writer"],"varint::encode_unsigned::varint_encode_u128":["config::internal::Endian","core::marker::Sized","core::result::Result","enc::write::SizeWriter","enc::write::Writer"],"varint::encode_unsigned::varint_encode_u16":["config::internal::Endian","core::marker::Sized","core::result::Result","enc::write::SizeWriter","enc::write::Writer"],"varint::encode_unsigned::varint_encode_u32":["config::internal::Endian","core::marker::Sized","core::result::Result","enc::write::SizeWriter","enc::write::Writer"],"varint::encode_unsigned::varint_encode_u64":["config::internal::Endian","core::marker::Sized","core::result::Result","enc::write::SizeWriter","enc::write::Writer"],"varint::encode_unsigned::varint_encode_usize":["config::internal::Endian","core::marker::Sized","core::result::Result","enc::write::SizeWriter","enc::write::Writer"]},"glob_path_import":{"atomic":"","features":"","features::derive":"features::","features::impl_alloc":"features::","features::impl_std":"features::"},"self_to_fn":{"<T as config::Config>::T":["impl<T> Config for T where\n    T: InternalEndianConfig + InternalIntEncodingConfig + InternalLimitConfig + Copy + Clone\n{\n}"],"alloc::borrow::Cow":["impl<'cow, T> BorrowDecode<'cow> for Cow<'cow, T>\nwhere\n    T: ToOwned + ?Sized,\n    &'cow T: BorrowDecode<'cow>,\n{\n    fn borrow_decode<D: BorrowDecoder<'cow>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = <&T>::borrow_decode(decoder)?;\n        Ok(Cow::Borrowed(t))\n    }\n}","impl<'cow, T> Decode for Cow<'cow, T>\nwhere\n    T: ToOwned + ?Sized,\n    <T as ToOwned>::Owned: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = <T as ToOwned>::Owned::decode(decoder)?;\n        Ok(Cow::Owned(t))\n    }\n}","impl<'cow, T> Encode for Cow<'cow, T>\nwhere\n    T: ToOwned + ?Sized,\n    for<'a> &'a T: Encode,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.as_ref().encode(encoder)\n    }\n}"],"alloc::boxed::Box":["impl Decode for Box<str> {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        String::decode(decoder).map(String::into_boxed_str)\n    }\n}","impl<'de, T> BorrowDecode<'de> for Box<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::borrow_decode(decoder)?;\n        Ok(Box::new(t))\n    }\n}","impl<'de, T> BorrowDecode<'de> for Box<[T]>\nwhere\n    T: BorrowDecode<'de> + 'de,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let vec = Vec::borrow_decode(decoder)?;\n        Ok(vec.into_boxed_slice())\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }","impl<T> Decode for Box<T>\nwhere\n    T: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::decode(decoder)?;\n        Ok(Box::new(t))\n    }\n}","impl<T> Decode for Box<[T]>\nwhere\n    T: Decode + 'static,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let vec = Vec::decode(decoder)?;\n        Ok(vec.into_boxed_slice())\n    }\n}","impl<T> Encode for Box<T>\nwhere\n    T: Encode + ?Sized,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        T::encode(self, encoder)\n    }\n}"],"alloc::collections::BTreeMap":["impl<'de, K, V> BorrowDecode<'de> for BTreeMap<K, V>\nwhere\n    K: BorrowDecode<'de> + Ord,\n    V: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<(K, V)>(len)?;\n\n        let mut map = BTreeMap::new();\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<(K, V)>());\n\n            let key = K::borrow_decode(decoder)?;\n            let value = V::borrow_decode(decoder)?;\n            map.insert(key, value);\n        }\n        Ok(map)\n    }\n}","impl<K, V> Decode for BTreeMap<K, V>\nwhere\n    K: Decode + Ord,\n    V: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<(K, V)>(len)?;\n\n        let mut map = BTreeMap::new();\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<(K, V)>());\n\n            let key = K::decode(decoder)?;\n            let value = V::decode(decoder)?;\n            map.insert(key, value);\n        }\n        Ok(map)\n    }\n}","impl<K, V> Encode for BTreeMap<K, V>\nwhere\n    K: Encode + Ord,\n    V: Encode,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        for (key, val) in self.iter() {\n            key.encode(encoder)?;\n            val.encode(encoder)?;\n        }\n        Ok(())\n    }\n}"],"alloc::collections::BTreeSet":["impl<'de, T> BorrowDecode<'de> for BTreeSet<T>\nwhere\n    T: BorrowDecode<'de> + Ord,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = BTreeSet::new();\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::borrow_decode(decoder)?;\n            map.insert(key);\n        }\n        Ok(map)\n    }\n}","impl<T> Decode for BTreeSet<T>\nwhere\n    T: Decode + Ord,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = BTreeSet::new();\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::decode(decoder)?;\n            map.insert(key);\n        }\n        Ok(map)\n    }\n}","impl<T> Encode for BTreeSet<T>\nwhere\n    T: Encode + Ord,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        for item in self.iter() {\n            item.encode(encoder)?;\n        }\n        Ok(())\n    }\n}"],"alloc::collections::BinaryHeap":["impl<'de, T> BorrowDecode<'de> for BinaryHeap<T>\nwhere\n    T: BorrowDecode<'de> + Ord,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = BinaryHeap::with_capacity(len);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::borrow_decode(decoder)?;\n            map.push(key);\n        }\n        Ok(map)\n    }\n}","impl<T> Decode for BinaryHeap<T>\nwhere\n    T: Decode + Ord,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = BinaryHeap::with_capacity(len);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::decode(decoder)?;\n            map.push(key);\n        }\n        Ok(map)\n    }\n}","impl<T> Encode for BinaryHeap<T>\nwhere\n    T: Encode + Ord,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        for val in self.iter() {\n            val.encode(encoder)?;\n        }\n        Ok(())\n    }\n}"],"alloc::collections::VecDeque":["impl<'de, T> BorrowDecode<'de> for VecDeque<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = VecDeque::with_capacity(len);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::borrow_decode(decoder)?;\n            map.push_back(key);\n        }\n        Ok(map)\n    }\n}","impl<T> Decode for VecDeque<T>\nwhere\n    T: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = VecDeque::with_capacity(len);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::decode(decoder)?;\n            map.push_back(key);\n        }\n        Ok(map)\n    }\n}","impl<T> Encode for VecDeque<T>\nwhere\n    T: Encode,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        for item in self.iter() {\n            item.encode(encoder)?;\n        }\n        Ok(())\n    }\n}"],"alloc::ffi::CString":["impl Decode for CString {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let vec = std::vec::Vec::decode(decoder)?;\n        CString::new(vec).map_err(|inner| DecodeError::CStringNulError {\n            position: inner.nul_position(),\n        })\n    }\n}","impl Encode for CString {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.as_bytes().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"alloc::rc::Rc":["impl<'de, T> BorrowDecode<'de> for Rc<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::borrow_decode(decoder)?;\n        Ok(Rc::new(t))\n    }\n}","impl<'de, T> BorrowDecode<'de> for Rc<[T]>\nwhere\n    T: BorrowDecode<'de> + 'de,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let vec = Vec::borrow_decode(decoder)?;\n        Ok(vec.into())\n    }\n}","impl<T> Decode for Rc<T>\nwhere\n    T: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::decode(decoder)?;\n        Ok(Rc::new(t))\n    }\n}","impl<T> Decode for Rc<[T]>\nwhere\n    T: Decode + 'static,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let vec = Vec::decode(decoder)?;\n        Ok(vec.into())\n    }\n}","impl<T> Encode for Rc<T>\nwhere\n    T: Encode + ?Sized,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        T::encode(self, encoder)\n    }\n}"],"alloc::string::String":["impl Decode for String {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let bytes = Vec::<u8>::decode(decoder)?;\n        String::from_utf8(bytes).map_err(|e| DecodeError::Utf8 {\n            inner: e.utf8_error(),\n        })\n    }\n}","impl Encode for String {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.as_bytes().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"alloc::sync::Arc":["impl Decode for Arc<str> {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let decoded = String::decode(decoder)?;\n        Ok(decoded.into())\n    }\n}","impl<'de, T> BorrowDecode<'de> for Arc<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::borrow_decode(decoder)?;\n        Ok(Arc::new(t))\n    }\n}","impl<'de, T> BorrowDecode<'de> for Arc<[T]>\nwhere\n    T: BorrowDecode<'de> + 'de,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let vec = Vec::borrow_decode(decoder)?;\n        Ok(vec.into())\n    }\n}","impl<'de> BorrowDecode<'de> for Arc<str> {\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let decoded = String::decode(decoder)?;\n        Ok(decoded.into())\n    }\n}","impl<T> Decode for Arc<T>\nwhere\n    T: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::decode(decoder)?;\n        Ok(Arc::new(t))\n    }\n}","impl<T> Decode for Arc<[T]>\nwhere\n    T: Decode + 'static,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let vec = Vec::decode(decoder)?;\n        Ok(vec.into())\n    }\n}","impl<T> Encode for Arc<T>\nwhere\n    T: Encode + ?Sized,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        T::encode(self, encoder)\n    }\n}"],"alloc::vec::Vec":["impl<'de, T> BorrowDecode<'de> for Vec<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut vec = Vec::with_capacity(len);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            vec.push(T::borrow_decode(decoder)?);\n        }\n        Ok(vec)\n    }\n}","impl<T> Decode for Vec<T>\nwhere\n    T: Decode + 'static,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n\n        if core::any::TypeId::of::<T>() == core::any::TypeId::of::<u8>() {\n            decoder.claim_container_read::<T>(len)?;\n            // optimize for reading u8 vecs\n            let mut vec = Vec::new();\n            vec.resize(len, 0u8);\n            decoder.reader().read(&mut vec)?;\n            // Safety: Vec<T> is Vec<u8>\n            return Ok(unsafe { core::mem::transmute(vec) });\n        }\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut vec = Vec::with_capacity(len);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            vec.push(T::decode(decoder)?);\n        }\n        Ok(vec)\n    }\n}","impl<T> Encode for Vec<T>\nwhere\n    T: Encode + 'static,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        if core::any::TypeId::of::<T>() == core::any::TypeId::of::<u8>() {\n            let slice: &[u8] = unsafe { core::mem::transmute(self.as_slice()) };\n            encoder.writer().write(slice)?;\n            return Ok(());\n        }\n        for item in self.iter() {\n            item.encode(encoder)?;\n        }\n        Ok(())\n    }\n}"],"config::BigEndian":["Clone","Copy","impl InternalEndianConfig for BigEndian {\n    const ENDIAN: Endian = Endian::Big;\n}"],"config::Configuration":["Clone","Copy","impl<E, I, L: InternalLimitConfig> InternalLimitConfig for Configuration<E, I, L> {\n        const LIMIT: Option<usize> = L::LIMIT;\n    }","impl<E, I, L> Configuration<E, I, L> {\n    /// Makes bincode encode all integer types in big endian.\n    pub const fn with_big_endian(self) -> Configuration<BigEndian, I, L> {\n        generate()\n    }\n\n    /// Makes bincode encode all integer types in little endian.\n    pub const fn with_little_endian(self) -> Configuration<LittleEndian, I, L> {\n        generate()\n    }\n\n    /// Makes bincode encode all integer types with a variable integer encoding.\n    ///\n    /// Encoding an unsigned integer v (of any type excepting u8) works as follows:\n    ///\n    /// 1. If `u < 251`, encode it as a single byte with that value.\n    /// 2. If `251 <= u < 2**16`, encode it as a literal byte 251, followed by a u16 with value `u`.\n    /// 3. If `2**16 <= u < 2**32`, encode it as a literal byte 252, followed by a u32 with value `u`.\n    /// 4. If `2**32 <= u < 2**64`, encode it as a literal byte 253, followed by a u64 with value `u`.\n    /// 5. If `2**64 <= u < 2**128`, encode it as a literal byte 254, followed by a\n    ///   u128 with value `u`.\n    ///\n    /// Then, for signed integers, we first convert to unsigned using the zigzag algorithm,\n    /// and then encode them as we do for unsigned integers generally. The reason we use this\n    /// algorithm is that it encodes those values which are close to zero in less bytes; the\n    /// obvious algorithm, where we encode the cast values, gives a very large encoding for all\n    /// negative values.\n    ///\n    /// The zigzag algorithm is defined as follows:\n    ///\n    /// ```rust\n    /// # type Signed = i32;\n    /// # type Unsigned = u32;\n    /// fn zigzag(v: Signed) -> Unsigned {\n    ///     match v {\n    ///         0 => 0,\n    ///         // To avoid the edge case of Signed::min_value()\n    ///         // !n is equal to `-n - 1`, so this is:\n    ///         // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n    ///         v if v < 0 => !(v as Unsigned) * 2 - 1,\n    ///         v if v > 0 => (v as Unsigned) * 2,\n    /// #       _ => unreachable!()\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// And works such that:\n    ///\n    /// ```rust\n    /// # let zigzag = |n: i64| -> u64 {\n    /// #     match n {\n    /// #         0 => 0,\n    /// #         v if v < 0 => !(v as u64) * 2 + 1,\n    /// #         v if v > 0 => (v as u64) * 2,\n    /// #         _ => unreachable!(),\n    /// #     }\n    /// # };\n    /// assert_eq!(zigzag(0), 0);\n    /// assert_eq!(zigzag(-1), 1);\n    /// assert_eq!(zigzag(1), 2);\n    /// assert_eq!(zigzag(-2), 3);\n    /// assert_eq!(zigzag(2), 4);\n    /// // etc\n    /// assert_eq!(zigzag(i64::min_value()), u64::max_value());\n    /// ```\n    ///\n    /// Note that u256 and the like are unsupported by this format; if and when they are added to the\n    /// language, they may be supported via the extension point given by the 255 byte.\n    pub const fn with_variable_int_encoding(self) -> Configuration<E, Varint, L> {\n        generate()\n    }\n\n    /// Fixed-size integer encoding.\n    ///\n    /// * Fixed size integers are encoded directly\n    /// * Enum discriminants are encoded as u32\n    /// * Lengths and usize are encoded as u64\n    pub const fn with_fixed_int_encoding(self) -> Configuration<E, Fixint, L> {\n        generate()\n    }\n\n    /// Sets the byte limit to `limit`.\n    pub const fn with_limit<const N: usize>(self) -> Configuration<E, I, Limit<N>> {\n        generate()\n    }\n\n    /// Clear the byte limit.\n    pub const fn with_no_limit(self) -> Configuration<E, I, NoLimit> {\n        generate()\n    }\n}","impl<E, I, L> Default for Configuration<E, I, L> {\n    fn default() -> Self {\n        generate()\n    }\n}","impl<E, I: InternalIntEncodingConfig, L> InternalIntEncodingConfig for Configuration<E, I, L> {\n        const INT_ENCODING: IntEncoding = I::INT_ENCODING;\n    }","impl<E: InternalEndianConfig, I, L> InternalEndianConfig for Configuration<E, I, L> {\n        const ENDIAN: Endian = E::ENDIAN;\n    }"],"config::Fixint":["Clone","Copy","impl InternalIntEncodingConfig for Fixint {\n    const INT_ENCODING: IntEncoding = IntEncoding::Fixed;\n}"],"config::Limit":["Clone","Copy","impl<const N: usize> InternalLimitConfig for Limit<N> {\n    const LIMIT: Option<usize> = Some(N);\n}"],"config::LittleEndian":["Clone","Copy","impl InternalEndianConfig for LittleEndian {\n    const ENDIAN: Endian = Endian::Little;\n}"],"config::NoLimit":["Clone","Copy","impl InternalLimitConfig for NoLimit {\n    const LIMIT: Option<usize> = None;\n}"],"config::Varint":["Clone","Copy","impl InternalIntEncodingConfig for Varint {\n    const INT_ENCODING: IntEncoding = IntEncoding::Variable;\n}"],"config::internal::Endian":["Eq","PartialEq"],"config::internal::IntEncoding":["Eq","PartialEq"],"core::cell::Cell":["impl<'de, T> BorrowDecode<'de> for Cell<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::borrow_decode(decoder)?;\n        Ok(Cell::new(t))\n    }\n}","impl<T> Decode for Cell<T>\nwhere\n    T: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::decode(decoder)?;\n        Ok(Cell::new(t))\n    }\n}","impl<T> Encode for Cell<T>\nwhere\n    T: Encode + Copy,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        T::encode(&self.get(), encoder)\n    }\n}"],"core::cell::RefCell":["impl<'de, T> BorrowDecode<'de> for RefCell<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::borrow_decode(decoder)?;\n        Ok(RefCell::new(t))\n    }\n}","impl<T> Decode for RefCell<T>\nwhere\n    T: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::decode(decoder)?;\n        Ok(RefCell::new(t))\n    }\n}","impl<T> Encode for RefCell<T>\nwhere\n    T: Encode + ?Sized,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        let borrow_guard = self\n            .try_borrow()\n            .map_err(|e| EncodeError::RefCellAlreadyBorrowed {\n                inner: e,\n                type_name: core::any::type_name::<RefCell<T>>(),\n            })?;\n        T::encode(&borrow_guard, encoder)\n    }\n}"],"core::marker::PhantomData":["impl<'de, T> BorrowDecode<'de> for core::marker::PhantomData<T> {\n    fn borrow_decode<D: BorrowDecoder<'de>>(_: &mut D) -> Result<Self, DecodeError> {\n        Ok(core::marker::PhantomData)\n    }\n}","impl<T> Decode for core::marker::PhantomData<T> {\n    fn decode<D: Decoder>(_: &mut D) -> Result<Self, DecodeError> {\n        Ok(core::marker::PhantomData)\n    }\n}","impl<T> Encode for PhantomData<T> {\n    fn encode<E: Encoder>(&self, _: &mut E) -> Result<(), EncodeError> {\n        Ok(())\n    }\n}"],"core::num::NonZeroI128":["impl Decode for NonZeroI128 {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        NonZeroI128::new(i128::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::I128,\n        })\n    }\n}","impl Encode for NonZeroI128 {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.get().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::num::NonZeroI16":["impl Decode for NonZeroI16 {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        NonZeroI16::new(i16::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::I16,\n        })\n    }\n}","impl Encode for NonZeroI16 {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.get().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::num::NonZeroI32":["impl Decode for NonZeroI32 {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        NonZeroI32::new(i32::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::I32,\n        })\n    }\n}","impl Encode for NonZeroI32 {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.get().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::num::NonZeroI64":["impl Decode for NonZeroI64 {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        NonZeroI64::new(i64::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::I64,\n        })\n    }\n}","impl Encode for NonZeroI64 {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.get().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::num::NonZeroI8":["impl Decode for NonZeroI8 {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        NonZeroI8::new(i8::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::I8,\n        })\n    }\n}","impl Encode for NonZeroI8 {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.get().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::num::NonZeroIsize":["impl Decode for NonZeroIsize {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        NonZeroIsize::new(isize::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::Isize,\n        })\n    }\n}","impl Encode for NonZeroIsize {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.get().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::num::NonZeroU128":["impl Decode for NonZeroU128 {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        NonZeroU128::new(u128::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::U128,\n        })\n    }\n}","impl Encode for NonZeroU128 {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.get().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::num::NonZeroU16":["impl Decode for NonZeroU16 {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        NonZeroU16::new(u16::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::U16,\n        })\n    }\n}","impl Encode for NonZeroU16 {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.get().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::num::NonZeroU32":["impl Decode for NonZeroU32 {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        NonZeroU32::new(u32::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::U32,\n        })\n    }\n}","impl Encode for NonZeroU32 {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.get().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::num::NonZeroU64":["impl Decode for NonZeroU64 {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        NonZeroU64::new(u64::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::U64,\n        })\n    }\n}","impl Encode for NonZeroU64 {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.get().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::num::NonZeroU8":["impl Decode for NonZeroU8 {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        NonZeroU8::new(u8::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::U8,\n        })\n    }\n}","impl Encode for NonZeroU8 {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.get().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::num::NonZeroUsize":["impl Decode for NonZeroUsize {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        NonZeroUsize::new(usize::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::Usize,\n        })\n    }\n}","impl Encode for NonZeroUsize {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.get().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::ops::Bound":["impl<'de, T> BorrowDecode<'de> for Bound<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        match u32::decode(decoder)? {\n            0 => Ok(Bound::Unbounded),\n            1 => Ok(Bound::Included(T::borrow_decode(decoder)?)),\n            2 => Ok(Bound::Excluded(T::borrow_decode(decoder)?)),\n            x => Err(DecodeError::UnexpectedVariant {\n                allowed: &crate::error::AllowedEnumVariants::Range { max: 2, min: 0 },\n                found: x,\n                type_name: core::any::type_name::<Bound<T>>(),\n            }),\n        }\n    }\n}","impl<T> Decode for Bound<T>\nwhere\n    T: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        match u32::decode(decoder)? {\n            0 => Ok(Bound::Unbounded),\n            1 => Ok(Bound::Included(T::decode(decoder)?)),\n            2 => Ok(Bound::Excluded(T::decode(decoder)?)),\n            x => Err(DecodeError::UnexpectedVariant {\n                allowed: &crate::error::AllowedEnumVariants::Range { max: 2, min: 0 },\n                found: x,\n                type_name: core::any::type_name::<Bound<T>>(),\n            }),\n        }\n    }\n}","impl<T> Encode for Bound<T>\nwhere\n    T: Encode,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        match self {\n            Self::Unbounded => {\n                0u32.encode(encoder)?;\n            }\n            Self::Included(val) => {\n                1u32.encode(encoder)?;\n                val.encode(encoder)?;\n            }\n            Self::Excluded(val) => {\n                2u32.encode(encoder)?;\n                val.encode(encoder)?;\n            }\n        }\n        Ok(())\n    }\n}"],"core::ops::Range":["impl<'de, T> BorrowDecode<'de> for Range<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let min = T::borrow_decode(decoder)?;\n        let max = T::borrow_decode(decoder)?;\n        Ok(min..max)\n    }\n}","impl<T> Decode for Range<T>\nwhere\n    T: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let min = T::decode(decoder)?;\n        let max = T::decode(decoder)?;\n        Ok(min..max)\n    }\n}","impl<T> Encode for Range<T>\nwhere\n    T: Encode,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.start.encode(encoder)?;\n        self.end.encode(encoder)?;\n        Ok(())\n    }\n}"],"core::ops::RangeInclusive":["impl<'de, T> BorrowDecode<'de> for RangeInclusive<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let min = T::borrow_decode(decoder)?;\n        let max = T::borrow_decode(decoder)?;\n        Ok(RangeInclusive::new(min, max))\n    }\n}","impl<T> Decode for RangeInclusive<T>\nwhere\n    T: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let min = T::decode(decoder)?;\n        let max = T::decode(decoder)?;\n        Ok(RangeInclusive::new(min, max))\n    }\n}","impl<T> Encode for RangeInclusive<T>\nwhere\n    T: Encode,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.start().encode(encoder)?;\n        self.end().encode(encoder)?;\n        Ok(())\n    }\n}"],"core::option::Option":["impl<'de, T> BorrowDecode<'de> for Option<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        match super::decode_option_variant(decoder, core::any::type_name::<Option<T>>())? {\n            Some(_) => {\n                let val = T::borrow_decode(decoder)?;\n                Ok(Some(val))\n            }\n            None => Ok(None),\n        }\n    }\n}","impl<T> Decode for Option<T>\nwhere\n    T: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        match super::decode_option_variant(decoder, core::any::type_name::<Option<T>>())? {\n            Some(_) => {\n                let val = T::decode(decoder)?;\n                Ok(Some(val))\n            }\n            None => Ok(None),\n        }\n    }\n}","impl<T> Encode for Option<T>\nwhere\n    T: Encode,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        super::encode_option_variant(encoder, self)?;\n        if let Some(val) = self {\n            val.encode(encoder)?;\n        }\n        Ok(())\n    }\n}"],"core::result::Result":["impl<'de, T, U> BorrowDecode<'de> for Result<T, U>\nwhere\n    T: BorrowDecode<'de>,\n    U: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let is_ok = u32::decode(decoder)?;\n        match is_ok {\n            0 => {\n                let t = T::borrow_decode(decoder)?;\n                Ok(Ok(t))\n            }\n            1 => {\n                let u = U::borrow_decode(decoder)?;\n                Ok(Err(u))\n            }\n            x => Err(DecodeError::UnexpectedVariant {\n                found: x,\n                allowed: &crate::error::AllowedEnumVariants::Range { max: 1, min: 0 },\n                type_name: core::any::type_name::<Result<T, U>>(),\n            }),\n        }\n    }\n}","impl<T, U> Decode for Result<T, U>\nwhere\n    T: Decode,\n    U: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let is_ok = u32::decode(decoder)?;\n        match is_ok {\n            0 => {\n                let t = T::decode(decoder)?;\n                Ok(Ok(t))\n            }\n            1 => {\n                let u = U::decode(decoder)?;\n                Ok(Err(u))\n            }\n            x => Err(DecodeError::UnexpectedVariant {\n                found: x,\n                allowed: &crate::error::AllowedEnumVariants::Range { max: 1, min: 0 },\n                type_name: core::any::type_name::<Result<T, U>>(),\n            }),\n        }\n    }\n}","impl<T, U> Encode for Result<T, U>\nwhere\n    T: Encode,\n    U: Encode,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        match self {\n            Ok(val) => {\n                0u32.encode(encoder)?;\n                val.encode(encoder)\n            }\n            Err(err) => {\n                1u32.encode(encoder)?;\n                err.encode(encoder)\n            }\n        }\n    }\n}"],"core::sync::atomic::AtomicBool":["impl Decode for AtomicBool {\n    fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError> {\n        Ok(AtomicBool::new(Decode::decode(decoder)?))\n    }\n}","impl Encode for AtomicBool {\n    fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError> {\n        self.load(Ordering::SeqCst).encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::sync::atomic::AtomicI16":["impl Decode for AtomicI16 {\n    fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError> {\n        Ok(AtomicI16::new(Decode::decode(decoder)?))\n    }\n}","impl Encode for AtomicI16 {\n    fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError> {\n        self.load(Ordering::SeqCst).encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::sync::atomic::AtomicI32":["impl Decode for AtomicI32 {\n    fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError> {\n        Ok(AtomicI32::new(Decode::decode(decoder)?))\n    }\n}","impl Encode for AtomicI32 {\n    fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError> {\n        self.load(Ordering::SeqCst).encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::sync::atomic::AtomicI64":["impl Decode for AtomicI64 {\n    fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError> {\n        Ok(AtomicI64::new(Decode::decode(decoder)?))\n    }\n}","impl Encode for AtomicI64 {\n    fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError> {\n        self.load(Ordering::SeqCst).encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::sync::atomic::AtomicI8":["impl Decode for AtomicI8 {\n    fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError> {\n        Ok(AtomicI8::new(Decode::decode(decoder)?))\n    }\n}","impl Encode for AtomicI8 {\n    fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError> {\n        self.load(Ordering::SeqCst).encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::sync::atomic::AtomicIsize":["impl Decode for AtomicIsize {\n    fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError> {\n        Ok(AtomicIsize::new(Decode::decode(decoder)?))\n    }\n}","impl Encode for AtomicIsize {\n    fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError> {\n        self.load(Ordering::SeqCst).encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::sync::atomic::AtomicU16":["impl Decode for AtomicU16 {\n    fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError> {\n        Ok(AtomicU16::new(Decode::decode(decoder)?))\n    }\n}","impl Encode for AtomicU16 {\n    fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError> {\n        self.load(Ordering::SeqCst).encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::sync::atomic::AtomicU32":["impl Decode for AtomicU32 {\n    fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError> {\n        Ok(AtomicU32::new(Decode::decode(decoder)?))\n    }\n}","impl Encode for AtomicU32 {\n    fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError> {\n        self.load(Ordering::SeqCst).encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::sync::atomic::AtomicU64":["impl Decode for AtomicU64 {\n    fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError> {\n        Ok(AtomicU64::new(Decode::decode(decoder)?))\n    }\n}","impl Encode for AtomicU64 {\n    fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError> {\n        self.load(Ordering::SeqCst).encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::sync::atomic::AtomicU8":["impl Decode for AtomicU8 {\n    fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError> {\n        Ok(AtomicU8::new(Decode::decode(decoder)?))\n    }\n}","impl Encode for AtomicU8 {\n    fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError> {\n        self.load(Ordering::SeqCst).encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::sync::atomic::AtomicUsize":["impl Decode for AtomicUsize {\n    fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError> {\n        Ok(AtomicUsize::new(Decode::decode(decoder)?))\n    }\n}","impl Encode for AtomicUsize {\n    fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError> {\n        self.load(Ordering::SeqCst).encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"core::time::Duration":["impl Decode for Duration {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        const NANOS_PER_SEC: u64 = 1_000_000_000;\n        let secs: u64 = Decode::decode(decoder)?;\n        let nanos: u32 = Decode::decode(decoder)?;\n        if secs.checked_add(u64::from(nanos) / NANOS_PER_SEC).is_none() {\n            return Err(DecodeError::InvalidDuration { secs, nanos });\n        }\n        Ok(Duration::new(secs, nanos))\n    }\n}","impl Encode for Duration {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.as_secs().encode(encoder)?;\n        self.subsec_nanos().encode(encoder)?;\n        Ok(())\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"de::decoder::DecoderImpl":["impl<'de, R: BorrowReader<'de>, C: Config> BorrowDecoder<'de> for DecoderImpl<R, C> {\n    type BR = R;\n\n    fn borrow_reader(&mut self) -> &mut Self::BR {\n        &mut self.reader\n    }\n}","impl<R, C: Config> Sealed for DecoderImpl<R, C> {}","impl<R: Reader, C: Config> Decoder for DecoderImpl<R, C> {\n    type R = R;\n\n    type C = C;\n\n    fn reader(&mut self) -> &mut Self::R {\n        &mut self.reader\n    }\n\n    fn config(&self) -> &Self::C {\n        &self.config\n    }\n\n    #[inline]\n    fn claim_bytes_read(&mut self, n: usize) -> Result<(), DecodeError> {\n        // C::LIMIT is a const so this check should get compiled away\n        if let Some(limit) = C::LIMIT {\n            // Make sure we don't accidentally overflow `bytes_read`\n            self.bytes_read = self\n                .bytes_read\n                .checked_add(n)\n                .ok_or(DecodeError::LimitExceeded)?;\n            if self.bytes_read > limit {\n                Err(DecodeError::LimitExceeded)\n            } else {\n                Ok(())\n            }\n        } else {\n            Ok(())\n        }\n    }\n\n    #[inline]\n    fn unclaim_bytes_read(&mut self, n: usize) {\n        // C::LIMIT is a const so this check should get compiled away\n        if C::LIMIT.is_some() {\n            // We should always be claiming more than we unclaim, so this should never underflow\n            self.bytes_read -= n;\n        }\n    }\n}","impl<R: Reader, C: Config> DecoderImpl<R, C> {\n    /// Construct a new Decoder\n    pub fn new(reader: R, config: C) -> DecoderImpl<R, C> {\n        DecoderImpl {\n            reader,\n            config,\n            bytes_read: 0,\n        }\n    }\n}"],"de::impl_core::collect_into_array::Guard":["impl<T, const N: usize> Drop for Guard<'_, T, N> {\n        fn drop(&mut self) {\n            debug_assert!(self.initialized <= N);\n\n            // SAFETY: this slice will contain only initialized objects.\n            unsafe {\n                core::ptr::drop_in_place(slice_assume_init_mut(\n                    self.array_mut.get_unchecked_mut(..self.initialized),\n                ));\n            }\n        }\n    }"],"de::read::SliceReader":["impl<'storage> BorrowReader<'storage> for SliceReader<'storage> {\n    #[inline(always)]\n    fn take_bytes(&mut self, length: usize) -> Result<&'storage [u8], DecodeError> {\n        if length > self.slice.len() {\n            return Err(DecodeError::UnexpectedEnd {\n                additional: length - self.slice.len(),\n            });\n        }\n        let (read_slice, remaining) = self.slice.split_at(length);\n        self.slice = remaining;\n        Ok(read_slice)\n    }\n}","impl<'storage> Reader for SliceReader<'storage> {\n    #[inline(always)]\n    fn read(&mut self, bytes: &mut [u8]) -> Result<(), DecodeError> {\n        if bytes.len() > self.slice.len() {\n            return Err(DecodeError::UnexpectedEnd {\n                additional: bytes.len() - self.slice.len(),\n            });\n        }\n        let (read_slice, remaining) = self.slice.split_at(bytes.len());\n        bytes.copy_from_slice(read_slice);\n        self.slice = remaining;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn peek_read(&mut self, n: usize) -> Option<&'storage [u8]> {\n        self.slice.get(..n)\n    }\n\n    #[inline]\n    fn consume(&mut self, n: usize) {\n        self.slice = self.slice.get(n..).unwrap_or_default();\n    }\n}","impl<'storage> SliceReader<'storage> {\n    /// Constructs a slice reader\n    pub fn new(bytes: &'storage [u8]) -> SliceReader<'storage> {\n        SliceReader { slice: bytes }\n    }\n}"],"enc::encoder::EncoderImpl":["impl<W: Writer, C: Config> Encoder for EncoderImpl<W, C> {\n    type W = W;\n\n    type C = C;\n\n    #[inline]\n    fn writer(&mut self) -> &mut Self::W {\n        &mut self.writer\n    }\n\n    #[inline]\n    fn config(&self) -> &Self::C {\n        &self.config\n    }\n}","impl<W: Writer, C: Config> EncoderImpl<W, C> {\n    /// Create a new Encoder\n    pub fn new(writer: W, config: C) -> EncoderImpl<W, C> {\n        EncoderImpl { writer, config }\n    }\n\n    /// Return the underlying writer\n    #[inline]\n    pub fn into_writer(self) -> W {\n        self.writer\n    }\n}","impl<W: Writer, C: Config> Sealed for EncoderImpl<W, C> {}"],"enc::write::SizeWriter":["Default","impl Writer for SizeWriter {\n    #[inline(always)]\n    fn write(&mut self, bytes: &[u8]) -> Result<(), EncodeError> {\n        self.bytes_written += bytes.len();\n\n        Ok(())\n    }\n}"],"enc::write::SliceWriter":["impl<'storage> SliceWriter<'storage> {\n    /// Create a new instance of `SliceWriter` with the given byte array.\n    pub fn new(bytes: &'storage mut [u8]) -> SliceWriter<'storage> {\n        let original = bytes.len();\n        SliceWriter {\n            slice: bytes,\n            original_length: original,\n        }\n    }\n\n    /// Return the amount of bytes written so far.\n    pub fn bytes_written(&self) -> usize {\n        self.original_length - self.slice.len()\n    }\n}","impl<'storage> Writer for SliceWriter<'storage> {\n    #[inline(always)]\n    fn write(&mut self, bytes: &[u8]) -> Result<(), EncodeError> {\n        if bytes.len() > self.slice.len() {\n            return Err(EncodeError::UnexpectedEnd);\n        }\n        let (a, b) = core::mem::take(&mut self.slice).split_at_mut(bytes.len());\n        a.copy_from_slice(bytes);\n        self.slice = b;\n\n        Ok(())\n    }\n}"],"error::AllowedEnumVariants":["Debug","Eq","PartialEq"],"error::DecodeError":["Debug","impl DecodeError {\n    /// If the current error is `InvalidIntegerType`, change the `expected` and\n    /// `found` values from `Ux` to `Ix`. This is needed to have correct error\n    /// reporting in src/varint/decode_signed.rs since this calls\n    /// src/varint/decode_unsigned.rs and needs to correct the `expected` and\n    /// `found` types.\n    pub(crate) fn change_integer_type_to_signed(self) -> DecodeError {\n        match self {\n            Self::InvalidIntegerType { expected, found } => Self::InvalidIntegerType {\n                expected: expected.into_signed(),\n                found: found.into_signed(),\n            },\n            other => other,\n        }\n    }\n}","impl core::fmt::Display for DecodeError {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        // TODO: Improve this?\n        write!(f, \"{:?}\", self)\n    }\n}","impl std::error::Error for DecodeError {\n    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n        match self {\n            Self::Utf8 { inner } => Some(inner),\n            _ => None,\n        }\n    }\n}"],"error::EncodeError":["Debug","impl core::fmt::Display for EncodeError {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        // TODO: Improve this?\n        write!(f, \"{:?}\", self)\n    }\n}","impl std::error::Error for EncodeError {\n    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n        match self {\n            Self::RefCellAlreadyBorrowed { inner, .. } => Some(inner),\n            Self::Io { inner, .. } => Some(inner),\n            Self::InvalidSystemTime { inner, .. } => Some(inner),\n            _ => None,\n        }\n    }\n}"],"error::IntegerType":["Debug","Eq","PartialEq","impl IntegerType {\n    /// Change the `Ux` value to the associated `Ix` value.\n    /// Returns the old value if `self` is already `Ix`.\n    pub(crate) fn into_signed(self) -> Self {\n        match self {\n            Self::U8 => Self::I8,\n            Self::U16 => Self::I16,\n            Self::U32 => Self::I32,\n            Self::U64 => Self::I64,\n            Self::U128 => Self::I128,\n            Self::Usize => Self::Isize,\n\n            other => other,\n        }\n    }\n}"],"features::impl_alloc::VecWriter":["Default","impl VecWriter {\n    /// Create a new vec writer with the given capacity\n    pub fn with_capacity(cap: usize) -> Self {\n        Self {\n            inner: Vec::with_capacity(cap),\n        }\n    }\n    // May not be used in all feature combinations\n    #[allow(dead_code)]\n    pub(crate) fn collect(self) -> Vec<u8> {\n        self.inner\n    }\n}","impl enc::write::Writer for VecWriter {\n    #[inline(always)]\n    fn write(&mut self, bytes: &[u8]) -> Result<(), EncodeError> {\n        self.inner.extend_from_slice(bytes);\n        Ok(())\n    }\n}"],"features::impl_std::IoReader":["impl<R> IoReader<R> {\n    pub fn new(reader: R) -> Self {\n        Self { reader }\n    }\n}","impl<R> Reader for IoReader<R>\nwhere\n    R: std::io::Read,\n{\n    #[inline(always)]\n    fn read(&mut self, bytes: &mut [u8]) -> Result<(), DecodeError> {\n        self.reader\n            .read_exact(bytes)\n            .map_err(|inner| DecodeError::Io {\n                inner,\n                additional: bytes.len(),\n            })\n    }\n}"],"features::impl_std::IoWriter":["impl<'a, W: std::io::Write> IoWriter<'a, W> {\n    pub fn new(writer: &'a mut W) -> Self {\n        Self {\n            writer,\n            bytes_written: 0,\n        }\n    }\n\n    pub fn bytes_written(&self) -> usize {\n        self.bytes_written\n    }\n}","impl<'storage, W: std::io::Write> Writer for IoWriter<'storage, W> {\n    #[inline(always)]\n    fn write(&mut self, bytes: &[u8]) -> Result<(), EncodeError> {\n        self.writer\n            .write_all(bytes)\n            .map_err(|inner| EncodeError::Io {\n                inner,\n                index: self.bytes_written,\n            })?;\n        self.bytes_written += bytes.len();\n        Ok(())\n    }\n}"],"std::collections::HashMap":["impl<'de, K, V, S> BorrowDecode<'de> for HashMap<K, V, S>\nwhere\n    K: BorrowDecode<'de> + Eq + std::hash::Hash,\n    V: BorrowDecode<'de>,\n    S: std::hash::BuildHasher + Default,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<(K, V)>(len)?;\n\n        let hash_builder: S = Default::default();\n        let mut map = HashMap::with_capacity_and_hasher(len, hash_builder);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<(K, V)>());\n\n            let k = K::borrow_decode(decoder)?;\n            let v = V::borrow_decode(decoder)?;\n            map.insert(k, v);\n        }\n        Ok(map)\n    }\n}","impl<K, V, S> Decode for HashMap<K, V, S>\nwhere\n    K: Decode + Eq + std::hash::Hash,\n    V: Decode,\n    S: std::hash::BuildHasher + Default,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<(K, V)>(len)?;\n\n        let hash_builder: S = Default::default();\n        let mut map = HashMap::with_capacity_and_hasher(len, hash_builder);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<(K, V)>());\n\n            let k = K::decode(decoder)?;\n            let v = V::decode(decoder)?;\n            map.insert(k, v);\n        }\n        Ok(map)\n    }\n}","impl<K, V, S> Encode for HashMap<K, V, S>\nwhere\n    K: Encode,\n    V: Encode,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        for (k, v) in self.iter() {\n            Encode::encode(k, encoder)?;\n            Encode::encode(v, encoder)?;\n        }\n        Ok(())\n    }\n}"],"std::collections::HashSet":["impl<'de, T, S> BorrowDecode<'de> for HashSet<T, S>\nwhere\n    T: BorrowDecode<'de> + Eq + Hash,\n    S: std::hash::BuildHasher + Default,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = HashSet::with_capacity_and_hasher(len, S::default());\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::borrow_decode(decoder)?;\n            map.insert(key);\n        }\n        Ok(map)\n    }\n}","impl<T, S> Decode for HashSet<T, S>\nwhere\n    T: Decode + Eq + Hash,\n    S: std::hash::BuildHasher + Default,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let hash_builder: S = Default::default();\n        let mut map: HashSet<T, S> = HashSet::with_capacity_and_hasher(len, hash_builder);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::decode(decoder)?;\n            map.insert(key);\n        }\n        Ok(map)\n    }\n}","impl<T, S> Encode for HashSet<T, S>\nwhere\n    T: Encode,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        for item in self.iter() {\n            item.encode(encoder)?;\n        }\n        Ok(())\n    }\n}"],"std::io::BufReader":["impl<R> Reader for std::io::BufReader<R>\nwhere\n    R: std::io::Read,\n{\n    fn read(&mut self, bytes: &mut [u8]) -> Result<(), DecodeError> {\n        self.read_exact(bytes).map_err(|inner| DecodeError::Io {\n            inner,\n            additional: bytes.len(),\n        })\n    }\n\n    #[inline]\n    fn peek_read(&mut self, n: usize) -> Option<&[u8]> {\n        self.buffer().get(..n)\n    }\n\n    #[inline]\n    fn consume(&mut self, n: usize) {\n        <Self as std::io::BufRead>::consume(self, n);\n    }\n}"],"std::net::IpAddr":["impl Decode for IpAddr {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        match u32::decode(decoder)? {\n            0 => Ok(IpAddr::V4(Ipv4Addr::decode(decoder)?)),\n            1 => Ok(IpAddr::V6(Ipv6Addr::decode(decoder)?)),\n            found => Err(DecodeError::UnexpectedVariant {\n                allowed: &crate::error::AllowedEnumVariants::Range { min: 0, max: 1 },\n                found,\n                type_name: core::any::type_name::<IpAddr>(),\n            }),\n        }\n    }\n}","impl Encode for IpAddr {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        match self {\n            IpAddr::V4(v4) => {\n                0u32.encode(encoder)?;\n                v4.encode(encoder)\n            }\n            IpAddr::V6(v6) => {\n                1u32.encode(encoder)?;\n                v6.encode(encoder)\n            }\n        }\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"std::net::Ipv4Addr":["impl Decode for Ipv4Addr {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let mut buff = [0u8; 4];\n        decoder.reader().read(&mut buff)?;\n        Ok(Self::from(buff))\n    }\n}","impl Encode for Ipv4Addr {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        encoder.writer().write(&self.octets())\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"std::net::Ipv6Addr":["impl Decode for Ipv6Addr {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let mut buff = [0u8; 16];\n        decoder.reader().read(&mut buff)?;\n        Ok(Self::from(buff))\n    }\n}","impl Encode for Ipv6Addr {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        encoder.writer().write(&self.octets())\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"std::net::SocketAddr":["impl Decode for SocketAddr {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        match u32::decode(decoder)? {\n            0 => Ok(SocketAddr::V4(SocketAddrV4::decode(decoder)?)),\n            1 => Ok(SocketAddr::V6(SocketAddrV6::decode(decoder)?)),\n            found => Err(DecodeError::UnexpectedVariant {\n                allowed: &crate::error::AllowedEnumVariants::Range { min: 0, max: 1 },\n                found,\n                type_name: core::any::type_name::<SocketAddr>(),\n            }),\n        }\n    }\n}","impl Encode for SocketAddr {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        match self {\n            SocketAddr::V4(v4) => {\n                0u32.encode(encoder)?;\n                v4.encode(encoder)\n            }\n            SocketAddr::V6(v6) => {\n                1u32.encode(encoder)?;\n                v6.encode(encoder)\n            }\n        }\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"std::net::SocketAddrV4":["impl Decode for SocketAddrV4 {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let ip = Ipv4Addr::decode(decoder)?;\n        let port = u16::decode(decoder)?;\n        Ok(Self::new(ip, port))\n    }\n}","impl Encode for SocketAddrV4 {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.ip().encode(encoder)?;\n        self.port().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"std::net::SocketAddrV6":["impl Decode for SocketAddrV6 {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let ip = Ipv6Addr::decode(decoder)?;\n        let port = u16::decode(decoder)?;\n        Ok(Self::new(ip, port, 0, 0))\n    }\n}","impl Encode for SocketAddrV6 {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.ip().encode(encoder)?;\n        self.port().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"std::path::PathBuf":["impl Decode for PathBuf {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let string = std::string::String::decode(decoder)?;\n        Ok(string.into())\n    }\n}","impl Encode for PathBuf {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        self.as_path().encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"],"std::sync::Mutex":["impl<'de, T> BorrowDecode<'de> for Mutex<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::borrow_decode(decoder)?;\n        Ok(Mutex::new(t))\n    }\n}","impl<T> Decode for Mutex<T>\nwhere\n    T: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::decode(decoder)?;\n        Ok(Mutex::new(t))\n    }\n}","impl<T> Encode for Mutex<T>\nwhere\n    T: Encode,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        let t = self.lock().map_err(|_| EncodeError::LockFailed {\n            type_name: core::any::type_name::<Mutex<T>>(),\n        })?;\n        t.encode(encoder)\n    }\n}"],"std::sync::RwLock":["impl<'de, T> BorrowDecode<'de> for RwLock<T>\nwhere\n    T: BorrowDecode<'de>,\n{\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::borrow_decode(decoder)?;\n        Ok(RwLock::new(t))\n    }\n}","impl<T> Decode for RwLock<T>\nwhere\n    T: Decode,\n{\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let t = T::decode(decoder)?;\n        Ok(RwLock::new(t))\n    }\n}","impl<T> Encode for RwLock<T>\nwhere\n    T: Encode,\n{\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        let t = self.read().map_err(|_| EncodeError::LockFailed {\n            type_name: core::any::type_name::<RwLock<T>>(),\n        })?;\n        t.encode(encoder)\n    }\n}"],"std::time::SystemTime":["impl Decode for SystemTime {\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n        let duration = Duration::decode(decoder)?;\n        match SystemTime::UNIX_EPOCH.checked_add(duration) {\n            Some(t) => Ok(t),\n            None => Err(DecodeError::InvalidSystemTime { duration }),\n        }\n    }\n}","impl Encode for SystemTime {\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n        let duration = self.duration_since(SystemTime::UNIX_EPOCH).map_err(|e| {\n            EncodeError::InvalidSystemTime {\n                inner: e,\n                time: std::boxed::Box::new(*self),\n            }\n        })?;\n        duration.encode(encoder)\n    }\n}","impl<'de> $crate::BorrowDecode<'de> for $ty {\n            fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError> {\n                $crate::Decode::decode(decoder)\n            }\n        }"]},"single_path_import":{"bincode_derive::BorrowDecode":"features::derive::BorrowDecode","bincode_derive::Decode":"features::derive::Decode","bincode_derive::Encode":"features::derive::Encode","de::BorrowDecode":"BorrowDecode","de::Decode":"Decode","de::decoder::DecoderImpl":"de::DecoderImpl","enc::Encode":"Encode","enc::encoder::EncoderImpl":"enc::EncoderImpl","varint::decode_signed::varint_decode_i128":"varint::varint_decode_i128","varint::decode_signed::varint_decode_i16":"varint::varint_decode_i16","varint::decode_signed::varint_decode_i32":"varint::varint_decode_i32","varint::decode_signed::varint_decode_i64":"varint::varint_decode_i64","varint::decode_signed::varint_decode_isize":"varint::varint_decode_isize","varint::decode_unsigned::varint_decode_u128":"varint::varint_decode_u128","varint::decode_unsigned::varint_decode_u16":"varint::varint_decode_u16","varint::decode_unsigned::varint_decode_u32":"varint::varint_decode_u32","varint::decode_unsigned::varint_decode_u64":"varint::varint_decode_u64","varint::decode_unsigned::varint_decode_usize":"varint::varint_decode_usize","varint::encode_signed::varint_encode_i128":"varint::varint_encode_i128","varint::encode_signed::varint_encode_i16":"varint::varint_encode_i16","varint::encode_signed::varint_encode_i32":"varint::varint_encode_i32","varint::encode_signed::varint_encode_i64":"varint::varint_encode_i64","varint::encode_signed::varint_encode_isize":"varint::varint_encode_isize","varint::encode_unsigned::varint_encode_u128":"varint::varint_encode_u128","varint::encode_unsigned::varint_encode_u16":"varint::varint_encode_u16","varint::encode_unsigned::varint_encode_u32":"varint::varint_encode_u32","varint::encode_unsigned::varint_encode_u64":"varint::varint_encode_u64","varint::encode_unsigned::varint_encode_usize":"varint::varint_encode_usize"},"srcs":{"<&'a mut T as de::BorrowDecoder<'de>>::borrow_reader":["fn borrow_reader(&mut self) -> &mut Self::BR{\n        T::borrow_reader(self)\n    }","Real(LocalPath(\"src/de/mod.rs\"))"],"<&'a mut T as de::Decoder>::claim_bytes_read":["#[inline]\nfn claim_bytes_read(&mut self, n: usize) -> Result<(), DecodeError>{\n        T::claim_bytes_read(self, n)\n    }","Real(LocalPath(\"src/de/mod.rs\"))"],"<&'a mut T as de::Decoder>::config":["fn config(&self) -> &Self::C{\n        T::config(self)\n    }","Real(LocalPath(\"src/de/mod.rs\"))"],"<&'a mut T as de::Decoder>::reader":["fn reader(&mut self) -> &mut Self::R{\n        T::reader(self)\n    }","Real(LocalPath(\"src/de/mod.rs\"))"],"<&'a mut T as de::Decoder>::unclaim_bytes_read":["#[inline]\nfn unclaim_bytes_read(&mut self, n: usize){\n        T::unclaim_bytes_read(self, n)\n    }","Real(LocalPath(\"src/de/mod.rs\"))"],"<&'a mut T as enc::Encoder>::config":["fn config(&self) -> &Self::C{\n        T::config(self)\n    }","Real(LocalPath(\"src/enc/mod.rs\"))"],"<&'a mut T as enc::Encoder>::writer":["fn writer(&mut self) -> &mut Self::W{\n        T::writer(self)\n    }","Real(LocalPath(\"src/enc/mod.rs\"))"],"<&mut T as de::read::Reader>::consume":["#[inline]\nfn consume(&mut self, n: usize){\n        (*self).consume(n)\n    }","Real(LocalPath(\"src/de/read.rs\"))"],"<&mut T as de::read::Reader>::peek_read":["#[inline]\nfn peek_read(&mut self, n: usize) -> Option<&[u8]>{\n        (**self).peek_read(n)\n    }","Real(LocalPath(\"src/de/read.rs\"))"],"<&mut T as de::read::Reader>::read":["#[inline]\nfn read(&mut self, bytes: &mut [u8]) -> Result<(), DecodeError>{\n        (**self).read(bytes)\n    }","Real(LocalPath(\"src/de/read.rs\"))"],"<&mut T as enc::write::Writer>::write":["#[inline]\nfn write(&mut self, bytes: &[u8]) -> Result<(), EncodeError>{\n        (**self).write(bytes)\n    }","Real(LocalPath(\"src/enc/write.rs\"))"],"<config::Configuration<E, I, L> as core::default::Default>::default":["fn default() -> Self{\n        generate()\n    }","Real(LocalPath(\"src/config.rs\"))"],"<de::decoder::DecoderImpl<R, C> as de::BorrowDecoder<'de>>::borrow_reader":["fn borrow_reader(&mut self) -> &mut Self::BR{\n        &mut self.reader\n    }","Real(LocalPath(\"src/de/decoder.rs\"))"],"<de::decoder::DecoderImpl<R, C> as de::Decoder>::claim_bytes_read":["#[inline]\nfn claim_bytes_read(&mut self, n: usize) -> Result<(), DecodeError>{\n        // C::LIMIT is a const so this check should get compiled away\n        if let Some(limit) = C::LIMIT {\n            // Make sure we don't accidentally overflow `bytes_read`\n            self.bytes_read = self\n                .bytes_read\n                .checked_add(n)\n                .ok_or(DecodeError::LimitExceeded)?;\n            if self.bytes_read > limit {\n                Err(DecodeError::LimitExceeded)\n            } else {\n                Ok(())\n            }\n        } else {\n            Ok(())\n        }\n    }","Real(LocalPath(\"src/de/decoder.rs\"))"],"<de::decoder::DecoderImpl<R, C> as de::Decoder>::config":["fn config(&self) -> &Self::C{\n        &self.config\n    }","Real(LocalPath(\"src/de/decoder.rs\"))"],"<de::decoder::DecoderImpl<R, C> as de::Decoder>::reader":["fn reader(&mut self) -> &mut Self::R{\n        &mut self.reader\n    }","Real(LocalPath(\"src/de/decoder.rs\"))"],"<de::decoder::DecoderImpl<R, C> as de::Decoder>::unclaim_bytes_read":["#[inline]\nfn unclaim_bytes_read(&mut self, n: usize){\n        // C::LIMIT is a const so this check should get compiled away\n        if C::LIMIT.is_some() {\n            // We should always be claiming more than we unclaim, so this should never underflow\n            self.bytes_read -= n;\n        }\n    }","Real(LocalPath(\"src/de/decoder.rs\"))"],"<de::impl_core::collect_into_array::Guard<'_, T, N> as core::ops::Drop>::drop":["fn drop(&mut self){\n            debug_assert!(self.initialized <= N);\n\n            // SAFETY: this slice will contain only initialized objects.\n            unsafe {\n                core::ptr::drop_in_place(slice_assume_init_mut(\n                    self.array_mut.get_unchecked_mut(..self.initialized),\n                ));\n            }\n        }","Real(LocalPath(\"src/de/impl_core.rs\"))"],"<de::read::SliceReader<'storage> as de::read::BorrowReader<'storage>>::take_bytes":["#[inline(always)]\nfn take_bytes(&mut self, length: usize) -> Result<&'storage [u8], DecodeError>{\n        if length > self.slice.len() {\n            return Err(DecodeError::UnexpectedEnd {\n                additional: length - self.slice.len(),\n            });\n        }\n        let (read_slice, remaining) = self.slice.split_at(length);\n        self.slice = remaining;\n        Ok(read_slice)\n    }","Real(LocalPath(\"src/de/read.rs\"))"],"<de::read::SliceReader<'storage> as de::read::Reader>::consume":["#[inline]\nfn consume(&mut self, n: usize){\n        self.slice = self.slice.get(n..).unwrap_or_default();\n    }","Real(LocalPath(\"src/de/read.rs\"))"],"<de::read::SliceReader<'storage> as de::read::Reader>::peek_read":["#[inline]\nfn peek_read(&mut self, n: usize) -> Option<&'storage [u8]>{\n        self.slice.get(..n)\n    }","Real(LocalPath(\"src/de/read.rs\"))"],"<de::read::SliceReader<'storage> as de::read::Reader>::read":["#[inline(always)]\nfn read(&mut self, bytes: &mut [u8]) -> Result<(), DecodeError>{\n        if bytes.len() > self.slice.len() {\n            return Err(DecodeError::UnexpectedEnd {\n                additional: bytes.len() - self.slice.len(),\n            });\n        }\n        let (read_slice, remaining) = self.slice.split_at(bytes.len());\n        bytes.copy_from_slice(read_slice);\n        self.slice = remaining;\n\n        Ok(())\n    }","Real(LocalPath(\"src/de/read.rs\"))"],"<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::config":["#[inline]\nfn config(&self) -> &Self::C{\n        &self.config\n    }","Real(LocalPath(\"src/enc/encoder.rs\"))"],"<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::writer":["#[inline]\nfn writer(&mut self) -> &mut Self::W{\n        &mut self.writer\n    }","Real(LocalPath(\"src/enc/encoder.rs\"))"],"<enc::write::SizeWriter as enc::write::Writer>::write":["#[inline(always)]\nfn write(&mut self, bytes: &[u8]) -> Result<(), EncodeError>{\n        self.bytes_written += bytes.len();\n\n        Ok(())\n    }","Real(LocalPath(\"src/enc/write.rs\"))"],"<enc::write::SliceWriter<'storage> as enc::write::Writer>::write":["#[inline(always)]\nfn write(&mut self, bytes: &[u8]) -> Result<(), EncodeError>{\n        if bytes.len() > self.slice.len() {\n            return Err(EncodeError::UnexpectedEnd);\n        }\n        let (a, b) = core::mem::take(&mut self.slice).split_at_mut(bytes.len());\n        a.copy_from_slice(bytes);\n        self.slice = b;\n\n        Ok(())\n    }","Real(LocalPath(\"src/enc/write.rs\"))"],"<error::DecodeError as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        // TODO: Improve this?\n        write!(f, \"{:?}\", self)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::EncodeError as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result{\n        // TODO: Improve this?\n        write!(f, \"{:?}\", self)\n    }","Real(LocalPath(\"src/error.rs\"))"],"<features::impl_alloc::VecWriter as enc::write::Writer>::write":["#[inline(always)]\nfn write(&mut self, bytes: &[u8]) -> Result<(), EncodeError>{\n        self.inner.extend_from_slice(bytes);\n        Ok(())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"<features::impl_std::IoReader<R> as de::read::Reader>::read":["#[inline(always)]\nfn read(&mut self, bytes: &mut [u8]) -> Result<(), DecodeError>{\n        self.reader\n            .read_exact(bytes)\n            .map_err(|inner| DecodeError::Io {\n                inner,\n                additional: bytes.len(),\n            })\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"<features::impl_std::IoWriter<'storage, W> as enc::write::Writer>::write":["#[inline(always)]\nfn write(&mut self, bytes: &[u8]) -> Result<(), EncodeError>{\n        self.writer\n            .write_all(bytes)\n            .map_err(|inner| EncodeError::Io {\n                inner,\n                index: self.bytes_written,\n            })?;\n        self.bytes_written += bytes.len();\n        Ok(())\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicBool>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI16>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI32>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI64>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI8>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicIsize>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU16>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU32>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU64>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU8>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicUsize>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"atomic::<impl de::Decode for core::sync::atomic::AtomicBool>::decode":["fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError>{\n        Ok(AtomicBool::new(Decode::decode(decoder)?))\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl de::Decode for core::sync::atomic::AtomicI16>::decode":["fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError>{\n        Ok(AtomicI16::new(Decode::decode(decoder)?))\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl de::Decode for core::sync::atomic::AtomicI32>::decode":["fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError>{\n        Ok(AtomicI32::new(Decode::decode(decoder)?))\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl de::Decode for core::sync::atomic::AtomicI64>::decode":["fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError>{\n        Ok(AtomicI64::new(Decode::decode(decoder)?))\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl de::Decode for core::sync::atomic::AtomicI8>::decode":["fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError>{\n        Ok(AtomicI8::new(Decode::decode(decoder)?))\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl de::Decode for core::sync::atomic::AtomicIsize>::decode":["fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError>{\n        Ok(AtomicIsize::new(Decode::decode(decoder)?))\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl de::Decode for core::sync::atomic::AtomicU16>::decode":["fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError>{\n        Ok(AtomicU16::new(Decode::decode(decoder)?))\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl de::Decode for core::sync::atomic::AtomicU32>::decode":["fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError>{\n        Ok(AtomicU32::new(Decode::decode(decoder)?))\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl de::Decode for core::sync::atomic::AtomicU64>::decode":["fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError>{\n        Ok(AtomicU64::new(Decode::decode(decoder)?))\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl de::Decode for core::sync::atomic::AtomicU8>::decode":["fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError>{\n        Ok(AtomicU8::new(Decode::decode(decoder)?))\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl de::Decode for core::sync::atomic::AtomicUsize>::decode":["fn decode<D: crate::de::Decoder>(decoder: &mut D) -> Result<Self, crate::error::DecodeError>{\n        Ok(AtomicUsize::new(Decode::decode(decoder)?))\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicBool>::encode":["fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError>{\n        self.load(Ordering::SeqCst).encode(encoder)\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicI16>::encode":["fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError>{\n        self.load(Ordering::SeqCst).encode(encoder)\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicI32>::encode":["fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError>{\n        self.load(Ordering::SeqCst).encode(encoder)\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicI64>::encode":["fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError>{\n        self.load(Ordering::SeqCst).encode(encoder)\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicI8>::encode":["fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError>{\n        self.load(Ordering::SeqCst).encode(encoder)\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicIsize>::encode":["fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError>{\n        self.load(Ordering::SeqCst).encode(encoder)\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicU16>::encode":["fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError>{\n        self.load(Ordering::SeqCst).encode(encoder)\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicU32>::encode":["fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError>{\n        self.load(Ordering::SeqCst).encode(encoder)\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicU64>::encode":["fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError>{\n        self.load(Ordering::SeqCst).encode(encoder)\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicU8>::encode":["fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError>{\n        self.load(Ordering::SeqCst).encode(encoder)\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicUsize>::encode":["fn encode<E: crate::enc::Encoder>(\n        &self,\n        encoder: &mut E,\n    ) -> Result<(), crate::error::EncodeError>{\n        self.load(Ordering::SeqCst).encode(encoder)\n    }","Real(LocalPath(\"src/atomic.rs\"))"],"borrow_decode_from_slice":["/// Attempt to decode a given type `D` from the given slice. Returns the decoded output and the amount of bytes read.\n///\n/// See the [config] module for more information on configurations.\n///\n/// [config]: config/index.html\npub fn borrow_decode_from_slice<'a, D: de::BorrowDecode<'a>, C: Config>(\n    src: &'a [u8],\n    config: C,\n) -> Result<(D, usize), error::DecodeError>{\n    let reader = de::read::SliceReader::new(src);\n    let mut decoder = de::DecoderImpl::<_, C>::new(reader, config);\n    let result = D::borrow_decode(&mut decoder)?;\n    let bytes_read = src.len() - decoder.reader().slice.len();\n    Ok((result, bytes_read))\n}","Real(LocalPath(\"src/lib.rs\"))"],"config::BigEndian":["/// Encodes all integer types in big endian.\npub struct BigEndian {}","Real(LocalPath(\"src/config.rs\"))"],"config::Config":["/// Indicates a type is valid for controlling the bincode configuration\npub trait Config:\n    InternalEndianConfig + InternalIntEncodingConfig + InternalLimitConfig + Copy + Clone\n{\n}","Real(LocalPath(\"src/config.rs\"))"],"config::Configuration":["/// The Configuration struct is used to build bincode configurations. The [Config] trait is implemented\n/// by this struct when a valid configuration has been constructed.\n///\n/// The following methods are mutually exclusive and will overwrite each other. The last call to one of these methods determines the behavior of the configuration:\n///\n/// - [with_little_endian] and [with_big_endian]\n/// - [with_fixed_int_encoding] and [with_variable_int_encoding]\n///\n///\n/// [with_little_endian]: #method.with_little_endian\n/// [with_big_endian]: #method.with_big_endian\n/// [with_fixed_int_encoding]: #method.with_fixed_int_encoding\n/// [with_variable_int_encoding]: #method.with_variable_int_encoding\npub struct Configuration<E = LittleEndian, I = Varint, L = NoLimit> {\n    _e: PhantomData<E>,\n    _i: PhantomData<I>,\n    _l: PhantomData<L>,\n}","Real(LocalPath(\"src/config.rs\"))"],"config::Configuration::<E, I, L>::with_big_endian":["/// Makes bincode encode all integer types in big endian.\npub const fn with_big_endian(self) -> Configuration<BigEndian, I, L>{\n        generate()\n    }","Real(LocalPath(\"src/config.rs\"))"],"config::Configuration::<E, I, L>::with_fixed_int_encoding":["/// Fixed-size integer encoding.\n///\n/// * Fixed size integers are encoded directly\n/// * Enum discriminants are encoded as u32\n/// * Lengths and usize are encoded as u64\npub const fn with_fixed_int_encoding(self) -> Configuration<E, Fixint, L>{\n        generate()\n    }","Real(LocalPath(\"src/config.rs\"))"],"config::Configuration::<E, I, L>::with_limit":["/// Sets the byte limit to `limit`.\npub const fn with_limit<const N: usize>(self) -> Configuration<E, I, Limit<N>>{\n        generate()\n    }","Real(LocalPath(\"src/config.rs\"))"],"config::Configuration::<E, I, L>::with_little_endian":["/// Makes bincode encode all integer types in little endian.\npub const fn with_little_endian(self) -> Configuration<LittleEndian, I, L>{\n        generate()\n    }","Real(LocalPath(\"src/config.rs\"))"],"config::Configuration::<E, I, L>::with_no_limit":["/// Clear the byte limit.\npub const fn with_no_limit(self) -> Configuration<E, I, NoLimit>{\n        generate()\n    }","Real(LocalPath(\"src/config.rs\"))"],"config::Configuration::<E, I, L>::with_variable_int_encoding":["/// Makes bincode encode all integer types with a variable integer encoding.\n///\n/// Encoding an unsigned integer v (of any type excepting u8) works as follows:\n///\n/// 1. If `u < 251`, encode it as a single byte with that value.\n/// 2. If `251 <= u < 2**16`, encode it as a literal byte 251, followed by a u16 with value `u`.\n/// 3. If `2**16 <= u < 2**32`, encode it as a literal byte 252, followed by a u32 with value `u`.\n/// 4. If `2**32 <= u < 2**64`, encode it as a literal byte 253, followed by a u64 with value `u`.\n/// 5. If `2**64 <= u < 2**128`, encode it as a literal byte 254, followed by a\n///   u128 with value `u`.\n///\n/// Then, for signed integers, we first convert to unsigned using the zigzag algorithm,\n/// and then encode them as we do for unsigned integers generally. The reason we use this\n/// algorithm is that it encodes those values which are close to zero in less bytes; the\n/// obvious algorithm, where we encode the cast values, gives a very large encoding for all\n/// negative values.\n///\n/// The zigzag algorithm is defined as follows:\n///\n/// ```rust\n/// # type Signed = i32;\n/// # type Unsigned = u32;\n/// fn zigzag(v: Signed) -> Unsigned {\n///     match v {\n///         0 => 0,\n///         // To avoid the edge case of Signed::min_value()\n///         // !n is equal to `-n - 1`, so this is:\n///         // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n///         v if v < 0 => !(v as Unsigned) * 2 - 1,\n///         v if v > 0 => (v as Unsigned) * 2,\n/// #       _ => unreachable!()\n///     }\n/// }\n/// ```\n///\n/// And works such that:\n///\n/// ```rust\n/// # let zigzag = |n: i64| -> u64 {\n/// #     match n {\n/// #         0 => 0,\n/// #         v if v < 0 => !(v as u64) * 2 + 1,\n/// #         v if v > 0 => (v as u64) * 2,\n/// #         _ => unreachable!(),\n/// #     }\n/// # };\n/// assert_eq!(zigzag(0), 0);\n/// assert_eq!(zigzag(-1), 1);\n/// assert_eq!(zigzag(1), 2);\n/// assert_eq!(zigzag(-2), 3);\n/// assert_eq!(zigzag(2), 4);\n/// // etc\n/// assert_eq!(zigzag(i64::min_value()), u64::max_value());\n/// ```\n///\n/// Note that u256 and the like are unsupported by this format; if and when they are added to the\n/// language, they may be supported via the extension point given by the 255 byte.\npub const fn with_variable_int_encoding(self) -> Configuration<E, Varint, L>{\n        generate()\n    }","Real(LocalPath(\"src/config.rs\"))"],"config::Fixint":["/// Use fixed-size integer encoding.\npub struct Fixint {}","Real(LocalPath(\"src/config.rs\"))"],"config::Limit":["/// Sets the byte limit to N.\npub struct Limit<const N: usize> {}","Real(LocalPath(\"src/config.rs\"))"],"config::LittleEndian":["/// Encodes all integer types in little endian.\npub struct LittleEndian {}","Real(LocalPath(\"src/config.rs\"))"],"config::NoLimit":["/// Sets an unlimited byte limit.\npub struct NoLimit {}","Real(LocalPath(\"src/config.rs\"))"],"config::Varint":["/// Use variable integer encoding.\npub struct Varint {}","Real(LocalPath(\"src/config.rs\"))"],"config::generate":["const fn generate<E, I, L>() -> Configuration<E, I, L>{\n    Configuration {\n        _e: PhantomData,\n        _i: PhantomData,\n        _l: PhantomData,\n    }\n}","Real(LocalPath(\"src/config.rs\"))"],"config::internal::Endian":["pub enum Endian {\n        Little,\n        Big,\n    }","Real(LocalPath(\"src/config.rs\"))"],"config::internal::IntEncoding":["pub enum IntEncoding {\n        Fixed,\n        Variable,\n    }","Real(LocalPath(\"src/config.rs\"))"],"config::internal::InternalEndianConfig":["pub trait InternalEndianConfig {\n        const ENDIAN: Endian;\n    }","Real(LocalPath(\"src/config.rs\"))"],"config::internal::InternalIntEncodingConfig":["pub trait InternalIntEncodingConfig {\n        const INT_ENCODING: IntEncoding;\n    }","Real(LocalPath(\"src/config.rs\"))"],"config::internal::InternalLimitConfig":["pub trait InternalLimitConfig {\n        const LIMIT: Option<usize>;\n    }","Real(LocalPath(\"src/config.rs\"))"],"config::legacy":["/// Creates the \"legacy\" default config. This is the default config that was present in bincode 1.0\n/// - Little endian\n/// - Fixed int length encoding\npub const fn legacy() -> Configuration<LittleEndian, Fixint, NoLimit>{\n    generate()\n}","Real(LocalPath(\"src/config.rs\"))"],"config::standard":["/// The default config for bincode 2.0. By default this will be:\n/// - Little endian\n/// - Variable int encoding\npub const fn standard() -> Configuration{\n    generate()\n}","Real(LocalPath(\"src/config.rs\"))"],"de::BorrowDecode":["/// Trait that makes a type able to be decoded, akin to serde's `Deserialize` trait.\n///\n/// This trait should be implemented for types that contain borrowed data, like `&str` and `&[u8]`. If your type does not have borrowed data, consider implementing [Decode] instead.\n///\n/// This trait will be automatically implemented if you enable the `derive` feature and add `#[derive(bincode::Decode)]` to a type with a lifetime.\npub trait BorrowDecode<'de>: Sized {\n    /// Attempt to decode this type with the given [BorrowDecode].\n    fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>;\n}","Real(LocalPath(\"src/de/mod.rs\"))"],"de::BorrowDecoder":["/// Any source that can decode basic types. This type is most notably implemented for [Decoder].\n///\n/// This is an extension of [Decode] that can also return borrowed data.\npub trait BorrowDecoder<'de>: Decoder {\n    /// The concrete [BorrowReader] type\n    type BR: BorrowReader<'de>;\n\n    /// Rerturns a mutable reference to the borrow reader\n    fn borrow_reader(&mut self) -> &mut Self::BR;\n}","Real(LocalPath(\"src/de/mod.rs\"))"],"de::Decode":["/// Trait that makes a type able to be decoded, akin to serde's `DeserializeOwned` trait.\n///\n/// This trait should be implemented for types which do not have references to data in the reader. For types that contain e.g. `&str` and `&[u8]`, implement [BorrowDecode] instead.\n///\n/// Whenever you implement `Decode` for your type, the base trait `BorrowDecode` is automatically implemented.\n///\n/// This trait will be automatically implemented if you enable the `derive` feature and add `#[derive(bincode::Decode)]` to your type. Note that if the type contains any lifetimes, `BorrowDecode` will be implemented instead.\n///\n/// # Implementing this trait manually\n///\n/// If you want to implement this trait for your type, the easiest way is to add a `#[derive(bincode::Decode)]`, build and check your `target/generated/bincode/` folder. This should generate a `<Struct name>_Decode.rs` file.\n///\n/// For this struct:\n///\n/// ```\n/// struct Entity {\n///     pub x: f32,\n///     pub y: f32,\n/// }\n/// ```\n///\n/// It will look something like:\n///\n/// ```\n/// # struct Entity {\n/// #     pub x: f32,\n/// #     pub y: f32,\n/// # }\n/// impl bincode::Decode for Entity {\n///     fn decode<D: bincode::de::Decoder>(\n///         decoder: &mut D,\n///     ) -> core::result::Result<Self, bincode::error::DecodeError> {\n///         Ok(Self {\n///             x: bincode::Decode::decode(decoder)?,\n///             y: bincode::Decode::decode(decoder)?,\n///         })\n///     }\n/// }\n/// impl<'de> bincode::BorrowDecode<'de> for Entity {\n///     fn borrow_decode<D: bincode::de::BorrowDecoder<'de>>(\n///         decoder: &mut D,\n///     ) -> core::result::Result<Self, bincode::error::DecodeError> {\n///         Ok(Self {\n///             x: bincode::BorrowDecode::borrow_decode(decoder)?,\n///             y: bincode::BorrowDecode::borrow_decode(decoder)?,\n///         })\n///     }\n/// }\n/// ```\n///\n/// From here you can add/remove fields, or add custom logic.\n///\n/// To get specific integer types, you can use:\n/// ```\n/// # struct Foo;\n/// # impl bincode::Decode for Foo {\n/// #     fn decode<D: bincode::de::Decoder>(\n/// #         decoder: &mut D,\n/// #     ) -> core::result::Result<Self, bincode::error::DecodeError> {\n/// let x: u8 = bincode::Decode::decode(decoder)?;\n/// let x = <u8 as bincode::Decode>::decode(decoder)?;\n/// #         Ok(Foo)\n/// #     }\n/// # }\n/// # bincode::impl_borrow_decode!(Foo);\n/// ```\npub trait Decode: Sized {\n    /// Attempt to decode this type with the given [Decode].\n    fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>;\n}","Real(LocalPath(\"src/de/mod.rs\"))"],"de::Decoder":["/// Any source that can decode basic types. This type is most notably implemented for [Decoder].\npub trait Decoder: Sealed {\n    /// The concrete [Reader] type\n    type R: Reader;\n\n    /// The concrete [Config] type\n    type C: Config;\n\n    /// Returns a mutable reference to the reader\n    fn reader(&mut self) -> &mut Self::R;\n\n    /// Returns a reference to the config\n    fn config(&self) -> &Self::C;\n\n    /// Claim that `n` bytes are going to be read from the decoder.\n    /// This can be used to validate `Configuration::Limit<N>()`.\n    fn claim_bytes_read(&mut self, n: usize) -> Result<(), DecodeError>;\n\n    /// Claim that we're going to read a container which contains `len` entries of `T`.\n    /// This will correctly handle overflowing if `len * size_of::<T>() > usize::max_value`\n    fn claim_container_read<T>(&mut self, len: usize) -> Result<(), DecodeError> {\n        if <Self::C as InternalLimitConfig>::LIMIT.is_some() {\n            match len.checked_mul(core::mem::size_of::<T>()) {\n                Some(val) => self.claim_bytes_read(val),\n                None => Err(DecodeError::LimitExceeded),\n            }\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Notify the decoder that `n` bytes are being reclaimed.\n    ///\n    /// When decoding container types, a typical implementation would claim to read `len * size_of::<T>()` bytes.\n    /// This is to ensure that bincode won't allocate several GB of memory while constructing the container.\n    ///\n    /// Because the implementation claims `len * size_of::<T>()`, but then has to decode each `T`, this would be marked\n    /// as double. This function allows us to un-claim each `T` that gets decoded.\n    ///\n    /// We cannot check if `len * size_of::<T>()` is valid without claiming it, because this would mean that if you have\n    /// a nested container (e.g. `Vec<Vec<T>>`), it does not know how much memory is already claimed, and could easily\n    /// allocate much more than the user intends.\n    /// ```\n    /// # use bincode::de::{Decode, Decoder};\n    /// # use bincode::error::DecodeError;\n    /// # struct Container<T>(Vec<T>);\n    /// # impl<T> Container<T> {\n    /// #     fn with_capacity(cap: usize) -> Self {\n    /// #         Self(Vec::with_capacity(cap))\n    /// #     }\n    /// #     \n    /// #     fn push(&mut self, t: T) {\n    /// #         self.0.push(t);\n    /// #     }\n    /// # }\n    /// impl<T: Decode> Decode for Container<T> {\n    ///     fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError> {\n    ///         let len = u64::decode(decoder)?;\n    ///         let len: usize = len.try_into().map_err(|_| DecodeError::OutsideUsizeRange(len))?;\n    ///         // Make sure we don't allocate too much memory\n    ///         decoder.claim_bytes_read(len * core::mem::size_of::<T>());\n    ///\n    ///         let mut result = Container::with_capacity(len);\n    ///         for _ in 0..len {\n    ///             // un-claim the memory\n    ///             decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n    ///             result.push(T::decode(decoder)?)\n    ///         }\n    ///         Ok(result)\n    ///     }\n    /// }\n    /// impl<'de, T: bincode::BorrowDecode<'de>> bincode::BorrowDecode<'de> for Container<T> {\n    ///     fn borrow_decode<D: bincode::de::BorrowDecoder<'de>>(\n    ///         decoder: &mut D,\n    ///     ) -> core::result::Result<Self, bincode::error::DecodeError> {\n    ///         let len = u64::borrow_decode(decoder)?;\n    ///         let len: usize = len.try_into().map_err(|_| DecodeError::OutsideUsizeRange(len))?;\n    ///         // Make sure we don't allocate too much memory\n    ///         decoder.claim_bytes_read(len * core::mem::size_of::<T>());\n    ///\n    ///         let mut result = Container::with_capacity(len);\n    ///         for _ in 0..len {\n    ///             // un-claim the memory\n    ///             decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n    ///             result.push(T::borrow_decode(decoder)?)\n    ///         }\n    ///         Ok(result)\n    ///     }\n    /// }\n    /// ```\n    fn unclaim_bytes_read(&mut self, n: usize);\n}","Real(LocalPath(\"src/de/mod.rs\"))"],"de::Decoder::claim_container_read":["/// Claim that we're going to read a container which contains `len` entries of `T`.\n/// This will correctly handle overflowing if `len * size_of::<T>() > usize::max_value`\nfn claim_container_read<T>(&mut self, len: usize) -> Result<(), DecodeError>{\n        if <Self::C as InternalLimitConfig>::LIMIT.is_some() {\n            match len.checked_mul(core::mem::size_of::<T>()) {\n                Some(val) => self.claim_bytes_read(val),\n                None => Err(DecodeError::LimitExceeded),\n            }\n        } else {\n            Ok(())\n        }\n    }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::decode_option_variant":["/// Decodes only the option variant from the decoder. Will not read any more data than that.\n#[inline]\npub(crate) fn decode_option_variant<D: Decoder>(\n    decoder: &mut D,\n    type_name: &'static str,\n) -> Result<Option<()>, DecodeError>{\n    let is_some = u8::decode(decoder)?;\n    match is_some {\n        0 => Ok(None),\n        1 => Ok(Some(())),\n        x => Err(DecodeError::UnexpectedVariant {\n            found: x as u32,\n            allowed: &crate::error::AllowedEnumVariants::Range { max: 1, min: 0 },\n            type_name,\n        }),\n    }\n}","Real(LocalPath(\"src/de/mod.rs\"))"],"de::decode_slice_len":["/// Decodes the length of any slice, container, etc from the decoder\n#[inline]\npub(crate) fn decode_slice_len<D: Decoder>(decoder: &mut D) -> Result<usize, DecodeError>{\n    let v = u64::decode(decoder)?;\n\n    v.try_into().map_err(|_| DecodeError::OutsideUsizeRange(v))\n}","Real(LocalPath(\"src/de/mod.rs\"))"],"de::decoder::DecoderImpl":["/// A Decoder that reads bytes from a given reader `R`.\n///\n/// This struct should rarely be used.\n/// In most cases, prefer any of the `decode` functions.\n///\n/// The ByteOrder that is chosen will impact the endianness that\n/// is used to read integers out of the reader.\n///\n/// ```\n/// # let slice: &[u8] = &[0, 0, 0, 0];\n/// # let some_reader = bincode::de::read::SliceReader::new(slice);\n/// use bincode::de::{DecoderImpl, Decode};\n/// let mut decoder = DecoderImpl::new(some_reader, bincode::config::standard());\n/// // this u32 can be any Decode\n/// let value = u32::decode(&mut decoder).unwrap();\n/// ```\npub struct DecoderImpl<R, C: Config> {\n    reader: R,\n    config: C,\n    bytes_read: usize,\n}","Real(LocalPath(\"src/de/decoder.rs\"))"],"de::decoder::DecoderImpl::<R, C>::new":["/// Construct a new Decoder\npub fn new(reader: R, config: C) -> DecoderImpl<R, C>{\n        DecoderImpl {\n            reader,\n            config,\n            bytes_read: 0,\n        }\n    }","Real(LocalPath(\"src/de/decoder.rs\"))"],"de::impl_core::array_assume_init":["/// Extracts the values from an array of `MaybeUninit` containers.\n///\n/// # Safety\n///\n/// It is up to the caller to guarantee that all elements of the array are\n/// in an initialized state.\n///\n/// # Examples\n///\n/// ```ignore\n/// #![feature(maybe_uninit_uninit_array)]\n/// #![feature(maybe_uninit_array_assume_init)]\n/// use std::mem::MaybeUninit;\n///\n/// let mut array: [MaybeUninit<i32>; 3] = MaybeUninit::uninit_array();\n/// array[0].write(0);\n/// array[1].write(1);\n/// array[2].write(2);\n///\n/// // SAFETY: Now safe as we initialised all elements\n/// let array = unsafe {\n///     MaybeUninit::array_assume_init(array)\n/// };\n///\n/// assert_eq!(array, [0, 1, 2]);\n/// ```\n#[inline(always)]\npub unsafe fn array_assume_init<T, const N: usize>(array: [MaybeUninit<T>; N]) -> [T; N]{\n    // SAFETY:\n    // * The caller guarantees that all elements of the array are initialized\n    // * `MaybeUninit<T>` and T are guaranteed to have the same layout\n    // * `MaybeUninit` does not drop, so there are no double-frees\n    // And thus the conversion is safe\n    unsafe {\n        // intrinsics::assert_inhabited::<[T; N]>();\n        (&array as *const _ as *const [T; N]).read()\n    }\n}","Real(LocalPath(\"src/de/impl_core.rs\"))"],"de::impl_core::collect_into_array":["/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n/// yields fewer than `N` items, `None` is returned and all already yielded\n/// items are dropped.\n///\n/// Since the iterator is passed as a mutable reference and this function calls\n/// `next` at most `N` times, the iterator can still be used afterwards to\n/// retrieve the remaining items.\n///\n/// If `iter.next()` panicks, all items already yielded by the iterator are\n/// dropped.\n#[allow(clippy::while_let_on_iterator)]\npub fn collect_into_array<E, I, T, const N: usize>(iter: &mut I) -> Option<Result<[T; N], E>>\nwhere\n    I: Iterator<Item = Result<T, E>>,{\n    if N == 0 {\n        // SAFETY: An empty array is always inhabited and has no validity invariants.\n        return unsafe { Some(Ok(mem::zeroed())) };\n    }\n\n    struct Guard<'a, T, const N: usize> {\n        array_mut: &'a mut [MaybeUninit<T>; N],\n        initialized: usize,\n    }\n\n    impl<T, const N: usize> Drop for Guard<'_, T, N> {\n        fn drop(&mut self) {\n            debug_assert!(self.initialized <= N);\n\n            // SAFETY: this slice will contain only initialized objects.\n            unsafe {\n                core::ptr::drop_in_place(slice_assume_init_mut(\n                    self.array_mut.get_unchecked_mut(..self.initialized),\n                ));\n            }\n        }\n    }\n\n    let mut array = uninit_array::<T, N>();\n    let mut guard = Guard {\n        array_mut: &mut array,\n        initialized: 0,\n    };\n\n    while let Some(item_rslt) = iter.next() {\n        let item = match item_rslt {\n            Err(err) => {\n                return Some(Err(err));\n            }\n            Ok(elem) => elem,\n        };\n\n        // SAFETY: `guard.initialized` starts at 0, is increased by one in the\n        // loop and the loop is aborted once it reaches N (which is\n        // `array.len()`).\n        unsafe {\n            guard\n                .array_mut\n                .get_unchecked_mut(guard.initialized)\n                .write(item);\n        }\n        guard.initialized += 1;\n\n        // Check if the whole array was initialized.\n        if guard.initialized == N {\n            mem::forget(guard);\n\n            // SAFETY: the condition above asserts that all elements are\n            // initialized.\n            let out = unsafe { array_assume_init(array) };\n            return Some(Ok(out));\n        }\n    }\n\n    // This is only reached if the iterator is exhausted before\n    // `guard.initialized` reaches `N`. Also note that `guard` is dropped here,\n    // dropping all already initialized elements.\n    None\n}","Real(LocalPath(\"src/de/impl_core.rs\"))"],"de::impl_core::collect_into_array::Guard":["struct Guard<'a, T, const N: usize> {\n        array_mut: &'a mut [MaybeUninit<T>; N],\n        initialized: usize,\n    }","Real(LocalPath(\"src/de/impl_core.rs\"))"],"de::impl_core::slice_assume_init_mut":["/// Assuming all the elements are initialized, get a mutable slice to them.\n///\n/// # Safety\n///\n/// It is up to the caller to guarantee that the `MaybeUninit<T>` elements\n/// really are in an initialized state.\n/// Calling this when the content is not yet fully initialized causes undefined behavior.\n///\n/// See [`assume_init_mut`] for more details and examples.\n///\n/// [`assume_init_mut`]: MaybeUninit::assume_init_mut\n#[inline(always)]\npub unsafe fn slice_assume_init_mut<T>(slice: &mut [MaybeUninit<T>]) -> &mut [T]{\n    // SAFETY: similar to safety notes for `slice_get_ref`, but we have a\n    // mutable reference which is also guaranteed to be valid for writes.\n    unsafe { &mut *(slice as *mut [MaybeUninit<T>] as *mut [T]) }\n}","Real(LocalPath(\"src/de/impl_core.rs\"))"],"de::impl_core::uninit_array":["/// Create a new array of `MaybeUninit<T>` items, in an uninitialized state.\n///\n/// Note: in a future Rust version this method may become unnecessary\n/// when Rust allows\n/// [inline const expressions](https://github.com/rust-lang/rust/issues/76001).\n/// The example below could then use `let mut buf = [const { MaybeUninit::<u8>::uninit() }; 32];`.\n///\n/// # Examples\n///\n/// ```ignore\n/// #![feature(maybe_uninit_uninit_array, maybe_uninit_extra, maybe_uninit_slice)]\n///\n/// use std::mem::MaybeUninit;\n///\n/// extern \"C\" {\n///     fn read_into_buffer(ptr: *mut u8, max_len: usize) -> usize;\n/// }\n///\n/// /// Returns a (possibly smaller) slice of data that was actually read\n/// fn read(buf: &mut [MaybeUninit<u8>]) -> &[u8] {\n///     unsafe {\n///         let len = read_into_buffer(buf.as_mut_ptr() as *mut u8, buf.len());\n///         MaybeUninit::slice_assume_init_ref(&buf[..len])\n///     }\n/// }\n///\n/// let mut buf: [MaybeUninit<u8>; 32] = MaybeUninit::uninit_array();\n/// let data = read(&mut buf);\n/// ```\n#[inline(always)]\nfn uninit_array<T, const LEN: usize>() -> [MaybeUninit<T>; LEN]{\n    // SAFETY: An uninitialized `[MaybeUninit<_>; LEN]` is valid.\n    unsafe { MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init() }\n}","Real(LocalPath(\"src/de/impl_core.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A,)>::borrow_decode":["fn borrow_decode<BD: BorrowDecoder<'de>>(decoder: &mut BD) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::borrow_decode(decoder)?,\n                    $($extra :: borrow_decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impl_tuples::<impl de::Decode for (A,)>::decode":["fn decode<DE: Decoder>(decoder: &mut DE) -> Result<Self, DecodeError>{\n                Ok((\n                    $first::decode(decoder)?,\n                    $($extra :: decode(decoder)?, )*\n                ))\n            }","Real(LocalPath(\"src/de/impl_tuples.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for &'a [u8]>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = super::decode_slice_len(decoder)?;\n        decoder.claim_bytes_read(len)?;\n        decoder.borrow_reader().take_bytes(len)\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for &'a str>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let slice = <&[u8]>::borrow_decode(decoder)?;\n        core::str::from_utf8(slice).map_err(|inner| DecodeError::Utf8 { inner })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for ()>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for [T; N]>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(core::mem::size_of::<[T; N]>())?;\n\n        // Optimize for `[u8; N]`\n        if TypeId::of::<u8>() == TypeId::of::<T>() {\n            let mut buf = [0u8; N];\n            decoder.reader().read(&mut buf)?;\n            let ptr = &mut buf as *mut _ as *mut [T; N];\n\n            // Safety: we know that T is a u8, so it is perfectly safe to\n            // translate an array of u8 into an array of T\n            let res = unsafe { ptr.read() };\n            Ok(res)\n        } else {\n            let result = super::impl_core::collect_into_array(&mut (0..N).map(|_| {\n                // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n                decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n                T::borrow_decode(decoder)\n            }));\n\n            // result is only None if N does not match the values of `(0..N)`, which it always should\n            // So this unwrap should never occur\n            result.unwrap()\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for bool>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for char>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::cell::Cell<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::borrow_decode(decoder)?;\n        Ok(Cell::new(t))\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::cell::RefCell<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::borrow_decode(decoder)?;\n        Ok(RefCell::new(t))\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::marker::PhantomData<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(_: &mut D) -> Result<Self, DecodeError>{\n        Ok(core::marker::PhantomData)\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI128>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI16>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI32>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI64>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI8>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroIsize>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU128>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU16>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU32>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU64>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU8>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroUsize>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::ops::Bound<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        match u32::decode(decoder)? {\n            0 => Ok(Bound::Unbounded),\n            1 => Ok(Bound::Included(T::borrow_decode(decoder)?)),\n            2 => Ok(Bound::Excluded(T::borrow_decode(decoder)?)),\n            x => Err(DecodeError::UnexpectedVariant {\n                allowed: &crate::error::AllowedEnumVariants::Range { max: 2, min: 0 },\n                found: x,\n                type_name: core::any::type_name::<Bound<T>>(),\n            }),\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::ops::Range<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let min = T::borrow_decode(decoder)?;\n        let max = T::borrow_decode(decoder)?;\n        Ok(min..max)\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::ops::RangeInclusive<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let min = T::borrow_decode(decoder)?;\n        let max = T::borrow_decode(decoder)?;\n        Ok(RangeInclusive::new(min, max))\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::option::Option<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        match super::decode_option_variant(decoder, core::any::type_name::<Option<T>>())? {\n            Some(_) => {\n                let val = T::borrow_decode(decoder)?;\n                Ok(Some(val))\n            }\n            None => Ok(None),\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::result::Result<T, U>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let is_ok = u32::decode(decoder)?;\n        match is_ok {\n            0 => {\n                let t = T::borrow_decode(decoder)?;\n                Ok(Ok(t))\n            }\n            1 => {\n                let u = U::borrow_decode(decoder)?;\n                Ok(Err(u))\n            }\n            x => Err(DecodeError::UnexpectedVariant {\n                found: x,\n                allowed: &crate::error::AllowedEnumVariants::Range { max: 1, min: 0 },\n                type_name: core::any::type_name::<Result<T, U>>(),\n            }),\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for core::time::Duration>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for f32>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for f64>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for i128>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for i16>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for i32>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for i64>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for i8>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for isize>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for u128>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for u16>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for u32>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for u64>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for u8>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::BorrowDecode<'de> for usize>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"de::impls::<impl de::Decode for ()>::decode":["fn decode<D: Decoder>(_: &mut D) -> Result<Self, DecodeError>{\n        Ok(())\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for [T; N]>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(core::mem::size_of::<[T; N]>())?;\n\n        // Optimize for `[u8; N]`\n        if TypeId::of::<u8>() == TypeId::of::<T>() {\n            let mut buf = [0u8; N];\n            decoder.reader().read(&mut buf)?;\n            let ptr = &mut buf as *mut _ as *mut [T; N];\n\n            // Safety: we know that T is a u8, so it is perfectly safe to\n            // translate an array of u8 into an array of T\n            let res = unsafe { ptr.read() };\n            Ok(res)\n        } else {\n            let result = super::impl_core::collect_into_array(&mut (0..N).map(|_| {\n                // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n                decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n                T::decode(decoder)\n            }));\n\n            // result is only None if N does not match the values of `(0..N)`, which it always should\n            // So this unwrap should never occur\n            result.unwrap()\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for bool>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        match u8::decode(decoder)? {\n            0 => Ok(false),\n            1 => Ok(true),\n            x => Err(DecodeError::InvalidBooleanValue(x)),\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for char>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let mut array = [0u8; 4];\n\n        // Look at the first byte to see how many bytes must be read\n        decoder.reader().read(&mut array[..1])?;\n\n        let width = utf8_char_width(array[0]);\n        if width == 0 {\n            return Err(DecodeError::InvalidCharEncoding(array));\n        }\n        // Normally we have to `.claim_bytes_read` before reading, however in this\n        // case the amount of bytes read from `char` can vary wildly, and it should\n        // only read up to 4 bytes too much.\n        decoder.claim_bytes_read(width)?;\n        if width == 1 {\n            return Ok(array[0] as char);\n        }\n\n        // read the remaining pain\n        decoder.reader().read(&mut array[1..width])?;\n        let res = core::str::from_utf8(&array[..width])\n            .ok()\n            .and_then(|s| s.chars().next())\n            .ok_or(DecodeError::InvalidCharEncoding(array))?;\n        Ok(res)\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::cell::Cell<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::decode(decoder)?;\n        Ok(Cell::new(t))\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::cell::RefCell<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::decode(decoder)?;\n        Ok(RefCell::new(t))\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::marker::PhantomData<T>>::decode":["fn decode<D: Decoder>(_: &mut D) -> Result<Self, DecodeError>{\n        Ok(core::marker::PhantomData)\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::num::NonZeroI128>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        NonZeroI128::new(i128::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::I128,\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::num::NonZeroI16>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        NonZeroI16::new(i16::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::I16,\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::num::NonZeroI32>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        NonZeroI32::new(i32::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::I32,\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::num::NonZeroI64>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        NonZeroI64::new(i64::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::I64,\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::num::NonZeroI8>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        NonZeroI8::new(i8::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::I8,\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::num::NonZeroIsize>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        NonZeroIsize::new(isize::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::Isize,\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::num::NonZeroU128>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        NonZeroU128::new(u128::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::U128,\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::num::NonZeroU16>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        NonZeroU16::new(u16::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::U16,\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::num::NonZeroU32>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        NonZeroU32::new(u32::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::U32,\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::num::NonZeroU64>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        NonZeroU64::new(u64::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::U64,\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::num::NonZeroU8>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        NonZeroU8::new(u8::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::U8,\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::num::NonZeroUsize>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        NonZeroUsize::new(usize::decode(decoder)?).ok_or(DecodeError::NonZeroTypeIsZero {\n            non_zero_type: IntegerType::Usize,\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::ops::Bound<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        match u32::decode(decoder)? {\n            0 => Ok(Bound::Unbounded),\n            1 => Ok(Bound::Included(T::decode(decoder)?)),\n            2 => Ok(Bound::Excluded(T::decode(decoder)?)),\n            x => Err(DecodeError::UnexpectedVariant {\n                allowed: &crate::error::AllowedEnumVariants::Range { max: 2, min: 0 },\n                found: x,\n                type_name: core::any::type_name::<Bound<T>>(),\n            }),\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::ops::Range<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let min = T::decode(decoder)?;\n        let max = T::decode(decoder)?;\n        Ok(min..max)\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::ops::RangeInclusive<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let min = T::decode(decoder)?;\n        let max = T::decode(decoder)?;\n        Ok(RangeInclusive::new(min, max))\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::option::Option<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        match super::decode_option_variant(decoder, core::any::type_name::<Option<T>>())? {\n            Some(_) => {\n                let val = T::decode(decoder)?;\n                Ok(Some(val))\n            }\n            None => Ok(None),\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::result::Result<T, U>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let is_ok = u32::decode(decoder)?;\n        match is_ok {\n            0 => {\n                let t = T::decode(decoder)?;\n                Ok(Ok(t))\n            }\n            1 => {\n                let u = U::decode(decoder)?;\n                Ok(Err(u))\n            }\n            x => Err(DecodeError::UnexpectedVariant {\n                found: x,\n                allowed: &crate::error::AllowedEnumVariants::Range { max: 1, min: 0 },\n                type_name: core::any::type_name::<Result<T, U>>(),\n            }),\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for core::time::Duration>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        const NANOS_PER_SEC: u64 = 1_000_000_000;\n        let secs: u64 = Decode::decode(decoder)?;\n        let nanos: u32 = Decode::decode(decoder)?;\n        if secs.checked_add(u64::from(nanos) / NANOS_PER_SEC).is_none() {\n            return Err(DecodeError::InvalidDuration { secs, nanos });\n        }\n        Ok(Duration::new(secs, nanos))\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for f32>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(4)?;\n        let mut bytes = [0u8; 4];\n        decoder.reader().read(&mut bytes)?;\n        Ok(match D::C::ENDIAN {\n            Endian::Little => f32::from_le_bytes(bytes),\n            Endian::Big => f32::from_be_bytes(bytes),\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for f64>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(8)?;\n        let mut bytes = [0u8; 8];\n        decoder.reader().read(&mut bytes)?;\n        Ok(match D::C::ENDIAN {\n            Endian::Little => f64::from_le_bytes(bytes),\n            Endian::Big => f64::from_be_bytes(bytes),\n        })\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for i128>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(16)?;\n        match D::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_decode_i128(decoder.reader(), D::C::ENDIAN)\n            }\n            IntEncoding::Fixed => {\n                let mut bytes = [0u8; 16];\n                decoder.reader().read(&mut bytes)?;\n                Ok(match D::C::ENDIAN {\n                    Endian::Little => i128::from_le_bytes(bytes),\n                    Endian::Big => i128::from_be_bytes(bytes),\n                })\n            }\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for i16>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(2)?;\n        match D::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_decode_i16(decoder.reader(), D::C::ENDIAN)\n            }\n            IntEncoding::Fixed => {\n                let mut bytes = [0u8; 2];\n                decoder.reader().read(&mut bytes)?;\n                Ok(match D::C::ENDIAN {\n                    Endian::Little => i16::from_le_bytes(bytes),\n                    Endian::Big => i16::from_be_bytes(bytes),\n                })\n            }\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for i32>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(4)?;\n        match D::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_decode_i32(decoder.reader(), D::C::ENDIAN)\n            }\n            IntEncoding::Fixed => {\n                let mut bytes = [0u8; 4];\n                decoder.reader().read(&mut bytes)?;\n                Ok(match D::C::ENDIAN {\n                    Endian::Little => i32::from_le_bytes(bytes),\n                    Endian::Big => i32::from_be_bytes(bytes),\n                })\n            }\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for i64>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(8)?;\n        match D::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_decode_i64(decoder.reader(), D::C::ENDIAN)\n            }\n            IntEncoding::Fixed => {\n                let mut bytes = [0u8; 8];\n                decoder.reader().read(&mut bytes)?;\n                Ok(match D::C::ENDIAN {\n                    Endian::Little => i64::from_le_bytes(bytes),\n                    Endian::Big => i64::from_be_bytes(bytes),\n                })\n            }\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for i8>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(1)?;\n        let mut bytes = [0u8; 1];\n        decoder.reader().read(&mut bytes)?;\n        Ok(bytes[0] as i8)\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for isize>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(8)?;\n        match D::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_decode_isize(decoder.reader(), D::C::ENDIAN)\n            }\n            IntEncoding::Fixed => {\n                let mut bytes = [0u8; 8];\n                decoder.reader().read(&mut bytes)?;\n                Ok(match D::C::ENDIAN {\n                    Endian::Little => i64::from_le_bytes(bytes),\n                    Endian::Big => i64::from_be_bytes(bytes),\n                } as isize)\n            }\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for u128>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(16)?;\n        match D::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_decode_u128(decoder.reader(), D::C::ENDIAN)\n            }\n            IntEncoding::Fixed => {\n                let mut bytes = [0u8; 16];\n                decoder.reader().read(&mut bytes)?;\n                Ok(match D::C::ENDIAN {\n                    Endian::Little => u128::from_le_bytes(bytes),\n                    Endian::Big => u128::from_be_bytes(bytes),\n                })\n            }\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for u16>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(2)?;\n        match D::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_decode_u16(decoder.reader(), D::C::ENDIAN)\n            }\n            IntEncoding::Fixed => {\n                let mut bytes = [0u8; 2];\n                decoder.reader().read(&mut bytes)?;\n                Ok(match D::C::ENDIAN {\n                    Endian::Little => u16::from_le_bytes(bytes),\n                    Endian::Big => u16::from_be_bytes(bytes),\n                })\n            }\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for u32>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(4)?;\n        match D::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_decode_u32(decoder.reader(), D::C::ENDIAN)\n            }\n            IntEncoding::Fixed => {\n                let mut bytes = [0u8; 4];\n                decoder.reader().read(&mut bytes)?;\n                Ok(match D::C::ENDIAN {\n                    Endian::Little => u32::from_le_bytes(bytes),\n                    Endian::Big => u32::from_be_bytes(bytes),\n                })\n            }\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for u64>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(8)?;\n        match D::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_decode_u64(decoder.reader(), D::C::ENDIAN)\n            }\n            IntEncoding::Fixed => {\n                let mut bytes = [0u8; 8];\n                decoder.reader().read(&mut bytes)?;\n                Ok(match D::C::ENDIAN {\n                    Endian::Little => u64::from_le_bytes(bytes),\n                    Endian::Big => u64::from_be_bytes(bytes),\n                })\n            }\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for u8>::decode":["#[inline]\nfn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(1)?;\n        if let Some(buf) = decoder.reader().peek_read(1) {\n            let byte = buf[0];\n            decoder.reader().consume(1);\n            Ok(byte)\n        } else {\n            let mut bytes = [0u8; 1];\n            decoder.reader().read(&mut bytes)?;\n            Ok(bytes[0])\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::<impl de::Decode for usize>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        decoder.claim_bytes_read(8)?;\n        match D::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_decode_usize(decoder.reader(), D::C::ENDIAN)\n            }\n            IntEncoding::Fixed => {\n                let mut bytes = [0u8; 8];\n                decoder.reader().read(&mut bytes)?;\n\n                let value = match D::C::ENDIAN {\n                    Endian::Little => u64::from_le_bytes(bytes),\n                    Endian::Big => u64::from_be_bytes(bytes),\n                };\n\n                value\n                    .try_into()\n                    .map_err(|_| DecodeError::OutsideUsizeRange(value))\n            }\n        }\n    }","Real(LocalPath(\"src/de/impls.rs\"))"],"de::impls::utf8_char_width":["const fn utf8_char_width(b: u8) -> usize{\n    UTF8_CHAR_WIDTH[b as usize] as usize\n}","Real(LocalPath(\"src/de/impls.rs\"))"],"de::read::BorrowReader":["/// A reader for borrowed data. Implementors of this must also implement the [Reader] trait. See the module documentation for more information.\npub trait BorrowReader<'storage>: Reader {\n    /// Read exactly `length` bytes and return a slice to this data. If not enough bytes could be read, an error should be returned.\n    ///\n    /// *note*: Exactly `length` bytes must be returned. If less bytes are returned, bincode may panic. If more bytes are returned, the excess bytes may be discarded.\n    fn take_bytes(&mut self, length: usize) -> Result<&'storage [u8], DecodeError>;\n}","Real(LocalPath(\"src/de/read.rs\"))"],"de::read::Reader":["/// A reader for owned data. See the module documentation for more information.\npub trait Reader {\n    /// Fill the given `bytes` argument with values. Exactly the length of the given slice must be filled, or else an error must be returned.\n    fn read(&mut self, bytes: &mut [u8]) -> Result<(), DecodeError>;\n\n    /// If this reader wraps a buffer of any kind, this function lets callers access contents of\n    /// the buffer without passing data through a buffer first.\n    #[inline]\n    fn peek_read(&mut self, _: usize) -> Option<&[u8]> {\n        None\n    }\n\n    /// If an implementation of `peek_read` is provided, an implementation of this function\n    /// must be provided so that subsequent reads or peek-reads do not return the same bytes\n    #[inline]\n    fn consume(&mut self, _: usize) {}\n}","Real(LocalPath(\"src/de/read.rs\"))"],"de::read::Reader::consume":["/// If an implementation of `peek_read` is provided, an implementation of this function\n/// must be provided so that subsequent reads or peek-reads do not return the same bytes\n#[inline]\nfn consume(&mut self, _: usize){}","Real(LocalPath(\"src/de/read.rs\"))"],"de::read::Reader::peek_read":["/// If this reader wraps a buffer of any kind, this function lets callers access contents of\n/// the buffer without passing data through a buffer first.\n#[inline]\nfn peek_read(&mut self, _: usize) -> Option<&[u8]>{\n        None\n    }","Real(LocalPath(\"src/de/read.rs\"))"],"de::read::SliceReader":["/// A reader type for `&[u8]` slices. Implements both [Reader] and [BorrowReader], and thus can be used for borrowed data.\npub struct SliceReader<'storage> {\n    pub(crate) slice: &'storage [u8],\n}","Real(LocalPath(\"src/de/read.rs\"))"],"de::read::SliceReader::<'storage>::new":["/// Constructs a slice reader\npub fn new(bytes: &'storage [u8]) -> SliceReader<'storage>{\n        SliceReader { slice: bytes }\n    }","Real(LocalPath(\"src/de/read.rs\"))"],"decode_from_reader":["/// Attempt to decode a given type `D` from the given [Reader].\n///\n/// See the [config] module for more information on configurations.\n///\n/// [config]: config/index.html\npub fn decode_from_reader<D: de::Decode, R: Reader, C: Config>(\n    reader: R,\n    config: C,\n) -> Result<D, error::DecodeError>{\n    let mut decoder = de::DecoderImpl::<_, C>::new(reader, config);\n    D::decode(&mut decoder)\n}","Real(LocalPath(\"src/lib.rs\"))"],"decode_from_slice":["/// Attempt to decode a given type `D` from the given slice. Returns the decoded output and the amount of bytes read.\n///\n/// See the [config] module for more information on configurations.\n///\n/// [config]: config/index.html\npub fn decode_from_slice<D: de::Decode, C: Config>(\n    src: &[u8],\n    config: C,\n) -> Result<(D, usize), error::DecodeError>{\n    let reader = de::read::SliceReader::new(src);\n    let mut decoder = de::DecoderImpl::<_, C>::new(reader, config);\n    let result = D::decode(&mut decoder)?;\n    let bytes_read = src.len() - decoder.reader().slice.len();\n    Ok((result, bytes_read))\n}","Real(LocalPath(\"src/lib.rs\"))"],"enc::Encode":["/// Any source that can be encoded. This trait should be implemented for all types that you want to be able to use with any of the `encode_with` methods.\n///\n/// This trait will be automatically implemented if you enable the `derive` feature and add `#[derive(bincode::Encode)]` to your trait.\n///\n/// # Implementing this trait manually\n///\n/// If you want to implement this trait for your type, the easiest way is to add a `#[derive(bincode::Encode)]`, build and check your `target/generated/bincode/` folder. This should generate a `<Struct name>_Encode.rs` file.\n///\n/// For this struct:\n///\n/// ```\n/// struct Entity {\n///     pub x: f32,\n///     pub y: f32,\n/// }\n/// ```\n/// It will look something like:\n///\n/// ```\n/// # struct Entity {\n/// #     pub x: f32,\n/// #     pub y: f32,\n/// # }\n/// impl bincode::Encode for Entity {\n///     fn encode<E: bincode::enc::Encoder>(\n///         &self,\n///         encoder: &mut E,\n///     ) -> core::result::Result<(), bincode::error::EncodeError> {\n///         bincode::Encode::encode(&self.x, encoder)?;\n///         bincode::Encode::encode(&self.y, encoder)?;\n///         Ok(())\n///     }\n/// }\n/// ```\n///\n/// From here you can add/remove fields, or add custom logic.\npub trait Encode {\n    /// Encode a given type.\n    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>;\n}","Real(LocalPath(\"src/enc/mod.rs\"))"],"enc::Encoder":["/// Helper trait to encode basic types into.\npub trait Encoder: Sealed {\n    /// The concrete [Writer] type\n    type W: Writer;\n\n    /// The concrete [Config] type\n    type C: Config;\n\n    /// Returns a mutable reference to the writer\n    fn writer(&mut self) -> &mut Self::W;\n\n    /// Returns a reference to the config\n    fn config(&self) -> &Self::C;\n}","Real(LocalPath(\"src/enc/mod.rs\"))"],"enc::encode_option_variant":["/// Encode the variant of the given option. Will not encode the option itself.\n#[inline]\npub(crate) fn encode_option_variant<E: Encoder, T>(\n    encoder: &mut E,\n    value: &Option<T>,\n) -> Result<(), EncodeError>{\n    match value {\n        None => 0u8.encode(encoder),\n        Some(_) => 1u8.encode(encoder),\n    }\n}","Real(LocalPath(\"src/enc/mod.rs\"))"],"enc::encode_slice_len":["/// Encodes the length of any slice, container, etc into the given encoder\n#[inline]\npub(crate) fn encode_slice_len<E: Encoder>(encoder: &mut E, len: usize) -> Result<(), EncodeError>{\n    (len as u64).encode(encoder)\n}","Real(LocalPath(\"src/enc/mod.rs\"))"],"enc::encoder::EncoderImpl":["/// An Encoder that writes bytes into a given writer `W`.\n///\n/// This struct should rarely be used.\n/// In most cases, prefer any of the `encode` functions.\n///\n/// The ByteOrder that is chosen will impact the endianness that\n/// is used to write integers to the writer.\n///\n/// ```\n/// # use bincode::enc::{write::SliceWriter, EncoderImpl, Encode};\n/// let slice: &mut [u8] = &mut [0, 0, 0, 0];\n/// let config = bincode::config::legacy().with_big_endian();\n///\n/// let mut encoder = EncoderImpl::new(SliceWriter::new(slice), config);\n/// // this u32 can be any Encodable\n/// 5u32.encode(&mut encoder).unwrap();\n/// assert_eq!(encoder.into_writer().bytes_written(), 4);\n/// assert_eq!(slice, [0, 0, 0, 5]);\n/// ```\npub struct EncoderImpl<W: Writer, C: Config> {\n    writer: W,\n    config: C,\n}","Real(LocalPath(\"src/enc/encoder.rs\"))"],"enc::encoder::EncoderImpl::<W, C>::into_writer":["/// Return the underlying writer\n#[inline]\npub fn into_writer(self) -> W{\n        self.writer\n    }","Real(LocalPath(\"src/enc/encoder.rs\"))"],"enc::encoder::EncoderImpl::<W, C>::new":["/// Create a new Encoder\npub fn new(writer: W, config: C) -> EncoderImpl<W, C>{\n        EncoderImpl { writer, config }\n    }","Real(LocalPath(\"src/enc/encoder.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        self.4.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        self.4.encode(encoder)?;\n        self.5.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        self.4.encode(encoder)?;\n        self.5.encode(encoder)?;\n        self.6.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        self.4.encode(encoder)?;\n        self.5.encode(encoder)?;\n        self.6.encode(encoder)?;\n        self.7.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        self.4.encode(encoder)?;\n        self.5.encode(encoder)?;\n        self.6.encode(encoder)?;\n        self.7.encode(encoder)?;\n        self.8.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        self.4.encode(encoder)?;\n        self.5.encode(encoder)?;\n        self.6.encode(encoder)?;\n        self.7.encode(encoder)?;\n        self.8.encode(encoder)?;\n        self.9.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        self.4.encode(encoder)?;\n        self.5.encode(encoder)?;\n        self.6.encode(encoder)?;\n        self.7.encode(encoder)?;\n        self.8.encode(encoder)?;\n        self.9.encode(encoder)?;\n        self.10.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        self.4.encode(encoder)?;\n        self.5.encode(encoder)?;\n        self.6.encode(encoder)?;\n        self.7.encode(encoder)?;\n        self.8.encode(encoder)?;\n        self.9.encode(encoder)?;\n        self.10.encode(encoder)?;\n        self.11.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        self.4.encode(encoder)?;\n        self.5.encode(encoder)?;\n        self.6.encode(encoder)?;\n        self.7.encode(encoder)?;\n        self.8.encode(encoder)?;\n        self.9.encode(encoder)?;\n        self.10.encode(encoder)?;\n        self.11.encode(encoder)?;\n        self.12.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        self.4.encode(encoder)?;\n        self.5.encode(encoder)?;\n        self.6.encode(encoder)?;\n        self.7.encode(encoder)?;\n        self.8.encode(encoder)?;\n        self.9.encode(encoder)?;\n        self.10.encode(encoder)?;\n        self.11.encode(encoder)?;\n        self.12.encode(encoder)?;\n        self.13.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        self.4.encode(encoder)?;\n        self.5.encode(encoder)?;\n        self.6.encode(encoder)?;\n        self.7.encode(encoder)?;\n        self.8.encode(encoder)?;\n        self.9.encode(encoder)?;\n        self.10.encode(encoder)?;\n        self.11.encode(encoder)?;\n        self.12.encode(encoder)?;\n        self.13.encode(encoder)?;\n        self.14.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        self.1.encode(encoder)?;\n        self.2.encode(encoder)?;\n        self.3.encode(encoder)?;\n        self.4.encode(encoder)?;\n        self.5.encode(encoder)?;\n        self.6.encode(encoder)?;\n        self.7.encode(encoder)?;\n        self.8.encode(encoder)?;\n        self.9.encode(encoder)?;\n        self.10.encode(encoder)?;\n        self.11.encode(encoder)?;\n        self.12.encode(encoder)?;\n        self.13.encode(encoder)?;\n        self.14.encode(encoder)?;\n        self.15.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impl_tuples::<impl enc::Encode for (A,)>::encode":["fn encode<_E: Encoder>(&self, encoder: &mut _E) -> Result<(), EncodeError>{\n        self.0.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impl_tuples.rs\"))"],"enc::impls::<impl enc::Encode for &'a T>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        T::encode(self, encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for ()>::encode":["fn encode<E: Encoder>(&self, _: &mut E) -> Result<(), EncodeError>{\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for [T; N]>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        for item in self.iter() {\n            item.encode(encoder)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for [T]>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        super::encode_slice_len(encoder, self.len())?;\n\n        if core::any::TypeId::of::<T>() == core::any::TypeId::of::<u8>() {\n            let t: &[u8] = unsafe { core::mem::transmute(self) };\n            encoder.writer().write(t)?;\n            return Ok(());\n        }\n\n        for item in self {\n            item.encode(encoder)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for bool>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        u8::from(*self).encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for char>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        encode_utf8(encoder.writer(), *self)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::cell::Cell<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        T::encode(&self.get(), encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::cell::RefCell<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        let borrow_guard = self\n            .try_borrow()\n            .map_err(|e| EncodeError::RefCellAlreadyBorrowed {\n                inner: e,\n                type_name: core::any::type_name::<RefCell<T>>(),\n            })?;\n        T::encode(&borrow_guard, encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::marker::PhantomData<T>>::encode":["fn encode<E: Encoder>(&self, _: &mut E) -> Result<(), EncodeError>{\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::num::NonZeroI128>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.get().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::num::NonZeroI16>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.get().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::num::NonZeroI32>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.get().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::num::NonZeroI64>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.get().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::num::NonZeroI8>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.get().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::num::NonZeroIsize>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.get().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::num::NonZeroU128>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.get().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::num::NonZeroU16>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.get().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::num::NonZeroU32>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.get().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::num::NonZeroU64>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.get().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::num::NonZeroU8>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.get().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::num::NonZeroUsize>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.get().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::ops::Bound<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match self {\n            Self::Unbounded => {\n                0u32.encode(encoder)?;\n            }\n            Self::Included(val) => {\n                1u32.encode(encoder)?;\n                val.encode(encoder)?;\n            }\n            Self::Excluded(val) => {\n                2u32.encode(encoder)?;\n                val.encode(encoder)?;\n            }\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::ops::Range<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.start.encode(encoder)?;\n        self.end.encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::ops::RangeInclusive<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.start().encode(encoder)?;\n        self.end().encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::option::Option<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        super::encode_option_variant(encoder, self)?;\n        if let Some(val) = self {\n            val.encode(encoder)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::result::Result<T, U>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match self {\n            Ok(val) => {\n                0u32.encode(encoder)?;\n                val.encode(encoder)\n            }\n            Err(err) => {\n                1u32.encode(encoder)?;\n                err.encode(encoder)\n            }\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for core::time::Duration>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.as_secs().encode(encoder)?;\n        self.subsec_nanos().encode(encoder)?;\n        Ok(())\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for f32>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match E::C::ENDIAN {\n            Endian::Big => encoder.writer().write(&self.to_be_bytes()),\n            Endian::Little => encoder.writer().write(&self.to_le_bytes()),\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for f64>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match E::C::ENDIAN {\n            Endian::Big => encoder.writer().write(&self.to_be_bytes()),\n            Endian::Little => encoder.writer().write(&self.to_le_bytes()),\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for i128>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match E::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_encode_i128(encoder.writer(), E::C::ENDIAN, *self)\n            }\n            IntEncoding::Fixed => match E::C::ENDIAN {\n                Endian::Big => encoder.writer().write(&self.to_be_bytes()),\n                Endian::Little => encoder.writer().write(&self.to_le_bytes()),\n            },\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for i16>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match E::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_encode_i16(encoder.writer(), E::C::ENDIAN, *self)\n            }\n            IntEncoding::Fixed => match E::C::ENDIAN {\n                Endian::Big => encoder.writer().write(&self.to_be_bytes()),\n                Endian::Little => encoder.writer().write(&self.to_le_bytes()),\n            },\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for i32>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match E::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_encode_i32(encoder.writer(), E::C::ENDIAN, *self)\n            }\n            IntEncoding::Fixed => match E::C::ENDIAN {\n                Endian::Big => encoder.writer().write(&self.to_be_bytes()),\n                Endian::Little => encoder.writer().write(&self.to_le_bytes()),\n            },\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for i64>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match E::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_encode_i64(encoder.writer(), E::C::ENDIAN, *self)\n            }\n            IntEncoding::Fixed => match E::C::ENDIAN {\n                Endian::Big => encoder.writer().write(&self.to_be_bytes()),\n                Endian::Little => encoder.writer().write(&self.to_le_bytes()),\n            },\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for i8>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        encoder.writer().write(&[*self as u8])\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for isize>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match E::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_encode_isize(encoder.writer(), E::C::ENDIAN, *self)\n            }\n            IntEncoding::Fixed => match E::C::ENDIAN {\n                Endian::Big => encoder.writer().write(&(*self as i64).to_be_bytes()),\n                Endian::Little => encoder.writer().write(&(*self as i64).to_le_bytes()),\n            },\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for str>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.as_bytes().encode(encoder)\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for u128>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match E::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_encode_u128(encoder.writer(), E::C::ENDIAN, *self)\n            }\n            IntEncoding::Fixed => match E::C::ENDIAN {\n                Endian::Big => encoder.writer().write(&self.to_be_bytes()),\n                Endian::Little => encoder.writer().write(&self.to_le_bytes()),\n            },\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for u16>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match E::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_encode_u16(encoder.writer(), E::C::ENDIAN, *self)\n            }\n            IntEncoding::Fixed => match E::C::ENDIAN {\n                Endian::Big => encoder.writer().write(&self.to_be_bytes()),\n                Endian::Little => encoder.writer().write(&self.to_le_bytes()),\n            },\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for u32>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match E::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_encode_u32(encoder.writer(), E::C::ENDIAN, *self)\n            }\n            IntEncoding::Fixed => match E::C::ENDIAN {\n                Endian::Big => encoder.writer().write(&self.to_be_bytes()),\n                Endian::Little => encoder.writer().write(&self.to_le_bytes()),\n            },\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for u64>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match E::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_encode_u64(encoder.writer(), E::C::ENDIAN, *self)\n            }\n            IntEncoding::Fixed => match E::C::ENDIAN {\n                Endian::Big => encoder.writer().write(&self.to_be_bytes()),\n                Endian::Little => encoder.writer().write(&self.to_le_bytes()),\n            },\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for u8>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        encoder.writer().write(&[*self])\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::<impl enc::Encode for usize>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match E::C::INT_ENCODING {\n            IntEncoding::Variable => {\n                crate::varint::varint_encode_usize(encoder.writer(), E::C::ENDIAN, *self)\n            }\n            IntEncoding::Fixed => match E::C::ENDIAN {\n                Endian::Big => encoder.writer().write(&(*self as u64).to_be_bytes()),\n                Endian::Little => encoder.writer().write(&(*self as u64).to_le_bytes()),\n            },\n        }\n    }","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::impls::encode_utf8":["fn encode_utf8(writer: &mut impl Writer, c: char) -> Result<(), EncodeError>{\n    let code = c as u32;\n\n    if code < MAX_ONE_B {\n        writer.write(&[c as u8])\n    } else if code < MAX_TWO_B {\n        let mut buf = [0u8; 2];\n        buf[0] = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n        buf[1] = (code & 0x3F) as u8 | TAG_CONT;\n        writer.write(&buf)\n    } else if code < MAX_THREE_B {\n        let mut buf = [0u8; 3];\n        buf[0] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n        buf[1] = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n        buf[2] = (code & 0x3F) as u8 | TAG_CONT;\n        writer.write(&buf)\n    } else {\n        let mut buf = [0u8; 4];\n        buf[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n        buf[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n        buf[2] = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n        buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n        writer.write(&buf)\n    }\n}","Real(LocalPath(\"src/enc/impls.rs\"))"],"enc::write::SizeWriter":["/// A writer that counts how many bytes were written. This is useful for e.g. pre-allocating buffers bfeore writing to them.\npub struct SizeWriter {\n    /// the amount of bytes that were written so far\n    pub bytes_written: usize,\n}","Real(LocalPath(\"src/enc/write.rs\"))"],"enc::write::SliceWriter":["/// A helper struct that implements `Writer` for a `&[u8]` slice.\n///\n/// ```\n/// use bincode::enc::write::{Writer, SliceWriter};\n///\n/// let destination = &mut [0u8; 100];\n/// let mut writer = SliceWriter::new(destination);\n/// writer.write(&[1, 2, 3, 4, 5]).unwrap();\n///\n/// assert_eq!(writer.bytes_written(), 5);\n/// assert_eq!(destination[0..6], [1, 2, 3, 4, 5, 0]);\n/// ```\npub struct SliceWriter<'storage> {\n    slice: &'storage mut [u8],\n    original_length: usize,\n}","Real(LocalPath(\"src/enc/write.rs\"))"],"enc::write::SliceWriter::<'storage>::bytes_written":["/// Return the amount of bytes written so far.\npub fn bytes_written(&self) -> usize{\n        self.original_length - self.slice.len()\n    }","Real(LocalPath(\"src/enc/write.rs\"))"],"enc::write::SliceWriter::<'storage>::new":["/// Create a new instance of `SliceWriter` with the given byte array.\npub fn new(bytes: &'storage mut [u8]) -> SliceWriter<'storage>{\n        let original = bytes.len();\n        SliceWriter {\n            slice: bytes,\n            original_length: original,\n        }\n    }","Real(LocalPath(\"src/enc/write.rs\"))"],"enc::write::Writer":["/// Trait that indicates that a struct can be used as a destination to encode data too. This is used by [Encode]\n///\n/// [Encode]: ../trait.Encode.html\npub trait Writer {\n    /// Write `bytes` to the underlying writer. Exactly `bytes.len()` bytes must be written, or else an error should be returned.\n    fn write(&mut self, bytes: &[u8]) -> Result<(), EncodeError>;\n}","Real(LocalPath(\"src/enc/write.rs\"))"],"encode_into_slice":["/// Encode the given value into the given slice. Returns the amount of bytes that have been written.\n///\n/// See the [config] module for more information on configurations.\n///\n/// [config]: config/index.html\npub fn encode_into_slice<E: enc::Encode, C: Config>(\n    val: E,\n    dst: &mut [u8],\n    config: C,\n) -> Result<usize, error::EncodeError>{\n    let writer = enc::write::SliceWriter::new(dst);\n    let mut encoder = enc::EncoderImpl::<_, C>::new(writer, config);\n    val.encode(&mut encoder)?;\n    Ok(encoder.into_writer().bytes_written())\n}","Real(LocalPath(\"src/lib.rs\"))"],"encode_into_writer":["/// Encode the given value into a custom [Writer].\n///\n/// See the [config] module for more information on configurations.\n///\n/// [config]: config/index.html\npub fn encode_into_writer<E: enc::Encode, W: Writer, C: Config>(\n    val: E,\n    writer: W,\n    config: C,\n) -> Result<(), error::EncodeError>{\n    let mut encoder = enc::EncoderImpl::<_, C>::new(writer, config);\n    val.encode(&mut encoder)?;\n    Ok(())\n}","Real(LocalPath(\"src/lib.rs\"))"],"error::AllowedEnumVariants":["/// Indicates which enum variants are allowed\n#[non_exhaustive]\npub enum AllowedEnumVariants {\n    /// All values between `min` and `max` (inclusive) are allowed\n    #[allow(missing_docs)]\n    Range { min: u32, max: u32 },\n    /// Each one of these values is allowed\n    Allowed(&'static [u32]),\n}","Real(LocalPath(\"src/error.rs\"))"],"error::DecodeError":["/// Errors that can be encountered by decoding a type\n#[non_exhaustive]\npub enum DecodeError {\n    /// The reader reached its end but more bytes were expected.\n    UnexpectedEnd {\n        /// Gives an estimate of how many extra bytes are needed.\n        ///\n        /// **Note**: this is only an estimate and not indicative of the actual bytes needed.\n        ///\n        /// **Note**: Bincode has no look-ahead mechanism. This means that this will only return the amount of bytes to be read for the current action, and not take into account the entire data structure being read.\n        additional: usize,\n    },\n\n    /// The given configuration limit was exceeded\n    LimitExceeded,\n\n    /// Invalid type was found. The decoder tried to read type `expected`, but found type `found` instead.\n    InvalidIntegerType {\n        /// The type that was being read from the reader\n        expected: IntegerType,\n        /// The type that was encoded in the data\n        found: IntegerType,\n    },\n\n    /// The decoder tried to decode any of the `NonZero*` types but the value is zero\n    NonZeroTypeIsZero {\n        /// The type that was being read from the reader\n        non_zero_type: IntegerType,\n    },\n\n    /// Invalid enum variant was found. The decoder tried to decode variant index `found`, but the variant index should be between `min` and `max`.\n    UnexpectedVariant {\n        /// The type name that was being decoded.\n        type_name: &'static str,\n\n        /// The variants that are allowed\n        allowed: &'static AllowedEnumVariants,\n\n        /// The index of the enum that the decoder encountered\n        found: u32,\n    },\n\n    /// The decoder tried to decode a `str`, but an utf8 error was encountered.\n    Utf8 {\n        /// The inner error\n        inner: core::str::Utf8Error,\n    },\n\n    /// The decoder tried to decode a `char` and failed. The given buffer contains the bytes that are read at the moment of failure.\n    InvalidCharEncoding([u8; 4]),\n\n    /// The decoder tried to decode a `bool` and failed. The given value is what is actually read.\n    InvalidBooleanValue(u8),\n\n    /// The decoder tried to decode an array of length `required`, but the binary data contained an array of length `found`.\n    ArrayLengthMismatch {\n        /// The length of the array required by the rust type.\n        required: usize,\n        /// The length of the array found in the binary format.\n        found: usize,\n    },\n\n    /// The encoded value is outside of the range of the target usize type.\n    ///\n    /// This can happen if an usize was encoded on an architecture with a larger\n    /// usize type and then decoded on an architecture with a smaller one. For\n    /// example going from a 64 bit architecture to a 32 or 16 bit one may\n    /// cause this error.\n    OutsideUsizeRange(u64),\n\n    /// Tried to decode an enum with no variants\n    EmptyEnum {\n        /// The type that was being decoded\n        type_name: &'static str,\n    },\n\n    /// The decoder tried to decode a Duration and overflowed the number of seconds.\n    InvalidDuration {\n        /// The number of seconds in the duration.\n        secs: u64,\n\n        /// The number of nanoseconds in the duration, which when converted to seconds and added to\n        /// `secs`, overflows a `u64`.\n        nanos: u32,\n    },\n\n    /// The decoder tried to decode a SystemTime and overflowed\n    InvalidSystemTime {\n        /// The duration which could not have been added to\n        /// [`UNIX_EPOCH`](std::time::SystemTime::UNIX_EPOCH)\n        duration: core::time::Duration,\n    },\n\n    /// The decoder tried to decode a `CString`, but the incoming data contained a 0 byte\n    #[cfg(feature = \"std\")]\n    CStringNulError {\n        /// Nul byte position\n        position: usize,\n    },\n\n    /// The reader encountered an IO error but more bytes were expected.\n    #[cfg(feature = \"std\")]\n    Io {\n        /// The IO error expected\n        inner: std::io::Error,\n\n        /// Gives an estimate of how many extra bytes are needed.\n        ///\n        /// **Note**: this is only an estimate and not indicative of the actual bytes needed.\n        ///\n        /// **Note**: Bincode has no look-ahead mechanism. This means that this will only return the amount of bytes to be read for the current action, and not take into account the entire data structure being read.\n        additional: usize,\n    },\n\n    /// An uncommon error occurred, see the inner text for more information\n    Other(&'static str),\n\n    /// An uncommon error occurred, see the inner text for more information\n    #[cfg(feature = \"alloc\")]\n    OtherString(alloc::string::String),\n\n    #[cfg(feature = \"serde\")]\n    /// A serde-specific error that occurred while decoding.\n    Serde(crate::features::serde::DecodeError),\n}","Real(LocalPath(\"src/error.rs\"))"],"error::DecodeError::change_integer_type_to_signed":["/// If the current error is `InvalidIntegerType`, change the `expected` and\n/// `found` values from `Ux` to `Ix`. This is needed to have correct error\n/// reporting in src/varint/decode_signed.rs since this calls\n/// src/varint/decode_unsigned.rs and needs to correct the `expected` and\n/// `found` types.\npub(crate) fn change_integer_type_to_signed(self) -> DecodeError{\n        match self {\n            Self::InvalidIntegerType { expected, found } => Self::InvalidIntegerType {\n                expected: expected.into_signed(),\n                found: found.into_signed(),\n            },\n            other => other,\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"error::EncodeError":["/// Errors that can be encountered by encoding a type\n#[non_exhaustive]\npub enum EncodeError {\n    /// The writer ran out of storage.\n    UnexpectedEnd,\n\n    /// The RefCell<T> is already borrowed\n    RefCellAlreadyBorrowed {\n        /// The inner borrow error\n        inner: core::cell::BorrowError,\n        /// the type name of the RefCell being encoded that is currently borrowed.\n        type_name: &'static str,\n    },\n\n    /// An uncommon error occurred, see the inner text for more information\n    Other(&'static str),\n\n    /// An uncommon error occurred, see the inner text for more information\n    #[cfg(feature = \"alloc\")]\n    OtherString(alloc::string::String),\n\n    /// A `std::path::Path` was being encoded but did not contain a valid `&str` representation\n    #[cfg(feature = \"std\")]\n    InvalidPathCharacters,\n\n    /// The targeted writer encountered an `std::io::Error`\n    #[cfg(feature = \"std\")]\n    Io {\n        /// The encountered error\n        inner: std::io::Error,\n        /// The amount of bytes that were written before the error occurred\n        index: usize,\n    },\n\n    /// The encoder tried to encode a `Mutex` or `RwLock`, but the locking failed\n    #[cfg(feature = \"std\")]\n    LockFailed {\n        /// The type name of the mutex for debugging purposes\n        type_name: &'static str,\n    },\n\n    /// The encoder tried to encode a `SystemTime`, but it was before `SystemTime::UNIX_EPOCH`\n    #[cfg(feature = \"std\")]\n    InvalidSystemTime {\n        /// The error that was thrown by the SystemTime\n        inner: std::time::SystemTimeError,\n        /// The SystemTime that caused the error\n        time: std::boxed::Box<std::time::SystemTime>,\n    },\n\n    #[cfg(feature = \"serde\")]\n    /// A serde-specific error that occurred while decoding.\n    Serde(crate::features::serde::EncodeError),\n}","Real(LocalPath(\"src/error.rs\"))"],"error::IntegerType":["/// Integer types. Used by [DecodeError]. These types have no purpose other than being shown in errors.\n#[non_exhaustive]\n#[allow(missing_docs)]\npub enum IntegerType {\n    U8,\n    U16,\n    U32,\n    U64,\n    U128,\n    Usize,\n\n    I8,\n    I16,\n    I32,\n    I64,\n    I128,\n    Isize,\n\n    Reserved,\n}","Real(LocalPath(\"src/error.rs\"))"],"error::IntegerType::into_signed":["/// Change the `Ux` value to the associated `Ix` value.\n/// Returns the old value if `self` is already `Ix`.\npub(crate) fn into_signed(self) -> Self{\n        match self {\n            Self::U8 => Self::I8,\n            Self::U16 => Self::I16,\n            Self::U32 => Self::I32,\n            Self::U64 => Self::I64,\n            Self::U128 => Self::I128,\n            Self::Usize => Self::Isize,\n\n            other => other,\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'cow> for alloc::borrow::Cow<'cow, T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'cow>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = <&T>::borrow_decode(decoder)?;\n        Ok(Cow::Borrowed(t))\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::borrow_decode(decoder)?;\n        Ok(Box::new(t))\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<[T]>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let vec = Vec::borrow_decode(decoder)?;\n        Ok(vec.into_boxed_slice())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<str>>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeMap<K, V>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<(K, V)>(len)?;\n\n        let mut map = BTreeMap::new();\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<(K, V)>());\n\n            let key = K::borrow_decode(decoder)?;\n            let value = V::borrow_decode(decoder)?;\n            map.insert(key, value);\n        }\n        Ok(map)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeSet<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = BTreeSet::new();\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::borrow_decode(decoder)?;\n            map.insert(key);\n        }\n        Ok(map)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BinaryHeap<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = BinaryHeap::with_capacity(len);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::borrow_decode(decoder)?;\n            map.push(key);\n        }\n        Ok(map)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::VecDeque<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = VecDeque::with_capacity(len);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::borrow_decode(decoder)?;\n            map.push_back(key);\n        }\n        Ok(map)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::borrow_decode(decoder)?;\n        Ok(Rc::new(t))\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<[T]>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let vec = Vec::borrow_decode(decoder)?;\n        Ok(vec.into())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::string::String>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::borrow_decode(decoder)?;\n        Ok(Arc::new(t))\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<[T]>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let vec = Vec::borrow_decode(decoder)?;\n        Ok(vec.into())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<str>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let decoded = String::decode(decoder)?;\n        Ok(decoded.into())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::vec::Vec<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut vec = Vec::with_capacity(len);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            vec.push(T::borrow_decode(decoder)?);\n        }\n        Ok(vec)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::borrow::Cow<'cow, T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = <T as ToOwned>::Owned::decode(decoder)?;\n        Ok(Cow::Owned(t))\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::decode(decoder)?;\n        Ok(Box::new(t))\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<[T]>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let vec = Vec::decode(decoder)?;\n        Ok(vec.into_boxed_slice())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<str>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        String::decode(decoder).map(String::into_boxed_str)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::collections::BTreeMap<K, V>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<(K, V)>(len)?;\n\n        let mut map = BTreeMap::new();\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<(K, V)>());\n\n            let key = K::decode(decoder)?;\n            let value = V::decode(decoder)?;\n            map.insert(key, value);\n        }\n        Ok(map)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::collections::BTreeSet<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = BTreeSet::new();\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::decode(decoder)?;\n            map.insert(key);\n        }\n        Ok(map)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::collections::BinaryHeap<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = BinaryHeap::with_capacity(len);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::decode(decoder)?;\n            map.push(key);\n        }\n        Ok(map)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::collections::VecDeque<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = VecDeque::with_capacity(len);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::decode(decoder)?;\n            map.push_back(key);\n        }\n        Ok(map)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::rc::Rc<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::decode(decoder)?;\n        Ok(Rc::new(t))\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::rc::Rc<[T]>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let vec = Vec::decode(decoder)?;\n        Ok(vec.into())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::string::String>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let bytes = Vec::<u8>::decode(decoder)?;\n        String::from_utf8(bytes).map_err(|e| DecodeError::Utf8 {\n            inner: e.utf8_error(),\n        })\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::decode(decoder)?;\n        Ok(Arc::new(t))\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<[T]>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let vec = Vec::decode(decoder)?;\n        Ok(vec.into())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<str>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let decoded = String::decode(decoder)?;\n        Ok(decoded.into())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl de::Decode for alloc::vec::Vec<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n\n        if core::any::TypeId::of::<T>() == core::any::TypeId::of::<u8>() {\n            decoder.claim_container_read::<T>(len)?;\n            // optimize for reading u8 vecs\n            let mut vec = Vec::new();\n            vec.resize(len, 0u8);\n            decoder.reader().read(&mut vec)?;\n            // Safety: Vec<T> is Vec<u8>\n            return Ok(unsafe { core::mem::transmute(vec) });\n        }\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut vec = Vec::with_capacity(len);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            vec.push(T::decode(decoder)?);\n        }\n        Ok(vec)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl enc::Encode for alloc::borrow::Cow<'cow, T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.as_ref().encode(encoder)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl enc::Encode for alloc::boxed::Box<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        T::encode(self, encoder)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeMap<K, V>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        for (key, val) in self.iter() {\n            key.encode(encoder)?;\n            val.encode(encoder)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeSet<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        for item in self.iter() {\n            item.encode(encoder)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl enc::Encode for alloc::collections::BinaryHeap<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        for val in self.iter() {\n            val.encode(encoder)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl enc::Encode for alloc::collections::VecDeque<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        for item in self.iter() {\n            item.encode(encoder)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl enc::Encode for alloc::rc::Rc<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        T::encode(self, encoder)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl enc::Encode for alloc::string::String>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.as_bytes().encode(encoder)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl enc::Encode for alloc::sync::Arc<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        T::encode(self, encoder)\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::<impl enc::Encode for alloc::vec::Vec<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        if core::any::TypeId::of::<T>() == core::any::TypeId::of::<u8>() {\n            let slice: &[u8] = unsafe { core::mem::transmute(self.as_slice()) };\n            encoder.writer().write(slice)?;\n            return Ok(());\n        }\n        for item in self.iter() {\n            item.encode(encoder)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::VecWriter":["pub(crate) struct VecWriter {\n    inner: Vec<u8>,\n}","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::VecWriter::collect":["#[allow(dead_code)]\npub(crate) fn collect(self) -> Vec<u8>{\n        self.inner\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::VecWriter::with_capacity":["/// Create a new vec writer with the given capacity\npub fn with_capacity(cap: usize) -> Self{\n        Self {\n            inner: Vec::with_capacity(cap),\n        }\n    }","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_alloc::encode_to_vec":["/// Encode the given value into a `Vec<u8>` with the given `Config`. See the [config] module for more information.\n///\n/// [config]: config/index.html\npub fn encode_to_vec<E: enc::Encode, C: Config>(val: E, config: C) -> Result<Vec<u8>, EncodeError>{\n    let size = {\n        let mut size_writer = enc::EncoderImpl::<_, C>::new(SizeWriter::default(), config);\n        val.encode(&mut size_writer)?;\n        size_writer.into_writer().bytes_written\n    };\n    let writer = VecWriter::with_capacity(size);\n    let mut encoder = enc::EncoderImpl::<_, C>::new(writer, config);\n    val.encode(&mut encoder)?;\n    Ok(encoder.into_writer().inner)\n}","Real(LocalPath(\"src/features/impl_alloc.rs\"))"],"features::impl_std::<impl core::error::Error for error::DecodeError>::source":["fn source(&self) -> Option<&(dyn std::error::Error + 'static)>{\n        match self {\n            Self::Utf8 { inner } => Some(inner),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl core::error::Error for error::EncodeError>::source":["fn source(&self) -> Option<&(dyn std::error::Error + 'static)>{\n        match self {\n            Self::RefCellAlreadyBorrowed { inner, .. } => Some(inner),\n            Self::Io { inner, .. } => Some(inner),\n            Self::InvalidSystemTime { inner, .. } => Some(inner),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for &'de std::path::Path>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let str = <&'de str>::borrow_decode(decoder)?;\n        Ok(Path::new(str))\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for alloc::ffi::CString>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashMap<K, V, S>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<(K, V)>(len)?;\n\n        let hash_builder: S = Default::default();\n        let mut map = HashMap::with_capacity_and_hasher(len, hash_builder);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<(K, V)>());\n\n            let k = K::borrow_decode(decoder)?;\n            let v = V::borrow_decode(decoder)?;\n            map.insert(k, v);\n        }\n        Ok(map)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashSet<T, S>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let mut map = HashSet::with_capacity_and_hasher(len, S::default());\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::borrow_decode(decoder)?;\n            map.insert(key);\n        }\n        Ok(map)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::IpAddr>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv4Addr>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv6Addr>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddr>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV4>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV6>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for std::path::PathBuf>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for std::sync::Mutex<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::borrow_decode(decoder)?;\n        Ok(Mutex::new(t))\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for std::sync::RwLock<T>>::borrow_decode":["fn borrow_decode<D: BorrowDecoder<'de>>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::borrow_decode(decoder)?;\n        Ok(RwLock::new(t))\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::BorrowDecode<'de> for std::time::SystemTime>::borrow_decode":["fn borrow_decode<D: $crate::de::BorrowDecoder<'de>>(\n                decoder: &mut D,\n            ) -> core::result::Result<Self, $crate::error::DecodeError>{\n                $crate::Decode::decode(decoder)\n            }","Real(LocalPath(\"src/de/mod.rs\"))"],"features::impl_std::<impl de::Decode for alloc::ffi::CString>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let vec = std::vec::Vec::decode(decoder)?;\n        CString::new(vec).map_err(|inner| DecodeError::CStringNulError {\n            position: inner.nul_position(),\n        })\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::Decode for std::collections::HashMap<K, V, S>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<(K, V)>(len)?;\n\n        let hash_builder: S = Default::default();\n        let mut map = HashMap::with_capacity_and_hasher(len, hash_builder);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<(K, V)>());\n\n            let k = K::decode(decoder)?;\n            let v = V::decode(decoder)?;\n            map.insert(k, v);\n        }\n        Ok(map)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::Decode for std::collections::HashSet<T, S>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let len = crate::de::decode_slice_len(decoder)?;\n        decoder.claim_container_read::<T>(len)?;\n\n        let hash_builder: S = Default::default();\n        let mut map: HashSet<T, S> = HashSet::with_capacity_and_hasher(len, hash_builder);\n        for _ in 0..len {\n            // See the documentation on `unclaim_bytes_read` as to why we're doing this here\n            decoder.unclaim_bytes_read(core::mem::size_of::<T>());\n\n            let key = T::decode(decoder)?;\n            map.insert(key);\n        }\n        Ok(map)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::Decode for std::net::IpAddr>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        match u32::decode(decoder)? {\n            0 => Ok(IpAddr::V4(Ipv4Addr::decode(decoder)?)),\n            1 => Ok(IpAddr::V6(Ipv6Addr::decode(decoder)?)),\n            found => Err(DecodeError::UnexpectedVariant {\n                allowed: &crate::error::AllowedEnumVariants::Range { min: 0, max: 1 },\n                found,\n                type_name: core::any::type_name::<IpAddr>(),\n            }),\n        }\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::Decode for std::net::Ipv4Addr>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let mut buff = [0u8; 4];\n        decoder.reader().read(&mut buff)?;\n        Ok(Self::from(buff))\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::Decode for std::net::Ipv6Addr>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let mut buff = [0u8; 16];\n        decoder.reader().read(&mut buff)?;\n        Ok(Self::from(buff))\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::Decode for std::net::SocketAddr>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        match u32::decode(decoder)? {\n            0 => Ok(SocketAddr::V4(SocketAddrV4::decode(decoder)?)),\n            1 => Ok(SocketAddr::V6(SocketAddrV6::decode(decoder)?)),\n            found => Err(DecodeError::UnexpectedVariant {\n                allowed: &crate::error::AllowedEnumVariants::Range { min: 0, max: 1 },\n                found,\n                type_name: core::any::type_name::<SocketAddr>(),\n            }),\n        }\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::Decode for std::net::SocketAddrV4>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let ip = Ipv4Addr::decode(decoder)?;\n        let port = u16::decode(decoder)?;\n        Ok(Self::new(ip, port))\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::Decode for std::net::SocketAddrV6>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let ip = Ipv6Addr::decode(decoder)?;\n        let port = u16::decode(decoder)?;\n        Ok(Self::new(ip, port, 0, 0))\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::Decode for std::path::PathBuf>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let string = std::string::String::decode(decoder)?;\n        Ok(string.into())\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::Decode for std::sync::Mutex<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::decode(decoder)?;\n        Ok(Mutex::new(t))\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::Decode for std::sync::RwLock<T>>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let t = T::decode(decoder)?;\n        Ok(RwLock::new(t))\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::Decode for std::time::SystemTime>::decode":["fn decode<D: Decoder>(decoder: &mut D) -> Result<Self, DecodeError>{\n        let duration = Duration::decode(decoder)?;\n        match SystemTime::UNIX_EPOCH.checked_add(duration) {\n            Some(t) => Ok(t),\n            None => Err(DecodeError::InvalidSystemTime { duration }),\n        }\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::consume":["#[inline]\nfn consume(&mut self, n: usize){\n        <Self as std::io::BufRead>::consume(self, n);\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::peek_read":["#[inline]\nfn peek_read(&mut self, n: usize) -> Option<&[u8]>{\n        self.buffer().get(..n)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::read":["fn read(&mut self, bytes: &mut [u8]) -> Result<(), DecodeError>{\n        self.read_exact(bytes).map_err(|inner| DecodeError::Io {\n            inner,\n            additional: bytes.len(),\n        })\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for &'a core::ffi::CStr>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.to_bytes().encode(encoder)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for &std::path::Path>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match self.to_str() {\n            Some(str) => str.encode(encoder),\n            None => Err(EncodeError::InvalidPathCharacters),\n        }\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for alloc::ffi::CString>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.as_bytes().encode(encoder)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for std::collections::HashMap<K, V, S>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        for (k, v) in self.iter() {\n            Encode::encode(k, encoder)?;\n            Encode::encode(v, encoder)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for std::collections::HashSet<T, S>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        crate::enc::encode_slice_len(encoder, self.len())?;\n        for item in self.iter() {\n            item.encode(encoder)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for std::net::IpAddr>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match self {\n            IpAddr::V4(v4) => {\n                0u32.encode(encoder)?;\n                v4.encode(encoder)\n            }\n            IpAddr::V6(v6) => {\n                1u32.encode(encoder)?;\n                v6.encode(encoder)\n            }\n        }\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for std::net::Ipv4Addr>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        encoder.writer().write(&self.octets())\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for std::net::Ipv6Addr>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        encoder.writer().write(&self.octets())\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for std::net::SocketAddr>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        match self {\n            SocketAddr::V4(v4) => {\n                0u32.encode(encoder)?;\n                v4.encode(encoder)\n            }\n            SocketAddr::V6(v6) => {\n                1u32.encode(encoder)?;\n                v6.encode(encoder)\n            }\n        }\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for std::net::SocketAddrV4>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.ip().encode(encoder)?;\n        self.port().encode(encoder)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for std::net::SocketAddrV6>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.ip().encode(encoder)?;\n        self.port().encode(encoder)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for std::path::PathBuf>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        self.as_path().encode(encoder)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for std::sync::Mutex<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        let t = self.lock().map_err(|_| EncodeError::LockFailed {\n            type_name: core::any::type_name::<Mutex<T>>(),\n        })?;\n        t.encode(encoder)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for std::sync::RwLock<T>>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        let t = self.read().map_err(|_| EncodeError::LockFailed {\n            type_name: core::any::type_name::<RwLock<T>>(),\n        })?;\n        t.encode(encoder)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::<impl enc::Encode for std::time::SystemTime>::encode":["fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError>{\n        let duration = self.duration_since(SystemTime::UNIX_EPOCH).map_err(|e| {\n            EncodeError::InvalidSystemTime {\n                inner: e,\n                time: std::boxed::Box::new(*self),\n            }\n        })?;\n        duration.encode(encoder)\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::IoReader":["pub(crate) struct IoReader<R> {\n    reader: R,\n}","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::IoReader::<R>::new":["pub fn new(reader: R) -> Self{\n        Self { reader }\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::IoWriter":["pub(crate) struct IoWriter<'a, W: std::io::Write> {\n    writer: &'a mut W,\n    bytes_written: usize,\n}","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::IoWriter::<'a, W>::bytes_written":["pub fn bytes_written(&self) -> usize{\n        self.bytes_written\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::IoWriter::<'a, W>::new":["pub fn new(writer: &'a mut W) -> Self{\n        Self {\n            writer,\n            bytes_written: 0,\n        }\n    }","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::decode_from_std_read":["/// Decode type `D` from the given reader with the given `Config`. The reader can be any type that implements `std::io::Read`, e.g. `std::fs::File`.\n///\n/// See the [config] module for more information about config options.\n///\n/// [config]: config/index.html\npub fn decode_from_std_read<D: Decode, C: Config, R: std::io::Read>(\n    src: &mut R,\n    config: C,\n) -> Result<D, DecodeError>{\n    let reader = IoReader::new(src);\n    let mut decoder = DecoderImpl::<_, C>::new(reader, config);\n    D::decode(&mut decoder)\n}","Real(LocalPath(\"src/features/impl_std.rs\"))"],"features::impl_std::encode_into_std_write":["/// Encode the given value into any type that implements `std::io::Write`, e.g. `std::fs::File`, with the given `Config`.\n/// See the [config] module for more information.\n/// Returns the amount of bytes written.\n///\n/// [config]: config/index.html\npub fn encode_into_std_write<E: Encode, C: Config, W: std::io::Write>(\n    val: E,\n    dst: &mut W,\n    config: C,\n) -> Result<usize, EncodeError>{\n    let writer = IoWriter::new(dst);\n    let mut encoder = EncoderImpl::<_, C>::new(writer, config);\n    val.encode(&mut encoder)?;\n    Ok(encoder.into_writer().bytes_written())\n}","Real(LocalPath(\"src/features/impl_std.rs\"))"],"utils::Sealed":["pub trait Sealed {}","Real(LocalPath(\"src/utils.rs\"))"],"varint::decode_signed::varint_decode_i128":["pub fn varint_decode_i128<R: Reader>(read: &mut R, endian: Endian) -> Result<i128, DecodeError>{\n    let n = super::varint_decode_u128(read, endian)\n        .map_err(DecodeError::change_integer_type_to_signed)?;\n    Ok(if n % 2 == 0 {\n        // positive number\n        (n / 2) as _\n    } else {\n        // negative number\n        // !m * 2 + 1 = n\n        // !m * 2 = n - 1\n        // !m = (n - 1) / 2\n        // m = !((n - 1) / 2)\n        // since we have n is odd, we have floor(n / 2) = floor((n - 1) / 2)\n        !(n / 2) as _\n    })\n}","Real(LocalPath(\"src/varint/decode_signed.rs\"))"],"varint::decode_signed::varint_decode_i16":["pub fn varint_decode_i16<R: Reader>(read: &mut R, endian: Endian) -> Result<i16, DecodeError>{\n    let n = super::varint_decode_u16(read, endian)\n        .map_err(DecodeError::change_integer_type_to_signed)?;\n    Ok(if n % 2 == 0 {\n        // positive number\n        (n / 2) as _\n    } else {\n        // negative number\n        // !m * 2 + 1 = n\n        // !m * 2 = n - 1\n        // !m = (n - 1) / 2\n        // m = !((n - 1) / 2)\n        // since we have n is odd, we have floor(n / 2) = floor((n - 1) / 2)\n        !(n / 2) as _\n    })\n}","Real(LocalPath(\"src/varint/decode_signed.rs\"))"],"varint::decode_signed::varint_decode_i32":["pub fn varint_decode_i32<R: Reader>(read: &mut R, endian: Endian) -> Result<i32, DecodeError>{\n    let n = super::varint_decode_u32(read, endian)\n        .map_err(DecodeError::change_integer_type_to_signed)?;\n    Ok(if n % 2 == 0 {\n        // positive number\n        (n / 2) as _\n    } else {\n        // negative number\n        // !m * 2 + 1 = n\n        // !m * 2 = n - 1\n        // !m = (n - 1) / 2\n        // m = !((n - 1) / 2)\n        // since we have n is odd, we have floor(n / 2) = floor((n - 1) / 2)\n        !(n / 2) as _\n    })\n}","Real(LocalPath(\"src/varint/decode_signed.rs\"))"],"varint::decode_signed::varint_decode_i64":["pub fn varint_decode_i64<R: Reader>(read: &mut R, endian: Endian) -> Result<i64, DecodeError>{\n    let n = super::varint_decode_u64(read, endian)\n        .map_err(DecodeError::change_integer_type_to_signed)?;\n    Ok(if n % 2 == 0 {\n        // positive number\n        (n / 2) as _\n    } else {\n        // negative number\n        // !m * 2 + 1 = n\n        // !m * 2 = n - 1\n        // !m = (n - 1) / 2\n        // m = !((n - 1) / 2)\n        // since we have n is odd, we have floor(n / 2) = floor((n - 1) / 2)\n        !(n / 2) as _\n    })\n}","Real(LocalPath(\"src/varint/decode_signed.rs\"))"],"varint::decode_signed::varint_decode_isize":["pub fn varint_decode_isize<R: Reader>(read: &mut R, endian: Endian) -> Result<isize, DecodeError>{\n    match varint_decode_i64(read, endian) {\n        Ok(val) => Ok(val as isize),\n        Err(DecodeError::InvalidIntegerType { found, .. }) => {\n            Err(DecodeError::InvalidIntegerType {\n                expected: IntegerType::Isize,\n                found: found.into_signed(),\n            })\n        }\n        Err(e) => Err(e),\n    }\n}","Real(LocalPath(\"src/varint/decode_signed.rs\"))"],"varint::decode_unsigned::deserialize_varint_cold_u128":["#[inline(never)]\n#[cold]\nfn deserialize_varint_cold_u128<R>(read: &mut R, endian: Endian) -> Result<u128, DecodeError>\nwhere\n    R: Reader,{\n    let mut bytes = [0u8; 1];\n    read.read(&mut bytes)?;\n    match bytes[0] {\n        byte @ 0..=SINGLE_BYTE_MAX => Ok(byte as u128),\n        U16_BYTE => {\n            let mut bytes = [0u8; 2];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u16::from_be_bytes(bytes) as u128,\n                Endian::Little => u16::from_le_bytes(bytes) as u128,\n            })\n        }\n        U32_BYTE => {\n            let mut bytes = [0u8; 4];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u32::from_be_bytes(bytes) as u128,\n                Endian::Little => u32::from_le_bytes(bytes) as u128,\n            })\n        }\n        U64_BYTE => {\n            let mut bytes = [0u8; 8];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u64::from_be_bytes(bytes) as u128,\n                Endian::Little => u64::from_le_bytes(bytes) as u128,\n            })\n        }\n        U128_BYTE => {\n            let mut bytes = [0u8; 16];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u128::from_be_bytes(bytes),\n                Endian::Little => u128::from_le_bytes(bytes),\n            })\n        }\n        _ => invalid_varint_discriminant(IntegerType::U128, IntegerType::Reserved),\n    }\n}","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))"],"varint::decode_unsigned::deserialize_varint_cold_u16":["#[inline(never)]\n#[cold]\nfn deserialize_varint_cold_u16<R>(read: &mut R, endian: Endian) -> Result<u16, DecodeError>\nwhere\n    R: Reader,{\n    let mut bytes = [0u8; 1];\n    read.read(&mut bytes)?;\n    match bytes[0] {\n        byte @ 0..=SINGLE_BYTE_MAX => Ok(byte as u16),\n        U16_BYTE => {\n            let mut bytes = [0u8; 2];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u16::from_be_bytes(bytes),\n                Endian::Little => u16::from_le_bytes(bytes),\n            })\n        }\n        U32_BYTE => invalid_varint_discriminant(IntegerType::U16, IntegerType::U32),\n        U64_BYTE => invalid_varint_discriminant(IntegerType::U16, IntegerType::U64),\n        U128_BYTE => invalid_varint_discriminant(IntegerType::U16, IntegerType::U128),\n        _ => invalid_varint_discriminant(IntegerType::U16, IntegerType::Reserved),\n    }\n}","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))"],"varint::decode_unsigned::deserialize_varint_cold_u32":["#[inline(never)]\n#[cold]\nfn deserialize_varint_cold_u32<R>(read: &mut R, endian: Endian) -> Result<u32, DecodeError>\nwhere\n    R: Reader,{\n    let mut bytes = [0u8; 1];\n    read.read(&mut bytes)?;\n    match bytes[0] {\n        byte @ 0..=SINGLE_BYTE_MAX => Ok(byte as u32),\n        U16_BYTE => {\n            let mut bytes = [0u8; 2];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u16::from_be_bytes(bytes) as u32,\n                Endian::Little => u16::from_le_bytes(bytes) as u32,\n            })\n        }\n        U32_BYTE => {\n            let mut bytes = [0u8; 4];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u32::from_be_bytes(bytes),\n                Endian::Little => u32::from_le_bytes(bytes),\n            })\n        }\n        U64_BYTE => invalid_varint_discriminant(IntegerType::U32, IntegerType::U64),\n        U128_BYTE => invalid_varint_discriminant(IntegerType::U32, IntegerType::U128),\n        _ => invalid_varint_discriminant(IntegerType::U32, IntegerType::Reserved),\n    }\n}","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))"],"varint::decode_unsigned::deserialize_varint_cold_u64":["#[inline(never)]\n#[cold]\nfn deserialize_varint_cold_u64<R>(read: &mut R, endian: Endian) -> Result<u64, DecodeError>\nwhere\n    R: Reader,{\n    let mut bytes = [0u8; 1];\n    read.read(&mut bytes)?;\n    match bytes[0] {\n        byte @ 0..=SINGLE_BYTE_MAX => Ok(byte as u64),\n        U16_BYTE => {\n            let mut bytes = [0u8; 2];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u16::from_be_bytes(bytes) as u64,\n                Endian::Little => u16::from_le_bytes(bytes) as u64,\n            })\n        }\n        U32_BYTE => {\n            let mut bytes = [0u8; 4];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u32::from_be_bytes(bytes) as u64,\n                Endian::Little => u32::from_le_bytes(bytes) as u64,\n            })\n        }\n        U64_BYTE => {\n            let mut bytes = [0u8; 8];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u64::from_be_bytes(bytes),\n                Endian::Little => u64::from_le_bytes(bytes),\n            })\n        }\n        U128_BYTE => invalid_varint_discriminant(IntegerType::U64, IntegerType::U128),\n        _ => invalid_varint_discriminant(IntegerType::U64, IntegerType::Reserved),\n    }\n}","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))"],"varint::decode_unsigned::deserialize_varint_cold_usize":["#[inline(never)]\n#[cold]\nfn deserialize_varint_cold_usize<R>(read: &mut R, endian: Endian) -> Result<usize, DecodeError>\nwhere\n    R: Reader,{\n    let mut bytes = [0u8; 1];\n    read.read(&mut bytes)?;\n    match bytes[0] {\n        byte @ 0..=SINGLE_BYTE_MAX => Ok(byte as usize),\n        U16_BYTE => {\n            let mut bytes = [0u8; 2];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u16::from_be_bytes(bytes) as usize,\n                Endian::Little => u16::from_le_bytes(bytes) as usize,\n            })\n        }\n        U32_BYTE => {\n            let mut bytes = [0u8; 4];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u32::from_be_bytes(bytes) as usize,\n                Endian::Little => u32::from_le_bytes(bytes) as usize,\n            })\n        }\n        U64_BYTE => {\n            let mut bytes = [0u8; 8];\n            read.read(&mut bytes)?;\n            Ok(match endian {\n                Endian::Big => u64::from_be_bytes(bytes) as usize,\n                Endian::Little => u64::from_le_bytes(bytes) as usize,\n            })\n        }\n        U128_BYTE => invalid_varint_discriminant(IntegerType::Usize, IntegerType::U128),\n        _ => invalid_varint_discriminant(IntegerType::Usize, IntegerType::Reserved),\n    }\n}","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))"],"varint::decode_unsigned::invalid_varint_discriminant":["#[inline(never)]\n#[cold]\nfn invalid_varint_discriminant<T>(\n    expected: IntegerType,\n    found: IntegerType,\n) -> Result<T, DecodeError>{\n    Err(DecodeError::InvalidIntegerType { expected, found })\n}","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))"],"varint::decode_unsigned::varint_decode_u128":["pub fn varint_decode_u128<R: Reader>(read: &mut R, endian: Endian) -> Result<u128, DecodeError>{\n    if let Some(bytes) = read.peek_read(17) {\n        let (discriminant, bytes) = bytes.split_at(1);\n        let (out, used) = match discriminant[0] {\n            byte @ 0..=SINGLE_BYTE_MAX => (byte as u128, 1),\n            U16_BYTE => {\n                let val = match endian {\n                    Endian::Big => u16::from_be_bytes(bytes[..2].try_into().unwrap()),\n                    Endian::Little => u16::from_le_bytes(bytes[..2].try_into().unwrap()),\n                };\n\n                (val as u128, 3)\n            }\n            U32_BYTE => {\n                let val = match endian {\n                    Endian::Big => u32::from_be_bytes(bytes[..4].try_into().unwrap()),\n                    Endian::Little => u32::from_le_bytes(bytes[..4].try_into().unwrap()),\n                };\n\n                (val as u128, 5)\n            }\n            U64_BYTE => {\n                let val = match endian {\n                    Endian::Big => u64::from_be_bytes(bytes[..8].try_into().unwrap()),\n                    Endian::Little => u64::from_le_bytes(bytes[..8].try_into().unwrap()),\n                };\n\n                (val as u128, 9)\n            }\n            U128_BYTE => {\n                let val = match endian {\n                    Endian::Big => u128::from_be_bytes(bytes[..16].try_into().unwrap()),\n                    Endian::Little => u128::from_le_bytes(bytes[..16].try_into().unwrap()),\n                };\n\n                (val, 17)\n            }\n            _ => return invalid_varint_discriminant(IntegerType::Usize, IntegerType::Reserved),\n        };\n\n        read.consume(used);\n        Ok(out)\n    } else {\n        deserialize_varint_cold_u128(read, endian)\n    }\n}","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))"],"varint::decode_unsigned::varint_decode_u16":["pub fn varint_decode_u16<R: Reader>(read: &mut R, endian: Endian) -> Result<u16, DecodeError>{\n    if let Some(bytes) = read.peek_read(3) {\n        let (discriminant, bytes) = bytes.split_at(1);\n        let (out, used) = match discriminant[0] {\n            byte @ 0..=SINGLE_BYTE_MAX => (byte as u16, 1),\n            U16_BYTE => {\n                let val = match endian {\n                    Endian::Big => u16::from_be_bytes(bytes[..2].try_into().unwrap()),\n                    Endian::Little => u16::from_le_bytes(bytes[..2].try_into().unwrap()),\n                };\n\n                (val, 3)\n            }\n            U32_BYTE => return invalid_varint_discriminant(IntegerType::U16, IntegerType::U32),\n            U64_BYTE => return invalid_varint_discriminant(IntegerType::U16, IntegerType::U64),\n            U128_BYTE => return invalid_varint_discriminant(IntegerType::U16, IntegerType::U128),\n            _ => return invalid_varint_discriminant(IntegerType::U16, IntegerType::Reserved),\n        };\n\n        read.consume(used);\n        Ok(out)\n    } else {\n        deserialize_varint_cold_u16(read, endian)\n    }\n}","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))"],"varint::decode_unsigned::varint_decode_u32":["pub fn varint_decode_u32<R: Reader>(read: &mut R, endian: Endian) -> Result<u32, DecodeError>{\n    if let Some(bytes) = read.peek_read(5) {\n        let (discriminant, bytes) = bytes.split_at(1);\n        let (out, used) = match discriminant[0] {\n            byte @ 0..=SINGLE_BYTE_MAX => (byte as u32, 1),\n            U16_BYTE => {\n                let val = match endian {\n                    Endian::Big => u16::from_be_bytes(bytes[..2].try_into().unwrap()),\n                    Endian::Little => u16::from_le_bytes(bytes[..2].try_into().unwrap()),\n                };\n\n                (val as u32, 3)\n            }\n            U32_BYTE => {\n                let val = match endian {\n                    Endian::Big => u32::from_be_bytes(bytes[..4].try_into().unwrap()),\n                    Endian::Little => u32::from_le_bytes(bytes[..4].try_into().unwrap()),\n                };\n\n                (val, 5)\n            }\n            U64_BYTE => return invalid_varint_discriminant(IntegerType::U32, IntegerType::U64),\n            U128_BYTE => return invalid_varint_discriminant(IntegerType::U32, IntegerType::U128),\n            _ => return invalid_varint_discriminant(IntegerType::U32, IntegerType::Reserved),\n        };\n\n        read.consume(used);\n        Ok(out)\n    } else {\n        deserialize_varint_cold_u32(read, endian)\n    }\n}","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))"],"varint::decode_unsigned::varint_decode_u64":["pub fn varint_decode_u64<R: Reader>(read: &mut R, endian: Endian) -> Result<u64, DecodeError>{\n    if let Some(bytes) = read.peek_read(9) {\n        let (discriminant, bytes) = bytes.split_at(1);\n        let (out, used) = match discriminant[0] {\n            byte @ 0..=SINGLE_BYTE_MAX => (byte as u64, 1),\n            U16_BYTE => {\n                let val = match endian {\n                    Endian::Big => u16::from_be_bytes(bytes[..2].try_into().unwrap()),\n                    Endian::Little => u16::from_le_bytes(bytes[..2].try_into().unwrap()),\n                };\n\n                (val as u64, 3)\n            }\n            U32_BYTE => {\n                let val = match endian {\n                    Endian::Big => u32::from_be_bytes(bytes[..4].try_into().unwrap()),\n                    Endian::Little => u32::from_le_bytes(bytes[..4].try_into().unwrap()),\n                };\n\n                (val as u64, 5)\n            }\n            U64_BYTE => {\n                let val = match endian {\n                    Endian::Big => u64::from_be_bytes(bytes[..8].try_into().unwrap()),\n                    Endian::Little => u64::from_le_bytes(bytes[..8].try_into().unwrap()),\n                };\n\n                (val, 9)\n            }\n            U128_BYTE => return invalid_varint_discriminant(IntegerType::U32, IntegerType::U128),\n            _ => return invalid_varint_discriminant(IntegerType::U32, IntegerType::Reserved),\n        };\n\n        read.consume(used);\n        Ok(out)\n    } else {\n        deserialize_varint_cold_u64(read, endian)\n    }\n}","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))"],"varint::decode_unsigned::varint_decode_usize":["pub fn varint_decode_usize<R: Reader>(read: &mut R, endian: Endian) -> Result<usize, DecodeError>{\n    if let Some(bytes) = read.peek_read(9) {\n        let (discriminant, bytes) = bytes.split_at(1);\n        let (out, used) = match discriminant[0] {\n            byte @ 0..=SINGLE_BYTE_MAX => (byte as usize, 1),\n            U16_BYTE => {\n                let val = match endian {\n                    Endian::Big => u16::from_be_bytes(bytes[..2].try_into().unwrap()),\n                    Endian::Little => u16::from_le_bytes(bytes[..2].try_into().unwrap()),\n                };\n\n                (val as usize, 3)\n            }\n            U32_BYTE => {\n                let val = match endian {\n                    Endian::Big => u32::from_be_bytes(bytes[..4].try_into().unwrap()),\n                    Endian::Little => u32::from_le_bytes(bytes[..4].try_into().unwrap()),\n                };\n\n                (val as usize, 5)\n            }\n            U64_BYTE => {\n                let val = match endian {\n                    Endian::Big => u64::from_be_bytes(bytes[..8].try_into().unwrap()),\n                    Endian::Little => u64::from_le_bytes(bytes[..8].try_into().unwrap()),\n                };\n\n                (val as usize, 9)\n            }\n            U128_BYTE => return invalid_varint_discriminant(IntegerType::Usize, IntegerType::U128),\n            _ => return invalid_varint_discriminant(IntegerType::Usize, IntegerType::Reserved),\n        };\n\n        read.consume(used);\n        Ok(out)\n    } else {\n        deserialize_varint_cold_usize(read, endian)\n    }\n}","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))"],"varint::encode_signed::varint_encode_i128":["pub fn varint_encode_i128<W: Writer>(\n    writer: &mut W,\n    endian: Endian,\n    val: i128,\n) -> Result<(), EncodeError>{\n    varint_encode_u128(\n        writer,\n        endian,\n        if val < 0 {\n            // let's avoid the edge case of i128::min_value()\n            // !n is equal to `-n - 1`, so this is:\n            // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n            !(val as u128) * 2 + 1\n        } else {\n            (val as u128) * 2\n        },\n    )\n}","Real(LocalPath(\"src/varint/encode_signed.rs\"))"],"varint::encode_signed::varint_encode_i16":["pub fn varint_encode_i16<W: Writer>(\n    writer: &mut W,\n    endian: Endian,\n    val: i16,\n) -> Result<(), EncodeError>{\n    varint_encode_u16(\n        writer,\n        endian,\n        if val < 0 {\n            // let's avoid the edge case of i16::min_value()\n            // !n is equal to `-n - 1`, so this is:\n            // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n            !(val as u16) * 2 + 1\n        } else {\n            (val as u16) * 2\n        },\n    )\n}","Real(LocalPath(\"src/varint/encode_signed.rs\"))"],"varint::encode_signed::varint_encode_i32":["pub fn varint_encode_i32<W: Writer>(\n    writer: &mut W,\n    endian: Endian,\n    val: i32,\n) -> Result<(), EncodeError>{\n    varint_encode_u32(\n        writer,\n        endian,\n        if val < 0 {\n            // let's avoid the edge case of i32::min_value()\n            // !n is equal to `-n - 1`, so this is:\n            // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n            !(val as u32) * 2 + 1\n        } else {\n            (val as u32) * 2\n        },\n    )\n}","Real(LocalPath(\"src/varint/encode_signed.rs\"))"],"varint::encode_signed::varint_encode_i64":["pub fn varint_encode_i64<W: Writer>(\n    writer: &mut W,\n    endian: Endian,\n    val: i64,\n) -> Result<(), EncodeError>{\n    varint_encode_u64(\n        writer,\n        endian,\n        if val < 0 {\n            // let's avoid the edge case of i64::min_value()\n            // !n is equal to `-n - 1`, so this is:\n            // !n * 2 + 1 = 2(-n - 1) + 1 = -2n - 2 + 1 = -2n - 1\n            !(val as u64) * 2 + 1\n        } else {\n            (val as u64) * 2\n        },\n    )\n}","Real(LocalPath(\"src/varint/encode_signed.rs\"))"],"varint::encode_signed::varint_encode_isize":["pub fn varint_encode_isize<W: Writer>(\n    writer: &mut W,\n    endian: Endian,\n    val: isize,\n) -> Result<(), EncodeError>{\n    // isize is being encoded as a i64\n    varint_encode_i64(writer, endian, val as i64)\n}","Real(LocalPath(\"src/varint/encode_signed.rs\"))"],"varint::encode_unsigned::varint_encode_u128":["pub fn varint_encode_u128<W: Writer>(\n    writer: &mut W,\n    endian: Endian,\n    val: u128,\n) -> Result<(), EncodeError>{\n    if val <= SINGLE_BYTE_MAX as _ {\n        writer.write(&[val as u8])\n    } else if val <= u16::MAX as _ {\n        writer.write(&[U16_BYTE])?;\n        match endian {\n            Endian::Big => writer.write(&(val as u16).to_be_bytes()),\n            Endian::Little => writer.write(&(val as u16).to_le_bytes()),\n        }\n    } else if val <= u32::MAX as _ {\n        writer.write(&[U32_BYTE])?;\n        match endian {\n            Endian::Big => writer.write(&(val as u32).to_be_bytes()),\n            Endian::Little => writer.write(&(val as u32).to_le_bytes()),\n        }\n    } else if val <= u64::MAX as _ {\n        writer.write(&[U64_BYTE])?;\n        match endian {\n            Endian::Big => writer.write(&(val as u64).to_be_bytes()),\n            Endian::Little => writer.write(&(val as u64).to_le_bytes()),\n        }\n    } else {\n        writer.write(&[U128_BYTE])?;\n        match endian {\n            Endian::Big => writer.write(&val.to_be_bytes()),\n            Endian::Little => writer.write(&val.to_le_bytes()),\n        }\n    }\n}","Real(LocalPath(\"src/varint/encode_unsigned.rs\"))"],"varint::encode_unsigned::varint_encode_u16":["pub fn varint_encode_u16<W: Writer>(\n    writer: &mut W,\n    endian: Endian,\n    val: u16,\n) -> Result<(), EncodeError>{\n    if val <= SINGLE_BYTE_MAX as _ {\n        writer.write(&[val as u8])\n    } else {\n        writer.write(&[U16_BYTE])?;\n        match endian {\n            Endian::Big => writer.write(&val.to_be_bytes()),\n            Endian::Little => writer.write(&val.to_le_bytes()),\n        }\n    }\n}","Real(LocalPath(\"src/varint/encode_unsigned.rs\"))"],"varint::encode_unsigned::varint_encode_u32":["pub fn varint_encode_u32<W: Writer>(\n    writer: &mut W,\n    endian: Endian,\n    val: u32,\n) -> Result<(), EncodeError>{\n    if val <= SINGLE_BYTE_MAX as _ {\n        writer.write(&[val as u8])\n    } else if val <= u16::MAX as _ {\n        writer.write(&[U16_BYTE])?;\n        match endian {\n            Endian::Big => writer.write(&(val as u16).to_be_bytes()),\n            Endian::Little => writer.write(&(val as u16).to_le_bytes()),\n        }\n    } else {\n        writer.write(&[U32_BYTE])?;\n        match endian {\n            Endian::Big => writer.write(&val.to_be_bytes()),\n            Endian::Little => writer.write(&val.to_le_bytes()),\n        }\n    }\n}","Real(LocalPath(\"src/varint/encode_unsigned.rs\"))"],"varint::encode_unsigned::varint_encode_u64":["pub fn varint_encode_u64<W: Writer>(\n    writer: &mut W,\n    endian: Endian,\n    val: u64,\n) -> Result<(), EncodeError>{\n    if val <= SINGLE_BYTE_MAX as _ {\n        writer.write(&[val as u8])\n    } else if val <= u16::MAX as _ {\n        writer.write(&[U16_BYTE])?;\n        match endian {\n            Endian::Big => writer.write(&(val as u16).to_be_bytes()),\n            Endian::Little => writer.write(&(val as u16).to_le_bytes()),\n        }\n    } else if val <= u32::MAX as _ {\n        writer.write(&[U32_BYTE])?;\n        match endian {\n            Endian::Big => writer.write(&(val as u32).to_be_bytes()),\n            Endian::Little => writer.write(&(val as u32).to_le_bytes()),\n        }\n    } else {\n        writer.write(&[U64_BYTE])?;\n        match endian {\n            Endian::Big => writer.write(&val.to_be_bytes()),\n            Endian::Little => writer.write(&val.to_le_bytes()),\n        }\n    }\n}","Real(LocalPath(\"src/varint/encode_unsigned.rs\"))"],"varint::encode_unsigned::varint_encode_usize":["pub fn varint_encode_usize<W: Writer>(\n    writer: &mut W,\n    endian: Endian,\n    val: usize,\n) -> Result<(), EncodeError>{\n    // usize is being encoded as a u64\n    varint_encode_u64(writer, endian, val as u64)\n}","Real(LocalPath(\"src/varint/encode_unsigned.rs\"))"]},"struct_constructor":{"&<&'a mut T as de::Decoder>::C":["config"],"&<&'a mut T as enc::Encoder>::C":["config"],"&<Self as de::Decoder>::C":["config"],"&<Self as enc::Encoder>::C":["config"],"&<de::decoder::DecoderImpl<R, C> as de::Decoder>::C":["config"],"&<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::C":["config"],"&mut <&'a mut T as de::BorrowDecoder<'de>>::BR":["borrow_reader"],"&mut <&'a mut T as de::Decoder>::R":["reader"],"&mut <&'a mut T as enc::Encoder>::W":["writer"],"&mut <Self as de::BorrowDecoder<'de>>::BR":["borrow_reader"],"&mut <Self as de::Decoder>::R":["reader"],"&mut <Self as enc::Encoder>::W":["writer"],"&mut <de::decoder::DecoderImpl<R, C> as de::BorrowDecoder<'de>>::BR":["borrow_reader"],"&mut <de::decoder::DecoderImpl<R, C> as de::Decoder>::R":["reader"],"&mut <enc::encoder::EncoderImpl<W, C> as enc::Encoder>::W":["writer"],"&mut [T]":["slice_assume_init_mut"],"[T; N]":["array_assume_init"],"[core::mem::MaybeUninit<T>; LEN]":["uninit_array"],"alloc::vec::Vec":["collect"],"bool":["eq"],"config::BigEndian":["clone"],"config::Configuration":["clone","default","generate","legacy","standard"],"config::Fixint":["clone"],"config::Limit":["clone"],"config::LittleEndian":["clone"],"config::NoLimit":["clone"],"config::Varint":["clone"],"core::option::Option":["collect_into_array","peek_read","source"],"core::result::Result":["borrow_decode","borrow_decode_from_slice","claim_bytes_read","claim_container_read","decode","decode_from_reader","decode_from_slice","decode_from_std_read","decode_option_variant","decode_slice_len","deserialize_varint_cold_u128","deserialize_varint_cold_u16","deserialize_varint_cold_u32","deserialize_varint_cold_u64","deserialize_varint_cold_usize","encode","encode_into_slice","encode_into_std_write","encode_into_writer","encode_option_variant","encode_slice_len","encode_to_vec","encode_utf8","fmt","invalid_varint_discriminant","read","take_bytes","varint_decode_i128","varint_decode_i16","varint_decode_i32","varint_decode_i64","varint_decode_isize","varint_decode_u128","varint_decode_u16","varint_decode_u32","varint_decode_u64","varint_decode_usize","varint_encode_i128","varint_encode_i16","varint_encode_i32","varint_encode_i64","varint_encode_isize","varint_encode_u128","varint_encode_u16","varint_encode_u32","varint_encode_u64","varint_encode_usize","write"],"de::decoder::DecoderImpl":["new"],"de::read::SliceReader":["new"],"enc::encoder::EncoderImpl":["new"],"enc::write::SizeWriter":["default"],"enc::write::SliceWriter":["new"],"features::impl_alloc::VecWriter":["default","with_capacity"],"features::impl_std::IoReader":["new"],"features::impl_std::IoWriter":["new"],"usize":["bytes_written","utf8_char_width"]},"struct_to_trait":{"<T as config::Config>::T":["config::Config"],"alloc::borrow::Cow":["de::BorrowDecode","de::Decode","enc::Encode"],"alloc::boxed::Box":["de::BorrowDecode","de::Decode","enc::Encode"],"alloc::collections::BTreeMap":["de::BorrowDecode","de::Decode","enc::Encode"],"alloc::collections::BTreeSet":["de::BorrowDecode","de::Decode","enc::Encode"],"alloc::collections::BinaryHeap":["de::BorrowDecode","de::Decode","enc::Encode"],"alloc::collections::VecDeque":["de::BorrowDecode","de::Decode","enc::Encode"],"alloc::ffi::CString":["de::BorrowDecode","de::Decode","enc::Encode"],"alloc::rc::Rc":["de::BorrowDecode","de::Decode","enc::Encode"],"alloc::string::String":["de::BorrowDecode","de::Decode","enc::Encode"],"alloc::sync::Arc":["de::BorrowDecode","de::Decode","enc::Encode"],"alloc::vec::Vec":["de::BorrowDecode","de::Decode","enc::Encode"],"config::BigEndian":["config::internal::InternalEndianConfig","core::clone::Clone","core::marker::Copy"],"config::Configuration":["config::internal::InternalEndianConfig","config::internal::InternalIntEncodingConfig","config::internal::InternalLimitConfig","core::clone::Clone","core::default::Default","core::marker::Copy"],"config::Fixint":["config::internal::InternalIntEncodingConfig","core::clone::Clone","core::marker::Copy"],"config::Limit":["config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy"],"config::LittleEndian":["config::internal::InternalEndianConfig","core::clone::Clone","core::marker::Copy"],"config::NoLimit":["config::internal::InternalLimitConfig","core::clone::Clone","core::marker::Copy"],"config::Varint":["config::internal::InternalIntEncodingConfig","core::clone::Clone","core::marker::Copy"],"config::internal::Endian":["core::cmp::Eq","core::cmp::PartialEq","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"config::internal::IntEncoding":["core::cmp::Eq","core::cmp::PartialEq","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"core::cell::Cell":["de::BorrowDecode","de::Decode","enc::Encode"],"core::cell::RefCell":["de::BorrowDecode","de::Decode","enc::Encode"],"core::marker::PhantomData":["de::BorrowDecode","de::Decode","enc::Encode"],"core::num::NonZeroI128":["de::BorrowDecode","de::Decode","enc::Encode"],"core::num::NonZeroI16":["de::BorrowDecode","de::Decode","enc::Encode"],"core::num::NonZeroI32":["de::BorrowDecode","de::Decode","enc::Encode"],"core::num::NonZeroI64":["de::BorrowDecode","de::Decode","enc::Encode"],"core::num::NonZeroI8":["de::BorrowDecode","de::Decode","enc::Encode"],"core::num::NonZeroIsize":["de::BorrowDecode","de::Decode","enc::Encode"],"core::num::NonZeroU128":["de::BorrowDecode","de::Decode","enc::Encode"],"core::num::NonZeroU16":["de::BorrowDecode","de::Decode","enc::Encode"],"core::num::NonZeroU32":["de::BorrowDecode","de::Decode","enc::Encode"],"core::num::NonZeroU64":["de::BorrowDecode","de::Decode","enc::Encode"],"core::num::NonZeroU8":["de::BorrowDecode","de::Decode","enc::Encode"],"core::num::NonZeroUsize":["de::BorrowDecode","de::Decode","enc::Encode"],"core::ops::Bound":["de::BorrowDecode","de::Decode","enc::Encode"],"core::ops::Range":["de::BorrowDecode","de::Decode","enc::Encode"],"core::ops::RangeInclusive":["de::BorrowDecode","de::Decode","enc::Encode"],"core::option::Option":["de::BorrowDecode","de::Decode","enc::Encode"],"core::result::Result":["de::BorrowDecode","de::Decode","enc::Encode"],"core::sync::atomic::AtomicBool":["de::BorrowDecode","de::Decode","enc::Encode"],"core::sync::atomic::AtomicI16":["de::BorrowDecode","de::Decode","enc::Encode"],"core::sync::atomic::AtomicI32":["de::BorrowDecode","de::Decode","enc::Encode"],"core::sync::atomic::AtomicI64":["de::BorrowDecode","de::Decode","enc::Encode"],"core::sync::atomic::AtomicI8":["de::BorrowDecode","de::Decode","enc::Encode"],"core::sync::atomic::AtomicIsize":["de::BorrowDecode","de::Decode","enc::Encode"],"core::sync::atomic::AtomicU16":["de::BorrowDecode","de::Decode","enc::Encode"],"core::sync::atomic::AtomicU32":["de::BorrowDecode","de::Decode","enc::Encode"],"core::sync::atomic::AtomicU64":["de::BorrowDecode","de::Decode","enc::Encode"],"core::sync::atomic::AtomicU8":["de::BorrowDecode","de::Decode","enc::Encode"],"core::sync::atomic::AtomicUsize":["de::BorrowDecode","de::Decode","enc::Encode"],"core::time::Duration":["de::BorrowDecode","de::Decode","enc::Encode"],"de::decoder::DecoderImpl":["de::BorrowDecoder","de::Decoder","utils::Sealed"],"de::impl_core::collect_into_array::Guard":["core::ops::Drop"],"de::read::SliceReader":["de::read::BorrowReader","de::read::Reader"],"enc::encoder::EncoderImpl":["enc::Encoder","utils::Sealed"],"enc::write::SizeWriter":["core::default::Default","enc::write::Writer"],"enc::write::SliceWriter":["enc::write::Writer"],"error::AllowedEnumVariants":["core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"error::DecodeError":["core::error::Error","core::fmt::Debug","core::fmt::Display"],"error::EncodeError":["core::error::Error","core::fmt::Debug","core::fmt::Display"],"error::IntegerType":["core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::StructuralEq","core::marker::StructuralPartialEq"],"features::impl_alloc::VecWriter":["core::default::Default","enc::write::Writer"],"features::impl_std::IoReader":["de::read::Reader"],"features::impl_std::IoWriter":["enc::write::Writer"],"std::collections::HashMap":["de::BorrowDecode","de::Decode","enc::Encode"],"std::collections::HashSet":["de::BorrowDecode","de::Decode","enc::Encode"],"std::io::BufReader":["de::read::Reader"],"std::net::IpAddr":["de::BorrowDecode","de::Decode","enc::Encode"],"std::net::Ipv4Addr":["de::BorrowDecode","de::Decode","enc::Encode"],"std::net::Ipv6Addr":["de::BorrowDecode","de::Decode","enc::Encode"],"std::net::SocketAddr":["de::BorrowDecode","de::Decode","enc::Encode"],"std::net::SocketAddrV4":["de::BorrowDecode","de::Decode","enc::Encode"],"std::net::SocketAddrV6":["de::BorrowDecode","de::Decode","enc::Encode"],"std::path::PathBuf":["de::BorrowDecode","de::Decode","enc::Encode"],"std::sync::Mutex":["de::BorrowDecode","de::Decode","enc::Encode"],"std::sync::RwLock":["de::BorrowDecode","de::Decode","enc::Encode"],"std::time::SystemTime":["de::BorrowDecode","de::Decode","enc::Encode"]},"targets":{"<&'a mut T as de::BorrowDecoder<'de>>::borrow_reader":["borrow_reader","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecoder"],"<&'a mut T as de::Decoder>::claim_bytes_read":["claim_bytes_read","Real(LocalPath(\"src/de/mod.rs\"))","de::Decoder"],"<&'a mut T as de::Decoder>::config":["config","Real(LocalPath(\"src/de/mod.rs\"))","de::Decoder"],"<&'a mut T as de::Decoder>::reader":["reader","Real(LocalPath(\"src/de/mod.rs\"))","de::Decoder"],"<&'a mut T as de::Decoder>::unclaim_bytes_read":["unclaim_bytes_read","Real(LocalPath(\"src/de/mod.rs\"))","de::Decoder"],"<&'a mut T as enc::Encoder>::config":["config","Real(LocalPath(\"src/enc/mod.rs\"))","enc::Encoder"],"<&'a mut T as enc::Encoder>::writer":["writer","Real(LocalPath(\"src/enc/mod.rs\"))","enc::Encoder"],"<&mut T as de::read::Reader>::consume":["consume","Real(LocalPath(\"src/de/read.rs\"))","de::read::Reader"],"<&mut T as de::read::Reader>::peek_read":["peek_read","Real(LocalPath(\"src/de/read.rs\"))","de::read::Reader"],"<&mut T as de::read::Reader>::read":["read","Real(LocalPath(\"src/de/read.rs\"))","de::read::Reader"],"<&mut T as enc::write::Writer>::write":["write","Real(LocalPath(\"src/enc/write.rs\"))","enc::write::Writer"],"<config::Configuration<E, I, L> as core::default::Default>::default":["default","Real(LocalPath(\"src/config.rs\"))","core::default::Default"],"<de::decoder::DecoderImpl<R, C> as de::BorrowDecoder<'de>>::borrow_reader":["borrow_reader","Real(LocalPath(\"src/de/decoder.rs\"))","de::BorrowDecoder"],"<de::decoder::DecoderImpl<R, C> as de::Decoder>::claim_bytes_read":["claim_bytes_read","Real(LocalPath(\"src/de/decoder.rs\"))","de::Decoder"],"<de::decoder::DecoderImpl<R, C> as de::Decoder>::config":["config","Real(LocalPath(\"src/de/decoder.rs\"))","de::Decoder"],"<de::decoder::DecoderImpl<R, C> as de::Decoder>::reader":["reader","Real(LocalPath(\"src/de/decoder.rs\"))","de::Decoder"],"<de::decoder::DecoderImpl<R, C> as de::Decoder>::unclaim_bytes_read":["unclaim_bytes_read","Real(LocalPath(\"src/de/decoder.rs\"))","de::Decoder"],"<de::impl_core::collect_into_array::Guard<'_, T, N> as core::ops::Drop>::drop":["drop","Real(LocalPath(\"src/de/impl_core.rs\"))","core::ops::Drop"],"<de::read::SliceReader<'storage> as de::read::BorrowReader<'storage>>::take_bytes":["take_bytes","Real(LocalPath(\"src/de/read.rs\"))","de::read::BorrowReader"],"<de::read::SliceReader<'storage> as de::read::Reader>::consume":["consume","Real(LocalPath(\"src/de/read.rs\"))","de::read::Reader"],"<de::read::SliceReader<'storage> as de::read::Reader>::peek_read":["peek_read","Real(LocalPath(\"src/de/read.rs\"))","de::read::Reader"],"<de::read::SliceReader<'storage> as de::read::Reader>::read":["read","Real(LocalPath(\"src/de/read.rs\"))","de::read::Reader"],"<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::config":["config","Real(LocalPath(\"src/enc/encoder.rs\"))","enc::Encoder"],"<enc::encoder::EncoderImpl<W, C> as enc::Encoder>::writer":["writer","Real(LocalPath(\"src/enc/encoder.rs\"))","enc::Encoder"],"<enc::write::SizeWriter as enc::write::Writer>::write":["write","Real(LocalPath(\"src/enc/write.rs\"))","enc::write::Writer"],"<enc::write::SliceWriter<'storage> as enc::write::Writer>::write":["write","Real(LocalPath(\"src/enc/write.rs\"))","enc::write::Writer"],"<error::DecodeError as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","core::fmt::Display"],"<error::EncodeError as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","core::fmt::Display"],"<features::impl_alloc::VecWriter as enc::write::Writer>::write":["write","Real(LocalPath(\"src/features/impl_alloc.rs\"))","enc::write::Writer"],"<features::impl_std::IoReader<R> as de::read::Reader>::read":["read","Real(LocalPath(\"src/features/impl_std.rs\"))","de::read::Reader"],"<features::impl_std::IoWriter<'storage, W> as enc::write::Writer>::write":["write","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::write::Writer"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicBool>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI16>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI32>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI64>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicI8>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicIsize>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU16>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU32>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU64>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicU8>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"atomic::<impl de::BorrowDecode<'de> for core::sync::atomic::AtomicUsize>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"atomic::<impl de::Decode for core::sync::atomic::AtomicBool>::decode":["decode","Real(LocalPath(\"src/atomic.rs\"))","de::Decode"],"atomic::<impl de::Decode for core::sync::atomic::AtomicI16>::decode":["decode","Real(LocalPath(\"src/atomic.rs\"))","de::Decode"],"atomic::<impl de::Decode for core::sync::atomic::AtomicI32>::decode":["decode","Real(LocalPath(\"src/atomic.rs\"))","de::Decode"],"atomic::<impl de::Decode for core::sync::atomic::AtomicI64>::decode":["decode","Real(LocalPath(\"src/atomic.rs\"))","de::Decode"],"atomic::<impl de::Decode for core::sync::atomic::AtomicI8>::decode":["decode","Real(LocalPath(\"src/atomic.rs\"))","de::Decode"],"atomic::<impl de::Decode for core::sync::atomic::AtomicIsize>::decode":["decode","Real(LocalPath(\"src/atomic.rs\"))","de::Decode"],"atomic::<impl de::Decode for core::sync::atomic::AtomicU16>::decode":["decode","Real(LocalPath(\"src/atomic.rs\"))","de::Decode"],"atomic::<impl de::Decode for core::sync::atomic::AtomicU32>::decode":["decode","Real(LocalPath(\"src/atomic.rs\"))","de::Decode"],"atomic::<impl de::Decode for core::sync::atomic::AtomicU64>::decode":["decode","Real(LocalPath(\"src/atomic.rs\"))","de::Decode"],"atomic::<impl de::Decode for core::sync::atomic::AtomicU8>::decode":["decode","Real(LocalPath(\"src/atomic.rs\"))","de::Decode"],"atomic::<impl de::Decode for core::sync::atomic::AtomicUsize>::decode":["decode","Real(LocalPath(\"src/atomic.rs\"))","de::Decode"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicBool>::encode":["encode","Real(LocalPath(\"src/atomic.rs\"))","enc::Encode"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicI16>::encode":["encode","Real(LocalPath(\"src/atomic.rs\"))","enc::Encode"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicI32>::encode":["encode","Real(LocalPath(\"src/atomic.rs\"))","enc::Encode"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicI64>::encode":["encode","Real(LocalPath(\"src/atomic.rs\"))","enc::Encode"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicI8>::encode":["encode","Real(LocalPath(\"src/atomic.rs\"))","enc::Encode"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicIsize>::encode":["encode","Real(LocalPath(\"src/atomic.rs\"))","enc::Encode"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicU16>::encode":["encode","Real(LocalPath(\"src/atomic.rs\"))","enc::Encode"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicU32>::encode":["encode","Real(LocalPath(\"src/atomic.rs\"))","enc::Encode"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicU64>::encode":["encode","Real(LocalPath(\"src/atomic.rs\"))","enc::Encode"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicU8>::encode":["encode","Real(LocalPath(\"src/atomic.rs\"))","enc::Encode"],"atomic::<impl enc::Encode for core::sync::atomic::AtomicUsize>::encode":["encode","Real(LocalPath(\"src/atomic.rs\"))","enc::Encode"],"borrow_decode_from_slice":["borrow_decode_from_slice","Real(LocalPath(\"src/lib.rs\"))",""],"config::Configuration::<E, I, L>::with_big_endian":["with_big_endian","Real(LocalPath(\"src/config.rs\"))",""],"config::Configuration::<E, I, L>::with_fixed_int_encoding":["with_fixed_int_encoding","Real(LocalPath(\"src/config.rs\"))",""],"config::Configuration::<E, I, L>::with_limit":["with_limit","Real(LocalPath(\"src/config.rs\"))",""],"config::Configuration::<E, I, L>::with_little_endian":["with_little_endian","Real(LocalPath(\"src/config.rs\"))",""],"config::Configuration::<E, I, L>::with_no_limit":["with_no_limit","Real(LocalPath(\"src/config.rs\"))",""],"config::Configuration::<E, I, L>::with_variable_int_encoding":["with_variable_int_encoding","Real(LocalPath(\"src/config.rs\"))",""],"config::generate":["generate","Real(LocalPath(\"src/config.rs\"))",""],"config::legacy":["legacy","Real(LocalPath(\"src/config.rs\"))",""],"config::standard":["standard","Real(LocalPath(\"src/config.rs\"))",""],"de::Decoder::claim_container_read":["claim_container_read","Real(LocalPath(\"src/de/mod.rs\"))",""],"de::decode_option_variant":["decode_option_variant","Real(LocalPath(\"src/de/mod.rs\"))",""],"de::decode_slice_len":["decode_slice_len","Real(LocalPath(\"src/de/mod.rs\"))",""],"de::decoder::DecoderImpl::<R, C>::new":["new","Real(LocalPath(\"src/de/decoder.rs\"))",""],"de::impl_core::array_assume_init":["array_assume_init","Real(LocalPath(\"src/de/impl_core.rs\"))",""],"de::impl_core::collect_into_array":["collect_into_array","Real(LocalPath(\"src/de/impl_core.rs\"))",""],"de::impl_core::slice_assume_init_mut":["slice_assume_init_mut","Real(LocalPath(\"src/de/impl_core.rs\"))",""],"de::impl_core::uninit_array":["uninit_array","Real(LocalPath(\"src/de/impl_core.rs\"))",""],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::BorrowDecode<'de> for (A,)>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::BorrowDecode"],"de::impl_tuples::<impl de::Decode for (A, B)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impl_tuples::<impl de::Decode for (A,)>::decode":["decode","Real(LocalPath(\"src/de/impl_tuples.rs\"))","de::Decode"],"de::impls::<impl de::BorrowDecode<'de> for &'a [u8]>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impls.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for &'a str>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impls.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for ()>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for [T; N]>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impls.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for bool>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for char>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::cell::Cell<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impls.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::cell::RefCell<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impls.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::marker::PhantomData<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impls.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI128>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI16>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI32>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI64>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroI8>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroIsize>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU128>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU16>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU32>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU64>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroU8>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::num::NonZeroUsize>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::ops::Bound<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impls.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::ops::Range<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impls.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::ops::RangeInclusive<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impls.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::option::Option<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impls.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::result::Result<T, U>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/impls.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for core::time::Duration>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for f32>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for f64>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for i128>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for i16>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for i32>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for i64>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for i8>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for isize>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for u128>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for u16>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for u32>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for u64>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for u8>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::BorrowDecode<'de> for usize>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"de::impls::<impl de::Decode for ()>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for [T; N]>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for bool>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for char>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::cell::Cell<T>>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::cell::RefCell<T>>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::marker::PhantomData<T>>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::num::NonZeroI128>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::num::NonZeroI16>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::num::NonZeroI32>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::num::NonZeroI64>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::num::NonZeroI8>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::num::NonZeroIsize>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::num::NonZeroU128>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::num::NonZeroU16>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::num::NonZeroU32>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::num::NonZeroU64>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::num::NonZeroU8>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::num::NonZeroUsize>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::ops::Bound<T>>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::ops::Range<T>>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::ops::RangeInclusive<T>>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::option::Option<T>>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::result::Result<T, U>>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for core::time::Duration>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for f32>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for f64>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for i128>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for i16>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for i32>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for i64>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for i8>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for isize>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for u128>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for u16>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for u32>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for u64>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for u8>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::<impl de::Decode for usize>::decode":["decode","Real(LocalPath(\"src/de/impls.rs\"))","de::Decode"],"de::impls::utf8_char_width":["utf8_char_width","Real(LocalPath(\"src/de/impls.rs\"))",""],"de::read::Reader::consume":["consume","Real(LocalPath(\"src/de/read.rs\"))",""],"de::read::Reader::peek_read":["peek_read","Real(LocalPath(\"src/de/read.rs\"))",""],"de::read::SliceReader::<'storage>::new":["new","Real(LocalPath(\"src/de/read.rs\"))",""],"decode_from_reader":["decode_from_reader","Real(LocalPath(\"src/lib.rs\"))",""],"decode_from_slice":["decode_from_slice","Real(LocalPath(\"src/lib.rs\"))",""],"enc::encode_option_variant":["encode_option_variant","Real(LocalPath(\"src/enc/mod.rs\"))",""],"enc::encode_slice_len":["encode_slice_len","Real(LocalPath(\"src/enc/mod.rs\"))",""],"enc::encoder::EncoderImpl::<W, C>::into_writer":["into_writer","Real(LocalPath(\"src/enc/encoder.rs\"))",""],"enc::encoder::EncoderImpl::<W, C>::new":["new","Real(LocalPath(\"src/enc/encoder.rs\"))",""],"enc::impl_tuples::<impl enc::Encode for (A, B)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impl_tuples::<impl enc::Encode for (A,)>::encode":["encode","Real(LocalPath(\"src/enc/impl_tuples.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for &'a T>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for ()>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for [T; N]>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for [T]>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for bool>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for char>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::cell::Cell<T>>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::cell::RefCell<T>>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::marker::PhantomData<T>>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::num::NonZeroI128>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::num::NonZeroI16>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::num::NonZeroI32>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::num::NonZeroI64>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::num::NonZeroI8>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::num::NonZeroIsize>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::num::NonZeroU128>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::num::NonZeroU16>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::num::NonZeroU32>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::num::NonZeroU64>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::num::NonZeroU8>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::num::NonZeroUsize>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::ops::Bound<T>>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::ops::Range<T>>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::ops::RangeInclusive<T>>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::option::Option<T>>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::result::Result<T, U>>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for core::time::Duration>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for f32>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for f64>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for i128>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for i16>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for i32>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for i64>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for i8>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for isize>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for str>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for u128>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for u16>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for u32>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for u64>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for u8>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::<impl enc::Encode for usize>::encode":["encode","Real(LocalPath(\"src/enc/impls.rs\"))","enc::Encode"],"enc::impls::encode_utf8":["encode_utf8","Real(LocalPath(\"src/enc/impls.rs\"))",""],"enc::write::SliceWriter::<'storage>::bytes_written":["bytes_written","Real(LocalPath(\"src/enc/write.rs\"))",""],"enc::write::SliceWriter::<'storage>::new":["new","Real(LocalPath(\"src/enc/write.rs\"))",""],"encode_into_slice":["encode_into_slice","Real(LocalPath(\"src/lib.rs\"))",""],"encode_into_writer":["encode_into_writer","Real(LocalPath(\"src/lib.rs\"))",""],"error::DecodeError::change_integer_type_to_signed":["change_integer_type_to_signed","Real(LocalPath(\"src/error.rs\"))",""],"error::IntegerType::into_signed":["into_signed","Real(LocalPath(\"src/error.rs\"))",""],"features::impl_alloc::<impl de::BorrowDecode<'cow> for alloc::borrow::Cow<'cow, T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<[T]>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::boxed::Box<str>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeMap<K, V>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BTreeSet<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::BinaryHeap<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::collections::VecDeque<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::rc::Rc<[T]>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::string::String>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<[T]>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::sync::Arc<str>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::BorrowDecode<'de> for alloc::vec::Vec<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::BorrowDecode"],"features::impl_alloc::<impl de::Decode for alloc::borrow::Cow<'cow, T>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<T>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<[T]>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::boxed::Box<str>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::collections::BTreeMap<K, V>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::collections::BTreeSet<T>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::collections::BinaryHeap<T>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::collections::VecDeque<T>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::rc::Rc<T>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::rc::Rc<[T]>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::string::String>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<T>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<[T]>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::sync::Arc<str>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl de::Decode for alloc::vec::Vec<T>>::decode":["decode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","de::Decode"],"features::impl_alloc::<impl enc::Encode for alloc::borrow::Cow<'cow, T>>::encode":["encode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","enc::Encode"],"features::impl_alloc::<impl enc::Encode for alloc::boxed::Box<T>>::encode":["encode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","enc::Encode"],"features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeMap<K, V>>::encode":["encode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","enc::Encode"],"features::impl_alloc::<impl enc::Encode for alloc::collections::BTreeSet<T>>::encode":["encode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","enc::Encode"],"features::impl_alloc::<impl enc::Encode for alloc::collections::BinaryHeap<T>>::encode":["encode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","enc::Encode"],"features::impl_alloc::<impl enc::Encode for alloc::collections::VecDeque<T>>::encode":["encode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","enc::Encode"],"features::impl_alloc::<impl enc::Encode for alloc::rc::Rc<T>>::encode":["encode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","enc::Encode"],"features::impl_alloc::<impl enc::Encode for alloc::string::String>::encode":["encode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","enc::Encode"],"features::impl_alloc::<impl enc::Encode for alloc::sync::Arc<T>>::encode":["encode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","enc::Encode"],"features::impl_alloc::<impl enc::Encode for alloc::vec::Vec<T>>::encode":["encode","Real(LocalPath(\"src/features/impl_alloc.rs\"))","enc::Encode"],"features::impl_alloc::VecWriter::collect":["collect","Real(LocalPath(\"src/features/impl_alloc.rs\"))",""],"features::impl_alloc::VecWriter::with_capacity":["with_capacity","Real(LocalPath(\"src/features/impl_alloc.rs\"))",""],"features::impl_alloc::encode_to_vec":["encode_to_vec","Real(LocalPath(\"src/features/impl_alloc.rs\"))",""],"features::impl_std::<impl core::error::Error for error::DecodeError>::source":["source","Real(LocalPath(\"src/features/impl_std.rs\"))","core::error::Error"],"features::impl_std::<impl core::error::Error for error::EncodeError>::source":["source","Real(LocalPath(\"src/features/impl_std.rs\"))","core::error::Error"],"features::impl_std::<impl de::BorrowDecode<'de> for &'de std::path::Path>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for alloc::ffi::CString>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashMap<K, V, S>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for std::collections::HashSet<T, S>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::IpAddr>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv4Addr>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::Ipv6Addr>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddr>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV4>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for std::net::SocketAddrV6>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for std::path::PathBuf>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for std::sync::Mutex<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for std::sync::RwLock<T>>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::BorrowDecode<'de> for std::time::SystemTime>::borrow_decode":["borrow_decode","Real(LocalPath(\"src/de/mod.rs\"))","de::BorrowDecode"],"features::impl_std::<impl de::Decode for alloc::ffi::CString>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::Decode for std::collections::HashMap<K, V, S>>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::Decode for std::collections::HashSet<T, S>>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::Decode for std::net::IpAddr>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::Decode for std::net::Ipv4Addr>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::Decode for std::net::Ipv6Addr>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::Decode for std::net::SocketAddr>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::Decode for std::net::SocketAddrV4>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::Decode for std::net::SocketAddrV6>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::Decode for std::path::PathBuf>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::Decode for std::sync::Mutex<T>>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::Decode for std::sync::RwLock<T>>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::Decode for std::time::SystemTime>::decode":["decode","Real(LocalPath(\"src/features/impl_std.rs\"))","de::Decode"],"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::consume":["consume","Real(LocalPath(\"src/features/impl_std.rs\"))","de::read::Reader"],"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::peek_read":["peek_read","Real(LocalPath(\"src/features/impl_std.rs\"))","de::read::Reader"],"features::impl_std::<impl de::read::Reader for std::io::BufReader<R>>::read":["read","Real(LocalPath(\"src/features/impl_std.rs\"))","de::read::Reader"],"features::impl_std::<impl enc::Encode for &'a core::ffi::CStr>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for &std::path::Path>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for alloc::ffi::CString>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for std::collections::HashMap<K, V, S>>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for std::collections::HashSet<T, S>>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for std::net::IpAddr>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for std::net::Ipv4Addr>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for std::net::Ipv6Addr>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for std::net::SocketAddr>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for std::net::SocketAddrV4>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for std::net::SocketAddrV6>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for std::path::PathBuf>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for std::sync::Mutex<T>>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for std::sync::RwLock<T>>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::<impl enc::Encode for std::time::SystemTime>::encode":["encode","Real(LocalPath(\"src/features/impl_std.rs\"))","enc::Encode"],"features::impl_std::IoReader::<R>::new":["new","Real(LocalPath(\"src/features/impl_std.rs\"))",""],"features::impl_std::IoWriter::<'a, W>::bytes_written":["bytes_written","Real(LocalPath(\"src/features/impl_std.rs\"))",""],"features::impl_std::IoWriter::<'a, W>::new":["new","Real(LocalPath(\"src/features/impl_std.rs\"))",""],"features::impl_std::decode_from_std_read":["decode_from_std_read","Real(LocalPath(\"src/features/impl_std.rs\"))",""],"features::impl_std::encode_into_std_write":["encode_into_std_write","Real(LocalPath(\"src/features/impl_std.rs\"))",""],"varint::decode_signed::varint_decode_i128":["varint_decode_i128","Real(LocalPath(\"src/varint/decode_signed.rs\"))",""],"varint::decode_signed::varint_decode_i16":["varint_decode_i16","Real(LocalPath(\"src/varint/decode_signed.rs\"))",""],"varint::decode_signed::varint_decode_i32":["varint_decode_i32","Real(LocalPath(\"src/varint/decode_signed.rs\"))",""],"varint::decode_signed::varint_decode_i64":["varint_decode_i64","Real(LocalPath(\"src/varint/decode_signed.rs\"))",""],"varint::decode_signed::varint_decode_isize":["varint_decode_isize","Real(LocalPath(\"src/varint/decode_signed.rs\"))",""],"varint::decode_unsigned::deserialize_varint_cold_u128":["deserialize_varint_cold_u128","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))",""],"varint::decode_unsigned::deserialize_varint_cold_u16":["deserialize_varint_cold_u16","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))",""],"varint::decode_unsigned::deserialize_varint_cold_u32":["deserialize_varint_cold_u32","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))",""],"varint::decode_unsigned::deserialize_varint_cold_u64":["deserialize_varint_cold_u64","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))",""],"varint::decode_unsigned::deserialize_varint_cold_usize":["deserialize_varint_cold_usize","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))",""],"varint::decode_unsigned::invalid_varint_discriminant":["invalid_varint_discriminant","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))",""],"varint::decode_unsigned::varint_decode_u128":["varint_decode_u128","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))",""],"varint::decode_unsigned::varint_decode_u16":["varint_decode_u16","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))",""],"varint::decode_unsigned::varint_decode_u32":["varint_decode_u32","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))",""],"varint::decode_unsigned::varint_decode_u64":["varint_decode_u64","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))",""],"varint::decode_unsigned::varint_decode_usize":["varint_decode_usize","Real(LocalPath(\"src/varint/decode_unsigned.rs\"))",""],"varint::encode_signed::varint_encode_i128":["varint_encode_i128","Real(LocalPath(\"src/varint/encode_signed.rs\"))",""],"varint::encode_signed::varint_encode_i16":["varint_encode_i16","Real(LocalPath(\"src/varint/encode_signed.rs\"))",""],"varint::encode_signed::varint_encode_i32":["varint_encode_i32","Real(LocalPath(\"src/varint/encode_signed.rs\"))",""],"varint::encode_signed::varint_encode_i64":["varint_encode_i64","Real(LocalPath(\"src/varint/encode_signed.rs\"))",""],"varint::encode_signed::varint_encode_isize":["varint_encode_isize","Real(LocalPath(\"src/varint/encode_signed.rs\"))",""],"varint::encode_unsigned::varint_encode_u128":["varint_encode_u128","Real(LocalPath(\"src/varint/encode_unsigned.rs\"))",""],"varint::encode_unsigned::varint_encode_u16":["varint_encode_u16","Real(LocalPath(\"src/varint/encode_unsigned.rs\"))",""],"varint::encode_unsigned::varint_encode_u32":["varint_encode_u32","Real(LocalPath(\"src/varint/encode_unsigned.rs\"))",""],"varint::encode_unsigned::varint_encode_u64":["varint_encode_u64","Real(LocalPath(\"src/varint/encode_unsigned.rs\"))",""],"varint::encode_unsigned::varint_encode_usize":["varint_encode_usize","Real(LocalPath(\"src/varint/encode_unsigned.rs\"))",""]},"trait_to_struct":{"config::Config":["<T as config::Config>::T"],"config::internal::InternalEndianConfig":["config::BigEndian","config::Configuration","config::LittleEndian"],"config::internal::InternalIntEncodingConfig":["config::Configuration","config::Fixint","config::Varint"],"config::internal::InternalLimitConfig":["config::Configuration","config::Limit","config::NoLimit"],"core::clone::Clone":["config::BigEndian","config::Configuration","config::Fixint","config::Limit","config::LittleEndian","config::NoLimit","config::Varint"],"core::cmp::Eq":["config::internal::Endian","config::internal::IntEncoding","error::AllowedEnumVariants","error::IntegerType"],"core::cmp::PartialEq":["config::internal::Endian","config::internal::IntEncoding","error::AllowedEnumVariants","error::IntegerType"],"core::default::Default":["config::Configuration","enc::write::SizeWriter","features::impl_alloc::VecWriter"],"core::error::Error":["error::DecodeError","error::EncodeError"],"core::fmt::Debug":["error::AllowedEnumVariants","error::DecodeError","error::EncodeError","error::IntegerType"],"core::fmt::Display":["error::DecodeError","error::EncodeError"],"core::marker::Copy":["config::BigEndian","config::Configuration","config::Fixint","config::Limit","config::LittleEndian","config::NoLimit","config::Varint"],"core::marker::StructuralEq":["config::internal::Endian","config::internal::IntEncoding","error::AllowedEnumVariants","error::IntegerType"],"core::marker::StructuralPartialEq":["config::internal::Endian","config::internal::IntEncoding","error::AllowedEnumVariants","error::IntegerType"],"core::ops::Drop":["de::impl_core::collect_into_array::Guard"],"de::BorrowDecode":["alloc::borrow::Cow","alloc::boxed::Box","alloc::collections::BTreeMap","alloc::collections::BTreeSet","alloc::collections::BinaryHeap","alloc::collections::VecDeque","alloc::ffi::CString","alloc::rc::Rc","alloc::string::String","alloc::sync::Arc","alloc::vec::Vec","core::cell::Cell","core::cell::RefCell","core::marker::PhantomData","core::num::NonZeroI128","core::num::NonZeroI16","core::num::NonZeroI32","core::num::NonZeroI64","core::num::NonZeroI8","core::num::NonZeroIsize","core::num::NonZeroU128","core::num::NonZeroU16","core::num::NonZeroU32","core::num::NonZeroU64","core::num::NonZeroU8","core::num::NonZeroUsize","core::ops::Bound","core::ops::Range","core::ops::RangeInclusive","core::option::Option","core::result::Result","core::sync::atomic::AtomicBool","core::sync::atomic::AtomicI16","core::sync::atomic::AtomicI32","core::sync::atomic::AtomicI64","core::sync::atomic::AtomicI8","core::sync::atomic::AtomicIsize","core::sync::atomic::AtomicU16","core::sync::atomic::AtomicU32","core::sync::atomic::AtomicU64","core::sync::atomic::AtomicU8","core::sync::atomic::AtomicUsize","core::time::Duration","std::collections::HashMap","std::collections::HashSet","std::net::IpAddr","std::net::Ipv4Addr","std::net::Ipv6Addr","std::net::SocketAddr","std::net::SocketAddrV4","std::net::SocketAddrV6","std::path::PathBuf","std::sync::Mutex","std::sync::RwLock","std::time::SystemTime"],"de::BorrowDecoder":["de::decoder::DecoderImpl"],"de::Decode":["alloc::borrow::Cow","alloc::boxed::Box","alloc::collections::BTreeMap","alloc::collections::BTreeSet","alloc::collections::BinaryHeap","alloc::collections::VecDeque","alloc::ffi::CString","alloc::rc::Rc","alloc::string::String","alloc::sync::Arc","alloc::vec::Vec","core::cell::Cell","core::cell::RefCell","core::marker::PhantomData","core::num::NonZeroI128","core::num::NonZeroI16","core::num::NonZeroI32","core::num::NonZeroI64","core::num::NonZeroI8","core::num::NonZeroIsize","core::num::NonZeroU128","core::num::NonZeroU16","core::num::NonZeroU32","core::num::NonZeroU64","core::num::NonZeroU8","core::num::NonZeroUsize","core::ops::Bound","core::ops::Range","core::ops::RangeInclusive","core::option::Option","core::result::Result","core::sync::atomic::AtomicBool","core::sync::atomic::AtomicI16","core::sync::atomic::AtomicI32","core::sync::atomic::AtomicI64","core::sync::atomic::AtomicI8","core::sync::atomic::AtomicIsize","core::sync::atomic::AtomicU16","core::sync::atomic::AtomicU32","core::sync::atomic::AtomicU64","core::sync::atomic::AtomicU8","core::sync::atomic::AtomicUsize","core::time::Duration","std::collections::HashMap","std::collections::HashSet","std::net::IpAddr","std::net::Ipv4Addr","std::net::Ipv6Addr","std::net::SocketAddr","std::net::SocketAddrV4","std::net::SocketAddrV6","std::path::PathBuf","std::sync::Mutex","std::sync::RwLock","std::time::SystemTime"],"de::Decoder":["de::decoder::DecoderImpl"],"de::read::BorrowReader":["de::read::SliceReader"],"de::read::Reader":["de::read::SliceReader","features::impl_std::IoReader","std::io::BufReader"],"enc::Encode":["alloc::borrow::Cow","alloc::boxed::Box","alloc::collections::BTreeMap","alloc::collections::BTreeSet","alloc::collections::BinaryHeap","alloc::collections::VecDeque","alloc::ffi::CString","alloc::rc::Rc","alloc::string::String","alloc::sync::Arc","alloc::vec::Vec","core::cell::Cell","core::cell::RefCell","core::marker::PhantomData","core::num::NonZeroI128","core::num::NonZeroI16","core::num::NonZeroI32","core::num::NonZeroI64","core::num::NonZeroI8","core::num::NonZeroIsize","core::num::NonZeroU128","core::num::NonZeroU16","core::num::NonZeroU32","core::num::NonZeroU64","core::num::NonZeroU8","core::num::NonZeroUsize","core::ops::Bound","core::ops::Range","core::ops::RangeInclusive","core::option::Option","core::result::Result","core::sync::atomic::AtomicBool","core::sync::atomic::AtomicI16","core::sync::atomic::AtomicI32","core::sync::atomic::AtomicI64","core::sync::atomic::AtomicI8","core::sync::atomic::AtomicIsize","core::sync::atomic::AtomicU16","core::sync::atomic::AtomicU32","core::sync::atomic::AtomicU64","core::sync::atomic::AtomicU8","core::sync::atomic::AtomicUsize","core::time::Duration","std::collections::HashMap","std::collections::HashSet","std::net::IpAddr","std::net::Ipv4Addr","std::net::Ipv6Addr","std::net::SocketAddr","std::net::SocketAddrV4","std::net::SocketAddrV6","std::path::PathBuf","std::sync::Mutex","std::sync::RwLock","std::time::SystemTime"],"enc::Encoder":["enc::encoder::EncoderImpl"],"enc::write::Writer":["enc::write::SizeWriter","enc::write::SliceWriter","features::impl_alloc::VecWriter","features::impl_std::IoWriter"],"utils::Sealed":["de::decoder::DecoderImpl","enc::encoder::EncoderImpl"]},"type_to_def_path":{"config::BigEndian":"config::BigEndian","config::Configuration<E, I, L>":"config::Configuration","config::Fixint":"config::Fixint","config::Limit<N>":"config::Limit","config::LittleEndian":"config::LittleEndian","config::NoLimit":"config::NoLimit","config::Varint":"config::Varint","config::internal::Endian":"config::internal::Endian","config::internal::IntEncoding":"config::internal::IntEncoding","de::decoder::DecoderImpl<R, C>":"de::decoder::DecoderImpl","de::impl_core::collect_into_array::Guard<'a, T, N>":"de::impl_core::collect_into_array::Guard","de::read::SliceReader<'storage>":"de::read::SliceReader","enc::encoder::EncoderImpl<W, C>":"enc::encoder::EncoderImpl","enc::write::SizeWriter":"enc::write::SizeWriter","enc::write::SliceWriter<'storage>":"enc::write::SliceWriter","error::AllowedEnumVariants":"error::AllowedEnumVariants","error::DecodeError":"error::DecodeError","error::EncodeError":"error::EncodeError","error::IntegerType":"error::IntegerType","features::impl_alloc::VecWriter":"features::impl_alloc::VecWriter","features::impl_std::IoReader<R>":"features::impl_std::IoReader","features::impl_std::IoWriter<'a, W>":"features::impl_std::IoWriter"}}