-----------------
src/de.rs de::from_trait
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::from_trait":{"R":["std::marker::Sized","read::Read"],"T":["std::marker::Sized","serde::Deserialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::from_trait":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead","read::StrRead"],"T":["map::Map","number::Number","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"read::IoRead":{"R":["std::io::Take<T>","&'a std::sys::unix::fd::FileDesc","std::process::ChildStdout","std::fs::File","std::sys::unix::stdio::Stdin","std::io::StdinLock<'_>","std::collections::VecDeque<u8, A>","&std::fs::File","std::io::Repeat","std::os::unix::net::UnixStream","std::process::ChildStderr","std::boxed::Box<R>","std::io::Empty","std::io::BufReader<R>","&std::net::TcpStream","std::io::Chain<T, U>","std::io::Cursor<T>","std::net::TcpStream","std::io::Stdin","std::io::stdio::StdinRaw","std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // R
+de::from_trait(p0);
+crate::de::from_trait(p0);
+crate::de::from_trait(p0);
-----------------
src/de.rs de::from_reader
deps:{"<T as serde::de::DeserializeOwned>":{"T":["std::marker::Sized","serde::Deserialize"]},"de::from_reader":{"R":["std::marker::Sized","std::io::Read"],"T":["serde::de::DeserializeOwned","std::marker::Sized"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<T as serde::de::DeserializeOwned>":{"T":["value::Value","number::Number","map::Map"]},"de::from_reader":{"R":["std::io::stdio::StdinRaw","std::io::Take<T>","std::io::Repeat","std::fs::File","&std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::net::TcpStream","std::boxed::Box<R>","std::process::ChildStderr","std::sys::unix::stdio::Stdin","std::io::Stdin","std::io::BufReader<R>","&std::fs::File","std::io::Cursor<T>","std::io::StdinLock<'_>","&'a std::os::unix::net::UnixStream","std::io::Chain<T, U>","std::io::impls::<impl std::io::Read for &mut R>","std::os::unix::net::UnixStream","std::process::ChildStdout","std::collections::VecDeque<u8, A>","std::io::Empty"],"T":["<T as serde::de::DeserializeOwned>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // R
+de::from_reader(p0);
+crate::de::from_reader(p0);
+crate::de::from_reader(p0);
-----------------
src/de.rs de::from_slice
'a
deps:{"de::from_slice":{"T":["std::marker::Sized","serde::Deserialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"de::from_slice":{"T":["value::Value","map::Map","number::Number"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+de::from_slice(p0);
+crate::de::from_slice(p0);
+crate::de::from_slice(p0);
-----------------
src/de.rs de::from_str
'a
deps:{"de::from_str":{"T":["std::marker::Sized","serde::Deserialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"de::from_str":{"T":["number::Number","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = "sample"; // None+&str
+de::from_str(&p0);
+crate::de::from_str(&p0);
+crate::de::from_str(&p0);
-----------------
src/error.rs error::make_error
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+error::make_error(p0);
+crate::error::make_error(p0);
+crate::error::make_error(p0);
-----------------
src/error.rs error::parse_line_col
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+std::string::String
+error::parse_line_col(p0);
+crate::error::parse_line_col(p0);
+crate::error::parse_line_col(p0);
-----------------
src/error.rs error::starts_with_digit
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+error::starts_with_digit(&p0);
+crate::error::starts_with_digit(&p0);
+crate::error::starts_with_digit(&p0);
-----------------
src/ser.rs ser::key_must_be_a_string
deps:{}
candidates:{}
+ser::key_must_be_a_string();
+crate::ser::key_must_be_a_string();
+crate::ser::key_must_be_a_string();
-----------------
src/ser.rs ser::format_escaped_str
deps:{"ser::format_escaped_str":{"F":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::format_escaped_str":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // F
let mut p2 = "sample"; // None+&str
+ser::format_escaped_str(p0, p1, &p2);
+crate::ser::format_escaped_str(p0, p1, &p2);
+crate::ser::format_escaped_str(p0, p1, &p2);
-----------------
src/ser.rs ser::format_escaped_str_contents
deps:{"ser::format_escaped_str_contents":{"F":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::format_escaped_str_contents":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // F
let mut p2 = "sample"; // None+&str
+ser::format_escaped_str_contents(p0, p1, &p2);
+crate::ser::format_escaped_str_contents(p0, p1, &p2);
+crate::ser::format_escaped_str_contents(p0, p1, &p2);
-----------------
src/ser.rs ser::to_writer
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"ser::to_writer":{"T":["serde::Serialize"],"W":["std::marker::Sized","std::io::Write"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"ser::to_writer":{"T":["number::Number","map::Map","serde::ser::impls::<impl serde::Serialize for &'a T>","value::Value"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // W
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+ser::to_writer(p0, p1);
+crate::ser::to_writer(p0, p1);
+crate::ser::to_writer(p0, p1);
-----------------
src/ser.rs ser::to_writer_pretty
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"ser::to_writer_pretty":{"T":["serde::Serialize"],"W":["std::marker::Sized","std::io::Write"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"ser::to_writer_pretty":{"T":["value::Value","map::Map","serde::ser::impls::<impl serde::Serialize for &'a T>","number::Number"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // W
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+ser::to_writer_pretty(p0, p1);
+crate::ser::to_writer_pretty(p0, p1);
+crate::ser::to_writer_pretty(p0, p1);
-----------------
src/ser.rs ser::to_vec
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"ser::to_vec":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"ser::to_vec":{"T":["value::Value","serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","number::Number"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
+ser::to_vec(p0);
+crate::ser::to_vec(p0);
+crate::ser::to_vec(p0);
-----------------
src/ser.rs ser::to_vec_pretty
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"ser::to_vec_pretty":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"ser::to_vec_pretty":{"T":["map::Map","value::Value","serde::ser::impls::<impl serde::Serialize for &'a T>","number::Number"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
+ser::to_vec_pretty(p0);
+crate::ser::to_vec_pretty(p0);
+crate::ser::to_vec_pretty(p0);
-----------------
src/ser.rs ser::to_string
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"ser::to_string":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"ser::to_string":{"T":["map::Map","number::Number","value::Value","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
+ser::to_string(p0);
+crate::ser::to_string(p0);
+crate::ser::to_string(p0);
-----------------
src/ser.rs ser::to_string_pretty
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"ser::to_string_pretty":{"T":["serde::Serialize"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"ser::to_string_pretty":{"T":["value::Value","number::Number","map::Map","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // T
+ser::to_string_pretty(p0);
+crate::ser::to_string_pretty(p0);
+crate::ser::to_string_pretty(p0);
-----------------
src/ser.rs ser::indent
deps:{"ser::indent":{"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::indent":{"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p1 = 0usize; // None+usize
let mut p2 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+ser::indent(p0, p1, p2);
+crate::ser::indent(p0, p1, p2);
+crate::ser::indent(p0, p1, p2);
-----------------
src/value/mod.rs <value::Value as std::fmt::Display>::fmt::io_error
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::fmt::Error
+<value::Value as std::fmt::Display>::fmt::io_error(p0);
+crate::<value::Value as std::fmt::Display>::fmt::io_error(p0);
+<value::Value>::fmt::io_error(p0);
-----------------
src/value/mod.rs value::parse_index
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+value::parse_index(&p0);
+crate::value::parse_index(&p0);
+crate::value::parse_index(&p0);
-----------------
src/value/de.rs value::de::visit_array
'de
deps:{"value::de::visit_array":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::visit_array":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+value::de::visit_array(p0, p1);
+crate::value::de::visit_array(p0, p1);
+crate::value::de::visit_array(p0, p1);
-----------------
src/value/de.rs value::de::visit_object
'de
deps:{"value::de::visit_object":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::visit_object":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+value::de::visit_object(p0, p1);
+crate::value::de::visit_object(p0, p1);
+crate::value::de::visit_object(p0, p1);
-----------------
src/value/de.rs value::de::visit_array_ref
'de
deps:{"value::de::visit_array_ref":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::visit_array_ref":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [value::Value]
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+value::de::visit_array_ref(p0, p1);
+crate::value::de::visit_array_ref(p0, p1);
+crate::value::de::visit_array_ref(p0, p1);
-----------------
src/value/de.rs value::de::visit_object_ref
'de
deps:{"value::de::visit_object_ref":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::visit_object_ref":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+value::de::visit_object_ref(p0, p1);
+crate::value::de::visit_object_ref(p0, p1);
+crate::value::de::visit_object_ref(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::eq_i64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = 0i64; // None+i64
+value::partial_eq::eq_i64(p0, p1);
+crate::value::partial_eq::eq_i64(p0, p1);
+crate::value::partial_eq::eq_i64(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::eq_u64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = 0u64; // None+u64
+value::partial_eq::eq_u64(p0, p1);
+crate::value::partial_eq::eq_u64(p0, p1);
+crate::value::partial_eq::eq_u64(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::eq_f32
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = 0f32; // None+f32
+value::partial_eq::eq_f32(p0, p1);
+crate::value::partial_eq::eq_f32(p0, p1);
+crate::value::partial_eq::eq_f32(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::eq_f64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = 0f64; // None+f64
+value::partial_eq::eq_f64(p0, p1);
+crate::value::partial_eq::eq_f64(p0, p1);
+crate::value::partial_eq::eq_f64(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::eq_bool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = true; // None+bool
+value::partial_eq::eq_bool(p0, p1);
+crate::value::partial_eq::eq_bool(p0, p1);
+crate::value::partial_eq::eq_bool(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::eq_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
+value::partial_eq::eq_str(p0, &p1);
+crate::value::partial_eq::eq_str(p0, &p1);
+crate::value::partial_eq::eq_str(p0, &p1);
-----------------
src/value/ser.rs value::ser::key_must_be_a_string
deps:{}
candidates:{}
+value::ser::key_must_be_a_string();
+crate::value::ser::key_must_be_a_string();
+crate::value::ser::key_must_be_a_string();
-----------------
src/value/mod.rs value::to_value
deps:{"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"value::to_value":{"T":["std::marker::Sized","serde::Serialize"]}}
candidates:{"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"value::to_value":{"T":["value::Value","map::Map","serde::ser::impls::<impl serde::Serialize for &'a T>","number::Number"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+value::to_value(p0);
+crate::value::to_value(p0);
+crate::value::to_value(p0);
-----------------
src/value/mod.rs value::from_value
deps:{"<T as serde::de::DeserializeOwned>":{"T":["serde::Deserialize","std::marker::Sized"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"value::from_value":{"T":["std::marker::Sized","serde::de::DeserializeOwned"]}}
candidates:{"<T as serde::de::DeserializeOwned>":{"T":["number::Number","value::Value","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"value::from_value":{"T":["<T as serde::de::DeserializeOwned>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
+value::from_value(p0);
+crate::value::from_value(p0);
+crate::value::from_value(p0);
-----------------
src/read.rs read::next_or_eof
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::next_or_eof":{"R":["read::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::os::unix::net::UnixStream","std::io::Stdin","&std::fs::File","std::fs::File","std::boxed::Box<R>","std::io::Cursor<T>","std::sys::unix::stdio::Stdin","std::process::ChildStdout","&std::net::TcpStream","std::io::Chain<T, U>","std::io::StdinLock<'_>","std::io::BufReader<R>","std::io::stdio::StdinRaw","std::io::Empty","std::net::TcpStream","std::io::Repeat","std::io::Take<T>","&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStderr","std::collections::VecDeque<u8, A>"]},"read::next_or_eof":{"R":["read::IoRead","read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
+read::next_or_eof(p0);
+crate::read::next_or_eof(p0);
+crate::read::next_or_eof(p0);
-----------------
src/read.rs read::peek_or_eof
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::peek_or_eof":{"R":["read::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::boxed::Box<R>","std::io::Empty","std::process::ChildStderr","std::io::StdinLock<'_>","std::io::BufReader<R>","std::os::unix::net::UnixStream","std::io::Cursor<T>","std::io::Chain<T, U>","&'a std::os::unix::net::UnixStream","std::process::ChildStdout","std::io::Stdin","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream","std::net::TcpStream","std::collections::VecDeque<u8, A>","std::io::stdio::StdinRaw","std::fs::File","std::io::Repeat","&std::fs::File","std::sys::unix::stdio::Stdin","std::io::Take<T>","&'a std::sys::unix::fd::FileDesc"]},"read::peek_or_eof":{"R":["read::SliceRead","read::StrRead","read::IoRead","<&'a mut R as read::Read<'de>>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
+read::peek_or_eof(p0);
+crate::read::peek_or_eof(p0);
+crate::read::peek_or_eof(p0);
-----------------
src/read.rs read::error
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::error":{"R":["read::Read"],"T":["std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["&std::fs::File","std::io::Repeat","std::io::Stdin","std::process::ChildStderr","&'a std::os::unix::net::UnixStream","std::process::ChildStdout","std::sys::unix::stdio::Stdin","std::io::StdinLock<'_>","&std::net::TcpStream","std::io::stdio::StdinRaw","std::io::Empty","std::io::Chain<T, U>","std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::io::Take<T>","&'a std::sys::unix::fd::FileDesc","std::io::Cursor<T>","std::io::BufReader<R>","std::boxed::Box<R>","std::fs::File","std::collections::VecDeque<u8, A>","std::os::unix::net::UnixStream"]},"read::error":{"R":["read::StrRead","read::IoRead","<&'a mut R as read::Read<'de>>","read::SliceRead"],"T":["RUG_ANY"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // R
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorCode
+read::error(p0, p1);
+crate::read::error(p0, p1);
+crate::read::error(p0, p1);
-----------------
src/read.rs read::as_str
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::as_str":{"R":["std::marker::Sized","read::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["&std::net::TcpStream","std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","std::io::Repeat","std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStderr","&'a std::os::unix::net::UnixStream","std::io::BufReader<R>","std::io::Cursor<T>","&std::fs::File","&'a std::sys::unix::fd::FileDesc","std::io::Stdin","std::io::StdinLock<'_>","std::sys::unix::stdio::Stdin","std::collections::VecDeque<u8, A>","std::net::TcpStream","std::boxed::Box<R>","std::io::Chain<T, U>","std::process::ChildStdout","std::io::Empty","std::io::Take<T>"]},"read::as_str":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::IoRead"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // R
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+read::as_str(p0, p1);
+crate::read::as_str(p0, p1);
+crate::read::as_str(p0, p1);
-----------------
src/read.rs read::parse_escape
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::parse_escape":{"R":["std::marker::Sized","read::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["&'a std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","&std::net::TcpStream","std::io::BufReader<R>","std::io::Cursor<T>","std::io::StdinLock<'_>","std::io::Stdin","std::io::Empty","std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::boxed::Box<R>","&std::fs::File","std::io::Chain<T, U>","std::io::Take<T>","std::fs::File","std::process::ChildStderr","std::collections::VecDeque<u8, A>","std::process::ChildStdout","std::io::Repeat"]},"read::parse_escape":{"R":["read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
let mut p1 = true; // None+bool
let mut p2 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+read::parse_escape(p0, p1, p2);
+crate::read::parse_escape(p0, p1, p2);
+crate::read::parse_escape(p0, p1, p2);
-----------------
src/read.rs read::parse_escape::encode_surrogate
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
let mut p1 = 0u16; // None+u16
+read::parse_escape::encode_surrogate(p0, p1);
+crate::read::parse_escape::encode_surrogate(p0, p1);
+crate::read::parse_escape::encode_surrogate(p0, p1);
-----------------
src/read.rs read::ignore_escape
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::ignore_escape":{"R":["read::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::io::impls::<impl std::io::Read for &mut R>","std::sys::unix::stdio::Stdin","std::io::Stdin","std::process::ChildStderr","std::io::Cursor<T>","std::io::Repeat","std::net::TcpStream","std::process::ChildStdout","std::collections::VecDeque<u8, A>","std::io::BufReader<R>","std::io::Chain<T, U>","&'a std::sys::unix::fd::FileDesc","std::boxed::Box<R>","&'a std::os::unix::net::UnixStream","&std::net::TcpStream","std::os::unix::net::UnixStream","&std::fs::File","std::io::StdinLock<'_>","std::io::stdio::StdinRaw","std::fs::File","std::io::Take<T>","std::io::Empty"]},"read::ignore_escape":{"R":["read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::SliceRead"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // R
+read::ignore_escape(p0);
+crate::read::ignore_escape(p0);
+crate::read::ignore_escape(p0);
-----------------
src/read.rs read::decode_hex_val
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+read::decode_hex_val(p0);
+crate::read::decode_hex_val(p0);
+crate::read::decode_hex_val(p0);
-----------------
src/ser.rs ser::Formatter::write_null
deps:{"ser::Formatter::write_null":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_null":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.write_null(p1);
+ser::Formatter::write_null(p0, p1);
+crate::ser::Formatter::write_null(p0, p1);
+crate::ser::Formatter::write_null(p0, p1);
-----------------
src/ser.rs ser::Formatter::write_bool
deps:{"ser::Formatter::write_bool":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_bool":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = true; // None+bool
+p0.write_bool(p1, p2);
+ser::Formatter::write_bool(p0, p1, p2);
+crate::ser::Formatter::write_bool(p0, p1, p2);
+crate::ser::Formatter::write_bool(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_i8
deps:{"ser::Formatter::write_i8":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_i8":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = 0i8; // None+i8
+p0.write_i8(p1, p2);
+ser::Formatter::write_i8(p0, p1, p2);
+crate::ser::Formatter::write_i8(p0, p1, p2);
+crate::ser::Formatter::write_i8(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_i16
deps:{"ser::Formatter::write_i16":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_i16":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = 0i16; // None+i16
+p0.write_i16(p1, p2);
+ser::Formatter::write_i16(p0, p1, p2);
+crate::ser::Formatter::write_i16(p0, p1, p2);
+crate::ser::Formatter::write_i16(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_i32
deps:{"ser::Formatter::write_i32":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_i32":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = 0i32; // None+i32
+p0.write_i32(p1, p2);
+ser::Formatter::write_i32(p0, p1, p2);
+crate::ser::Formatter::write_i32(p0, p1, p2);
+crate::ser::Formatter::write_i32(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_i64
deps:{"ser::Formatter::write_i64":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_i64":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = 0i64; // None+i64
+p0.write_i64(p1, p2);
+ser::Formatter::write_i64(p0, p1, p2);
+crate::ser::Formatter::write_i64(p0, p1, p2);
+crate::ser::Formatter::write_i64(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_i128
deps:{"ser::Formatter::write_i128":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_i128":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = 0i128; // None+i128
+p0.write_i128(p1, p2);
+ser::Formatter::write_i128(p0, p1, p2);
+crate::ser::Formatter::write_i128(p0, p1, p2);
+crate::ser::Formatter::write_i128(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_u8
deps:{"ser::Formatter::write_u8":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_u8":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = 0u8; // None+u8
+p0.write_u8(p1, p2);
+ser::Formatter::write_u8(p0, p1, p2);
+crate::ser::Formatter::write_u8(p0, p1, p2);
+crate::ser::Formatter::write_u8(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_u16
deps:{"ser::Formatter::write_u16":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_u16":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = 0u16; // None+u16
+p0.write_u16(p1, p2);
+ser::Formatter::write_u16(p0, p1, p2);
+crate::ser::Formatter::write_u16(p0, p1, p2);
+crate::ser::Formatter::write_u16(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_u32
deps:{"ser::Formatter::write_u32":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_u32":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = 0u32; // None+u32
+p0.write_u32(p1, p2);
+ser::Formatter::write_u32(p0, p1, p2);
+crate::ser::Formatter::write_u32(p0, p1, p2);
+crate::ser::Formatter::write_u32(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_u64
deps:{"ser::Formatter::write_u64":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_u64":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = 0u64; // None+u64
+p0.write_u64(p1, p2);
+ser::Formatter::write_u64(p0, p1, p2);
+crate::ser::Formatter::write_u64(p0, p1, p2);
+crate::ser::Formatter::write_u64(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_u128
deps:{"ser::Formatter::write_u128":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_u128":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = 0u128; // None+u128
+p0.write_u128(p1, p2);
+ser::Formatter::write_u128(p0, p1, p2);
+crate::ser::Formatter::write_u128(p0, p1, p2);
+crate::ser::Formatter::write_u128(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_f32
deps:{"ser::Formatter::write_f32":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_f32":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = 0f32; // None+f32
+p0.write_f32(p1, p2);
+ser::Formatter::write_f32(p0, p1, p2);
+crate::ser::Formatter::write_f32(p0, p1, p2);
+crate::ser::Formatter::write_f32(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_f64
deps:{"ser::Formatter::write_f64":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_f64":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = 0f64; // None+f64
+p0.write_f64(p1, p2);
+ser::Formatter::write_f64(p0, p1, p2);
+crate::ser::Formatter::write_f64(p0, p1, p2);
+crate::ser::Formatter::write_f64(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::write_number_str
deps:{"ser::Formatter::write_number_str":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_number_str":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = "sample"; // None+&str
+p0.write_number_str(p1, &p2);
+ser::Formatter::write_number_str(p0, p1, &p2);
+crate::ser::Formatter::write_number_str(p0, p1, &p2);
+crate::ser::Formatter::write_number_str(p0, p1, &p2);
-----------------
src/ser.rs ser::Formatter::begin_string
deps:{"ser::Formatter::begin_string":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::begin_string":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.begin_string(p1);
+ser::Formatter::begin_string(p0, p1);
+crate::ser::Formatter::begin_string(p0, p1);
+crate::ser::Formatter::begin_string(p0, p1);
-----------------
src/ser.rs ser::Formatter::end_string
deps:{"ser::Formatter::end_string":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::end_string":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.end_string(p1);
+ser::Formatter::end_string(p0, p1);
+crate::ser::Formatter::end_string(p0, p1);
+crate::ser::Formatter::end_string(p0, p1);
-----------------
src/ser.rs ser::Formatter::write_string_fragment
deps:{"ser::Formatter::write_string_fragment":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_string_fragment":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = "sample"; // None+&str
+p0.write_string_fragment(p1, &p2);
+ser::Formatter::write_string_fragment(p0, p1, &p2);
+crate::ser::Formatter::write_string_fragment(p0, p1, &p2);
+crate::ser::Formatter::write_string_fragment(p0, p1, &p2);
-----------------
src/ser.rs ser::Formatter::write_char_escape
deps:{"ser::Formatter::write_char_escape":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_char_escape":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = MaybeUninit::uninit().assume_init(); // ser::CharEscape
+p0.write_char_escape(p1, p2);
+ser::Formatter::write_char_escape(p0, p1, p2);
+crate::ser::Formatter::write_char_escape(p0, p1, p2);
+crate::ser::Formatter::write_char_escape(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::begin_array
deps:{"ser::Formatter::begin_array":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::begin_array":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.begin_array(p1);
+ser::Formatter::begin_array(p0, p1);
+crate::ser::Formatter::begin_array(p0, p1);
+crate::ser::Formatter::begin_array(p0, p1);
-----------------
src/ser.rs ser::Formatter::end_array
deps:{"ser::Formatter::end_array":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::end_array":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.end_array(p1);
+ser::Formatter::end_array(p0, p1);
+crate::ser::Formatter::end_array(p0, p1);
+crate::ser::Formatter::end_array(p0, p1);
-----------------
src/ser.rs ser::Formatter::begin_array_value
deps:{"ser::Formatter::begin_array_value":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::begin_array_value":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = true; // None+bool
+p0.begin_array_value(p1, p2);
+ser::Formatter::begin_array_value(p0, p1, p2);
+crate::ser::Formatter::begin_array_value(p0, p1, p2);
+crate::ser::Formatter::begin_array_value(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::end_array_value
deps:{"ser::Formatter::end_array_value":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::end_array_value":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.end_array_value(p1);
+ser::Formatter::end_array_value(p0, p1);
+crate::ser::Formatter::end_array_value(p0, p1);
+crate::ser::Formatter::end_array_value(p0, p1);
-----------------
src/ser.rs ser::Formatter::begin_object
deps:{"ser::Formatter::begin_object":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::begin_object":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.begin_object(p1);
+ser::Formatter::begin_object(p0, p1);
+crate::ser::Formatter::begin_object(p0, p1);
+crate::ser::Formatter::begin_object(p0, p1);
-----------------
src/ser.rs ser::Formatter::end_object
deps:{"ser::Formatter::end_object":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::end_object":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.end_object(p1);
+ser::Formatter::end_object(p0, p1);
+crate::ser::Formatter::end_object(p0, p1);
+crate::ser::Formatter::end_object(p0, p1);
-----------------
src/ser.rs ser::Formatter::begin_object_key
deps:{"ser::Formatter::begin_object_key":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::begin_object_key":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = true; // None+bool
+p0.begin_object_key(p1, p2);
+ser::Formatter::begin_object_key(p0, p1, p2);
+crate::ser::Formatter::begin_object_key(p0, p1, p2);
+crate::ser::Formatter::begin_object_key(p0, p1, p2);
-----------------
src/ser.rs ser::Formatter::end_object_key
deps:{"ser::Formatter::end_object_key":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::end_object_key":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.end_object_key(p1);
+ser::Formatter::end_object_key(p0, p1);
+crate::ser::Formatter::end_object_key(p0, p1);
+crate::ser::Formatter::end_object_key(p0, p1);
-----------------
src/ser.rs ser::Formatter::begin_object_value
deps:{"ser::Formatter::begin_object_value":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::begin_object_value":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.begin_object_value(p1);
+ser::Formatter::begin_object_value(p0, p1);
+crate::ser::Formatter::begin_object_value(p0, p1);
+crate::ser::Formatter::begin_object_value(p0, p1);
-----------------
src/ser.rs ser::Formatter::end_object_value
deps:{"ser::Formatter::end_object_value":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::end_object_value":{"Self":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.end_object_value(p1);
+ser::Formatter::end_object_value(p0, p1);
+crate::ser::Formatter::end_object_value(p0, p1);
+crate::ser::Formatter::end_object_value(p0, p1);
-----------------
src/ser.rs ser::Formatter::write_raw_fragment
deps:{"ser::Formatter::write_raw_fragment":{"Self":["ser::Formatter"],"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Formatter::write_raw_fragment":{"Self":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = "sample"; // None+&str
+p0.write_raw_fragment(p1, &p2);
+ser::Formatter::write_raw_fragment(p0, p1, &p2);
+crate::ser::Formatter::write_raw_fragment(p0, p1, &p2);
+crate::ser::Formatter::write_raw_fragment(p0, p1, &p2);
-----------------
src/value/index.rs value::index::Index::index_into
deps:{"<&'a T as value::index::Index>":{},"<&'a T as value::index::private::Sealed>":{},"value::index::Index::index_into":{"Self":["value::index::Index","value::index::private::Sealed"]}}
candidates:{"<&'a T as value::index::Index>":{},"<&'a T as value::index::private::Sealed>":{},"value::index::Index::index_into":{"Self":["std::string::String","<&'a T as value::index::private::Sealed>","<&'a T as value::index::Index>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_into(p1);
+value::index::Index::index_into(p0, p1);
+crate::value::index::Index::index_into(p0, p1);
+crate::value::index::Index::index_into(p0, p1);
-----------------
src/value/index.rs value::index::Index::index_into_mut
deps:{"<&'a T as value::index::Index>":{},"value::index::Index::index_into_mut":{"Self":["value::index::Index","value::index::private::Sealed"]}}
candidates:{"<&'a T as value::index::Index>":{},"value::index::Index::index_into_mut":{"Self":["std::string::String","<&'a T as value::index::Index>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_into_mut(p1);
+value::index::Index::index_into_mut(p0, p1);
+crate::value::index::Index::index_into_mut(p0, p1);
+crate::value::index::Index::index_into_mut(p0, p1);
-----------------
src/value/index.rs value::index::Index::index_or_insert
deps:{"<&'a T as value::index::Index>":{},"value::index::Index::index_or_insert":{"Self":["value::index::Index","value::index::private::Sealed"]}}
candidates:{"<&'a T as value::index::Index>":{},"value::index::Index::index_or_insert":{"Self":["std::string::String","<&'a T as value::index::Index>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_or_insert(p1);
+value::index::Index::index_or_insert(p0, p1);
+crate::value::index::Index::index_or_insert(p0, p1);
+crate::value::index::Index::index_or_insert(p0, p1);
-----------------
src/read.rs read::Read::next
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::Read::next":{"Self":["read::Read","read::private::Sealed"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["std::io::Cursor<T>","std::collections::VecDeque<u8, A>","std::io::Chain<T, U>","std::boxed::Box<R>","std::io::Stdin","&'a std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::io::BufReader<R>","std::net::TcpStream","std::process::ChildStdout","&'a std::sys::unix::fd::FileDesc","&std::fs::File","std::process::ChildStderr","std::io::impls::<impl std::io::Read for &mut R>","std::fs::File","&std::net::TcpStream","std::io::Repeat","std::os::unix::net::UnixStream","std::io::Take<T>","std::io::Empty","std::io::StdinLock<'_>","std::io::stdio::StdinRaw"]},"read::Read::next":{"Self":["read::IoRead","read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::<impl read::private::Sealed for &'a mut R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.next();
+read::Read::next(p0);
+crate::read::Read::next(p0);
+crate::read::Read::next(p0);
-----------------
src/read.rs read::Read::peek
'de
deps:{"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::Read::peek":{"Self":["read::Read","read::private::Sealed"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["&'a std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::io::Cursor<T>","std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","std::fs::File","std::process::ChildStderr","std::io::Stdin","&std::net::TcpStream","&std::fs::File","std::io::Empty","std::io::BufReader<R>","std::process::ChildStdout","std::boxed::Box<R>","std::sys::unix::stdio::Stdin","&'a std::sys::unix::fd::FileDesc","std::io::impls::<impl std::io::Read for &mut R>","std::io::Repeat","std::io::Chain<T, U>","std::io::StdinLock<'_>","std::net::TcpStream","std::io::Take<T>"]},"read::Read::peek":{"Self":["read::<impl read::private::Sealed for &'a mut R>","read::StrRead","read::SliceRead","read::IoRead"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.peek();
+read::Read::peek(p0);
+crate::read::Read::peek(p0);
+crate::read::Read::peek(p0);
-----------------
src/read.rs read::Read::discard
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::Read::discard":{"Self":["read::private::Sealed","read::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["std::io::StdinLock<'_>","&std::net::TcpStream","&'a std::os::unix::net::UnixStream","std::io::Repeat","std::process::ChildStderr","std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::fs::File","std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","&std::fs::File","std::io::Stdin","std::process::ChildStdout","std::io::Chain<T, U>","std::io::Empty","std::io::Cursor<T>","std::io::stdio::StdinRaw","std::io::BufReader<R>","std::io::Take<T>","std::sys::unix::stdio::Stdin","std::boxed::Box<R>","std::collections::VecDeque<u8, A>"]},"read::Read::discard":{"Self":["read::IoRead","read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::<impl read::private::Sealed for &'a mut R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.discard();
+read::Read::discard(p0);
+crate::read::Read::discard(p0);
+crate::read::Read::discard(p0);
-----------------
src/read.rs read::Read::position
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::Read::position":{"Self":["read::private::Sealed","read::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["&'a std::sys::unix::fd::FileDesc","std::fs::File","std::process::ChildStderr","std::os::unix::net::UnixStream","std::io::impls::<impl std::io::Read for &mut R>","std::io::stdio::StdinRaw","&std::fs::File","std::io::Stdin","std::sys::unix::stdio::Stdin","std::io::Cursor<T>","std::io::Chain<T, U>","std::io::BufReader<R>","&'a std::os::unix::net::UnixStream","std::net::TcpStream","std::process::ChildStdout","std::io::StdinLock<'_>","&std::net::TcpStream","std::boxed::Box<R>","std::io::Empty","std::io::Repeat","std::collections::VecDeque<u8, A>","std::io::Take<T>"]},"read::Read::position":{"Self":["<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead","read::StrRead"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.position();
+read::Read::position(p0);
+crate::read::Read::position(p0);
+crate::read::Read::position(p0);
-----------------
src/read.rs read::Read::peek_position
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::Read::peek_position":{"Self":["read::Read","read::private::Sealed"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["&std::net::TcpStream","std::boxed::Box<R>","std::sys::unix::stdio::Stdin","std::io::stdio::StdinRaw","&std::fs::File","std::process::ChildStdout","std::process::ChildStderr","std::io::Empty","std::net::TcpStream","std::fs::File","std::io::Repeat","std::collections::VecDeque<u8, A>","std::os::unix::net::UnixStream","std::io::Stdin","std::io::BufReader<R>","std::io::StdinLock<'_>","std::io::impls::<impl std::io::Read for &mut R>","std::io::Take<T>","std::io::Cursor<T>","&'a std::sys::unix::fd::FileDesc","std::io::Chain<T, U>","&'a std::os::unix::net::UnixStream"]},"read::Read::peek_position":{"Self":["read::IoRead","read::StrRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::<impl read::private::Sealed for &'a mut R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.peek_position();
+read::Read::peek_position(p0);
+crate::read::Read::peek_position(p0);
+crate::read::Read::peek_position(p0);
-----------------
src/read.rs read::Read::byte_offset
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"read::Read::byte_offset":{"Self":["read::private::Sealed","read::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["std::io::Take<T>","std::io::Cursor<T>","std::boxed::Box<R>","std::net::TcpStream","std::io::BufReader<R>","std::sys::unix::stdio::Stdin","std::io::Repeat","std::io::impls::<impl std::io::Read for &mut R>","&'a std::sys::unix::fd::FileDesc","std::io::stdio::StdinRaw","std::io::Empty","std::process::ChildStderr","&std::net::TcpStream","std::os::unix::net::UnixStream","std::io::Stdin","&'a std::os::unix::net::UnixStream","std::fs::File","&std::fs::File","std::process::ChildStdout","std::io::StdinLock<'_>","std::collections::VecDeque<u8, A>","std::io::Chain<T, U>"]},"read::Read::byte_offset":{"Self":["read::SliceRead","read::<impl read::private::Sealed for &'a mut R>","<&'a mut R as read::Read<'de>>","read::IoRead","read::StrRead"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // Self
+p0.byte_offset();
+read::Read::byte_offset(p0);
+crate::read::Read::byte_offset(p0);
+crate::read::Read::byte_offset(p0);
-----------------
src/read.rs read::Read::parse_str
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::Read::parse_str":{"Self":["read::private::Sealed","read::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["&'a std::os::unix::net::UnixStream","std::io::Empty","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStderr","std::io::Take<T>","std::io::Repeat","std::fs::File","std::io::Cursor<T>","std::io::StdinLock<'_>","std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","std::io::BufReader<R>","std::io::Chain<T, U>","std::net::TcpStream","&std::fs::File","&std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::boxed::Box<R>","std::collections::VecDeque<u8, A>","std::io::Stdin","std::sys::unix::stdio::Stdin","std::process::ChildStdout"]},"read::Read::parse_str":{"Self":["read::<impl read::private::Sealed for &'a mut R>","read::IoRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.parse_str(p1);
+read::Read::parse_str(p0, p1);
+crate::read::Read::parse_str(p0, p1);
+crate::read::Read::parse_str(p0, p1);
-----------------
src/read.rs read::Read::parse_str_raw
'de
deps:{"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::Read::parse_str_raw":{"Self":["read::Read","read::private::Sealed"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["std::io::Repeat","&'a std::sys::unix::fd::FileDesc","&std::net::TcpStream","std::io::Chain<T, U>","std::io::stdio::StdinRaw","std::io::Cursor<T>","std::io::Stdin","std::process::ChildStdout","std::io::BufReader<R>","std::io::impls::<impl std::io::Read for &mut R>","std::io::StdinLock<'_>","std::net::TcpStream","std::process::ChildStderr","&'a std::os::unix::net::UnixStream","std::io::Empty","std::fs::File","std::os::unix::net::UnixStream","std::io::Take<T>","&std::fs::File","std::boxed::Box<R>","std::collections::VecDeque<u8, A>","std::sys::unix::stdio::Stdin"]},"read::Read::parse_str_raw":{"Self":["read::StrRead","read::<impl read::private::Sealed for &'a mut R>","read::SliceRead","read::IoRead"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.parse_str_raw(p1);
+read::Read::parse_str_raw(p0, p1);
+crate::read::Read::parse_str_raw(p0, p1);
+crate::read::Read::parse_str_raw(p0, p1);
-----------------
src/read.rs read::Read::ignore_str
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"read::Read::ignore_str":{"Self":["read::private::Sealed","read::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::sys::unix::stdio::Stdin","std::io::Take<T>","&std::fs::File","std::io::Stdin","&'a std::sys::unix::fd::FileDesc","std::io::Repeat","std::io::Empty","std::io::BufReader<R>","std::fs::File","std::io::Chain<T, U>","std::collections::VecDeque<u8, A>","std::process::ChildStderr","std::os::unix::net::UnixStream","std::io::stdio::StdinRaw","std::io::StdinLock<'_>","&'a std::os::unix::net::UnixStream","&std::net::TcpStream","std::boxed::Box<R>","std::io::impls::<impl std::io::Read for &mut R>","std::io::Cursor<T>","std::net::TcpStream","std::process::ChildStdout"]},"read::Read::ignore_str":{"Self":["<&'a mut R as read::Read<'de>>","read::StrRead","read::IoRead","read::SliceRead"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.ignore_str();
+read::Read::ignore_str(p0);
+crate::read::Read::ignore_str(p0);
+crate::read::Read::ignore_str(p0);
-----------------
src/read.rs read::Read::decode_hex_escape
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::Read::decode_hex_escape":{"Self":["read::Read","read::private::Sealed"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::IoRead":{"R":["&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::boxed::Box<R>","std::io::BufReader<R>","std::io::Empty","std::process::ChildStderr","std::io::Stdin","&std::net::TcpStream","std::io::Cursor<T>","std::io::stdio::StdinRaw","std::io::StdinLock<'_>","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStdout","&std::fs::File","std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::fs::File","std::sys::unix::stdio::Stdin","std::io::Chain<T, U>","std::io::Take<T>","std::net::TcpStream","std::io::Repeat"]},"read::Read::decode_hex_escape":{"Self":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead","read::StrRead"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
+p0.decode_hex_escape();
+read::Read::decode_hex_escape(p0);
+crate::read::Read::decode_hex_escape(p0);
+crate::read::Read::decode_hex_escape(p0);
-----------------
src/read.rs read::Read::set_failed
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"read::Read::set_failed":{"Self":["read::private::Sealed","read::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"read::<impl read::private::Sealed for &'a mut R>":{},"read::IoRead":{"R":["&std::fs::File","std::process::ChildStderr","std::sys::unix::stdio::Stdin","std::fs::File","&'a std::sys::unix::fd::FileDesc","&std::net::TcpStream","std::os::unix::net::UnixStream","std::io::StdinLock<'_>","std::io::Cursor<T>","&'a std::os::unix::net::UnixStream","std::io::Repeat","std::net::TcpStream","std::io::Empty","std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","std::boxed::Box<R>","std::io::BufReader<R>","std::io::Stdin","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStdout","std::io::Chain<T, U>","std::io::Take<T>"]},"read::Read::set_failed":{"Self":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::IoRead","read::StrRead","read::<impl read::private::Sealed for &'a mut R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // Self
let mut p1 = &mut true; // None+bool
+p0.set_failed(p1);
+read::Read::set_failed(p0, p1);
+crate::read::Read::set_failed(p0, p1);
+crate::read::Read::set_failed(p0, p1);
-----------------
src/de.rs de::Deserializer::<R>::new
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::new":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::new":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead","read::StrRead"]},"read::IoRead":{"R":["std::io::StdinLock<'_>","&std::net::TcpStream","&std::fs::File","std::io::Chain<T, U>","std::net::TcpStream","std::os::unix::net::UnixStream","std::boxed::Box<R>","std::io::Repeat","std::io::BufReader<R>","&'a std::os::unix::net::UnixStream","std::io::stdio::StdinRaw","std::process::ChildStderr","std::sys::unix::stdio::Stdin","std::fs::File","std::collections::VecDeque<u8, A>","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStdout","std::io::Cursor<T>","std::io::Stdin","std::io::Empty","&'a std::sys::unix::fd::FileDesc","std::io::Take<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // R
+de::Deserializer::<R>::new(p0);
+crate::de::Deserializer::<R>::new(p0);
+<de::Deserializer<R>>::new(p0);
-----------------
src/de.rs de::Deserializer::<read::IoRead<R>>::from_reader
deps:{"de::Deserializer::<read::IoRead<R>>::from_reader":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"de::Deserializer::<read::IoRead<R>>::from_reader":{"R":["&'a std::sys::unix::fd::FileDesc","std::io::Stdin","std::collections::VecDeque<u8, A>","std::io::Chain<T, U>","std::io::Take<T>","&'a std::os::unix::net::UnixStream","std::io::Repeat","std::io::BufReader<R>","std::net::TcpStream","&std::net::TcpStream","std::sys::unix::stdio::Stdin","std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","std::io::StdinLock<'_>","std::os::unix::net::UnixStream","&std::fs::File","std::io::Cursor<T>","std::boxed::Box<R>","std::process::ChildStdout","std::io::stdio::StdinRaw","std::io::Empty","std::process::ChildStderr"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // R
+de::Deserializer::<read::IoRead<R>>::from_reader(p0);
+crate::de::Deserializer::<read::IoRead<R>>::from_reader(p0);
+<de::Deserializer<read::IoRead<R>>>::from_reader(p0);
-----------------
src/de.rs de::Deserializer::<read::SliceRead<'a>>::from_slice
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+de::Deserializer::<read::SliceRead<'a>>::from_slice(p0);
+crate::de::Deserializer::<read::SliceRead<'a>>::from_slice(p0);
+<de::Deserializer<read::SliceRead<'a>>>::from_slice(p0);
-----------------
src/de.rs de::Deserializer::<read::StrRead<'a>>::from_str
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+de::Deserializer::<read::StrRead<'a>>::from_str(&p0);
+crate::de::Deserializer::<read::StrRead<'a>>::from_str(&p0);
+<de::Deserializer<read::StrRead<'a>>>::from_str(&p0);
-----------------
src/de.rs de::ParserNumber::visit
'de
deps:{"de::ParserNumber::visit":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"de::ParserNumber::visit":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ParserNumber
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.visit(p1);
+de::ParserNumber::visit(p0, p1);
+crate::de::ParserNumber::visit(p0, p1);
+<de::ParserNumber>::visit(p0, p1);
-----------------
src/de.rs de::ParserNumber::invalid_type
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ParserNumber
let mut p1 = & MaybeUninit::uninit().assume_init(); // dyn serde::de::Expected
+p0.invalid_type(p1);
+de::ParserNumber::invalid_type(p0, p1);
+crate::de::ParserNumber::invalid_type(p0, p1);
+<de::ParserNumber>::invalid_type(p0, p1);
-----------------
src/de.rs de::Deserializer::<R>::end
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::end":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::end":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::IoRead","read::StrRead"]},"read::IoRead":{"R":["std::sys::unix::stdio::Stdin","std::io::Cursor<T>","std::net::TcpStream","std::process::ChildStdout","std::io::impls::<impl std::io::Read for &mut R>","std::io::Repeat","std::boxed::Box<R>","std::io::BufReader<R>","std::process::ChildStderr","&'a std::os::unix::net::UnixStream","&std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::io::Take<T>","std::fs::File","std::io::Stdin","std::io::Empty","std::io::Chain<T, U>","std::io::StdinLock<'_>","std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","std::os::unix::net::UnixStream","&std::fs::File"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.end();
+de::Deserializer::<R>::end(p0);
+crate::de::Deserializer::<R>::end(p0);
+<de::Deserializer<R>>::end(p0);
-----------------
src/de.rs de::Deserializer::<R>::into_iter
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::into_iter":{"R":["read::Read","std::marker::Sized"],"T":["std::marker::Sized","serde::Deserialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::into_iter":{"R":["read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead"],"T":["map::Map","value::Value","number::Number"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"read::IoRead":{"R":["std::io::Repeat","std::io::impls::<impl std::io::Read for &mut R>","std::net::TcpStream","&'a std::os::unix::net::UnixStream","std::io::Stdin","std::sys::unix::stdio::Stdin","std::io::Chain<T, U>","std::io::Empty","std::process::ChildStderr","&'a std::sys::unix::fd::FileDesc","std::io::StdinLock<'_>","std::os::unix::net::UnixStream","&std::fs::File","std::io::Take<T>","std::fs::File","std::boxed::Box<R>","std::collections::VecDeque<u8, A>","std::io::stdio::StdinRaw","std::io::BufReader<R>","std::io::Cursor<T>","&std::net::TcpStream","std::process::ChildStdout"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.into_iter();
+de::Deserializer::<R>::into_iter(p0);
+crate::de::Deserializer::<R>::into_iter(p0);
+<de::Deserializer<R>>::into_iter(p0);
-----------------
src/de.rs de::Deserializer::<R>::peek
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::peek":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::peek":{"R":["<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead","read::StrRead"]},"read::IoRead":{"R":["std::io::StdinLock<'_>","std::io::Chain<T, U>","std::io::Stdin","std::io::Take<T>","std::sys::unix::stdio::Stdin","std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::os::unix::net::UnixStream","std::io::Empty","std::process::ChildStdout","std::io::BufReader<R>","std::boxed::Box<R>","std::process::ChildStderr","std::collections::VecDeque<u8, A>","&std::fs::File","std::io::Repeat","&std::net::TcpStream","std::io::stdio::StdinRaw","std::net::TcpStream","std::fs::File","std::io::Cursor<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.peek();
+de::Deserializer::<R>::peek(p0);
+crate::de::Deserializer::<R>::peek(p0);
+<de::Deserializer<R>>::peek(p0);
-----------------
src/de.rs de::Deserializer::<R>::peek_or_null
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::peek_or_null":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::peek_or_null":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"]},"read::IoRead":{"R":["std::io::Cursor<T>","std::io::Empty","std::process::ChildStderr","std::io::stdio::StdinRaw","std::io::Repeat","std::collections::VecDeque<u8, A>","std::io::Chain<T, U>","std::io::StdinLock<'_>","std::io::BufReader<R>","std::boxed::Box<R>","std::os::unix::net::UnixStream","std::process::ChildStdout","&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::fs::File","std::sys::unix::stdio::Stdin","&std::fs::File","std::io::Take<T>","&std::net::TcpStream","std::net::TcpStream","std::io::Stdin","std::io::impls::<impl std::io::Read for &mut R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.peek_or_null();
+de::Deserializer::<R>::peek_or_null(p0);
+crate::de::Deserializer::<R>::peek_or_null(p0);
+<de::Deserializer<R>>::peek_or_null(p0);
-----------------
src/de.rs de::Deserializer::<R>::eat_char
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::eat_char":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::eat_char":{"R":["read::IoRead","read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>"]},"read::IoRead":{"R":["std::io::Cursor<T>","&std::net::TcpStream","&std::fs::File","std::io::Stdin","&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::io::impls::<impl std::io::Read for &mut R>","std::io::Chain<T, U>","std::io::BufReader<R>","std::process::ChildStderr","std::collections::VecDeque<u8, A>","std::io::StdinLock<'_>","std::io::Take<T>","std::io::Empty","std::os::unix::net::UnixStream","std::fs::File","std::process::ChildStdout","std::sys::unix::stdio::Stdin","std::io::stdio::StdinRaw","std::boxed::Box<R>","std::net::TcpStream","std::io::Repeat"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.eat_char();
+de::Deserializer::<R>::eat_char(p0);
+crate::de::Deserializer::<R>::eat_char(p0);
+<de::Deserializer<R>>::eat_char(p0);
-----------------
src/de.rs de::Deserializer::<R>::next_char
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::next_char":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::next_char":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"]},"read::IoRead":{"R":["std::os::unix::net::UnixStream","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStdout","std::io::Take<T>","std::io::Stdin","std::sys::unix::stdio::Stdin","&std::net::TcpStream","std::boxed::Box<R>","&'a std::os::unix::net::UnixStream","std::io::BufReader<R>","std::io::Chain<T, U>","std::io::Cursor<T>","std::io::StdinLock<'_>","std::fs::File","&std::fs::File","std::io::stdio::StdinRaw","std::io::Empty","std::net::TcpStream","std::collections::VecDeque<u8, A>","std::process::ChildStderr","std::io::Repeat","&'a std::sys::unix::fd::FileDesc"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.next_char();
+de::Deserializer::<R>::next_char(p0);
+crate::de::Deserializer::<R>::next_char(p0);
+<de::Deserializer<R>>::next_char(p0);
-----------------
src/de.rs de::Deserializer::<R>::next_char_or_null
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::next_char_or_null":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::next_char_or_null":{"R":["read::SliceRead","read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead"]},"read::IoRead":{"R":["std::io::StdinLock<'_>","std::sys::unix::stdio::Stdin","std::io::Repeat","std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::io::Chain<T, U>","std::io::stdio::StdinRaw","std::io::Stdin","&std::fs::File","std::io::Take<T>","std::io::BufReader<R>","std::process::ChildStderr","std::io::impls::<impl std::io::Read for &mut R>","std::io::Cursor<T>","std::process::ChildStdout","std::fs::File","std::net::TcpStream","std::io::Empty","&std::net::TcpStream","&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::boxed::Box<R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.next_char_or_null();
+de::Deserializer::<R>::next_char_or_null(p0);
+crate::de::Deserializer::<R>::next_char_or_null(p0);
+<de::Deserializer<R>>::next_char_or_null(p0);
-----------------
src/de.rs de::Deserializer::<R>::error
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::error":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::error":{"R":["read::SliceRead","read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead"]},"read::IoRead":{"R":["std::sys::unix::stdio::Stdin","std::io::Chain<T, U>","&'a std::os::unix::net::UnixStream","std::fs::File","std::net::TcpStream","std::boxed::Box<R>","&std::net::TcpStream","&std::fs::File","std::os::unix::net::UnixStream","std::io::Repeat","std::io::stdio::StdinRaw","std::io::Cursor<T>","std::io::StdinLock<'_>","std::process::ChildStderr","std::io::BufReader<R>","std::io::Stdin","std::io::impls::<impl std::io::Read for &mut R>","std::collections::VecDeque<u8, A>","std::process::ChildStdout","std::io::Empty","std::io::Take<T>","&'a std::sys::unix::fd::FileDesc"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorCode
+p0.error(p1);
+de::Deserializer::<R>::error(p0, p1);
+crate::de::Deserializer::<R>::error(p0, p1);
+<de::Deserializer<R>>::error(p0, p1);
-----------------
src/de.rs de::Deserializer::<R>::peek_error
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::peek_error":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::peek_error":{"R":["read::StrRead","<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead"]},"read::IoRead":{"R":["std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream","std::io::StdinLock<'_>","std::process::ChildStderr","std::io::Stdin","std::io::Take<T>","std::os::unix::net::UnixStream","std::boxed::Box<R>","std::process::ChildStdout","std::io::Cursor<T>","&std::net::TcpStream","std::io::Chain<T, U>","&std::fs::File","std::io::stdio::StdinRaw","&'a std::sys::unix::fd::FileDesc","std::io::Empty","std::io::BufReader<R>","std::io::Repeat","std::sys::unix::stdio::Stdin","std::collections::VecDeque<u8, A>","std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // error::ErrorCode
+p0.peek_error(p1);
+de::Deserializer::<R>::peek_error(p0, p1);
+crate::de::Deserializer::<R>::peek_error(p0, p1);
+<de::Deserializer<R>>::peek_error(p0, p1);
-----------------
src/de.rs de::Deserializer::<R>::parse_whitespace
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_whitespace":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_whitespace":{"R":["read::SliceRead","read::StrRead","read::IoRead","<&'a mut R as read::Read<'de>>"]},"read::IoRead":{"R":["std::io::Empty","std::process::ChildStdout","&std::net::TcpStream","std::sys::unix::stdio::Stdin","&'a std::sys::unix::fd::FileDesc","std::io::Stdin","std::io::StdinLock<'_>","&std::fs::File","&'a std::os::unix::net::UnixStream","std::io::Cursor<T>","std::collections::VecDeque<u8, A>","std::net::TcpStream","std::boxed::Box<R>","std::os::unix::net::UnixStream","std::io::stdio::StdinRaw","std::io::Chain<T, U>","std::io::Take<T>","std::process::ChildStderr","std::io::impls::<impl std::io::Read for &mut R>","std::io::BufReader<R>","std::fs::File","std::io::Repeat"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.parse_whitespace();
+de::Deserializer::<R>::parse_whitespace(p0);
+crate::de::Deserializer::<R>::parse_whitespace(p0);
+<de::Deserializer<R>>::parse_whitespace(p0);
-----------------
src/de.rs de::Deserializer::<R>::peek_invalid_type
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::peek_invalid_type":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::peek_invalid_type":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"]},"read::IoRead":{"R":["&'a std::os::unix::net::UnixStream","std::os::unix::net::UnixStream","std::io::Repeat","std::io::Empty","std::collections::VecDeque<u8, A>","std::fs::File","std::io::Chain<T, U>","std::process::ChildStderr","std::net::TcpStream","std::io::StdinLock<'_>","std::process::ChildStdout","std::io::BufReader<R>","std::io::stdio::StdinRaw","std::io::Cursor<T>","std::sys::unix::stdio::Stdin","&std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::io::impls::<impl std::io::Read for &mut R>","std::boxed::Box<R>","&std::fs::File","std::io::Stdin","std::io::Take<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = & MaybeUninit::uninit().assume_init(); // dyn serde::de::Expected
+p0.peek_invalid_type(p1);
+de::Deserializer::<R>::peek_invalid_type(p0, p1);
+crate::de::Deserializer::<R>::peek_invalid_type(p0, p1);
+<de::Deserializer<R>>::peek_invalid_type(p0, p1);
-----------------
src/de.rs de::Deserializer::<R>::deserialize_number
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::deserialize_number":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::deserialize_number":{"R":["read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::io::Cursor<T>","std::io::Stdin","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream","std::io::Empty","std::net::TcpStream","std::io::Take<T>","std::io::Chain<T, U>","std::process::ChildStderr","std::collections::VecDeque<u8, A>","&std::fs::File","std::io::Repeat","&'a std::os::unix::net::UnixStream","std::io::stdio::StdinRaw","std::fs::File","std::sys::unix::stdio::Stdin","std::io::BufReader<R>","std::process::ChildStdout","std::boxed::Box<R>","&'a std::sys::unix::fd::FileDesc","std::io::StdinLock<'_>","std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_number(p1);
+de::Deserializer::<R>::deserialize_number(p0, p1);
+crate::de::Deserializer::<R>::deserialize_number(p0, p1);
+<de::Deserializer<R>>::deserialize_number(p0, p1);
-----------------
src/de.rs de::Deserializer::<R>::scan_integer128
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::scan_integer128":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::scan_integer128":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead"]},"read::IoRead":{"R":["std::io::Chain<T, U>","std::io::Repeat","&std::fs::File","std::io::stdio::StdinRaw","std::io::Take<T>","std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStderr","std::net::TcpStream","&'a std::os::unix::net::UnixStream","&std::net::TcpStream","std::process::ChildStdout","std::io::Stdin","std::boxed::Box<R>","std::os::unix::net::UnixStream","std::io::Empty","std::sys::unix::stdio::Stdin","std::io::StdinLock<'_>","&'a std::sys::unix::fd::FileDesc","std::io::BufReader<R>","std::io::Cursor<T>","std::collections::VecDeque<u8, A>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = &mut std::string::String::new(); // None+std::string::String
+p0.scan_integer128(p1);
+de::Deserializer::<R>::scan_integer128(p0, p1);
+crate::de::Deserializer::<R>::scan_integer128(p0, p1);
+<de::Deserializer<R>>::scan_integer128(p0, p1);
-----------------
src/de.rs de::Deserializer::<R>::fix_position
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::fix_position":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::fix_position":{"R":["<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead","read::StrRead"]},"read::IoRead":{"R":["std::net::TcpStream","std::io::Take<T>","&std::fs::File","std::sys::unix::stdio::Stdin","&std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::os::unix::net::UnixStream","std::io::StdinLock<'_>","std::io::BufReader<R>","std::io::Empty","std::process::ChildStderr","std::process::ChildStdout","std::io::Cursor<T>","std::io::Repeat","std::io::Stdin","std::io::Chain<T, U>","&'a std::sys::unix::fd::FileDesc","&'a std::os::unix::net::UnixStream","std::boxed::Box<R>","std::collections::VecDeque<u8, A>","std::io::stdio::StdinRaw","std::fs::File"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // error::Error
+p0.fix_position(p1);
+de::Deserializer::<R>::fix_position(p0, p1);
+crate::de::Deserializer::<R>::fix_position(p0, p1);
+<de::Deserializer<R>>::fix_position(p0, p1);
-----------------
src/de.rs de::Deserializer::<R>::parse_ident
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_ident":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_ident":{"R":["read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::SliceRead"]},"read::IoRead":{"R":["std::io::StdinLock<'_>","std::io::stdio::StdinRaw","std::process::ChildStderr","std::os::unix::net::UnixStream","std::io::Take<T>","&std::fs::File","std::fs::File","std::io::Repeat","std::process::ChildStdout","&std::net::TcpStream","std::boxed::Box<R>","std::net::TcpStream","std::io::BufReader<R>","std::sys::unix::stdio::Stdin","std::io::Cursor<T>","std::io::Stdin","&'a std::os::unix::net::UnixStream","std::io::Empty","&'a std::sys::unix::fd::FileDesc","std::collections::VecDeque<u8, A>","std::io::Chain<T, U>","std::io::impls::<impl std::io::Read for &mut R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.parse_ident(p1);
+de::Deserializer::<R>::parse_ident(p0, p1);
+crate::de::Deserializer::<R>::parse_ident(p0, p1);
+<de::Deserializer<R>>::parse_ident(p0, p1);
-----------------
src/de.rs de::Deserializer::<R>::parse_integer
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_integer":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_integer":{"R":["<&'a mut R as read::Read<'de>>","read::StrRead","read::IoRead","read::SliceRead"]},"read::IoRead":{"R":["std::io::BufReader<R>","std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::io::Empty","std::boxed::Box<R>","std::io::Chain<T, U>","std::io::Repeat","std::process::ChildStderr","&'a std::os::unix::net::UnixStream","std::io::Stdin","std::net::TcpStream","std::io::StdinLock<'_>","std::process::ChildStdout","std::io::stdio::StdinRaw","&std::fs::File","std::io::Take<T>","std::io::Cursor<T>","&std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::fs::File","std::collections::VecDeque<u8, A>","std::io::impls::<impl std::io::Read for &mut R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = true; // None+bool
+p0.parse_integer(p1);
+de::Deserializer::<R>::parse_integer(p0, p1);
+crate::de::Deserializer::<R>::parse_integer(p0, p1);
+<de::Deserializer<R>>::parse_integer(p0, p1);
-----------------
src/de.rs de::Deserializer::<R>::parse_number
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_number":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_number":{"R":["read::SliceRead","read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>"]},"read::IoRead":{"R":["&'a std::sys::unix::fd::FileDesc","std::io::Empty","std::io::Stdin","std::net::TcpStream","std::io::BufReader<R>","&'a std::os::unix::net::UnixStream","std::boxed::Box<R>","std::io::Cursor<T>","std::io::Repeat","std::process::ChildStdout","&std::fs::File","std::io::Take<T>","std::fs::File","std::process::ChildStderr","std::sys::unix::stdio::Stdin","std::io::impls::<impl std::io::Read for &mut R>","std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::io::Chain<T, U>","std::io::StdinLock<'_>","&std::net::TcpStream","std::io::stdio::StdinRaw"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = true; // None+bool
let mut p2 = 0u64; // None+u64
+p0.parse_number(p1, p2);
+de::Deserializer::<R>::parse_number(p0, p1, p2);
+crate::de::Deserializer::<R>::parse_number(p0, p1, p2);
+<de::Deserializer<R>>::parse_number(p0, p1, p2);
-----------------
src/de.rs de::Deserializer::<R>::parse_decimal
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_decimal":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_decimal":{"R":["read::SliceRead","read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>"]},"read::IoRead":{"R":["std::process::ChildStdout","std::sys::unix::stdio::Stdin","std::io::BufReader<R>","std::io::Chain<T, U>","std::io::stdio::StdinRaw","std::net::TcpStream","std::os::unix::net::UnixStream","std::io::Take<T>","std::io::Cursor<T>","std::boxed::Box<R>","std::io::StdinLock<'_>","std::process::ChildStderr","std::io::Empty","std::fs::File","&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","&std::fs::File","std::io::Stdin","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream","std::io::Repeat","std::collections::VecDeque<u8, A>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = true; // None+bool
let mut p2 = 0u64; // None+u64
let mut p3 = 0i32; // None+i32
+p0.parse_decimal(p1, p2, p3);
+de::Deserializer::<R>::parse_decimal(p0, p1, p2, p3);
+crate::de::Deserializer::<R>::parse_decimal(p0, p1, p2, p3);
+<de::Deserializer<R>>::parse_decimal(p0, p1, p2, p3);
-----------------
src/de.rs de::Deserializer::<R>::parse_exponent
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_exponent":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_exponent":{"R":["read::SliceRead","read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>"]},"read::IoRead":{"R":["&std::net::TcpStream","std::net::TcpStream","std::io::Repeat","std::io::Chain<T, U>","std::os::unix::net::UnixStream","std::io::Take<T>","std::io::Stdin","&'a std::os::unix::net::UnixStream","std::process::ChildStdout","&std::fs::File","std::fs::File","std::io::Cursor<T>","std::io::StdinLock<'_>","std::io::BufReader<R>","std::io::stdio::StdinRaw","std::sys::unix::stdio::Stdin","std::boxed::Box<R>","std::process::ChildStderr","std::io::impls::<impl std::io::Read for &mut R>","&'a std::sys::unix::fd::FileDesc","std::io::Empty","std::collections::VecDeque<u8, A>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = true; // None+bool
let mut p2 = 0u64; // None+u64
let mut p3 = 0i32; // None+i32
+p0.parse_exponent(p1, p2, p3);
+de::Deserializer::<R>::parse_exponent(p0, p1, p2, p3);
+crate::de::Deserializer::<R>::parse_exponent(p0, p1, p2, p3);
+<de::Deserializer<R>>::parse_exponent(p0, p1, p2, p3);
-----------------
src/de.rs de::Deserializer::<R>::f64_from_parts
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::f64_from_parts":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::f64_from_parts":{"R":["read::SliceRead","read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>"]},"read::IoRead":{"R":["std::os::unix::net::UnixStream","std::fs::File","std::io::Chain<T, U>","std::io::Empty","std::io::BufReader<R>","std::sys::unix::stdio::Stdin","&std::net::TcpStream","&std::fs::File","std::process::ChildStdout","std::io::Repeat","std::io::Take<T>","&'a std::sys::unix::fd::FileDesc","std::io::Cursor<T>","std::io::stdio::StdinRaw","std::process::ChildStderr","std::net::TcpStream","std::collections::VecDeque<u8, A>","std::io::StdinLock<'_>","std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin","&'a std::os::unix::net::UnixStream","std::boxed::Box<R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = true; // None+bool
let mut p2 = 0u64; // None+u64
let mut p3 = 0i32; // None+i32
+p0.f64_from_parts(p1, p2, p3);
+de::Deserializer::<R>::f64_from_parts(p0, p1, p2, p3);
+crate::de::Deserializer::<R>::f64_from_parts(p0, p1, p2, p3);
+<de::Deserializer<R>>::f64_from_parts(p0, p1, p2, p3);
-----------------
src/de.rs de::Deserializer::<R>::parse_long_integer
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_long_integer":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_long_integer":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"]},"read::IoRead":{"R":["std::process::ChildStderr","std::sys::unix::stdio::Stdin","&'a std::os::unix::net::UnixStream","std::io::impls::<impl std::io::Read for &mut R>","std::io::Empty","std::os::unix::net::UnixStream","std::io::Stdin","std::process::ChildStdout","std::io::Take<T>","std::net::TcpStream","std::io::StdinLock<'_>","std::fs::File","&std::net::TcpStream","std::io::stdio::StdinRaw","std::io::BufReader<R>","std::collections::VecDeque<u8, A>","&std::fs::File","&'a std::sys::unix::fd::FileDesc","std::io::Chain<T, U>","std::io::Repeat","std::boxed::Box<R>","std::io::Cursor<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = true; // None+bool
let mut p2 = 0u64; // None+u64
+p0.parse_long_integer(p1, p2);
+de::Deserializer::<R>::parse_long_integer(p0, p1, p2);
+crate::de::Deserializer::<R>::parse_long_integer(p0, p1, p2);
+<de::Deserializer<R>>::parse_long_integer(p0, p1, p2);
-----------------
src/de.rs de::Deserializer::<R>::parse_decimal_overflow
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_decimal_overflow":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_decimal_overflow":{"R":["read::IoRead","read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>"]},"read::IoRead":{"R":["&'a std::sys::unix::fd::FileDesc","std::sys::unix::stdio::Stdin","std::net::TcpStream","&std::fs::File","std::io::Repeat","std::io::Chain<T, U>","std::fs::File","std::process::ChildStdout","std::io::Empty","std::io::BufReader<R>","std::boxed::Box<R>","std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStderr","std::io::StdinLock<'_>","&std::net::TcpStream","std::io::Take<T>","&'a std::os::unix::net::UnixStream","std::io::stdio::StdinRaw","std::io::Stdin","std::io::Cursor<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = true; // None+bool
let mut p2 = 0u64; // None+u64
let mut p3 = 0i32; // None+i32
+p0.parse_decimal_overflow(p1, p2, p3);
+de::Deserializer::<R>::parse_decimal_overflow(p0, p1, p2, p3);
+crate::de::Deserializer::<R>::parse_decimal_overflow(p0, p1, p2, p3);
+<de::Deserializer<R>>::parse_decimal_overflow(p0, p1, p2, p3);
-----------------
src/de.rs de::Deserializer::<R>::parse_exponent_overflow
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_exponent_overflow":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_exponent_overflow":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead"]},"read::IoRead":{"R":["&std::net::TcpStream","std::io::Take<T>","std::process::ChildStdout","std::process::ChildStderr","std::collections::VecDeque<u8, A>","&std::fs::File","&'a std::os::unix::net::UnixStream","std::io::Repeat","std::sys::unix::stdio::Stdin","std::os::unix::net::UnixStream","std::io::Stdin","std::io::stdio::StdinRaw","std::io::Chain<T, U>","std::io::Empty","std::io::StdinLock<'_>","std::io::Cursor<T>","std::io::BufReader<R>","&'a std::sys::unix::fd::FileDesc","std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","std::net::TcpStream","std::boxed::Box<R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = true; // None+bool
let mut p2 = true; // None+bool
let mut p3 = true; // None+bool
+p0.parse_exponent_overflow(p1, p2, p3);
+de::Deserializer::<R>::parse_exponent_overflow(p0, p1, p2, p3);
+crate::de::Deserializer::<R>::parse_exponent_overflow(p0, p1, p2, p3);
+<de::Deserializer<R>>::parse_exponent_overflow(p0, p1, p2, p3);
-----------------
src/de.rs de::Deserializer::<R>::parse_any_signed_number
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_any_signed_number":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_any_signed_number":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"]},"read::IoRead":{"R":["std::process::ChildStdout","std::io::BufReader<R>","std::net::TcpStream","std::boxed::Box<R>","std::process::ChildStderr","std::os::unix::net::UnixStream","&std::fs::File","std::io::stdio::StdinRaw","&'a std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::io::StdinLock<'_>","std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin","std::io::Cursor<T>","std::fs::File","std::io::Take<T>","std::collections::VecDeque<u8, A>","std::io::Repeat","&'a std::sys::unix::fd::FileDesc","&std::net::TcpStream","std::io::Chain<T, U>","std::io::Empty"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.parse_any_signed_number();
+de::Deserializer::<R>::parse_any_signed_number(p0);
+crate::de::Deserializer::<R>::parse_any_signed_number(p0);
+<de::Deserializer<R>>::parse_any_signed_number(p0);
-----------------
src/de.rs de::Deserializer::<R>::parse_any_number
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_any_number":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_any_number":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::IoRead"]},"read::IoRead":{"R":["std::sys::unix::stdio::Stdin","std::collections::VecDeque<u8, A>","&'a std::sys::unix::fd::FileDesc","std::os::unix::net::UnixStream","std::io::impls::<impl std::io::Read for &mut R>","&std::fs::File","std::io::stdio::StdinRaw","std::io::Empty","std::process::ChildStdout","std::io::Stdin","std::fs::File","&'a std::os::unix::net::UnixStream","std::io::Chain<T, U>","std::boxed::Box<R>","std::io::Repeat","std::io::Cursor<T>","&std::net::TcpStream","std::io::StdinLock<'_>","std::io::Take<T>","std::process::ChildStderr","std::io::BufReader<R>","std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = true; // None+bool
+p0.parse_any_number(p1);
+de::Deserializer::<R>::parse_any_number(p0, p1);
+crate::de::Deserializer::<R>::parse_any_number(p0, p1);
+<de::Deserializer<R>>::parse_any_number(p0, p1);
-----------------
src/de.rs de::Deserializer::<R>::parse_object_colon
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_object_colon":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::parse_object_colon":{"R":["<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead","read::StrRead"]},"read::IoRead":{"R":["std::io::Stdin","std::process::ChildStderr","std::net::TcpStream","std::sys::unix::stdio::Stdin","std::io::Take<T>","std::fs::File","std::io::Empty","std::io::Cursor<T>","std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream","&std::fs::File","std::os::unix::net::UnixStream","std::boxed::Box<R>","std::io::StdinLock<'_>","std::io::Repeat","std::process::ChildStdout","&std::net::TcpStream","std::collections::VecDeque<u8, A>","std::io::Chain<T, U>","std::io::BufReader<R>","std::io::stdio::StdinRaw","&'a std::sys::unix::fd::FileDesc"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.parse_object_colon();
+de::Deserializer::<R>::parse_object_colon(p0);
+crate::de::Deserializer::<R>::parse_object_colon(p0);
+<de::Deserializer<R>>::parse_object_colon(p0);
-----------------
src/de.rs de::Deserializer::<R>::end_seq
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::end_seq":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::end_seq":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::SliceRead"]},"read::IoRead":{"R":["std::boxed::Box<R>","std::sys::unix::stdio::Stdin","std::io::StdinLock<'_>","std::io::Cursor<T>","&'a std::os::unix::net::UnixStream","std::os::unix::net::UnixStream","std::io::stdio::StdinRaw","std::process::ChildStderr","std::io::Take<T>","std::io::Repeat","std::io::Chain<T, U>","std::io::Empty","std::io::impls::<impl std::io::Read for &mut R>","std::fs::File","std::io::BufReader<R>","&std::fs::File","std::collections::VecDeque<u8, A>","std::io::Stdin","std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","&std::net::TcpStream","std::process::ChildStdout"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.end_seq();
+de::Deserializer::<R>::end_seq(p0);
+crate::de::Deserializer::<R>::end_seq(p0);
+<de::Deserializer<R>>::end_seq(p0);
-----------------
src/de.rs de::Deserializer::<R>::end_map
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::end_map":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::end_map":{"R":["read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::IoRead"]},"read::IoRead":{"R":["std::os::unix::net::UnixStream","std::io::Stdin","std::io::StdinLock<'_>","&'a std::os::unix::net::UnixStream","std::io::BufReader<R>","std::fs::File","std::process::ChildStderr","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStdout","&'a std::sys::unix::fd::FileDesc","std::net::TcpStream","&std::fs::File","std::io::Chain<T, U>","std::sys::unix::stdio::Stdin","std::boxed::Box<R>","std::io::Take<T>","std::io::Repeat","std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","&std::net::TcpStream","std::io::Cursor<T>","std::io::Empty"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.end_map();
+de::Deserializer::<R>::end_map(p0);
+crate::de::Deserializer::<R>::end_map(p0);
+<de::Deserializer<R>>::end_map(p0);
-----------------
src/de.rs de::Deserializer::<R>::ignore_value
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::ignore_value":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::ignore_value":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::SliceRead"]},"read::IoRead":{"R":["std::net::TcpStream","std::io::Cursor<T>","std::sys::unix::stdio::Stdin","&'a std::os::unix::net::UnixStream","&std::net::TcpStream","std::boxed::Box<R>","std::io::Chain<T, U>","std::os::unix::net::UnixStream","std::io::Stdin","std::process::ChildStdout","std::io::Empty","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStderr","std::io::Repeat","std::fs::File","std::io::BufReader<R>","std::collections::VecDeque<u8, A>","&'a std::sys::unix::fd::FileDesc","std::io::stdio::StdinRaw","std::io::StdinLock<'_>","&std::fs::File","std::io::Take<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.ignore_value();
+de::Deserializer::<R>::ignore_value(p0);
+crate::de::Deserializer::<R>::ignore_value(p0);
+<de::Deserializer<R>>::ignore_value(p0);
-----------------
src/de.rs de::Deserializer::<R>::ignore_integer
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::ignore_integer":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::ignore_integer":{"R":["read::SliceRead","read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead"]},"read::IoRead":{"R":["&'a std::sys::unix::fd::FileDesc","&'a std::os::unix::net::UnixStream","std::io::Take<T>","std::process::ChildStderr","std::io::Repeat","std::sys::unix::stdio::Stdin","std::boxed::Box<R>","std::process::ChildStdout","std::io::Cursor<T>","&std::fs::File","&std::net::TcpStream","std::io::StdinLock<'_>","std::io::BufReader<R>","std::io::Stdin","std::io::Empty","std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","std::collections::VecDeque<u8, A>","std::io::stdio::StdinRaw","std::net::TcpStream","std::os::unix::net::UnixStream","std::io::Chain<T, U>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.ignore_integer();
+de::Deserializer::<R>::ignore_integer(p0);
+crate::de::Deserializer::<R>::ignore_integer(p0);
+<de::Deserializer<R>>::ignore_integer(p0);
-----------------
src/de.rs de::Deserializer::<R>::ignore_decimal
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::ignore_decimal":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::ignore_decimal":{"R":["read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead"]},"read::IoRead":{"R":["std::io::StdinLock<'_>","std::io::Repeat","std::io::Take<T>","std::io::stdio::StdinRaw","&'a std::sys::unix::fd::FileDesc","&'a std::os::unix::net::UnixStream","std::io::Empty","std::fs::File","std::io::Cursor<T>","std::io::BufReader<R>","&std::net::TcpStream","std::collections::VecDeque<u8, A>","std::os::unix::net::UnixStream","std::process::ChildStdout","std::net::TcpStream","std::io::Chain<T, U>","std::process::ChildStderr","std::boxed::Box<R>","std::sys::unix::stdio::Stdin","&std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.ignore_decimal();
+de::Deserializer::<R>::ignore_decimal(p0);
+crate::de::Deserializer::<R>::ignore_decimal(p0);
+<de::Deserializer<R>>::ignore_decimal(p0);
-----------------
src/de.rs de::Deserializer::<R>::ignore_exponent
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::ignore_exponent":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::Deserializer::<R>::ignore_exponent":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead"]},"read::IoRead":{"R":["std::io::stdio::StdinRaw","&std::fs::File","std::process::ChildStdout","std::boxed::Box<R>","std::sys::unix::stdio::Stdin","std::fs::File","std::io::Empty","std::collections::VecDeque<u8, A>","&'a std::os::unix::net::UnixStream","std::io::StdinLock<'_>","&'a std::sys::unix::fd::FileDesc","std::os::unix::net::UnixStream","std::io::impls::<impl std::io::Read for &mut R>","std::io::BufReader<R>","std::io::Repeat","std::io::Chain<T, U>","std::io::Take<T>","std::io::Stdin","std::net::TcpStream","std::process::ChildStderr","std::io::Cursor<T>","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+p0.ignore_exponent();
+de::Deserializer::<R>::ignore_exponent(p0);
+crate::de::Deserializer::<R>::ignore_exponent(p0);
+<de::Deserializer<R>>::ignore_exponent(p0);
-----------------
src/de.rs de::<impl std::str::FromStr for number::Number>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+de::<impl std::str::FromStr for number::Number>::from_str(&p0);
+crate::de::<impl std::str::FromStr for number::Number>::from_str(&p0);
+<number::Number>::from_str(&p0);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_any
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_any":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_any":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead","read::StrRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::process::ChildStdout","&std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::io::Cursor<T>","std::sys::unix::stdio::Stdin","std::io::Stdin","std::io::stdio::StdinRaw","&std::fs::File","std::process::ChildStderr","std::os::unix::net::UnixStream","std::io::Take<T>","std::io::Chain<T, U>","std::io::impls::<impl std::io::Read for &mut R>","std::io::StdinLock<'_>","std::io::BufReader<R>","std::collections::VecDeque<u8, A>","&'a std::os::unix::net::UnixStream","std::fs::File","std::net::TcpStream","std::io::Repeat","std::io::Empty","std::boxed::Box<R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_any(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bool
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bool":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bool":{"R":["<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead","read::StrRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::io::Take<T>","std::io::stdio::StdinRaw","&std::fs::File","&std::net::TcpStream","std::process::ChildStdout","std::io::BufReader<R>","std::io::Repeat","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStderr","std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::io::Chain<T, U>","std::collections::VecDeque<u8, A>","std::sys::unix::stdio::Stdin","std::boxed::Box<R>","std::io::Stdin","std::io::Empty","&'a std::os::unix::net::UnixStream","std::net::TcpStream","std::io::Cursor<T>","std::io::StdinLock<'_>","std::fs::File"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_bool(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i8
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i8":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i8":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::SliceRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::Cursor<T>","std::io::impls::<impl std::io::Read for &mut R>","std::collections::VecDeque<u8, A>","std::fs::File","std::io::Empty","std::net::TcpStream","std::boxed::Box<R>","std::io::BufReader<R>","std::io::Repeat","&'a std::sys::unix::fd::FileDesc","std::os::unix::net::UnixStream","std::process::ChildStderr","std::sys::unix::stdio::Stdin","std::io::Stdin","std::io::stdio::StdinRaw","std::io::Take<T>","&std::fs::File","std::process::ChildStdout","std::io::Chain<T, U>","&std::net::TcpStream","std::io::StdinLock<'_>","&'a std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_i8(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i16
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i16":{"R":["read::Read","std::marker::Sized"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i16":{"R":["read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::SliceRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["&'a std::os::unix::net::UnixStream","std::os::unix::net::UnixStream","std::io::BufReader<R>","std::io::Empty","&std::fs::File","std::io::Chain<T, U>","std::io::Cursor<T>","std::boxed::Box<R>","&'a std::sys::unix::fd::FileDesc","std::net::TcpStream","std::sys::unix::stdio::Stdin","std::io::Stdin","std::io::Repeat","std::io::impls::<impl std::io::Read for &mut R>","std::io::Take<T>","std::fs::File","std::collections::VecDeque<u8, A>","std::process::ChildStderr","std::io::stdio::StdinRaw","std::process::ChildStdout","std::io::StdinLock<'_>","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_i16(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i32
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i32":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i32":{"R":["<&'a mut R as read::Read<'de>>","read::IoRead","read::StrRead","read::SliceRead"],"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::os::unix::net::UnixStream","std::boxed::Box<R>","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStdout","std::io::Cursor<T>","std::io::Take<T>","&'a std::os::unix::net::UnixStream","std::io::Repeat","std::net::TcpStream","std::collections::VecDeque<u8, A>","std::io::stdio::StdinRaw","std::io::Empty","std::io::BufReader<R>","&std::fs::File","&std::net::TcpStream","std::io::Chain<T, U>","std::fs::File","std::sys::unix::stdio::Stdin","std::io::StdinLock<'_>","std::process::ChildStderr","&'a std::sys::unix::fd::FileDesc","std::io::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_i32(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i64
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i64":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i64":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::IoRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::BufReader<R>","&'a std::sys::unix::fd::FileDesc","std::io::impls::<impl std::io::Read for &mut R>","std::io::Chain<T, U>","std::boxed::Box<R>","std::io::Cursor<T>","std::collections::VecDeque<u8, A>","std::net::TcpStream","&'a std::os::unix::net::UnixStream","std::process::ChildStdout","std::fs::File","std::io::Take<T>","&std::net::TcpStream","std::sys::unix::stdio::Stdin","std::io::stdio::StdinRaw","std::process::ChildStderr","std::os::unix::net::UnixStream","std::io::Stdin","std::io::Empty","std::io::Repeat","std::io::StdinLock<'_>","&std::fs::File"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_i64(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u8
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u8":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u8":{"R":["read::StrRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead"],"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::io::Repeat","std::process::ChildStdout","std::io::stdio::StdinRaw","&std::net::TcpStream","std::io::Take<T>","&'a std::sys::unix::fd::FileDesc","&'a std::os::unix::net::UnixStream","&std::fs::File","std::io::BufReader<R>","std::io::Empty","std::io::impls::<impl std::io::Read for &mut R>","std::io::Cursor<T>","std::net::TcpStream","std::boxed::Box<R>","std::io::StdinLock<'_>","std::sys::unix::stdio::Stdin","std::process::ChildStderr","std::io::Stdin","std::io::Chain<T, U>","std::os::unix::net::UnixStream","std::fs::File","std::collections::VecDeque<u8, A>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_u8(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u16
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u16":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u16":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::IoRead","read::StrRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","std::io::Stdin","std::collections::VecDeque<u8, A>","std::boxed::Box<R>","std::io::impls::<impl std::io::Read for &mut R>","std::io::StdinLock<'_>","&'a std::sys::unix::fd::FileDesc","std::io::Empty","std::io::BufReader<R>","std::io::Take<T>","std::io::Cursor<T>","std::net::TcpStream","std::process::ChildStderr","std::fs::File","std::process::ChildStdout","std::io::Chain<T, U>","std::io::Repeat","std::sys::unix::stdio::Stdin","&'a std::os::unix::net::UnixStream","&std::fs::File","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_u16(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u32
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u32":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u32":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::process::ChildStderr","std::io::Take<T>","std::io::stdio::StdinRaw","std::io::impls::<impl std::io::Read for &mut R>","std::io::BufReader<R>","&std::net::TcpStream","std::sys::unix::stdio::Stdin","&std::fs::File","std::collections::VecDeque<u8, A>","&'a std::sys::unix::fd::FileDesc","std::io::Cursor<T>","std::io::Repeat","std::fs::File","std::io::Stdin","&'a std::os::unix::net::UnixStream","std::net::TcpStream","std::boxed::Box<R>","std::io::StdinLock<'_>","std::io::Empty","std::os::unix::net::UnixStream","std::process::ChildStdout","std::io::Chain<T, U>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_u32(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u64
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u64":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u64":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::boxed::Box<R>","std::io::StdinLock<'_>","std::process::ChildStdout","std::io::stdio::StdinRaw","std::process::ChildStderr","std::collections::VecDeque<u8, A>","std::net::TcpStream","std::io::Chain<T, U>","&'a std::os::unix::net::UnixStream","&std::fs::File","std::sys::unix::stdio::Stdin","&std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::fs::File","std::os::unix::net::UnixStream","std::io::Empty","&'a std::sys::unix::fd::FileDesc","std::io::Repeat","std::io::Stdin","std::io::Cursor<T>","std::io::BufReader<R>","std::io::Take<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_u64(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f32
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f32":{"R":["read::Read","std::marker::Sized"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f32":{"R":["read::StrRead","read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["std::io::impls::<impl std::io::Read for &mut R>","std::net::TcpStream","std::io::BufReader<R>","std::io::Take<T>","std::io::Repeat","std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::io::Cursor<T>","&'a std::os::unix::net::UnixStream","std::io::Empty","std::fs::File","&'a std::sys::unix::fd::FileDesc","&std::fs::File","std::collections::VecDeque<u8, A>","std::process::ChildStderr","std::io::stdio::StdinRaw","std::io::Chain<T, U>","std::process::ChildStdout","std::boxed::Box<R>","std::io::Stdin","std::io::StdinLock<'_>","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_f32(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f64
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f64":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f64":{"R":["read::SliceRead","read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>"],"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["std::boxed::Box<R>","std::io::Take<T>","std::net::TcpStream","std::io::stdio::StdinRaw","std::io::StdinLock<'_>","&'a std::os::unix::net::UnixStream","std::io::BufReader<R>","std::io::Cursor<T>","&std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream","std::fs::File","std::process::ChildStdout","&'a std::sys::unix::fd::FileDesc","std::io::Repeat","std::io::Chain<T, U>","std::sys::unix::stdio::Stdin","std::os::unix::net::UnixStream","std::io::Empty","std::process::ChildStderr","std::io::Stdin","std::collections::VecDeque<u8, A>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_f64(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i128
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i128":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i128":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead","read::StrRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::sys::unix::stdio::Stdin","std::os::unix::net::UnixStream","std::io::Cursor<T>","std::process::ChildStderr","&'a std::os::unix::net::UnixStream","std::io::StdinLock<'_>","std::io::Repeat","std::process::ChildStdout","std::io::Chain<T, U>","&std::fs::File","std::io::stdio::StdinRaw","std::boxed::Box<R>","&'a std::sys::unix::fd::FileDesc","std::io::BufReader<R>","std::io::Take<T>","std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin","std::io::Empty","std::net::TcpStream","std::collections::VecDeque<u8, A>","std::fs::File","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i128(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i128(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_i128(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_i128(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u128
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u128":{"R":["read::Read","std::marker::Sized"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u128":{"R":["read::SliceRead","read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::net::TcpStream","std::io::Take<T>","std::io::BufReader<R>","std::io::StdinLock<'_>","std::process::ChildStdout","std::io::Empty","std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin","std::io::Chain<T, U>","std::boxed::Box<R>","&'a std::os::unix::net::UnixStream","std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::io::Cursor<T>","std::fs::File","std::collections::VecDeque<u8, A>","&'a std::sys::unix::fd::FileDesc","&std::fs::File","std::io::Repeat","std::process::ChildStderr","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u128(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u128(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_u128(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_u128(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_char
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_char":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_char":{"R":["<&'a mut R as read::Read<'de>>","read::StrRead","read::SliceRead","read::IoRead"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::net::TcpStream","std::os::unix::net::UnixStream","&std::fs::File","std::io::Cursor<T>","std::io::BufReader<R>","std::io::stdio::StdinRaw","std::io::Take<T>","&'a std::sys::unix::fd::FileDesc","std::process::ChildStdout","std::process::ChildStderr","&std::net::TcpStream","std::fs::File","std::boxed::Box<R>","std::collections::VecDeque<u8, A>","std::sys::unix::stdio::Stdin","std::io::Stdin","std::io::StdinLock<'_>","std::io::Repeat","std::io::Chain<T, U>","&'a std::os::unix::net::UnixStream","std::io::Empty","std::io::impls::<impl std::io::Read for &mut R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_char(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_str
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_str":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_str":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::SliceRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["std::io::Chain<T, U>","std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","std::boxed::Box<R>","&'a std::sys::unix::fd::FileDesc","std::io::StdinLock<'_>","std::io::Stdin","&'a std::os::unix::net::UnixStream","&std::net::TcpStream","std::collections::VecDeque<u8, A>","&std::fs::File","std::io::Cursor<T>","std::io::Repeat","std::process::ChildStderr","std::io::Take<T>","std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::process::ChildStdout","std::net::TcpStream","std::io::Empty","std::io::stdio::StdinRaw","std::io::BufReader<R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_str(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_string
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_string":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_string":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::SliceRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::boxed::Box<R>","std::io::Take<T>","std::io::Empty","std::sys::unix::stdio::Stdin","std::io::StdinLock<'_>","std::io::Repeat","std::io::stdio::StdinRaw","&'a std::sys::unix::fd::FileDesc","std::io::Cursor<T>","&std::fs::File","std::os::unix::net::UnixStream","std::process::ChildStderr","&std::net::TcpStream","std::io::Chain<T, U>","std::io::impls::<impl std::io::Read for &mut R>","std::net::TcpStream","std::io::Stdin","std::process::ChildStdout","std::collections::VecDeque<u8, A>","std::io::BufReader<R>","&'a std::os::unix::net::UnixStream","std::fs::File"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_string(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bytes
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bytes":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bytes":{"R":["read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::sys::unix::stdio::Stdin","std::boxed::Box<R>","std::io::Repeat","std::io::StdinLock<'_>","std::io::Take<T>","std::io::Chain<T, U>","&'a std::os::unix::net::UnixStream","&std::net::TcpStream","std::process::ChildStdout","&'a std::sys::unix::fd::FileDesc","std::io::stdio::StdinRaw","std::fs::File","std::collections::VecDeque<u8, A>","std::io::Stdin","std::io::Empty","std::process::ChildStderr","std::io::BufReader<R>","std::net::TcpStream","&std::fs::File","std::os::unix::net::UnixStream","std::io::impls::<impl std::io::Read for &mut R>","std::io::Cursor<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_bytes(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_byte_buf
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_byte_buf":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_byte_buf":{"R":["read::SliceRead","read::StrRead","read::IoRead","<&'a mut R as read::Read<'de>>"],"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::boxed::Box<R>","std::io::impls::<impl std::io::Read for &mut R>","std::io::Take<T>","std::io::Empty","std::io::Cursor<T>","std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","&std::net::TcpStream","std::net::TcpStream","std::sys::unix::stdio::Stdin","std::process::ChildStdout","std::fs::File","&'a std::sys::unix::fd::FileDesc","std::io::Chain<T, U>","std::io::BufReader<R>","std::process::ChildStderr","&std::fs::File","std::io::Stdin","std::io::Repeat","std::io::StdinLock<'_>","std::os::unix::net::UnixStream","&'a std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_byte_buf(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_option
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_option":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_option":{"R":["read::StrRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["&std::fs::File","std::io::Repeat","&std::net::TcpStream","std::io::Chain<T, U>","std::process::ChildStdout","std::io::Cursor<T>","std::collections::VecDeque<u8, A>","std::io::Empty","&'a std::os::unix::net::UnixStream","std::io::BufReader<R>","std::io::StdinLock<'_>","std::sys::unix::stdio::Stdin","std::net::TcpStream","std::process::ChildStderr","std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","std::io::Take<T>","std::boxed::Box<R>","&'a std::sys::unix::fd::FileDesc","std::io::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_option(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit":{"R":["read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::SliceRead"],"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::sys::unix::stdio::Stdin","&std::net::TcpStream","std::io::Chain<T, U>","std::collections::VecDeque<u8, A>","std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream","std::process::ChildStderr","std::io::Take<T>","std::io::BufReader<R>","std::net::TcpStream","&std::fs::File","std::boxed::Box<R>","std::io::Repeat","std::io::StdinLock<'_>","std::io::stdio::StdinRaw","std::io::Stdin","std::io::Empty","std::fs::File","std::io::Cursor<T>","&'a std::sys::unix::fd::FileDesc","std::process::ChildStdout","std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_unit(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit_struct
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit_struct":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit_struct":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["std::io::Empty","std::collections::VecDeque<u8, A>","std::os::unix::net::UnixStream","&std::fs::File","std::io::BufReader<R>","std::boxed::Box<R>","std::io::Stdin","std::sys::unix::stdio::Stdin","std::io::Take<T>","std::net::TcpStream","std::io::Cursor<T>","std::io::Chain<T, U>","std::process::ChildStdout","std::io::Repeat","std::process::ChildStderr","&'a std::sys::unix::fd::FileDesc","&'a std::os::unix::net::UnixStream","std::fs::File","std::io::StdinLock<'_>","std::io::stdio::StdinRaw","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<&'a mut de::Deserializer<R>>::deserialize_unit_struct(p0, &p1, p2);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_newtype_struct
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_newtype_struct":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_newtype_struct":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead","read::StrRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::Stdin","std::process::ChildStderr","std::io::Empty","&std::net::TcpStream","std::net::TcpStream","std::sys::unix::stdio::Stdin","std::io::Take<T>","std::process::ChildStdout","std::io::Repeat","std::io::stdio::StdinRaw","std::boxed::Box<R>","std::fs::File","std::io::Cursor<T>","std::io::impls::<impl std::io::Read for &mut R>","&std::fs::File","std::io::StdinLock<'_>","&'a std::os::unix::net::UnixStream","std::io::BufReader<R>","std::io::Chain<T, U>","std::collections::VecDeque<u8, A>","&'a std::sys::unix::fd::FileDesc","std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<&'a mut de::Deserializer<R>>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_seq
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_seq":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_seq":{"R":["read::IoRead","read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::net::TcpStream","std::io::BufReader<R>","&std::net::TcpStream","std::io::Chain<T, U>","std::fs::File","std::collections::VecDeque<u8, A>","std::io::stdio::StdinRaw","std::process::ChildStderr","&std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","std::boxed::Box<R>","std::os::unix::net::UnixStream","std::io::Take<T>","std::sys::unix::stdio::Stdin","std::io::Repeat","std::io::Cursor<T>","&'a std::os::unix::net::UnixStream","std::io::StdinLock<'_>","std::process::ChildStdout","&'a std::sys::unix::fd::FileDesc","std::io::Empty","std::io::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_seq(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple":{"R":["read::Read","std::marker::Sized"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::boxed::Box<R>","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream","std::net::TcpStream","&'a std::os::unix::net::UnixStream","std::io::Take<T>","&std::fs::File","std::io::stdio::StdinRaw","std::io::BufReader<R>","&'a std::sys::unix::fd::FileDesc","std::fs::File","std::collections::VecDeque<u8, A>","std::process::ChildStdout","std::io::Repeat","std::io::Cursor<T>","std::io::Stdin","std::os::unix::net::UnixStream","std::io::Empty","std::sys::unix::stdio::Stdin","std::io::Chain<T, U>","std::process::ChildStderr","std::io::StdinLock<'_>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<&'a mut de::Deserializer<R>>::deserialize_tuple(p0, p1, p2);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple_struct
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple_struct":{"R":["read::Read","std::marker::Sized"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple_struct":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead"],"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::io::BufReader<R>","std::io::Cursor<T>","std::io::Stdin","std::io::stdio::StdinRaw","std::io::Chain<T, U>","std::io::Take<T>","std::collections::VecDeque<u8, A>","&'a std::sys::unix::fd::FileDesc","std::fs::File","&'a std::os::unix::net::UnixStream","std::process::ChildStderr","std::boxed::Box<R>","std::sys::unix::stdio::Stdin","std::process::ChildStdout","std::io::Repeat","std::net::TcpStream","&std::net::TcpStream","std::io::Empty","std::os::unix::net::UnixStream","std::io::StdinLock<'_>","std::io::impls::<impl std::io::Read for &mut R>","&std::fs::File"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<&'a mut de::Deserializer<R>>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_map
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_map":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_map":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::fs::File","std::process::ChildStderr","std::process::ChildStdout","std::io::Cursor<T>","&std::net::TcpStream","std::io::Stdin","std::io::Take<T>","std::io::StdinLock<'_>","&std::fs::File","std::collections::VecDeque<u8, A>","std::io::BufReader<R>","&'a std::sys::unix::fd::FileDesc","&'a std::os::unix::net::UnixStream","std::io::Chain<T, U>","std::io::stdio::StdinRaw","std::io::Empty","std::io::Repeat","std::os::unix::net::UnixStream","std::boxed::Box<R>","std::io::impls::<impl std::io::Read for &mut R>","std::net::TcpStream","std::sys::unix::stdio::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_map(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_struct
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_struct":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_struct":{"R":["read::StrRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::IoRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::sys::unix::stdio::Stdin","std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::io::Repeat","std::io::Stdin","std::io::BufReader<R>","std::net::TcpStream","std::process::ChildStderr","std::io::Chain<T, U>","std::collections::VecDeque<u8, A>","std::io::Take<T>","&std::fs::File","std::io::StdinLock<'_>","std::os::unix::net::UnixStream","std::boxed::Box<R>","std::process::ChildStdout","std::io::Cursor<T>","std::io::stdio::StdinRaw","&std::net::TcpStream","std::io::Empty"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<&'a mut de::Deserializer<R>>::deserialize_struct(p0, &p1, p2, p3);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_enum
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_enum":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_enum":{"R":["read::StrRead","read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::process::ChildStdout","std::io::stdio::StdinRaw","std::io::Stdin","std::collections::VecDeque<u8, A>","&'a std::os::unix::net::UnixStream","&std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::io::Take<T>","std::io::BufReader<R>","std::io::StdinLock<'_>","std::sys::unix::stdio::Stdin","std::process::ChildStderr","&std::fs::File","std::io::Empty","std::io::Repeat","std::boxed::Box<R>","std::fs::File","std::io::Cursor<T>","std::io::impls::<impl std::io::Read for &mut R>","std::net::TcpStream","std::io::Chain<T, U>","std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<&'a mut de::Deserializer<R>>::deserialize_enum(p0, &p1, p2, p3);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_identifier
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_identifier":{"R":["read::Read","std::marker::Sized"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_identifier":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::io::Chain<T, U>","std::sys::unix::stdio::Stdin","&std::fs::File","std::io::BufReader<R>","std::io::Stdin","std::os::unix::net::UnixStream","std::io::StdinLock<'_>","std::net::TcpStream","std::io::Empty","std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","std::io::Repeat","std::fs::File","std::boxed::Box<R>","std::process::ChildStderr","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream","std::process::ChildStdout","&'a std::sys::unix::fd::FileDesc","&'a std::os::unix::net::UnixStream","std::io::Take<T>","std::io::Cursor<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_identifier(p0, p1);
-----------------
src/de.rs <&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_ignored_any
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_ignored_any":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_ignored_any":{"R":["read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::SliceRead"],"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["std::io::impls::<impl std::io::Read for &mut R>","std::io::StdinLock<'_>","std::io::Empty","std::sys::unix::stdio::Stdin","&std::fs::File","std::io::Stdin","std::boxed::Box<R>","std::io::Chain<T, U>","std::io::stdio::StdinRaw","std::net::TcpStream","std::io::Cursor<T>","std::fs::File","std::process::ChildStdout","std::os::unix::net::UnixStream","&'a std::os::unix::net::UnixStream","std::io::BufReader<R>","std::io::Take<T>","&std::net::TcpStream","std::collections::VecDeque<u8, A>","&'a std::sys::unix::fd::FileDesc","std::io::Repeat","std::process::ChildStderr"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<&'a mut de::Deserializer<R>>::deserialize_ignored_any(p0, p1);
-----------------
src/de.rs de::SeqAccess::<'a, R>::new
'a
deps:{"de::SeqAccess::<'a, R>::new":{"R":["std::marker::Sized"]}}
candidates:{"de::SeqAccess::<'a, R>::new":{"R":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+de::SeqAccess::<'a, R>::new(p0);
+crate::de::SeqAccess::<'a, R>::new(p0);
+<de::SeqAccess<'a, R>>::new(p0);
-----------------
src/de.rs <de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed":{"R":["read::Read","std::marker::Sized"],"T":["serde::de::DeserializeSeed","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed":{"R":["read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::IoRead"],"T":["value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::Stdin","std::boxed::Box<R>","std::io::StdinLock<'_>","&std::fs::File","std::process::ChildStderr","std::io::BufReader<R>","std::process::ChildStdout","std::io::Take<T>","std::collections::VecDeque<u8, A>","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream","std::io::Empty","std::io::Cursor<T>","&'a std::sys::unix::fd::FileDesc","std::io::stdio::StdinRaw","std::net::TcpStream","std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::fs::File","std::io::Repeat","std::io::Chain<T, U>","&'a std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::SeqAccess<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.next_element_seed(p1);
+<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed(p0, p1);
+crate::<de::SeqAccess<'a, R> as serde::de::SeqAccess<'de>>::next_element_seed(p0, p1);
+<de::SeqAccess<'a, R>>::next_element_seed(p0, p1);
-----------------
src/de.rs de::MapAccess::<'a, R>::new
'a
deps:{"de::MapAccess::<'a, R>::new":{"R":["std::marker::Sized"]}}
candidates:{"de::MapAccess::<'a, R>::new":{"R":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+de::MapAccess::<'a, R>::new(p0);
+crate::de::MapAccess::<'a, R>::new(p0);
+<de::MapAccess<'a, R>>::new(p0);
-----------------
src/de.rs <de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed":{"K":["serde::de::DeserializeSeed","std::marker::Sized"],"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed":{"K":["value::de::KeyClassifier"],"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"]},"read::IoRead":{"R":["std::io::Chain<T, U>","&std::fs::File","std::process::ChildStderr","std::fs::File","std::io::Empty","std::process::ChildStdout","&'a std::sys::unix::fd::FileDesc","std::io::Repeat","std::io::Cursor<T>","std::io::StdinLock<'_>","std::io::Stdin","std::io::stdio::StdinRaw","std::sys::unix::stdio::Stdin","std::collections::VecDeque<u8, A>","std::os::unix::net::UnixStream","std::io::Take<T>","std::io::BufReader<R>","std::net::TcpStream","&std::net::TcpStream","std::boxed::Box<R>","std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::MapAccess<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // K
+p0.next_key_seed(p1);
+<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+crate::<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+<de::MapAccess<'a, R>>::next_key_seed(p0, p1);
-----------------
src/de.rs <de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_value_seed
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_value_seed":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::DeserializeSeed"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_value_seed":{"R":["read::IoRead","read::StrRead","read::SliceRead","<&'a mut R as read::Read<'de>>"],"V":["value::de::KeyClassifier"]},"read::IoRead":{"R":["std::boxed::Box<R>","std::io::Cursor<T>","std::fs::File","std::io::Stdin","&'a std::sys::unix::fd::FileDesc","std::io::BufReader<R>","std::io::Take<T>","std::io::stdio::StdinRaw","&'a std::os::unix::net::UnixStream","std::net::TcpStream","&std::fs::File","std::io::Chain<T, U>","std::io::StdinLock<'_>","std::process::ChildStdout","&std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::os::unix::net::UnixStream","std::io::Empty","std::collections::VecDeque<u8, A>","std::process::ChildStderr","std::io::Repeat","std::sys::unix::stdio::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::MapAccess<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.next_value_seed(p1);
+<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+crate::<de::MapAccess<'a, R> as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+<de::MapAccess<'a, R>>::next_value_seed(p0, p1);
-----------------
src/de.rs de::VariantAccess::<'a, R>::new
'a
deps:{"de::VariantAccess::<'a, R>::new":{"R":["std::marker::Sized"]}}
candidates:{"de::VariantAccess::<'a, R>::new":{"R":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+de::VariantAccess::<'a, R>::new(p0);
+crate::de::VariantAccess::<'a, R>::new(p0);
+<de::VariantAccess<'a, R>>::new(p0);
-----------------
src/de.rs <de::VariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::VariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed":{"R":["read::Read","std::marker::Sized"],"V":["serde::de::DeserializeSeed","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::VariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed":{"R":["read::StrRead","read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>"],"V":["value::de::KeyClassifier"]},"read::IoRead":{"R":["std::net::TcpStream","std::io::Stdin","std::boxed::Box<R>","&std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStderr","std::io::Chain<T, U>","std::io::stdio::StdinRaw","&'a std::sys::unix::fd::FileDesc","std::io::BufReader<R>","std::collections::VecDeque<u8, A>","std::io::Take<T>","std::io::StdinLock<'_>","std::io::Cursor<T>","std::fs::File","std::os::unix::net::UnixStream","std::io::Repeat","std::io::Empty","&'a std::os::unix::net::UnixStream","std::process::ChildStdout","std::sys::unix::stdio::Stdin","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::VariantAccess<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.variant_seed(p1);
+<de::VariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+crate::<de::VariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+<de::VariantAccess<'a, R>>::variant_seed(p0, p1);
-----------------
src/de.rs <de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::IoRead"]},"read::IoRead":{"R":["&'a std::sys::unix::fd::FileDesc","std::sys::unix::stdio::Stdin","std::net::TcpStream","std::io::stdio::StdinRaw","std::boxed::Box<R>","std::os::unix::net::UnixStream","std::io::Chain<T, U>","&std::net::TcpStream","std::io::Empty","std::io::Take<T>","&'a std::os::unix::net::UnixStream","&std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","std::io::BufReader<R>","std::io::StdinLock<'_>","std::io::Stdin","std::fs::File","std::collections::VecDeque<u8, A>","std::process::ChildStderr","std::io::Repeat","std::io::Cursor<T>","std::process::ChildStdout"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::VariantAccess<'a, R>
+p0.unit_variant();
+<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant(p0);
+crate::<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant(p0);
+<de::VariantAccess<'a, R>>::unit_variant(p0);
-----------------
src/de.rs <de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"R":["std::marker::Sized","read::Read"],"T":["std::marker::Sized","serde::de::DeserializeSeed"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"R":["read::IoRead","read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>"],"T":["value::de::KeyClassifier"]},"read::IoRead":{"R":["&std::fs::File","std::fs::File","std::io::Take<T>","std::net::TcpStream","std::boxed::Box<R>","std::io::impls::<impl std::io::Read for &mut R>","std::io::stdio::StdinRaw","std::io::Cursor<T>","&'a std::sys::unix::fd::FileDesc","std::sys::unix::stdio::Stdin","std::os::unix::net::UnixStream","&'a std::os::unix::net::UnixStream","std::process::ChildStdout","std::io::Chain<T, U>","std::io::Empty","&std::net::TcpStream","std::io::Repeat","std::io::StdinLock<'_>","std::io::BufReader<R>","std::io::Stdin","std::collections::VecDeque<u8, A>","std::process::ChildStderr"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::VariantAccess<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.newtype_variant_seed(p1);
+<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+crate::<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+<de::VariantAccess<'a, R>>::newtype_variant_seed(p0, p1);
-----------------
src/de.rs <de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant":{"R":["read::IoRead","read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::io::impls::<impl std::io::Read for &mut R>","std::io::Empty","std::io::stdio::StdinRaw","&std::net::TcpStream","std::io::Take<T>","&'a std::sys::unix::fd::FileDesc","std::io::StdinLock<'_>","std::io::Chain<T, U>","std::collections::VecDeque<u8, A>","std::net::TcpStream","&std::fs::File","std::os::unix::net::UnixStream","std::process::ChildStdout","std::io::Repeat","std::io::BufReader<R>","std::io::Stdin","std::fs::File","std::io::Cursor<T>","&'a std::os::unix::net::UnixStream","std::boxed::Box<R>","std::sys::unix::stdio::Stdin","std::process::ChildStderr"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::VariantAccess<'a, R>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.tuple_variant(p1, p2);
+<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+crate::<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+<de::VariantAccess<'a, R>>::tuple_variant(p0, p1, p2);
-----------------
src/de.rs <de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant":{"R":["read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::IoRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["&std::net::TcpStream","std::io::Repeat","std::io::StdinLock<'_>","&'a std::os::unix::net::UnixStream","std::fs::File","std::process::ChildStderr","std::collections::VecDeque<u8, A>","std::io::Chain<T, U>","std::io::Empty","std::sys::unix::stdio::Stdin","std::io::Stdin","&'a std::sys::unix::fd::FileDesc","std::os::unix::net::UnixStream","std::process::ChildStdout","std::io::Cursor<T>","std::io::impls::<impl std::io::Read for &mut R>","std::boxed::Box<R>","std::net::TcpStream","std::io::stdio::StdinRaw","&std::fs::File","std::io::BufReader<R>","std::io::Take<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::VariantAccess<'a, R>
let mut p1 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.struct_variant(p1, p2);
+<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+crate::<de::VariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+<de::VariantAccess<'a, R>>::struct_variant(p0, p1, p2);
-----------------
src/de.rs de::UnitVariantAccess::<'a, R>::new
'a
deps:{"de::UnitVariantAccess::<'a, R>::new":{"R":["std::marker::Sized"]}}
candidates:{"de::UnitVariantAccess::<'a, R>::new":{"R":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::Deserializer<R>
+de::UnitVariantAccess::<'a, R>::new(p0);
+crate::de::UnitVariantAccess::<'a, R>::new(p0);
+<de::UnitVariantAccess<'a, R>>::new(p0);
-----------------
src/de.rs <de::UnitVariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::UnitVariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::DeserializeSeed"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::UnitVariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed":{"R":["read::StrRead","read::IoRead","<&'a mut R as read::Read<'de>>","read::SliceRead"],"V":["value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::StdinLock<'_>","std::boxed::Box<R>","std::io::Empty","std::fs::File","&std::fs::File","std::sys::unix::stdio::Stdin","std::io::stdio::StdinRaw","std::process::ChildStderr","std::io::BufReader<R>","std::io::Stdin","std::io::Cursor<T>","std::io::Repeat","&std::net::TcpStream","&'a std::os::unix::net::UnixStream","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStdout","std::os::unix::net::UnixStream","std::net::TcpStream","std::io::Take<T>","std::io::Chain<T, U>","&'a std::sys::unix::fd::FileDesc","std::collections::VecDeque<u8, A>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::UnitVariantAccess<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.variant_seed(p1);
+<de::UnitVariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+crate::<de::UnitVariantAccess<'a, R> as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+<de::UnitVariantAccess<'a, R>>::variant_seed(p0, p1);
-----------------
src/de.rs <de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant":{"R":["read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::SliceRead"]},"read::IoRead":{"R":["std::io::StdinLock<'_>","&std::fs::File","std::io::Take<T>","std::io::Cursor<T>","std::io::Repeat","std::process::ChildStdout","&'a std::sys::unix::fd::FileDesc","std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","std::fs::File","std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream","std::io::Empty","std::process::ChildStderr","std::boxed::Box<R>","&std::net::TcpStream","std::os::unix::net::UnixStream","std::io::BufReader<R>","std::io::Chain<T, U>","std::io::Stdin","std::sys::unix::stdio::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::UnitVariantAccess<'a, R>
+p0.unit_variant();
+<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant(p0);
+crate::<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::unit_variant(p0);
+<de::UnitVariantAccess<'a, R>>::unit_variant(p0);
-----------------
src/de.rs <de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"R":["std::marker::Sized","read::Read"],"T":["serde::de::DeserializeSeed","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"R":["read::StrRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::IoRead"],"T":["value::de::KeyClassifier"]},"read::IoRead":{"R":["&std::net::TcpStream","std::io::Chain<T, U>","std::boxed::Box<R>","std::net::TcpStream","&std::fs::File","std::process::ChildStderr","std::fs::File","std::io::Cursor<T>","std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","std::os::unix::net::UnixStream","std::io::Repeat","std::io::Empty","std::io::StdinLock<'_>","std::sys::unix::stdio::Stdin","std::process::ChildStdout","&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::io::Take<T>","std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin","std::io::BufReader<R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::UnitVariantAccess<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.newtype_variant_seed(p1);
+<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+crate::<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+<de::UnitVariantAccess<'a, R>>::newtype_variant_seed(p0, p1);
-----------------
src/de.rs <de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::IoRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::impls::<impl std::io::Read for &mut R>","std::io::Repeat","&'a std::sys::unix::fd::FileDesc","std::process::ChildStdout","&'a std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::boxed::Box<R>","std::io::stdio::StdinRaw","std::sys::unix::stdio::Stdin","std::fs::File","std::io::StdinLock<'_>","std::net::TcpStream","std::io::Stdin","std::io::Empty","std::io::Take<T>","&std::fs::File","&std::net::TcpStream","std::io::Chain<T, U>","std::os::unix::net::UnixStream","std::process::ChildStderr","std::io::Cursor<T>","std::io::BufReader<R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::UnitVariantAccess<'a, R>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.tuple_variant(p1, p2);
+<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+crate::<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+<de::UnitVariantAccess<'a, R>>::tuple_variant(p0, p1, p2);
-----------------
src/de.rs <de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::net::TcpStream","std::io::Chain<T, U>","std::io::Cursor<T>","std::collections::VecDeque<u8, A>","std::os::unix::net::UnixStream","std::process::ChildStderr","&std::net::TcpStream","std::io::Empty","std::boxed::Box<R>","std::io::Repeat","std::process::ChildStdout","std::fs::File","std::io::Stdin","std::sys::unix::stdio::Stdin","std::io::BufReader<R>","std::io::StdinLock<'_>","std::io::Take<T>","&std::fs::File","std::io::stdio::StdinRaw"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::UnitVariantAccess<'a, R>
let mut p1 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.struct_variant(p1, p2);
+<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+crate::<de::UnitVariantAccess<'a, R> as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+<de::UnitVariantAccess<'a, R>>::struct_variant(p0, p1, p2);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_any
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_any":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_any":{"R":["read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead"],"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::io::Chain<T, U>","std::io::impls::<impl std::io::Read for &mut R>","std::net::TcpStream","std::io::Stdin","std::io::BufReader<R>","std::io::StdinLock<'_>","std::io::Repeat","std::os::unix::net::UnixStream","std::io::Cursor<T>","std::io::Take<T>","std::process::ChildStderr","std::sys::unix::stdio::Stdin","std::fs::File","&'a std::os::unix::net::UnixStream","std::process::ChildStdout","&std::fs::File","std::boxed::Box<R>","std::collections::VecDeque<u8, A>","std::io::stdio::StdinRaw","std::io::Empty","&std::net::TcpStream","&'a std::sys::unix::fd::FileDesc"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<de::MapKey<'a, R>>::deserialize_any(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i8
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i8":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i8":{"R":["read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::IoRead"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["&std::fs::File","std::collections::VecDeque<u8, A>","std::io::impls::<impl std::io::Read for &mut R>","std::io::BufReader<R>","std::io::Cursor<T>","std::fs::File","std::process::ChildStdout","std::boxed::Box<R>","&'a std::os::unix::net::UnixStream","std::io::Repeat","std::io::StdinLock<'_>","&'a std::sys::unix::fd::FileDesc","std::io::Stdin","std::net::TcpStream","std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::process::ChildStderr","std::io::Empty","std::io::Take<T>","std::io::Chain<T, U>","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<de::MapKey<'a, R>>::deserialize_i8(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i16
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i16":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i16":{"R":["<&'a mut R as read::Read<'de>>","read::IoRead","read::StrRead","read::SliceRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["&'a std::sys::unix::fd::FileDesc","&std::net::TcpStream","std::io::Chain<T, U>","std::process::ChildStderr","std::collections::VecDeque<u8, A>","std::io::Stdin","std::io::Cursor<T>","std::net::TcpStream","std::io::Take<T>","std::io::Repeat","std::io::stdio::StdinRaw","&std::fs::File","std::process::ChildStdout","std::io::StdinLock<'_>","std::sys::unix::stdio::Stdin","&'a std::os::unix::net::UnixStream","std::boxed::Box<R>","std::io::Empty","std::io::impls::<impl std::io::Read for &mut R>","std::fs::File","std::io::BufReader<R>","std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<de::MapKey<'a, R>>::deserialize_i16(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i32
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i32":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i32":{"R":["read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::Stdin","std::io::StdinLock<'_>","&'a std::sys::unix::fd::FileDesc","std::io::Cursor<T>","std::fs::File","std::collections::VecDeque<u8, A>","&std::net::TcpStream","std::boxed::Box<R>","std::io::BufReader<R>","std::net::TcpStream","std::sys::unix::stdio::Stdin","std::io::Empty","std::process::ChildStderr","std::os::unix::net::UnixStream","std::io::stdio::StdinRaw","std::io::Chain<T, U>","std::io::Repeat","std::process::ChildStdout","&std::fs::File","&'a std::os::unix::net::UnixStream","std::io::impls::<impl std::io::Read for &mut R>","std::io::Take<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<de::MapKey<'a, R>>::deserialize_i32(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i64
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i64":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i64":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::sys::unix::stdio::Stdin","std::net::TcpStream","std::io::Stdin","std::io::Cursor<T>","std::collections::VecDeque<u8, A>","&'a std::sys::unix::fd::FileDesc","std::os::unix::net::UnixStream","std::process::ChildStderr","std::io::impls::<impl std::io::Read for &mut R>","std::io::stdio::StdinRaw","std::process::ChildStdout","&std::fs::File","&'a std::os::unix::net::UnixStream","std::io::Repeat","std::fs::File","std::io::StdinLock<'_>","std::io::Chain<T, U>","std::io::Empty","std::io::Take<T>","&std::net::TcpStream","std::io::BufReader<R>","std::boxed::Box<R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<de::MapKey<'a, R>>::deserialize_i64(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i128
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i128":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i128":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::SliceRead"],"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::io::StdinLock<'_>","std::io::stdio::StdinRaw","std::fs::File","std::sys::unix::stdio::Stdin","std::io::BufReader<R>","std::io::Cursor<T>","std::io::Empty","std::net::TcpStream","std::process::ChildStdout","&'a std::sys::unix::fd::FileDesc","std::process::ChildStderr","&std::fs::File","std::collections::VecDeque<u8, A>","std::io::impls::<impl std::io::Read for &mut R>","std::boxed::Box<R>","std::io::Repeat","std::io::Take<T>","std::io::Stdin","&std::net::TcpStream","std::os::unix::net::UnixStream","&'a std::os::unix::net::UnixStream","std::io::Chain<T, U>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i128(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i128(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_i128(p0, p1);
+<de::MapKey<'a, R>>::deserialize_i128(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u8
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u8":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u8":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::IoRead","read::StrRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::boxed::Box<R>","std::sys::unix::stdio::Stdin","std::io::Stdin","std::collections::VecDeque<u8, A>","std::io::Chain<T, U>","std::io::StdinLock<'_>","std::io::BufReader<R>","&std::fs::File","std::io::Cursor<T>","std::process::ChildStdout","std::io::Repeat","&'a std::sys::unix::fd::FileDesc","std::io::stdio::StdinRaw","std::io::Empty","std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::os::unix::net::UnixStream","std::process::ChildStderr","std::fs::File","&'a std::os::unix::net::UnixStream","std::io::Take<T>","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<de::MapKey<'a, R>>::deserialize_u8(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u16
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u16":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u16":{"R":["read::StrRead","read::IoRead","<&'a mut R as read::Read<'de>>","read::SliceRead"],"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::io::BufReader<R>","std::boxed::Box<R>","std::collections::VecDeque<u8, A>","std::process::ChildStdout","std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","std::io::Cursor<T>","std::io::Repeat","std::io::Take<T>","std::fs::File","std::io::Empty","std::process::ChildStderr","std::net::TcpStream","std::io::StdinLock<'_>","&std::net::TcpStream","&'a std::os::unix::net::UnixStream","std::io::impls::<impl std::io::Read for &mut R>","&std::fs::File","std::sys::unix::stdio::Stdin","std::io::Stdin","std::io::Chain<T, U>","&'a std::sys::unix::fd::FileDesc"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<de::MapKey<'a, R>>::deserialize_u16(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u32
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u32":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u32":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::SliceRead"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::Stdin","std::collections::VecDeque<u8, A>","std::io::Empty","std::fs::File","std::process::ChildStderr","std::net::TcpStream","std::io::Cursor<T>","&std::net::TcpStream","&std::fs::File","std::io::BufReader<R>","std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::io::Chain<T, U>","std::process::ChildStdout","std::io::stdio::StdinRaw","&'a std::os::unix::net::UnixStream","std::io::Repeat","std::io::StdinLock<'_>","std::boxed::Box<R>","std::io::Take<T>","std::io::impls::<impl std::io::Read for &mut R>","std::sys::unix::stdio::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<de::MapKey<'a, R>>::deserialize_u32(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u64
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u64":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u64":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::SliceRead"],"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin","std::boxed::Box<R>","std::io::Empty","&std::fs::File","std::io::Take<T>","std::process::ChildStdout","std::io::Repeat","std::fs::File","&'a std::os::unix::net::UnixStream","std::io::stdio::StdinRaw","&'a std::sys::unix::fd::FileDesc","std::process::ChildStderr","std::io::Cursor<T>","std::net::TcpStream","std::io::StdinLock<'_>","&std::net::TcpStream","std::io::BufReader<R>","std::sys::unix::stdio::Stdin","std::collections::VecDeque<u8, A>","std::io::Chain<T, U>","std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<de::MapKey<'a, R>>::deserialize_u64(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u128
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u128":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u128":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::IoRead"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::Take<T>","std::io::Empty","&'a std::os::unix::net::UnixStream","&std::net::TcpStream","&std::fs::File","std::net::TcpStream","std::io::Repeat","std::io::Cursor<T>","std::io::Stdin","std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::process::ChildStdout","std::io::BufReader<R>","std::io::StdinLock<'_>","std::process::ChildStderr","&'a std::sys::unix::fd::FileDesc","std::sys::unix::stdio::Stdin","std::io::stdio::StdinRaw","std::io::impls::<impl std::io::Read for &mut R>","std::fs::File","std::boxed::Box<R>","std::io::Chain<T, U>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u128(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u128(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_u128(p0, p1);
+<de::MapKey<'a, R>>::deserialize_u128(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_option
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_option":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_option":{"R":["<&'a mut R as read::Read<'de>>","read::IoRead","read::StrRead","read::SliceRead"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::net::TcpStream","&std::net::TcpStream","std::os::unix::net::UnixStream","std::io::stdio::StdinRaw","std::io::Empty","std::io::Cursor<T>","&'a std::os::unix::net::UnixStream","std::process::ChildStdout","std::io::BufReader<R>","std::sys::unix::stdio::Stdin","std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin","std::collections::VecDeque<u8, A>","std::io::Chain<T, U>","std::io::StdinLock<'_>","std::process::ChildStderr","std::fs::File","&std::fs::File","&'a std::sys::unix::fd::FileDesc","std::boxed::Box<R>","std::io::Repeat","std::io::Take<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<de::MapKey<'a, R>>::deserialize_option(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_newtype_struct
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_newtype_struct":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_newtype_struct":{"R":["<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead","read::StrRead"],"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["std::io::Chain<T, U>","std::io::Take<T>","std::io::Cursor<T>","&std::net::TcpStream","&std::fs::File","std::io::stdio::StdinRaw","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStdout","std::fs::File","std::collections::VecDeque<u8, A>","&'a std::sys::unix::fd::FileDesc","std::boxed::Box<R>","std::io::Empty","&'a std::os::unix::net::UnixStream","std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::io::Stdin","std::net::TcpStream","std::io::BufReader<R>","std::process::ChildStderr","std::io::StdinLock<'_>","std::io::Repeat"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<de::MapKey<'a, R>>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_enum
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_enum":{"R":["read::Read","std::marker::Sized"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_enum":{"R":["read::StrRead","<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::process::ChildStdout","std::sys::unix::stdio::Stdin","std::io::Cursor<T>","std::net::TcpStream","&'a std::os::unix::net::UnixStream","std::io::Repeat","std::collections::VecDeque<u8, A>","std::process::ChildStderr","std::boxed::Box<R>","std::io::Chain<T, U>","std::io::impls::<impl std::io::Read for &mut R>","std::io::StdinLock<'_>","&'a std::sys::unix::fd::FileDesc","std::io::Take<T>","&std::net::TcpStream","&std::fs::File","std::io::stdio::StdinRaw","std::fs::File","std::io::Empty","std::io::BufReader<R>","std::io::Stdin","std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<de::MapKey<'a, R>>::deserialize_enum(p0, &p1, p2, p3);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bytes
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bytes":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bytes":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"],"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::io::Repeat","std::process::ChildStdout","std::io::Stdin","std::io::stdio::StdinRaw","std::net::TcpStream","std::io::BufReader<R>","&std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::boxed::Box<R>","std::io::impls::<impl std::io::Read for &mut R>","&std::fs::File","std::sys::unix::stdio::Stdin","std::io::Empty","std::io::Chain<T, U>","std::io::Take<T>","&'a std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::os::unix::net::UnixStream","std::io::StdinLock<'_>","std::process::ChildStderr","std::io::Cursor<T>","std::fs::File"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<de::MapKey<'a, R>>::deserialize_bytes(p0, p1);
-----------------
src/de.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_byte_buf
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_byte_buf":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_byte_buf":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::IoRead"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::io::Empty","std::io::BufReader<R>","std::io::Repeat","std::fs::File","std::io::Chain<T, U>","std::os::unix::net::UnixStream","std::io::impls::<impl std::io::Read for &mut R>","std::io::StdinLock<'_>","std::process::ChildStderr","std::io::Cursor<T>","&std::net::TcpStream","std::io::stdio::StdinRaw","std::sys::unix::stdio::Stdin","&'a std::sys::unix::fd::FileDesc","&'a std::os::unix::net::UnixStream","&std::fs::File","std::net::TcpStream","std::process::ChildStdout","std::io::Take<T>","std::boxed::Box<R>","std::io::Stdin","std::collections::VecDeque<u8, A>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<de::MapKey<'a, R>>::deserialize_byte_buf(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bool
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bool":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bool":{"R":["read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::collections::VecDeque<u8, A>","&'a std::os::unix::net::UnixStream","&std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::os::unix::net::UnixStream","std::fs::File","std::io::StdinLock<'_>","std::process::ChildStdout","std::io::Empty","std::io::stdio::StdinRaw","std::sys::unix::stdio::Stdin","std::io::Cursor<T>","std::boxed::Box<R>","std::io::Repeat","&'a std::sys::unix::fd::FileDesc","std::io::BufReader<R>","&std::fs::File","std::net::TcpStream","std::io::Take<T>","std::io::Stdin","std::process::ChildStderr","std::io::Chain<T, U>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<de::MapKey<'a, R>>::deserialize_bool(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f32
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f32":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f32":{"R":["read::SliceRead","read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["&std::net::TcpStream","std::io::Take<T>","std::io::Repeat","std::io::Stdin","std::fs::File","std::io::Cursor<T>","std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::io::Empty","std::io::BufReader<R>","std::io::stdio::StdinRaw","std::io::impls::<impl std::io::Read for &mut R>","std::os::unix::net::UnixStream","std::io::StdinLock<'_>","&std::fs::File","std::collections::VecDeque<u8, A>","std::process::ChildStdout","std::sys::unix::stdio::Stdin","&'a std::os::unix::net::UnixStream","std::boxed::Box<R>","std::io::Chain<T, U>","std::process::ChildStderr"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<de::MapKey<'a, R>>::deserialize_f32(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f64
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f64":{"R":["read::Read","std::marker::Sized"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f64":{"R":["read::SliceRead","read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::net::TcpStream","std::sys::unix::stdio::Stdin","std::io::BufReader<R>","std::io::stdio::StdinRaw","std::io::impls::<impl std::io::Read for &mut R>","std::os::unix::net::UnixStream","std::io::Repeat","std::collections::VecDeque<u8, A>","std::process::ChildStdout","std::io::Empty","&'a std::sys::unix::fd::FileDesc","std::io::StdinLock<'_>","&std::net::TcpStream","std::io::Chain<T, U>","std::io::Cursor<T>","std::fs::File","&std::fs::File","&'a std::os::unix::net::UnixStream","std::boxed::Box<R>","std::io::Take<T>","std::io::Stdin","std::process::ChildStderr"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<de::MapKey<'a, R>>::deserialize_f64(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_char
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_char":{"R":["read::Read","std::marker::Sized"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_char":{"R":["read::StrRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::IoRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["&std::fs::File","std::sys::unix::stdio::Stdin","std::io::Chain<T, U>","&'a std::sys::unix::fd::FileDesc","std::io::BufReader<R>","std::io::Repeat","std::io::stdio::StdinRaw","&std::net::TcpStream","std::os::unix::net::UnixStream","std::boxed::Box<R>","std::collections::VecDeque<u8, A>","std::process::ChildStderr","&'a std::os::unix::net::UnixStream","std::io::StdinLock<'_>","std::io::Empty","std::io::Take<T>","std::net::TcpStream","std::io::Cursor<T>","std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStdout","std::io::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<de::MapKey<'a, R>>::deserialize_char(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_str
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_str":{"R":["std::marker::Sized","read::Read"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_str":{"R":["read::StrRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["std::io::BufReader<R>","std::os::unix::net::UnixStream","std::io::Stdin","std::io::StdinLock<'_>","&'a std::sys::unix::fd::FileDesc","std::collections::VecDeque<u8, A>","std::io::Cursor<T>","std::io::Chain<T, U>","std::process::ChildStderr","&std::fs::File","&'a std::os::unix::net::UnixStream","std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::boxed::Box<R>","&std::net::TcpStream","std::io::stdio::StdinRaw","std::io::Empty","std::fs::File","std::sys::unix::stdio::Stdin","std::io::Repeat","std::io::Take<T>","std::process::ChildStdout"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<de::MapKey<'a, R>>::deserialize_str(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_string
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_string":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_string":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::process::ChildStdout","std::io::stdio::StdinRaw","std::io::Repeat","&'a std::sys::unix::fd::FileDesc","std::os::unix::net::UnixStream","&std::net::TcpStream","std::fs::File","std::io::Empty","&'a std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::boxed::Box<R>","std::io::Stdin","std::io::Chain<T, U>","std::net::TcpStream","std::io::BufReader<R>","std::io::impls::<impl std::io::Read for &mut R>","&std::fs::File","std::io::Cursor<T>","std::io::Take<T>","std::io::StdinLock<'_>","std::process::ChildStderr","std::sys::unix::stdio::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<de::MapKey<'a, R>>::deserialize_string(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit":{"R":["read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::SliceRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::Empty","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStdout","std::os::unix::net::UnixStream","std::io::Take<T>","std::boxed::Box<R>","&'a std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::process::ChildStderr","std::io::Stdin","std::io::Repeat","std::fs::File","std::io::BufReader<R>","std::io::stdio::StdinRaw","std::io::Cursor<T>","&'a std::sys::unix::fd::FileDesc","&std::net::TcpStream","std::io::StdinLock<'_>","std::io::Chain<T, U>","std::collections::VecDeque<u8, A>","std::net::TcpStream","&std::fs::File"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<de::MapKey<'a, R>>::deserialize_unit(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit_struct
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit_struct":{"R":["read::Read","std::marker::Sized"],"V":["serde::de::Visitor","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit_struct":{"R":["read::StrRead","read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>"],"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]},"read::IoRead":{"R":["std::io::Stdin","std::collections::VecDeque<u8, A>","std::process::ChildStderr","std::io::BufReader<R>","std::io::stdio::StdinRaw","&std::net::TcpStream","std::io::Chain<T, U>","std::io::Cursor<T>","std::process::ChildStdout","std::os::unix::net::UnixStream","std::io::impls::<impl std::io::Read for &mut R>","std::io::StdinLock<'_>","std::io::Take<T>","std::io::Empty","std::sys::unix::stdio::Stdin","std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::io::Repeat","&'a std::os::unix::net::UnixStream","std::boxed::Box<R>","&std::fs::File","std::fs::File"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<de::MapKey<'a, R>>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_seq
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_seq":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_seq":{"R":["<&'a mut R as read::Read<'de>>","read::StrRead","read::IoRead","read::SliceRead"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::Chain<T, U>","std::collections::VecDeque<u8, A>","std::net::TcpStream","std::os::unix::net::UnixStream","std::process::ChildStdout","std::io::Repeat","std::io::Cursor<T>","std::io::stdio::StdinRaw","std::io::Empty","std::process::ChildStderr","std::sys::unix::stdio::Stdin","&'a std::sys::unix::fd::FileDesc","std::io::StdinLock<'_>","&'a std::os::unix::net::UnixStream","std::io::impls::<impl std::io::Read for &mut R>","std::io::BufReader<R>","std::io::Stdin","&std::net::TcpStream","std::fs::File","std::boxed::Box<R>","&std::fs::File","std::io::Take<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<de::MapKey<'a, R>>::deserialize_seq(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::SliceRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::io::Chain<T, U>","&std::fs::File","&'a std::os::unix::net::UnixStream","std::io::BufReader<R>","std::net::TcpStream","std::io::StdinLock<'_>","std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin","std::boxed::Box<R>","&'a std::sys::unix::fd::FileDesc","std::fs::File","&std::net::TcpStream","std::sys::unix::stdio::Stdin","std::io::Take<T>","std::process::ChildStdout","std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::io::Cursor<T>","std::io::stdio::StdinRaw","std::io::Repeat","std::io::Empty","std::process::ChildStderr"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<de::MapKey<'a, R>>::deserialize_tuple(p0, p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple_struct
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple_struct":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple_struct":{"R":["read::SliceRead","read::StrRead","read::IoRead","<&'a mut R as read::Read<'de>>"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]},"read::IoRead":{"R":["std::io::Empty","&'a std::sys::unix::fd::FileDesc","std::io::BufReader<R>","std::os::unix::net::UnixStream","std::io::StdinLock<'_>","std::sys::unix::stdio::Stdin","std::collections::VecDeque<u8, A>","std::io::Take<T>","std::io::Repeat","std::io::stdio::StdinRaw","std::io::Cursor<T>","std::process::ChildStdout","std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream","std::io::Stdin","std::io::Chain<T, U>","&std::fs::File","std::boxed::Box<R>","std::fs::File","std::process::ChildStderr","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<de::MapKey<'a, R>>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_map
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_map":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_map":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::IoRead","read::StrRead"],"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["&'a std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::io::Stdin","&std::fs::File","std::io::Chain<T, U>","std::process::ChildStderr","std::io::BufReader<R>","std::boxed::Box<R>","&std::net::TcpStream","std::io::StdinLock<'_>","std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","std::io::Repeat","std::io::Cursor<T>","std::fs::File","std::process::ChildStdout","std::collections::VecDeque<u8, A>","std::net::TcpStream","std::io::Take<T>","&'a std::sys::unix::fd::FileDesc","std::io::Empty","std::io::impls::<impl std::io::Read for &mut R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<de::MapKey<'a, R>>::deserialize_map(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_struct
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_struct":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_struct":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::SliceRead"],"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]},"read::IoRead":{"R":["std::process::ChildStderr","std::io::stdio::StdinRaw","std::io::Chain<T, U>","std::io::Empty","std::process::ChildStdout","std::io::StdinLock<'_>","&std::fs::File","std::io::Repeat","std::boxed::Box<R>","std::io::Cursor<T>","std::io::BufReader<R>","&'a std::os::unix::net::UnixStream","std::net::TcpStream","std::sys::unix::stdio::Stdin","std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin","&std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::collections::VecDeque<u8, A>","std::os::unix::net::UnixStream","std::io::Take<T>","std::fs::File"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<de::MapKey<'a, R>>::deserialize_struct(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_identifier
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_identifier":{"R":["read::Read","std::marker::Sized"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_identifier":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"],"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["std::process::ChildStderr","std::io::Repeat","std::io::impls::<impl std::io::Read for &mut R>","std::io::StdinLock<'_>","std::os::unix::net::UnixStream","std::net::TcpStream","std::io::Stdin","&'a std::sys::unix::fd::FileDesc","std::io::BufReader<R>","std::process::ChildStdout","std::io::Take<T>","&'a std::os::unix::net::UnixStream","std::io::stdio::StdinRaw","std::boxed::Box<R>","std::io::Empty","std::sys::unix::stdio::Stdin","&std::fs::File","std::io::Cursor<T>","std::fs::File","std::io::Chain<T, U>","std::collections::VecDeque<u8, A>","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<de::MapKey<'a, R>>::deserialize_identifier(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_ignored_any
'de,'a
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_ignored_any":{"R":["std::marker::Sized","read::Read"],"V":["std::marker::Sized","serde::de::Visitor"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_ignored_any":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead","read::StrRead"],"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]},"read::IoRead":{"R":["std::process::ChildStderr","std::io::Chain<T, U>","std::io::stdio::StdinRaw","&std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::collections::VecDeque<u8, A>","std::net::TcpStream","&std::fs::File","std::io::Repeat","std::io::Stdin","std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::process::ChildStdout","&'a std::os::unix::net::UnixStream","std::io::Take<T>","std::io::Cursor<T>","std::io::StdinLock<'_>","std::boxed::Box<R>","std::io::BufReader<R>","std::io::Empty","std::fs::File","std::sys::unix::stdio::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::MapKey<'a, R>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<de::MapKey<'a, R> as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<de::MapKey<'a, R>>::deserialize_ignored_any(p0, p1);
-----------------
src/de.rs de::StreamDeserializer::<'de, R, T>::new
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::StreamDeserializer::<'de, R, T>::new":{"R":["std::marker::Sized","read::Read"],"T":["serde::Deserialize","std::marker::Sized"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::StreamDeserializer::<'de, R, T>::new":{"R":["<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead","read::StrRead"],"T":["number::Number","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"read::IoRead":{"R":["std::io::StdinLock<'_>","std::os::unix::net::UnixStream","std::io::Stdin","&std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStdout","std::boxed::Box<R>","std::io::Repeat","std::io::Cursor<T>","std::sys::unix::stdio::Stdin","std::net::TcpStream","std::collections::VecDeque<u8, A>","std::io::stdio::StdinRaw","std::fs::File","std::io::Chain<T, U>","std::io::BufReader<R>","std::io::Take<T>","&'a std::sys::unix::fd::FileDesc","&std::fs::File","std::io::Empty","&'a std::os::unix::net::UnixStream","std::process::ChildStderr"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // R
+de::StreamDeserializer::<'de, R, T>::new(p0);
+crate::de::StreamDeserializer::<'de, R, T>::new(p0);
+<de::StreamDeserializer<'de, R, T>>::new(p0);
-----------------
src/de.rs de::StreamDeserializer::<'de, R, T>::byte_offset
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::StreamDeserializer::<'de, R, T>::byte_offset":{"R":["read::Read","std::marker::Sized"],"T":["std::marker::Sized","serde::Deserialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::StreamDeserializer::<'de, R, T>::byte_offset":{"R":["read::IoRead","read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>"],"T":["value::Value","map::Map","number::Number"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"read::IoRead":{"R":["&'a std::sys::unix::fd::FileDesc","std::sys::unix::stdio::Stdin","std::boxed::Box<R>","std::io::Empty","std::io::Stdin","std::io::Chain<T, U>","std::process::ChildStdout","std::process::ChildStderr","std::io::StdinLock<'_>","std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream","std::os::unix::net::UnixStream","std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","std::io::BufReader<R>","std::io::Repeat","std::io::Take<T>","std::io::Cursor<T>","&std::fs::File","std::net::TcpStream","&'a std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // de::StreamDeserializer<'de, R, T>
+p0.byte_offset();
+de::StreamDeserializer::<'de, R, T>::byte_offset(p0);
+crate::de::StreamDeserializer::<'de, R, T>::byte_offset(p0);
+<de::StreamDeserializer<'de, R, T>>::byte_offset(p0);
-----------------
src/de.rs de::StreamDeserializer::<'de, R, T>::peek_end_of_value
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"de::StreamDeserializer::<'de, R, T>::peek_end_of_value":{"R":["std::marker::Sized","read::Read"],"T":["std::marker::Sized","serde::Deserialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"de::StreamDeserializer::<'de, R, T>::peek_end_of_value":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead","read::StrRead"],"T":["number::Number","map::Map","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"read::IoRead":{"R":["&'a std::os::unix::net::UnixStream","std::io::Cursor<T>","std::process::ChildStderr","std::collections::VecDeque<u8, A>","std::io::Stdin","std::process::ChildStdout","std::io::Repeat","&std::net::TcpStream","std::io::Take<T>","std::io::StdinLock<'_>","std::io::Chain<T, U>","std::boxed::Box<R>","std::fs::File","std::sys::unix::stdio::Stdin","std::os::unix::net::UnixStream","std::io::BufReader<R>","&std::fs::File","std::net::TcpStream","std::io::Empty","&'a std::sys::unix::fd::FileDesc","std::io::impls::<impl std::io::Read for &mut R>","std::io::stdio::StdinRaw"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::StreamDeserializer<'de, R, T>
+p0.peek_end_of_value();
+de::StreamDeserializer::<'de, R, T>::peek_end_of_value(p0);
+crate::de::StreamDeserializer::<'de, R, T>::peek_end_of_value(p0);
+<de::StreamDeserializer<'de, R, T>>::peek_end_of_value(p0);
-----------------
src/de.rs <de::StreamDeserializer<'de, R, T> as std::iter::Iterator>::next
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<de::StreamDeserializer<'de, R, T> as std::iter::Iterator>::next":{"R":["read::Read","std::marker::Sized"],"T":["std::marker::Sized","serde::Deserialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<de::StreamDeserializer<'de, R, T> as std::iter::Iterator>::next":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead","read::StrRead"],"T":["value::Value","map::Map","number::Number"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"read::IoRead":{"R":["std::process::ChildStdout","std::io::Stdin","std::collections::VecDeque<u8, A>","std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::boxed::Box<R>","&std::fs::File","std::process::ChildStderr","std::io::Repeat","std::io::BufReader<R>","std::io::stdio::StdinRaw","&'a std::os::unix::net::UnixStream","std::io::Chain<T, U>","std::io::Take<T>","std::io::StdinLock<'_>","&'a std::sys::unix::fd::FileDesc","&std::net::TcpStream","std::fs::File","std::sys::unix::stdio::Stdin","std::io::Cursor<T>","std::io::Empty","std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // de::StreamDeserializer<'de, R, T>
+p0.next();
+<de::StreamDeserializer<'de, R, T> as std::iter::Iterator>::next(p0);
+crate::<de::StreamDeserializer<'de, R, T> as std::iter::Iterator>::next(p0);
+<de::StreamDeserializer<'de, R, T>>::next(p0);
-----------------
src/error.rs error::Error::line
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.line();
+error::Error::line(p0);
+crate::error::Error::line(p0);
+<error::Error>::line(p0);
-----------------
src/error.rs error::Error::column
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.column();
+error::Error::column(p0);
+crate::error::Error::column(p0);
+<error::Error>::column(p0);
-----------------
src/error.rs error::Error::classify
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.classify();
+error::Error::classify(p0);
+crate::error::Error::classify(p0);
+<error::Error>::classify(p0);
-----------------
src/error.rs error::Error::is_io
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.is_io();
+error::Error::is_io(p0);
+crate::error::Error::is_io(p0);
+<error::Error>::is_io(p0);
-----------------
src/error.rs error::Error::is_syntax
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.is_syntax();
+error::Error::is_syntax(p0);
+crate::error::Error::is_syntax(p0);
+<error::Error>::is_syntax(p0);
-----------------
src/error.rs error::Error::is_data
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.is_data();
+error::Error::is_data(p0);
+crate::error::Error::is_data(p0);
+<error::Error>::is_data(p0);
-----------------
src/error.rs error::Error::is_eof
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.is_eof();
+error::Error::is_eof(p0);
+crate::error::Error::is_eof(p0);
+<error::Error>::is_eof(p0);
-----------------
src/error.rs <error::Category as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Category
+p0.clone();
+<error::Category as std::clone::Clone>::clone(p0);
+crate::<error::Category as std::clone::Clone>::clone(p0);
+<error::Category>::clone(p0);
-----------------
src/error.rs <error::Category as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Category
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::Category
+p0.eq(p1);
+<error::Category as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::Category as std::cmp::PartialEq>::eq(p0, p1);
+<error::Category>::eq(p0, p1);
-----------------
src/error.rs <error::Category as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Category
+p0.assert_receiver_is_total_eq();
+<error::Category as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::Category as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::Category>::assert_receiver_is_total_eq(p0);
-----------------
src/error.rs <error::Category as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Category
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Category as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Category as std::fmt::Debug>::fmt(p0, p1);
+<error::Category>::fmt(p0, p1);
-----------------
src/error.rs error::<impl std::convert::From<error::Error> for std::io::Error>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::Error
+error::<impl std::convert::From<error::Error> for std::io::Error>::from(p0);
+crate::error::<impl std::convert::From<error::Error> for std::io::Error>::from(p0);
+<std::io::Error>::from(p0);
-----------------
src/error.rs error::Error::syntax
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::ErrorCode
let mut p1 = 0usize; // None+usize
let mut p2 = 0usize; // None+usize
+error::Error::syntax(p0, p1, p2);
+crate::error::Error::syntax(p0, p1, p2);
+<error::Error>::syntax(p0, p1, p2);
-----------------
src/error.rs error::Error::io
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::io::Error
+error::Error::io(p0);
+crate::error::Error::io(p0);
+<error::Error>::io(p0);
-----------------
src/error.rs error::Error::fix_position
deps:{"error::Error::fix_position":{"F":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"error::Error::fix_position":{"F":["std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::CharEscapeDefault","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::IsWhitespace","core::str::IsAsciiWhitespace","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDebugContinue","core::str::UnsafeBytesToStr","std::boxed::Box<F, A>","core::str::CharEscapeUnicode"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.fix_position(p1);
+error::Error::fix_position(p0, p1);
+crate::error::Error::fix_position(p0, p1);
+<error::Error>::fix_position(p0, p1);
-----------------
src/error.rs <error::ErrorCode as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorCode
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::ErrorCode as std::fmt::Display>::fmt(p0, p1);
+crate::<error::ErrorCode as std::fmt::Display>::fmt(p0, p1);
+<error::ErrorCode>::fmt(p0, p1);
-----------------
src/error.rs <error::Error as std::error::Error>::source
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.source();
+<error::Error as std::error::Error>::source(p0);
+crate::<error::Error as std::error::Error>::source(p0);
+<error::Error>::source(p0);
-----------------
src/error.rs <error::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Display>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
src/error.rs <error::ErrorImpl as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::ErrorImpl
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::ErrorImpl as std::fmt::Display>::fmt(p0, p1);
+crate::<error::ErrorImpl as std::fmt::Display>::fmt(p0, p1);
+<error::ErrorImpl>::fmt(p0, p1);
-----------------
src/error.rs <error::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Debug>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
src/error.rs <error::Error as serde::de::Error>::custom
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<error::Error as serde::de::Error>::custom":{"T":["std::marker::Sized","std::fmt::Display"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<error::Error as serde::de::Error>::custom":{"T":["error::ErrorCode","error::Error","error::ErrorImpl","<&T as std::fmt::Display>","value::index::Type","value::Value","number::Number","<&mut T as std::fmt::Display>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+<error::Error as serde::de::Error>::custom(p0);
+crate::<error::Error as serde::de::Error>::custom(p0);
+<error::Error>::custom(p0);
-----------------
src/error.rs <error::Error as serde::de::Error>::invalid_type
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // serde::de::Unexpected<'_>
let mut p1 = & MaybeUninit::uninit().assume_init(); // dyn serde::de::Expected
+<error::Error as serde::de::Error>::invalid_type(p0, p1);
+crate::<error::Error as serde::de::Error>::invalid_type(p0, p1);
+<error::Error>::invalid_type(p0, p1);
-----------------
src/error.rs <error::Error as serde::ser::Error>::custom
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<error::Error as serde::ser::Error>::custom":{"T":["std::marker::Sized","std::fmt::Display"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<error::Error as serde::ser::Error>::custom":{"T":["value::index::Type","<&T as std::fmt::Display>","<&mut T as std::fmt::Display>","number::Number","error::Error","error::ErrorCode","error::ErrorImpl","value::Value"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+<error::Error as serde::ser::Error>::custom(p0);
+crate::<error::Error as serde::ser::Error>::custom(p0);
+<error::Error>::custom(p0);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::new
deps:{}
candidates:{}
+map::Map::<std::string::String, value::Value>::new();
+crate::map::Map::<std::string::String, value::Value>::new();
+<map::Map<std::string::String, value::Value>>::new();
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::with_capacity
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+map::Map::<std::string::String, value::Value>::with_capacity(p0);
+crate::map::Map::<std::string::String, value::Value>::with_capacity(p0);
+<map::Map<std::string::String, value::Value>>::with_capacity(p0);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::clear
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.clear();
+map::Map::<std::string::String, value::Value>::clear(p0);
+crate::map::Map::<std::string::String, value::Value>::clear(p0);
+<map::Map<std::string::String, value::Value>>::clear(p0);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::get
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::get":{"Q":["std::cmp::Ord","std::hash::Hash","std::cmp::Eq"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::get":{"Q":["bool","std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","char","i64","u64","i8","usize","u16","std::hash::impls::<impl std::hash::Hash for *mut T>","i32","i16","u32","u8"],"std::string::String":["std::rc::Rc<T>","std::ffi::CString","std::sync::Arc<T>","std::boxed::Box<T, A>","std::ffi::OsString","std::string::String","<T as std::borrow::Borrow<T>>","std::path::PathBuf","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>"]},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.get(p1);
+map::Map::<std::string::String, value::Value>::get(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::get(p0, p1);
+<map::Map<std::string::String, value::Value>>::get(p0, p1);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::contains_key
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::contains_key":{"Q":["std::hash::Hash","std::cmp::Ord","std::cmp::Eq"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::contains_key":{"Q":["std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","i64","i32","i16","u32","u8","u16","usize","std::hash::impls::<impl std::hash::Hash for *const T>","u64","i8","bool","char"],"std::string::String":["std::sync::Arc<T>","std::boxed::Box<T, A>","std::ffi::CString","std::ffi::OsString","std::vec::Vec<T, A>","std::rc::Rc<T>","std::string::String","<&mut T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::path::PathBuf"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.contains_key(p1);
+map::Map::<std::string::String, value::Value>::contains_key(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::contains_key(p0, p1);
+<map::Map<std::string::String, value::Value>>::contains_key(p0, p1);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::get_mut
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::get_mut":{"Q":["std::hash::Hash","std::cmp::Ord","std::cmp::Eq"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::get_mut":{"Q":["u16","char","i32","i64","bool","u64","i8","std::hash::impls::<impl std::hash::Hash for *mut T>","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","i16","usize","std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","u8","u32"],"std::string::String":["std::string::String","std::sync::Arc<T>","std::rc::Rc<T>","std::ffi::CString","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","std::ffi::OsString","<&mut T as std::borrow::Borrow<T>>","std::path::PathBuf","std::boxed::Box<T, A>"]},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.get_mut(p1);
+map::Map::<std::string::String, value::Value>::get_mut(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::get_mut(p0, p1);
+<map::Map<std::string::String, value::Value>>::get_mut(p0, p1);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::get_key_value
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::get_key_value":{"Q":["std::cmp::Ord","std::cmp::Eq","std::hash::Hash"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::get_key_value":{"Q":["char","u16","std::hash::impls::<impl std::hash::Hash for *mut T>","std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","u32","bool","u64","i16","i8","i32","u8","usize","i64"],"std::string::String":["<&mut T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::ffi::CString","std::borrow::Cow<'a, B>","std::string::String","std::ffi::OsString","std::vec::Vec<T, A>","std::path::PathBuf","std::rc::Rc<T>","std::sync::Arc<T>"]},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.get_key_value(p1);
+map::Map::<std::string::String, value::Value>::get_key_value(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::get_key_value(p0, p1);
+<map::Map<std::string::String, value::Value>>::get_key_value(p0, p1);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::insert
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = std::string::String::new(); // None+std::string::String
let mut p2 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert(p1, p2);
+map::Map::<std::string::String, value::Value>::insert(p0, p1, p2);
+crate::map::Map::<std::string::String, value::Value>::insert(p0, p1, p2);
+<map::Map<std::string::String, value::Value>>::insert(p0, p1, p2);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::remove
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::remove":{"Q":["std::hash::Hash","std::cmp::Ord","std::cmp::Eq"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::remove":{"Q":["u16","u64","u8","usize","i16","i64","i32","i8","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>","bool","u32","char","std::hash::impls::<impl std::hash::Hash for *const T>"],"std::string::String":["<&mut T as std::borrow::Borrow<T>>","std::ffi::CString","std::vec::Vec<T, A>","std::string::String","std::ffi::OsString","std::path::PathBuf","std::boxed::Box<T, A>","std::borrow::Cow<'a, B>","std::sync::Arc<T>","std::rc::Rc<T>"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.remove(p1);
+map::Map::<std::string::String, value::Value>::remove(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::remove(p0, p1);
+<map::Map<std::string::String, value::Value>>::remove(p0, p1);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::remove_entry
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::remove_entry":{"Q":["std::cmp::Eq","std::cmp::Ord","std::hash::Hash"],"std::string::String":["std::borrow::Borrow"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"map::Map::<std::string::String, value::Value>::remove_entry":{"Q":["u32","u16","u8","u64","usize","bool","i64","i32","char","std::ptr::const_ptr::<impl std::cmp::Ord for *const T>","i16","i8","std::ptr::const_ptr::<impl std::cmp::Eq for *const T>"],"std::string::String":["std::vec::Vec<T, A>","std::rc::Rc<T>","std::path::PathBuf","std::boxed::Box<T, A>","std::ffi::OsString","std::sync::Arc<T>","<T as std::borrow::Borrow<T>>","std::borrow::Cow<'a, B>","std::ffi::CString","std::string::String"]},"std::ptr::const_ptr::<impl std::cmp::Eq for *const T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.remove_entry(p1);
+map::Map::<std::string::String, value::Value>::remove_entry(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::remove_entry(p0, p1);
+<map::Map<std::string::String, value::Value>>::remove_entry(p0, p1);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::append
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.append(p1);
+map::Map::<std::string::String, value::Value>::append(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::append(p0, p1);
+<map::Map<std::string::String, value::Value>>::append(p0, p1);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::entry
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"map::Map::<std::string::String, value::Value>::entry":{"S":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"map::Map::<std::string::String, value::Value>::entry":{"S":["std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"]}}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.entry(p1);
+map::Map::<std::string::String, value::Value>::entry(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::entry(p0, p1);
+<map::Map<std::string::String, value::Value>>::entry(p0, p1);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::len
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.len();
+map::Map::<std::string::String, value::Value>::len(p0);
+crate::map::Map::<std::string::String, value::Value>::len(p0);
+<map::Map<std::string::String, value::Value>>::len(p0);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::is_empty
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.is_empty();
+map::Map::<std::string::String, value::Value>::is_empty(p0);
+crate::map::Map::<std::string::String, value::Value>::is_empty(p0);
+<map::Map<std::string::String, value::Value>>::is_empty(p0);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::iter
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.iter();
+map::Map::<std::string::String, value::Value>::iter(p0);
+crate::map::Map::<std::string::String, value::Value>::iter(p0);
+<map::Map<std::string::String, value::Value>>::iter(p0);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::iter_mut
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.iter_mut();
+map::Map::<std::string::String, value::Value>::iter_mut(p0);
+crate::map::Map::<std::string::String, value::Value>::iter_mut(p0);
+<map::Map<std::string::String, value::Value>>::iter_mut(p0);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::keys
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.keys();
+map::Map::<std::string::String, value::Value>::keys(p0);
+crate::map::Map::<std::string::String, value::Value>::keys(p0);
+<map::Map<std::string::String, value::Value>>::keys(p0);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::values
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.values();
+map::Map::<std::string::String, value::Value>::values(p0);
+crate::map::Map::<std::string::String, value::Value>::values(p0);
+<map::Map<std::string::String, value::Value>>::values(p0);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::values_mut
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.values_mut();
+map::Map::<std::string::String, value::Value>::values_mut(p0);
+crate::map::Map::<std::string::String, value::Value>::values_mut(p0);
+<map::Map<std::string::String, value::Value>>::values_mut(p0);
-----------------
src/map.rs map::Map::<std::string::String, value::Value>::retain
deps:{"map::Map::<std::string::String, value::Value>::retain":{"F":["std::marker::Sized","std::ops::FnMut"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
candidates:{"map::Map::<std::string::String, value::Value>::retain":{"F":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","std::boxed::Box<F, A>","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::str::LinesAnyMap","core::str::IsWhitespace","core::str::CharEscapeDefault","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>","core::str::CharEscapeUnicode"]},"std::ops::function::impls::<impl std::ops::FnMut<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnMut<A> for &mut F>":{}}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.retain(p1);
+map::Map::<std::string::String, value::Value>::retain(p0, p1);
+crate::map::Map::<std::string::String, value::Value>::retain(p0, p1);
+<map::Map<std::string::String, value::Value>>::retain(p0, p1);
-----------------
src/map.rs <map::Map<std::string::String, value::Value> as std::default::Default>::default
deps:{}
candidates:{}
+<map::Map<std::string::String, value::Value> as std::default::Default>::default();
+crate::<map::Map<std::string::String, value::Value> as std::default::Default>::default();
+<map::Map<std::string::String, value::Value>>::default();
-----------------
src/map.rs <map::Map<std::string::String, value::Value> as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.clone();
+<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone(p0);
+crate::<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone(p0);
+<map::Map<std::string::String, value::Value>>::clone(p0);
-----------------
src/map.rs <map::Map<std::string::String, value::Value> as std::clone::Clone>::clone_from
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.clone_from(p1);
+<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone_from(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as std::clone::Clone>::clone_from(p0, p1);
+<map::Map<std::string::String, value::Value>>::clone_from(p0, p1);
-----------------
src/map.rs <map::Map<std::string::String, value::Value> as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.eq(p1);
+<map::Map<std::string::String, value::Value> as std::cmp::PartialEq>::eq(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as std::cmp::PartialEq>::eq(p0, p1);
+<map::Map<std::string::String, value::Value>>::eq(p0, p1);
-----------------
src/map.rs <map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index":{"Q":["std::cmp::Eq","std::hash::Hash","std::cmp::Ord"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index":{"Q":["std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>","std::hash::impls::<impl std::hash::Hash for *mut T>","i16","std::hash::impls::<impl std::hash::Hash for *const T>","u16","i32","bool","u8","i64","char","i8","usize","u64","u32"],"std::string::String":["std::ffi::CString","std::ffi::OsString","std::borrow::Cow<'a, B>","std::vec::Vec<T, A>","<&mut T as std::borrow::Borrow<T>>","std::rc::Rc<T>","std::sync::Arc<T>","std::boxed::Box<T, A>","std::string::String","std::path::PathBuf"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::mut_ptr::<impl std::cmp::Eq for *mut T>":{}}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.index(p1);
+<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as std::ops::Index<&'a Q>>::index(p0, p1);
+<map::Map<std::string::String, value::Value>>::index(p0, p1);
-----------------
src/map.rs <map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut
'a
deps:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut":{"Q":["std::cmp::Ord","std::cmp::Eq","std::hash::Hash"],"std::string::String":["std::borrow::Borrow"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
candidates:{"<&T as std::borrow::Borrow<T>>":{},"<&mut T as std::borrow::Borrow<T>>":{},"<T as std::borrow::Borrow<T>>":{},"<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut":{"Q":["u16","bool","i16","i64","u64","i32","usize","char","i8","std::hash::impls::<impl std::hash::Hash for *const T>","std::hash::impls::<impl std::hash::Hash for *mut T>","std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>","u32","u8"],"std::string::String":["std::borrow::Cow<'a, B>","std::rc::Rc<T>","std::ffi::CString","std::string::String","std::sync::Arc<T>","<&T as std::borrow::Borrow<T>>","std::boxed::Box<T, A>","std::ffi::OsString","std::path::PathBuf","std::vec::Vec<T, A>"]},"std::hash::impls::<impl std::hash::Hash for *const T>":{},"std::hash::impls::<impl std::hash::Hash for *mut T>":{},"std::ptr::const_ptr::<impl std::cmp::Ord for *const T>":{},"std::ptr::mut_ptr::<impl std::cmp::Ord for *mut T>":{}}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = & MaybeUninit::uninit().assume_init(); // Q
+p0.index_mut(p1);
+<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as std::ops::IndexMut<&'a Q>>::index_mut(p0, p1);
+<map::Map<std::string::String, value::Value>>::index_mut(p0, p1);
-----------------
src/map.rs <map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt(p0, p1);
+<map::Map<std::string::String, value::Value>>::fmt(p0, p1);
-----------------
src/map.rs <map::Map<std::string::String, value::Value> as serde::Serialize>::serialize
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>":{},"<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize":{"S":["serde::Serializer","std::marker::Sized"]},"ser::MapKeySerializer":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"serde::ser::fmt::<impl serde::Serializer for &mut std::fmt::Formatter<'a>>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>":{},"<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize":{"S":["<&'a mut ser::Serializer<W, F> as serde::Serializer>","value::ser::MapKeySerializer","ser::MapKeySerializer","value::ser::Serializer","serde::ser::fmt::<impl serde::Serializer for &mut std::fmt::Formatter<'a>>"]},"ser::MapKeySerializer":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"serde::ser::fmt::<impl serde::Serializer for &mut std::fmt::Formatter<'a>>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.serialize(p1);
+<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as serde::Serialize>::serialize(p0, p1);
+<map::Map<std::string::String, value::Value>>::serialize(p0, p1);
-----------------
src/map.rs <map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>":{},"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize":{"D":["serde::Deserializer","std::marker::Sized"]},"de::MapKey":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>":{},"<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize":{"D":["number::Number","<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>","value::de::BorrowedCowStrDeserializer","de::MapKey","value::Value","value::de::MapKeyDeserializer"]},"de::MapKey":{"R":["read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::SliceRead"]},"read::IoRead":{"R":["std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin","&std::net::TcpStream","std::io::StdinLock<'_>","&std::fs::File","std::io::Cursor<T>","std::os::unix::net::UnixStream","std::process::ChildStderr","std::sys::unix::stdio::Stdin","std::io::stdio::StdinRaw","std::process::ChildStdout","std::boxed::Box<R>","std::net::TcpStream","std::io::Chain<T, U>","&'a std::os::unix::net::UnixStream","std::io::Empty","std::collections::VecDeque<u8, A>","std::io::Repeat","std::io::Take<T>","&'a std::sys::unix::fd::FileDesc","std::io::BufReader<R>","std::fs::File"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize(p0);
+crate::<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize(p0);
+<map::Map<std::string::String, value::Value>>::deserialize(p0);
-----------------
src/map.rs <<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor>::expecting(p0, p1);
-----------------
src/map.rs <<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit
'de
deps:{"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit":{"E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit":{"E":["error::Error"]}}
let mut p0 = std::string::String::new(); // None+<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor
+p0.visit_unit();
+<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit(p0);
+crate::<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_unit(p0);
+<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor>::visit_unit(p0);
-----------------
src/map.rs <<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&mut A as serde::de::MapAccess<'de>>":{},"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map":{"V":["std::marker::Sized","serde::de::MapAccess"]},"de::MapAccess":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&mut A as serde::de::MapAccess<'de>>":{},"<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map":{"V":["<&mut A as serde::de::MapAccess<'de>>","de::MapAccess","value::de::MapDeserializer","value::de::MapRefDeserializer"]},"de::MapAccess":{"R":["read::SliceRead","read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead"]},"read::IoRead":{"R":["std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","std::io::Repeat","std::io::StdinLock<'_>","std::io::Empty","std::fs::File","std::io::BufReader<R>","std::process::ChildStdout","std::boxed::Box<R>","&std::fs::File","std::io::Stdin","std::io::Chain<T, U>","std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::io::Take<T>","std::process::ChildStderr","std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::io::Cursor<T>","std::net::TcpStream","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = std::string::String::new(); // None+<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.visit_map(p1);
+<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor>::visit_map(p0, p1);
-----------------
src/map.rs <map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter":{"T":["std::marker::Sized","std::iter::IntoIterator"]},"de::StreamDeserializer":{"R":["std::marker::Sized","read::Read","read::Fused"],"T":["serde::Deserialize","std::marker::Sized"]},"iter::LineColIterator":{"I":["std::iter::Iterator","std::marker::Sized"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["map::Keys","map::Iter","map::IterMut","<&mut I as std::iter::Iterator>","map::IntoIter","map::Values","map::ValuesMut","iter::LineColIterator","de::StreamDeserializer"]},"<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter":{"T":["<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>","<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>","map::Map"]},"de::StreamDeserializer":{"R":["read::SliceRead","read::StrRead"],"T":["value::Value","number::Number","map::Map"]},"iter::LineColIterator":{"I":["map::IterMut","map::Iter","map::IntoIter","map::Keys","map::ValuesMut","iter::LineColIterator","de::StreamDeserializer","<&mut I as std::iter::Iterator>","map::Values"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // T
+<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter(p0);
+crate::<map::Map<std::string::String, value::Value> as std::iter::FromIterator<(std::string::String, value::Value)>>::from_iter(p0);
+<map::Map<std::string::String, value::Value>>::from_iter(p0);
-----------------
src/map.rs <map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend":{"T":["std::iter::IntoIterator","std::marker::Sized"]},"de::StreamDeserializer":{"R":["std::marker::Sized","read::Read","read::Fused"],"T":["serde::Deserialize","std::marker::Sized"]},"iter::LineColIterator":{"I":["std::marker::Sized","std::iter::Iterator"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["<&mut I as std::iter::Iterator>","iter::LineColIterator","map::Keys","map::IterMut","de::StreamDeserializer","map::IntoIter","map::ValuesMut","map::Values","map::Iter"]},"<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend":{"T":["<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>","map::Map","<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>"]},"de::StreamDeserializer":{"R":["read::SliceRead","read::StrRead"],"T":["value::Value","map::Map","number::Number"]},"iter::LineColIterator":{"I":["map::IntoIter","map::Keys","<&mut I as std::iter::Iterator>","de::StreamDeserializer","iter::LineColIterator","map::Iter","map::Values","map::ValuesMut","map::IterMut"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.extend(p1);
+<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend(p0, p1);
+crate::<map::Map<std::string::String, value::Value> as std::iter::Extend<(std::string::String, value::Value)>>::extend(p0, p1);
+<map::Map<std::string::String, value::Value>>::extend(p0, p1);
-----------------
src/map.rs map::Entry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Entry<'a>
+p0.key();
+map::Entry::<'a>::key(p0);
+crate::map::Entry::<'a>::key(p0);
+<map::Entry<'a>>::key(p0);
-----------------
src/map.rs map::Entry::<'a>::or_insert
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // map::Entry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.or_insert(p1);
+map::Entry::<'a>::or_insert(p0, p1);
+crate::map::Entry::<'a>::or_insert(p0, p1);
+<map::Entry<'a>>::or_insert(p0, p1);
-----------------
src/map.rs map::Entry::<'a>::or_insert_with
'a
deps:{"map::Entry::<'a>::or_insert_with":{"F":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"map::Entry::<'a>::or_insert_with":{"F":["core::str::CharEscapeDebugContinue","core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsAsciiWhitespace","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // map::Entry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.or_insert_with(p1);
+map::Entry::<'a>::or_insert_with(p0, p1);
+crate::map::Entry::<'a>::or_insert_with(p0, p1);
+<map::Entry<'a>>::or_insert_with(p0, p1);
-----------------
src/map.rs map::Entry::<'a>::and_modify
'a
deps:{"map::Entry::<'a>::and_modify":{"F":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"map::Entry::<'a>::and_modify":{"F":["core::str::BytesIsNotEmpty","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsNotEmpty","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::UnsafeBytesToStr","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","core::str::CharEscapeDebugContinue","std::boxed::Box<F, A>","core::str::IsWhitespace","std::panic::AssertUnwindSafe<F>","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","core::str::IsAsciiWhitespace","core::str::CharEscapeUnicode"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // map::Entry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+p0.and_modify(p1);
+map::Entry::<'a>::and_modify(p0, p1);
+crate::map::Entry::<'a>::and_modify(p0, p1);
+<map::Entry<'a>>::and_modify(p0, p1);
-----------------
src/map.rs map::VacantEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::VacantEntry<'a>
+p0.key();
+map::VacantEntry::<'a>::key(p0);
+crate::map::VacantEntry::<'a>::key(p0);
+<map::VacantEntry<'a>>::key(p0);
-----------------
src/map.rs map::VacantEntry::<'a>::insert
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // map::VacantEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert(p1);
+map::VacantEntry::<'a>::insert(p0, p1);
+crate::map::VacantEntry::<'a>::insert(p0, p1);
+<map::VacantEntry<'a>>::insert(p0, p1);
-----------------
src/map.rs map::OccupiedEntry::<'a>::key
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::OccupiedEntry<'a>
+p0.key();
+map::OccupiedEntry::<'a>::key(p0);
+crate::map::OccupiedEntry::<'a>::key(p0);
+<map::OccupiedEntry<'a>>::key(p0);
-----------------
src/map.rs map::OccupiedEntry::<'a>::get
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::OccupiedEntry<'a>
+p0.get();
+map::OccupiedEntry::<'a>::get(p0);
+crate::map::OccupiedEntry::<'a>::get(p0);
+<map::OccupiedEntry<'a>>::get(p0);
-----------------
src/map.rs map::OccupiedEntry::<'a>::get_mut
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::OccupiedEntry<'a>
+p0.get_mut();
+map::OccupiedEntry::<'a>::get_mut(p0);
+crate::map::OccupiedEntry::<'a>::get_mut(p0);
+<map::OccupiedEntry<'a>>::get_mut(p0);
-----------------
src/map.rs map::OccupiedEntry::<'a>::into_mut
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // map::OccupiedEntry<'a>
+p0.into_mut();
+map::OccupiedEntry::<'a>::into_mut(p0);
+crate::map::OccupiedEntry::<'a>::into_mut(p0);
+<map::OccupiedEntry<'a>>::into_mut(p0);
-----------------
src/map.rs map::OccupiedEntry::<'a>::insert
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::OccupiedEntry<'a>
let mut p1 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.insert(p1);
+map::OccupiedEntry::<'a>::insert(p0, p1);
+crate::map::OccupiedEntry::<'a>::insert(p0, p1);
+<map::OccupiedEntry<'a>>::insert(p0, p1);
-----------------
src/map.rs map::OccupiedEntry::<'a>::remove
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // map::OccupiedEntry<'a>
+p0.remove();
+map::OccupiedEntry::<'a>::remove(p0);
+crate::map::OccupiedEntry::<'a>::remove(p0);
+<map::OccupiedEntry<'a>>::remove(p0);
-----------------
src/map.rs <&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.into_iter();
+<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter(p0);
+<&'a map::Map<std::string::String, value::Value>>::into_iter(p0);
-----------------
src/map.rs <map::Iter<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::Iter<'a>
+p0.next();
+<map::Iter<'a> as std::iter::Iterator>::next(p0);
+crate::<map::Iter<'a> as std::iter::Iterator>::next(p0);
+<map::Iter<'a>>::next(p0);
-----------------
src/map.rs <map::Iter<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Iter<'a>
+p0.size_hint();
+<map::Iter<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<map::Iter<'a> as std::iter::Iterator>::size_hint(p0);
+<map::Iter<'a>>::size_hint(p0);
-----------------
src/map.rs <map::Iter<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::Iter<'a>
+p0.next_back();
+<map::Iter<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<map::Iter<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<map::Iter<'a>>::next_back(p0);
-----------------
src/map.rs <map::Iter<'a> as std::iter::ExactSizeIterator>::len
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Iter<'a>
+p0.len();
+<map::Iter<'a> as std::iter::ExactSizeIterator>::len(p0);
+crate::<map::Iter<'a> as std::iter::ExactSizeIterator>::len(p0);
+<map::Iter<'a>>::len(p0);
-----------------
src/map.rs <&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter
'a
deps:{}
candidates:{}
let mut p0 = &mut std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.into_iter();
+<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter(p0);
+crate::<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter(p0);
+<&'a mut map::Map<std::string::String, value::Value>>::into_iter(p0);
-----------------
src/map.rs <map::IterMut<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::IterMut<'a>
+p0.next();
+<map::IterMut<'a> as std::iter::Iterator>::next(p0);
+crate::<map::IterMut<'a> as std::iter::Iterator>::next(p0);
+<map::IterMut<'a>>::next(p0);
-----------------
src/map.rs <map::IterMut<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::IterMut<'a>
+p0.size_hint();
+<map::IterMut<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<map::IterMut<'a> as std::iter::Iterator>::size_hint(p0);
+<map::IterMut<'a>>::size_hint(p0);
-----------------
src/map.rs <map::IterMut<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::IterMut<'a>
+p0.next_back();
+<map::IterMut<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<map::IterMut<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<map::IterMut<'a>>::next_back(p0);
-----------------
src/map.rs <map::IterMut<'a> as std::iter::ExactSizeIterator>::len
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::IterMut<'a>
+p0.len();
+<map::IterMut<'a> as std::iter::ExactSizeIterator>::len(p0);
+crate::<map::IterMut<'a> as std::iter::ExactSizeIterator>::len(p0);
+<map::IterMut<'a>>::len(p0);
-----------------
src/map.rs <map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+p0.into_iter();
+<map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter(p0);
+crate::<map::Map<std::string::String, value::Value> as std::iter::IntoIterator>::into_iter(p0);
+<map::Map<std::string::String, value::Value>>::into_iter(p0);
-----------------
src/map.rs <map::IntoIter as std::iter::Iterator>::next
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::IntoIter
+p0.next();
+<map::IntoIter as std::iter::Iterator>::next(p0);
+crate::<map::IntoIter as std::iter::Iterator>::next(p0);
+<map::IntoIter>::next(p0);
-----------------
src/map.rs <map::IntoIter as std::iter::Iterator>::size_hint
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::IntoIter
+p0.size_hint();
+<map::IntoIter as std::iter::Iterator>::size_hint(p0);
+crate::<map::IntoIter as std::iter::Iterator>::size_hint(p0);
+<map::IntoIter>::size_hint(p0);
-----------------
src/map.rs <map::IntoIter as std::iter::DoubleEndedIterator>::next_back
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::IntoIter
+p0.next_back();
+<map::IntoIter as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<map::IntoIter as std::iter::DoubleEndedIterator>::next_back(p0);
+<map::IntoIter>::next_back(p0);
-----------------
src/map.rs <map::IntoIter as std::iter::ExactSizeIterator>::len
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::IntoIter
+p0.len();
+<map::IntoIter as std::iter::ExactSizeIterator>::len(p0);
+crate::<map::IntoIter as std::iter::ExactSizeIterator>::len(p0);
+<map::IntoIter>::len(p0);
-----------------
src/map.rs <map::Keys<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::Keys<'a>
+p0.next();
+<map::Keys<'a> as std::iter::Iterator>::next(p0);
+crate::<map::Keys<'a> as std::iter::Iterator>::next(p0);
+<map::Keys<'a>>::next(p0);
-----------------
src/map.rs <map::Keys<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Keys<'a>
+p0.size_hint();
+<map::Keys<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<map::Keys<'a> as std::iter::Iterator>::size_hint(p0);
+<map::Keys<'a>>::size_hint(p0);
-----------------
src/map.rs <map::Keys<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::Keys<'a>
+p0.next_back();
+<map::Keys<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<map::Keys<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<map::Keys<'a>>::next_back(p0);
-----------------
src/map.rs <map::Keys<'a> as std::iter::ExactSizeIterator>::len
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Keys<'a>
+p0.len();
+<map::Keys<'a> as std::iter::ExactSizeIterator>::len(p0);
+crate::<map::Keys<'a> as std::iter::ExactSizeIterator>::len(p0);
+<map::Keys<'a>>::len(p0);
-----------------
src/map.rs <map::Values<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::Values<'a>
+p0.next();
+<map::Values<'a> as std::iter::Iterator>::next(p0);
+crate::<map::Values<'a> as std::iter::Iterator>::next(p0);
+<map::Values<'a>>::next(p0);
-----------------
src/map.rs <map::Values<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Values<'a>
+p0.size_hint();
+<map::Values<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<map::Values<'a> as std::iter::Iterator>::size_hint(p0);
+<map::Values<'a>>::size_hint(p0);
-----------------
src/map.rs <map::Values<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::Values<'a>
+p0.next_back();
+<map::Values<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<map::Values<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<map::Values<'a>>::next_back(p0);
-----------------
src/map.rs <map::Values<'a> as std::iter::ExactSizeIterator>::len
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::Values<'a>
+p0.len();
+<map::Values<'a> as std::iter::ExactSizeIterator>::len(p0);
+crate::<map::Values<'a> as std::iter::ExactSizeIterator>::len(p0);
+<map::Values<'a>>::len(p0);
-----------------
src/map.rs <map::ValuesMut<'a> as std::iter::Iterator>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::ValuesMut<'a>
+p0.next();
+<map::ValuesMut<'a> as std::iter::Iterator>::next(p0);
+crate::<map::ValuesMut<'a> as std::iter::Iterator>::next(p0);
+<map::ValuesMut<'a>>::next(p0);
-----------------
src/map.rs <map::ValuesMut<'a> as std::iter::Iterator>::size_hint
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::ValuesMut<'a>
+p0.size_hint();
+<map::ValuesMut<'a> as std::iter::Iterator>::size_hint(p0);
+crate::<map::ValuesMut<'a> as std::iter::Iterator>::size_hint(p0);
+<map::ValuesMut<'a>>::size_hint(p0);
-----------------
src/map.rs <map::ValuesMut<'a> as std::iter::DoubleEndedIterator>::next_back
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // map::ValuesMut<'a>
+p0.next_back();
+<map::ValuesMut<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+crate::<map::ValuesMut<'a> as std::iter::DoubleEndedIterator>::next_back(p0);
+<map::ValuesMut<'a>>::next_back(p0);
-----------------
src/map.rs <map::ValuesMut<'a> as std::iter::ExactSizeIterator>::len
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // map::ValuesMut<'a>
+p0.len();
+<map::ValuesMut<'a> as std::iter::ExactSizeIterator>::len(p0);
+crate::<map::ValuesMut<'a> as std::iter::ExactSizeIterator>::len(p0);
+<map::ValuesMut<'a>>::len(p0);
-----------------
src/ser.rs ser::Serializer::<W>::new
deps:{"ser::Serializer::<W>::new":{"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Serializer::<W>::new":{"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // W
+ser::Serializer::<W>::new(p0);
+crate::ser::Serializer::<W>::new(p0);
+<ser::Serializer<W>>::new(p0);
-----------------
src/ser.rs ser::Serializer::<W, ser::PrettyFormatter<'a>>::pretty
'a
deps:{"ser::Serializer::<W, ser::PrettyFormatter<'a>>::pretty":{"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Serializer::<W, ser::PrettyFormatter<'a>>::pretty":{"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // W
+ser::Serializer::<W, ser::PrettyFormatter<'a>>::pretty(p0);
+crate::ser::Serializer::<W, ser::PrettyFormatter<'a>>::pretty(p0);
+<ser::Serializer<W, ser::PrettyFormatter<'a>>>::pretty(p0);
-----------------
src/ser.rs ser::Serializer::<W, F>::with_formatter
deps:{"ser::Serializer::<W, F>::with_formatter":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Serializer::<W, F>::with_formatter":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // W
let mut p1 = MaybeUninit::uninit().assume_init(); // F
+ser::Serializer::<W, F>::with_formatter(p0, p1);
+crate::ser::Serializer::<W, F>::with_formatter(p0, p1);
+<ser::Serializer<W, F>>::with_formatter(p0, p1);
-----------------
src/ser.rs ser::Serializer::<W, F>::into_inner
deps:{"ser::Serializer::<W, F>::into_inner":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"ser::Serializer::<W, F>::into_inner":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
+p0.into_inner();
+ser::Serializer::<W, F>::into_inner(p0);
+crate::ser::Serializer::<W, F>::into_inner(p0);
+<ser::Serializer<W, F>>::into_inner(p0);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bool
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bool":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bool":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = true; // None+bool
+p0.serialize_bool(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bool(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bool(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_bool(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i8
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i8":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i8":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0i8; // None+i8
+p0.serialize_i8(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i8(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i8(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_i8(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i16
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i16":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i16":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0i16; // None+i16
+p0.serialize_i16(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i16(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i16(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_i16(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i32
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i32":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i32":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0i32; // None+i32
+p0.serialize_i32(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i32(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i32(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_i32(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i64
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i64":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i64":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0i64; // None+i64
+p0.serialize_i64(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i64(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i64(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_i64(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i128
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i128":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i128":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0i128; // None+i128
+p0.serialize_i128(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i128(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_i128(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_i128(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u8
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u8":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u8":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0u8; // None+u8
+p0.serialize_u8(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u8(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u8(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_u8(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u16
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u16":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u16":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0u16; // None+u16
+p0.serialize_u16(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u16(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u16(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_u16(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u32
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u32":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u32":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0u32; // None+u32
+p0.serialize_u32(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u32(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u32(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_u32(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u64
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u64":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u64":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0u64; // None+u64
+p0.serialize_u64(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u64(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u64(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_u64(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u128
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u128":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u128":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0u128; // None+u128
+p0.serialize_u128(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u128(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_u128(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_u128(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f32
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f32":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f32":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0f32; // None+f32
+p0.serialize_f32(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f32(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f32(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_f32(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f64
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f64":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f64":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0f64; // None+f64
+p0.serialize_f64(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f64(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_f64(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_f64(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_char
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_char":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_char":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 'a'; // None+char
+p0.serialize_char(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_char(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_char(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_char(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_str
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_str":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_str":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = "sample"; // None+&str
+p0.serialize_str(&p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_str(p0, &p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_str(p0, &p1);
+<&'a mut ser::Serializer<W, F>>::serialize_str(p0, &p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bytes
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bytes":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bytes":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.serialize_bytes(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bytes(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_bytes(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_bytes(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
+p0.serialize_unit();
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit(p0);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit(p0);
+<&'a mut ser::Serializer<W, F>>::serialize_unit(p0);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_struct
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_struct":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_struct":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = "sample"; // None+&str
+p0.serialize_unit_struct(&p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_struct(p0, &p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_struct(p0, &p1);
+<&'a mut ser::Serializer<W, F>>::serialize_unit_struct(p0, &p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_variant
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_variant":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_variant":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
+p0.serialize_unit_variant(&p1, p2, &p3);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+<&'a mut ser::Serializer<W, F>>::serialize_unit_variant(p0, &p1, p2, &p3);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_struct
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_struct":{"F":["ser::Formatter","std::marker::Sized"],"T":["serde::Serialize"],"W":["std::marker::Sized","std::io::Write"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_struct":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"T":["map::Map","serde::ser::impls::<impl serde::Serialize for &'a mut T>","number::Number","value::Value"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_struct(&p1, p2);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+<&'a mut ser::Serializer<W, F>>::serialize_newtype_struct(p0, &p1, p2);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_variant
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_variant":{"F":["std::marker::Sized","ser::Formatter"],"T":["serde::Serialize"],"W":["std::marker::Sized","std::io::Write"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_variant":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"T":["number::Number","serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","value::Value"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_variant(&p1, p2, &p3, p4);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+<&'a mut ser::Serializer<W, F>>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_none
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_none":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_none":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
+p0.serialize_none();
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_none(p0);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_none(p0);
+<&'a mut ser::Serializer<W, F>>::serialize_none(p0);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_some
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_some":{"F":["std::marker::Sized","ser::Formatter"],"T":["serde::Serialize"],"W":["std::marker::Sized","std::io::Write"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_some":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"T":["value::Value","number::Number","serde::ser::impls::<impl serde::Serialize for &'a mut T>","map::Map"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_some(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_some(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_some(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_some(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_seq
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_seq":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_seq":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_seq(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_seq(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_seq(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_seq(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = 0usize; // None+usize
+p0.serialize_tuple(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_tuple(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_struct
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_struct":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_struct":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_tuple_struct(&p1, p2);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+<&'a mut ser::Serializer<W, F>>::serialize_tuple_struct(p0, &p1, p2);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_variant
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_variant":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_variant":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_tuple_variant(&p1, p2, &p3, p4);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+<&'a mut ser::Serializer<W, F>>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_map
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_map":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_map":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_map(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_map(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_map(p0, p1);
+<&'a mut ser::Serializer<W, F>>::serialize_map(p0, p1);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_struct(&p1, p2);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct(p0, &p1, p2);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct(p0, &p1, p2);
+<&'a mut ser::Serializer<W, F>>::serialize_struct(p0, &p1, p2);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct_variant
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct_variant":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct_variant":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_struct_variant(&p1, p2, &p3, p4);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+<&'a mut ser::Serializer<W, F>>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
-----------------
src/ser.rs <&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str
'a
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str":{"F":["std::marker::Sized","ser::Formatter"],"T":["std::fmt::Display"],"W":["std::io::Write","std::marker::Sized"]},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"T":["value::Value","<&T as std::fmt::Display>","error::ErrorCode","value::index::Type","error::ErrorImpl","error::Error","number::Number"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Serializer<W, F>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.collect_str(p1);
+<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str(p0, p1);
+crate::<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str(p0, p1);
+<&'a mut ser::Serializer<W, F>>::collect_str(p0, p1);
-----------------
src/ser.rs <<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F> as std::fmt::Write>::write_str
'ser
deps:{"<<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F> as std::fmt::Write>::write_str":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F> as std::fmt::Write>::write_str":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // <&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F>
let mut p1 = "sample"; // None+&str
+p0.write_str(&p1);
+<<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F> as std::fmt::Write>::write_str(p0, &p1);
+crate::<<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F> as std::fmt::Write>::write_str(p0, &p1);
+<<&'a mut ser::Serializer<W, F> as serde::Serializer>::collect_str::Adapter<'ser, W, F>>::write_str(p0, &p1);
-----------------
src/ser.rs <ser::State as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::State
+p0.assert_receiver_is_total_eq();
+<ser::State as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<ser::State as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<ser::State>::assert_receiver_is_total_eq(p0);
-----------------
src/ser.rs <ser::State as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::State
let mut p1 = & MaybeUninit::uninit().assume_init(); // ser::State
+p0.eq(p1);
+<ser::State as std::cmp::PartialEq>::eq(p0, p1);
+crate::<ser::State as std::cmp::PartialEq>::eq(p0, p1);
+<ser::State>::eq(p0, p1);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::serialize_element
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::serialize_element":{"F":["std::marker::Sized","ser::Formatter"],"T":["serde::Serialize"],"W":["std::marker::Sized","std::io::Write"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::serialize_element":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"T":["number::Number","map::Map","value::Value","serde::ser::impls::<impl serde::Serialize for &'a T>"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_element(p1);
+<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::serialize_element(p0, p1);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::serialize_element(p0, p1);
+<ser::Compound<'a, W, F>>::serialize_element(p0, p1);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::end
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::end":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::end":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
+p0.end();
+<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::end(p0);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeSeq>::end(p0);
+<ser::Compound<'a, W, F>>::end(p0);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::serialize_element
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::serialize_element":{"F":["std::marker::Sized","ser::Formatter"],"T":["serde::Serialize"],"W":["std::marker::Sized","std::io::Write"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::serialize_element":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","value::Value","number::Number","map::Map"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_element(p1);
+<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::serialize_element(p0, p1);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::serialize_element(p0, p1);
+<ser::Compound<'a, W, F>>::serialize_element(p0, p1);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::end
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::end":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::end":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
+p0.end();
+<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::end(p0);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeTuple>::end(p0);
+<ser::Compound<'a, W, F>>::end(p0);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::serialize_field
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::serialize_field":{"F":["ser::Formatter","std::marker::Sized"],"T":["serde::Serialize"],"W":["std::io::Write","std::marker::Sized"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::serialize_field":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","value::Value","number::Number"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(p1);
+<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::serialize_field(p0, p1);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::serialize_field(p0, p1);
+<ser::Compound<'a, W, F>>::serialize_field(p0, p1);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::end
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::end":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::end":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
+p0.end();
+<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::end(p0);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeTupleStruct>::end(p0);
+<ser::Compound<'a, W, F>>::end(p0);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::serialize_field
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::serialize_field":{"F":["std::marker::Sized","ser::Formatter"],"T":["serde::Serialize"],"W":["std::io::Write","std::marker::Sized"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::serialize_field":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"T":["number::Number","value::Value","map::Map","serde::ser::impls::<impl serde::Serialize for &'a T>"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(p1);
+<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::serialize_field(p0, p1);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::serialize_field(p0, p1);
+<ser::Compound<'a, W, F>>::serialize_field(p0, p1);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::end
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::end":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::end":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
+p0.end();
+<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::end(p0);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeTupleVariant>::end(p0);
+<ser::Compound<'a, W, F>>::end(p0);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_key
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_key":{"F":["std::marker::Sized","ser::Formatter"],"T":["serde::Serialize"],"W":["std::marker::Sized","std::io::Write"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_key":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"T":["map::Map","number::Number","serde::ser::impls::<impl serde::Serialize for &'a T>","value::Value"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_key(p1);
+<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_key(p0, p1);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_key(p0, p1);
+<ser::Compound<'a, W, F>>::serialize_key(p0, p1);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_value
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_value":{"F":["ser::Formatter","std::marker::Sized"],"T":["serde::Serialize"],"W":["std::marker::Sized","std::io::Write"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_value":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"T":["map::Map","number::Number","serde::ser::impls::<impl serde::Serialize for &'a T>","value::Value"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_value(p1);
+<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_value(p0, p1);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::serialize_value(p0, p1);
+<ser::Compound<'a, W, F>>::serialize_value(p0, p1);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeMap>::end
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::end":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::end":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
+p0.end();
+<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::end(p0);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeMap>::end(p0);
+<ser::Compound<'a, W, F>>::end(p0);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::serialize_field
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::serialize_field":{"F":["ser::Formatter","std::marker::Sized"],"T":["serde::Serialize"],"W":["std::marker::Sized","std::io::Write"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::serialize_field":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"T":["value::Value","map::Map","serde::ser::impls::<impl serde::Serialize for &'a T>","number::Number"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(&p1, p2);
+<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+<ser::Compound<'a, W, F>>::serialize_field(p0, &p1, p2);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::end
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::end":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::end":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
+p0.end();
+<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::end(p0);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeStruct>::end(p0);
+<ser::Compound<'a, W, F>>::end(p0);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::serialize_field
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::serialize_field":{"F":["ser::Formatter","std::marker::Sized"],"T":["serde::Serialize"],"W":["std::marker::Sized","std::io::Write"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::serialize_field":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","value::Value","number::Number","map::Map"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(&p1, p2);
+<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::serialize_field(p0, &p1, p2);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::serialize_field(p0, &p1, p2);
+<ser::Compound<'a, W, F>>::serialize_field(p0, &p1, p2);
-----------------
src/ser.rs <ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::end
'a
deps:{"<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::end":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::end":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::Compound<'a, W, F>
+p0.end();
+<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::end(p0);
+crate::<ser::Compound<'a, W, F> as serde::ser::SerializeStructVariant>::end(p0);
+<ser::Compound<'a, W, F>>::end(p0);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_str
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_str":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_str":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = "sample"; // None+&str
+p0.serialize_str(&p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_str(p0, &p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_str(p0, &p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_str(p0, &p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_variant
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_variant":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_variant":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
+p0.serialize_unit_variant(&p1, p2, &p3);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+<ser::MapKeySerializer<'a, W, F>>::serialize_unit_variant(p0, &p1, p2, &p3);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_struct
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_struct":{"F":["ser::Formatter","std::marker::Sized"],"T":["serde::Serialize"],"W":["std::io::Write","std::marker::Sized"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_struct":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"T":["value::Value","map::Map","serde::ser::impls::<impl serde::Serialize for &'a mut T>","number::Number"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_struct(&p1, p2);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+<ser::MapKeySerializer<'a, W, F>>::serialize_newtype_struct(p0, &p1, p2);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bool
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bool":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bool":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = true; // None+bool
+p0.serialize_bool(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bool(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bool(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_bool(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i8
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i8":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i8":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0i8; // None+i8
+p0.serialize_i8(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i8(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i8(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_i8(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i16
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i16":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i16":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0i16; // None+i16
+p0.serialize_i16(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i16(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i16(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_i16(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i32
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i32":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i32":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0i32; // None+i32
+p0.serialize_i32(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i32(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i32(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_i32(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i64
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i64":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i64":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0i64; // None+i64
+p0.serialize_i64(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i64(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i64(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_i64(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i128
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i128":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i128":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0i128; // None+i128
+p0.serialize_i128(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i128(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_i128(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_i128(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u8
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u8":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u8":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0u8; // None+u8
+p0.serialize_u8(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u8(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u8(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_u8(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u16
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u16":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u16":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0u16; // None+u16
+p0.serialize_u16(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u16(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u16(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_u16(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u32
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u32":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u32":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0u32; // None+u32
+p0.serialize_u32(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u32(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u32(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_u32(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u64
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u64":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u64":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0u64; // None+u64
+p0.serialize_u64(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u64(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u64(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_u64(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u128
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u128":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u128":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0u128; // None+u128
+p0.serialize_u128(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u128(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_u128(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_u128(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f32
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f32":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f32":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0f32; // None+f32
+p0.serialize_f32(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f32(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f32(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_f32(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f64
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f64":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f64":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0f64; // None+f64
+p0.serialize_f64(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f64(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_f64(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_f64(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_char
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_char":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_char":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 'a'; // None+char
+p0.serialize_char(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_char(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_char(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_char(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bytes
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bytes":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bytes":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.serialize_bytes(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bytes(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_bytes(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_bytes(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
+p0.serialize_unit();
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit(p0);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit(p0);
+<ser::MapKeySerializer<'a, W, F>>::serialize_unit(p0);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_struct
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_struct":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_struct":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = "sample"; // None+&str
+p0.serialize_unit_struct(&p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_struct(p0, &p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_unit_struct(p0, &p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_unit_struct(p0, &p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_variant
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_variant":{"F":["ser::Formatter","std::marker::Sized"],"T":["serde::Serialize"],"W":["std::io::Write","std::marker::Sized"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_variant":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"T":["number::Number","map::Map","serde::ser::impls::<impl serde::Serialize for &'a mut T>","value::Value"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_variant(&p1, p2, &p3, p4);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+<ser::MapKeySerializer<'a, W, F>>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_none
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_none":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_none":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
+p0.serialize_none();
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_none(p0);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_none(p0);
+<ser::MapKeySerializer<'a, W, F>>::serialize_none(p0);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_some
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_some":{"F":["std::marker::Sized","ser::Formatter"],"T":["serde::Serialize"],"W":["std::io::Write","std::marker::Sized"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_some":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"T":["map::Map","value::Value","serde::ser::impls::<impl serde::Serialize for &'a T>","number::Number"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_some(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_some(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_some(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_some(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_seq
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_seq":{"F":["ser::Formatter","std::marker::Sized"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_seq":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_seq(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_seq(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_seq(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_seq(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = 0usize; // None+usize
+p0.serialize_tuple(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_tuple(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_struct
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_struct":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_struct":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_tuple_struct(&p1, p2);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+<ser::MapKeySerializer<'a, W, F>>::serialize_tuple_struct(p0, &p1, p2);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_variant
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_variant":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_variant":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_tuple_variant(&p1, p2, &p3, p4);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+<ser::MapKeySerializer<'a, W, F>>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_map
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_map":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_map":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_map(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_map(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_map(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::serialize_map(p0, p1);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_struct(&p1, p2);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct(p0, &p1, p2);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct(p0, &p1, p2);
+<ser::MapKeySerializer<'a, W, F>>::serialize_struct(p0, &p1, p2);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct_variant
'a
deps:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct_variant":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct_variant":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_struct_variant(&p1, p2, &p3, p4);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+<ser::MapKeySerializer<'a, W, F>>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
-----------------
src/ser.rs <ser::MapKeySerializer<'a, W, F> as serde::Serializer>::collect_str
'a
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::collect_str":{"F":["std::marker::Sized","ser::Formatter"],"T":["std::fmt::Display"],"W":["std::marker::Sized","std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::collect_str":{"F":["ser::CompactFormatter","ser::PrettyFormatter"],"T":["<&mut T as std::fmt::Display>","value::index::Type","error::ErrorImpl","error::ErrorCode","value::Value","error::Error","number::Number"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // ser::MapKeySerializer<'a, W, F>
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.collect_str(p1);
+<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::collect_str(p0, p1);
+crate::<ser::MapKeySerializer<'a, W, F> as serde::Serializer>::collect_str(p0, p1);
+<ser::MapKeySerializer<'a, W, F>>::collect_str(p0, p1);
-----------------
src/ser.rs ser::CharEscape::from_escape_table
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
+ser::CharEscape::from_escape_table(p0, p1);
+crate::ser::CharEscape::from_escape_table(p0, p1);
+<ser::CharEscape>::from_escape_table(p0, p1);
-----------------
src/ser.rs <ser::CompactFormatter as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::CompactFormatter
+p0.clone();
+<ser::CompactFormatter as std::clone::Clone>::clone(p0);
+crate::<ser::CompactFormatter as std::clone::Clone>::clone(p0);
+<ser::CompactFormatter>::clone(p0);
-----------------
src/ser.rs <ser::CompactFormatter as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::CompactFormatter
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ser::CompactFormatter as std::fmt::Debug>::fmt(p0, p1);
+crate::<ser::CompactFormatter as std::fmt::Debug>::fmt(p0, p1);
+<ser::CompactFormatter>::fmt(p0, p1);
-----------------
src/ser.rs <ser::PrettyFormatter<'a> as std::clone::Clone>::clone
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::PrettyFormatter<'a>
+p0.clone();
+<ser::PrettyFormatter<'a> as std::clone::Clone>::clone(p0);
+crate::<ser::PrettyFormatter<'a> as std::clone::Clone>::clone(p0);
+<ser::PrettyFormatter<'a>>::clone(p0);
-----------------
src/ser.rs <ser::PrettyFormatter<'a> as std::fmt::Debug>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // ser::PrettyFormatter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<ser::PrettyFormatter<'a> as std::fmt::Debug>::fmt(p0, p1);
+crate::<ser::PrettyFormatter<'a> as std::fmt::Debug>::fmt(p0, p1);
+<ser::PrettyFormatter<'a>>::fmt(p0, p1);
-----------------
src/ser.rs ser::PrettyFormatter::<'a>::new
'a
deps:{}
candidates:{}
+ser::PrettyFormatter::<'a>::new();
+crate::ser::PrettyFormatter::<'a>::new();
+<ser::PrettyFormatter<'a>>::new();
-----------------
src/ser.rs ser::PrettyFormatter::<'a>::with_indent
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+ser::PrettyFormatter::<'a>::with_indent(p0);
+crate::ser::PrettyFormatter::<'a>::with_indent(p0);
+<ser::PrettyFormatter<'a>>::with_indent(p0);
-----------------
src/ser.rs <ser::PrettyFormatter<'a> as std::default::Default>::default
'a
deps:{}
candidates:{}
+<ser::PrettyFormatter<'a> as std::default::Default>::default();
+crate::<ser::PrettyFormatter<'a> as std::default::Default>::default();
+<ser::PrettyFormatter<'a>>::default();
-----------------
src/ser.rs <ser::PrettyFormatter<'a> as ser::Formatter>::begin_array
'a
deps:{"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array":{"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array":{"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::PrettyFormatter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.begin_array(p1);
+<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array(p0, p1);
+crate::<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array(p0, p1);
+<ser::PrettyFormatter<'a>>::begin_array(p0, p1);
-----------------
src/ser.rs <ser::PrettyFormatter<'a> as ser::Formatter>::end_array
'a
deps:{"<ser::PrettyFormatter<'a> as ser::Formatter>::end_array":{"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::PrettyFormatter<'a> as ser::Formatter>::end_array":{"W":["<value::Value as std::fmt::Display>::fmt::WriterFormatter","std::io::impls::<impl std::io::Write for &mut W>"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::PrettyFormatter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.end_array(p1);
+<ser::PrettyFormatter<'a> as ser::Formatter>::end_array(p0, p1);
+crate::<ser::PrettyFormatter<'a> as ser::Formatter>::end_array(p0, p1);
+<ser::PrettyFormatter<'a>>::end_array(p0, p1);
-----------------
src/ser.rs <ser::PrettyFormatter<'a> as ser::Formatter>::begin_array_value
'a
deps:{"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array_value":{"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array_value":{"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::PrettyFormatter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = true; // None+bool
+p0.begin_array_value(p1, p2);
+<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array_value(p0, p1, p2);
+crate::<ser::PrettyFormatter<'a> as ser::Formatter>::begin_array_value(p0, p1, p2);
+<ser::PrettyFormatter<'a>>::begin_array_value(p0, p1, p2);
-----------------
src/ser.rs <ser::PrettyFormatter<'a> as ser::Formatter>::end_array_value
'a
deps:{"<ser::PrettyFormatter<'a> as ser::Formatter>::end_array_value":{"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::PrettyFormatter<'a> as ser::Formatter>::end_array_value":{"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::PrettyFormatter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.end_array_value(p1);
+<ser::PrettyFormatter<'a> as ser::Formatter>::end_array_value(p0, p1);
+crate::<ser::PrettyFormatter<'a> as ser::Formatter>::end_array_value(p0, p1);
+<ser::PrettyFormatter<'a>>::end_array_value(p0, p1);
-----------------
src/ser.rs <ser::PrettyFormatter<'a> as ser::Formatter>::begin_object
'a
deps:{"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object":{"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object":{"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::PrettyFormatter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.begin_object(p1);
+<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object(p0, p1);
+crate::<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object(p0, p1);
+<ser::PrettyFormatter<'a>>::begin_object(p0, p1);
-----------------
src/ser.rs <ser::PrettyFormatter<'a> as ser::Formatter>::end_object
'a
deps:{"<ser::PrettyFormatter<'a> as ser::Formatter>::end_object":{"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::PrettyFormatter<'a> as ser::Formatter>::end_object":{"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::PrettyFormatter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.end_object(p1);
+<ser::PrettyFormatter<'a> as ser::Formatter>::end_object(p0, p1);
+crate::<ser::PrettyFormatter<'a> as ser::Formatter>::end_object(p0, p1);
+<ser::PrettyFormatter<'a>>::end_object(p0, p1);
-----------------
src/ser.rs <ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_key
'a
deps:{"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_key":{"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_key":{"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::PrettyFormatter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
let mut p2 = true; // None+bool
+p0.begin_object_key(p1, p2);
+<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_key(p0, p1, p2);
+crate::<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_key(p0, p1, p2);
+<ser::PrettyFormatter<'a>>::begin_object_key(p0, p1, p2);
-----------------
src/ser.rs <ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_value
'a
deps:{"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_value":{"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_value":{"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::PrettyFormatter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.begin_object_value(p1);
+<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_value(p0, p1);
+crate::<ser::PrettyFormatter<'a> as ser::Formatter>::begin_object_value(p0, p1);
+<ser::PrettyFormatter<'a>>::begin_object_value(p0, p1);
-----------------
src/ser.rs <ser::PrettyFormatter<'a> as ser::Formatter>::end_object_value
'a
deps:{"<ser::PrettyFormatter<'a> as ser::Formatter>::end_object_value":{"W":["std::io::Write"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<ser::PrettyFormatter<'a> as ser::Formatter>::end_object_value":{"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // ser::PrettyFormatter<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // W
+p0.end_object_value(p1);
+<ser::PrettyFormatter<'a> as ser::Formatter>::end_object_value(p0, p1);
+crate::<ser::PrettyFormatter<'a> as ser::Formatter>::end_object_value(p0, p1);
+<ser::PrettyFormatter<'a>>::end_object_value(p0, p1);
-----------------
src/value/mod.rs <value::Value as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.clone();
+<value::Value as std::clone::Clone>::clone(p0);
+crate::<value::Value as std::clone::Clone>::clone(p0);
+<value::Value>::clone(p0);
-----------------
src/value/mod.rs <value::Value as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.assert_receiver_is_total_eq();
+<value::Value as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<value::Value as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<value::Value>::assert_receiver_is_total_eq(p0);
-----------------
src/value/mod.rs <value::Value as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+<value::Value as std::cmp::PartialEq>::eq(p0, p1);
+crate::<value::Value as std::cmp::PartialEq>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/mod.rs <value::Value as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<value::Value as std::fmt::Debug>::fmt(p0, p1);
+crate::<value::Value as std::fmt::Debug>::fmt(p0, p1);
+<value::Value>::fmt(p0, p1);
-----------------
src/value/mod.rs <value::Value as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<value::Value as std::fmt::Display>::fmt(p0, p1);
+crate::<value::Value as std::fmt::Display>::fmt(p0, p1);
+<value::Value>::fmt(p0, p1);
-----------------
src/value/mod.rs <<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::write
'a,'b
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // <value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b>
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.write(p1);
+<<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::write(p0, p1);
+crate::<<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::write(p0, p1);
+<<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b>>::write(p0, p1);
-----------------
src/value/mod.rs <<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::flush
'a,'b
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // <value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b>
+p0.flush();
+<<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::flush(p0);
+crate::<<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b> as std::io::Write>::flush(p0);
+<<value::Value as std::fmt::Display>::fmt::WriterFormatter<'a, 'b>>::flush(p0);
-----------------
src/value/mod.rs value::Value::get
deps:{"<&'a T as value::index::Index>":{},"value::Value::get":{"I":["std::marker::Sized","value::index::Index"]}}
candidates:{"<&'a T as value::index::Index>":{},"value::Value::get":{"I":["<&'a T as value::index::Index>","std::string::String"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.get(p1);
+value::Value::get(p0, p1);
+crate::value::Value::get(p0, p1);
+<value::Value>::get(p0, p1);
-----------------
src/value/mod.rs value::Value::get_mut
deps:{"<&'a T as value::index::Index>":{},"value::Value::get_mut":{"I":["std::marker::Sized","value::index::Index"]}}
candidates:{"<&'a T as value::index::Index>":{},"value::Value::get_mut":{"I":["std::string::String","<&'a T as value::index::Index>"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.get_mut(p1);
+value::Value::get_mut(p0, p1);
+crate::value::Value::get_mut(p0, p1);
+<value::Value>::get_mut(p0, p1);
-----------------
src/value/mod.rs value::Value::is_object
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_object();
+value::Value::is_object(p0);
+crate::value::Value::is_object(p0);
+<value::Value>::is_object(p0);
-----------------
src/value/mod.rs value::Value::as_object
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_object();
+value::Value::as_object(p0);
+crate::value::Value::as_object(p0);
+<value::Value>::as_object(p0);
-----------------
src/value/mod.rs value::Value::as_object_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_object_mut();
+value::Value::as_object_mut(p0);
+crate::value::Value::as_object_mut(p0);
+<value::Value>::as_object_mut(p0);
-----------------
src/value/mod.rs value::Value::is_array
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_array();
+value::Value::is_array(p0);
+crate::value::Value::is_array(p0);
+<value::Value>::is_array(p0);
-----------------
src/value/mod.rs value::Value::as_array
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_array();
+value::Value::as_array(p0);
+crate::value::Value::as_array(p0);
+<value::Value>::as_array(p0);
-----------------
src/value/mod.rs value::Value::as_array_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_array_mut();
+value::Value::as_array_mut(p0);
+crate::value::Value::as_array_mut(p0);
+<value::Value>::as_array_mut(p0);
-----------------
src/value/mod.rs value::Value::is_string
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_string();
+value::Value::is_string(p0);
+crate::value::Value::is_string(p0);
+<value::Value>::is_string(p0);
-----------------
src/value/mod.rs value::Value::as_str
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_str();
+value::Value::as_str(p0);
+crate::value::Value::as_str(p0);
+<value::Value>::as_str(p0);
-----------------
src/value/mod.rs value::Value::is_number
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_number();
+value::Value::is_number(p0);
+crate::value::Value::is_number(p0);
+<value::Value>::is_number(p0);
-----------------
src/value/mod.rs value::Value::is_i64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_i64();
+value::Value::is_i64(p0);
+crate::value::Value::is_i64(p0);
+<value::Value>::is_i64(p0);
-----------------
src/value/mod.rs value::Value::is_u64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_u64();
+value::Value::is_u64(p0);
+crate::value::Value::is_u64(p0);
+<value::Value>::is_u64(p0);
-----------------
src/value/mod.rs value::Value::is_f64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_f64();
+value::Value::is_f64(p0);
+crate::value::Value::is_f64(p0);
+<value::Value>::is_f64(p0);
-----------------
src/value/mod.rs value::Value::as_i64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_i64();
+value::Value::as_i64(p0);
+crate::value::Value::as_i64(p0);
+<value::Value>::as_i64(p0);
-----------------
src/value/mod.rs value::Value::as_u64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_u64();
+value::Value::as_u64(p0);
+crate::value::Value::as_u64(p0);
+<value::Value>::as_u64(p0);
-----------------
src/value/mod.rs value::Value::as_f64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_f64();
+value::Value::as_f64(p0);
+crate::value::Value::as_f64(p0);
+<value::Value>::as_f64(p0);
-----------------
src/value/mod.rs value::Value::is_boolean
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_boolean();
+value::Value::is_boolean(p0);
+crate::value::Value::is_boolean(p0);
+<value::Value>::is_boolean(p0);
-----------------
src/value/mod.rs value::Value::as_bool
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_bool();
+value::Value::as_bool(p0);
+crate::value::Value::as_bool(p0);
+<value::Value>::as_bool(p0);
-----------------
src/value/mod.rs value::Value::is_null
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.is_null();
+value::Value::is_null(p0);
+crate::value::Value::is_null(p0);
+<value::Value>::is_null(p0);
-----------------
src/value/mod.rs value::Value::as_null
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.as_null();
+value::Value::as_null(p0);
+crate::value::Value::as_null(p0);
+<value::Value>::as_null(p0);
-----------------
src/value/mod.rs value::Value::pointer
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
+p0.pointer(&p1);
+value::Value::pointer(p0, &p1);
+crate::value::Value::pointer(p0, &p1);
+<value::Value>::pointer(p0, &p1);
-----------------
src/value/mod.rs value::Value::pointer_mut
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
+p0.pointer_mut(&p1);
+value::Value::pointer_mut(p0, &p1);
+crate::value::Value::pointer_mut(p0, &p1);
+<value::Value>::pointer_mut(p0, &p1);
-----------------
src/value/mod.rs value::Value::take
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.take();
+value::Value::take(p0);
+crate::value::Value::take(p0);
+<value::Value>::take(p0);
-----------------
src/value/mod.rs <value::Value as std::default::Default>::default
deps:{}
candidates:{}
+<value::Value as std::default::Default>::default();
+crate::<value::Value as std::default::Default>::default();
+<value::Value>::default();
-----------------
src/value/de.rs value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>":{},"de::MapKey":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{},"value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize":{"D":["std::marker::Sized","serde::Deserializer"]}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>":{},"de::MapKey":{"R":["read::StrRead","<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead"]},"read::IoRead":{"R":["std::fs::File","std::sys::unix::stdio::Stdin","std::io::impls::<impl std::io::Read for &mut R>","std::io::stdio::StdinRaw","std::io::BufReader<R>","std::io::Take<T>","std::io::Chain<T, U>","&'a std::os::unix::net::UnixStream","&std::fs::File","&'a std::sys::unix::fd::FileDesc","std::os::unix::net::UnixStream","std::io::Empty","std::net::TcpStream","std::boxed::Box<R>","std::process::ChildStderr","std::io::StdinLock<'_>","std::collections::VecDeque<u8, A>","std::io::Cursor<T>","std::process::ChildStdout","&std::net::TcpStream","std::io::Repeat","std::io::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{},"value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize":{"D":["<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>","value::de::BorrowedCowStrDeserializer","de::MapKey","value::de::MapKeyDeserializer","number::Number","value::Value"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize(p0);
+crate::value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize(p0);
+<value::Value>::deserialize(p0);
-----------------
src/value/de.rs <value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor>::expecting(p0, p1);
-----------------
src/value/de.rs <value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool
'de
deps:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool":{"E":["std::marker::Sized"]}}
candidates:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor
let mut p1 = true; // None+bool
+p0.visit_bool(p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool(p0, p1);
+crate::<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_bool(p0, p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor>::visit_bool(p0, p1);
-----------------
src/value/de.rs <value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64
'de
deps:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64":{"E":["std::marker::Sized"]}}
candidates:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor
let mut p1 = 0i64; // None+i64
+p0.visit_i64(p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64(p0, p1);
+crate::<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_i64(p0, p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor>::visit_i64(p0, p1);
-----------------
src/value/de.rs <value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64":{"E":["std::marker::Sized"]}}
candidates:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor>::visit_u64(p0, p1);
-----------------
src/value/de.rs <value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64
'de
deps:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64":{"E":["std::marker::Sized"]}}
candidates:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor
let mut p1 = 0f64; // None+f64
+p0.visit_f64(p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64(p0, p1);
+crate::<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_f64(p0, p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor>::visit_f64(p0, p1);
-----------------
src/value/de.rs <value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str":{"E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str":{"E":["error::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor>::visit_str(p0, &p1);
-----------------
src/value/de.rs <value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string
'de
deps:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string":{"E":["std::marker::Sized"]}}
candidates:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor
let mut p1 = std::string::String::new(); // None+std::string::String
+p0.visit_string(p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string(p0, p1);
+crate::<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_string(p0, p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor>::visit_string(p0, p1);
-----------------
src/value/de.rs <value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_none
'de
deps:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_none":{"E":["std::marker::Sized"]}}
candidates:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_none":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor
+p0.visit_none();
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_none(p0);
+crate::<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_none(p0);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor>::visit_none(p0);
-----------------
src/value/de.rs <value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>":{},"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some":{"D":["serde::Deserializer","std::marker::Sized"]},"de::MapKey":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>":{},"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some":{"D":["value::de::BorrowedCowStrDeserializer","number::Number","value::Value","value::de::MapKeyDeserializer","<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>","de::MapKey"]},"de::MapKey":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead","read::IoRead"]},"read::IoRead":{"R":["&std::fs::File","&'a std::os::unix::net::UnixStream","std::net::TcpStream","std::io::Take<T>","std::io::StdinLock<'_>","std::io::Cursor<T>","std::fs::File","std::process::ChildStderr","std::boxed::Box<R>","&'a std::sys::unix::fd::FileDesc","std::io::Repeat","std::io::Chain<T, U>","std::io::BufReader<R>","std::process::ChildStdout","std::io::Empty","&std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","std::io::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor
let mut p1 = MaybeUninit::uninit().assume_init(); // D
+p0.visit_some(p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some(p0, p1);
+crate::<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_some(p0, p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor>::visit_some(p0, p1);
-----------------
src/value/de.rs <value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_unit
'de
deps:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_unit":{"E":["std::marker::Sized"]}}
candidates:{"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_unit":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor
+p0.visit_unit();
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_unit(p0);
+crate::<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_unit(p0);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor>::visit_unit(p0);
-----------------
src/value/de.rs <value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&mut A as serde::de::SeqAccess<'de>>":{},"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq":{"V":["serde::de::SeqAccess","std::marker::Sized"]},"de::SeqAccess":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&mut A as serde::de::SeqAccess<'de>>":{},"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq":{"V":["value::de::SeqDeserializer","value::de::SeqRefDeserializer","de::SeqAccess","<&mut A as serde::de::SeqAccess<'de>>"]},"de::SeqAccess":{"R":["read::StrRead","<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead"]},"read::IoRead":{"R":["std::io::impls::<impl std::io::Read for &mut R>","std::io::Take<T>","std::process::ChildStdout","&std::net::TcpStream","std::io::StdinLock<'_>","std::io::Repeat","std::boxed::Box<R>","std::io::Cursor<T>","std::io::Chain<T, U>","std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","&std::fs::File","std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","std::io::Stdin","std::io::BufReader<R>","std::net::TcpStream","std::io::Empty","&'a std::os::unix::net::UnixStream","std::fs::File","&'a std::sys::unix::fd::FileDesc","std::process::ChildStderr"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.visit_seq(p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+crate::<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_seq(p0, p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor>::visit_seq(p0, p1);
-----------------
src/value/de.rs <value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&mut A as serde::de::MapAccess<'de>>":{},"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map":{"V":["serde::de::MapAccess","std::marker::Sized"]},"de::MapAccess":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&mut A as serde::de::MapAccess<'de>>":{},"<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map":{"V":["<&mut A as serde::de::MapAccess<'de>>","value::de::MapDeserializer","value::de::MapRefDeserializer","de::MapAccess"]},"de::MapAccess":{"R":["<&'a mut R as read::Read<'de>>","read::StrRead","read::IoRead","read::SliceRead"]},"read::IoRead":{"R":["std::os::unix::net::UnixStream","std::io::Take<T>","&'a std::os::unix::net::UnixStream","std::net::TcpStream","std::io::Chain<T, U>","std::fs::File","std::boxed::Box<R>","std::io::Empty","std::sys::unix::stdio::Stdin","&std::net::TcpStream","std::collections::VecDeque<u8, A>","std::process::ChildStderr","std::io::Cursor<T>","std::io::Stdin","std::process::ChildStdout","std::io::Repeat","std::io::impls::<impl std::io::Read for &mut R>","std::io::BufReader<R>","&'a std::sys::unix::fd::FileDesc","std::io::StdinLock<'_>","std::io::stdio::StdinRaw","&std::fs::File"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.visit_map(p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map(p0, p1);
+crate::<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor as serde::de::Visitor<'de>>::visit_map(p0, p1);
+<value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor>::visit_map(p0, p1);
-----------------
src/value/de.rs value::de::<impl std::str::FromStr for value::Value>::from_str
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+value::de::<impl std::str::FromStr for value::Value>::from_str(&p0);
+crate::value::de::<impl std::str::FromStr for value::Value>::from_str(&p0);
+<value::Value>::from_str(&p0);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_any
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_any":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_any(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_any(p0, p1);
+<value::Value>::deserialize_any(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i8
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i8":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i8(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i8(p0, p1);
+<value::Value>::deserialize_i8(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i16
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i16":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i16(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i16(p0, p1);
+<value::Value>::deserialize_i16(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i32
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i32":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i32(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i32(p0, p1);
+<value::Value>::deserialize_i32(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i64
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i64":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i64(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i64(p0, p1);
+<value::Value>::deserialize_i64(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i128
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i128":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i128":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i128(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i128(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_i128(p0, p1);
+<value::Value>::deserialize_i128(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u8
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u8":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u8(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u8(p0, p1);
+<value::Value>::deserialize_u8(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u16
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u16":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u16(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u16(p0, p1);
+<value::Value>::deserialize_u16(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u32
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u32":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u32(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u32(p0, p1);
+<value::Value>::deserialize_u32(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u64
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u64":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u64(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u64(p0, p1);
+<value::Value>::deserialize_u64(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u128
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u128":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u128":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u128(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u128(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_u128(p0, p1);
+<value::Value>::deserialize_u128(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f32
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f32":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f32(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f32(p0, p1);
+<value::Value>::deserialize_f32(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f64
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f64":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f64(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_f64(p0, p1);
+<value::Value>::deserialize_f64(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_option
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_option":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_option":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_option(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_option(p0, p1);
+<value::Value>::deserialize_option(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_enum
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_enum":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_enum":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_enum(p0, &p1, p2, p3);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_enum(p0, &p1, p2, p3);
+<value::Value>::deserialize_enum(p0, &p1, p2, p3);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_newtype_struct
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_newtype_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_newtype_struct":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_newtype_struct(p0, &p1, p2);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_newtype_struct(p0, &p1, p2);
+<value::Value>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bool
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bool":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bool":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bool(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bool(p0, p1);
+<value::Value>::deserialize_bool(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_char
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_char":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_char":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_char(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_char(p0, p1);
+<value::Value>::deserialize_char(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_str
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_str":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_str":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_str(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_str(p0, p1);
+<value::Value>::deserialize_str(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_string
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_string":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_string":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_string(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_string(p0, p1);
+<value::Value>::deserialize_string(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bytes
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bytes":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bytes":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bytes(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_bytes(p0, p1);
+<value::Value>::deserialize_bytes(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_byte_buf
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_byte_buf":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_byte_buf":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_byte_buf(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_byte_buf(p0, p1);
+<value::Value>::deserialize_byte_buf(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit(p0, p1);
+<value::Value>::deserialize_unit(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit_struct
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit_struct":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit_struct(p0, &p1, p2);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_unit_struct(p0, &p1, p2);
+<value::Value>::deserialize_unit_struct(p0, &p1, p2);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_seq
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_seq":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_seq":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_seq(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_seq(p0, p1);
+<value::Value>::deserialize_seq(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple(p0, p1, p2);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple(p0, p1, p2);
+<value::Value>::deserialize_tuple(p0, p1, p2);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple_struct
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple_struct":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<value::Value>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_map
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_map":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_map":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_map(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_map(p0, p1);
+<value::Value>::deserialize_map(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_struct
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_struct":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_struct(p0, &p1, p2, p3);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_struct(p0, &p1, p2, p3);
+<value::Value>::deserialize_struct(p0, &p1, p2, p3);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_identifier
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_identifier":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_identifier(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_identifier(p0, p1);
+<value::Value>::deserialize_identifier(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_ignored_any
'de
deps:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_ignored_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_ignored_any":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_ignored_any(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_ignored_any(p0, p1);
+<value::Value>::deserialize_ignored_any(p0, p1);
-----------------
src/value/de.rs <value::de::EnumDeserializer as serde::de::EnumAccess<'de>>::variant_seed
'de
deps:{"<value::de::EnumDeserializer as serde::de::EnumAccess<'de>>::variant_seed":{"V":["serde::de::DeserializeSeed","std::marker::Sized"]}}
candidates:{"<value::de::EnumDeserializer as serde::de::EnumAccess<'de>>::variant_seed":{"V":["value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::EnumDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.variant_seed(p1);
+<value::de::EnumDeserializer as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+crate::<value::de::EnumDeserializer as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+<value::de::EnumDeserializer>::variant_seed(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::de::IntoDeserializer<'de, error::Error> for value::Value>::into_deserializer
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::Value
+p0.into_deserializer();
+value::de::<impl serde::de::IntoDeserializer<'de, error::Error> for value::Value>::into_deserializer(p0);
+crate::value::de::<impl serde::de::IntoDeserializer<'de, error::Error> for value::Value>::into_deserializer(p0);
+<value::Value>::into_deserializer(p0);
-----------------
src/value/de.rs <value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::unit_variant
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::VariantDeserializer
+p0.unit_variant();
+<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::unit_variant(p0);
+crate::<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::unit_variant(p0);
+<value::de::VariantDeserializer>::unit_variant(p0);
-----------------
src/value/de.rs <value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed
'de
deps:{"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"T":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"T":["value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::VariantDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.newtype_variant_seed(p1);
+<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+crate::<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+<value::de::VariantDeserializer>::newtype_variant_seed(p0, p1);
-----------------
src/value/de.rs <value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::tuple_variant
'de
deps:{"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::tuple_variant":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::tuple_variant":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::VariantDeserializer
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.tuple_variant(p1, p2);
+<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+crate::<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+<value::de::VariantDeserializer>::tuple_variant(p0, p1, p2);
-----------------
src/value/de.rs <value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::struct_variant
'de
deps:{"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::struct_variant":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::struct_variant":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::VariantDeserializer
let mut p1 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.struct_variant(p1, p2);
+<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+crate::<value::de::VariantDeserializer as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+<value::de::VariantDeserializer>::struct_variant(p0, p1, p2);
-----------------
src/value/de.rs value::de::SeqDeserializer::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<value::Value>
+value::de::SeqDeserializer::new(p0);
+crate::value::de::SeqDeserializer::new(p0);
+<value::de::SeqDeserializer>::new(p0);
-----------------
src/value/de.rs <value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed
'de
deps:{"<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed":{"T":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed":{"T":["value::de::KeyClassifier"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::de::SeqDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.next_element_seed(p1);
+<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed(p0, p1);
+crate::<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::next_element_seed(p0, p1);
+<value::de::SeqDeserializer>::next_element_seed(p0, p1);
-----------------
src/value/de.rs <value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::de::SeqDeserializer
+p0.size_hint();
+<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint(p0);
+crate::<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint(p0);
+<value::de::SeqDeserializer>::size_hint(p0);
-----------------
src/value/de.rs value::de::MapDeserializer::new
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+value::de::MapDeserializer::new(p0);
+crate::value::de::MapDeserializer::new(p0);
+<value::de::MapDeserializer>::new(p0);
-----------------
src/value/de.rs <value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed
'de
deps:{"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed":{"T":["serde::de::DeserializeSeed","std::marker::Sized"]}}
candidates:{"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed":{"T":["value::de::KeyClassifier"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::de::MapDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.next_key_seed(p1);
+<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+crate::<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+<value::de::MapDeserializer>::next_key_seed(p0, p1);
-----------------
src/value/de.rs <value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed
'de
deps:{"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed":{"T":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed":{"T":["value::de::KeyClassifier"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::de::MapDeserializer
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.next_value_seed(p1);
+<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+crate::<value::de::MapDeserializer as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+<value::de::MapDeserializer>::next_value_seed(p0, p1);
-----------------
src/value/de.rs <value::de::MapDeserializer as serde::de::MapAccess<'de>>::size_hint
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::de::MapDeserializer
+p0.size_hint();
+<value::de::MapDeserializer as serde::de::MapAccess<'de>>::size_hint(p0);
+crate::<value::de::MapDeserializer as serde::de::MapAccess<'de>>::size_hint(p0);
+<value::de::MapDeserializer>::size_hint(p0);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_any
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_any":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_any":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_any(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_any(p0, p1);
+<&'de value::Value>::deserialize_any(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i8
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i8":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i8":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i8(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i8(p0, p1);
+<&'de value::Value>::deserialize_i8(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i16
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i16":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i16":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i16(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i16(p0, p1);
+<&'de value::Value>::deserialize_i16(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i32
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i32":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i32(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i32(p0, p1);
+<&'de value::Value>::deserialize_i32(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i64
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i64":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i64(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i64(p0, p1);
+<&'de value::Value>::deserialize_i64(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i128
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i128":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i128":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i128(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i128(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_i128(p0, p1);
+<&'de value::Value>::deserialize_i128(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u8
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u8":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u8":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u8(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u8(p0, p1);
+<&'de value::Value>::deserialize_u8(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u16
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u16":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u16(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u16(p0, p1);
+<&'de value::Value>::deserialize_u16(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u32
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u32":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u32(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u32(p0, p1);
+<&'de value::Value>::deserialize_u32(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u64
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u64":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u64(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u64(p0, p1);
+<&'de value::Value>::deserialize_u64(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u128
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u128":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u128":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u128(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u128(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_u128(p0, p1);
+<&'de value::Value>::deserialize_u128(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f32
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f32":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f32(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f32(p0, p1);
+<&'de value::Value>::deserialize_f32(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f64
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f64":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f64(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_f64(p0, p1);
+<&'de value::Value>::deserialize_f64(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_option
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_option":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_option":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_option(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_option(p0, p1);
+<&'de value::Value>::deserialize_option(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_enum
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_enum":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_enum":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_enum(p0, &p1, p2, p3);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_enum(p0, &p1, p2, p3);
+<&'de value::Value>::deserialize_enum(p0, &p1, p2, p3);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_newtype_struct
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_newtype_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_newtype_struct":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_newtype_struct(p0, &p1, p2);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_newtype_struct(p0, &p1, p2);
+<&'de value::Value>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bool
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bool":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bool":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bool(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bool(p0, p1);
+<&'de value::Value>::deserialize_bool(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_char
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_char":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_char":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_char(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_char(p0, p1);
+<&'de value::Value>::deserialize_char(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_str
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_str":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_str":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_str(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_str(p0, p1);
+<&'de value::Value>::deserialize_str(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_string
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_string":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_string":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_string(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_string(p0, p1);
+<&'de value::Value>::deserialize_string(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bytes
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bytes":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bytes":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bytes(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bytes(p0, p1);
+<&'de value::Value>::deserialize_bytes(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_byte_buf
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_byte_buf":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_byte_buf":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_byte_buf(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_byte_buf(p0, p1);
+<&'de value::Value>::deserialize_byte_buf(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit(p0, p1);
+<&'de value::Value>::deserialize_unit(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit_struct
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit_struct":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit_struct(p0, &p1, p2);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_unit_struct(p0, &p1, p2);
+<&'de value::Value>::deserialize_unit_struct(p0, &p1, p2);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_seq
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_seq":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_seq":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_seq(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_seq(p0, p1);
+<&'de value::Value>::deserialize_seq(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple(p0, p1, p2);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple(p0, p1, p2);
+<&'de value::Value>::deserialize_tuple(p0, p1, p2);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple_struct
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple_struct":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<&'de value::Value>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_map
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_map":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_map":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_map(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_map(p0, p1);
+<&'de value::Value>::deserialize_map(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_struct
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_struct":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_struct(p0, &p1, p2, p3);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_struct(p0, &p1, p2, p3);
+<&'de value::Value>::deserialize_struct(p0, &p1, p2, p3);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_identifier
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_identifier":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_identifier(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_identifier(p0, p1);
+<&'de value::Value>::deserialize_identifier(p0, p1);
-----------------
src/value/de.rs value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_ignored_any
'de
deps:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_ignored_any":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_ignored_any":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_ignored_any(p0, p1);
+crate::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_ignored_any(p0, p1);
+<&'de value::Value>::deserialize_ignored_any(p0, p1);
-----------------
src/value/de.rs <value::de::EnumRefDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed
'de
deps:{"<value::de::EnumRefDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed":{"V":["serde::de::DeserializeSeed","std::marker::Sized"]}}
candidates:{"<value::de::EnumRefDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed":{"V":["value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::EnumRefDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.variant_seed(p1);
+<value::de::EnumRefDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+crate::<value::de::EnumRefDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+<value::de::EnumRefDeserializer<'de>>::variant_seed(p0, p1);
-----------------
src/value/de.rs <value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::unit_variant
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::VariantRefDeserializer<'de>
+p0.unit_variant();
+<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::unit_variant(p0);
+crate::<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::unit_variant(p0);
+<value::de::VariantRefDeserializer<'de>>::unit_variant(p0);
-----------------
src/value/de.rs <value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::newtype_variant_seed
'de
deps:{"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"T":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"T":["value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::VariantRefDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.newtype_variant_seed(p1);
+<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+crate::<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+<value::de::VariantRefDeserializer<'de>>::newtype_variant_seed(p0, p1);
-----------------
src/value/de.rs <value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::tuple_variant
'de
deps:{"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::tuple_variant":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::tuple_variant":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::VariantRefDeserializer<'de>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.tuple_variant(p1, p2);
+<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+crate::<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+<value::de::VariantRefDeserializer<'de>>::tuple_variant(p0, p1, p2);
-----------------
src/value/de.rs <value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::struct_variant
'de
deps:{"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::struct_variant":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::struct_variant":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::VariantRefDeserializer<'de>
let mut p1 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.struct_variant(p1, p2);
+<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+crate::<value::de::VariantRefDeserializer<'de> as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+<value::de::VariantRefDeserializer<'de>>::struct_variant(p0, p1, p2);
-----------------
src/value/de.rs value::de::SeqRefDeserializer::<'de>::new
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [value::Value]
+value::de::SeqRefDeserializer::<'de>::new(p0);
+crate::value::de::SeqRefDeserializer::<'de>::new(p0);
+<value::de::SeqRefDeserializer<'de>>::new(p0);
-----------------
src/value/de.rs <value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::next_element_seed
'de
deps:{"<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::next_element_seed":{"T":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::next_element_seed":{"T":["value::de::KeyClassifier"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::de::SeqRefDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.next_element_seed(p1);
+<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::next_element_seed(p0, p1);
+crate::<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::next_element_seed(p0, p1);
+<value::de::SeqRefDeserializer<'de>>::next_element_seed(p0, p1);
-----------------
src/value/de.rs <value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::size_hint
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::de::SeqRefDeserializer<'de>
+p0.size_hint();
+<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::size_hint(p0);
+crate::<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::size_hint(p0);
+<value::de::SeqRefDeserializer<'de>>::size_hint(p0);
-----------------
src/value/de.rs value::de::MapRefDeserializer::<'de>::new
'de
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+value::de::MapRefDeserializer::<'de>::new(p0);
+crate::value::de::MapRefDeserializer::<'de>::new(p0);
+<value::de::MapRefDeserializer<'de>>::new(p0);
-----------------
src/value/de.rs <value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_key_seed
'de
deps:{"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_key_seed":{"T":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_key_seed":{"T":["value::de::KeyClassifier"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::de::MapRefDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.next_key_seed(p1);
+<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+crate::<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_key_seed(p0, p1);
+<value::de::MapRefDeserializer<'de>>::next_key_seed(p0, p1);
-----------------
src/value/de.rs <value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_value_seed
'de
deps:{"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_value_seed":{"T":["serde::de::DeserializeSeed","std::marker::Sized"]}}
candidates:{"<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_value_seed":{"T":["value::de::KeyClassifier"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::de::MapRefDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.next_value_seed(p1);
+<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+crate::<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::next_value_seed(p0, p1);
+<value::de::MapRefDeserializer<'de>>::next_value_seed(p0, p1);
-----------------
src/value/de.rs <value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::size_hint
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::de::MapRefDeserializer<'de>
+p0.size_hint();
+<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::size_hint(p0);
+crate::<value::de::MapRefDeserializer<'de> as serde::de::MapAccess<'de>>::size_hint(p0);
+<value::de::MapRefDeserializer<'de>>::size_hint(p0);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_any(p0, p1);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_i8(p0, p1);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_i16(p0, p1);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_i32(p0, p1);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_i64(p0, p1);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i128(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_i128(p0, p1);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_u8(p0, p1);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_u16(p0, p1);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_u32(p0, p1);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_u64(p0, p1);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u128(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_u128(p0, p1);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_option(p0, p1);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<value::de::MapKeyDeserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
src/value/de.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<value::de::MapKeyDeserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_bool(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_f32(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_f64(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_char(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_str(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_string(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_bytes(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_byte_buf(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_unit(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<value::de::MapKeyDeserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_seq(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<value::de::MapKeyDeserializer<'de>>::deserialize_tuple(p0, p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<value::de::MapKeyDeserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_map(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<value::de::MapKeyDeserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_identifier(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any
'de
deps:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::MapKeyDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<value::de::MapKeyDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<value::de::MapKeyDeserializer<'de>>::deserialize_ignored_any(p0, p1);
-----------------
src/value/de.rs <value::de::KeyClassifier as serde::de::DeserializeSeed<'de>>::deserialize
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>":{},"<value::de::KeyClassifier as serde::de::DeserializeSeed<'de>>::deserialize":{"D":["std::marker::Sized","serde::Deserializer"]},"de::MapKey":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>":{},"<value::de::KeyClassifier as serde::de::DeserializeSeed<'de>>::deserialize":{"D":["value::de::BorrowedCowStrDeserializer","value::Value","number::Number","<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>","value::de::MapKeyDeserializer","de::MapKey"]},"de::MapKey":{"R":["read::IoRead","read::SliceRead","<&'a mut R as read::Read<'de>>","read::StrRead"]},"read::IoRead":{"R":["std::process::ChildStdout","std::io::Cursor<T>","std::io::stdio::StdinRaw","std::sys::unix::stdio::Stdin","std::io::Chain<T, U>","std::net::TcpStream","&'a std::os::unix::net::UnixStream","std::io::Take<T>","&std::net::TcpStream","std::process::ChildStderr","std::io::StdinLock<'_>","std::io::Repeat","std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin","std::collections::VecDeque<u8, A>","std::boxed::Box<R>","std::io::Empty","std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::fs::File","&std::fs::File","std::io::BufReader<R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::KeyClassifier
let mut p1 = MaybeUninit::uninit().assume_init(); // D
+p0.deserialize(p1);
+<value::de::KeyClassifier as serde::de::DeserializeSeed<'de>>::deserialize(p0, p1);
+crate::<value::de::KeyClassifier as serde::de::DeserializeSeed<'de>>::deserialize(p0, p1);
+<value::de::KeyClassifier>::deserialize(p0, p1);
-----------------
src/value/de.rs <value::de::KeyClassifier as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::de::KeyClassifier
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<value::de::KeyClassifier as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<value::de::KeyClassifier as serde::de::Visitor<'de>>::expecting(p0, p1);
+<value::de::KeyClassifier>::expecting(p0, p1);
-----------------
src/value/de.rs <value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_str
'de
deps:{"<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_str":{"E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_str":{"E":["error::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::KeyClassifier
let mut p1 = "sample"; // None+&str
+p0.visit_str(&p1);
+<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+crate::<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_str(p0, &p1);
+<value::de::KeyClassifier>::visit_str(p0, &p1);
-----------------
src/value/de.rs <value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_string
'de
deps:{"<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_string":{"E":["std::marker::Sized","serde::de::Error"]}}
candidates:{"<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_string":{"E":["error::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::KeyClassifier
let mut p1 = std::string::String::new(); // None+std::string::String
+p0.visit_string(p1);
+<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_string(p0, p1);
+crate::<value::de::KeyClassifier as serde::de::Visitor<'de>>::visit_string(p0, p1);
+<value::de::KeyClassifier>::visit_string(p0, p1);
-----------------
src/value/de.rs value::de::<impl value::Value>::invalid_type
deps:{"value::de::<impl value::Value>::invalid_type":{"E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"value::de::<impl value::Value>::invalid_type":{"E":["error::Error"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & MaybeUninit::uninit().assume_init(); // dyn serde::de::Expected
+p0.invalid_type(p1);
+value::de::<impl value::Value>::invalid_type(p0, p1);
+crate::value::de::<impl value::Value>::invalid_type(p0, p1);
+<value::Value>::invalid_type(p0, p1);
-----------------
src/value/de.rs value::de::<impl value::Value>::unexpected
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.unexpected();
+value::de::<impl value::Value>::unexpected(p0);
+crate::value::de::<impl value::Value>::unexpected(p0);
+<value::Value>::unexpected(p0);
-----------------
src/value/de.rs value::de::BorrowedCowStrDeserializer::<'de>::new
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'de, str>
+value::de::BorrowedCowStrDeserializer::<'de>::new(p0);
+crate::value::de::BorrowedCowStrDeserializer::<'de>::new(p0);
+<value::de::BorrowedCowStrDeserializer<'de>>::new(p0);
-----------------
src/value/de.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_any(p0, p1);
-----------------
src/value/de.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_bool(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_i8(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_i16(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_i32(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_i64(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i128(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_i128(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_i128(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_u8(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_u16(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_u32(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_u64(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u128(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_u128(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_u128(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_f32(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_f64(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_char(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_str(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_string(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_bytes(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_byte_buf(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_option(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_unit(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_seq(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_tuple(p0, p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_map(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_identifier(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::deserialize_ignored_any(p0, p1);
-----------------
src/value/de.rs <value::de::BorrowedCowStrDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed
'de
deps:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed":{"T":["std::marker::Sized","serde::de::DeserializeSeed"]}}
candidates:{"<value::de::BorrowedCowStrDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed":{"T":["value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::BorrowedCowStrDeserializer<'de>
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.variant_seed(p1);
+<value::de::BorrowedCowStrDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+crate::<value::de::BorrowedCowStrDeserializer<'de> as serde::de::EnumAccess<'de>>::variant_seed(p0, p1);
+<value::de::BorrowedCowStrDeserializer<'de>>::variant_seed(p0, p1);
-----------------
src/value/de.rs <value::de::UnitOnly as serde::de::VariantAccess<'de>>::unit_variant
'de
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::UnitOnly
+p0.unit_variant();
+<value::de::UnitOnly as serde::de::VariantAccess<'de>>::unit_variant(p0);
+crate::<value::de::UnitOnly as serde::de::VariantAccess<'de>>::unit_variant(p0);
+<value::de::UnitOnly>::unit_variant(p0);
-----------------
src/value/de.rs <value::de::UnitOnly as serde::de::VariantAccess<'de>>::newtype_variant_seed
'de
deps:{"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"T":["serde::de::DeserializeSeed","std::marker::Sized"]}}
candidates:{"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::newtype_variant_seed":{"T":["value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::UnitOnly
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.newtype_variant_seed(p1);
+<value::de::UnitOnly as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+crate::<value::de::UnitOnly as serde::de::VariantAccess<'de>>::newtype_variant_seed(p0, p1);
+<value::de::UnitOnly>::newtype_variant_seed(p0, p1);
-----------------
src/value/de.rs <value::de::UnitOnly as serde::de::VariantAccess<'de>>::tuple_variant
'de
deps:{"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::tuple_variant":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::tuple_variant":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::UnitOnly
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.tuple_variant(p1, p2);
+<value::de::UnitOnly as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+crate::<value::de::UnitOnly as serde::de::VariantAccess<'de>>::tuple_variant(p0, p1, p2);
+<value::de::UnitOnly>::tuple_variant(p0, p1, p2);
-----------------
src/value/de.rs <value::de::UnitOnly as serde::de::VariantAccess<'de>>::struct_variant
'de
deps:{"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::struct_variant":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<value::de::UnitOnly as serde::de::VariantAccess<'de>>::struct_variant":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::de::UnitOnly
let mut p1 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.struct_variant(p1, p2);
+<value::de::UnitOnly as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+crate::<value::de::UnitOnly as serde::de::VariantAccess<'de>>::struct_variant(p0, p1, p2);
+<value::de::UnitOnly>::struct_variant(p0, p1, p2);
-----------------
src/value/from.rs value::from::<impl std::convert::From<i8> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+value::from::<impl std::convert::From<i8> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<i8> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<i16> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+value::from::<impl std::convert::From<i16> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<i16> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<i32> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+value::from::<impl std::convert::From<i32> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<i32> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<i64> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+value::from::<impl std::convert::From<i64> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<i64> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<isize> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+value::from::<impl std::convert::From<isize> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<isize> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<u8> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+value::from::<impl std::convert::From<u8> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<u8> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<u16> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+value::from::<impl std::convert::From<u16> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<u16> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<u32> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+value::from::<impl std::convert::From<u32> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<u32> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<u64> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+value::from::<impl std::convert::From<u64> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<u64> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<usize> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+value::from::<impl std::convert::From<usize> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<usize> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<f32> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+value::from::<impl std::convert::From<f32> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<f32> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<f64> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+value::from::<impl std::convert::From<f64> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<f64> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<bool> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = true; // None+bool
+value::from::<impl std::convert::From<bool> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<bool> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<std::string::String> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+std::string::String
+value::from::<impl std::convert::From<std::string::String> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<std::string::String> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<&'a str> for value::Value>::from
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+value::from::<impl std::convert::From<&'a str> for value::Value>::from(&p0);
+crate::value::from::<impl std::convert::From<&'a str> for value::Value>::from(&p0);
+<value::Value>::from(&p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<std::borrow::Cow<'a, str>> for value::Value>::from
'a
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::borrow::Cow<'a, str>
+value::from::<impl std::convert::From<std::borrow::Cow<'a, str>> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<std::borrow::Cow<'a, str>> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<number::Number> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
+value::from::<impl std::convert::From<number::Number> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<number::Number> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<map::Map<std::string::String, value::Value>> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = std::string::String::new(); // None+map::Map<std::string::String, value::Value>
+value::from::<impl std::convert::From<map::Map<std::string::String, value::Value>> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<map::Map<std::string::String, value::Value>> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<std::vec::Vec<T>> for value::Value>::from
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"value::from::<impl std::convert::From<std::vec::Vec<T>> for value::Value>::from":{"T":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"value::from::<impl std::convert::From<std::vec::Vec<T>> for value::Value>::from":{"T":["std::sys::unix::process::process_inner::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::process::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::vec::Vec<T>
+value::from::<impl std::convert::From<std::vec::Vec<T>> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<std::vec::Vec<T>> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<&'a [T]> for value::Value>::from
'a
deps:{"value::from::<impl std::convert::From<&'a [T]> for value::Value>::from":{"T":["std::clone::Clone","std::convert::Into","std::marker::Sized"]}}
candidates:{"value::from::<impl std::convert::From<&'a [T]> for value::Value>::from":{"T":["std::process::ExitStatusError","std::sys::unix::process::process_inner::ExitStatusError","std::sync::mpmc::select::Selected"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // [T]
+value::from::<impl std::convert::From<&'a [T]> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<&'a [T]> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::iter::FromIterator<T> for value::Value>::from_iter
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::marker::Sized","std::iter::Iterator"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"de::StreamDeserializer":{"R":["read::Fused","read::Read","std::marker::Sized"],"T":["serde::Deserialize","std::marker::Sized"]},"iter::LineColIterator":{"I":["std::marker::Sized","std::iter::Iterator"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"value::from::<impl std::iter::FromIterator<T> for value::Value>::from_iter":{"I":["std::iter::IntoIterator","std::marker::Sized"],"T":["std::convert::Into","std::marker::Sized"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["map::IterMut","<&mut I as std::iter::Iterator>","map::IntoIter","iter::LineColIterator","map::ValuesMut","map::Iter","de::StreamDeserializer","map::Keys","map::Values"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"de::StreamDeserializer":{"R":["read::SliceRead","read::StrRead"],"T":["value::Value","number::Number","map::Map"]},"iter::LineColIterator":{"I":["map::Iter","map::Keys","iter::LineColIterator","map::Values","<&mut I as std::iter::Iterator>","map::IterMut","map::IntoIter","de::StreamDeserializer","map::ValuesMut"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"value::from::<impl std::iter::FromIterator<T> for value::Value>::from_iter":{"I":["map::Map","<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>","<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>"],"T":["std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","<T as std::convert::Into<U>>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+value::from::<impl std::iter::FromIterator<T> for value::Value>::from_iter(p0);
+crate::value::from::<impl std::iter::FromIterator<T> for value::Value>::from_iter(p0);
+<value::Value>::from_iter(p0);
-----------------
src/value/from.rs value::from::<impl std::iter::FromIterator<(K, V)> for value::Value>::from_iter
deps:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["std::iter::Iterator","std::marker::Sized"]},"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"de::StreamDeserializer":{"R":["read::Read","std::marker::Sized","read::Fused"],"T":["std::marker::Sized","serde::Deserialize"]},"iter::LineColIterator":{"I":["std::marker::Sized","std::iter::Iterator"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"value::from::<impl std::iter::FromIterator<(K, V)> for value::Value>::from_iter":{"I":["std::marker::Sized","std::iter::IntoIterator"],"K":["std::marker::Sized","std::convert::Into"],"V":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<&'a hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a hashbrown::set::HashSet<T, S, A> as std::iter::IntoIterator>":{},"<&'a map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut hashbrown::map::HashMap<K, V, S, A> as std::iter::IntoIterator>":{},"<&'a mut map::Map<std::string::String, value::Value> as std::iter::IntoIterator>":{},"<&'a mut std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a mut std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a mut std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a mut std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a mut std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a mut std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a mut std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeMap<K, V, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BTreeSet<T, A> as std::iter::IntoIterator>":{},"<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>":{},"<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>":{},"<&'a std::collections::HashSet<T, S> as std::iter::IntoIterator>":{},"<&'a std::collections::LinkedList<T> as std::iter::IntoIterator>":{},"<&'a std::collections::VecDeque<T, A> as std::iter::IntoIterator>":{},"<&'a std::option::Option<T> as std::iter::IntoIterator>":{},"<&'a std::result::Result<T, E> as std::iter::IntoIterator>":{},"<&'a std::sync::mpsc::Receiver<T> as std::iter::IntoIterator>":{},"<&'a std::vec::Vec<T, A> as std::iter::IntoIterator>":{},"<&mut I as std::iter::Iterator>":{},"<I as std::iter::IntoIterator>":{"I":["de::StreamDeserializer","iter::LineColIterator","map::ValuesMut","map::Keys","map::IterMut","map::Values","<&mut I as std::iter::Iterator>","map::IntoIter","map::Iter"]},"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"de::StreamDeserializer":{"R":["read::StrRead","read::SliceRead"],"T":["number::Number","map::Map","value::Value"]},"iter::LineColIterator":{"I":["map::ValuesMut","map::Values","map::IntoIter","map::Keys","<&mut I as std::iter::Iterator>","map::IterMut","map::Iter","iter::LineColIterator","de::StreamDeserializer"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"value::from::<impl std::iter::FromIterator<(K, V)> for value::Value>::from_iter":{"I":["<&'a std::collections::HashMap<K, V, S> as std::iter::IntoIterator>","<&'a std::collections::BinaryHeap<T> as std::iter::IntoIterator>","map::Map"],"K":["<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected","std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError"],"V":["std::process::ExitStatusError","std::sync::mpmc::select::Selected","<T as std::convert::Into<U>>","std::sys::unix::process::process_inner::ExitStatusError"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+value::from::<impl std::iter::FromIterator<(K, V)> for value::Value>::from_iter(p0);
+crate::value::from::<impl std::iter::FromIterator<(K, V)> for value::Value>::from_iter(p0);
+<value::Value>::from_iter(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<()> for value::Value>::from
deps:{}
candidates:{}
let mut p0 = (); // None+()
+value::from::<impl std::convert::From<()> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<()> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/from.rs value::from::<impl std::convert::From<std::option::Option<T>> for value::Value>::from
deps:{"<T as std::convert::Into<U>>":{"T":["std::marker::Sized"]},"value::from::<impl std::convert::From<std::option::Option<T>> for value::Value>::from":{"T":["std::marker::Sized","std::convert::Into"]}}
candidates:{"<T as std::convert::Into<U>>":{"T":["RUG_ANY"]},"value::from::<impl std::convert::From<std::option::Option<T>> for value::Value>::from":{"T":["std::sys::unix::process::process_inner::ExitStatusError","std::process::ExitStatusError","<T as std::convert::Into<U>>","std::sync::mpmc::select::Selected"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::option::Option<T>
+value::from::<impl std::convert::From<std::option::Option<T>> for value::Value>::from(p0);
+crate::value::from::<impl std::convert::From<std::option::Option<T>> for value::Value>::from(p0);
+<value::Value>::from(p0);
-----------------
src/value/index.rs <usize as value::index::Index>::index_into
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_into(p1);
+<usize as value::index::Index>::index_into(p0, p1);
+crate::<usize as value::index::Index>::index_into(p0, p1);
+<usize>::index_into(p0, p1);
-----------------
src/value/index.rs <usize as value::index::Index>::index_into_mut
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_into_mut(p1);
+<usize as value::index::Index>::index_into_mut(p0, p1);
+crate::<usize as value::index::Index>::index_into_mut(p0, p1);
+<usize>::index_into_mut(p0, p1);
-----------------
src/value/index.rs <usize as value::index::Index>::index_or_insert
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_or_insert(p1);
+<usize as value::index::Index>::index_or_insert(p0, p1);
+crate::<usize as value::index::Index>::index_or_insert(p0, p1);
+<usize>::index_or_insert(p0, p1);
-----------------
src/value/index.rs <str as value::index::Index>::index_into
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_into(p1);
+<str as value::index::Index>::index_into(&p0, p1);
+crate::<str as value::index::Index>::index_into(&p0, p1);
+<str>::index_into(&p0, p1);
-----------------
src/value/index.rs <str as value::index::Index>::index_into_mut
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_into_mut(p1);
+<str as value::index::Index>::index_into_mut(&p0, p1);
+crate::<str as value::index::Index>::index_into_mut(&p0, p1);
+<str>::index_into_mut(&p0, p1);
-----------------
src/value/index.rs <str as value::index::Index>::index_or_insert
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_or_insert(p1);
+<str as value::index::Index>::index_or_insert(&p0, p1);
+crate::<str as value::index::Index>::index_or_insert(&p0, p1);
+<str>::index_or_insert(&p0, p1);
-----------------
src/value/index.rs <std::string::String as value::index::Index>::index_into
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_into(p1);
+<std::string::String as value::index::Index>::index_into(p0, p1);
+crate::<std::string::String as value::index::Index>::index_into(p0, p1);
+<std::string::String>::index_into(p0, p1);
-----------------
src/value/index.rs <std::string::String as value::index::Index>::index_into_mut
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_into_mut(p1);
+<std::string::String as value::index::Index>::index_into_mut(p0, p1);
+crate::<std::string::String as value::index::Index>::index_into_mut(p0, p1);
+<std::string::String>::index_into_mut(p0, p1);
-----------------
src/value/index.rs <std::string::String as value::index::Index>::index_or_insert
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_or_insert(p1);
+<std::string::String as value::index::Index>::index_or_insert(p0, p1);
+crate::<std::string::String as value::index::Index>::index_or_insert(p0, p1);
+<std::string::String>::index_or_insert(p0, p1);
-----------------
src/value/index.rs <&'a T as value::index::Index>::index_into
'a
deps:{"<&'a T as value::index::Index>":{},"<&'a T as value::index::Index>::index_into":{"T":["value::index::Index"]}}
candidates:{"<&'a T as value::index::Index>":{},"<&'a T as value::index::Index>::index_into":{"T":["std::string::String","<&'a T as value::index::Index>"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_into(p1);
+<&'a T as value::index::Index>::index_into(p0, p1);
+crate::<&'a T as value::index::Index>::index_into(p0, p1);
+<&'a T>::index_into(p0, p1);
-----------------
src/value/index.rs <&'a T as value::index::Index>::index_into_mut
'a
deps:{"<&'a T as value::index::Index>":{},"<&'a T as value::index::Index>::index_into_mut":{"T":["value::index::Index"]}}
candidates:{"<&'a T as value::index::Index>":{},"<&'a T as value::index::Index>::index_into_mut":{"T":["std::string::String","<&'a T as value::index::Index>"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_into_mut(p1);
+<&'a T as value::index::Index>::index_into_mut(p0, p1);
+crate::<&'a T as value::index::Index>::index_into_mut(p0, p1);
+<&'a T>::index_into_mut(p0, p1);
-----------------
src/value/index.rs <&'a T as value::index::Index>::index_or_insert
'a
deps:{"<&'a T as value::index::Index>":{},"<&'a T as value::index::Index>::index_or_insert":{"T":["value::index::Index"]}}
candidates:{"<&'a T as value::index::Index>":{},"<&'a T as value::index::Index>::index_or_insert":{"T":["<&'a T as value::index::Index>","std::string::String"]}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // T
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
+p0.index_or_insert(p1);
+<&'a T as value::index::Index>::index_or_insert(p0, p1);
+crate::<&'a T as value::index::Index>::index_or_insert(p0, p1);
+<&'a T>::index_or_insert(p0, p1);
-----------------
src/value/index.rs <value::index::Type<'a> as std::fmt::Display>::fmt
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::index::Type<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<value::index::Type<'a> as std::fmt::Display>::fmt(p0, p1);
+crate::<value::index::Type<'a> as std::fmt::Display>::fmt(p0, p1);
+<value::index::Type<'a>>::fmt(p0, p1);
-----------------
src/value/index.rs value::index::<impl std::ops::Index<I> for value::Value>::index
deps:{"<&'a T as value::index::Index>":{},"value::index::<impl std::ops::Index<I> for value::Value>::index":{"I":["value::index::Index","std::marker::Sized"]}}
candidates:{"<&'a T as value::index::Index>":{},"value::index::<impl std::ops::Index<I> for value::Value>::index":{"I":["std::string::String","<&'a T as value::index::Index>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.index(p1);
+value::index::<impl std::ops::Index<I> for value::Value>::index(p0, p1);
+crate::value::index::<impl std::ops::Index<I> for value::Value>::index(p0, p1);
+<value::Value>::index(p0, p1);
-----------------
src/value/index.rs value::index::<impl std::ops::IndexMut<I> for value::Value>::index_mut
deps:{"<&'a T as value::index::Index>":{},"value::index::<impl std::ops::IndexMut<I> for value::Value>::index_mut":{"I":["std::marker::Sized","value::index::Index"]}}
candidates:{"<&'a T as value::index::Index>":{},"value::index::<impl std::ops::IndexMut<I> for value::Value>::index_mut":{"I":["<&'a T as value::index::Index>","std::string::String"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // I
+p0.index_mut(p1);
+value::index::<impl std::ops::IndexMut<I> for value::Value>::index_mut(p0, p1);
+crate::value::index::<impl std::ops::IndexMut<I> for value::Value>::index_mut(p0, p1);
+<value::Value>::index_mut(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<str> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = "sample"; // None+&str
+p0.eq(&p1);
+value::partial_eq::<impl std::cmp::PartialEq<str> for value::Value>::eq(p0, &p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<str> for value::Value>::eq(p0, &p1);
+<value::Value>::eq(p0, &p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<&'a str> for value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & "a"; // None+&str
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<&'a str> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<&'a str> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for str>::eq
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for str>::eq(&p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for str>::eq(&p0, p1);
+<str>::eq(&p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for &'a str>::eq
'a
deps:{}
candidates:{}
let mut p0 = & "a"; // None+&'a str
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for &'a str>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for &'a str>::eq(p0, p1);
+<&'a str>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<std::string::String> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & std::string::String::new(); // None+std::string::String
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<std::string::String> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<std::string::String> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for std::string::String>::eq
deps:{}
candidates:{}
let mut p0 = & std::string::String::new(); // None+std::string::String
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for std::string::String>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for std::string::String>::eq(p0, p1);
+<std::string::String>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<i8> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0i8; // None+i8
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<i8> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<i8> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i8>::eq
deps:{}
candidates:{}
let mut p0 = & 0i8; // None+i8
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i8>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i8>::eq(p0, p1);
+<i8>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<i8> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0i8; // None+i8
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<i8> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<i8> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<i8> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0i8; // None+i8
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<i8> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<i8> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<i16> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0i16; // None+i16
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<i16> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<i16> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i16>::eq
deps:{}
candidates:{}
let mut p0 = & 0i16; // None+i16
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i16>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i16>::eq(p0, p1);
+<i16>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<i16> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0i16; // None+i16
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<i16> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<i16> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<i16> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0i16; // None+i16
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<i16> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<i16> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<i32> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0i32; // None+i32
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<i32> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<i32> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i32>::eq
deps:{}
candidates:{}
let mut p0 = & 0i32; // None+i32
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i32>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i32>::eq(p0, p1);
+<i32>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<i32> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0i32; // None+i32
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<i32> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<i32> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<i32> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0i32; // None+i32
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<i32> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<i32> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<i64> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0i64; // None+i64
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<i64> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<i64> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i64>::eq
deps:{}
candidates:{}
let mut p0 = & 0i64; // None+i64
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i64>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for i64>::eq(p0, p1);
+<i64>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<i64> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0i64; // None+i64
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<i64> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<i64> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<i64> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0i64; // None+i64
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<i64> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<i64> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<isize> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0isize; // None+isize
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<isize> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<isize> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for isize>::eq
deps:{}
candidates:{}
let mut p0 = & 0isize; // None+isize
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for isize>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for isize>::eq(p0, p1);
+<isize>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<isize> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0isize; // None+isize
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<isize> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<isize> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<isize> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0isize; // None+isize
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<isize> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<isize> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<u8> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0u8; // None+u8
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<u8> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<u8> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u8>::eq
deps:{}
candidates:{}
let mut p0 = & 0u8; // None+u8
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u8>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u8>::eq(p0, p1);
+<u8>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<u8> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0u8; // None+u8
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<u8> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<u8> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<u8> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0u8; // None+u8
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<u8> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<u8> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<u16> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0u16; // None+u16
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<u16> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<u16> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u16>::eq
deps:{}
candidates:{}
let mut p0 = & 0u16; // None+u16
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u16>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u16>::eq(p0, p1);
+<u16>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<u16> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0u16; // None+u16
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<u16> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<u16> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<u16> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0u16; // None+u16
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<u16> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<u16> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<u32> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0u32; // None+u32
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<u32> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<u32> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u32>::eq
deps:{}
candidates:{}
let mut p0 = & 0u32; // None+u32
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u32>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u32>::eq(p0, p1);
+<u32>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<u32> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0u32; // None+u32
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<u32> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<u32> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<u32> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0u32; // None+u32
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<u32> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<u32> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<u64> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0u64; // None+u64
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<u64> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<u64> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u64>::eq
deps:{}
candidates:{}
let mut p0 = & 0u64; // None+u64
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u64>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for u64>::eq(p0, p1);
+<u64>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<u64> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0u64; // None+u64
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<u64> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<u64> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<u64> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0u64; // None+u64
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<u64> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<u64> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<usize> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0usize; // None+usize
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<usize> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<usize> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for usize>::eq
deps:{}
candidates:{}
let mut p0 = & 0usize; // None+usize
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for usize>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for usize>::eq(p0, p1);
+<usize>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<usize> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0usize; // None+usize
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<usize> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<usize> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<usize> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0usize; // None+usize
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<usize> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<usize> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<f32> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0f32; // None+f32
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<f32> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<f32> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for f32>::eq
deps:{}
candidates:{}
let mut p0 = & 0f32; // None+f32
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for f32>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for f32>::eq(p0, p1);
+<f32>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<f32> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0f32; // None+f32
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<f32> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<f32> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<f32> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0f32; // None+f32
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<f32> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<f32> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<f64> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0f64; // None+f64
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<f64> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<f64> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for f64>::eq
deps:{}
candidates:{}
let mut p0 = & 0f64; // None+f64
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for f64>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for f64>::eq(p0, p1);
+<f64>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<f64> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0f64; // None+f64
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<f64> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<f64> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<f64> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & 0f64; // None+f64
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<f64> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<f64> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<bool> for value::Value>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & true; // None+bool
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<bool> for value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<bool> for value::Value>::eq(p0, p1);
+<value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<value::Value> for bool>::eq
deps:{}
candidates:{}
let mut p0 = & true; // None+bool
let mut p1 = & MaybeUninit::uninit().assume_init(); // value::Value
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<value::Value> for bool>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<value::Value> for bool>::eq(p0, p1);
+<bool>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<bool> for &'a value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & true; // None+bool
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<bool> for &'a value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<bool> for &'a value::Value>::eq(p0, p1);
+<&'a value::Value>::eq(p0, p1);
-----------------
src/value/partial_eq.rs value::partial_eq::<impl std::cmp::PartialEq<bool> for &'a mut value::Value>::eq
'a
deps:{}
candidates:{}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = & true; // None+bool
+p0.eq(p1);
+value::partial_eq::<impl std::cmp::PartialEq<bool> for &'a mut value::Value>::eq(p0, p1);
+crate::value::partial_eq::<impl std::cmp::PartialEq<bool> for &'a mut value::Value>::eq(p0, p1);
+<&'a mut value::Value>::eq(p0, p1);
-----------------
src/value/ser.rs value::ser::<impl serde::Serialize for value::Value>::serialize
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>":{},"ser::MapKeySerializer":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::marker::Sized","std::io::Write"]},"serde::ser::fmt::<impl serde::Serializer for &mut std::fmt::Formatter<'a>>":{},"std::io::impls::<impl std::io::Write for &mut W>":{},"value::ser::<impl serde::Serialize for value::Value>::serialize":{"S":["serde::Serializer","std::marker::Sized"]}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>":{},"ser::MapKeySerializer":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"serde::ser::fmt::<impl serde::Serializer for &mut std::fmt::Formatter<'a>>":{},"std::io::impls::<impl std::io::Write for &mut W>":{},"value::ser::<impl serde::Serialize for value::Value>::serialize":{"S":["serde::ser::fmt::<impl serde::Serializer for &mut std::fmt::Formatter<'a>>","<&'a mut ser::Serializer<W, F> as serde::Serializer>","value::ser::Serializer","value::ser::MapKeySerializer","ser::MapKeySerializer"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // value::Value
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.serialize(p1);
+value::ser::<impl serde::Serialize for value::Value>::serialize(p0, p1);
+crate::value::ser::<impl serde::Serialize for value::Value>::serialize(p0, p1);
+<value::Value>::serialize(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_bool
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = true; // None+bool
+p0.serialize_bool(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_bool(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_bool(p0, p1);
+<value::ser::Serializer>::serialize_bool(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_i8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0i8; // None+i8
+p0.serialize_i8(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_i8(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_i8(p0, p1);
+<value::ser::Serializer>::serialize_i8(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_i16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0i16; // None+i16
+p0.serialize_i16(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_i16(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_i16(p0, p1);
+<value::ser::Serializer>::serialize_i16(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_i32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0i32; // None+i32
+p0.serialize_i32(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_i32(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_i32(p0, p1);
+<value::ser::Serializer>::serialize_i32(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_i64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0i64; // None+i64
+p0.serialize_i64(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_i64(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_i64(p0, p1);
+<value::ser::Serializer>::serialize_i64(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_i128
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0i128; // None+i128
+p0.serialize_i128(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_i128(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_i128(p0, p1);
+<value::ser::Serializer>::serialize_i128(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_u8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0u8; // None+u8
+p0.serialize_u8(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_u8(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_u8(p0, p1);
+<value::ser::Serializer>::serialize_u8(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_u16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0u16; // None+u16
+p0.serialize_u16(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_u16(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_u16(p0, p1);
+<value::ser::Serializer>::serialize_u16(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_u32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0u32; // None+u32
+p0.serialize_u32(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_u32(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_u32(p0, p1);
+<value::ser::Serializer>::serialize_u32(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_u64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0u64; // None+u64
+p0.serialize_u64(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_u64(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_u64(p0, p1);
+<value::ser::Serializer>::serialize_u64(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_u128
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0u128; // None+u128
+p0.serialize_u128(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_u128(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_u128(p0, p1);
+<value::ser::Serializer>::serialize_u128(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_f32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0f32; // None+f32
+p0.serialize_f32(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_f32(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_f32(p0, p1);
+<value::ser::Serializer>::serialize_f32(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_f64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0f64; // None+f64
+p0.serialize_f64(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_f64(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_f64(p0, p1);
+<value::ser::Serializer>::serialize_f64(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_char
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 'a'; // None+char
+p0.serialize_char(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_char(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_char(p0, p1);
+<value::ser::Serializer>::serialize_char(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_str
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = "sample"; // None+&str
+p0.serialize_str(&p1);
+<value::ser::Serializer as serde::Serializer>::serialize_str(p0, &p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_str(p0, &p1);
+<value::ser::Serializer>::serialize_str(p0, &p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.serialize_bytes(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_bytes(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_bytes(p0, p1);
+<value::ser::Serializer>::serialize_bytes(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_unit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
+p0.serialize_unit();
+<value::ser::Serializer as serde::Serializer>::serialize_unit(p0);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_unit(p0);
+<value::ser::Serializer>::serialize_unit(p0);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_unit_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = "sample"; // None+&str
+p0.serialize_unit_struct(&p1);
+<value::ser::Serializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+<value::ser::Serializer>::serialize_unit_struct(p0, &p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_unit_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
+p0.serialize_unit_variant(&p1, p2, &p3);
+<value::ser::Serializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+<value::ser::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_newtype_struct
deps:{"<value::ser::Serializer as serde::Serializer>::serialize_newtype_struct":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::Serializer as serde::Serializer>::serialize_newtype_struct":{"T":["number::Number","value::Value","map::Map","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_struct(&p1, p2);
+<value::ser::Serializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+<value::ser::Serializer>::serialize_newtype_struct(p0, &p1, p2);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_newtype_variant
deps:{"<value::ser::Serializer as serde::Serializer>::serialize_newtype_variant":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::Serializer as serde::Serializer>::serialize_newtype_variant":{"T":["value::Value","number::Number","serde::ser::impls::<impl serde::Serialize for &'a mut T>","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_variant(&p1, p2, &p3, p4);
+<value::ser::Serializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+<value::ser::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_none
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
+p0.serialize_none();
+<value::ser::Serializer as serde::Serializer>::serialize_none(p0);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_none(p0);
+<value::ser::Serializer>::serialize_none(p0);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_some
deps:{"<value::ser::Serializer as serde::Serializer>::serialize_some":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::Serializer as serde::Serializer>::serialize_some":{"T":["number::Number","value::Value","map::Map","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_some(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_some(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_some(p0, p1);
+<value::ser::Serializer>::serialize_some(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_seq
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_seq(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_seq(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_seq(p0, p1);
+<value::ser::Serializer>::serialize_seq(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_tuple
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = 0usize; // None+usize
+p0.serialize_tuple(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_tuple(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_tuple(p0, p1);
+<value::ser::Serializer>::serialize_tuple(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_tuple_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_tuple_struct(&p1, p2);
+<value::ser::Serializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+<value::ser::Serializer>::serialize_tuple_struct(p0, &p1, p2);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_tuple_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_tuple_variant(&p1, p2, &p3, p4);
+<value::ser::Serializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+<value::ser::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_map
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_map(p1);
+<value::ser::Serializer as serde::Serializer>::serialize_map(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_map(p0, p1);
+<value::ser::Serializer>::serialize_map(p0, p1);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_struct(&p1, p2);
+<value::ser::Serializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+<value::ser::Serializer>::serialize_struct(p0, &p1, p2);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::serialize_struct_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_struct_variant(&p1, p2, &p3, p4);
+<value::ser::Serializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+crate::<value::ser::Serializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+<value::ser::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
-----------------
src/value/ser.rs <value::ser::Serializer as serde::Serializer>::collect_str
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<value::ser::Serializer as serde::Serializer>::collect_str":{"T":["std::fmt::Display"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<value::ser::Serializer as serde::Serializer>::collect_str":{"T":["number::Number","value::Value","error::Error","error::ErrorCode","value::index::Type","error::ErrorImpl","<&T as std::fmt::Display>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::Serializer
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.collect_str(p1);
+<value::ser::Serializer as serde::Serializer>::collect_str(p0, p1);
+crate::<value::ser::Serializer as serde::Serializer>::collect_str(p0, p1);
+<value::ser::Serializer>::collect_str(p0, p1);
-----------------
src/value/ser.rs <value::ser::SerializeVec as serde::ser::SerializeSeq>::serialize_element
deps:{"<value::ser::SerializeVec as serde::ser::SerializeSeq>::serialize_element":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::SerializeVec as serde::ser::SerializeSeq>::serialize_element":{"T":["map::Map","number::Number","value::Value","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ser::SerializeVec
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_element(p1);
+<value::ser::SerializeVec as serde::ser::SerializeSeq>::serialize_element(p0, p1);
+crate::<value::ser::SerializeVec as serde::ser::SerializeSeq>::serialize_element(p0, p1);
+<value::ser::SerializeVec>::serialize_element(p0, p1);
-----------------
src/value/ser.rs <value::ser::SerializeVec as serde::ser::SerializeSeq>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::SerializeVec
+p0.end();
+<value::ser::SerializeVec as serde::ser::SerializeSeq>::end(p0);
+crate::<value::ser::SerializeVec as serde::ser::SerializeSeq>::end(p0);
+<value::ser::SerializeVec>::end(p0);
-----------------
src/value/ser.rs <value::ser::SerializeVec as serde::ser::SerializeTuple>::serialize_element
deps:{"<value::ser::SerializeVec as serde::ser::SerializeTuple>::serialize_element":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::SerializeVec as serde::ser::SerializeTuple>::serialize_element":{"T":["value::Value","number::Number","serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ser::SerializeVec
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_element(p1);
+<value::ser::SerializeVec as serde::ser::SerializeTuple>::serialize_element(p0, p1);
+crate::<value::ser::SerializeVec as serde::ser::SerializeTuple>::serialize_element(p0, p1);
+<value::ser::SerializeVec>::serialize_element(p0, p1);
-----------------
src/value/ser.rs <value::ser::SerializeVec as serde::ser::SerializeTuple>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::SerializeVec
+p0.end();
+<value::ser::SerializeVec as serde::ser::SerializeTuple>::end(p0);
+crate::<value::ser::SerializeVec as serde::ser::SerializeTuple>::end(p0);
+<value::ser::SerializeVec>::end(p0);
-----------------
src/value/ser.rs <value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::serialize_field
deps:{"<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::serialize_field":{"T":["value::Value","serde::ser::impls::<impl serde::Serialize for &'a T>","number::Number","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ser::SerializeVec
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(p1);
+<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::serialize_field(p0, p1);
+crate::<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::serialize_field(p0, p1);
+<value::ser::SerializeVec>::serialize_field(p0, p1);
-----------------
src/value/ser.rs <value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::SerializeVec
+p0.end();
+<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::end(p0);
+crate::<value::ser::SerializeVec as serde::ser::SerializeTupleStruct>::end(p0);
+<value::ser::SerializeVec>::end(p0);
-----------------
src/value/ser.rs <value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::serialize_field
deps:{"<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::serialize_field":{"T":["number::Number","serde::ser::impls::<impl serde::Serialize for &'a T>","value::Value","map::Map"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ser::SerializeTupleVariant
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(p1);
+<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::serialize_field(p0, p1);
+crate::<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::serialize_field(p0, p1);
+<value::ser::SerializeTupleVariant>::serialize_field(p0, p1);
-----------------
src/value/ser.rs <value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::SerializeTupleVariant
+p0.end();
+<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::end(p0);
+crate::<value::ser::SerializeTupleVariant as serde::ser::SerializeTupleVariant>::end(p0);
+<value::ser::SerializeTupleVariant>::end(p0);
-----------------
src/value/ser.rs <value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_key
deps:{"<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_key":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_key":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","number::Number","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ser::SerializeMap
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_key(p1);
+<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_key(p0, p1);
+crate::<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_key(p0, p1);
+<value::ser::SerializeMap>::serialize_key(p0, p1);
-----------------
src/value/ser.rs <value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_value
deps:{"<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_value":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_value":{"T":["number::Number","map::Map","serde::ser::impls::<impl serde::Serialize for &'a T>","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ser::SerializeMap
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_value(p1);
+<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_value(p0, p1);
+crate::<value::ser::SerializeMap as serde::ser::SerializeMap>::serialize_value(p0, p1);
+<value::ser::SerializeMap>::serialize_value(p0, p1);
-----------------
src/value/ser.rs <value::ser::SerializeMap as serde::ser::SerializeMap>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::SerializeMap
+p0.end();
+<value::ser::SerializeMap as serde::ser::SerializeMap>::end(p0);
+crate::<value::ser::SerializeMap as serde::ser::SerializeMap>::end(p0);
+<value::ser::SerializeMap>::end(p0);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
+p0.serialize_unit_variant(&p1, p2, &p3);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_variant(p0, &p1, p2, &p3);
+<value::ser::MapKeySerializer>::serialize_unit_variant(p0, &p1, p2, &p3);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_struct
deps:{"<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_struct":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_struct":{"T":["serde::ser::impls::<impl serde::Serialize for &'a T>","map::Map","value::Value","number::Number"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_struct(&p1, p2);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_struct(p0, &p1, p2);
+<value::ser::MapKeySerializer>::serialize_newtype_struct(p0, &p1, p2);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_bool
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = true; // None+bool
+p0.serialize_bool(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_bool(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_bool(p0, p1);
+<value::ser::MapKeySerializer>::serialize_bool(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_i8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = 0i8; // None+i8
+p0.serialize_i8(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_i8(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_i8(p0, p1);
+<value::ser::MapKeySerializer>::serialize_i8(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_i16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = 0i16; // None+i16
+p0.serialize_i16(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_i16(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_i16(p0, p1);
+<value::ser::MapKeySerializer>::serialize_i16(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_i32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = 0i32; // None+i32
+p0.serialize_i32(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_i32(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_i32(p0, p1);
+<value::ser::MapKeySerializer>::serialize_i32(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_i64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = 0i64; // None+i64
+p0.serialize_i64(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_i64(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_i64(p0, p1);
+<value::ser::MapKeySerializer>::serialize_i64(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_u8
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = 0u8; // None+u8
+p0.serialize_u8(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_u8(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_u8(p0, p1);
+<value::ser::MapKeySerializer>::serialize_u8(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_u16
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = 0u16; // None+u16
+p0.serialize_u16(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_u16(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_u16(p0, p1);
+<value::ser::MapKeySerializer>::serialize_u16(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_u32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = 0u32; // None+u32
+p0.serialize_u32(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_u32(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_u32(p0, p1);
+<value::ser::MapKeySerializer>::serialize_u32(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_u64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = 0u64; // None+u64
+p0.serialize_u64(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_u64(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_u64(p0, p1);
+<value::ser::MapKeySerializer>::serialize_u64(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_f32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = 0f32; // None+f32
+p0.serialize_f32(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_f32(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_f32(p0, p1);
+<value::ser::MapKeySerializer>::serialize_f32(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_f64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = 0f64; // None+f64
+p0.serialize_f64(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_f64(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_f64(p0, p1);
+<value::ser::MapKeySerializer>::serialize_f64(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_char
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = 'a'; // None+char
+p0.serialize_char(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_char(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_char(p0, p1);
+<value::ser::MapKeySerializer>::serialize_char(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_str
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = "sample"; // None+&str
+p0.serialize_str(&p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_str(p0, &p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_str(p0, &p1);
+<value::ser::MapKeySerializer>::serialize_str(p0, &p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_bytes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+p0.serialize_bytes(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_bytes(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_bytes(p0, p1);
+<value::ser::MapKeySerializer>::serialize_bytes(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_unit
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
+p0.serialize_unit();
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit(p0);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit(p0);
+<value::ser::MapKeySerializer>::serialize_unit(p0);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = "sample"; // None+&str
+p0.serialize_unit_struct(&p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_unit_struct(p0, &p1);
+<value::ser::MapKeySerializer>::serialize_unit_struct(p0, &p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_variant
deps:{"<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_variant":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_variant":{"T":["map::Map","number::Number","serde::ser::impls::<impl serde::Serialize for &'a T>","value::Value"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_newtype_variant(&p1, p2, &p3, p4);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
+<value::ser::MapKeySerializer>::serialize_newtype_variant(p0, &p1, p2, &p3, p4);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_none
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
+p0.serialize_none();
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_none(p0);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_none(p0);
+<value::ser::MapKeySerializer>::serialize_none(p0);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_some
deps:{"<value::ser::MapKeySerializer as serde::Serializer>::serialize_some":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::MapKeySerializer as serde::Serializer>::serialize_some":{"T":["value::Value","map::Map","number::Number","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_some(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_some(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_some(p0, p1);
+<value::ser::MapKeySerializer>::serialize_some(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_seq
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_seq(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_seq(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_seq(p0, p1);
+<value::ser::MapKeySerializer>::serialize_seq(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = 0usize; // None+usize
+p0.serialize_tuple(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple(p0, p1);
+<value::ser::MapKeySerializer>::serialize_tuple(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_tuple_struct(&p1, p2);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_struct(p0, &p1, p2);
+<value::ser::MapKeySerializer>::serialize_tuple_struct(p0, &p1, p2);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_tuple_variant(&p1, p2, &p3, p4);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
+<value::ser::MapKeySerializer>::serialize_tuple_variant(p0, &p1, p2, &p3, p4);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_map
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = MaybeUninit::uninit().assume_init(); // std::option::Option<usize>
+p0.serialize_map(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_map(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_map(p0, p1);
+<value::ser::MapKeySerializer>::serialize_map(p0, p1);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_struct
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
+p0.serialize_struct(&p1, p2);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct(p0, &p1, p2);
+<value::ser::MapKeySerializer>::serialize_struct(p0, &p1, p2);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::serialize_struct_variant
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = "sample"; // None+&str
let mut p2 = 0u32; // None+u32
let mut p3 = "sample"; // None+&str
let mut p4 = 0usize; // None+usize
+p0.serialize_struct_variant(&p1, p2, &p3, p4);
+<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
+<value::ser::MapKeySerializer>::serialize_struct_variant(p0, &p1, p2, &p3, p4);
-----------------
src/value/ser.rs <value::ser::MapKeySerializer as serde::Serializer>::collect_str
deps:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<value::ser::MapKeySerializer as serde::Serializer>::collect_str":{"T":["std::fmt::Display"]}}
candidates:{"<&T as std::fmt::Display>":{},"<&mut T as std::fmt::Display>":{},"<value::ser::MapKeySerializer as serde::Serializer>::collect_str":{"T":["value::Value","number::Number","error::ErrorCode","value::index::Type","<&T as std::fmt::Display>","error::Error","error::ErrorImpl"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::MapKeySerializer
let mut p1 = & MaybeUninit::uninit().assume_init(); // T
+p0.collect_str(p1);
+<value::ser::MapKeySerializer as serde::Serializer>::collect_str(p0, p1);
+crate::<value::ser::MapKeySerializer as serde::Serializer>::collect_str(p0, p1);
+<value::ser::MapKeySerializer>::collect_str(p0, p1);
-----------------
src/value/ser.rs <value::ser::SerializeMap as serde::ser::SerializeStruct>::serialize_field
deps:{"<value::ser::SerializeMap as serde::ser::SerializeStruct>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::SerializeMap as serde::ser::SerializeStruct>::serialize_field":{"T":["value::Value","number::Number","map::Map","serde::ser::impls::<impl serde::Serialize for &'a T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ser::SerializeMap
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(&p1, p2);
+<value::ser::SerializeMap as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+crate::<value::ser::SerializeMap as serde::ser::SerializeStruct>::serialize_field(p0, &p1, p2);
+<value::ser::SerializeMap>::serialize_field(p0, &p1, p2);
-----------------
src/value/ser.rs <value::ser::SerializeMap as serde::ser::SerializeStruct>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::SerializeMap
+p0.end();
+<value::ser::SerializeMap as serde::ser::SerializeStruct>::end(p0);
+crate::<value::ser::SerializeMap as serde::ser::SerializeStruct>::end(p0);
+<value::ser::SerializeMap>::end(p0);
-----------------
src/value/ser.rs <value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::serialize_field
deps:{"<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::serialize_field":{"T":["serde::Serialize"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
candidates:{"<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::serialize_field":{"T":["value::Value","map::Map","number::Number","serde::ser::impls::<impl serde::Serialize for &'a mut T>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]},"serde::ser::impls::<impl serde::Serialize for &'a T>":{},"serde::ser::impls::<impl serde::Serialize for &'a mut T>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // value::ser::SerializeStructVariant
let mut p1 = "sample"; // None+&str
let mut p2 = & MaybeUninit::uninit().assume_init(); // T
+p0.serialize_field(&p1, p2);
+<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::serialize_field(p0, &p1, p2);
+crate::<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::serialize_field(p0, &p1, p2);
+<value::ser::SerializeStructVariant>::serialize_field(p0, &p1, p2);
-----------------
src/value/ser.rs <value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::end
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // value::ser::SerializeStructVariant
+p0.end();
+<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::end(p0);
+crate::<value::ser::SerializeStructVariant as serde::ser::SerializeStructVariant>::end(p0);
+<value::ser::SerializeStructVariant>::end(p0);
-----------------
src/iter.rs iter::LineColIterator::<I>::new
deps:{"<&mut I as std::iter::Iterator>":{},"de::StreamDeserializer":{"R":["std::marker::Sized","read::Read","read::Fused"],"T":["std::marker::Sized","serde::Deserialize"]},"iter::LineColIterator":{"I":["std::iter::Iterator","std::marker::Sized"]},"iter::LineColIterator::<I>::new":{"I":["std::marker::Sized","std::iter::Iterator"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<&mut I as std::iter::Iterator>":{},"de::StreamDeserializer":{"R":["read::SliceRead","read::StrRead"],"T":["map::Map","number::Number","value::Value"]},"iter::LineColIterator":{"I":["iter::LineColIterator","map::ValuesMut","map::IterMut","map::IntoIter","de::StreamDeserializer","map::Values","map::Keys","<&mut I as std::iter::Iterator>","map::Iter"]},"iter::LineColIterator::<I>::new":{"I":["map::Keys","de::StreamDeserializer","map::IntoIter","<&mut I as std::iter::Iterator>","map::IterMut","map::Values","map::ValuesMut","iter::LineColIterator","map::Iter"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+iter::LineColIterator::<I>::new(p0);
+crate::iter::LineColIterator::<I>::new(p0);
+<iter::LineColIterator<I>>::new(p0);
-----------------
src/iter.rs iter::LineColIterator::<I>::line
deps:{"<&mut I as std::iter::Iterator>":{},"de::StreamDeserializer":{"R":["read::Fused","read::Read","std::marker::Sized"],"T":["serde::Deserialize","std::marker::Sized"]},"iter::LineColIterator":{"I":["std::marker::Sized","std::iter::Iterator"]},"iter::LineColIterator::<I>::line":{"I":["std::marker::Sized","std::iter::Iterator"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<&mut I as std::iter::Iterator>":{},"de::StreamDeserializer":{"R":["read::StrRead","read::SliceRead"],"T":["map::Map","number::Number","value::Value"]},"iter::LineColIterator":{"I":["map::Values","map::IntoIter","map::ValuesMut","<&mut I as std::iter::Iterator>","de::StreamDeserializer","map::IterMut","iter::LineColIterator","map::Keys","map::Iter"]},"iter::LineColIterator::<I>::line":{"I":["<&mut I as std::iter::Iterator>","de::StreamDeserializer","map::Iter","map::IterMut","map::Values","iter::LineColIterator","map::IntoIter","map::Keys","map::ValuesMut"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // iter::LineColIterator<I>
+p0.line();
+iter::LineColIterator::<I>::line(p0);
+crate::iter::LineColIterator::<I>::line(p0);
+<iter::LineColIterator<I>>::line(p0);
-----------------
src/iter.rs iter::LineColIterator::<I>::col
deps:{"<&mut I as std::iter::Iterator>":{},"de::StreamDeserializer":{"R":["read::Fused","std::marker::Sized","read::Read"],"T":["std::marker::Sized","serde::Deserialize"]},"iter::LineColIterator":{"I":["std::iter::Iterator","std::marker::Sized"]},"iter::LineColIterator::<I>::col":{"I":["std::iter::Iterator","std::marker::Sized"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<&mut I as std::iter::Iterator>":{},"de::StreamDeserializer":{"R":["read::SliceRead","read::StrRead"],"T":["number::Number","map::Map","value::Value"]},"iter::LineColIterator":{"I":["<&mut I as std::iter::Iterator>","map::Values","iter::LineColIterator","map::IterMut","map::ValuesMut","de::StreamDeserializer","map::IntoIter","map::Keys","map::Iter"]},"iter::LineColIterator::<I>::col":{"I":["iter::LineColIterator","de::StreamDeserializer","map::Values","map::IntoIter","map::ValuesMut","map::Iter","map::IterMut","map::Keys","<&mut I as std::iter::Iterator>"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // iter::LineColIterator<I>
+p0.col();
+iter::LineColIterator::<I>::col(p0);
+crate::iter::LineColIterator::<I>::col(p0);
+<iter::LineColIterator<I>>::col(p0);
-----------------
src/iter.rs iter::LineColIterator::<I>::byte_offset
deps:{"<&mut I as std::iter::Iterator>":{},"de::StreamDeserializer":{"R":["read::Read","read::Fused","std::marker::Sized"],"T":["std::marker::Sized","serde::Deserialize"]},"iter::LineColIterator":{"I":["std::marker::Sized","std::iter::Iterator"]},"iter::LineColIterator::<I>::byte_offset":{"I":["std::marker::Sized","std::iter::Iterator"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<&mut I as std::iter::Iterator>":{},"de::StreamDeserializer":{"R":["read::SliceRead","read::StrRead"],"T":["number::Number","value::Value","map::Map"]},"iter::LineColIterator":{"I":["iter::LineColIterator","<&mut I as std::iter::Iterator>","map::IterMut","de::StreamDeserializer","map::ValuesMut","map::IntoIter","map::Iter","map::Values","map::Keys"]},"iter::LineColIterator::<I>::byte_offset":{"I":["map::IntoIter","map::Iter","map::IterMut","map::ValuesMut","map::Values","iter::LineColIterator","<&mut I as std::iter::Iterator>","de::StreamDeserializer","map::Keys"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // iter::LineColIterator<I>
+p0.byte_offset();
+iter::LineColIterator::<I>::byte_offset(p0);
+crate::iter::LineColIterator::<I>::byte_offset(p0);
+<iter::LineColIterator<I>>::byte_offset(p0);
-----------------
src/iter.rs <iter::LineColIterator<I> as std::iter::Iterator>::next
deps:{"<&mut I as std::iter::Iterator>":{},"<iter::LineColIterator<I> as std::iter::Iterator>::next":{"I":["std::marker::Sized","std::iter::Iterator"]},"de::StreamDeserializer":{"R":["read::Fused","read::Read","std::marker::Sized"],"T":["std::marker::Sized","serde::Deserialize"]},"iter::LineColIterator":{"I":["std::iter::Iterator","std::marker::Sized"]},"map::Map":{"K":["std::marker::Sized"],"V":["std::marker::Sized"]}}
candidates:{"<&mut I as std::iter::Iterator>":{},"<iter::LineColIterator<I> as std::iter::Iterator>::next":{"I":["de::StreamDeserializer","map::IterMut","map::Values","<&mut I as std::iter::Iterator>","map::Iter","map::IntoIter","iter::LineColIterator","map::ValuesMut","map::Keys"]},"de::StreamDeserializer":{"R":["read::StrRead","read::SliceRead"],"T":["number::Number","value::Value","map::Map"]},"iter::LineColIterator":{"I":["<&mut I as std::iter::Iterator>","map::Values","map::Iter","iter::LineColIterator","map::ValuesMut","map::IntoIter","map::Keys","de::StreamDeserializer","map::IterMut"]},"map::Map":{"K":["RUG_ANY"],"V":["RUG_ANY"]}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // iter::LineColIterator<I>
+p0.next();
+<iter::LineColIterator<I> as std::iter::Iterator>::next(p0);
+crate::<iter::LineColIterator<I> as std::iter::Iterator>::next(p0);
+<iter::LineColIterator<I>>::next(p0);
-----------------
src/number.rs <number::Number as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
+p0.clone();
+<number::Number as std::clone::Clone>::clone(p0);
+crate::<number::Number as std::clone::Clone>::clone(p0);
+<number::Number>::clone(p0);
-----------------
src/number.rs <number::Number as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = & MaybeUninit::uninit().assume_init(); // number::Number
+p0.eq(p1);
+<number::Number as std::cmp::PartialEq>::eq(p0, p1);
+crate::<number::Number as std::cmp::PartialEq>::eq(p0, p1);
+<number::Number>::eq(p0, p1);
-----------------
src/number.rs <number::Number as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
+p0.assert_receiver_is_total_eq();
+<number::Number as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<number::Number as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<number::Number>::assert_receiver_is_total_eq(p0);
-----------------
src/number.rs <number::Number as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<number::Number as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<number::Number as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher","std::collections::hash_map::DefaultHasher","std::hash::sip::Hasher<S>","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<number::Number as std::hash::Hash>::hash(p0, p1);
+crate::<number::Number as std::hash::Hash>::hash(p0, p1);
+<number::Number>::hash(p0, p1);
-----------------
src/number.rs <number::N as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::N
+p0.clone();
+<number::N as std::clone::Clone>::clone(p0);
+crate::<number::N as std::clone::Clone>::clone(p0);
+<number::N>::clone(p0);
-----------------
src/number.rs <number::N as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::N
let mut p1 = & MaybeUninit::uninit().assume_init(); // number::N
+p0.eq(p1);
+<number::N as std::cmp::PartialEq>::eq(p0, p1);
+crate::<number::N as std::cmp::PartialEq>::eq(p0, p1);
+<number::N>::eq(p0, p1);
-----------------
src/number.rs <number::N as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<number::N as std::hash::Hash>::hash":{"H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<number::N as std::hash::Hash>::hash":{"H":["std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::boxed::Box<T, A>","std::hash::SipHasher","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::N
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<number::N as std::hash::Hash>::hash(p0, p1);
+crate::<number::N as std::hash::Hash>::hash(p0, p1);
+<number::N>::hash(p0, p1);
-----------------
src/number.rs number::Number::is_i64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
+p0.is_i64();
+number::Number::is_i64(p0);
+crate::number::Number::is_i64(p0);
+<number::Number>::is_i64(p0);
-----------------
src/number.rs number::Number::is_u64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
+p0.is_u64();
+number::Number::is_u64(p0);
+crate::number::Number::is_u64(p0);
+<number::Number>::is_u64(p0);
-----------------
src/number.rs number::Number::is_f64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
+p0.is_f64();
+number::Number::is_f64(p0);
+crate::number::Number::is_f64(p0);
+<number::Number>::is_f64(p0);
-----------------
src/number.rs number::Number::as_i64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
+p0.as_i64();
+number::Number::as_i64(p0);
+crate::number::Number::as_i64(p0);
+<number::Number>::as_i64(p0);
-----------------
src/number.rs number::Number::as_u64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
+p0.as_u64();
+number::Number::as_u64(p0);
+crate::number::Number::as_u64(p0);
+<number::Number>::as_u64(p0);
-----------------
src/number.rs number::Number::as_f64
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
+p0.as_f64();
+number::Number::as_f64(p0);
+crate::number::Number::as_f64(p0);
+<number::Number>::as_f64(p0);
-----------------
src/number.rs number::Number::from_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+number::Number::from_f64(p0);
+crate::number::Number::from_f64(p0);
+<number::Number>::from_f64(p0);
-----------------
src/number.rs number::Number::as_f32
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
+p0.as_f32();
+number::Number::as_f32(p0);
+crate::number::Number::as_f32(p0);
+<number::Number>::as_f32(p0);
-----------------
src/number.rs number::Number::from_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+number::Number::from_f32(p0);
+crate::number::Number::from_f32(p0);
+<number::Number>::from_f32(p0);
-----------------
src/number.rs <number::Number as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<number::Number as std::fmt::Display>::fmt(p0, p1);
+crate::<number::Number as std::fmt::Display>::fmt(p0, p1);
+<number::Number>::fmt(p0, p1);
-----------------
src/number.rs <number::Number as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<number::Number as std::fmt::Debug>::fmt(p0, p1);
+crate::<number::Number as std::fmt::Debug>::fmt(p0, p1);
+<number::Number>::fmt(p0, p1);
-----------------
src/number.rs <number::Number as serde::Serialize>::serialize
deps:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>":{},"<number::Number as serde::Serialize>::serialize":{"S":["serde::Serializer","std::marker::Sized"]},"ser::MapKeySerializer":{"F":["std::marker::Sized","ser::Formatter"],"W":["std::io::Write","std::marker::Sized"]},"serde::ser::fmt::<impl serde::Serializer for &mut std::fmt::Formatter<'a>>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
candidates:{"<&'a mut ser::Serializer<W, F> as serde::Serializer>":{},"<number::Number as serde::Serialize>::serialize":{"S":["value::ser::MapKeySerializer","<&'a mut ser::Serializer<W, F> as serde::Serializer>","value::ser::Serializer","serde::ser::fmt::<impl serde::Serializer for &mut std::fmt::Formatter<'a>>","ser::MapKeySerializer"]},"ser::MapKeySerializer":{"F":["ser::PrettyFormatter","ser::CompactFormatter"],"W":["std::io::impls::<impl std::io::Write for &mut W>","<value::Value as std::fmt::Display>::fmt::WriterFormatter"]},"serde::ser::fmt::<impl serde::Serializer for &mut std::fmt::Formatter<'a>>":{},"std::io::impls::<impl std::io::Write for &mut W>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // S
+p0.serialize(p1);
+<number::Number as serde::Serialize>::serialize(p0, p1);
+crate::<number::Number as serde::Serialize>::serialize(p0, p1);
+<number::Number>::serialize(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserialize<'de>>::deserialize
'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>":{},"<number::Number as serde::Deserialize<'de>>::deserialize":{"D":["std::marker::Sized","serde::Deserializer"]},"de::MapKey":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>":{},"<number::Number as serde::Deserialize<'de>>::deserialize":{"D":["value::de::BorrowedCowStrDeserializer","number::Number","value::de::MapKeyDeserializer","<&'a mut de::Deserializer<R> as serde::Deserializer<'de>>","de::MapKey","value::Value"]},"de::MapKey":{"R":["read::IoRead","read::SliceRead","read::StrRead","<&'a mut R as read::Read<'de>>"]},"read::IoRead":{"R":["&'a std::sys::unix::fd::FileDesc","std::io::StdinLock<'_>","std::io::Repeat","std::io::Chain<T, U>","std::io::BufReader<R>","std::io::impls::<impl std::io::Read for &mut R>","std::io::Cursor<T>","std::io::Stdin","std::boxed::Box<R>","std::io::Take<T>","std::fs::File","std::collections::VecDeque<u8, A>","std::sys::unix::stdio::Stdin","&std::net::TcpStream","std::process::ChildStderr","std::net::TcpStream","std::io::stdio::StdinRaw","std::process::ChildStdout","&std::fs::File","std::os::unix::net::UnixStream","std::io::Empty","&'a std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // D
+<number::Number as serde::Deserialize<'de>>::deserialize(p0);
+crate::<number::Number as serde::Deserialize<'de>>::deserialize(p0);
+<number::Number>::deserialize(p0);
-----------------
src/number.rs <<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::expecting
'de
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // <number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+p0.expecting(p1);
+<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+crate::<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::expecting(p0, p1);
+<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor>::expecting(p0, p1);
-----------------
src/number.rs <<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i64
'de
deps:{"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i64":{"E":["std::marker::Sized"]}}
candidates:{"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i64":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor
let mut p1 = 0i64; // None+i64
+p0.visit_i64(p1);
+<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i64(p0, p1);
+crate::<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_i64(p0, p1);
+<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor>::visit_i64(p0, p1);
-----------------
src/number.rs <<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u64
'de
deps:{"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u64":{"E":["std::marker::Sized"]}}
candidates:{"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u64":{"E":["RUG_ANY"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor
let mut p1 = 0u64; // None+u64
+p0.visit_u64(p1);
+<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+crate::<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_u64(p0, p1);
+<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor>::visit_u64(p0, p1);
-----------------
src/number.rs <<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_f64
'de
deps:{"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_f64":{"E":["serde::de::Error","std::marker::Sized"]}}
candidates:{"<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_f64":{"E":["error::Error"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // <number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor
let mut p1 = 0f64; // None+f64
+p0.visit_f64(p1);
+<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_f64(p0, p1);
+crate::<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor as serde::de::Visitor<'de>>::visit_f64(p0, p1);
+<<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor>::visit_f64(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_any
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_any":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<number::Number>::deserialize_any(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_i8
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_i8":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_i8":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<number::Number>::deserialize_i8(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_i16
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_i16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_i16":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<number::Number>::deserialize_i16(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_i32
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_i32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_i32":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<number::Number>::deserialize_i32(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_i64
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_i64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_i64":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<number::Number>::deserialize_i64(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_i128
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_i128":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_i128":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i128(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_i128(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_i128(p0, p1);
+<number::Number>::deserialize_i128(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_u8
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_u8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_u8":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<number::Number>::deserialize_u8(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_u16
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_u16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_u16":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<number::Number>::deserialize_u16(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_u32
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_u32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_u32":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<number::Number>::deserialize_u32(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_u64
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_u64":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_u64":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<number::Number>::deserialize_u64(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_u128
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_u128":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_u128":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u128(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_u128(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_u128(p0, p1);
+<number::Number>::deserialize_u128(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_f32
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_f32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_f32":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<number::Number>::deserialize_f32(p0, p1);
-----------------
src/number.rs <number::Number as serde::Deserializer<'de>>::deserialize_f64
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_f64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_f64":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<number::Number>::deserialize_f64(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_bool
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_bool":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_bool":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<number::Number>::deserialize_bool(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_char
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_char":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_char":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<number::Number>::deserialize_char(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_str
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_str":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_str":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<number::Number>::deserialize_str(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_string
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_string":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_string":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<number::Number>::deserialize_string(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_bytes
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_bytes":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_bytes":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<number::Number>::deserialize_bytes(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_byte_buf
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<number::Number>::deserialize_byte_buf(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_option
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_option":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_option":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<number::Number>::deserialize_option(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_unit
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_unit":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_unit":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<number::Number>::deserialize_unit(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_unit_struct
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<number::Number as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<number::Number>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<number::Number>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_seq
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_seq":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_seq":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<number::Number>::deserialize_seq(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_tuple
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_tuple":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_tuple":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<number::Number as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<number::Number>::deserialize_tuple(p0, p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<number::Number>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_map
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_map":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_map":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<number::Number>::deserialize_map(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_struct
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_struct":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<number::Number as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<number::Number>::deserialize_struct(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_enum
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_enum":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_enum":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<number::Number as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<number::Number>::deserialize_enum(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_identifier
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_identifier":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<number::Number>::deserialize_identifier(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <number::Number as serde::Deserializer<'de>>::deserialize_ignored_any
'de
deps:{"<number::Number as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<number::Number as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<number::Number as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<number::Number as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<number::Number>::deserialize_ignored_any(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_any
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_any":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_any(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_any(p0, p1);
+<&'a number::Number>::deserialize_any(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_i8
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i8":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i8(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_i8(p0, p1);
+<&'a number::Number>::deserialize_i8(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_i16
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i16":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i16":{"V":["value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i16(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_i16(p0, p1);
+<&'a number::Number>::deserialize_i16(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_i32
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i32":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i32":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i32(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_i32(p0, p1);
+<&'a number::Number>::deserialize_i32(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_i64
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i64":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i64(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_i64(p0, p1);
+<&'a number::Number>::deserialize_i64(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_i128
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i128":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_i128":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_i128(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_i128(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_i128(p0, p1);
+<&'a number::Number>::deserialize_i128(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_u8
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u8":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u8":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u8(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_u8(p0, p1);
+<&'a number::Number>::deserialize_u8(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_u16
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u16":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u16":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u16(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_u16(p0, p1);
+<&'a number::Number>::deserialize_u16(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_u32
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u32":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u32(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_u32(p0, p1);
+<&'a number::Number>::deserialize_u32(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_u64
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u64":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u64(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_u64(p0, p1);
+<&'a number::Number>::deserialize_u64(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_u128
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u128":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_u128":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_u128(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_u128(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_u128(p0, p1);
+<&'a number::Number>::deserialize_u128(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_f32
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_f32":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_f32":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f32(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_f32(p0, p1);
+<&'a number::Number>::deserialize_f32(p0, p1);
-----------------
src/number.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_f64
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_f64":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_f64":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_f64(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_f64(p0, p1);
+<&'a number::Number>::deserialize_f64(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_bool
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_bool":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_bool":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bool(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_bool(p0, p1);
+<&'a number::Number>::deserialize_bool(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_char
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_char":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_char":{"V":["value::de::KeyClassifier","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_char(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_char(p0, p1);
+<&'a number::Number>::deserialize_char(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_str
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_str":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_str":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_str(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_str(p0, p1);
+<&'a number::Number>::deserialize_str(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_string
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_string":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_string":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_string(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_string(p0, p1);
+<&'a number::Number>::deserialize_string(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_bytes
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_bytes":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_bytes":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_bytes(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_bytes(p0, p1);
+<&'a number::Number>::deserialize_bytes(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_byte_buf
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_byte_buf":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_byte_buf(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_byte_buf(p0, p1);
+<&'a number::Number>::deserialize_byte_buf(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_option
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_option":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_option":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_option(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_option(p0, p1);
+<&'a number::Number>::deserialize_option(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_unit
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit(p0, p1);
+<&'a number::Number>::deserialize_unit(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_unit_struct
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit_struct":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_unit_struct(&p1, p2);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_unit_struct(p0, &p1, p2);
+<&'a number::Number>::deserialize_unit_struct(p0, &p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = "sample"; // None+&str
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_newtype_struct(&p1, p2);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_newtype_struct(p0, &p1, p2);
+<&'a number::Number>::deserialize_newtype_struct(p0, &p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_seq
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_seq":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_seq":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_seq(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_seq(p0, p1);
+<&'a number::Number>::deserialize_seq(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = 0usize; // None+usize
let mut p2 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple(p1, p2);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple(p0, p1, p2);
+<&'a number::Number>::deserialize_tuple(p0, p1, p2);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct":{"V":["<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = "sample"; // None+&str
let mut p2 = 0usize; // None+usize
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_tuple_struct(&p1, p2, p3);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_tuple_struct(p0, &p1, p2, p3);
+<&'a number::Number>::deserialize_tuple_struct(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_map
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_map":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_map":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_map(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_map(p0, p1);
+<&'a number::Number>::deserialize_map(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_struct
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_struct":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_struct":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_struct(&p1, p2, p3);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_struct(p0, &p1, p2, p3);
+<&'a number::Number>::deserialize_struct(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_enum
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_enum":{"V":["serde::de::Visitor","std::marker::Sized"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_enum":{"V":["value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = "sample"; // None+&str
let mut p2 = & ["a"].as_mut_slice(); // None+[&'static str]
let mut p3 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_enum(&p1, p2, p3);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_enum(p0, &p1, p2, p3);
+<&'a number::Number>::deserialize_enum(p0, &p1, p2, p3);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_identifier
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_identifier":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_identifier":{"V":["value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor","value::de::KeyClassifier","<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_identifier(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_identifier(p0, p1);
+<&'a number::Number>::deserialize_identifier(p0, p1);
-----------------
/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/serde_core-1.0.228/src/macros.rs <&'a number::Number as serde::Deserializer<'de>>::deserialize_ignored_any
'de,'a
deps:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["std::marker::Sized","serde::de::Visitor"]}}
candidates:{"<&'a number::Number as serde::Deserializer<'de>>::deserialize_ignored_any":{"V":["<number::Number as serde::Deserialize<'de>>::deserialize::NumberVisitor","<map::Map<std::string::String, value::Value> as serde::Deserialize<'de>>::deserialize::Visitor","value::de::KeyClassifier","value::de::<impl serde::Deserialize<'de> for value::Value>::deserialize::ValueVisitor"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
let mut p1 = MaybeUninit::uninit().assume_init(); // V
+p0.deserialize_ignored_any(p1);
+<&'a number::Number as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+crate::<&'a number::Number as serde::Deserializer<'de>>::deserialize_ignored_any(p0, p1);
+<&'a number::Number>::deserialize_ignored_any(p0, p1);
-----------------
src/number.rs <number::Number as std::convert::From<de::ParserNumber>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // de::ParserNumber
+<number::Number as std::convert::From<de::ParserNumber>>::from(p0);
+crate::<number::Number as std::convert::From<de::ParserNumber>>::from(p0);
+<number::Number>::from(p0);
-----------------
src/number.rs <number::Number as std::convert::From<u8>>::from
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<number::Number as std::convert::From<u8>>::from(p0);
+crate::<number::Number as std::convert::From<u8>>::from(p0);
+<number::Number>::from(p0);
-----------------
src/number.rs <number::Number as std::convert::From<u16>>::from
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
+<number::Number as std::convert::From<u16>>::from(p0);
+crate::<number::Number as std::convert::From<u16>>::from(p0);
+<number::Number>::from(p0);
-----------------
src/number.rs <number::Number as std::convert::From<u32>>::from
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
+<number::Number as std::convert::From<u32>>::from(p0);
+crate::<number::Number as std::convert::From<u32>>::from(p0);
+<number::Number>::from(p0);
-----------------
src/number.rs <number::Number as std::convert::From<u64>>::from
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+<number::Number as std::convert::From<u64>>::from(p0);
+crate::<number::Number as std::convert::From<u64>>::from(p0);
+<number::Number>::from(p0);
-----------------
src/number.rs <number::Number as std::convert::From<usize>>::from
deps:{}
candidates:{}
let mut p0 = 0usize; // None+usize
+<number::Number as std::convert::From<usize>>::from(p0);
+crate::<number::Number as std::convert::From<usize>>::from(p0);
+<number::Number>::from(p0);
-----------------
src/number.rs <number::Number as std::convert::From<i8>>::from
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
+<number::Number as std::convert::From<i8>>::from(p0);
+crate::<number::Number as std::convert::From<i8>>::from(p0);
+<number::Number>::from(p0);
-----------------
src/number.rs <number::Number as std::convert::From<i16>>::from
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
+<number::Number as std::convert::From<i16>>::from(p0);
+crate::<number::Number as std::convert::From<i16>>::from(p0);
+<number::Number>::from(p0);
-----------------
src/number.rs <number::Number as std::convert::From<i32>>::from
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+<number::Number as std::convert::From<i32>>::from(p0);
+crate::<number::Number as std::convert::From<i32>>::from(p0);
+<number::Number>::from(p0);
-----------------
src/number.rs <number::Number as std::convert::From<i64>>::from
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+<number::Number as std::convert::From<i64>>::from(p0);
+crate::<number::Number as std::convert::From<i64>>::from(p0);
+<number::Number>::from(p0);
-----------------
src/number.rs <number::Number as std::convert::From<isize>>::from
deps:{}
candidates:{}
let mut p0 = 0isize; // None+isize
+<number::Number as std::convert::From<isize>>::from(p0);
+crate::<number::Number as std::convert::From<isize>>::from(p0);
+<number::Number>::from(p0);
-----------------
src/number.rs number::Number::unexpected
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // number::Number
+p0.unexpected();
+number::Number::unexpected(p0);
+crate::number::Number::unexpected(p0);
+<number::Number>::unexpected(p0);
-----------------
src/read.rs <read::Reference<'b, 'c, T> as std::ops::Deref>::deref
'b,'c
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // read::Reference<'b, 'c, T>
+p0.deref();
+<read::Reference<'b, 'c, T> as std::ops::Deref>::deref(p0);
+crate::<read::Reference<'b, 'c, T> as std::ops::Deref>::deref(p0);
+<read::Reference<'b, 'c, T>>::deref(p0);
-----------------
src/read.rs read::IoRead::<R>::new
deps:{"read::IoRead::<R>::new":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"read::IoRead::<R>::new":{"R":["std::net::TcpStream","&std::fs::File","&std::net::TcpStream","std::process::ChildStderr","std::fs::File","std::os::unix::net::UnixStream","std::io::Empty","std::io::Repeat","std::io::Chain<T, U>","std::io::StdinLock<'_>","std::io::Take<T>","std::process::ChildStdout","&'a std::sys::unix::fd::FileDesc","std::io::impls::<impl std::io::Read for &mut R>","std::io::stdio::StdinRaw","std::sys::unix::stdio::Stdin","std::io::Cursor<T>","std::io::Stdin","std::collections::VecDeque<u8, A>","std::boxed::Box<R>","std::io::BufReader<R>","&'a std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // R
+read::IoRead::<R>::new(p0);
+crate::read::IoRead::<R>::new(p0);
+<read::IoRead<R>>::new(p0);
-----------------
src/read.rs read::IoRead::<R>::parse_str_bytes
's
deps:{"read::IoRead::<R>::parse_str_bytes":{"F":["std::marker::Sized","std::ops::FnOnce"],"R":["std::marker::Sized","std::io::Read"],"T":["std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"read::IoRead::<R>::parse_str_bytes":{"F":["core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","std::panic::AssertUnwindSafe<F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::slice::ascii::EscapeByte","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::LinesAnyMap","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeDefault","core::str::CharEscapeDebugContinue","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::IsNotEmpty","core::str::CharEscapeUnicode","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>","std::boxed::Box<F, A>"],"R":["std::boxed::Box<R>","std::io::BufReader<R>","std::collections::VecDeque<u8, A>","std::sys::unix::stdio::Stdin","&'a std::sys::unix::fd::FileDesc","std::io::Stdin","std::process::ChildStdout","&std::fs::File","std::io::Take<T>","std::io::stdio::StdinRaw","std::io::Empty","std::io::StdinLock<'_>","std::os::unix::net::UnixStream","std::net::TcpStream","std::io::Cursor<T>","std::fs::File","std::io::Repeat","&'a std::os::unix::net::UnixStream","&std::net::TcpStream","std::process::ChildStderr","std::io::impls::<impl std::io::Read for &mut R>","std::io::Chain<T, U>"],"T":["RUG_ANY"]},"std::io::impls::<impl std::io::Read for &mut R>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::IoRead<R>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
let mut p2 = true; // None+bool
let mut p3 = MaybeUninit::uninit().assume_init(); // F
+p0.parse_str_bytes(p1, p2, p3);
+read::IoRead::<R>::parse_str_bytes(p0, p1, p2, p3);
+crate::read::IoRead::<R>::parse_str_bytes(p0, p1, p2, p3);
+<read::IoRead<R>>::parse_str_bytes(p0, p1, p2, p3);
-----------------
src/read.rs <read::IoRead<R> as read::Read<'de>>::next
'de
deps:{"<read::IoRead<R> as read::Read<'de>>::next":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<read::IoRead<R> as read::Read<'de>>::next":{"R":["std::io::Cursor<T>","std::boxed::Box<R>","std::io::impls::<impl std::io::Read for &mut R>","std::net::TcpStream","std::io::stdio::StdinRaw","std::process::ChildStderr","std::io::Repeat","std::collections::VecDeque<u8, A>","&std::fs::File","&'a std::sys::unix::fd::FileDesc","&'a std::os::unix::net::UnixStream","std::io::Stdin","std::process::ChildStdout","std::io::BufReader<R>","std::io::Take<T>","std::os::unix::net::UnixStream","std::fs::File","std::io::Chain<T, U>","std::io::StdinLock<'_>","std::sys::unix::stdio::Stdin","std::io::Empty","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::IoRead<R>
+p0.next();
+<read::IoRead<R> as read::Read<'de>>::next(p0);
+crate::<read::IoRead<R> as read::Read<'de>>::next(p0);
+<read::IoRead<R>>::next(p0);
-----------------
src/read.rs <read::IoRead<R> as read::Read<'de>>::peek
'de
deps:{"<read::IoRead<R> as read::Read<'de>>::peek":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<read::IoRead<R> as read::Read<'de>>::peek":{"R":["&'a std::os::unix::net::UnixStream","std::process::ChildStdout","std::io::StdinLock<'_>","std::io::Chain<T, U>","std::boxed::Box<R>","std::io::stdio::StdinRaw","&std::net::TcpStream","std::io::Empty","&'a std::sys::unix::fd::FileDesc","&std::fs::File","std::io::BufReader<R>","std::io::impls::<impl std::io::Read for &mut R>","std::fs::File","std::os::unix::net::UnixStream","std::io::Cursor<T>","std::io::Repeat","std::net::TcpStream","std::collections::VecDeque<u8, A>","std::io::Take<T>","std::process::ChildStderr","std::sys::unix::stdio::Stdin","std::io::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::IoRead<R>
+p0.peek();
+<read::IoRead<R> as read::Read<'de>>::peek(p0);
+crate::<read::IoRead<R> as read::Read<'de>>::peek(p0);
+<read::IoRead<R>>::peek(p0);
-----------------
src/read.rs <read::IoRead<R> as read::Read<'de>>::discard
'de
deps:{"<read::IoRead<R> as read::Read<'de>>::discard":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<read::IoRead<R> as read::Read<'de>>::discard":{"R":["std::io::impls::<impl std::io::Read for &mut R>","std::collections::VecDeque<u8, A>","std::process::ChildStdout","std::io::Stdin","std::sys::unix::stdio::Stdin","std::io::Cursor<T>","std::os::unix::net::UnixStream","std::fs::File","std::io::StdinLock<'_>","&std::fs::File","std::io::Take<T>","std::process::ChildStderr","std::io::stdio::StdinRaw","&std::net::TcpStream","&'a std::os::unix::net::UnixStream","std::io::Repeat","std::io::Empty","std::net::TcpStream","std::boxed::Box<R>","std::io::Chain<T, U>","&'a std::sys::unix::fd::FileDesc","std::io::BufReader<R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::IoRead<R>
+p0.discard();
+<read::IoRead<R> as read::Read<'de>>::discard(p0);
+crate::<read::IoRead<R> as read::Read<'de>>::discard(p0);
+<read::IoRead<R>>::discard(p0);
-----------------
src/read.rs <read::IoRead<R> as read::Read<'de>>::position
'de
deps:{"<read::IoRead<R> as read::Read<'de>>::position":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<read::IoRead<R> as read::Read<'de>>::position":{"R":["std::net::TcpStream","std::io::Chain<T, U>","std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream","std::io::stdio::StdinRaw","std::io::Take<T>","std::process::ChildStdout","std::io::Cursor<T>","&'a std::sys::unix::fd::FileDesc","std::os::unix::net::UnixStream","&'a std::os::unix::net::UnixStream","std::io::BufReader<R>","std::io::Stdin","std::boxed::Box<R>","std::io::Repeat","&std::fs::File","std::collections::VecDeque<u8, A>","std::sys::unix::stdio::Stdin","std::io::StdinLock<'_>","std::io::Empty","std::process::ChildStderr"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // read::IoRead<R>
+p0.position();
+<read::IoRead<R> as read::Read<'de>>::position(p0);
+crate::<read::IoRead<R> as read::Read<'de>>::position(p0);
+<read::IoRead<R>>::position(p0);
-----------------
src/read.rs <read::IoRead<R> as read::Read<'de>>::peek_position
'de
deps:{"<read::IoRead<R> as read::Read<'de>>::peek_position":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<read::IoRead<R> as read::Read<'de>>::peek_position":{"R":["std::process::ChildStdout","&std::fs::File","&std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","std::io::Empty","std::process::ChildStderr","std::io::Take<T>","std::os::unix::net::UnixStream","std::io::BufReader<R>","std::io::StdinLock<'_>","std::net::TcpStream","std::io::Cursor<T>","std::io::Chain<T, U>","std::fs::File","std::io::Stdin","std::boxed::Box<R>","&'a std::sys::unix::fd::FileDesc","std::io::Repeat"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // read::IoRead<R>
+p0.peek_position();
+<read::IoRead<R> as read::Read<'de>>::peek_position(p0);
+crate::<read::IoRead<R> as read::Read<'de>>::peek_position(p0);
+<read::IoRead<R>>::peek_position(p0);
-----------------
src/read.rs <read::IoRead<R> as read::Read<'de>>::byte_offset
'de
deps:{"<read::IoRead<R> as read::Read<'de>>::byte_offset":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<read::IoRead<R> as read::Read<'de>>::byte_offset":{"R":["std::io::Repeat","&'a std::os::unix::net::UnixStream","std::fs::File","std::io::Stdin","std::process::ChildStderr","std::io::BufReader<R>","std::io::impls::<impl std::io::Read for &mut R>","std::sys::unix::stdio::Stdin","&std::fs::File","std::boxed::Box<R>","std::io::Cursor<T>","std::io::StdinLock<'_>","std::collections::VecDeque<u8, A>","&std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::io::stdio::StdinRaw","std::process::ChildStdout","std::io::Chain<T, U>","std::io::Take<T>","std::io::Empty","std::net::TcpStream","std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // read::IoRead<R>
+p0.byte_offset();
+<read::IoRead<R> as read::Read<'de>>::byte_offset(p0);
+crate::<read::IoRead<R> as read::Read<'de>>::byte_offset(p0);
+<read::IoRead<R>>::byte_offset(p0);
-----------------
src/read.rs <read::IoRead<R> as read::Read<'de>>::parse_str
'de
deps:{"<read::IoRead<R> as read::Read<'de>>::parse_str":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<read::IoRead<R> as read::Read<'de>>::parse_str":{"R":["std::sys::unix::stdio::Stdin","std::io::Repeat","&std::fs::File","&'a std::sys::unix::fd::FileDesc","std::io::impls::<impl std::io::Read for &mut R>","std::io::Empty","std::os::unix::net::UnixStream","std::io::Cursor<T>","std::fs::File","&'a std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::process::ChildStderr","std::boxed::Box<R>","&std::net::TcpStream","std::io::Chain<T, U>","std::net::TcpStream","std::io::stdio::StdinRaw","std::io::Take<T>","std::io::BufReader<R>","std::process::ChildStdout","std::io::Stdin","std::io::StdinLock<'_>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::IoRead<R>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.parse_str(p1);
+<read::IoRead<R> as read::Read<'de>>::parse_str(p0, p1);
+crate::<read::IoRead<R> as read::Read<'de>>::parse_str(p0, p1);
+<read::IoRead<R>>::parse_str(p0, p1);
-----------------
src/read.rs <read::IoRead<R> as read::Read<'de>>::parse_str_raw
'de
deps:{"<read::IoRead<R> as read::Read<'de>>::parse_str_raw":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<read::IoRead<R> as read::Read<'de>>::parse_str_raw":{"R":["std::boxed::Box<R>","std::io::Stdin","&std::net::TcpStream","std::io::StdinLock<'_>","std::io::impls::<impl std::io::Read for &mut R>","&'a std::sys::unix::fd::FileDesc","std::process::ChildStderr","std::collections::VecDeque<u8, A>","std::io::Take<T>","std::io::BufReader<R>","std::sys::unix::stdio::Stdin","std::io::Empty","std::io::Chain<T, U>","std::fs::File","std::net::TcpStream","std::io::stdio::StdinRaw","std::io::Repeat","std::io::Cursor<T>","std::os::unix::net::UnixStream","std::process::ChildStdout","&std::fs::File","&'a std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::IoRead<R>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.parse_str_raw(p1);
+<read::IoRead<R> as read::Read<'de>>::parse_str_raw(p0, p1);
+crate::<read::IoRead<R> as read::Read<'de>>::parse_str_raw(p0, p1);
+<read::IoRead<R>>::parse_str_raw(p0, p1);
-----------------
src/read.rs <read::IoRead<R> as read::Read<'de>>::ignore_str
'de
deps:{"<read::IoRead<R> as read::Read<'de>>::ignore_str":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<read::IoRead<R> as read::Read<'de>>::ignore_str":{"R":["std::io::Chain<T, U>","std::net::TcpStream","std::io::BufReader<R>","std::io::StdinLock<'_>","&std::fs::File","std::os::unix::net::UnixStream","std::process::ChildStderr","std::io::Stdin","std::io::impls::<impl std::io::Read for &mut R>","std::io::Cursor<T>","std::io::Empty","std::io::stdio::StdinRaw","std::sys::unix::stdio::Stdin","std::io::Take<T>","&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","&std::net::TcpStream","std::fs::File","std::boxed::Box<R>","std::process::ChildStdout","std::io::Repeat","std::collections::VecDeque<u8, A>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::IoRead<R>
+p0.ignore_str();
+<read::IoRead<R> as read::Read<'de>>::ignore_str(p0);
+crate::<read::IoRead<R> as read::Read<'de>>::ignore_str(p0);
+<read::IoRead<R>>::ignore_str(p0);
-----------------
src/read.rs <read::IoRead<R> as read::Read<'de>>::decode_hex_escape
'de
deps:{"<read::IoRead<R> as read::Read<'de>>::decode_hex_escape":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<read::IoRead<R> as read::Read<'de>>::decode_hex_escape":{"R":["std::io::Empty","std::io::BufReader<R>","std::net::TcpStream","std::process::ChildStderr","std::sys::unix::stdio::Stdin","std::io::Take<T>","std::boxed::Box<R>","&'a std::sys::unix::fd::FileDesc","std::process::ChildStdout","&'a std::os::unix::net::UnixStream","&std::fs::File","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream","std::io::stdio::StdinRaw","std::collections::VecDeque<u8, A>","std::io::Cursor<T>","std::os::unix::net::UnixStream","std::io::StdinLock<'_>","std::io::Chain<T, U>","std::fs::File","std::io::Repeat","std::io::Stdin"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::IoRead<R>
+p0.decode_hex_escape();
+<read::IoRead<R> as read::Read<'de>>::decode_hex_escape(p0);
+crate::<read::IoRead<R> as read::Read<'de>>::decode_hex_escape(p0);
+<read::IoRead<R>>::decode_hex_escape(p0);
-----------------
src/read.rs <read::IoRead<R> as read::Read<'de>>::set_failed
'de
deps:{"<read::IoRead<R> as read::Read<'de>>::set_failed":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<read::IoRead<R> as read::Read<'de>>::set_failed":{"R":["std::io::Repeat","&std::net::TcpStream","std::os::unix::net::UnixStream","std::io::Stdin","std::io::Cursor<T>","std::io::Empty","std::sys::unix::stdio::Stdin","std::net::TcpStream","std::io::Take<T>","std::collections::VecDeque<u8, A>","std::io::stdio::StdinRaw","std::process::ChildStderr","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStdout","std::io::Chain<T, U>","&'a std::os::unix::net::UnixStream","std::boxed::Box<R>","std::io::BufReader<R>","&std::fs::File","std::fs::File","&'a std::sys::unix::fd::FileDesc","std::io::StdinLock<'_>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::IoRead<R>
let mut p1 = &mut true; // None+bool
+p0.set_failed(p1);
+<read::IoRead<R> as read::Read<'de>>::set_failed(p0, p1);
+crate::<read::IoRead<R> as read::Read<'de>>::set_failed(p0, p1);
+<read::IoRead<R>>::set_failed(p0, p1);
-----------------
src/read.rs read::SliceRead::<'a>::new
'a
deps:{}
candidates:{}
let mut p0 = [0u8,0,0].as_mut_slice(); // None+&[u8]
+read::SliceRead::<'a>::new(p0);
+crate::read::SliceRead::<'a>::new(p0);
+<read::SliceRead<'a>>::new(p0);
-----------------
src/read.rs read::SliceRead::<'a>::position_of_index
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
let mut p1 = 0usize; // None+usize
+p0.position_of_index(p1);
+read::SliceRead::<'a>::position_of_index(p0, p1);
+crate::read::SliceRead::<'a>::position_of_index(p0, p1);
+<read::SliceRead<'a>>::position_of_index(p0, p1);
-----------------
src/read.rs read::SliceRead::<'a>::parse_str_bytes
'a,'s
deps:{"read::SliceRead::<'a>::parse_str_bytes":{"F":["std::marker::Sized","std::ops::FnOnce"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"read::SliceRead::<'a>::parse_str_bytes":{"F":["core::str::CharEscapeUnicode","core::str::IsNotEmpty","core::str::LinesAnyMap","core::slice::ascii::EscapeByte","std::boxed::Box<F, A>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::BytesIsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::str::IsWhitespace","core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::CharEscapeDefault","std::panic::AssertUnwindSafe<F>","core::str::IsAsciiWhitespace","core::str::CharEscapeDebugContinue","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
let mut p2 = true; // None+bool
let mut p3 = MaybeUninit::uninit().assume_init(); // F
+p0.parse_str_bytes(p1, p2, p3);
+read::SliceRead::<'a>::parse_str_bytes(p0, p1, p2, p3);
+crate::read::SliceRead::<'a>::parse_str_bytes(p0, p1, p2, p3);
+<read::SliceRead<'a>>::parse_str_bytes(p0, p1, p2, p3);
-----------------
src/read.rs <read::SliceRead<'a> as read::Read<'a>>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
+p0.next();
+<read::SliceRead<'a> as read::Read<'a>>::next(p0);
+crate::<read::SliceRead<'a> as read::Read<'a>>::next(p0);
+<read::SliceRead<'a>>::next(p0);
-----------------
src/read.rs <read::SliceRead<'a> as read::Read<'a>>::peek
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
+p0.peek();
+<read::SliceRead<'a> as read::Read<'a>>::peek(p0);
+crate::<read::SliceRead<'a> as read::Read<'a>>::peek(p0);
+<read::SliceRead<'a>>::peek(p0);
-----------------
src/read.rs <read::SliceRead<'a> as read::Read<'a>>::discard
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
+p0.discard();
+<read::SliceRead<'a> as read::Read<'a>>::discard(p0);
+crate::<read::SliceRead<'a> as read::Read<'a>>::discard(p0);
+<read::SliceRead<'a>>::discard(p0);
-----------------
src/read.rs <read::SliceRead<'a> as read::Read<'a>>::position
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
+p0.position();
+<read::SliceRead<'a> as read::Read<'a>>::position(p0);
+crate::<read::SliceRead<'a> as read::Read<'a>>::position(p0);
+<read::SliceRead<'a>>::position(p0);
-----------------
src/read.rs <read::SliceRead<'a> as read::Read<'a>>::peek_position
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
+p0.peek_position();
+<read::SliceRead<'a> as read::Read<'a>>::peek_position(p0);
+crate::<read::SliceRead<'a> as read::Read<'a>>::peek_position(p0);
+<read::SliceRead<'a>>::peek_position(p0);
-----------------
src/read.rs <read::SliceRead<'a> as read::Read<'a>>::byte_offset
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
+p0.byte_offset();
+<read::SliceRead<'a> as read::Read<'a>>::byte_offset(p0);
+crate::<read::SliceRead<'a> as read::Read<'a>>::byte_offset(p0);
+<read::SliceRead<'a>>::byte_offset(p0);
-----------------
src/read.rs <read::SliceRead<'a> as read::Read<'a>>::parse_str
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.parse_str(p1);
+<read::SliceRead<'a> as read::Read<'a>>::parse_str(p0, p1);
+crate::<read::SliceRead<'a> as read::Read<'a>>::parse_str(p0, p1);
+<read::SliceRead<'a>>::parse_str(p0, p1);
-----------------
src/read.rs <read::SliceRead<'a> as read::Read<'a>>::parse_str_raw
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.parse_str_raw(p1);
+<read::SliceRead<'a> as read::Read<'a>>::parse_str_raw(p0, p1);
+crate::<read::SliceRead<'a> as read::Read<'a>>::parse_str_raw(p0, p1);
+<read::SliceRead<'a>>::parse_str_raw(p0, p1);
-----------------
src/read.rs <read::SliceRead<'a> as read::Read<'a>>::ignore_str
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
+p0.ignore_str();
+<read::SliceRead<'a> as read::Read<'a>>::ignore_str(p0);
+crate::<read::SliceRead<'a> as read::Read<'a>>::ignore_str(p0);
+<read::SliceRead<'a>>::ignore_str(p0);
-----------------
src/read.rs <read::SliceRead<'a> as read::Read<'a>>::decode_hex_escape
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
+p0.decode_hex_escape();
+<read::SliceRead<'a> as read::Read<'a>>::decode_hex_escape(p0);
+crate::<read::SliceRead<'a> as read::Read<'a>>::decode_hex_escape(p0);
+<read::SliceRead<'a>>::decode_hex_escape(p0);
-----------------
src/read.rs <read::SliceRead<'a> as read::Read<'a>>::set_failed
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::SliceRead<'a>
let mut p1 = &mut true; // None+bool
+p0.set_failed(p1);
+<read::SliceRead<'a> as read::Read<'a>>::set_failed(p0, p1);
+crate::<read::SliceRead<'a> as read::Read<'a>>::set_failed(p0, p1);
+<read::SliceRead<'a>>::set_failed(p0, p1);
-----------------
src/read.rs read::StrRead::<'a>::new
'a
deps:{}
candidates:{}
let mut p0 = "sample"; // None+&str
+read::StrRead::<'a>::new(&p0);
+crate::read::StrRead::<'a>::new(&p0);
+<read::StrRead<'a>>::new(&p0);
-----------------
src/read.rs <read::StrRead<'a> as read::Read<'a>>::next
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::StrRead<'a>
+p0.next();
+<read::StrRead<'a> as read::Read<'a>>::next(p0);
+crate::<read::StrRead<'a> as read::Read<'a>>::next(p0);
+<read::StrRead<'a>>::next(p0);
-----------------
src/read.rs <read::StrRead<'a> as read::Read<'a>>::peek
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::StrRead<'a>
+p0.peek();
+<read::StrRead<'a> as read::Read<'a>>::peek(p0);
+crate::<read::StrRead<'a> as read::Read<'a>>::peek(p0);
+<read::StrRead<'a>>::peek(p0);
-----------------
src/read.rs <read::StrRead<'a> as read::Read<'a>>::discard
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::StrRead<'a>
+p0.discard();
+<read::StrRead<'a> as read::Read<'a>>::discard(p0);
+crate::<read::StrRead<'a> as read::Read<'a>>::discard(p0);
+<read::StrRead<'a>>::discard(p0);
-----------------
src/read.rs <read::StrRead<'a> as read::Read<'a>>::position
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // read::StrRead<'a>
+p0.position();
+<read::StrRead<'a> as read::Read<'a>>::position(p0);
+crate::<read::StrRead<'a> as read::Read<'a>>::position(p0);
+<read::StrRead<'a>>::position(p0);
-----------------
src/read.rs <read::StrRead<'a> as read::Read<'a>>::peek_position
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // read::StrRead<'a>
+p0.peek_position();
+<read::StrRead<'a> as read::Read<'a>>::peek_position(p0);
+crate::<read::StrRead<'a> as read::Read<'a>>::peek_position(p0);
+<read::StrRead<'a>>::peek_position(p0);
-----------------
src/read.rs <read::StrRead<'a> as read::Read<'a>>::byte_offset
'a
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // read::StrRead<'a>
+p0.byte_offset();
+<read::StrRead<'a> as read::Read<'a>>::byte_offset(p0);
+crate::<read::StrRead<'a> as read::Read<'a>>::byte_offset(p0);
+<read::StrRead<'a>>::byte_offset(p0);
-----------------
src/read.rs <read::StrRead<'a> as read::Read<'a>>::parse_str
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::StrRead<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.parse_str(p1);
+<read::StrRead<'a> as read::Read<'a>>::parse_str(p0, p1);
+crate::<read::StrRead<'a> as read::Read<'a>>::parse_str(p0, p1);
+<read::StrRead<'a>>::parse_str(p0, p1);
-----------------
src/read.rs <read::StrRead<'a> as read::Read<'a>>::parse_str_raw
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::StrRead<'a>
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.parse_str_raw(p1);
+<read::StrRead<'a> as read::Read<'a>>::parse_str_raw(p0, p1);
+crate::<read::StrRead<'a> as read::Read<'a>>::parse_str_raw(p0, p1);
+<read::StrRead<'a>>::parse_str_raw(p0, p1);
-----------------
src/read.rs <read::StrRead<'a> as read::Read<'a>>::ignore_str
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::StrRead<'a>
+p0.ignore_str();
+<read::StrRead<'a> as read::Read<'a>>::ignore_str(p0);
+crate::<read::StrRead<'a> as read::Read<'a>>::ignore_str(p0);
+<read::StrRead<'a>>::ignore_str(p0);
-----------------
src/read.rs <read::StrRead<'a> as read::Read<'a>>::decode_hex_escape
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::StrRead<'a>
+p0.decode_hex_escape();
+<read::StrRead<'a> as read::Read<'a>>::decode_hex_escape(p0);
+crate::<read::StrRead<'a> as read::Read<'a>>::decode_hex_escape(p0);
+<read::StrRead<'a>>::decode_hex_escape(p0);
-----------------
src/read.rs <read::StrRead<'a> as read::Read<'a>>::set_failed
'a
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // read::StrRead<'a>
let mut p1 = &mut true; // None+bool
+p0.set_failed(p1);
+<read::StrRead<'a> as read::Read<'a>>::set_failed(p0, p1);
+crate::<read::StrRead<'a> as read::Read<'a>>::set_failed(p0, p1);
+<read::StrRead<'a>>::set_failed(p0, p1);
-----------------
src/read.rs <&'a mut R as read::Read<'de>>::next
'a,'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::next":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::next":{"R":["read::StrRead","<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead"]},"read::IoRead":{"R":["std::net::TcpStream","std::fs::File","std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","std::io::Take<T>","&'a std::sys::unix::fd::FileDesc","std::io::Stdin","&'a std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::io::StdinLock<'_>","std::sys::unix::stdio::Stdin","std::io::BufReader<R>","&std::net::TcpStream","std::io::impls::<impl std::io::Read for &mut R>","std::process::ChildStderr","std::io::Chain<T, U>","std::boxed::Box<R>","std::io::Repeat","&std::fs::File","std::process::ChildStdout","std::io::Cursor<T>","std::io::Empty"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // R
+p0.next();
+<&'a mut R as read::Read<'de>>::next(p0);
+crate::<&'a mut R as read::Read<'de>>::next(p0);
+<&'a mut R>::next(p0);
-----------------
src/read.rs <&'a mut R as read::Read<'de>>::peek
'a,'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::peek":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::peek":{"R":["read::SliceRead","read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>"]},"read::IoRead":{"R":["std::collections::VecDeque<u8, A>","&std::net::TcpStream","std::io::Cursor<T>","std::process::ChildStdout","std::io::BufReader<R>","std::io::impls::<impl std::io::Read for &mut R>","&'a std::os::unix::net::UnixStream","std::io::StdinLock<'_>","std::io::Take<T>","&'a std::sys::unix::fd::FileDesc","&std::fs::File","std::process::ChildStderr","std::io::Repeat","std::fs::File","std::io::Empty","std::sys::unix::stdio::Stdin","std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","std::net::TcpStream","std::boxed::Box<R>","std::io::Stdin","std::io::Chain<T, U>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // R
+p0.peek();
+<&'a mut R as read::Read<'de>>::peek(p0);
+crate::<&'a mut R as read::Read<'de>>::peek(p0);
+<&'a mut R>::peek(p0);
-----------------
src/read.rs <&'a mut R as read::Read<'de>>::discard
'a,'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::discard":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::discard":{"R":["read::IoRead","read::StrRead","<&'a mut R as read::Read<'de>>","read::SliceRead"]},"read::IoRead":{"R":["std::io::Repeat","std::os::unix::net::UnixStream","std::io::Cursor<T>","&std::fs::File","std::io::Chain<T, U>","std::sys::unix::stdio::Stdin","std::io::Stdin","std::io::Empty","std::io::impls::<impl std::io::Read for &mut R>","std::io::BufReader<R>","std::collections::VecDeque<u8, A>","std::process::ChildStdout","std::io::stdio::StdinRaw","&std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::net::TcpStream","&'a std::os::unix::net::UnixStream","std::process::ChildStderr","std::fs::File","std::io::StdinLock<'_>","std::boxed::Box<R>","std::io::Take<T>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // R
+p0.discard();
+<&'a mut R as read::Read<'de>>::discard(p0);
+crate::<&'a mut R as read::Read<'de>>::discard(p0);
+<&'a mut R>::discard(p0);
-----------------
src/read.rs <&'a mut R as read::Read<'de>>::position
'a,'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::position":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::position":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::IoRead","read::StrRead"]},"read::IoRead":{"R":["&std::net::TcpStream","std::sys::unix::stdio::Stdin","std::os::unix::net::UnixStream","std::process::ChildStdout","&'a std::sys::unix::fd::FileDesc","std::io::StdinLock<'_>","std::collections::VecDeque<u8, A>","std::io::stdio::StdinRaw","std::net::TcpStream","std::io::Cursor<T>","&'a std::os::unix::net::UnixStream","&std::fs::File","std::io::Stdin","std::io::impls::<impl std::io::Read for &mut R>","std::io::Take<T>","std::boxed::Box<R>","std::io::Empty","std::io::BufReader<R>","std::fs::File","std::io::Repeat","std::process::ChildStderr","std::io::Chain<T, U>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // R
+p0.position();
+<&'a mut R as read::Read<'de>>::position(p0);
+crate::<&'a mut R as read::Read<'de>>::position(p0);
+<&'a mut R>::position(p0);
-----------------
src/read.rs <&'a mut R as read::Read<'de>>::peek_position
'a,'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::peek_position":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::peek_position":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::IoRead","read::StrRead"]},"read::IoRead":{"R":["std::io::Repeat","std::io::Empty","std::process::ChildStderr","std::io::StdinLock<'_>","std::collections::VecDeque<u8, A>","std::net::TcpStream","std::io::BufReader<R>","&std::fs::File","std::io::Take<T>","std::sys::unix::stdio::Stdin","std::process::ChildStdout","&'a std::os::unix::net::UnixStream","std::io::Cursor<T>","std::io::stdio::StdinRaw","std::os::unix::net::UnixStream","std::boxed::Box<R>","&'a std::sys::unix::fd::FileDesc","std::io::Stdin","std::fs::File","std::io::Chain<T, U>","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // R
+p0.peek_position();
+<&'a mut R as read::Read<'de>>::peek_position(p0);
+crate::<&'a mut R as read::Read<'de>>::peek_position(p0);
+<&'a mut R>::peek_position(p0);
-----------------
src/read.rs <&'a mut R as read::Read<'de>>::byte_offset
'a,'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::byte_offset":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::byte_offset":{"R":["read::StrRead","<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead"]},"read::IoRead":{"R":["std::io::impls::<impl std::io::Read for &mut R>","std::io::Cursor<T>","std::fs::File","std::io::stdio::StdinRaw","&std::net::TcpStream","std::io::Chain<T, U>","std::io::Take<T>","std::io::StdinLock<'_>","std::io::Repeat","std::io::Empty","std::io::BufReader<R>","std::sys::unix::stdio::Stdin","&std::fs::File","std::process::ChildStderr","std::boxed::Box<R>","std::collections::VecDeque<u8, A>","std::os::unix::net::UnixStream","std::io::Stdin","std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::process::ChildStdout","&'a std::os::unix::net::UnixStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = & & MaybeUninit::uninit().assume_init(); // R
+p0.byte_offset();
+<&'a mut R as read::Read<'de>>::byte_offset(p0);
+crate::<&'a mut R as read::Read<'de>>::byte_offset(p0);
+<&'a mut R>::byte_offset(p0);
-----------------
src/read.rs <&'a mut R as read::Read<'de>>::parse_str
'a,'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::parse_str":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::parse_str":{"R":["<&'a mut R as read::Read<'de>>","read::IoRead","read::SliceRead","read::StrRead"]},"read::IoRead":{"R":["std::io::Take<T>","std::io::Empty","std::io::Stdin","std::collections::VecDeque<u8, A>","std::io::impls::<impl std::io::Read for &mut R>","std::io::Cursor<T>","&'a std::sys::unix::fd::FileDesc","std::process::ChildStdout","std::sys::unix::stdio::Stdin","std::io::Repeat","std::io::StdinLock<'_>","&std::net::TcpStream","&std::fs::File","std::io::Chain<T, U>","std::process::ChildStderr","std::io::BufReader<R>","std::net::TcpStream","std::os::unix::net::UnixStream","std::boxed::Box<R>","std::fs::File","&'a std::os::unix::net::UnixStream","std::io::stdio::StdinRaw"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // R
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.parse_str(p1);
+<&'a mut R as read::Read<'de>>::parse_str(p0, p1);
+crate::<&'a mut R as read::Read<'de>>::parse_str(p0, p1);
+<&'a mut R>::parse_str(p0, p1);
-----------------
src/read.rs <&'a mut R as read::Read<'de>>::parse_str_raw
'a,'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::parse_str_raw":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::parse_str_raw":{"R":["read::SliceRead","read::IoRead","<&'a mut R as read::Read<'de>>","read::StrRead"]},"read::IoRead":{"R":["std::sys::unix::stdio::Stdin","std::io::impls::<impl std::io::Read for &mut R>","std::io::Stdin","std::io::Cursor<T>","std::process::ChildStdout","&'a std::sys::unix::fd::FileDesc","&std::fs::File","std::process::ChildStderr","std::io::StdinLock<'_>","std::io::stdio::StdinRaw","std::fs::File","std::boxed::Box<R>","std::io::BufReader<R>","std::io::Take<T>","std::io::Empty","std::io::Chain<T, U>","std::io::Repeat","&'a std::os::unix::net::UnixStream","std::os::unix::net::UnixStream","std::net::TcpStream","std::collections::VecDeque<u8, A>","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // R
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::vec::Vec<u8>
+p0.parse_str_raw(p1);
+<&'a mut R as read::Read<'de>>::parse_str_raw(p0, p1);
+crate::<&'a mut R as read::Read<'de>>::parse_str_raw(p0, p1);
+<&'a mut R>::parse_str_raw(p0, p1);
-----------------
src/read.rs <&'a mut R as read::Read<'de>>::ignore_str
'a,'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::ignore_str":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::ignore_str":{"R":["read::SliceRead","<&'a mut R as read::Read<'de>>","read::IoRead","read::StrRead"]},"read::IoRead":{"R":["std::io::StdinLock<'_>","std::io::Repeat","&'a std::os::unix::net::UnixStream","std::sys::unix::stdio::Stdin","std::io::Chain<T, U>","std::collections::VecDeque<u8, A>","std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::io::Take<T>","std::io::impls::<impl std::io::Read for &mut R>","&std::fs::File","std::process::ChildStdout","&std::net::TcpStream","std::io::Stdin","std::fs::File","std::io::Empty","std::io::Cursor<T>","std::io::BufReader<R>","std::process::ChildStderr","std::os::unix::net::UnixStream","std::boxed::Box<R>","std::io::stdio::StdinRaw"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // R
+p0.ignore_str();
+<&'a mut R as read::Read<'de>>::ignore_str(p0);
+crate::<&'a mut R as read::Read<'de>>::ignore_str(p0);
+<&'a mut R>::ignore_str(p0);
-----------------
src/read.rs <&'a mut R as read::Read<'de>>::decode_hex_escape
'a,'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::decode_hex_escape":{"R":["read::Read","std::marker::Sized"]},"read::IoRead":{"R":["std::marker::Sized","std::io::Read"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::decode_hex_escape":{"R":["<&'a mut R as read::Read<'de>>","read::SliceRead","read::StrRead","read::IoRead"]},"read::IoRead":{"R":["std::os::unix::net::UnixStream","std::process::ChildStderr","std::boxed::Box<R>","&'a std::os::unix::net::UnixStream","std::io::BufReader<R>","&std::net::TcpStream","&std::fs::File","std::io::Empty","std::io::Cursor<T>","std::sys::unix::stdio::Stdin","std::collections::VecDeque<u8, A>","std::process::ChildStdout","std::io::Chain<T, U>","std::io::Take<T>","std::io::StdinLock<'_>","std::io::stdio::StdinRaw","std::io::Repeat","std::net::TcpStream","&'a std::sys::unix::fd::FileDesc","std::io::Stdin","std::fs::File","std::io::impls::<impl std::io::Read for &mut R>"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // R
+p0.decode_hex_escape();
+<&'a mut R as read::Read<'de>>::decode_hex_escape(p0);
+crate::<&'a mut R as read::Read<'de>>::decode_hex_escape(p0);
+<&'a mut R>::decode_hex_escape(p0);
-----------------
src/read.rs <&'a mut R as read::Read<'de>>::set_failed
'a,'de
deps:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::set_failed":{"R":["std::marker::Sized","read::Read"]},"read::IoRead":{"R":["std::io::Read","std::marker::Sized"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
candidates:{"<&'a mut R as read::Read<'de>>":{},"<&'a mut R as read::Read<'de>>::set_failed":{"R":["read::IoRead","read::StrRead","read::SliceRead","<&'a mut R as read::Read<'de>>"]},"read::IoRead":{"R":["std::io::Empty","std::net::TcpStream","std::io::Take<T>","std::boxed::Box<R>","std::process::ChildStdout","std::io::stdio::StdinRaw","std::io::Chain<T, U>","std::io::BufReader<R>","&'a std::os::unix::net::UnixStream","&'a std::sys::unix::fd::FileDesc","std::process::ChildStderr","std::sys::unix::stdio::Stdin","&std::fs::File","std::fs::File","std::os::unix::net::UnixStream","std::collections::VecDeque<u8, A>","std::io::StdinLock<'_>","std::io::Cursor<T>","std::io::Repeat","std::io::Stdin","std::io::impls::<impl std::io::Read for &mut R>","&std::net::TcpStream"]},"std::io::impls::<impl std::io::Read for &mut R>":{}}
let mut p0 = &mut  &mut MaybeUninit::uninit().assume_init(); // R
let mut p1 = &mut true; // None+bool
+p0.set_failed(p1);
+<&'a mut R as read::Read<'de>>::set_failed(p0, p1);
+crate::<&'a mut R as read::Read<'de>>::set_failed(p0, p1);
+<&'a mut R>::set_failed(p0, p1);