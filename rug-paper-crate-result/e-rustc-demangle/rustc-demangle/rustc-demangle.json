{"dependencies":{"<Demangle<'a> as core::fmt::Debug>::fmt":["Demangle","core::fmt::Formatter","core::marker::Sized","core::option::Option","core::result::Result"],"<Demangle<'a> as core::fmt::Display>::fmt":["Demangle","core::fmt::Formatter","core::marker::Sized","core::option::Option","core::result::Result"],"<DemangleStyle<'a> as core::fmt::Display>::fmt":["DemangleStyle","core::fmt::Formatter","core::marker::Sized","core::result::Result","legacy::Demangle","v0::Demangle"],"<SizeLimitExhausted as core::clone::Clone>::clone":["SizeLimitExhausted"],"<SizeLimitExhausted as core::fmt::Debug>::fmt":["SizeLimitExhausted","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<SizeLimitedFmtAdapter<F> as core::fmt::Write>::write_str":["SizeLimitedFmtAdapter","core::marker::Sized","core::result::Result"],"<TryDemangleError as core::clone::Clone>::clone":["TryDemangleError"],"<TryDemangleError as core::fmt::Debug>::fmt":["TryDemangleError","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<legacy::Demangle<'a> as core::fmt::Display>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","legacy::Demangle"],"<v0::Demangle<'s> as core::fmt::Display>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","v0::Demangle"],"<v0::Ident<'s> as core::fmt::Display>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","v0::Ident"],"<v0::ParseError as core::cmp::Eq>::assert_receiver_is_total_eq":["v0::ParseError"],"<v0::ParseError as core::cmp::PartialEq>::eq":["v0::ParseError"],"<v0::ParseError as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::result::Result","v0::ParseError"],"Demangle":["Demangle","core::marker::Sized","core::option::Option"],"Demangle::<'a>::as_str":["Demangle","core::marker::Sized","core::option::Option"],"DemangleStyle":["DemangleStyle","legacy::Demangle","v0::Demangle"],"SizeLimitExhausted":["SizeLimitExhausted"],"SizeLimitedFmtAdapter":["SizeLimitedFmtAdapter","core::marker::Sized","core::result::Result"],"TryDemangleError":["TryDemangleError"],"demangle":["Demangle","core::marker::Sized","core::option::Option"],"is_ascii_alphanumeric":[],"is_ascii_punctuation":[],"is_symbol_like":[],"legacy::Demangle":["legacy::Demangle"],"legacy::demangle":["core::marker::Sized","core::result::Result"],"legacy::is_rust_hash":[],"try_demangle":["core::marker::Sized","core::result::Result"],"v0::Demangle":["v0::Demangle"],"v0::HexNibbles":["v0::HexNibbles"],"v0::HexNibbles::<'s>::try_parse_str_chars":["core::marker::Sized","core::option::Option","v0::HexNibbles"],"v0::HexNibbles::<'s>::try_parse_str_chars::{closure#2}::{closure#0}::utf8_len_from_first_byte":["core::marker::Sized","core::result::Result"],"v0::HexNibbles::<'s>::try_parse_uint":["core::marker::Sized","core::option::Option","v0::HexNibbles"],"v0::HexNibbles<'s>::try_parse_str_chars::{closure#2}::{closure#0}::Utf8FirstByteError":["v0::HexNibbles<'s>::try_parse_str_chars::{closure#2}::{closure#0}::Utf8FirstByteError"],"v0::Ident":["v0::Ident"],"v0::Ident::<'s>::punycode_decode":["core::marker::Sized","core::ops::FnMut","core::result::Result","v0::Ident"],"v0::Ident::<'s>::try_small_punycode_decode":["core::marker::Sized","core::ops::FnOnce","core::option::Option","v0::Ident"],"v0::ParseError":["v0::ParseError"],"v0::ParseError::message":["v0::ParseError"],"v0::Parser":["v0::Parser"],"v0::Parser::<'s>::backref":["core::marker::Sized","core::result::Result","v0::Parser"],"v0::Parser::<'s>::digit_10":["core::marker::Sized","core::result::Result","v0::Parser"],"v0::Parser::<'s>::digit_62":["core::marker::Sized","core::result::Result","v0::Parser"],"v0::Parser::<'s>::disambiguator":["core::marker::Sized","core::result::Result","v0::Parser"],"v0::Parser::<'s>::eat":["v0::Parser"],"v0::Parser::<'s>::hex_nibbles":["core::marker::Sized","core::result::Result","v0::Parser"],"v0::Parser::<'s>::ident":["core::marker::Sized","core::result::Result","v0::Parser"],"v0::Parser::<'s>::integer_62":["core::marker::Sized","core::result::Result","v0::Parser"],"v0::Parser::<'s>::namespace":["core::marker::Sized","core::result::Result","v0::Parser"],"v0::Parser::<'s>::next":["core::marker::Sized","core::result::Result","v0::Parser"],"v0::Parser::<'s>::opt_integer_62":["core::marker::Sized","core::result::Result","v0::Parser"],"v0::Parser::<'s>::peek":["core::marker::Sized","core::option::Option","v0::Parser"],"v0::Parser::<'s>::pop_depth":["v0::Parser"],"v0::Parser::<'s>::push_depth":["core::marker::Sized","core::result::Result","v0::Parser"],"v0::Printer":["core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::eat":["core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::in_binder":["core::marker::Sized","core::ops::FnOnce","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::pop_depth":["core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print":["Demangle","core::fmt::Display","core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print_backref":["core::marker::Sized","core::ops::FnOnce","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print_const":["core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print_const_str_literal":["core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print_const_uint":["core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print_dyn_trait":["core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print_generic_arg":["core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print_lifetime_from_index":["core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print_path":["core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print_path_maybe_open_generics":["core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print_quoted_escaped_chars":["core::iter::Iterator","core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print_sep_list":["core::marker::Sized","core::ops::Fn","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::print_type":["core::marker::Sized","core::option::Option","core::result::Result","v0::Printer"],"v0::Printer::<'a, 'b, 's>::skipping_printing":["core::marker::Sized","core::ops::FnOnce","core::option::Option","core::result::Result","v0::Printer"],"v0::basic_type":["core::marker::Sized","core::option::Option"],"v0::demangle":["core::marker::Sized","core::result::Result"]},"glob_path_import":{},"self_to_fn":{"Demangle":["impl<'a> Demangle<'a> {\n    /// Returns the underlying string that's being demangled.\n    pub fn as_str(&self) -> &'a str {\n        self.original\n    }\n}","impl<'a> fmt::Debug for Demangle<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}","impl<'a> fmt::Display for Demangle<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self.style {\n            None => f.write_str(self.original)?,\n            Some(ref d) => {\n                let alternate = f.alternate();\n                let mut size_limited_fmt = SizeLimitedFmtAdapter {\n                    remaining: Ok(MAX_SIZE),\n                    inner: &mut *f,\n                };\n                let fmt_result = if alternate {\n                    write!(size_limited_fmt, \"{:#}\", d)\n                } else {\n                    write!(size_limited_fmt, \"{}\", d)\n                };\n                let size_limit_result = size_limited_fmt.remaining.map(|_| ());\n\n                // Translate a `fmt::Error` generated by `SizeLimitedFmtAdapter`\n                // into an error message, instead of propagating it upwards\n                // (which could cause panicking from inside e.g. `std::io::print`).\n                match (fmt_result, size_limit_result) {\n                    (Err(_), Err(SizeLimitExhausted)) => f.write_str(\"{size limit reached}\")?,\n\n                    _ => {\n                        fmt_result?;\n                        size_limit_result\n                            .expect(\"`fmt::Error` from `SizeLimitedFmtAdapter` was discarded\");\n                    }\n                }\n            }\n        }\n        f.write_str(self.suffix)\n    }\n}"],"DemangleStyle":["impl<'a> fmt::Display for DemangleStyle<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            DemangleStyle::Legacy(ref d) => fmt::Display::fmt(d, f),\n            DemangleStyle::V0(ref d) => fmt::Display::fmt(d, f),\n        }\n    }\n}"],"SizeLimitExhausted":["Clone","Copy","Debug"],"SizeLimitedFmtAdapter":["impl<F: fmt::Write> fmt::Write for SizeLimitedFmtAdapter<F> {\n    fn write_str(&mut self, s: &str) -> fmt::Result {\n        self.remaining = self\n            .remaining\n            .and_then(|r| r.checked_sub(s.len()).ok_or(SizeLimitExhausted));\n\n        match self.remaining {\n            Ok(_) => self.inner.write_str(s),\n            Err(SizeLimitExhausted) => Err(fmt::Error),\n        }\n    }\n}"],"TryDemangleError":["Clone","Debug"],"legacy::Demangle":["impl<'a> fmt::Display for Demangle<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // Alright, let's do this.\n        let mut inner = self.inner;\n        for element in 0..self.elements {\n            let mut rest = inner;\n            while rest.chars().next().unwrap().is_digit(10) {\n                rest = &rest[1..];\n            }\n            let i: usize = inner[..(inner.len() - rest.len())].parse().unwrap();\n            inner = &rest[i..];\n            rest = &rest[..i];\n            // Skip printing the hash if alternate formatting\n            // was requested.\n            if f.alternate() && element + 1 == self.elements && is_rust_hash(&rest) {\n                break;\n            }\n            if element != 0 {\n                f.write_str(\"::\")?;\n            }\n            if rest.starts_with(\"_$\") {\n                rest = &rest[1..];\n            }\n            loop {\n                if rest.starts_with('.') {\n                    if let Some('.') = rest[1..].chars().next() {\n                        f.write_str(\"::\")?;\n                        rest = &rest[2..];\n                    } else {\n                        f.write_str(\".\")?;\n                        rest = &rest[1..];\n                    }\n                } else if rest.starts_with('$') {\n                    let (escape, after_escape) = if let Some(end) = rest[1..].find('$') {\n                        (&rest[1..=end], &rest[end + 2..])\n                    } else {\n                        break;\n                    };\n\n                    // see src/librustc_codegen_utils/symbol_names/legacy.rs for these mappings\n                    let unescaped = match escape {\n                        \"SP\" => \"@\",\n                        \"BP\" => \"*\",\n                        \"RF\" => \"&\",\n                        \"LT\" => \"<\",\n                        \"GT\" => \">\",\n                        \"LP\" => \"(\",\n                        \"RP\" => \")\",\n                        \"C\" => \",\",\n\n                        _ => {\n                            if escape.starts_with('u') {\n                                let digits = &escape[1..];\n                                let all_lower_hex = digits.chars().all(|c| match c {\n                                    '0'..='9' | 'a'..='f' => true,\n                                    _ => false,\n                                });\n                                let c = u32::from_str_radix(digits, 16)\n                                    .ok()\n                                    .and_then(char::from_u32);\n                                if let (true, Some(c)) = (all_lower_hex, c) {\n                                    // FIXME(eddyb) do we need to filter out control codepoints?\n                                    if !c.is_control() {\n                                        c.fmt(f)?;\n                                        rest = after_escape;\n                                        continue;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                    };\n                    f.write_str(unescaped)?;\n                    rest = after_escape;\n                } else if let Some(i) = rest.find(|c| c == '$' || c == '.') {\n                    f.write_str(&rest[..i])?;\n                    rest = &rest[i..];\n                } else {\n                    break;\n                }\n            }\n            f.write_str(rest)?;\n        }\n\n        Ok(())\n    }\n}"],"v0::Demangle":["impl<'s> fmt::Display for Demangle<'s> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let mut printer = Printer {\n            parser: Ok(Parser {\n                sym: self.inner,\n                next: 0,\n                depth: 0,\n            }),\n            out: Some(f),\n            bound_lifetime_depth: 0,\n        };\n        printer.print_path(true)\n    }\n}"],"v0::HexNibbles":["impl<'s> HexNibbles<'s> {\n    /// Decode an integer value (with the \"most significant nibble\" first),\n    /// returning `None` if it can't fit in an `u64`.\n    // FIXME(eddyb) should this \"just\" use `u128` instead?\n    fn try_parse_uint(&self) -> Option<u64> {\n        let nibbles = self.nibbles.trim_start_matches(\"0\");\n\n        if nibbles.len() > 16 {\n            return None;\n        }\n\n        let mut v = 0;\n        for nibble in nibbles.chars() {\n            v = (v << 4) | (nibble.to_digit(16).unwrap() as u64);\n        }\n        Some(v)\n    }\n\n    /// Decode a UTF-8 byte sequence (with each byte using a pair of nibbles)\n    /// into individual `char`s, returning `None` for invalid UTF-8.\n    fn try_parse_str_chars(&self) -> Option<impl Iterator<Item = char> + 's> {\n        if self.nibbles.len() % 2 != 0 {\n            return None;\n        }\n\n        // FIXME(eddyb) use `array_chunks` instead, when that becomes stable.\n        let mut bytes = self\n            .nibbles\n            .as_bytes()\n            .chunks_exact(2)\n            .map(|slice| match slice {\n                [a, b] => [a, b],\n                _ => unreachable!(),\n            })\n            .map(|[&hi, &lo]| {\n                let half = |nibble: u8| (nibble as char).to_digit(16).unwrap() as u8;\n                (half(hi) << 4) | half(lo)\n            });\n\n        let chars = iter::from_fn(move || {\n            // As long as there are any bytes left, there's at least one more\n            // UTF-8-encoded `char` to decode (or the possibility of error).\n            bytes.next().map(|first_byte| -> Result<char, ()> {\n                // FIXME(eddyb) this `enum` and `fn` should be somewhere in `core`.\n                enum Utf8FirstByteError {\n                    ContinuationByte,\n                    TooLong,\n                }\n                fn utf8_len_from_first_byte(byte: u8) -> Result<usize, Utf8FirstByteError> {\n                    match byte {\n                        0x00..=0x7f => Ok(1),\n                        0x80..=0xbf => Err(Utf8FirstByteError::ContinuationByte),\n                        0xc0..=0xdf => Ok(2),\n                        0xe0..=0xef => Ok(3),\n                        0xf0..=0xf7 => Ok(4),\n                        0xf8..=0xff => Err(Utf8FirstByteError::TooLong),\n                    }\n                }\n\n                // Collect the appropriate amount of bytes (up to 4), according\n                // to the UTF-8 length implied by the first byte.\n                let utf8_len = utf8_len_from_first_byte(first_byte).map_err(|_| ())?;\n                let utf8 = &mut [first_byte, 0, 0, 0][..utf8_len];\n                for i in 1..utf8_len {\n                    utf8[i] = bytes.next().ok_or(())?;\n                }\n\n                // Fully validate the UTF-8 sequence.\n                let s = str::from_utf8(utf8).map_err(|_| ())?;\n\n                // Since we included exactly one UTF-8 sequence, and validation\n                // succeeded, `str::chars` should return exactly one `char`.\n                let mut chars = s.chars();\n                match (chars.next(), chars.next()) {\n                    (Some(c), None) => Ok(c),\n                    _ => unreachable!(\n                        \"str::from_utf8({:?}) = {:?} was expected to have 1 char, \\\n                         but {} chars were found\",\n                        utf8,\n                        s,\n                        s.chars().count()\n                    ),\n                }\n            })\n        });\n\n        // HACK(eddyb) doing a separate validation iteration like this might be\n        // wasteful, but it's easier to avoid starting to print a string literal\n        // in the first place, than to abort it mid-string.\n        if chars.clone().any(|r| r.is_err()) {\n            None\n        } else {\n            Some(chars.map(Result::unwrap))\n        }\n    }\n}"],"v0::Ident":["impl<'s> Ident<'s> {\n    /// Attempt to decode punycode on the stack (allocation-free),\n    /// and pass the char slice to the closure, if successful.\n    /// This supports up to `SMALL_PUNYCODE_LEN` characters.\n    fn try_small_punycode_decode<F: FnOnce(&[char]) -> R, R>(&self, f: F) -> Option<R> {\n        let mut out = ['\\0'; SMALL_PUNYCODE_LEN];\n        let mut out_len = 0;\n        let r = self.punycode_decode(|i, c| {\n            // Check there's space left for another character.\n            out.get(out_len).ok_or(())?;\n\n            // Move the characters after the insert position.\n            let mut j = out_len;\n            out_len += 1;\n\n            while j > i {\n                out[j] = out[j - 1];\n                j -= 1;\n            }\n\n            // Insert the new character.\n            out[i] = c;\n\n            Ok(())\n        });\n        if r.is_ok() {\n            Some(f(&out[..out_len]))\n        } else {\n            None\n        }\n    }\n\n    /// Decode punycode as insertion positions and characters\n    /// and pass them to the closure, which can return `Err(())`\n    /// to stop the decoding process.\n    fn punycode_decode<F: FnMut(usize, char) -> Result<(), ()>>(\n        &self,\n        mut insert: F,\n    ) -> Result<(), ()> {\n        let mut punycode_bytes = self.punycode.bytes().peekable();\n        if punycode_bytes.peek().is_none() {\n            return Err(());\n        }\n\n        let mut len = 0;\n\n        // Populate initial output from ASCII fragment.\n        for c in self.ascii.chars() {\n            insert(len, c)?;\n            len += 1;\n        }\n\n        // Punycode parameters and initial state.\n        let base = 36;\n        let t_min = 1;\n        let t_max = 26;\n        let skew = 38;\n        let mut damp = 700;\n        let mut bias = 72;\n        let mut i: usize = 0;\n        let mut n: usize = 0x80;\n\n        loop {\n            // Read one delta value.\n            let mut delta: usize = 0;\n            let mut w = 1;\n            let mut k: usize = 0;\n            loop {\n                use core::cmp::{max, min};\n\n                k += base;\n                let t = min(max(k.saturating_sub(bias), t_min), t_max);\n\n                let d = match punycode_bytes.next() {\n                    Some(d @ b'a'..=b'z') => d - b'a',\n                    Some(d @ b'0'..=b'9') => 26 + (d - b'0'),\n                    _ => return Err(()),\n                };\n                let d = d as usize;\n                delta = delta.checked_add(d.checked_mul(w).ok_or(())?).ok_or(())?;\n                if d < t {\n                    break;\n                }\n                w = w.checked_mul(base - t).ok_or(())?;\n            }\n\n            // Compute the new insert position and character.\n            len += 1;\n            i = i.checked_add(delta).ok_or(())?;\n            n = n.checked_add(i / len).ok_or(())?;\n            i %= len;\n\n            let n_u32 = n as u32;\n            let c = if n_u32 as usize == n {\n                char::from_u32(n_u32).ok_or(())?\n            } else {\n                return Err(());\n            };\n\n            // Insert the new character and increment the insert position.\n            insert(i, c)?;\n            i += 1;\n\n            // If there are no more deltas, decoding is complete.\n            if punycode_bytes.peek().is_none() {\n                return Ok(());\n            }\n\n            // Perform bias adaptation.\n            delta /= damp;\n            damp = 2;\n\n            delta += delta / len;\n            let mut k = 0;\n            while delta > ((base - t_min) * t_max) / 2 {\n                delta /= base - t_min;\n                k += base;\n            }\n            bias = k + ((base - t_min + 1) * delta) / (delta + skew);\n        }\n    }\n}","impl<'s> fmt::Display for Ident<'s> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.try_small_punycode_decode(|chars| {\n            for &c in chars {\n                c.fmt(f)?;\n            }\n            Ok(())\n        })\n        .unwrap_or_else(|| {\n            if !self.punycode.is_empty() {\n                f.write_str(\"punycode{\")?;\n\n                // Reconstruct a standard Punycode encoding,\n                // by using `-` as the separator.\n                if !self.ascii.is_empty() {\n                    f.write_str(self.ascii)?;\n                    f.write_str(\"-\")?;\n                }\n                f.write_str(self.punycode)?;\n\n                f.write_str(\"}\")\n            } else {\n                f.write_str(self.ascii)\n            }\n        })\n    }\n}"],"v0::ParseError":["Debug","Eq","PartialEq","impl ParseError {\n    /// Snippet to print when the error is initially encountered.\n    fn message(&self) -> &str {\n        match self {\n            ParseError::Invalid => \"{invalid syntax}\",\n            ParseError::RecursedTooDeep => \"{recursion limit reached}\",\n        }\n    }\n}"],"v0::Parser":["impl<'s> Parser<'s> {\n    fn push_depth(&mut self) -> Result<(), ParseError> {\n        self.depth += 1;\n        if self.depth > MAX_DEPTH {\n            Err(ParseError::RecursedTooDeep)\n        } else {\n            Ok(())\n        }\n    }\n\n    fn pop_depth(&mut self) {\n        self.depth -= 1;\n    }\n\n    fn peek(&self) -> Option<u8> {\n        self.sym.as_bytes().get(self.next).cloned()\n    }\n\n    fn eat(&mut self, b: u8) -> bool {\n        if self.peek() == Some(b) {\n            self.next += 1;\n            true\n        } else {\n            false\n        }\n    }\n\n    fn next(&mut self) -> Result<u8, ParseError> {\n        let b = self.peek().ok_or(ParseError::Invalid)?;\n        self.next += 1;\n        Ok(b)\n    }\n\n    fn hex_nibbles(&mut self) -> Result<HexNibbles<'s>, ParseError> {\n        let start = self.next;\n        loop {\n            match self.next()? {\n                b'0'..=b'9' | b'a'..=b'f' => {}\n                b'_' => break,\n                _ => return Err(ParseError::Invalid),\n            }\n        }\n        Ok(HexNibbles {\n            nibbles: &self.sym[start..self.next - 1],\n        })\n    }\n\n    fn digit_10(&mut self) -> Result<u8, ParseError> {\n        let d = match self.peek() {\n            Some(d @ b'0'..=b'9') => d - b'0',\n            _ => return Err(ParseError::Invalid),\n        };\n        self.next += 1;\n        Ok(d)\n    }\n\n    fn digit_62(&mut self) -> Result<u8, ParseError> {\n        let d = match self.peek() {\n            Some(d @ b'0'..=b'9') => d - b'0',\n            Some(d @ b'a'..=b'z') => 10 + (d - b'a'),\n            Some(d @ b'A'..=b'Z') => 10 + 26 + (d - b'A'),\n            _ => return Err(ParseError::Invalid),\n        };\n        self.next += 1;\n        Ok(d)\n    }\n\n    fn integer_62(&mut self) -> Result<u64, ParseError> {\n        if self.eat(b'_') {\n            return Ok(0);\n        }\n\n        let mut x: u64 = 0;\n        while !self.eat(b'_') {\n            let d = self.digit_62()? as u64;\n            x = x.checked_mul(62).ok_or(ParseError::Invalid)?;\n            x = x.checked_add(d).ok_or(ParseError::Invalid)?;\n        }\n        x.checked_add(1).ok_or(ParseError::Invalid)\n    }\n\n    fn opt_integer_62(&mut self, tag: u8) -> Result<u64, ParseError> {\n        if !self.eat(tag) {\n            return Ok(0);\n        }\n        self.integer_62()?.checked_add(1).ok_or(ParseError::Invalid)\n    }\n\n    fn disambiguator(&mut self) -> Result<u64, ParseError> {\n        self.opt_integer_62(b's')\n    }\n\n    fn namespace(&mut self) -> Result<Option<char>, ParseError> {\n        match self.next()? {\n            // Special namespaces, like closures and shims.\n            ns @ b'A'..=b'Z' => Ok(Some(ns as char)),\n\n            // Implementation-specific/unspecified namespaces.\n            b'a'..=b'z' => Ok(None),\n\n            _ => Err(ParseError::Invalid),\n        }\n    }\n\n    fn backref(&mut self) -> Result<Parser<'s>, ParseError> {\n        let s_start = self.next - 1;\n        let i = self.integer_62()?;\n        if i >= s_start as u64 {\n            return Err(ParseError::Invalid);\n        }\n        let mut new_parser = Parser {\n            sym: self.sym,\n            next: i as usize,\n            depth: self.depth,\n        };\n        new_parser.push_depth()?;\n        Ok(new_parser)\n    }\n\n    fn ident(&mut self) -> Result<Ident<'s>, ParseError> {\n        let is_punycode = self.eat(b'u');\n        let mut len = self.digit_10()? as usize;\n        if len != 0 {\n            while let Ok(d) = self.digit_10() {\n                len = len.checked_mul(10).ok_or(ParseError::Invalid)?;\n                len = len.checked_add(d as usize).ok_or(ParseError::Invalid)?;\n            }\n        }\n\n        // Skip past the optional `_` separator.\n        self.eat(b'_');\n\n        let start = self.next;\n        self.next = self.next.checked_add(len).ok_or(ParseError::Invalid)?;\n        if self.next > self.sym.len() {\n            return Err(ParseError::Invalid);\n        }\n\n        let ident = &self.sym[start..self.next];\n\n        if is_punycode {\n            let ident = match ident.bytes().rposition(|b| b == b'_') {\n                Some(i) => Ident {\n                    ascii: &ident[..i],\n                    punycode: &ident[i + 1..],\n                },\n                None => Ident {\n                    ascii: \"\",\n                    punycode: ident,\n                },\n            };\n            if ident.punycode.is_empty() {\n                return Err(ParseError::Invalid);\n            }\n            Ok(ident)\n        } else {\n            Ok(Ident {\n                ascii: ident,\n                punycode: \"\",\n            })\n        }\n    }\n}"],"v0::Printer":["impl<'a, 'b, 's> Printer<'a, 'b, 's> {\n    /// Eat the given character from the parser,\n    /// returning `false` if the parser errored.\n    fn eat(&mut self, b: u8) -> bool {\n        self.parser.as_mut().map(|p| p.eat(b)) == Ok(true)\n    }\n\n    /// Skip printing (i.e. `self.out` will be `None`) for the duration of the\n    /// given closure. This should not change parsing behavior, only disable the\n    /// output, but there may be optimizations (such as not traversing backrefs).\n    fn skipping_printing<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut Self) -> fmt::Result,\n    {\n        let orig_out = self.out.take();\n        f(self).expect(\"`fmt::Error`s should be impossible without a `fmt::Formatter`\");\n        self.out = orig_out;\n    }\n\n    /// Print the target of a backref, using the given closure.\n    /// When printing is being skipped, the backref will only be parsed,\n    /// ignoring the backref's target completely.\n    fn print_backref<F>(&mut self, f: F) -> fmt::Result\n    where\n        F: FnOnce(&mut Self) -> fmt::Result,\n    {\n        let backref_parser = parse!(self, backref);\n\n        if self.out.is_none() {\n            return Ok(());\n        }\n\n        let orig_parser = mem::replace(&mut self.parser, Ok(backref_parser));\n        let r = f(self);\n        self.parser = orig_parser;\n        r\n    }\n\n    fn pop_depth(&mut self) {\n        if let Ok(ref mut parser) = self.parser {\n            parser.pop_depth();\n        }\n    }\n\n    /// Output the given value to `self.out` (using `fmt::Display` formatting),\n    /// if printing isn't being skipped.\n    fn print(&mut self, x: impl fmt::Display) -> fmt::Result {\n        if let Some(out) = &mut self.out {\n            fmt::Display::fmt(&x, out)?;\n        }\n        Ok(())\n    }\n\n    /// Output the given `char`s (escaped using `char::escape_debug`), with the\n    /// whole sequence wrapped in quotes, for either a `char` or `&str` literal,\n    /// if printing isn't being skipped.\n    fn print_quoted_escaped_chars(\n        &mut self,\n        quote: char,\n        chars: impl Iterator<Item = char>,\n    ) -> fmt::Result {\n        if let Some(out) = &mut self.out {\n            use core::fmt::Write;\n\n            out.write_char(quote)?;\n            for c in chars {\n                // Special-case not escaping a single/double quote, when\n                // inside the opposite kind of quote.\n                if matches!((quote, c), ('\\'', '\"') | ('\"', '\\'')) {\n                    out.write_char(c)?;\n                    continue;\n                }\n\n                for escaped in c.escape_debug() {\n                    out.write_char(escaped)?;\n                }\n            }\n            out.write_char(quote)?;\n        }\n        Ok(())\n    }\n\n    /// Print the lifetime according to the previously decoded index.\n    /// An index of `0` always refers to `'_`, but starting with `1`,\n    /// indices refer to late-bound lifetimes introduced by a binder.\n    fn print_lifetime_from_index(&mut self, lt: u64) -> fmt::Result {\n        // Bound lifetimes aren't tracked when skipping printing.\n        if self.out.is_none() {\n            return Ok(());\n        }\n\n        self.print(\"'\")?;\n        if lt == 0 {\n            return self.print(\"_\");\n        }\n        match (self.bound_lifetime_depth as u64).checked_sub(lt) {\n            Some(depth) => {\n                // Try to print lifetimes alphabetically first.\n                if depth < 26 {\n                    let c = (b'a' + depth as u8) as char;\n                    self.print(c)\n                } else {\n                    // Use `'_123` after running out of letters.\n                    self.print(\"_\")?;\n                    self.print(depth)\n                }\n            }\n            None => invalid!(self),\n        }\n    }\n\n    /// Optionally enter a binder ('G') for late-bound lifetimes,\n    /// printing e.g. `for<'a, 'b> ` before calling the closure,\n    /// and make those lifetimes visible to it (via depth level).\n    fn in_binder<F>(&mut self, f: F) -> fmt::Result\n    where\n        F: FnOnce(&mut Self) -> fmt::Result,\n    {\n        let bound_lifetimes = parse!(self, opt_integer_62(b'G'));\n\n        // Don't track bound lifetimes when skipping printing.\n        if self.out.is_none() {\n            return f(self);\n        }\n\n        if bound_lifetimes > 0 {\n            self.print(\"for<\")?;\n            for i in 0..bound_lifetimes {\n                if i > 0 {\n                    self.print(\", \")?;\n                }\n                self.bound_lifetime_depth += 1;\n                self.print_lifetime_from_index(1)?;\n            }\n            self.print(\"> \")?;\n        }\n\n        let r = f(self);\n\n        // Restore `bound_lifetime_depth` to the previous value.\n        self.bound_lifetime_depth -= bound_lifetimes as u32;\n\n        r\n    }\n\n    /// Print list elements using the given closure and separator,\n    /// until the end of the list ('E') is found, or the parser errors.\n    /// Returns the number of elements printed.\n    fn print_sep_list<F>(&mut self, f: F, sep: &str) -> Result<usize, fmt::Error>\n    where\n        F: Fn(&mut Self) -> fmt::Result,\n    {\n        let mut i = 0;\n        while self.parser.is_ok() && !self.eat(b'E') {\n            if i > 0 {\n                self.print(sep)?;\n            }\n            f(self)?;\n            i += 1;\n        }\n        Ok(i)\n    }\n\n    fn print_path(&mut self, in_value: bool) -> fmt::Result {\n        parse!(self, push_depth);\n\n        let tag = parse!(self, next);\n        match tag {\n            b'C' => {\n                let dis = parse!(self, disambiguator);\n                let name = parse!(self, ident);\n\n                self.print(name)?;\n                if let Some(out) = &mut self.out {\n                    if !out.alternate() {\n                        out.write_str(\"[\")?;\n                        fmt::LowerHex::fmt(&dis, out)?;\n                        out.write_str(\"]\")?;\n                    }\n                }\n            }\n            b'N' => {\n                let ns = parse!(self, namespace);\n\n                self.print_path(in_value)?;\n\n                // HACK(eddyb) if the parser is already marked as having errored,\n                // `parse!` below will print a `?` without its preceding `::`\n                // (because printing the `::` is skipped in certain conditions,\n                // i.e. a lowercase namespace with an empty identifier),\n                // so in order to get `::?`, the `::` has to be printed here.\n                if self.parser.is_err() {\n                    self.print(\"::\")?;\n                }\n\n                let dis = parse!(self, disambiguator);\n                let name = parse!(self, ident);\n\n                match ns {\n                    // Special namespaces, like closures and shims.\n                    Some(ns) => {\n                        self.print(\"::{\")?;\n                        match ns {\n                            'C' => self.print(\"closure\")?,\n                            'S' => self.print(\"shim\")?,\n                            _ => self.print(ns)?,\n                        }\n                        if !name.ascii.is_empty() || !name.punycode.is_empty() {\n                            self.print(\":\")?;\n                            self.print(name)?;\n                        }\n                        self.print(\"#\")?;\n                        self.print(dis)?;\n                        self.print(\"}\")?;\n                    }\n\n                    // Implementation-specific/unspecified namespaces.\n                    None => {\n                        if !name.ascii.is_empty() || !name.punycode.is_empty() {\n                            self.print(\"::\")?;\n                            self.print(name)?;\n                        }\n                    }\n                }\n            }\n            b'M' | b'X' | b'Y' => {\n                if tag != b'Y' {\n                    // Ignore the `impl`'s own path.\n                    parse!(self, disambiguator);\n                    self.skipping_printing(|this| this.print_path(false));\n                }\n\n                self.print(\"<\")?;\n                self.print_type()?;\n                if tag != b'M' {\n                    self.print(\" as \")?;\n                    self.print_path(false)?;\n                }\n                self.print(\">\")?;\n            }\n            b'I' => {\n                self.print_path(in_value)?;\n                if in_value {\n                    self.print(\"::\")?;\n                }\n                self.print(\"<\")?;\n                self.print_sep_list(Self::print_generic_arg, \", \")?;\n                self.print(\">\")?;\n            }\n            b'B' => {\n                self.print_backref(|this| this.print_path(in_value))?;\n            }\n            _ => invalid!(self),\n        }\n\n        self.pop_depth();\n        Ok(())\n    }\n\n    fn print_generic_arg(&mut self) -> fmt::Result {\n        if self.eat(b'L') {\n            let lt = parse!(self, integer_62);\n            self.print_lifetime_from_index(lt)\n        } else if self.eat(b'K') {\n            self.print_const(false)\n        } else {\n            self.print_type()\n        }\n    }\n\n    fn print_type(&mut self) -> fmt::Result {\n        let tag = parse!(self, next);\n\n        if let Some(ty) = basic_type(tag) {\n            return self.print(ty);\n        }\n\n        parse!(self, push_depth);\n\n        match tag {\n            b'R' | b'Q' => {\n                self.print(\"&\")?;\n                if self.eat(b'L') {\n                    let lt = parse!(self, integer_62);\n                    if lt != 0 {\n                        self.print_lifetime_from_index(lt)?;\n                        self.print(\" \")?;\n                    }\n                }\n                if tag != b'R' {\n                    self.print(\"mut \")?;\n                }\n                self.print_type()?;\n            }\n\n            b'P' | b'O' => {\n                self.print(\"*\")?;\n                if tag != b'P' {\n                    self.print(\"mut \")?;\n                } else {\n                    self.print(\"const \")?;\n                }\n                self.print_type()?;\n            }\n\n            b'A' | b'S' => {\n                self.print(\"[\")?;\n                self.print_type()?;\n                if tag == b'A' {\n                    self.print(\"; \")?;\n                    self.print_const(true)?;\n                }\n                self.print(\"]\")?;\n            }\n            b'T' => {\n                self.print(\"(\")?;\n                let count = self.print_sep_list(Self::print_type, \", \")?;\n                if count == 1 {\n                    self.print(\",\")?;\n                }\n                self.print(\")\")?;\n            }\n            b'F' => self.in_binder(|this| {\n                let is_unsafe = this.eat(b'U');\n                let abi = if this.eat(b'K') {\n                    if this.eat(b'C') {\n                        Some(\"C\")\n                    } else {\n                        let abi = parse!(this, ident);\n                        if abi.ascii.is_empty() || !abi.punycode.is_empty() {\n                            invalid!(this);\n                        }\n                        Some(abi.ascii)\n                    }\n                } else {\n                    None\n                };\n\n                if is_unsafe {\n                    this.print(\"unsafe \")?;\n                }\n\n                if let Some(abi) = abi {\n                    this.print(\"extern \\\"\")?;\n\n                    // If the ABI had any `-`, they were replaced with `_`,\n                    // so the parts between `_` have to be re-joined with `-`.\n                    let mut parts = abi.split('_');\n                    this.print(parts.next().unwrap())?;\n                    for part in parts {\n                        this.print(\"-\")?;\n                        this.print(part)?;\n                    }\n\n                    this.print(\"\\\" \")?;\n                }\n\n                this.print(\"fn(\")?;\n                this.print_sep_list(Self::print_type, \", \")?;\n                this.print(\")\")?;\n\n                if this.eat(b'u') {\n                    // Skip printing the return type if it's 'u', i.e. `()`.\n                } else {\n                    this.print(\" -> \")?;\n                    this.print_type()?;\n                }\n\n                Ok(())\n            })?,\n            b'D' => {\n                self.print(\"dyn \")?;\n                self.in_binder(|this| {\n                    this.print_sep_list(Self::print_dyn_trait, \" + \")?;\n                    Ok(())\n                })?;\n\n                if !self.eat(b'L') {\n                    invalid!(self);\n                }\n                let lt = parse!(self, integer_62);\n                if lt != 0 {\n                    self.print(\" + \")?;\n                    self.print_lifetime_from_index(lt)?;\n                }\n            }\n            b'B' => {\n                self.print_backref(Self::print_type)?;\n            }\n            _ => {\n                // Go back to the tag, so `print_path` also sees it.\n                let _ = self.parser.as_mut().map(|p| p.next -= 1);\n                self.print_path(false)?;\n            }\n        }\n\n        self.pop_depth();\n        Ok(())\n    }\n\n    /// A trait in a trait object may have some \"existential projections\"\n    /// (i.e. associated type bindings) after it, which should be printed\n    /// in the `<...>` of the trait, e.g. `dyn Trait<T, U, Assoc=X>`.\n    /// To this end, this method will keep the `<...>` of an 'I' path\n    /// open, by omitting the `>`, and return `Ok(true)` in that case.\n    fn print_path_maybe_open_generics(&mut self) -> Result<bool, fmt::Error> {\n        if self.eat(b'B') {\n            // NOTE(eddyb) the closure may not run if printing is being skipped,\n            // but in that case the returned boolean doesn't matter.\n            let mut open = false;\n            self.print_backref(|this| {\n                open = this.print_path_maybe_open_generics()?;\n                Ok(())\n            })?;\n            Ok(open)\n        } else if self.eat(b'I') {\n            self.print_path(false)?;\n            self.print(\"<\")?;\n            self.print_sep_list(Self::print_generic_arg, \", \")?;\n            Ok(true)\n        } else {\n            self.print_path(false)?;\n            Ok(false)\n        }\n    }\n\n    fn print_dyn_trait(&mut self) -> fmt::Result {\n        let mut open = self.print_path_maybe_open_generics()?;\n\n        while self.eat(b'p') {\n            if !open {\n                self.print(\"<\")?;\n                open = true;\n            } else {\n                self.print(\", \")?;\n            }\n\n            let name = parse!(self, ident);\n            self.print(name)?;\n            self.print(\" = \")?;\n            self.print_type()?;\n        }\n\n        if open {\n            self.print(\">\")?;\n        }\n\n        Ok(())\n    }\n\n    fn print_const(&mut self, in_value: bool) -> fmt::Result {\n        let tag = parse!(self, next);\n\n        parse!(self, push_depth);\n\n        // Only literals (and the names of `const` generic parameters, but they\n        // don't get mangled at all), can appear in generic argument position\n        // without any disambiguation, all other expressions require braces.\n        // To avoid duplicating the mapping between `tag` and what syntax gets\n        // used (especially any special-casing), every case that needs braces\n        // has to call `open_brace(self)?` (and the closing brace is automatic).\n        let mut opened_brace = false;\n        let mut open_brace_if_outside_expr = |this: &mut Self| {\n            // If this expression is nested in another, braces aren't required.\n            if in_value {\n                return Ok(());\n            }\n\n            opened_brace = true;\n            this.print(\"{\")\n        };\n\n        match tag {\n            b'p' => self.print(\"_\")?,\n\n            // Primitive leaves with hex-encoded values (see `basic_type`).\n            b'h' | b't' | b'm' | b'y' | b'o' | b'j' => self.print_const_uint(tag)?,\n            b'a' | b's' | b'l' | b'x' | b'n' | b'i' => {\n                if self.eat(b'n') {\n                    self.print(\"-\")?;\n                }\n\n                self.print_const_uint(tag)?;\n            }\n            b'b' => match parse!(self, hex_nibbles).try_parse_uint() {\n                Some(0) => self.print(\"false\")?,\n                Some(1) => self.print(\"true\")?,\n                _ => invalid!(self),\n            },\n            b'c' => {\n                let valid_char = parse!(self, hex_nibbles)\n                    .try_parse_uint()\n                    .and_then(|v| u32::try_from(v).ok())\n                    .and_then(char::from_u32);\n                match valid_char {\n                    Some(c) => self.print_quoted_escaped_chars('\\'', iter::once(c))?,\n                    None => invalid!(self),\n                }\n            }\n            b'e' => {\n                // NOTE(eddyb) a string literal `\"...\"` has type `&str`, so\n                // to get back the type `str`, `*\"...\"` syntax is needed\n                // (even if that may not be valid in Rust itself).\n                open_brace_if_outside_expr(self)?;\n                self.print(\"*\")?;\n\n                self.print_const_str_literal()?;\n            }\n\n            b'R' | b'Q' => {\n                // NOTE(eddyb) this prints `\"...\"` instead of `&*\"...\"`, which\n                // is what `Re..._` would imply (see comment for `str` above).\n                if tag == b'R' && self.eat(b'e') {\n                    self.print_const_str_literal()?;\n                } else {\n                    open_brace_if_outside_expr(self)?;\n                    self.print(\"&\")?;\n                    if tag != b'R' {\n                        self.print(\"mut \")?;\n                    }\n                    self.print_const(true)?;\n                }\n            }\n            b'A' => {\n                open_brace_if_outside_expr(self)?;\n                self.print(\"[\")?;\n                self.print_sep_list(|this| this.print_const(true), \", \")?;\n                self.print(\"]\")?;\n            }\n            b'T' => {\n                open_brace_if_outside_expr(self)?;\n                self.print(\"(\")?;\n                let count = self.print_sep_list(|this| this.print_const(true), \", \")?;\n                if count == 1 {\n                    self.print(\",\")?;\n                }\n                self.print(\")\")?;\n            }\n            b'V' => {\n                open_brace_if_outside_expr(self)?;\n                self.print_path(true)?;\n                match parse!(self, next) {\n                    b'U' => {}\n                    b'T' => {\n                        self.print(\"(\")?;\n                        self.print_sep_list(|this| this.print_const(true), \", \")?;\n                        self.print(\")\")?;\n                    }\n                    b'S' => {\n                        self.print(\" { \")?;\n                        self.print_sep_list(\n                            |this| {\n                                parse!(this, disambiguator);\n                                let name = parse!(this, ident);\n                                this.print(name)?;\n                                this.print(\": \")?;\n                                this.print_const(true)\n                            },\n                            \", \",\n                        )?;\n                        self.print(\" }\")?;\n                    }\n                    _ => invalid!(self),\n                }\n            }\n            b'B' => {\n                self.print_backref(|this| this.print_const(in_value))?;\n            }\n            _ => invalid!(self),\n        }\n\n        if opened_brace {\n            self.print(\"}\")?;\n        }\n\n        self.pop_depth();\n        Ok(())\n    }\n\n    fn print_const_uint(&mut self, ty_tag: u8) -> fmt::Result {\n        let hex = parse!(self, hex_nibbles);\n\n        match hex.try_parse_uint() {\n            Some(v) => self.print(v)?,\n\n            // Print anything that doesn't fit in `u64` verbatim.\n            None => {\n                self.print(\"0x\")?;\n                self.print(hex.nibbles)?;\n            }\n        }\n\n        if let Some(out) = &mut self.out {\n            if !out.alternate() {\n                let ty = basic_type(ty_tag).unwrap();\n                self.print(ty)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn print_const_str_literal(&mut self) -> fmt::Result {\n        match parse!(self, hex_nibbles).try_parse_str_chars() {\n            Some(chars) => self.print_quoted_escaped_chars('\"', chars),\n            None => invalid!(self),\n        }\n    }\n}"]},"single_path_import":{},"srcs":{"<Demangle<'a> as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Display::fmt(self, f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Demangle<'a> as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self.style {\n            None => f.write_str(self.original)?,\n            Some(ref d) => {\n                let alternate = f.alternate();\n                let mut size_limited_fmt = SizeLimitedFmtAdapter {\n                    remaining: Ok(MAX_SIZE),\n                    inner: &mut *f,\n                };\n                let fmt_result = if alternate {\n                    write!(size_limited_fmt, \"{:#}\", d)\n                } else {\n                    write!(size_limited_fmt, \"{}\", d)\n                };\n                let size_limit_result = size_limited_fmt.remaining.map(|_| ());\n\n                // Translate a `fmt::Error` generated by `SizeLimitedFmtAdapter`\n                // into an error message, instead of propagating it upwards\n                // (which could cause panicking from inside e.g. `std::io::print`).\n                match (fmt_result, size_limit_result) {\n                    (Err(_), Err(SizeLimitExhausted)) => f.write_str(\"{size limit reached}\")?,\n\n                    _ => {\n                        fmt_result?;\n                        size_limit_result\n                            .expect(\"`fmt::Error` from `SizeLimitedFmtAdapter` was discarded\");\n                    }\n                }\n            }\n        }\n        f.write_str(self.suffix)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<DemangleStyle<'a> as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match *self {\n            DemangleStyle::Legacy(ref d) => fmt::Display::fmt(d, f),\n            DemangleStyle::V0(ref d) => fmt::Display::fmt(d, f),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<SizeLimitedFmtAdapter<F> as core::fmt::Write>::write_str":["fn write_str(&mut self, s: &str) -> fmt::Result{\n        self.remaining = self\n            .remaining\n            .and_then(|r| r.checked_sub(s.len()).ok_or(SizeLimitExhausted));\n\n        match self.remaining {\n            Ok(_) => self.inner.write_str(s),\n            Err(SizeLimitExhausted) => Err(fmt::Error),\n        }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<legacy::Demangle<'a> as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        // Alright, let's do this.\n        let mut inner = self.inner;\n        for element in 0..self.elements {\n            let mut rest = inner;\n            while rest.chars().next().unwrap().is_digit(10) {\n                rest = &rest[1..];\n            }\n            let i: usize = inner[..(inner.len() - rest.len())].parse().unwrap();\n            inner = &rest[i..];\n            rest = &rest[..i];\n            // Skip printing the hash if alternate formatting\n            // was requested.\n            if f.alternate() && element + 1 == self.elements && is_rust_hash(&rest) {\n                break;\n            }\n            if element != 0 {\n                f.write_str(\"::\")?;\n            }\n            if rest.starts_with(\"_$\") {\n                rest = &rest[1..];\n            }\n            loop {\n                if rest.starts_with('.') {\n                    if let Some('.') = rest[1..].chars().next() {\n                        f.write_str(\"::\")?;\n                        rest = &rest[2..];\n                    } else {\n                        f.write_str(\".\")?;\n                        rest = &rest[1..];\n                    }\n                } else if rest.starts_with('$') {\n                    let (escape, after_escape) = if let Some(end) = rest[1..].find('$') {\n                        (&rest[1..=end], &rest[end + 2..])\n                    } else {\n                        break;\n                    };\n\n                    // see src/librustc_codegen_utils/symbol_names/legacy.rs for these mappings\n                    let unescaped = match escape {\n                        \"SP\" => \"@\",\n                        \"BP\" => \"*\",\n                        \"RF\" => \"&\",\n                        \"LT\" => \"<\",\n                        \"GT\" => \">\",\n                        \"LP\" => \"(\",\n                        \"RP\" => \")\",\n                        \"C\" => \",\",\n\n                        _ => {\n                            if escape.starts_with('u') {\n                                let digits = &escape[1..];\n                                let all_lower_hex = digits.chars().all(|c| match c {\n                                    '0'..='9' | 'a'..='f' => true,\n                                    _ => false,\n                                });\n                                let c = u32::from_str_radix(digits, 16)\n                                    .ok()\n                                    .and_then(char::from_u32);\n                                if let (true, Some(c)) = (all_lower_hex, c) {\n                                    // FIXME(eddyb) do we need to filter out control codepoints?\n                                    if !c.is_control() {\n                                        c.fmt(f)?;\n                                        rest = after_escape;\n                                        continue;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                    };\n                    f.write_str(unescaped)?;\n                    rest = after_escape;\n                } else if let Some(i) = rest.find(|c| c == '$' || c == '.') {\n                    f.write_str(&rest[..i])?;\n                    rest = &rest[i..];\n                } else {\n                    break;\n                }\n            }\n            f.write_str(rest)?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/legacy.rs\"))"],"<v0::Demangle<'s> as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let mut printer = Printer {\n            parser: Ok(Parser {\n                sym: self.inner,\n                next: 0,\n                depth: 0,\n            }),\n            out: Some(f),\n            bound_lifetime_depth: 0,\n        };\n        printer.print_path(true)\n    }","Real(LocalPath(\"src/v0.rs\"))"],"<v0::Ident<'s> as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.try_small_punycode_decode(|chars| {\n            for &c in chars {\n                c.fmt(f)?;\n            }\n            Ok(())\n        })\n        .unwrap_or_else(|| {\n            if !self.punycode.is_empty() {\n                f.write_str(\"punycode{\")?;\n\n                // Reconstruct a standard Punycode encoding,\n                // by using `-` as the separator.\n                if !self.ascii.is_empty() {\n                    f.write_str(self.ascii)?;\n                    f.write_str(\"-\")?;\n                }\n                f.write_str(self.punycode)?;\n\n                f.write_str(\"}\")\n            } else {\n                f.write_str(self.ascii)\n            }\n        })\n    }","Real(LocalPath(\"src/v0.rs\"))"],"Demangle":["/// Representation of a demangled symbol name.\npub struct Demangle<'a> {\n    style: Option<DemangleStyle<'a>>,\n    original: &'a str,\n    suffix: &'a str,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Demangle::<'a>::as_str":["/// Returns the underlying string that's being demangled.\npub fn as_str(&self) -> &'a str{\n        self.original\n    }","Real(LocalPath(\"src/lib.rs\"))"],"DemangleStyle":["enum DemangleStyle<'a> {\n    Legacy(legacy::Demangle<'a>),\n    V0(v0::Demangle<'a>),\n}","Real(LocalPath(\"src/lib.rs\"))"],"SizeLimitExhausted":["struct SizeLimitExhausted;","Real(LocalPath(\"src/lib.rs\"))"],"SizeLimitedFmtAdapter":["struct SizeLimitedFmtAdapter<F> {\n    remaining: Result<usize, SizeLimitExhausted>,\n    inner: F,\n}","Real(LocalPath(\"src/lib.rs\"))"],"TryDemangleError":["/// Error returned from the `try_demangle` function below when demangling fails.\npub struct TryDemangleError {\n    _priv: (),\n}","Real(LocalPath(\"src/lib.rs\"))"],"demangle":["/// De-mangles a Rust symbol into a more readable version\n///\n/// This function will take a **mangled** symbol and return a value. When printed,\n/// the de-mangled version will be written. If the symbol does not look like\n/// a mangled symbol, the original value will be written instead.\n///\n/// # Examples\n///\n/// ```\n/// use rustc_demangle::demangle;\n///\n/// assert_eq!(demangle(\"_ZN4testE\").to_string(), \"test\");\n/// assert_eq!(demangle(\"_ZN3foo3barE\").to_string(), \"foo::bar\");\n/// assert_eq!(demangle(\"foo\").to_string(), \"foo\");\n/// ```\npub fn demangle(mut s: &str) -> Demangle{\n    // During ThinLTO LLVM may import and rename internal symbols, so strip out\n    // those endings first as they're one of the last manglings applied to symbol\n    // names.\n    let llvm = \".llvm.\";\n    if let Some(i) = s.find(llvm) {\n        let candidate = &s[i + llvm.len()..];\n        let all_hex = candidate.chars().all(|c| match c {\n            'A'..='F' | '0'..='9' | '@' => true,\n            _ => false,\n        });\n\n        if all_hex {\n            s = &s[..i];\n        }\n    }\n\n    let mut suffix = \"\";\n    let mut style = match legacy::demangle(s) {\n        Ok((d, s)) => {\n            suffix = s;\n            Some(DemangleStyle::Legacy(d))\n        }\n        Err(()) => match v0::demangle(s) {\n            Ok((d, s)) => {\n                suffix = s;\n                Some(DemangleStyle::V0(d))\n            }\n            // FIXME(eddyb) would it make sense to treat an unknown-validity\n            // symbol (e.g. one that errored with `RecursedTooDeep`) as\n            // v0-mangled, and have the error show up in the demangling?\n            // (that error already gets past this initial check, and therefore\n            // will show up in the demangling, if hidden behind a backref)\n            Err(v0::ParseError::Invalid) | Err(v0::ParseError::RecursedTooDeep) => None,\n        },\n    };\n\n    // Output like LLVM IR adds extra period-delimited words. See if\n    // we are in that case and save the trailing words if so.\n    if !suffix.is_empty() {\n        if suffix.starts_with('.') && is_symbol_like(suffix) {\n            // Keep the suffix.\n        } else {\n            // Reset the suffix and invalidate the demangling.\n            suffix = \"\";\n            style = None;\n        }\n    }\n\n    Demangle {\n        style,\n        original: s,\n        suffix,\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"is_ascii_alphanumeric":["fn is_ascii_alphanumeric(c: char) -> bool{\n    match c {\n        '\\u{0041}'..='\\u{005A}' | '\\u{0061}'..='\\u{007A}' | '\\u{0030}'..='\\u{0039}' => true,\n        _ => false,\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"is_ascii_punctuation":["fn is_ascii_punctuation(c: char) -> bool{\n    match c {\n        '\\u{0021}'..='\\u{002F}'\n        | '\\u{003A}'..='\\u{0040}'\n        | '\\u{005B}'..='\\u{0060}'\n        | '\\u{007B}'..='\\u{007E}' => true,\n        _ => false,\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"is_symbol_like":["fn is_symbol_like(s: &str) -> bool{\n    s.chars().all(|c| {\n        // Once `char::is_ascii_punctuation` and `char::is_ascii_alphanumeric`\n        // have been stable for long enough, use those instead for clarity\n        is_ascii_alphanumeric(c) || is_ascii_punctuation(c)\n    })\n}","Real(LocalPath(\"src/lib.rs\"))"],"legacy::Demangle":["/// Representation of a demangled symbol name.\npub struct Demangle<'a> {\n    inner: &'a str,\n    /// The number of ::-separated elements in the original name.\n    elements: usize,\n}","Real(LocalPath(\"src/legacy.rs\"))"],"legacy::demangle":["/// De-mangles a Rust symbol into a more readable version\n///\n/// All Rust symbols by default are mangled as they contain characters that\n/// cannot be represented in all object files. The mangling mechanism is similar\n/// to C++'s, but Rust has a few specifics to handle items like lifetimes in\n/// symbols.\n///\n/// This function will take a **mangled** symbol and return a value. When printed,\n/// the de-mangled version will be written. If the symbol does not look like\n/// a mangled symbol, the original value will be written instead.\n///\n/// # Examples\n///\n/// ```\n/// use rustc_demangle::demangle;\n///\n/// assert_eq!(demangle(\"_ZN4testE\").to_string(), \"test\");\n/// assert_eq!(demangle(\"_ZN3foo3barE\").to_string(), \"foo::bar\");\n/// assert_eq!(demangle(\"foo\").to_string(), \"foo\");\n/// ```\npub fn demangle(s: &str) -> Result<(Demangle, &str), ()>{\n    // First validate the symbol. If it doesn't look like anything we're\n    // expecting, we just print it literally. Note that we must handle non-Rust\n    // symbols because we could have any function in the backtrace.\n    let inner = if s.starts_with(\"_ZN\") {\n        &s[3..]\n    } else if s.starts_with(\"ZN\") {\n        // On Windows, dbghelp strips leading underscores, so we accept \"ZN...E\"\n        // form too.\n        &s[2..]\n    } else if s.starts_with(\"__ZN\") {\n        // On OSX, symbols are prefixed with an extra _\n        &s[4..]\n    } else {\n        return Err(());\n    };\n\n    // only work with ascii text\n    if inner.bytes().any(|c| c & 0x80 != 0) {\n        return Err(());\n    }\n\n    let mut elements = 0;\n    let mut chars = inner.chars();\n    let mut c = chars.next().ok_or(())?;\n    while c != 'E' {\n        // Decode an identifier element's length.\n        if !c.is_digit(10) {\n            return Err(());\n        }\n        let mut len = 0usize;\n        while let Some(d) = c.to_digit(10) {\n            len = len\n                .checked_mul(10)\n                .and_then(|len| len.checked_add(d as usize))\n                .ok_or(())?;\n            c = chars.next().ok_or(())?;\n        }\n\n        // `c` already contains the first character of this identifier, skip it and\n        // all the other characters of this identifier, to reach the next element.\n        for _ in 0..len {\n            c = chars.next().ok_or(())?;\n        }\n\n        elements += 1;\n    }\n\n    Ok((Demangle { inner, elements }, chars.as_str()))\n}","Real(LocalPath(\"src/legacy.rs\"))"],"legacy::is_rust_hash":["fn is_rust_hash(s: &str) -> bool{\n    s.starts_with('h') && s[1..].chars().all(|c| c.is_digit(16))\n}","Real(LocalPath(\"src/legacy.rs\"))"],"try_demangle":["/// The same as `demangle`, except return an `Err` if the string does not appear\n/// to be a Rust symbol, rather than \"demangling\" the given string as a no-op.\n///\n/// ```\n/// extern crate rustc_demangle;\n///\n/// let not_a_rust_symbol = \"la la la\";\n///\n/// // The `try_demangle` function will reject strings which are not Rust symbols.\n/// assert!(rustc_demangle::try_demangle(not_a_rust_symbol).is_err());\n///\n/// // While `demangle` will just pass the non-symbol through as a no-op.\n/// assert_eq!(rustc_demangle::demangle(not_a_rust_symbol).as_str(), not_a_rust_symbol);\n/// ```\npub fn try_demangle(s: &str) -> Result<Demangle, TryDemangleError>{\n    let sym = demangle(s);\n    if sym.style.is_some() {\n        Ok(sym)\n    } else {\n        Err(TryDemangleError { _priv: () })\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"v0::Demangle":["/// Representation of a demangled symbol name.\npub struct Demangle<'a> {\n    inner: &'a str,\n}","Real(LocalPath(\"src/v0.rs\"))"],"v0::HexNibbles":["/// Sequence of lowercase hexadecimal nibbles (`0-9a-f`), used by leaf consts.\nstruct HexNibbles<'s> {\n    nibbles: &'s str,\n}","Real(LocalPath(\"src/v0.rs\"))"],"v0::HexNibbles::<'s>::try_parse_str_chars":["/// Decode a UTF-8 byte sequence (with each byte using a pair of nibbles)\n/// into individual `char`s, returning `None` for invalid UTF-8.\nfn try_parse_str_chars(&self) -> Option<impl Iterator<Item = char> + 's>{\n        if self.nibbles.len() % 2 != 0 {\n            return None;\n        }\n\n        // FIXME(eddyb) use `array_chunks` instead, when that becomes stable.\n        let mut bytes = self\n            .nibbles\n            .as_bytes()\n            .chunks_exact(2)\n            .map(|slice| match slice {\n                [a, b] => [a, b],\n                _ => unreachable!(),\n            })\n            .map(|[&hi, &lo]| {\n                let half = |nibble: u8| (nibble as char).to_digit(16).unwrap() as u8;\n                (half(hi) << 4) | half(lo)\n            });\n\n        let chars = iter::from_fn(move || {\n            // As long as there are any bytes left, there's at least one more\n            // UTF-8-encoded `char` to decode (or the possibility of error).\n            bytes.next().map(|first_byte| -> Result<char, ()> {\n                // FIXME(eddyb) this `enum` and `fn` should be somewhere in `core`.\n                enum Utf8FirstByteError {\n                    ContinuationByte,\n                    TooLong,\n                }\n                fn utf8_len_from_first_byte(byte: u8) -> Result<usize, Utf8FirstByteError> {\n                    match byte {\n                        0x00..=0x7f => Ok(1),\n                        0x80..=0xbf => Err(Utf8FirstByteError::ContinuationByte),\n                        0xc0..=0xdf => Ok(2),\n                        0xe0..=0xef => Ok(3),\n                        0xf0..=0xf7 => Ok(4),\n                        0xf8..=0xff => Err(Utf8FirstByteError::TooLong),\n                    }\n                }\n\n                // Collect the appropriate amount of bytes (up to 4), according\n                // to the UTF-8 length implied by the first byte.\n                let utf8_len = utf8_len_from_first_byte(first_byte).map_err(|_| ())?;\n                let utf8 = &mut [first_byte, 0, 0, 0][..utf8_len];\n                for i in 1..utf8_len {\n                    utf8[i] = bytes.next().ok_or(())?;\n                }\n\n                // Fully validate the UTF-8 sequence.\n                let s = str::from_utf8(utf8).map_err(|_| ())?;\n\n                // Since we included exactly one UTF-8 sequence, and validation\n                // succeeded, `str::chars` should return exactly one `char`.\n                let mut chars = s.chars();\n                match (chars.next(), chars.next()) {\n                    (Some(c), None) => Ok(c),\n                    _ => unreachable!(\n                        \"str::from_utf8({:?}) = {:?} was expected to have 1 char, \\\n                         but {} chars were found\",\n                        utf8,\n                        s,\n                        s.chars().count()\n                    ),\n                }\n            })\n        });\n\n        // HACK(eddyb) doing a separate validation iteration like this might be\n        // wasteful, but it's easier to avoid starting to print a string literal\n        // in the first place, than to abort it mid-string.\n        if chars.clone().any(|r| r.is_err()) {\n            None\n        } else {\n            Some(chars.map(Result::unwrap))\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::HexNibbles::<'s>::try_parse_str_chars::{closure#2}::{closure#0}::utf8_len_from_first_byte":["fn utf8_len_from_first_byte(byte: u8) -> Result<usize, Utf8FirstByteError>{\n                    match byte {\n                        0x00..=0x7f => Ok(1),\n                        0x80..=0xbf => Err(Utf8FirstByteError::ContinuationByte),\n                        0xc0..=0xdf => Ok(2),\n                        0xe0..=0xef => Ok(3),\n                        0xf0..=0xf7 => Ok(4),\n                        0xf8..=0xff => Err(Utf8FirstByteError::TooLong),\n                    }\n                }","Real(LocalPath(\"src/v0.rs\"))"],"v0::HexNibbles::<'s>::try_parse_uint":["/// Decode an integer value (with the \"most significant nibble\" first),\n/// returning `None` if it can't fit in an `u64`.\nfn try_parse_uint(&self) -> Option<u64>{\n        let nibbles = self.nibbles.trim_start_matches(\"0\");\n\n        if nibbles.len() > 16 {\n            return None;\n        }\n\n        let mut v = 0;\n        for nibble in nibbles.chars() {\n            v = (v << 4) | (nibble.to_digit(16).unwrap() as u64);\n        }\n        Some(v)\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::HexNibbles<'s>::try_parse_str_chars::{closure#2}::{closure#0}::Utf8FirstByteError":["enum Utf8FirstByteError {\n                    ContinuationByte,\n                    TooLong,\n                }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Ident":["struct Ident<'s> {\n    /// ASCII part of the identifier.\n    ascii: &'s str,\n    /// Punycode insertion codes for Unicode codepoints, if any.\n    punycode: &'s str,\n}","Real(LocalPath(\"src/v0.rs\"))"],"v0::Ident::<'s>::punycode_decode":["/// Decode punycode as insertion positions and characters\n/// and pass them to the closure, which can return `Err(())`\n/// to stop the decoding process.\nfn punycode_decode<F: FnMut(usize, char) -> Result<(), ()>>(\n        &self,\n        mut insert: F,\n    ) -> Result<(), ()>{\n        let mut punycode_bytes = self.punycode.bytes().peekable();\n        if punycode_bytes.peek().is_none() {\n            return Err(());\n        }\n\n        let mut len = 0;\n\n        // Populate initial output from ASCII fragment.\n        for c in self.ascii.chars() {\n            insert(len, c)?;\n            len += 1;\n        }\n\n        // Punycode parameters and initial state.\n        let base = 36;\n        let t_min = 1;\n        let t_max = 26;\n        let skew = 38;\n        let mut damp = 700;\n        let mut bias = 72;\n        let mut i: usize = 0;\n        let mut n: usize = 0x80;\n\n        loop {\n            // Read one delta value.\n            let mut delta: usize = 0;\n            let mut w = 1;\n            let mut k: usize = 0;\n            loop {\n                use core::cmp::{max, min};\n\n                k += base;\n                let t = min(max(k.saturating_sub(bias), t_min), t_max);\n\n                let d = match punycode_bytes.next() {\n                    Some(d @ b'a'..=b'z') => d - b'a',\n                    Some(d @ b'0'..=b'9') => 26 + (d - b'0'),\n                    _ => return Err(()),\n                };\n                let d = d as usize;\n                delta = delta.checked_add(d.checked_mul(w).ok_or(())?).ok_or(())?;\n                if d < t {\n                    break;\n                }\n                w = w.checked_mul(base - t).ok_or(())?;\n            }\n\n            // Compute the new insert position and character.\n            len += 1;\n            i = i.checked_add(delta).ok_or(())?;\n            n = n.checked_add(i / len).ok_or(())?;\n            i %= len;\n\n            let n_u32 = n as u32;\n            let c = if n_u32 as usize == n {\n                char::from_u32(n_u32).ok_or(())?\n            } else {\n                return Err(());\n            };\n\n            // Insert the new character and increment the insert position.\n            insert(i, c)?;\n            i += 1;\n\n            // If there are no more deltas, decoding is complete.\n            if punycode_bytes.peek().is_none() {\n                return Ok(());\n            }\n\n            // Perform bias adaptation.\n            delta /= damp;\n            damp = 2;\n\n            delta += delta / len;\n            let mut k = 0;\n            while delta > ((base - t_min) * t_max) / 2 {\n                delta /= base - t_min;\n                k += base;\n            }\n            bias = k + ((base - t_min + 1) * delta) / (delta + skew);\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Ident::<'s>::try_small_punycode_decode":["/// Attempt to decode punycode on the stack (allocation-free),\n/// and pass the char slice to the closure, if successful.\n/// This supports up to `SMALL_PUNYCODE_LEN` characters.\nfn try_small_punycode_decode<F: FnOnce(&[char]) -> R, R>(&self, f: F) -> Option<R>{\n        let mut out = ['\\0'; SMALL_PUNYCODE_LEN];\n        let mut out_len = 0;\n        let r = self.punycode_decode(|i, c| {\n            // Check there's space left for another character.\n            out.get(out_len).ok_or(())?;\n\n            // Move the characters after the insert position.\n            let mut j = out_len;\n            out_len += 1;\n\n            while j > i {\n                out[j] = out[j - 1];\n                j -= 1;\n            }\n\n            // Insert the new character.\n            out[i] = c;\n\n            Ok(())\n        });\n        if r.is_ok() {\n            Some(f(&out[..out_len]))\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::ParseError":["pub enum ParseError {\n    /// Symbol doesn't match the expected `v0` grammar.\n    Invalid,\n\n    /// Parsing the symbol crossed the recursion limit (see `MAX_DEPTH`).\n    RecursedTooDeep,\n}","Real(LocalPath(\"src/v0.rs\"))"],"v0::ParseError::message":["/// Snippet to print when the error is initially encountered.\nfn message(&self) -> &str{\n        match self {\n            ParseError::Invalid => \"{invalid syntax}\",\n            ParseError::RecursedTooDeep => \"{recursion limit reached}\",\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser":["struct Parser<'s> {\n    sym: &'s str,\n    next: usize,\n    depth: u32,\n}","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::backref":["fn backref(&mut self) -> Result<Parser<'s>, ParseError>{\n        let s_start = self.next - 1;\n        let i = self.integer_62()?;\n        if i >= s_start as u64 {\n            return Err(ParseError::Invalid);\n        }\n        let mut new_parser = Parser {\n            sym: self.sym,\n            next: i as usize,\n            depth: self.depth,\n        };\n        new_parser.push_depth()?;\n        Ok(new_parser)\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::digit_10":["fn digit_10(&mut self) -> Result<u8, ParseError>{\n        let d = match self.peek() {\n            Some(d @ b'0'..=b'9') => d - b'0',\n            _ => return Err(ParseError::Invalid),\n        };\n        self.next += 1;\n        Ok(d)\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::digit_62":["fn digit_62(&mut self) -> Result<u8, ParseError>{\n        let d = match self.peek() {\n            Some(d @ b'0'..=b'9') => d - b'0',\n            Some(d @ b'a'..=b'z') => 10 + (d - b'a'),\n            Some(d @ b'A'..=b'Z') => 10 + 26 + (d - b'A'),\n            _ => return Err(ParseError::Invalid),\n        };\n        self.next += 1;\n        Ok(d)\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::disambiguator":["fn disambiguator(&mut self) -> Result<u64, ParseError>{\n        self.opt_integer_62(b's')\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::eat":["fn eat(&mut self, b: u8) -> bool{\n        if self.peek() == Some(b) {\n            self.next += 1;\n            true\n        } else {\n            false\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::hex_nibbles":["fn hex_nibbles(&mut self) -> Result<HexNibbles<'s>, ParseError>{\n        let start = self.next;\n        loop {\n            match self.next()? {\n                b'0'..=b'9' | b'a'..=b'f' => {}\n                b'_' => break,\n                _ => return Err(ParseError::Invalid),\n            }\n        }\n        Ok(HexNibbles {\n            nibbles: &self.sym[start..self.next - 1],\n        })\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::ident":["fn ident(&mut self) -> Result<Ident<'s>, ParseError>{\n        let is_punycode = self.eat(b'u');\n        let mut len = self.digit_10()? as usize;\n        if len != 0 {\n            while let Ok(d) = self.digit_10() {\n                len = len.checked_mul(10).ok_or(ParseError::Invalid)?;\n                len = len.checked_add(d as usize).ok_or(ParseError::Invalid)?;\n            }\n        }\n\n        // Skip past the optional `_` separator.\n        self.eat(b'_');\n\n        let start = self.next;\n        self.next = self.next.checked_add(len).ok_or(ParseError::Invalid)?;\n        if self.next > self.sym.len() {\n            return Err(ParseError::Invalid);\n        }\n\n        let ident = &self.sym[start..self.next];\n\n        if is_punycode {\n            let ident = match ident.bytes().rposition(|b| b == b'_') {\n                Some(i) => Ident {\n                    ascii: &ident[..i],\n                    punycode: &ident[i + 1..],\n                },\n                None => Ident {\n                    ascii: \"\",\n                    punycode: ident,\n                },\n            };\n            if ident.punycode.is_empty() {\n                return Err(ParseError::Invalid);\n            }\n            Ok(ident)\n        } else {\n            Ok(Ident {\n                ascii: ident,\n                punycode: \"\",\n            })\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::integer_62":["fn integer_62(&mut self) -> Result<u64, ParseError>{\n        if self.eat(b'_') {\n            return Ok(0);\n        }\n\n        let mut x: u64 = 0;\n        while !self.eat(b'_') {\n            let d = self.digit_62()? as u64;\n            x = x.checked_mul(62).ok_or(ParseError::Invalid)?;\n            x = x.checked_add(d).ok_or(ParseError::Invalid)?;\n        }\n        x.checked_add(1).ok_or(ParseError::Invalid)\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::namespace":["fn namespace(&mut self) -> Result<Option<char>, ParseError>{\n        match self.next()? {\n            // Special namespaces, like closures and shims.\n            ns @ b'A'..=b'Z' => Ok(Some(ns as char)),\n\n            // Implementation-specific/unspecified namespaces.\n            b'a'..=b'z' => Ok(None),\n\n            _ => Err(ParseError::Invalid),\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::next":["fn next(&mut self) -> Result<u8, ParseError>{\n        let b = self.peek().ok_or(ParseError::Invalid)?;\n        self.next += 1;\n        Ok(b)\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::opt_integer_62":["fn opt_integer_62(&mut self, tag: u8) -> Result<u64, ParseError>{\n        if !self.eat(tag) {\n            return Ok(0);\n        }\n        self.integer_62()?.checked_add(1).ok_or(ParseError::Invalid)\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::peek":["fn peek(&self) -> Option<u8>{\n        self.sym.as_bytes().get(self.next).cloned()\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::pop_depth":["fn pop_depth(&mut self){\n        self.depth -= 1;\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Parser::<'s>::push_depth":["fn push_depth(&mut self) -> Result<(), ParseError>{\n        self.depth += 1;\n        if self.depth > MAX_DEPTH {\n            Err(ParseError::RecursedTooDeep)\n        } else {\n            Ok(())\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer":["struct Printer<'a, 'b: 'a, 's> {\n    /// The input parser to demangle from, or `Err` if any (parse) error was\n    /// encountered (in order to disallow further likely-incorrect demangling).\n    ///\n    /// See also the documentation on the `invalid!` and `parse!` macros below.\n    parser: Result<Parser<'s>, ParseError>,\n\n    /// The output formatter to demangle to, or `None` while skipping printing.\n    out: Option<&'a mut fmt::Formatter<'b>>,\n\n    /// Cumulative number of lifetimes bound by `for<...>` binders ('G'),\n    /// anywhere \"around\" the current entity (e.g. type) being demangled.\n    /// This value is not tracked while skipping printing, as it'd be unused.\n    ///\n    /// See also the documentation on the `Printer::in_binder` method.\n    bound_lifetime_depth: u32,\n}","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::eat":["/// Eat the given character from the parser,\n/// returning `false` if the parser errored.\nfn eat(&mut self, b: u8) -> bool{\n        self.parser.as_mut().map(|p| p.eat(b)) == Ok(true)\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::in_binder":["/// Optionally enter a binder ('G') for late-bound lifetimes,\n/// printing e.g. `for<'a, 'b> ` before calling the closure,\n/// and make those lifetimes visible to it (via depth level).\nfn in_binder<F>(&mut self, f: F) -> fmt::Result\n    where\n        F: FnOnce(&mut Self) -> fmt::Result,{\n        let bound_lifetimes = parse!(self, opt_integer_62(b'G'));\n\n        // Don't track bound lifetimes when skipping printing.\n        if self.out.is_none() {\n            return f(self);\n        }\n\n        if bound_lifetimes > 0 {\n            self.print(\"for<\")?;\n            for i in 0..bound_lifetimes {\n                if i > 0 {\n                    self.print(\", \")?;\n                }\n                self.bound_lifetime_depth += 1;\n                self.print_lifetime_from_index(1)?;\n            }\n            self.print(\"> \")?;\n        }\n\n        let r = f(self);\n\n        // Restore `bound_lifetime_depth` to the previous value.\n        self.bound_lifetime_depth -= bound_lifetimes as u32;\n\n        r\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::pop_depth":["fn pop_depth(&mut self){\n        if let Ok(ref mut parser) = self.parser {\n            parser.pop_depth();\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print":["/// Output the given value to `self.out` (using `fmt::Display` formatting),\n/// if printing isn't being skipped.\nfn print(&mut self, x: impl fmt::Display) -> fmt::Result{\n        if let Some(out) = &mut self.out {\n            fmt::Display::fmt(&x, out)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print_backref":["/// Print the target of a backref, using the given closure.\n/// When printing is being skipped, the backref will only be parsed,\n/// ignoring the backref's target completely.\nfn print_backref<F>(&mut self, f: F) -> fmt::Result\n    where\n        F: FnOnce(&mut Self) -> fmt::Result,{\n        let backref_parser = parse!(self, backref);\n\n        if self.out.is_none() {\n            return Ok(());\n        }\n\n        let orig_parser = mem::replace(&mut self.parser, Ok(backref_parser));\n        let r = f(self);\n        self.parser = orig_parser;\n        r\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print_const":["fn print_const(&mut self, in_value: bool) -> fmt::Result{\n        let tag = parse!(self, next);\n\n        parse!(self, push_depth);\n\n        // Only literals (and the names of `const` generic parameters, but they\n        // don't get mangled at all), can appear in generic argument position\n        // without any disambiguation, all other expressions require braces.\n        // To avoid duplicating the mapping between `tag` and what syntax gets\n        // used (especially any special-casing), every case that needs braces\n        // has to call `open_brace(self)?` (and the closing brace is automatic).\n        let mut opened_brace = false;\n        let mut open_brace_if_outside_expr = |this: &mut Self| {\n            // If this expression is nested in another, braces aren't required.\n            if in_value {\n                return Ok(());\n            }\n\n            opened_brace = true;\n            this.print(\"{\")\n        };\n\n        match tag {\n            b'p' => self.print(\"_\")?,\n\n            // Primitive leaves with hex-encoded values (see `basic_type`).\n            b'h' | b't' | b'm' | b'y' | b'o' | b'j' => self.print_const_uint(tag)?,\n            b'a' | b's' | b'l' | b'x' | b'n' | b'i' => {\n                if self.eat(b'n') {\n                    self.print(\"-\")?;\n                }\n\n                self.print_const_uint(tag)?;\n            }\n            b'b' => match parse!(self, hex_nibbles).try_parse_uint() {\n                Some(0) => self.print(\"false\")?,\n                Some(1) => self.print(\"true\")?,\n                _ => invalid!(self),\n            },\n            b'c' => {\n                let valid_char = parse!(self, hex_nibbles)\n                    .try_parse_uint()\n                    .and_then(|v| u32::try_from(v).ok())\n                    .and_then(char::from_u32);\n                match valid_char {\n                    Some(c) => self.print_quoted_escaped_chars('\\'', iter::once(c))?,\n                    None => invalid!(self),\n                }\n            }\n            b'e' => {\n                // NOTE(eddyb) a string literal `\"...\"` has type `&str`, so\n                // to get back the type `str`, `*\"...\"` syntax is needed\n                // (even if that may not be valid in Rust itself).\n                open_brace_if_outside_expr(self)?;\n                self.print(\"*\")?;\n\n                self.print_const_str_literal()?;\n            }\n\n            b'R' | b'Q' => {\n                // NOTE(eddyb) this prints `\"...\"` instead of `&*\"...\"`, which\n                // is what `Re..._` would imply (see comment for `str` above).\n                if tag == b'R' && self.eat(b'e') {\n                    self.print_const_str_literal()?;\n                } else {\n                    open_brace_if_outside_expr(self)?;\n                    self.print(\"&\")?;\n                    if tag != b'R' {\n                        self.print(\"mut \")?;\n                    }\n                    self.print_const(true)?;\n                }\n            }\n            b'A' => {\n                open_brace_if_outside_expr(self)?;\n                self.print(\"[\")?;\n                self.print_sep_list(|this| this.print_const(true), \", \")?;\n                self.print(\"]\")?;\n            }\n            b'T' => {\n                open_brace_if_outside_expr(self)?;\n                self.print(\"(\")?;\n                let count = self.print_sep_list(|this| this.print_const(true), \", \")?;\n                if count == 1 {\n                    self.print(\",\")?;\n                }\n                self.print(\")\")?;\n            }\n            b'V' => {\n                open_brace_if_outside_expr(self)?;\n                self.print_path(true)?;\n                match parse!(self, next) {\n                    b'U' => {}\n                    b'T' => {\n                        self.print(\"(\")?;\n                        self.print_sep_list(|this| this.print_const(true), \", \")?;\n                        self.print(\")\")?;\n                    }\n                    b'S' => {\n                        self.print(\" { \")?;\n                        self.print_sep_list(\n                            |this| {\n                                parse!(this, disambiguator);\n                                let name = parse!(this, ident);\n                                this.print(name)?;\n                                this.print(\": \")?;\n                                this.print_const(true)\n                            },\n                            \", \",\n                        )?;\n                        self.print(\" }\")?;\n                    }\n                    _ => invalid!(self),\n                }\n            }\n            b'B' => {\n                self.print_backref(|this| this.print_const(in_value))?;\n            }\n            _ => invalid!(self),\n        }\n\n        if opened_brace {\n            self.print(\"}\")?;\n        }\n\n        self.pop_depth();\n        Ok(())\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print_const_str_literal":["fn print_const_str_literal(&mut self) -> fmt::Result{\n        match parse!(self, hex_nibbles).try_parse_str_chars() {\n            Some(chars) => self.print_quoted_escaped_chars('\"', chars),\n            None => invalid!(self),\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print_const_uint":["fn print_const_uint(&mut self, ty_tag: u8) -> fmt::Result{\n        let hex = parse!(self, hex_nibbles);\n\n        match hex.try_parse_uint() {\n            Some(v) => self.print(v)?,\n\n            // Print anything that doesn't fit in `u64` verbatim.\n            None => {\n                self.print(\"0x\")?;\n                self.print(hex.nibbles)?;\n            }\n        }\n\n        if let Some(out) = &mut self.out {\n            if !out.alternate() {\n                let ty = basic_type(ty_tag).unwrap();\n                self.print(ty)?;\n            }\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print_dyn_trait":["fn print_dyn_trait(&mut self) -> fmt::Result{\n        let mut open = self.print_path_maybe_open_generics()?;\n\n        while self.eat(b'p') {\n            if !open {\n                self.print(\"<\")?;\n                open = true;\n            } else {\n                self.print(\", \")?;\n            }\n\n            let name = parse!(self, ident);\n            self.print(name)?;\n            self.print(\" = \")?;\n            self.print_type()?;\n        }\n\n        if open {\n            self.print(\">\")?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print_generic_arg":["fn print_generic_arg(&mut self) -> fmt::Result{\n        if self.eat(b'L') {\n            let lt = parse!(self, integer_62);\n            self.print_lifetime_from_index(lt)\n        } else if self.eat(b'K') {\n            self.print_const(false)\n        } else {\n            self.print_type()\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print_lifetime_from_index":["/// Print the lifetime according to the previously decoded index.\n/// An index of `0` always refers to `'_`, but starting with `1`,\n/// indices refer to late-bound lifetimes introduced by a binder.\nfn print_lifetime_from_index(&mut self, lt: u64) -> fmt::Result{\n        // Bound lifetimes aren't tracked when skipping printing.\n        if self.out.is_none() {\n            return Ok(());\n        }\n\n        self.print(\"'\")?;\n        if lt == 0 {\n            return self.print(\"_\");\n        }\n        match (self.bound_lifetime_depth as u64).checked_sub(lt) {\n            Some(depth) => {\n                // Try to print lifetimes alphabetically first.\n                if depth < 26 {\n                    let c = (b'a' + depth as u8) as char;\n                    self.print(c)\n                } else {\n                    // Use `'_123` after running out of letters.\n                    self.print(\"_\")?;\n                    self.print(depth)\n                }\n            }\n            None => invalid!(self),\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print_path":["fn print_path(&mut self, in_value: bool) -> fmt::Result{\n        parse!(self, push_depth);\n\n        let tag = parse!(self, next);\n        match tag {\n            b'C' => {\n                let dis = parse!(self, disambiguator);\n                let name = parse!(self, ident);\n\n                self.print(name)?;\n                if let Some(out) = &mut self.out {\n                    if !out.alternate() {\n                        out.write_str(\"[\")?;\n                        fmt::LowerHex::fmt(&dis, out)?;\n                        out.write_str(\"]\")?;\n                    }\n                }\n            }\n            b'N' => {\n                let ns = parse!(self, namespace);\n\n                self.print_path(in_value)?;\n\n                // HACK(eddyb) if the parser is already marked as having errored,\n                // `parse!` below will print a `?` without its preceding `::`\n                // (because printing the `::` is skipped in certain conditions,\n                // i.e. a lowercase namespace with an empty identifier),\n                // so in order to get `::?`, the `::` has to be printed here.\n                if self.parser.is_err() {\n                    self.print(\"::\")?;\n                }\n\n                let dis = parse!(self, disambiguator);\n                let name = parse!(self, ident);\n\n                match ns {\n                    // Special namespaces, like closures and shims.\n                    Some(ns) => {\n                        self.print(\"::{\")?;\n                        match ns {\n                            'C' => self.print(\"closure\")?,\n                            'S' => self.print(\"shim\")?,\n                            _ => self.print(ns)?,\n                        }\n                        if !name.ascii.is_empty() || !name.punycode.is_empty() {\n                            self.print(\":\")?;\n                            self.print(name)?;\n                        }\n                        self.print(\"#\")?;\n                        self.print(dis)?;\n                        self.print(\"}\")?;\n                    }\n\n                    // Implementation-specific/unspecified namespaces.\n                    None => {\n                        if !name.ascii.is_empty() || !name.punycode.is_empty() {\n                            self.print(\"::\")?;\n                            self.print(name)?;\n                        }\n                    }\n                }\n            }\n            b'M' | b'X' | b'Y' => {\n                if tag != b'Y' {\n                    // Ignore the `impl`'s own path.\n                    parse!(self, disambiguator);\n                    self.skipping_printing(|this| this.print_path(false));\n                }\n\n                self.print(\"<\")?;\n                self.print_type()?;\n                if tag != b'M' {\n                    self.print(\" as \")?;\n                    self.print_path(false)?;\n                }\n                self.print(\">\")?;\n            }\n            b'I' => {\n                self.print_path(in_value)?;\n                if in_value {\n                    self.print(\"::\")?;\n                }\n                self.print(\"<\")?;\n                self.print_sep_list(Self::print_generic_arg, \", \")?;\n                self.print(\">\")?;\n            }\n            b'B' => {\n                self.print_backref(|this| this.print_path(in_value))?;\n            }\n            _ => invalid!(self),\n        }\n\n        self.pop_depth();\n        Ok(())\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print_path_maybe_open_generics":["/// A trait in a trait object may have some \"existential projections\"\n/// (i.e. associated type bindings) after it, which should be printed\n/// in the `<...>` of the trait, e.g. `dyn Trait<T, U, Assoc=X>`.\n/// To this end, this method will keep the `<...>` of an 'I' path\n/// open, by omitting the `>`, and return `Ok(true)` in that case.\nfn print_path_maybe_open_generics(&mut self) -> Result<bool, fmt::Error>{\n        if self.eat(b'B') {\n            // NOTE(eddyb) the closure may not run if printing is being skipped,\n            // but in that case the returned boolean doesn't matter.\n            let mut open = false;\n            self.print_backref(|this| {\n                open = this.print_path_maybe_open_generics()?;\n                Ok(())\n            })?;\n            Ok(open)\n        } else if self.eat(b'I') {\n            self.print_path(false)?;\n            self.print(\"<\")?;\n            self.print_sep_list(Self::print_generic_arg, \", \")?;\n            Ok(true)\n        } else {\n            self.print_path(false)?;\n            Ok(false)\n        }\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print_quoted_escaped_chars":["/// Output the given `char`s (escaped using `char::escape_debug`), with the\n/// whole sequence wrapped in quotes, for either a `char` or `&str` literal,\n/// if printing isn't being skipped.\nfn print_quoted_escaped_chars(\n        &mut self,\n        quote: char,\n        chars: impl Iterator<Item = char>,\n    ) -> fmt::Result{\n        if let Some(out) = &mut self.out {\n            use core::fmt::Write;\n\n            out.write_char(quote)?;\n            for c in chars {\n                // Special-case not escaping a single/double quote, when\n                // inside the opposite kind of quote.\n                if matches!((quote, c), ('\\'', '\"') | ('\"', '\\'')) {\n                    out.write_char(c)?;\n                    continue;\n                }\n\n                for escaped in c.escape_debug() {\n                    out.write_char(escaped)?;\n                }\n            }\n            out.write_char(quote)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print_sep_list":["/// Print list elements using the given closure and separator,\n/// until the end of the list ('E') is found, or the parser errors.\n/// Returns the number of elements printed.\nfn print_sep_list<F>(&mut self, f: F, sep: &str) -> Result<usize, fmt::Error>\n    where\n        F: Fn(&mut Self) -> fmt::Result,{\n        let mut i = 0;\n        while self.parser.is_ok() && !self.eat(b'E') {\n            if i > 0 {\n                self.print(sep)?;\n            }\n            f(self)?;\n            i += 1;\n        }\n        Ok(i)\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::print_type":["fn print_type(&mut self) -> fmt::Result{\n        let tag = parse!(self, next);\n\n        if let Some(ty) = basic_type(tag) {\n            return self.print(ty);\n        }\n\n        parse!(self, push_depth);\n\n        match tag {\n            b'R' | b'Q' => {\n                self.print(\"&\")?;\n                if self.eat(b'L') {\n                    let lt = parse!(self, integer_62);\n                    if lt != 0 {\n                        self.print_lifetime_from_index(lt)?;\n                        self.print(\" \")?;\n                    }\n                }\n                if tag != b'R' {\n                    self.print(\"mut \")?;\n                }\n                self.print_type()?;\n            }\n\n            b'P' | b'O' => {\n                self.print(\"*\")?;\n                if tag != b'P' {\n                    self.print(\"mut \")?;\n                } else {\n                    self.print(\"const \")?;\n                }\n                self.print_type()?;\n            }\n\n            b'A' | b'S' => {\n                self.print(\"[\")?;\n                self.print_type()?;\n                if tag == b'A' {\n                    self.print(\"; \")?;\n                    self.print_const(true)?;\n                }\n                self.print(\"]\")?;\n            }\n            b'T' => {\n                self.print(\"(\")?;\n                let count = self.print_sep_list(Self::print_type, \", \")?;\n                if count == 1 {\n                    self.print(\",\")?;\n                }\n                self.print(\")\")?;\n            }\n            b'F' => self.in_binder(|this| {\n                let is_unsafe = this.eat(b'U');\n                let abi = if this.eat(b'K') {\n                    if this.eat(b'C') {\n                        Some(\"C\")\n                    } else {\n                        let abi = parse!(this, ident);\n                        if abi.ascii.is_empty() || !abi.punycode.is_empty() {\n                            invalid!(this);\n                        }\n                        Some(abi.ascii)\n                    }\n                } else {\n                    None\n                };\n\n                if is_unsafe {\n                    this.print(\"unsafe \")?;\n                }\n\n                if let Some(abi) = abi {\n                    this.print(\"extern \\\"\")?;\n\n                    // If the ABI had any `-`, they were replaced with `_`,\n                    // so the parts between `_` have to be re-joined with `-`.\n                    let mut parts = abi.split('_');\n                    this.print(parts.next().unwrap())?;\n                    for part in parts {\n                        this.print(\"-\")?;\n                        this.print(part)?;\n                    }\n\n                    this.print(\"\\\" \")?;\n                }\n\n                this.print(\"fn(\")?;\n                this.print_sep_list(Self::print_type, \", \")?;\n                this.print(\")\")?;\n\n                if this.eat(b'u') {\n                    // Skip printing the return type if it's 'u', i.e. `()`.\n                } else {\n                    this.print(\" -> \")?;\n                    this.print_type()?;\n                }\n\n                Ok(())\n            })?,\n            b'D' => {\n                self.print(\"dyn \")?;\n                self.in_binder(|this| {\n                    this.print_sep_list(Self::print_dyn_trait, \" + \")?;\n                    Ok(())\n                })?;\n\n                if !self.eat(b'L') {\n                    invalid!(self);\n                }\n                let lt = parse!(self, integer_62);\n                if lt != 0 {\n                    self.print(\" + \")?;\n                    self.print_lifetime_from_index(lt)?;\n                }\n            }\n            b'B' => {\n                self.print_backref(Self::print_type)?;\n            }\n            _ => {\n                // Go back to the tag, so `print_path` also sees it.\n                let _ = self.parser.as_mut().map(|p| p.next -= 1);\n                self.print_path(false)?;\n            }\n        }\n\n        self.pop_depth();\n        Ok(())\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::Printer::<'a, 'b, 's>::skipping_printing":["/// Skip printing (i.e. `self.out` will be `None`) for the duration of the\n/// given closure. This should not change parsing behavior, only disable the\n/// output, but there may be optimizations (such as not traversing backrefs).\nfn skipping_printing<F>(&mut self, f: F)\n    where\n        F: FnOnce(&mut Self) -> fmt::Result,{\n        let orig_out = self.out.take();\n        f(self).expect(\"`fmt::Error`s should be impossible without a `fmt::Formatter`\");\n        self.out = orig_out;\n    }","Real(LocalPath(\"src/v0.rs\"))"],"v0::basic_type":["fn basic_type(tag: u8) -> Option<&'static str>{\n    Some(match tag {\n        b'b' => \"bool\",\n        b'c' => \"char\",\n        b'e' => \"str\",\n        b'u' => \"()\",\n        b'a' => \"i8\",\n        b's' => \"i16\",\n        b'l' => \"i32\",\n        b'x' => \"i64\",\n        b'n' => \"i128\",\n        b'i' => \"isize\",\n        b'h' => \"u8\",\n        b't' => \"u16\",\n        b'm' => \"u32\",\n        b'y' => \"u64\",\n        b'o' => \"u128\",\n        b'j' => \"usize\",\n        b'f' => \"f32\",\n        b'd' => \"f64\",\n        b'z' => \"!\",\n        b'p' => \"_\",\n        b'v' => \"...\",\n\n        _ => return None,\n    })\n}","Real(LocalPath(\"src/v0.rs\"))"],"v0::demangle":["/// De-mangles a Rust symbol into a more readable version\n///\n/// This function will take a **mangled** symbol and return a value. When printed,\n/// the de-mangled version will be written. If the symbol does not look like\n/// a mangled symbol, the original value will be written instead.\npub fn demangle(s: &str) -> Result<(Demangle, &str), ParseError>{\n    // First validate the symbol. If it doesn't look like anything we're\n    // expecting, we just print it literally. Note that we must handle non-Rust\n    // symbols because we could have any function in the backtrace.\n    let inner;\n    if s.len() > 2 && s.starts_with(\"_R\") {\n        inner = &s[2..];\n    } else if s.len() > 1 && s.starts_with('R') {\n        // On Windows, dbghelp strips leading underscores, so we accept \"R...\"\n        // form too.\n        inner = &s[1..];\n    } else if s.len() > 3 && s.starts_with(\"__R\") {\n        // On OSX, symbols are prefixed with an extra _\n        inner = &s[3..];\n    } else {\n        return Err(ParseError::Invalid);\n    }\n\n    // Paths always start with uppercase characters.\n    match inner.as_bytes()[0] {\n        b'A'..=b'Z' => {}\n        _ => return Err(ParseError::Invalid),\n    }\n\n    // only work with ascii text\n    if inner.bytes().any(|c| c & 0x80 != 0) {\n        return Err(ParseError::Invalid);\n    }\n\n    // Verify that the symbol is indeed a valid path.\n    let try_parse_path = |parser| {\n        let mut dummy_printer = Printer {\n            parser: Ok(parser),\n            out: None,\n            bound_lifetime_depth: 0,\n        };\n        dummy_printer\n            .print_path(false)\n            .expect(\"`fmt::Error`s should be impossible without a `fmt::Formatter`\");\n        dummy_printer.parser\n    };\n    let mut parser = Parser {\n        sym: inner,\n        next: 0,\n        depth: 0,\n    };\n    parser = try_parse_path(parser)?;\n\n    // Instantiating crate (paths always start with uppercase characters).\n    if let Some(&(b'A'..=b'Z')) = parser.sym.as_bytes().get(parser.next) {\n        parser = try_parse_path(parser)?;\n    }\n\n    Ok((Demangle { inner }, &parser.sym[parser.next..]))\n}","Real(LocalPath(\"src/v0.rs\"))"]},"struct_constructor":{"&'a str":["as_str"],"&str":["message"],"Demangle":["demangle"],"SizeLimitExhausted":["clone"],"TryDemangleError":["clone"],"bool":["eat","eq","is_ascii_alphanumeric","is_ascii_punctuation","is_rust_hash","is_symbol_like"],"core::option::Option":["basic_type","peek","try_parse_str_chars","try_parse_uint","try_small_punycode_decode"],"core::result::Result":["backref","demangle","digit_10","digit_62","disambiguator","fmt","hex_nibbles","ident","in_binder","integer_62","namespace","next","opt_integer_62","print","print_backref","print_const","print_const_str_literal","print_const_uint","print_dyn_trait","print_generic_arg","print_lifetime_from_index","print_path","print_path_maybe_open_generics","print_quoted_escaped_chars","print_sep_list","print_type","punycode_decode","push_depth","try_demangle","utf8_len_from_first_byte","write_str"]},"struct_to_trait":{"Demangle":["core::fmt::Debug","core::fmt::Display"],"DemangleStyle":["core::fmt::Display"],"SizeLimitExhausted":["core::clone::Clone","core::fmt::Debug","core::marker::Copy"],"SizeLimitedFmtAdapter":["core::fmt::Write"],"TryDemangleError":["core::clone::Clone","core::fmt::Debug"],"legacy::Demangle":["core::fmt::Display"],"v0::Demangle":["core::fmt::Display"],"v0::Ident":["core::fmt::Display"],"v0::ParseError":["core::cmp::Eq","core::cmp::PartialEq","core::fmt::Debug","core::marker::StructuralEq","core::marker::StructuralPartialEq"]},"targets":{"<Demangle<'a> as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Debug"],"<Demangle<'a> as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Display"],"<DemangleStyle<'a> as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Display"],"<SizeLimitedFmtAdapter<F> as core::fmt::Write>::write_str":["write_str","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Write"],"<legacy::Demangle<'a> as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/legacy.rs\"))","core::fmt::Display"],"<v0::Demangle<'s> as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/v0.rs\"))","core::fmt::Display"],"<v0::Ident<'s> as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/v0.rs\"))","core::fmt::Display"],"Demangle::<'a>::as_str":["as_str","Real(LocalPath(\"src/lib.rs\"))",""],"demangle":["demangle","Real(LocalPath(\"src/lib.rs\"))",""],"is_ascii_alphanumeric":["is_ascii_alphanumeric","Real(LocalPath(\"src/lib.rs\"))",""],"is_ascii_punctuation":["is_ascii_punctuation","Real(LocalPath(\"src/lib.rs\"))",""],"is_symbol_like":["is_symbol_like","Real(LocalPath(\"src/lib.rs\"))",""],"legacy::demangle":["demangle","Real(LocalPath(\"src/legacy.rs\"))",""],"legacy::is_rust_hash":["is_rust_hash","Real(LocalPath(\"src/legacy.rs\"))",""],"try_demangle":["try_demangle","Real(LocalPath(\"src/lib.rs\"))",""],"v0::HexNibbles::<'s>::try_parse_str_chars":["try_parse_str_chars","Real(LocalPath(\"src/v0.rs\"))",""],"v0::HexNibbles::<'s>::try_parse_str_chars::{closure#2}::{closure#0}::utf8_len_from_first_byte":["utf8_len_from_first_byte","Real(LocalPath(\"src/v0.rs\"))",""],"v0::HexNibbles::<'s>::try_parse_uint":["try_parse_uint","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Ident::<'s>::punycode_decode":["punycode_decode","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Ident::<'s>::try_small_punycode_decode":["try_small_punycode_decode","Real(LocalPath(\"src/v0.rs\"))",""],"v0::ParseError::message":["message","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::backref":["backref","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::digit_10":["digit_10","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::digit_62":["digit_62","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::disambiguator":["disambiguator","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::eat":["eat","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::hex_nibbles":["hex_nibbles","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::ident":["ident","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::integer_62":["integer_62","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::namespace":["namespace","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::next":["next","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::opt_integer_62":["opt_integer_62","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::peek":["peek","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::pop_depth":["pop_depth","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Parser::<'s>::push_depth":["push_depth","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::eat":["eat","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::in_binder":["in_binder","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::pop_depth":["pop_depth","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print":["print","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print_backref":["print_backref","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print_const":["print_const","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print_const_str_literal":["print_const_str_literal","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print_const_uint":["print_const_uint","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print_dyn_trait":["print_dyn_trait","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print_generic_arg":["print_generic_arg","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print_lifetime_from_index":["print_lifetime_from_index","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print_path":["print_path","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print_path_maybe_open_generics":["print_path_maybe_open_generics","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print_quoted_escaped_chars":["print_quoted_escaped_chars","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print_sep_list":["print_sep_list","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::print_type":["print_type","Real(LocalPath(\"src/v0.rs\"))",""],"v0::Printer::<'a, 'b, 's>::skipping_printing":["skipping_printing","Real(LocalPath(\"src/v0.rs\"))",""],"v0::basic_type":["basic_type","Real(LocalPath(\"src/v0.rs\"))",""],"v0::demangle":["demangle","Real(LocalPath(\"src/v0.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["SizeLimitExhausted","TryDemangleError"],"core::cmp::Eq":["v0::ParseError"],"core::cmp::PartialEq":["v0::ParseError"],"core::fmt::Debug":["Demangle","SizeLimitExhausted","TryDemangleError","v0::ParseError"],"core::fmt::Display":["Demangle","DemangleStyle","legacy::Demangle","v0::Demangle","v0::Ident"],"core::fmt::Write":["SizeLimitedFmtAdapter"],"core::marker::Copy":["SizeLimitExhausted"],"core::marker::StructuralEq":["v0::ParseError"],"core::marker::StructuralPartialEq":["v0::ParseError"]},"type_to_def_path":{"Demangle<'a>":"Demangle","DemangleStyle<'a>":"DemangleStyle","SizeLimitExhausted":"SizeLimitExhausted","SizeLimitedFmtAdapter<F>":"SizeLimitedFmtAdapter","TryDemangleError":"TryDemangleError","legacy::Demangle<'a>":"legacy::Demangle","v0::Demangle<'a>":"v0::Demangle","v0::HexNibbles<'s>":"v0::HexNibbles","v0::HexNibbles<'s>::try_parse_str_chars::{closure#2}::{closure#0}::Utf8FirstByteError":"v0::HexNibbles<'s>::try_parse_str_chars::{closure#2}::{closure#0}::Utf8FirstByteError","v0::Ident<'s>":"v0::Ident","v0::ParseError":"v0::ParseError","v0::Parser<'s>":"v0::Parser","v0::Printer<'a, 'b, 's>":"v0::Printer"}}