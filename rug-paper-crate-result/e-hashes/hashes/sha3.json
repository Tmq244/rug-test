{"dependencies":{"<CShake128Core as core::clone::Clone>::clone":["CShake128Core","state::Sha3State"],"<CShake128Core as core::fmt::Debug>::fmt":["CShake128Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<CShake128Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<CShake128Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["CShake128Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<CShake128Core as digest::core_api::UpdateCore>::update_blocks":["CShake128Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<CShake128ReaderCore as core::clone::Clone>::clone":["CShake128ReaderCore","state::Sha3State"],"<CShake128ReaderCore as digest::core_api::XofReaderCore>::read_block":["CShake128ReaderCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<CShake256Core as core::clone::Clone>::clone":["CShake256Core","state::Sha3State"],"<CShake256Core as core::fmt::Debug>::fmt":["CShake256Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<CShake256Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<CShake256Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["CShake256Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<CShake256Core as digest::core_api::UpdateCore>::update_blocks":["CShake256Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<CShake256ReaderCore as core::clone::Clone>::clone":["CShake256ReaderCore","state::Sha3State"],"<CShake256ReaderCore as digest::core_api::XofReaderCore>::read_block":["CShake256ReaderCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Keccak224Core as core::clone::Clone>::clone":["Keccak224Core","state::Sha3State"],"<Keccak224Core as core::default::Default>::default":["Keccak224Core","state::Sha3State"],"<Keccak224Core as core::fmt::Debug>::fmt":["Keccak224Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<Keccak224Core as digest::Reset>::reset":["Keccak224Core","state::Sha3State"],"<Keccak224Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Keccak224Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Keccak224Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<Keccak224Core as digest::core_api::UpdateCore>::update_blocks":["Keccak224Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Keccak256Core as core::clone::Clone>::clone":["Keccak256Core","state::Sha3State"],"<Keccak256Core as core::default::Default>::default":["Keccak256Core","state::Sha3State"],"<Keccak256Core as core::fmt::Debug>::fmt":["Keccak256Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<Keccak256Core as digest::Reset>::reset":["Keccak256Core","state::Sha3State"],"<Keccak256Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Keccak256Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Keccak256Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<Keccak256Core as digest::core_api::UpdateCore>::update_blocks":["Keccak256Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Keccak256FullCore as core::clone::Clone>::clone":["Keccak256FullCore","state::Sha3State"],"<Keccak256FullCore as core::default::Default>::default":["Keccak256FullCore","state::Sha3State"],"<Keccak256FullCore as core::fmt::Debug>::fmt":["Keccak256FullCore","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<Keccak256FullCore as digest::Reset>::reset":["Keccak256FullCore","state::Sha3State"],"<Keccak256FullCore as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Keccak256FullCore as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Keccak256FullCore","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<Keccak256FullCore as digest::core_api::UpdateCore>::update_blocks":["Keccak256FullCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Keccak384Core as core::clone::Clone>::clone":["Keccak384Core","state::Sha3State"],"<Keccak384Core as core::default::Default>::default":["Keccak384Core","state::Sha3State"],"<Keccak384Core as core::fmt::Debug>::fmt":["Keccak384Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<Keccak384Core as digest::Reset>::reset":["Keccak384Core","state::Sha3State"],"<Keccak384Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Keccak384Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Keccak384Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<Keccak384Core as digest::core_api::UpdateCore>::update_blocks":["Keccak384Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Keccak512Core as core::clone::Clone>::clone":["Keccak512Core","state::Sha3State"],"<Keccak512Core as core::default::Default>::default":["Keccak512Core","state::Sha3State"],"<Keccak512Core as core::fmt::Debug>::fmt":["Keccak512Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<Keccak512Core as digest::Reset>::reset":["Keccak512Core","state::Sha3State"],"<Keccak512Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Keccak512Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Keccak512Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<Keccak512Core as digest::core_api::UpdateCore>::update_blocks":["Keccak512Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Sha3_224Core as core::clone::Clone>::clone":["Sha3_224Core","state::Sha3State"],"<Sha3_224Core as core::default::Default>::default":["Sha3_224Core","state::Sha3State"],"<Sha3_224Core as core::fmt::Debug>::fmt":["Sha3_224Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<Sha3_224Core as digest::Reset>::reset":["Sha3_224Core","state::Sha3State"],"<Sha3_224Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Sha3_224Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Sha3_224Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<Sha3_224Core as digest::core_api::UpdateCore>::update_blocks":["Sha3_224Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Sha3_256Core as core::clone::Clone>::clone":["Sha3_256Core","state::Sha3State"],"<Sha3_256Core as core::default::Default>::default":["Sha3_256Core","state::Sha3State"],"<Sha3_256Core as core::fmt::Debug>::fmt":["Sha3_256Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<Sha3_256Core as digest::Reset>::reset":["Sha3_256Core","state::Sha3State"],"<Sha3_256Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Sha3_256Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Sha3_256Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<Sha3_256Core as digest::core_api::UpdateCore>::update_blocks":["Sha3_256Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Sha3_384Core as core::clone::Clone>::clone":["Sha3_384Core","state::Sha3State"],"<Sha3_384Core as core::default::Default>::default":["Sha3_384Core","state::Sha3State"],"<Sha3_384Core as core::fmt::Debug>::fmt":["Sha3_384Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<Sha3_384Core as digest::Reset>::reset":["Sha3_384Core","state::Sha3State"],"<Sha3_384Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Sha3_384Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Sha3_384Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<Sha3_384Core as digest::core_api::UpdateCore>::update_blocks":["Sha3_384Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Sha3_512Core as core::clone::Clone>::clone":["Sha3_512Core","state::Sha3State"],"<Sha3_512Core as core::default::Default>::default":["Sha3_512Core","state::Sha3State"],"<Sha3_512Core as core::fmt::Debug>::fmt":["Sha3_512Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<Sha3_512Core as digest::Reset>::reset":["Sha3_512Core","state::Sha3State"],"<Sha3_512Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Sha3_512Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Sha3_512Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<Sha3_512Core as digest::core_api::UpdateCore>::update_blocks":["Sha3_512Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Shake128Core as core::clone::Clone>::clone":["Shake128Core","state::Sha3State"],"<Shake128Core as core::default::Default>::default":["Shake128Core","state::Sha3State"],"<Shake128Core as core::fmt::Debug>::fmt":["Shake128Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<Shake128Core as digest::Reset>::reset":["Shake128Core","state::Sha3State"],"<Shake128Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Shake128Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["Shake128Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<Shake128Core as digest::core_api::UpdateCore>::update_blocks":["Shake128Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Shake128ReaderCore as core::clone::Clone>::clone":["Shake128ReaderCore","state::Sha3State"],"<Shake128ReaderCore as digest::core_api::XofReaderCore>::read_block":["Shake128ReaderCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Shake256Core as core::clone::Clone>::clone":["Shake256Core","state::Sha3State"],"<Shake256Core as core::default::Default>::default":["Shake256Core","state::Sha3State"],"<Shake256Core as core::fmt::Debug>::fmt":["Shake256Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<Shake256Core as digest::Reset>::reset":["Shake256Core","state::Sha3State"],"<Shake256Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Shake256Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["Shake256Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<Shake256Core as digest::core_api::UpdateCore>::update_blocks":["Shake256Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<Shake256ReaderCore as core::clone::Clone>::clone":["Shake256ReaderCore","state::Sha3State"],"<Shake256ReaderCore as digest::core_api::XofReaderCore>::read_block":["Shake256ReaderCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<TurboShake128Core as core::clone::Clone>::clone":["TurboShake128Core","state::Sha3State"],"<TurboShake128Core as core::fmt::Debug>::fmt":["TurboShake128Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<TurboShake128Core as digest::Reset>::reset":["TurboShake128Core","state::Sha3State"],"<TurboShake128Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<TurboShake128Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["TurboShake128Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<TurboShake128Core as digest::core_api::UpdateCore>::update_blocks":["TurboShake128Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<TurboShake128ReaderCore as core::clone::Clone>::clone":["TurboShake128ReaderCore","state::Sha3State"],"<TurboShake128ReaderCore as digest::core_api::XofReaderCore>::read_block":["TurboShake128ReaderCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<TurboShake256Core as core::clone::Clone>::clone":["TurboShake256Core","state::Sha3State"],"<TurboShake256Core as core::fmt::Debug>::fmt":["TurboShake256Core","core::fmt::Formatter","core::marker::Sized","core::result::Result","state::Sha3State"],"<TurboShake256Core as digest::Reset>::reset":["TurboShake256Core","state::Sha3State"],"<TurboShake256Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<TurboShake256Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["TurboShake256Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::typenum::IsLess","digest::typenum::NonZero","state::Sha3State"],"<TurboShake256Core as digest::core_api::UpdateCore>::update_blocks":["TurboShake256Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<TurboShake256ReaderCore as core::clone::Clone>::clone":["TurboShake256ReaderCore","state::Sha3State"],"<TurboShake256ReaderCore as digest::core_api::XofReaderCore>::read_block":["TurboShake256ReaderCore","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","state::Sha3State"],"<state::Sha3State as core::clone::Clone>::clone":["state::Sha3State"],"<state::Sha3State as core::default::Default>::default":["state::Sha3State"],"CShake128Core":["CShake128Core","state::Sha3State"],"CShake128Core::new":["CShake128Core","state::Sha3State"],"CShake128Core::new_with_function_name":["CShake128Core","state::Sha3State"],"CShake128ReaderCore":["CShake128ReaderCore","state::Sha3State"],"CShake256Core":["CShake256Core","state::Sha3State"],"CShake256Core::new":["CShake256Core","state::Sha3State"],"CShake256Core::new_with_function_name":["CShake256Core","state::Sha3State"],"CShake256ReaderCore":["CShake256ReaderCore","state::Sha3State"],"Keccak224Core":["Keccak224Core","state::Sha3State"],"Keccak256Core":["Keccak256Core","state::Sha3State"],"Keccak256FullCore":["Keccak256FullCore","state::Sha3State"],"Keccak384Core":["Keccak384Core","state::Sha3State"],"Keccak512Core":["Keccak512Core","state::Sha3State"],"Sha3_224Core":["Sha3_224Core","state::Sha3State"],"Sha3_256Core":["Sha3_256Core","state::Sha3State"],"Sha3_384Core":["Sha3_384Core","state::Sha3State"],"Sha3_512Core":["Sha3_512Core","state::Sha3State"],"Shake128Core":["Shake128Core","state::Sha3State"],"Shake128ReaderCore":["Shake128ReaderCore","state::Sha3State"],"Shake256Core":["Shake256Core","state::Sha3State"],"Shake256ReaderCore":["Shake256ReaderCore","state::Sha3State"],"TurboShake128Core":["TurboShake128Core","state::Sha3State"],"TurboShake128Core::new":["TurboShake128Core","state::Sha3State"],"TurboShake128ReaderCore":["TurboShake128ReaderCore","state::Sha3State"],"TurboShake256Core":["TurboShake256Core","state::Sha3State"],"TurboShake256Core::new":["TurboShake256Core","state::Sha3State"],"TurboShake256ReaderCore":["TurboShake256ReaderCore","state::Sha3State"],"left_encode":[],"state::Sha3State":["state::Sha3State"],"state::Sha3State::absorb_block":["state::Sha3State"],"state::Sha3State::as_bytes":["state::Sha3State"],"state::Sha3State::new":["state::Sha3State"],"state::Sha3State::permute":["state::Sha3State"]},"glob_path_import":{},"self_to_fn":{"CShake128Core":["Clone","impl $name {\n            /// Creates a new CSHAKE instance with the given customization.\n            pub fn new(customization: &[u8]) -> Self {\n                Self::new_with_function_name(&[], customization)\n            }\n\n            /// Creates a new CSHAKE instance with the given function name and customization.\n            /// Note that the function name is intended for use by NIST and should only be set to\n            /// values defined by NIST. You probably don't need to use this function.\n            pub fn new_with_function_name(function_name: &[u8], customization: &[u8]) -> Self {\n                let mut state = Sha3State::default();\n                if function_name.is_empty() && customization.is_empty() {\n                    return Self {\n                        padding: $shake_pad,\n                        state: state.clone(),\n                        #[cfg(feature = \"reset\")]\n                        initial_state: state,\n                    };\n                }\n\n                let mut buffer = Buffer::<Self>::default();\n                let mut b = [0u8; 9];\n                buffer.digest_blocks(left_encode($rate::to_u64(), &mut b), |blocks| {\n                    for block in blocks {\n                        state.absorb_block(block);\n                    }\n                });\n                buffer.digest_blocks(\n                    left_encode((function_name.len() * 8) as u64, &mut b),\n                    |blocks| {\n                        for block in blocks {\n                            state.absorb_block(block);\n                        }\n                    },\n                );\n                buffer.digest_blocks(function_name, |blocks| {\n                    for block in blocks {\n                        state.absorb_block(block);\n                    }\n                });\n                buffer.digest_blocks(\n                    left_encode((customization.len() * 8) as u64, &mut b),\n                    |blocks| {\n                        for block in blocks {\n                            state.absorb_block(block);\n                        }\n                    },\n                );\n                buffer.digest_blocks(customization, |blocks| {\n                    for block in blocks {\n                        state.absorb_block(block);\n                    }\n                });\n                state.absorb_block(buffer.pad_with_zeros());\n\n                Self {\n                    padding: $cshake_pad,\n                    state: state.clone(),\n                    #[cfg(feature = \"reset\")]\n                    initial_state: state,\n                }\n            }\n        }","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl ExtendableOutputCore for $name {\n            type ReaderCore = $reader;\n\n            #[inline]\n            fn finalize_xof_core(&mut self, buffer: &mut Buffer<Self>) -> Self::ReaderCore {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = self.padding;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n                $reader {\n                    state: self.state.clone(),\n                }\n            }\n        }","impl HashMarker for $name {}","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"CShake128ReaderCore":["Clone","impl BlockSizeUser for $reader {\n            type BlockSize = $rate;\n        }","impl XofReaderCore for $reader {\n            #[inline]\n            fn read_block(&mut self) -> Block<Self> {\n                let mut block = Block::<Self>::default();\n                self.state.as_bytes(&mut block);\n                self.state.permute();\n                block\n            }\n        }"],"CShake256Core":["Clone","impl $name {\n            /// Creates a new CSHAKE instance with the given customization.\n            pub fn new(customization: &[u8]) -> Self {\n                Self::new_with_function_name(&[], customization)\n            }\n\n            /// Creates a new CSHAKE instance with the given function name and customization.\n            /// Note that the function name is intended for use by NIST and should only be set to\n            /// values defined by NIST. You probably don't need to use this function.\n            pub fn new_with_function_name(function_name: &[u8], customization: &[u8]) -> Self {\n                let mut state = Sha3State::default();\n                if function_name.is_empty() && customization.is_empty() {\n                    return Self {\n                        padding: $shake_pad,\n                        state: state.clone(),\n                        #[cfg(feature = \"reset\")]\n                        initial_state: state,\n                    };\n                }\n\n                let mut buffer = Buffer::<Self>::default();\n                let mut b = [0u8; 9];\n                buffer.digest_blocks(left_encode($rate::to_u64(), &mut b), |blocks| {\n                    for block in blocks {\n                        state.absorb_block(block);\n                    }\n                });\n                buffer.digest_blocks(\n                    left_encode((function_name.len() * 8) as u64, &mut b),\n                    |blocks| {\n                        for block in blocks {\n                            state.absorb_block(block);\n                        }\n                    },\n                );\n                buffer.digest_blocks(function_name, |blocks| {\n                    for block in blocks {\n                        state.absorb_block(block);\n                    }\n                });\n                buffer.digest_blocks(\n                    left_encode((customization.len() * 8) as u64, &mut b),\n                    |blocks| {\n                        for block in blocks {\n                            state.absorb_block(block);\n                        }\n                    },\n                );\n                buffer.digest_blocks(customization, |blocks| {\n                    for block in blocks {\n                        state.absorb_block(block);\n                    }\n                });\n                state.absorb_block(buffer.pad_with_zeros());\n\n                Self {\n                    padding: $cshake_pad,\n                    state: state.clone(),\n                    #[cfg(feature = \"reset\")]\n                    initial_state: state,\n                }\n            }\n        }","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl ExtendableOutputCore for $name {\n            type ReaderCore = $reader;\n\n            #[inline]\n            fn finalize_xof_core(&mut self, buffer: &mut Buffer<Self>) -> Self::ReaderCore {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = self.padding;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n                $reader {\n                    state: self.state.clone(),\n                }\n            }\n        }","impl HashMarker for $name {}","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"CShake256ReaderCore":["Clone","impl BlockSizeUser for $reader {\n            type BlockSize = $rate;\n        }","impl XofReaderCore for $reader {\n            #[inline]\n            fn read_block(&mut self) -> Block<Self> {\n                let mut block = Block::<Self>::default();\n                self.state.as_bytes(&mut block);\n                self.state.permute();\n                block\n            }\n        }"],"Keccak224Core":["Clone","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl Default for $name {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    state: Default::default(),\n                }\n            }\n        }","impl FixedOutputCore for $name {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }\n        }","impl HashMarker for $name {}","impl OutputSizeUser for $name {\n            type OutputSize = $output_size;\n        }","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"Keccak256Core":["Clone","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl Default for $name {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    state: Default::default(),\n                }\n            }\n        }","impl FixedOutputCore for $name {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }\n        }","impl HashMarker for $name {}","impl OutputSizeUser for $name {\n            type OutputSize = $output_size;\n        }","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"Keccak256FullCore":["Clone","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl Default for $name {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    state: Default::default(),\n                }\n            }\n        }","impl FixedOutputCore for $name {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }\n        }","impl HashMarker for $name {}","impl OutputSizeUser for $name {\n            type OutputSize = $output_size;\n        }","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"Keccak384Core":["Clone","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl Default for $name {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    state: Default::default(),\n                }\n            }\n        }","impl FixedOutputCore for $name {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }\n        }","impl HashMarker for $name {}","impl OutputSizeUser for $name {\n            type OutputSize = $output_size;\n        }","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"Keccak512Core":["Clone","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl Default for $name {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    state: Default::default(),\n                }\n            }\n        }","impl FixedOutputCore for $name {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }\n        }","impl HashMarker for $name {}","impl OutputSizeUser for $name {\n            type OutputSize = $output_size;\n        }","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"Sha3_224Core":["Clone","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl Default for $name {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    state: Default::default(),\n                }\n            }\n        }","impl FixedOutputCore for $name {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }\n        }","impl HashMarker for $name {}","impl OutputSizeUser for $name {\n            type OutputSize = $output_size;\n        }","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"Sha3_256Core":["Clone","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl Default for $name {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    state: Default::default(),\n                }\n            }\n        }","impl FixedOutputCore for $name {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }\n        }","impl HashMarker for $name {}","impl OutputSizeUser for $name {\n            type OutputSize = $output_size;\n        }","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"Sha3_384Core":["Clone","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl Default for $name {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    state: Default::default(),\n                }\n            }\n        }","impl FixedOutputCore for $name {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }\n        }","impl HashMarker for $name {}","impl OutputSizeUser for $name {\n            type OutputSize = $output_size;\n        }","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"Sha3_512Core":["Clone","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl Default for $name {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    state: Default::default(),\n                }\n            }\n        }","impl FixedOutputCore for $name {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }\n        }","impl HashMarker for $name {}","impl OutputSizeUser for $name {\n            type OutputSize = $output_size;\n        }","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"Shake128Core":["Clone","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl Default for $name {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    state: Default::default(),\n                }\n            }\n        }","impl ExtendableOutputCore for $name {\n            type ReaderCore = $reader;\n\n            #[inline]\n            fn finalize_xof_core(&mut self, buffer: &mut Buffer<Self>) -> Self::ReaderCore {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n                $reader {\n                    state: self.state.clone(),\n                }\n            }\n        }","impl HashMarker for $name {}","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"Shake128ReaderCore":["Clone","impl BlockSizeUser for $reader {\n            type BlockSize = $rate;\n        }","impl XofReaderCore for $reader {\n            #[inline]\n            fn read_block(&mut self) -> Block<Self> {\n                let mut block = Block::<Self>::default();\n                self.state.as_bytes(&mut block);\n                self.state.permute();\n                block\n            }\n        }"],"Shake256Core":["Clone","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl Default for $name {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    state: Default::default(),\n                }\n            }\n        }","impl ExtendableOutputCore for $name {\n            type ReaderCore = $reader;\n\n            #[inline]\n            fn finalize_xof_core(&mut self, buffer: &mut Buffer<Self>) -> Self::ReaderCore {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n                $reader {\n                    state: self.state.clone(),\n                }\n            }\n        }","impl HashMarker for $name {}","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"Shake256ReaderCore":["Clone","impl BlockSizeUser for $reader {\n            type BlockSize = $rate;\n        }","impl XofReaderCore for $reader {\n            #[inline]\n            fn read_block(&mut self) -> Block<Self> {\n                let mut block = Block::<Self>::default();\n                self.state.as_bytes(&mut block);\n                self.state.permute();\n                block\n            }\n        }"],"TurboShake128Core":["Clone","impl $name {\n            /// Creates a new TurboSHAKE instance with the given domain separation.\n            /// Note that the domain separation needs to be a byte with a value in\n            /// the range [0x01, . . . , 0x7F]\n            pub fn new(domain_separation: u8) -> Self {\n                assert!((0x01..=0x7F).contains(&domain_separation));\n                Self {\n                    domain_separation,\n                    state: Sha3State::new(TURBO_SHAKE_ROUND_COUNT),\n                }\n            }\n        }","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl ExtendableOutputCore for $name {\n            type ReaderCore = $reader;\n\n            #[inline]\n            fn finalize_xof_core(&mut self, buffer: &mut Buffer<Self>) -> Self::ReaderCore {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = self.domain_separation;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n                $reader {\n                    state: self.state.clone(),\n                }\n            }\n        }","impl HashMarker for $name {}","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Self::new(self.domain_separation);\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"TurboShake128ReaderCore":["Clone","impl BlockSizeUser for $reader {\n            type BlockSize = $rate;\n        }","impl XofReaderCore for $reader {\n            #[inline]\n            fn read_block(&mut self) -> Block<Self> {\n                let mut block = Block::<Self>::default();\n                self.state.as_bytes(&mut block);\n                self.state.permute();\n                block\n            }\n        }"],"TurboShake256Core":["Clone","impl $name {\n            /// Creates a new TurboSHAKE instance with the given domain separation.\n            /// Note that the domain separation needs to be a byte with a value in\n            /// the range [0x01, . . . , 0x7F]\n            pub fn new(domain_separation: u8) -> Self {\n                assert!((0x01..=0x7F).contains(&domain_separation));\n                Self {\n                    domain_separation,\n                    state: Sha3State::new(TURBO_SHAKE_ROUND_COUNT),\n                }\n            }\n        }","impl AlgorithmName for $name {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_name))\n            }\n        }","impl BlockSizeUser for $name {\n            type BlockSize = $rate;\n        }","impl BufferKindUser for $name {\n            type BufferKind = Eager;\n        }","impl ExtendableOutputCore for $name {\n            type ReaderCore = $reader;\n\n            #[inline]\n            fn finalize_xof_core(&mut self, buffer: &mut Buffer<Self>) -> Self::ReaderCore {\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = self.domain_separation;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n                $reader {\n                    state: self.state.clone(),\n                }\n            }\n        }","impl HashMarker for $name {}","impl Reset for $name {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Self::new(self.domain_separation);\n            }\n        }","impl UpdateCore for $name {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }\n        }","impl fmt::Debug for $name {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }\n        }"],"TurboShake256ReaderCore":["Clone","impl BlockSizeUser for $reader {\n            type BlockSize = $rate;\n        }","impl XofReaderCore for $reader {\n            #[inline]\n            fn read_block(&mut self) -> Block<Self> {\n                let mut block = Block::<Self>::default();\n                self.state.as_bytes(&mut block);\n                self.state.permute();\n                block\n            }\n        }"],"state::Sha3State":["Clone","impl Default for Sha3State {\n    fn default() -> Self {\n        Self {\n            state: [0u64; PLEN],\n            round_count: DEFAULT_ROUND_COUNT,\n        }\n    }\n}","impl Sha3State {\n    pub(crate) fn new(round_count: usize) -> Self {\n        Self {\n            state: [0u64; PLEN],\n            round_count,\n        }\n    }\n\n    #[inline(always)]\n    pub(crate) fn absorb_block(&mut self, block: &[u8]) {\n        debug_assert_eq!(block.len() % 8, 0);\n\n        for (b, s) in block.chunks_exact(8).zip(self.state.iter_mut()) {\n            *s ^= u64::from_le_bytes(b.try_into().unwrap());\n        }\n\n        keccak::p1600(&mut self.state, self.round_count);\n    }\n\n    #[inline(always)]\n    pub(crate) fn as_bytes(&self, out: &mut [u8]) {\n        for (o, s) in out.chunks_mut(8).zip(self.state.iter()) {\n            o.copy_from_slice(&s.to_le_bytes()[..o.len()]);\n        }\n    }\n\n    #[inline(always)]\n    pub(crate) fn permute(&mut self) {\n        keccak::p1600(&mut self.state, self.round_count);\n    }\n}"]},"single_path_import":{"digest":"digest","digest::Digest":"Digest"},"srcs":{"<CShake128Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<CShake128Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<CShake128Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["#[inline]\nfn finalize_xof_core(&mut self, buffer: &mut Buffer<Self>) -> Self::ReaderCore{\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = self.padding;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n                $reader {\n                    state: self.state.clone(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<CShake128Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<CShake128ReaderCore as digest::core_api::XofReaderCore>::read_block":["#[inline]\nfn read_block(&mut self) -> Block<Self>{\n                let mut block = Block::<Self>::default();\n                self.state.as_bytes(&mut block);\n                self.state.permute();\n                block\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<CShake256Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<CShake256Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<CShake256Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["#[inline]\nfn finalize_xof_core(&mut self, buffer: &mut Buffer<Self>) -> Self::ReaderCore{\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = self.padding;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n                $reader {\n                    state: self.state.clone(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<CShake256Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<CShake256ReaderCore as digest::core_api::XofReaderCore>::read_block":["#[inline]\nfn read_block(&mut self) -> Block<Self>{\n                let mut block = Block::<Self>::default();\n                self.state.as_bytes(&mut block);\n                self.state.permute();\n                block\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak224Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    state: Default::default(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak224Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak224Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak224Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak224Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak224Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak256Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    state: Default::default(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak256Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak256Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak256Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak256Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak256Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak256FullCore as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    state: Default::default(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak256FullCore as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak256FullCore as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak256FullCore as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak256FullCore as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak256FullCore as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak384Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    state: Default::default(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak384Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak384Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak384Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak384Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak384Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak512Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    state: Default::default(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak512Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak512Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak512Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak512Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Keccak512Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_224Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    state: Default::default(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_224Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_224Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_224Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_224Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_224Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_256Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    state: Default::default(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_256Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_256Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_256Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_256Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_256Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_384Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    state: Default::default(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_384Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_384Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_384Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_384Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_384Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_512Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    state: Default::default(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_512Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_512Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_512Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_512Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n\n                self.state.as_bytes(out);\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Sha3_512Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake128Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    state: Default::default(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake128Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake128Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake128Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake128Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["#[inline]\nfn finalize_xof_core(&mut self, buffer: &mut Buffer<Self>) -> Self::ReaderCore{\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n                $reader {\n                    state: self.state.clone(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake128Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake128ReaderCore as digest::core_api::XofReaderCore>::read_block":["#[inline]\nfn read_block(&mut self) -> Block<Self>{\n                let mut block = Block::<Self>::default();\n                self.state.as_bytes(&mut block);\n                self.state.permute();\n                block\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake256Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    state: Default::default(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake256Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake256Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake256Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake256Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["#[inline]\nfn finalize_xof_core(&mut self, buffer: &mut Buffer<Self>) -> Self::ReaderCore{\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = $pad;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n                $reader {\n                    state: self.state.clone(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake256Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<Shake256ReaderCore as digest::core_api::XofReaderCore>::read_block":["#[inline]\nfn read_block(&mut self) -> Block<Self>{\n                let mut block = Block::<Self>::default();\n                self.state.as_bytes(&mut block);\n                self.state.permute();\n                block\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<TurboShake128Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<TurboShake128Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Self::new(self.domain_separation);\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<TurboShake128Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<TurboShake128Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["#[inline]\nfn finalize_xof_core(&mut self, buffer: &mut Buffer<Self>) -> Self::ReaderCore{\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = self.domain_separation;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n                $reader {\n                    state: self.state.clone(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<TurboShake128Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<TurboShake128ReaderCore as digest::core_api::XofReaderCore>::read_block":["#[inline]\nfn read_block(&mut self) -> Block<Self>{\n                let mut block = Block::<Self>::default();\n                self.state.as_bytes(&mut block);\n                self.state.permute();\n                block\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<TurboShake256Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($name), \" { ... }\"))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<TurboShake256Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Self::new(self.domain_separation);\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<TurboShake256Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_name))\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<TurboShake256Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["#[inline]\nfn finalize_xof_core(&mut self, buffer: &mut Buffer<Self>) -> Self::ReaderCore{\n                let pos = buffer.get_pos();\n                let block = buffer.pad_with_zeros();\n                block[pos] = self.domain_separation;\n                let n = block.len();\n                block[n - 1] |= 0x80;\n\n                self.state.absorb_block(block);\n                $reader {\n                    state: self.state.clone(),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<TurboShake256Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                for block in blocks {\n                    self.state.absorb_block(block)\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<TurboShake256ReaderCore as digest::core_api::XofReaderCore>::read_block":["#[inline]\nfn read_block(&mut self) -> Block<Self>{\n                let mut block = Block::<Self>::default();\n                self.state.as_bytes(&mut block);\n                self.state.permute();\n                block\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"<state::Sha3State as core::default::Default>::default":["fn default() -> Self{\n        Self {\n            state: [0u64; PLEN],\n            round_count: DEFAULT_ROUND_COUNT,\n        }\n    }","Real(LocalPath(\"sha3/src/state.rs\"))"],"CShake128Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            padding: u8,\n            state: Sha3State,\n            #[cfg(feature = \"reset\")]\n            initial_state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"CShake128Core::new":["/// Creates a new CSHAKE instance with the given customization.\npub fn new(customization: &[u8]) -> Self{\n                Self::new_with_function_name(&[], customization)\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"CShake128Core::new_with_function_name":["/// Creates a new CSHAKE instance with the given function name and customization.\n/// Note that the function name is intended for use by NIST and should only be set to\n/// values defined by NIST. You probably don't need to use this function.\npub fn new_with_function_name(function_name: &[u8], customization: &[u8]) -> Self{\n                let mut state = Sha3State::default();\n                if function_name.is_empty() && customization.is_empty() {\n                    return Self {\n                        padding: $shake_pad,\n                        state: state.clone(),\n                        #[cfg(feature = \"reset\")]\n                        initial_state: state,\n                    };\n                }\n\n                let mut buffer = Buffer::<Self>::default();\n                let mut b = [0u8; 9];\n                buffer.digest_blocks(left_encode($rate::to_u64(), &mut b), |blocks| {\n                    for block in blocks {\n                        state.absorb_block(block);\n                    }\n                });\n                buffer.digest_blocks(\n                    left_encode((function_name.len() * 8) as u64, &mut b),\n                    |blocks| {\n                        for block in blocks {\n                            state.absorb_block(block);\n                        }\n                    },\n                );\n                buffer.digest_blocks(function_name, |blocks| {\n                    for block in blocks {\n                        state.absorb_block(block);\n                    }\n                });\n                buffer.digest_blocks(\n                    left_encode((customization.len() * 8) as u64, &mut b),\n                    |blocks| {\n                        for block in blocks {\n                            state.absorb_block(block);\n                        }\n                    },\n                );\n                buffer.digest_blocks(customization, |blocks| {\n                    for block in blocks {\n                        state.absorb_block(block);\n                    }\n                });\n                state.absorb_block(buffer.pad_with_zeros());\n\n                Self {\n                    padding: $cshake_pad,\n                    state: state.clone(),\n                    #[cfg(feature = \"reset\")]\n                    initial_state: state,\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"CShake128ReaderCore":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" reader state.\"]\n#[allow(non_camel_case_types)]\npub struct $reader {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"CShake256Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            padding: u8,\n            state: Sha3State,\n            #[cfg(feature = \"reset\")]\n            initial_state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"CShake256Core::new":["/// Creates a new CSHAKE instance with the given customization.\npub fn new(customization: &[u8]) -> Self{\n                Self::new_with_function_name(&[], customization)\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"CShake256Core::new_with_function_name":["/// Creates a new CSHAKE instance with the given function name and customization.\n/// Note that the function name is intended for use by NIST and should only be set to\n/// values defined by NIST. You probably don't need to use this function.\npub fn new_with_function_name(function_name: &[u8], customization: &[u8]) -> Self{\n                let mut state = Sha3State::default();\n                if function_name.is_empty() && customization.is_empty() {\n                    return Self {\n                        padding: $shake_pad,\n                        state: state.clone(),\n                        #[cfg(feature = \"reset\")]\n                        initial_state: state,\n                    };\n                }\n\n                let mut buffer = Buffer::<Self>::default();\n                let mut b = [0u8; 9];\n                buffer.digest_blocks(left_encode($rate::to_u64(), &mut b), |blocks| {\n                    for block in blocks {\n                        state.absorb_block(block);\n                    }\n                });\n                buffer.digest_blocks(\n                    left_encode((function_name.len() * 8) as u64, &mut b),\n                    |blocks| {\n                        for block in blocks {\n                            state.absorb_block(block);\n                        }\n                    },\n                );\n                buffer.digest_blocks(function_name, |blocks| {\n                    for block in blocks {\n                        state.absorb_block(block);\n                    }\n                });\n                buffer.digest_blocks(\n                    left_encode((customization.len() * 8) as u64, &mut b),\n                    |blocks| {\n                        for block in blocks {\n                            state.absorb_block(block);\n                        }\n                    },\n                );\n                buffer.digest_blocks(customization, |blocks| {\n                    for block in blocks {\n                        state.absorb_block(block);\n                    }\n                });\n                state.absorb_block(buffer.pad_with_zeros());\n\n                Self {\n                    padding: $cshake_pad,\n                    state: state.clone(),\n                    #[cfg(feature = \"reset\")]\n                    initial_state: state,\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"CShake256ReaderCore":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" reader state.\"]\n#[allow(non_camel_case_types)]\npub struct $reader {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Keccak224Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Keccak256Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Keccak256FullCore":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Keccak384Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Keccak512Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Sha3_224Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Sha3_256Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Sha3_384Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Sha3_512Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Shake128Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Shake128ReaderCore":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" reader state.\"]\n#[allow(non_camel_case_types)]\npub struct $reader {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Shake256Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"Shake256ReaderCore":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" reader state.\"]\n#[allow(non_camel_case_types)]\npub struct $reader {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"TurboShake128Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            domain_separation: u8,\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"TurboShake128Core::new":["/// Creates a new TurboSHAKE instance with the given domain separation.\n/// Note that the domain separation needs to be a byte with a value in\n/// the range [0x01, . . . , 0x7F]\npub fn new(domain_separation: u8) -> Self{\n                assert!((0x01..=0x7F).contains(&domain_separation));\n                Self {\n                    domain_separation,\n                    state: Sha3State::new(TURBO_SHAKE_ROUND_COUNT),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"TurboShake128ReaderCore":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" reader state.\"]\n#[allow(non_camel_case_types)]\npub struct $reader {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"TurboShake256Core":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" hasher state.\"]\n#[allow(non_camel_case_types)]\npub struct $name {\n            domain_separation: u8,\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"TurboShake256Core::new":["/// Creates a new TurboSHAKE instance with the given domain separation.\n/// Note that the domain separation needs to be a byte with a value in\n/// the range [0x01, . . . , 0x7F]\npub fn new(domain_separation: u8) -> Self{\n                assert!((0x01..=0x7F).contains(&domain_separation));\n                Self {\n                    domain_separation,\n                    state: Sha3State::new(TURBO_SHAKE_ROUND_COUNT),\n                }\n            }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"TurboShake256ReaderCore":["#[doc = \"Core \"]\n#[doc = $alg_name]\n#[doc = \" reader state.\"]\n#[allow(non_camel_case_types)]\npub struct $reader {\n            state: Sha3State,\n        }","Real(LocalPath(\"sha3/src/macros.rs\"))"],"left_encode":["#[inline(always)]\npub(crate) fn left_encode(val: u64, b: &mut [u8; 9]) -> &[u8]{\n    b[1..].copy_from_slice(&val.to_be_bytes());\n    let i = b[1..8].iter().take_while(|&&a| a == 0).count();\n    b[i] = (8 - i) as u8;\n    &b[i..]\n}","Real(LocalPath(\"sha3/src/lib.rs\"))"],"state::Sha3State":["pub(crate) struct Sha3State {\n    pub state: [u64; PLEN],\n    round_count: usize,\n}","Real(LocalPath(\"sha3/src/state.rs\"))"],"state::Sha3State::absorb_block":["#[inline(always)]\npub(crate) fn absorb_block(&mut self, block: &[u8]){\n        debug_assert_eq!(block.len() % 8, 0);\n\n        for (b, s) in block.chunks_exact(8).zip(self.state.iter_mut()) {\n            *s ^= u64::from_le_bytes(b.try_into().unwrap());\n        }\n\n        keccak::p1600(&mut self.state, self.round_count);\n    }","Real(LocalPath(\"sha3/src/state.rs\"))"],"state::Sha3State::as_bytes":["#[inline(always)]\npub(crate) fn as_bytes(&self, out: &mut [u8]){\n        for (o, s) in out.chunks_mut(8).zip(self.state.iter()) {\n            o.copy_from_slice(&s.to_le_bytes()[..o.len()]);\n        }\n    }","Real(LocalPath(\"sha3/src/state.rs\"))"],"state::Sha3State::new":["pub(crate) fn new(round_count: usize) -> Self{\n        Self {\n            state: [0u64; PLEN],\n            round_count,\n        }\n    }","Real(LocalPath(\"sha3/src/state.rs\"))"],"state::Sha3State::permute":["#[inline(always)]\npub(crate) fn permute(&mut self){\n        keccak::p1600(&mut self.state, self.round_count);\n    }","Real(LocalPath(\"sha3/src/state.rs\"))"]},"struct_constructor":{"&[u8]":["left_encode"],"<CShake128Core as digest::core_api::ExtendableOutputCore>::ReaderCore":["finalize_xof_core"],"<CShake256Core as digest::core_api::ExtendableOutputCore>::ReaderCore":["finalize_xof_core"],"<Shake128Core as digest::core_api::ExtendableOutputCore>::ReaderCore":["finalize_xof_core"],"<Shake256Core as digest::core_api::ExtendableOutputCore>::ReaderCore":["finalize_xof_core"],"<TurboShake128Core as digest::core_api::ExtendableOutputCore>::ReaderCore":["finalize_xof_core"],"<TurboShake256Core as digest::core_api::ExtendableOutputCore>::ReaderCore":["finalize_xof_core"],"CShake128Core":["clone","new","new_with_function_name"],"CShake128ReaderCore":["clone"],"CShake256Core":["clone","new","new_with_function_name"],"CShake256ReaderCore":["clone"],"Keccak224Core":["clone","default"],"Keccak256Core":["clone","default"],"Keccak256FullCore":["clone","default"],"Keccak384Core":["clone","default"],"Keccak512Core":["clone","default"],"Sha3_224Core":["clone","default"],"Sha3_256Core":["clone","default"],"Sha3_384Core":["clone","default"],"Sha3_512Core":["clone","default"],"Shake128Core":["clone","default"],"Shake128ReaderCore":["clone"],"Shake256Core":["clone","default"],"Shake256ReaderCore":["clone"],"TurboShake128Core":["clone","new"],"TurboShake128ReaderCore":["clone"],"TurboShake256Core":["clone","new"],"TurboShake256ReaderCore":["clone"],"core::result::Result":["fmt","write_alg_name"],"digest::generic_array::GenericArray":["read_block"],"state::Sha3State":["clone","default","new"]},"struct_to_trait":{"CShake128Core":["core::clone::Clone","core::fmt::Debug","digest::HashMarker","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::ExtendableOutputCore","digest::core_api::UpdateCore"],"CShake128ReaderCore":["core::clone::Clone","digest::core_api::BlockSizeUser","digest::core_api::XofReaderCore"],"CShake256Core":["core::clone::Clone","core::fmt::Debug","digest::HashMarker","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::ExtendableOutputCore","digest::core_api::UpdateCore"],"CShake256ReaderCore":["core::clone::Clone","digest::core_api::BlockSizeUser","digest::core_api::XofReaderCore"],"Keccak224Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Keccak256Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Keccak256FullCore":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Keccak384Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Keccak512Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Sha3_224Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Sha3_256Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Sha3_384Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Sha3_512Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Shake128Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::ExtendableOutputCore","digest::core_api::UpdateCore"],"Shake128ReaderCore":["core::clone::Clone","digest::core_api::BlockSizeUser","digest::core_api::XofReaderCore"],"Shake256Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::ExtendableOutputCore","digest::core_api::UpdateCore"],"Shake256ReaderCore":["core::clone::Clone","digest::core_api::BlockSizeUser","digest::core_api::XofReaderCore"],"TurboShake128Core":["core::clone::Clone","core::fmt::Debug","digest::HashMarker","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::ExtendableOutputCore","digest::core_api::UpdateCore"],"TurboShake128ReaderCore":["core::clone::Clone","digest::core_api::BlockSizeUser","digest::core_api::XofReaderCore"],"TurboShake256Core":["core::clone::Clone","core::fmt::Debug","digest::HashMarker","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::ExtendableOutputCore","digest::core_api::UpdateCore"],"TurboShake256ReaderCore":["core::clone::Clone","digest::core_api::BlockSizeUser","digest::core_api::XofReaderCore"],"state::Sha3State":["core::clone::Clone","core::default::Default"]},"targets":{"<CShake128Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<CShake128Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<CShake128Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["finalize_xof_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::ExtendableOutputCore"],"<CShake128Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<CShake128ReaderCore as digest::core_api::XofReaderCore>::read_block":["read_block","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::XofReaderCore"],"<CShake256Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<CShake256Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<CShake256Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["finalize_xof_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::ExtendableOutputCore"],"<CShake256Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<CShake256ReaderCore as digest::core_api::XofReaderCore>::read_block":["read_block","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::XofReaderCore"],"<Keccak224Core as core::default::Default>::default":["default","Real(LocalPath(\"sha3/src/macros.rs\"))","core::default::Default"],"<Keccak224Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<Keccak224Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<Keccak224Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Keccak224Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Keccak224Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Keccak256Core as core::default::Default>::default":["default","Real(LocalPath(\"sha3/src/macros.rs\"))","core::default::Default"],"<Keccak256Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<Keccak256Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<Keccak256Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Keccak256Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Keccak256Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Keccak256FullCore as core::default::Default>::default":["default","Real(LocalPath(\"sha3/src/macros.rs\"))","core::default::Default"],"<Keccak256FullCore as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<Keccak256FullCore as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<Keccak256FullCore as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Keccak256FullCore as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Keccak256FullCore as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Keccak384Core as core::default::Default>::default":["default","Real(LocalPath(\"sha3/src/macros.rs\"))","core::default::Default"],"<Keccak384Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<Keccak384Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<Keccak384Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Keccak384Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Keccak384Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Keccak512Core as core::default::Default>::default":["default","Real(LocalPath(\"sha3/src/macros.rs\"))","core::default::Default"],"<Keccak512Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<Keccak512Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<Keccak512Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Keccak512Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Keccak512Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Sha3_224Core as core::default::Default>::default":["default","Real(LocalPath(\"sha3/src/macros.rs\"))","core::default::Default"],"<Sha3_224Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<Sha3_224Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<Sha3_224Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Sha3_224Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Sha3_224Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Sha3_256Core as core::default::Default>::default":["default","Real(LocalPath(\"sha3/src/macros.rs\"))","core::default::Default"],"<Sha3_256Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<Sha3_256Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<Sha3_256Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Sha3_256Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Sha3_256Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Sha3_384Core as core::default::Default>::default":["default","Real(LocalPath(\"sha3/src/macros.rs\"))","core::default::Default"],"<Sha3_384Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<Sha3_384Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<Sha3_384Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Sha3_384Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Sha3_384Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Sha3_512Core as core::default::Default>::default":["default","Real(LocalPath(\"sha3/src/macros.rs\"))","core::default::Default"],"<Sha3_512Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<Sha3_512Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<Sha3_512Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Sha3_512Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Sha3_512Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Shake128Core as core::default::Default>::default":["default","Real(LocalPath(\"sha3/src/macros.rs\"))","core::default::Default"],"<Shake128Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<Shake128Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<Shake128Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Shake128Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["finalize_xof_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::ExtendableOutputCore"],"<Shake128Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Shake128ReaderCore as digest::core_api::XofReaderCore>::read_block":["read_block","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::XofReaderCore"],"<Shake256Core as core::default::Default>::default":["default","Real(LocalPath(\"sha3/src/macros.rs\"))","core::default::Default"],"<Shake256Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<Shake256Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<Shake256Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Shake256Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["finalize_xof_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::ExtendableOutputCore"],"<Shake256Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Shake256ReaderCore as digest::core_api::XofReaderCore>::read_block":["read_block","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::XofReaderCore"],"<TurboShake128Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<TurboShake128Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<TurboShake128Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<TurboShake128Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["finalize_xof_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::ExtendableOutputCore"],"<TurboShake128Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<TurboShake128ReaderCore as digest::core_api::XofReaderCore>::read_block":["read_block","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::XofReaderCore"],"<TurboShake256Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha3/src/macros.rs\"))","core::fmt::Debug"],"<TurboShake256Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::Reset"],"<TurboShake256Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<TurboShake256Core as digest::core_api::ExtendableOutputCore>::finalize_xof_core":["finalize_xof_core","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::ExtendableOutputCore"],"<TurboShake256Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::UpdateCore"],"<TurboShake256ReaderCore as digest::core_api::XofReaderCore>::read_block":["read_block","Real(LocalPath(\"sha3/src/macros.rs\"))","digest::core_api::XofReaderCore"],"<state::Sha3State as core::default::Default>::default":["default","Real(LocalPath(\"sha3/src/state.rs\"))","core::default::Default"],"CShake128Core::new":["new","Real(LocalPath(\"sha3/src/macros.rs\"))",""],"CShake128Core::new_with_function_name":["new_with_function_name","Real(LocalPath(\"sha3/src/macros.rs\"))",""],"CShake256Core::new":["new","Real(LocalPath(\"sha3/src/macros.rs\"))",""],"CShake256Core::new_with_function_name":["new_with_function_name","Real(LocalPath(\"sha3/src/macros.rs\"))",""],"TurboShake128Core::new":["new","Real(LocalPath(\"sha3/src/macros.rs\"))",""],"TurboShake256Core::new":["new","Real(LocalPath(\"sha3/src/macros.rs\"))",""],"left_encode":["left_encode","Real(LocalPath(\"sha3/src/lib.rs\"))",""],"state::Sha3State::absorb_block":["absorb_block","Real(LocalPath(\"sha3/src/state.rs\"))",""],"state::Sha3State::as_bytes":["as_bytes","Real(LocalPath(\"sha3/src/state.rs\"))",""],"state::Sha3State::new":["new","Real(LocalPath(\"sha3/src/state.rs\"))",""],"state::Sha3State::permute":["permute","Real(LocalPath(\"sha3/src/state.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["CShake128Core","CShake128ReaderCore","CShake256Core","CShake256ReaderCore","Keccak224Core","Keccak256Core","Keccak256FullCore","Keccak384Core","Keccak512Core","Sha3_224Core","Sha3_256Core","Sha3_384Core","Sha3_512Core","Shake128Core","Shake128ReaderCore","Shake256Core","Shake256ReaderCore","TurboShake128Core","TurboShake128ReaderCore","TurboShake256Core","TurboShake256ReaderCore","state::Sha3State"],"core::default::Default":["Keccak224Core","Keccak256Core","Keccak256FullCore","Keccak384Core","Keccak512Core","Sha3_224Core","Sha3_256Core","Sha3_384Core","Sha3_512Core","Shake128Core","Shake256Core","state::Sha3State"],"core::fmt::Debug":["CShake128Core","CShake256Core","Keccak224Core","Keccak256Core","Keccak256FullCore","Keccak384Core","Keccak512Core","Sha3_224Core","Sha3_256Core","Sha3_384Core","Sha3_512Core","Shake128Core","Shake256Core","TurboShake128Core","TurboShake256Core"],"digest::HashMarker":["CShake128Core","CShake256Core","Keccak224Core","Keccak256Core","Keccak256FullCore","Keccak384Core","Keccak512Core","Sha3_224Core","Sha3_256Core","Sha3_384Core","Sha3_512Core","Shake128Core","Shake256Core","TurboShake128Core","TurboShake256Core"],"digest::OutputSizeUser":["Keccak224Core","Keccak256Core","Keccak256FullCore","Keccak384Core","Keccak512Core","Sha3_224Core","Sha3_256Core","Sha3_384Core","Sha3_512Core"],"digest::Reset":["Keccak224Core","Keccak256Core","Keccak256FullCore","Keccak384Core","Keccak512Core","Sha3_224Core","Sha3_256Core","Sha3_384Core","Sha3_512Core","Shake128Core","Shake256Core","TurboShake128Core","TurboShake256Core"],"digest::core_api::AlgorithmName":["CShake128Core","CShake256Core","Keccak224Core","Keccak256Core","Keccak256FullCore","Keccak384Core","Keccak512Core","Sha3_224Core","Sha3_256Core","Sha3_384Core","Sha3_512Core","Shake128Core","Shake256Core","TurboShake128Core","TurboShake256Core"],"digest::core_api::BlockSizeUser":["CShake128Core","CShake128ReaderCore","CShake256Core","CShake256ReaderCore","Keccak224Core","Keccak256Core","Keccak256FullCore","Keccak384Core","Keccak512Core","Sha3_224Core","Sha3_256Core","Sha3_384Core","Sha3_512Core","Shake128Core","Shake128ReaderCore","Shake256Core","Shake256ReaderCore","TurboShake128Core","TurboShake128ReaderCore","TurboShake256Core","TurboShake256ReaderCore"],"digest::core_api::BufferKindUser":["CShake128Core","CShake256Core","Keccak224Core","Keccak256Core","Keccak256FullCore","Keccak384Core","Keccak512Core","Sha3_224Core","Sha3_256Core","Sha3_384Core","Sha3_512Core","Shake128Core","Shake256Core","TurboShake128Core","TurboShake256Core"],"digest::core_api::ExtendableOutputCore":["CShake128Core","CShake256Core","Shake128Core","Shake256Core","TurboShake128Core","TurboShake256Core"],"digest::core_api::FixedOutputCore":["Keccak224Core","Keccak256Core","Keccak256FullCore","Keccak384Core","Keccak512Core","Sha3_224Core","Sha3_256Core","Sha3_384Core","Sha3_512Core"],"digest::core_api::UpdateCore":["CShake128Core","CShake256Core","Keccak224Core","Keccak256Core","Keccak256FullCore","Keccak384Core","Keccak512Core","Sha3_224Core","Sha3_256Core","Sha3_384Core","Sha3_512Core","Shake128Core","Shake256Core","TurboShake128Core","TurboShake256Core"],"digest::core_api::XofReaderCore":["CShake128ReaderCore","CShake256ReaderCore","Shake128ReaderCore","Shake256ReaderCore","TurboShake128ReaderCore","TurboShake256ReaderCore"]},"type_to_def_path":{"CShake128Core":"CShake128Core","CShake128ReaderCore":"CShake128ReaderCore","CShake256Core":"CShake256Core","CShake256ReaderCore":"CShake256ReaderCore","Keccak224Core":"Keccak224Core","Keccak256Core":"Keccak256Core","Keccak256FullCore":"Keccak256FullCore","Keccak384Core":"Keccak384Core","Keccak512Core":"Keccak512Core","Sha3_224Core":"Sha3_224Core","Sha3_256Core":"Sha3_256Core","Sha3_384Core":"Sha3_384Core","Sha3_512Core":"Sha3_512Core","Shake128Core":"Shake128Core","Shake128ReaderCore":"Shake128ReaderCore","Shake256Core":"Shake256Core","Shake256ReaderCore":"Shake256ReaderCore","TurboShake128Core":"TurboShake128Core","TurboShake128ReaderCore":"TurboShake128ReaderCore","TurboShake256Core":"TurboShake256Core","TurboShake256ReaderCore":"TurboShake256ReaderCore","state::Sha3State":"state::Sha3State"}}