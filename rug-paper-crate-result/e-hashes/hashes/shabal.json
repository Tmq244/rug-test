{"dependencies":{"<core_api::ShabalVarCore as core::clone::Clone>::clone":["core::marker::Sized","core::num::Wrapping","core_api::ShabalVarCore"],"<core_api::ShabalVarCore as core::fmt::Debug>::fmt":["core::fmt::Formatter","core::marker::Sized","core::num::Wrapping","core::result::Result","core_api::ShabalVarCore"],"<core_api::ShabalVarCore as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<core_api::ShabalVarCore as digest::core_api::UpdateCore>::update_blocks":["core::marker::Sized","core::num::Wrapping","core_api::ShabalVarCore","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"<core_api::ShabalVarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["core::marker::Sized","core::num::Wrapping","core_api::ShabalVarCore","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero"],"<core_api::ShabalVarCore as digest::core_api::VariableOutputCore>::new":["core::marker::Sized","core::result::Result"],"core_api::ShabalVarCore":["core::marker::Sized","core::num::Wrapping","core_api::ShabalVarCore"],"core_api::ShabalVarCore::add_m":["core::marker::Sized","core::num::Wrapping","core_api::ShabalVarCore"],"core_api::ShabalVarCore::perm":["core::marker::Sized","core::num::Wrapping","core_api::ShabalVarCore"],"core_api::ShabalVarCore::perm_blocks":["core::marker::Sized","core::num::Wrapping","core_api::ShabalVarCore"],"core_api::ShabalVarCore::perm_elt":["core::marker::Sized","core::num::Wrapping","core_api::ShabalVarCore"],"core_api::ShabalVarCore::sub_m":["core::marker::Sized","core::num::Wrapping","core_api::ShabalVarCore"],"core_api::ShabalVarCore::swap_b_c":["core::marker::Sized","core::num::Wrapping","core_api::ShabalVarCore"],"core_api::ShabalVarCore::xor_w":["core::marker::Sized","core::num::Wrapping","core_api::ShabalVarCore"],"core_api::read_m":["core::marker::Sized","core::num::Wrapping","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"]},"glob_path_import":{},"self_to_fn":{"core_api::ShabalVarCore":["Clone","impl AlgorithmName for ShabalVarCore {\n    #[inline]\n    fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"Shabal\")\n    }\n}","impl BlockSizeUser for ShabalVarCore {\n    type BlockSize = BlockSize;\n}","impl BufferKindUser for ShabalVarCore {\n    type BufferKind = Eager;\n}","impl HashMarker for ShabalVarCore {}","impl OutputSizeUser for ShabalVarCore {\n    type OutputSize = U64;\n}","impl ShabalVarCore {\n    #[allow(clippy::needless_range_loop)]\n    fn add_m(&mut self, m: &M) {\n        for i in 0..16 {\n            self.b[i] += m[i];\n        }\n    }\n\n    #[allow(clippy::needless_range_loop)]\n    fn sub_m(&mut self, m: &M) {\n        for i in 0..16 {\n            self.c[i] -= m[i];\n        }\n    }\n\n    fn xor_w(&mut self) {\n        self.a[0].0 ^= self.w.0 as u32;\n        self.a[1].0 ^= (self.w.0 >> 32) as u32;\n    }\n\n    fn perm(&mut self, m: &M) {\n        self.b.iter_mut().for_each(|b| b.0 = b.0.rotate_left(17));\n        self.perm_blocks(m);\n\n        let a = &mut self.a;\n        let c = &self.c;\n        a[0] += c[11] + c[15] + c[3];\n        a[1] += c[12] + c[0] + c[4];\n        a[2] += c[13] + c[1] + c[5];\n        a[3] += c[14] + c[2] + c[6];\n        a[4] += c[15] + c[3] + c[7];\n        a[5] += c[0] + c[4] + c[8];\n        a[6] += c[1] + c[5] + c[9];\n        a[7] += c[2] + c[6] + c[10];\n        a[8] += c[3] + c[7] + c[11];\n        a[9] += c[4] + c[8] + c[12];\n        a[10] += c[5] + c[9] + c[13];\n        a[11] += c[6] + c[10] + c[14];\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    fn perm_elt(\n        &mut self,\n        xa0: usize,\n        xa1: usize,\n        xb0: usize,\n        xb1: usize,\n        xb2: usize,\n        xb3: usize,\n        xc0: usize,\n        xm: Wrapping<u32>,\n    ) {\n        let a = &mut self.a;\n        let b = &mut self.b;\n        let xc = self.c[xc0];\n\n        let t1 = Wrapping(a[xa1].0.rotate_left(15));\n        let t2 = t1 * Wrapping(5);\n        let t3 = (a[xa0] ^ t2 ^ xc) * Wrapping(3);\n        a[xa0] = t3 ^ b[xb1] ^ (b[xb2] & !b[xb3]) ^ xm;\n\n        let t = Wrapping(b[xb0].0.rotate_left(1));\n        b[xb0] = !(t ^ a[xa0]);\n    }\n\n    fn perm_blocks(&mut self, m: &M) {\n        self.perm_elt(0, 11, 0, 13, 9, 6, 8, m[0]);\n        self.perm_elt(1, 0, 1, 14, 10, 7, 7, m[1]);\n        self.perm_elt(2, 1, 2, 15, 11, 8, 6, m[2]);\n        self.perm_elt(3, 2, 3, 0, 12, 9, 5, m[3]);\n        self.perm_elt(4, 3, 4, 1, 13, 10, 4, m[4]);\n        self.perm_elt(5, 4, 5, 2, 14, 11, 3, m[5]);\n        self.perm_elt(6, 5, 6, 3, 15, 12, 2, m[6]);\n        self.perm_elt(7, 6, 7, 4, 0, 13, 1, m[7]);\n        self.perm_elt(8, 7, 8, 5, 1, 14, 0, m[8]);\n        self.perm_elt(9, 8, 9, 6, 2, 15, 15, m[9]);\n        self.perm_elt(10, 9, 10, 7, 3, 0, 14, m[10]);\n        self.perm_elt(11, 10, 11, 8, 4, 1, 13, m[11]);\n        self.perm_elt(0, 11, 12, 9, 5, 2, 12, m[12]);\n        self.perm_elt(1, 0, 13, 10, 6, 3, 11, m[13]);\n        self.perm_elt(2, 1, 14, 11, 7, 4, 10, m[14]);\n        self.perm_elt(3, 2, 15, 12, 8, 5, 9, m[15]);\n        self.perm_elt(4, 3, 0, 13, 9, 6, 8, m[0]);\n        self.perm_elt(5, 4, 1, 14, 10, 7, 7, m[1]);\n        self.perm_elt(6, 5, 2, 15, 11, 8, 6, m[2]);\n        self.perm_elt(7, 6, 3, 0, 12, 9, 5, m[3]);\n        self.perm_elt(8, 7, 4, 1, 13, 10, 4, m[4]);\n        self.perm_elt(9, 8, 5, 2, 14, 11, 3, m[5]);\n        self.perm_elt(10, 9, 6, 3, 15, 12, 2, m[6]);\n        self.perm_elt(11, 10, 7, 4, 0, 13, 1, m[7]);\n        self.perm_elt(0, 11, 8, 5, 1, 14, 0, m[8]);\n        self.perm_elt(1, 0, 9, 6, 2, 15, 15, m[9]);\n        self.perm_elt(2, 1, 10, 7, 3, 0, 14, m[10]);\n        self.perm_elt(3, 2, 11, 8, 4, 1, 13, m[11]);\n        self.perm_elt(4, 3, 12, 9, 5, 2, 12, m[12]);\n        self.perm_elt(5, 4, 13, 10, 6, 3, 11, m[13]);\n        self.perm_elt(6, 5, 14, 11, 7, 4, 10, m[14]);\n        self.perm_elt(7, 6, 15, 12, 8, 5, 9, m[15]);\n        self.perm_elt(8, 7, 0, 13, 9, 6, 8, m[0]);\n        self.perm_elt(9, 8, 1, 14, 10, 7, 7, m[1]);\n        self.perm_elt(10, 9, 2, 15, 11, 8, 6, m[2]);\n        self.perm_elt(11, 10, 3, 0, 12, 9, 5, m[3]);\n        self.perm_elt(0, 11, 4, 1, 13, 10, 4, m[4]);\n        self.perm_elt(1, 0, 5, 2, 14, 11, 3, m[5]);\n        self.perm_elt(2, 1, 6, 3, 15, 12, 2, m[6]);\n        self.perm_elt(3, 2, 7, 4, 0, 13, 1, m[7]);\n        self.perm_elt(4, 3, 8, 5, 1, 14, 0, m[8]);\n        self.perm_elt(5, 4, 9, 6, 2, 15, 15, m[9]);\n        self.perm_elt(6, 5, 10, 7, 3, 0, 14, m[10]);\n        self.perm_elt(7, 6, 11, 8, 4, 1, 13, m[11]);\n        self.perm_elt(8, 7, 12, 9, 5, 2, 12, m[12]);\n        self.perm_elt(9, 8, 13, 10, 6, 3, 11, m[13]);\n        self.perm_elt(10, 9, 14, 11, 7, 4, 10, m[14]);\n        self.perm_elt(11, 10, 15, 12, 8, 5, 9, m[15]);\n    }\n\n    fn swap_b_c(&mut self) {\n        mem::swap(&mut self.b, &mut self.c);\n    }\n}","impl UpdateCore for ShabalVarCore {\n    #[inline]\n    fn update_blocks(&mut self, blocks: &[Block]) {\n        for block in blocks {\n            let m = read_m(block);\n            self.add_m(&m);\n            self.xor_w();\n            self.perm(&m);\n            self.sub_m(&m);\n            self.swap_b_c();\n            self.w += Wrapping(1);\n        }\n    }\n}","impl VariableOutputCore for ShabalVarCore {\n    const TRUNC_SIDE: TruncSide = TruncSide::Right;\n\n    #[inline]\n    #[allow(clippy::needless_range_loop)]\n    fn new(output_size: usize) -> Result<Self, InvalidOutputSize> {\n        let init = match output_size {\n            24 => consts::INIT_192,\n            28 => consts::INIT_224,\n            32 => consts::INIT_256,\n            48 => consts::INIT_384,\n            64 => consts::INIT_512,\n            _ => return Err(InvalidOutputSize),\n        };\n        let w = Wrapping(1);\n        // TODO: use `array::map` on MSRV bump\n        let mut a = [Wrapping(0u32); 12];\n        let mut b = [Wrapping(0u32); 16];\n        let mut c = [Wrapping(0u32); 16];\n        for i in 0..12 {\n            a[i] = Wrapping(init.0[i]);\n        }\n        for i in 0..16 {\n            b[i] = Wrapping(init.1[i]);\n            c[i] = Wrapping(init.2[i]);\n        }\n        Ok(Self { a, b, c, w })\n    }\n\n    #[inline]\n    fn finalize_variable_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n        let pos = buffer.get_pos();\n        let block = buffer.pad_with_zeros();\n        block[pos] = 0x80;\n\n        let m = read_m(block);\n        self.add_m(&m);\n        self.xor_w();\n        self.perm(&m);\n        for _ in 0..3 {\n            self.swap_b_c();\n            self.xor_w();\n            self.perm(&m);\n        }\n\n        for (chunk, v) in out.chunks_exact_mut(4).zip(self.b.iter()) {\n            chunk.copy_from_slice(&v.0.to_le_bytes());\n        }\n    }\n}","impl fmt::Debug for ShabalVarCore {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"ShabalVarCore { ... }\")\n    }\n}"]},"single_path_import":{"core_api::ShabalVarCore":"ShabalVarCore","digest":"digest","digest::Digest":"Digest"},"srcs":{"<core_api::ShabalVarCore as core::fmt::Debug>::fmt":["#[inline]\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"ShabalVarCore { ... }\")\n    }","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"<core_api::ShabalVarCore as digest::core_api::AlgorithmName>::write_alg_name":["#[inline]\nfn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"Shabal\")\n    }","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"<core_api::ShabalVarCore as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block]){\n        for block in blocks {\n            let m = read_m(block);\n            self.add_m(&m);\n            self.xor_w();\n            self.perm(&m);\n            self.sub_m(&m);\n            self.swap_b_c();\n            self.w += Wrapping(1);\n        }\n    }","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"<core_api::ShabalVarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["#[inline]\nfn finalize_variable_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n        let pos = buffer.get_pos();\n        let block = buffer.pad_with_zeros();\n        block[pos] = 0x80;\n\n        let m = read_m(block);\n        self.add_m(&m);\n        self.xor_w();\n        self.perm(&m);\n        for _ in 0..3 {\n            self.swap_b_c();\n            self.xor_w();\n            self.perm(&m);\n        }\n\n        for (chunk, v) in out.chunks_exact_mut(4).zip(self.b.iter()) {\n            chunk.copy_from_slice(&v.0.to_le_bytes());\n        }\n    }","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"<core_api::ShabalVarCore as digest::core_api::VariableOutputCore>::new":["#[inline]\n#[allow(clippy::needless_range_loop)]\nfn new(output_size: usize) -> Result<Self, InvalidOutputSize>{\n        let init = match output_size {\n            24 => consts::INIT_192,\n            28 => consts::INIT_224,\n            32 => consts::INIT_256,\n            48 => consts::INIT_384,\n            64 => consts::INIT_512,\n            _ => return Err(InvalidOutputSize),\n        };\n        let w = Wrapping(1);\n        // TODO: use `array::map` on MSRV bump\n        let mut a = [Wrapping(0u32); 12];\n        let mut b = [Wrapping(0u32); 16];\n        let mut c = [Wrapping(0u32); 16];\n        for i in 0..12 {\n            a[i] = Wrapping(init.0[i]);\n        }\n        for i in 0..16 {\n            b[i] = Wrapping(init.1[i]);\n            c[i] = Wrapping(init.2[i]);\n        }\n        Ok(Self { a, b, c, w })\n    }","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"core_api::ShabalVarCore":["/// Inner state of Shabal hash functions.\npub struct ShabalVarCore {\n    a: [Wrapping<u32>; 12],\n    b: M,\n    c: M,\n    w: Wrapping<u64>,\n}","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"core_api::ShabalVarCore::add_m":["#[allow(clippy::needless_range_loop)]\nfn add_m(&mut self, m: &M){\n        for i in 0..16 {\n            self.b[i] += m[i];\n        }\n    }","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"core_api::ShabalVarCore::perm":["fn perm(&mut self, m: &M){\n        self.b.iter_mut().for_each(|b| b.0 = b.0.rotate_left(17));\n        self.perm_blocks(m);\n\n        let a = &mut self.a;\n        let c = &self.c;\n        a[0] += c[11] + c[15] + c[3];\n        a[1] += c[12] + c[0] + c[4];\n        a[2] += c[13] + c[1] + c[5];\n        a[3] += c[14] + c[2] + c[6];\n        a[4] += c[15] + c[3] + c[7];\n        a[5] += c[0] + c[4] + c[8];\n        a[6] += c[1] + c[5] + c[9];\n        a[7] += c[2] + c[6] + c[10];\n        a[8] += c[3] + c[7] + c[11];\n        a[9] += c[4] + c[8] + c[12];\n        a[10] += c[5] + c[9] + c[13];\n        a[11] += c[6] + c[10] + c[14];\n    }","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"core_api::ShabalVarCore::perm_blocks":["fn perm_blocks(&mut self, m: &M){\n        self.perm_elt(0, 11, 0, 13, 9, 6, 8, m[0]);\n        self.perm_elt(1, 0, 1, 14, 10, 7, 7, m[1]);\n        self.perm_elt(2, 1, 2, 15, 11, 8, 6, m[2]);\n        self.perm_elt(3, 2, 3, 0, 12, 9, 5, m[3]);\n        self.perm_elt(4, 3, 4, 1, 13, 10, 4, m[4]);\n        self.perm_elt(5, 4, 5, 2, 14, 11, 3, m[5]);\n        self.perm_elt(6, 5, 6, 3, 15, 12, 2, m[6]);\n        self.perm_elt(7, 6, 7, 4, 0, 13, 1, m[7]);\n        self.perm_elt(8, 7, 8, 5, 1, 14, 0, m[8]);\n        self.perm_elt(9, 8, 9, 6, 2, 15, 15, m[9]);\n        self.perm_elt(10, 9, 10, 7, 3, 0, 14, m[10]);\n        self.perm_elt(11, 10, 11, 8, 4, 1, 13, m[11]);\n        self.perm_elt(0, 11, 12, 9, 5, 2, 12, m[12]);\n        self.perm_elt(1, 0, 13, 10, 6, 3, 11, m[13]);\n        self.perm_elt(2, 1, 14, 11, 7, 4, 10, m[14]);\n        self.perm_elt(3, 2, 15, 12, 8, 5, 9, m[15]);\n        self.perm_elt(4, 3, 0, 13, 9, 6, 8, m[0]);\n        self.perm_elt(5, 4, 1, 14, 10, 7, 7, m[1]);\n        self.perm_elt(6, 5, 2, 15, 11, 8, 6, m[2]);\n        self.perm_elt(7, 6, 3, 0, 12, 9, 5, m[3]);\n        self.perm_elt(8, 7, 4, 1, 13, 10, 4, m[4]);\n        self.perm_elt(9, 8, 5, 2, 14, 11, 3, m[5]);\n        self.perm_elt(10, 9, 6, 3, 15, 12, 2, m[6]);\n        self.perm_elt(11, 10, 7, 4, 0, 13, 1, m[7]);\n        self.perm_elt(0, 11, 8, 5, 1, 14, 0, m[8]);\n        self.perm_elt(1, 0, 9, 6, 2, 15, 15, m[9]);\n        self.perm_elt(2, 1, 10, 7, 3, 0, 14, m[10]);\n        self.perm_elt(3, 2, 11, 8, 4, 1, 13, m[11]);\n        self.perm_elt(4, 3, 12, 9, 5, 2, 12, m[12]);\n        self.perm_elt(5, 4, 13, 10, 6, 3, 11, m[13]);\n        self.perm_elt(6, 5, 14, 11, 7, 4, 10, m[14]);\n        self.perm_elt(7, 6, 15, 12, 8, 5, 9, m[15]);\n        self.perm_elt(8, 7, 0, 13, 9, 6, 8, m[0]);\n        self.perm_elt(9, 8, 1, 14, 10, 7, 7, m[1]);\n        self.perm_elt(10, 9, 2, 15, 11, 8, 6, m[2]);\n        self.perm_elt(11, 10, 3, 0, 12, 9, 5, m[3]);\n        self.perm_elt(0, 11, 4, 1, 13, 10, 4, m[4]);\n        self.perm_elt(1, 0, 5, 2, 14, 11, 3, m[5]);\n        self.perm_elt(2, 1, 6, 3, 15, 12, 2, m[6]);\n        self.perm_elt(3, 2, 7, 4, 0, 13, 1, m[7]);\n        self.perm_elt(4, 3, 8, 5, 1, 14, 0, m[8]);\n        self.perm_elt(5, 4, 9, 6, 2, 15, 15, m[9]);\n        self.perm_elt(6, 5, 10, 7, 3, 0, 14, m[10]);\n        self.perm_elt(7, 6, 11, 8, 4, 1, 13, m[11]);\n        self.perm_elt(8, 7, 12, 9, 5, 2, 12, m[12]);\n        self.perm_elt(9, 8, 13, 10, 6, 3, 11, m[13]);\n        self.perm_elt(10, 9, 14, 11, 7, 4, 10, m[14]);\n        self.perm_elt(11, 10, 15, 12, 8, 5, 9, m[15]);\n    }","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"core_api::ShabalVarCore::perm_elt":["#[allow(clippy::too_many_arguments)]\nfn perm_elt(\n        &mut self,\n        xa0: usize,\n        xa1: usize,\n        xb0: usize,\n        xb1: usize,\n        xb2: usize,\n        xb3: usize,\n        xc0: usize,\n        xm: Wrapping<u32>,\n    ){\n        let a = &mut self.a;\n        let b = &mut self.b;\n        let xc = self.c[xc0];\n\n        let t1 = Wrapping(a[xa1].0.rotate_left(15));\n        let t2 = t1 * Wrapping(5);\n        let t3 = (a[xa0] ^ t2 ^ xc) * Wrapping(3);\n        a[xa0] = t3 ^ b[xb1] ^ (b[xb2] & !b[xb3]) ^ xm;\n\n        let t = Wrapping(b[xb0].0.rotate_left(1));\n        b[xb0] = !(t ^ a[xa0]);\n    }","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"core_api::ShabalVarCore::sub_m":["#[allow(clippy::needless_range_loop)]\nfn sub_m(&mut self, m: &M){\n        for i in 0..16 {\n            self.c[i] -= m[i];\n        }\n    }","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"core_api::ShabalVarCore::swap_b_c":["fn swap_b_c(&mut self){\n        mem::swap(&mut self.b, &mut self.c);\n    }","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"core_api::ShabalVarCore::xor_w":["fn xor_w(&mut self){\n        self.a[0].0 ^= self.w.0 as u32;\n        self.a[1].0 ^= (self.w.0 >> 32) as u32;\n    }","Real(LocalPath(\"shabal/src/core_api.rs\"))"],"core_api::read_m":["#[inline]\nfn read_m(input: &Block) -> M{\n    let mut m = [Wrapping(0); 16];\n    for (o, chunk) in m.iter_mut().zip(input.chunks_exact(4)) {\n        let a = chunk.try_into().unwrap();\n        *o = Wrapping(u32::from_le_bytes(a));\n    }\n    m\n}","Real(LocalPath(\"shabal/src/core_api.rs\"))"]},"struct_constructor":{"[core::num::Wrapping<u32>; 16]":["read_m"],"core::result::Result":["fmt","new","write_alg_name"],"core_api::ShabalVarCore":["clone"]},"struct_to_trait":{"core_api::ShabalVarCore":["core::clone::Clone","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::UpdateCore","digest::core_api::VariableOutputCore"]},"targets":{"<core_api::ShabalVarCore as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"shabal/src/core_api.rs\"))","core::fmt::Debug"],"<core_api::ShabalVarCore as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"shabal/src/core_api.rs\"))","digest::core_api::AlgorithmName"],"<core_api::ShabalVarCore as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"shabal/src/core_api.rs\"))","digest::core_api::UpdateCore"],"<core_api::ShabalVarCore as digest::core_api::VariableOutputCore>::finalize_variable_core":["finalize_variable_core","Real(LocalPath(\"shabal/src/core_api.rs\"))","digest::core_api::VariableOutputCore"],"<core_api::ShabalVarCore as digest::core_api::VariableOutputCore>::new":["new","Real(LocalPath(\"shabal/src/core_api.rs\"))","digest::core_api::VariableOutputCore"],"core_api::ShabalVarCore::add_m":["add_m","Real(LocalPath(\"shabal/src/core_api.rs\"))",""],"core_api::ShabalVarCore::perm":["perm","Real(LocalPath(\"shabal/src/core_api.rs\"))",""],"core_api::ShabalVarCore::perm_blocks":["perm_blocks","Real(LocalPath(\"shabal/src/core_api.rs\"))",""],"core_api::ShabalVarCore::perm_elt":["perm_elt","Real(LocalPath(\"shabal/src/core_api.rs\"))",""],"core_api::ShabalVarCore::sub_m":["sub_m","Real(LocalPath(\"shabal/src/core_api.rs\"))",""],"core_api::ShabalVarCore::swap_b_c":["swap_b_c","Real(LocalPath(\"shabal/src/core_api.rs\"))",""],"core_api::ShabalVarCore::xor_w":["xor_w","Real(LocalPath(\"shabal/src/core_api.rs\"))",""],"core_api::read_m":["read_m","Real(LocalPath(\"shabal/src/core_api.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["core_api::ShabalVarCore"],"core::fmt::Debug":["core_api::ShabalVarCore"],"digest::HashMarker":["core_api::ShabalVarCore"],"digest::OutputSizeUser":["core_api::ShabalVarCore"],"digest::core_api::AlgorithmName":["core_api::ShabalVarCore"],"digest::core_api::BlockSizeUser":["core_api::ShabalVarCore"],"digest::core_api::BufferKindUser":["core_api::ShabalVarCore"],"digest::core_api::UpdateCore":["core_api::ShabalVarCore"],"digest::core_api::VariableOutputCore":["core_api::ShabalVarCore"]},"type_to_def_path":{"core_api::ShabalVarCore":"core_api::ShabalVarCore"}}