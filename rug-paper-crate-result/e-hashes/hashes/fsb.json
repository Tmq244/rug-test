{"dependencies":{"<Fsb160Core as core::clone::Clone>::clone":["Fsb160Core"],"<Fsb160Core as core::default::Default>::default":["Fsb160Core"],"<Fsb160Core as core::fmt::Debug>::fmt":["Fsb160Core","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Fsb160Core as digest::Reset>::reset":["Fsb160Core"],"<Fsb160Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Fsb160Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Fsb160Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero"],"<Fsb160Core as digest::core_api::UpdateCore>::update_blocks":["Fsb160Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"<Fsb224Core as core::clone::Clone>::clone":["Fsb224Core"],"<Fsb224Core as core::default::Default>::default":["Fsb224Core"],"<Fsb224Core as core::fmt::Debug>::fmt":["Fsb224Core","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Fsb224Core as digest::Reset>::reset":["Fsb224Core"],"<Fsb224Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Fsb224Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Fsb224Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero"],"<Fsb224Core as digest::core_api::UpdateCore>::update_blocks":["Fsb224Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"<Fsb256Core as core::clone::Clone>::clone":["Fsb256Core"],"<Fsb256Core as core::default::Default>::default":["Fsb256Core"],"<Fsb256Core as core::fmt::Debug>::fmt":["Fsb256Core","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Fsb256Core as digest::Reset>::reset":["Fsb256Core"],"<Fsb256Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Fsb256Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Fsb256Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero"],"<Fsb256Core as digest::core_api::UpdateCore>::update_blocks":["Fsb256Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"<Fsb384Core as core::clone::Clone>::clone":["Fsb384Core"],"<Fsb384Core as core::default::Default>::default":["Fsb384Core"],"<Fsb384Core as core::fmt::Debug>::fmt":["Fsb384Core","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Fsb384Core as digest::Reset>::reset":["Fsb384Core"],"<Fsb384Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Fsb384Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Fsb384Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero"],"<Fsb384Core as digest::core_api::UpdateCore>::update_blocks":["Fsb384Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"<Fsb512Core as core::clone::Clone>::clone":["Fsb512Core"],"<Fsb512Core as core::default::Default>::default":["Fsb512Core"],"<Fsb512Core as core::fmt::Debug>::fmt":["Fsb512Core","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Fsb512Core as digest::Reset>::reset":["Fsb512Core"],"<Fsb512Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Fsb512Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Fsb512Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero"],"<Fsb512Core as digest::core_api::UpdateCore>::update_blocks":["Fsb512Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb160Core":["Fsb160Core"],"Fsb160Core::compress":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb160Core::computing_w_indices":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb160Core::define_iv":[],"Fsb160Core::dividing_bits":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb160Core::shift_and_truncate":[],"Fsb224Core":["Fsb224Core"],"Fsb224Core::compress":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb224Core::computing_w_indices":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb224Core::define_iv":[],"Fsb224Core::dividing_bits":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb224Core::shift_and_truncate":[],"Fsb256Core":["Fsb256Core"],"Fsb256Core::compress":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb256Core::computing_w_indices":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb256Core::define_iv":[],"Fsb256Core::dividing_bits":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb256Core::shift_and_truncate":[],"Fsb384Core":["Fsb384Core"],"Fsb384Core::compress":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb384Core::computing_w_indices":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb384Core::define_iv":[],"Fsb384Core::dividing_bits":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb384Core::shift_and_truncate":[],"Fsb512Core":["Fsb512Core"],"Fsb512Core::compress":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb512Core::computing_w_indices":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb512Core::define_iv":[],"Fsb512Core::dividing_bits":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"Fsb512Core::shift_and_truncate":[]},"glob_path_import":{},"self_to_fn":{"Fsb160Core":["Clone","impl $state {\n            const SIZE_OUTPUT_COMPRESS: usize = $r / 8;\n            const SIZE_INPUT_COMPRESS: usize = $s / 8;\n            const SIZE_MSG_CHUNKS: usize = Self::SIZE_INPUT_COMPRESS - Self::SIZE_OUTPUT_COMPRESS;\n            const SIZE_VECTORS: usize = $p / 8 + 1;\n            const SHIFT: u8 = 8 - ($p % 8) as u8;\n\n            fn define_iv(index: usize) -> [u8; Self::SIZE_VECTORS] {\n                let mut subset_pi: [u8; Self::SIZE_VECTORS] = [0u8; Self::SIZE_VECTORS];\n                subset_pi.copy_from_slice(\n                    &PI[index * Self::SIZE_VECTORS..(index + 1) * Self::SIZE_VECTORS],\n                );\n\n                // Now we change the last byte of the vector. We shift right and left, basically to\n                // replace the last `shift` bits by zero.\n                if let Some(last) = subset_pi.last_mut() {\n                    *last >>= Self::SHIFT;\n                    *last <<= Self::SHIFT;\n                }\n\n                subset_pi\n            }\n\n            /// Vector XORing. Given the s input bits of the function, we derive a set of w indexes\n            /// $(W_i)_{i\\in[0;w-1]}$ between $0$ and $n - 1$. The value of each $W_i$ is computed\n            /// from the inputs bits like this:\n            /// $W_i = i \\times (n / w) + IV_i + M_i \\times 2^{r / w}.\n            fn computing_w_indices(\n                input_vector: &[u8; Self::SIZE_OUTPUT_COMPRESS],\n                message: &Block<Self>,\n            ) -> [u32; $w] {\n                let mut wind: [u32; $w] = [0; $w];\n                let divided_message: [u8; $w] = Self::dividing_bits(message, ($s - $r) / $w);\n                for i in 0..($w) {\n                    let message_i = divided_message[i] as u32;\n\n                    wind[i] = (i * $n / $w) as u32\n                        + input_vector[i] as u32\n                        + (message_i << ($r / $w) as u8);\n                }\n\n                wind\n            }\n\n            /// This function servers the purpose presented in table 3, of breaking a bit array into\n            /// batches of size not multiple of 8. Note that the IV will be broken always in size 8, which\n            /// is quite convenient. Also, the only numbers we'll have to worry for are 5 and 6.\n            fn dividing_bits(input_bits: &Block<Self>, size_batches: usize) -> [u8; $w] {\n                if size_batches != 5usize && size_batches != 6usize {\n                    panic!(\n                        \"Expecting batches of size 5 or 6. Other values do not follow \\\n                    the standard specification\"\n                    )\n                }\n\n                let mut new_bits = [0u8; $w];\n                let shifting_factor = (8 - size_batches) as u8;\n                for (i, new_bit) in new_bits.iter_mut().enumerate().take($w - 1) {\n                    let position = i * size_batches;\n                    let initial_byte = position / 8;\n                    let initial_bit = position % 8;\n                    let switch = (initial_bit + size_batches - 1) / 8; // check if we use the next byte\n\n                    if switch == 1 {\n                        *new_bit = (input_bits[initial_byte] << initial_bit as u8\n                            | input_bits[initial_byte + 1] >> (8 - initial_bit as u8))\n                            >> shifting_factor;\n                    } else {\n                        *new_bit =\n                            (input_bits[initial_byte] << initial_bit as u8) >> shifting_factor;\n                    }\n                }\n                new_bits[$w - 1] =\n                    (input_bits[Self::SIZE_MSG_CHUNKS - 1] << shifting_factor) >> shifting_factor;\n\n                new_bits\n            }\n\n            /// This function outputs r bits, which are used to chain to the next iteration.\n            fn compress(hash: &mut [u8; Self::SIZE_OUTPUT_COMPRESS], message_block: &Block<Self>) {\n                let mut initial_vector = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                let w_indices = Self::computing_w_indices(hash, message_block);\n                for w_index in w_indices.iter() {\n                    let chosen_vec = w_index / $r as u32;\n                    let shift_value = w_index % $r as u32;\n                    let mut vector = Self::define_iv(chosen_vec as usize);\n                    let truncated = Self::shift_and_truncate(&mut vector, shift_value);\n\n                    initial_vector\n                        .iter_mut()\n                        .zip(truncated.iter())\n                        .for_each(|(x1, x2)| *x1 ^= *x2);\n                }\n\n                *hash = initial_vector;\n            }\n\n            fn shift_and_truncate(\n                array: &mut [u8; Self::SIZE_VECTORS],\n                shift_value: u32,\n            ) -> [u8; Self::SIZE_OUTPUT_COMPRESS] {\n                let array_len = array.len();\n                let bits_in_cue = ($p % 8) as u8;\n                let mut truncated = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                if shift_value == 0 {\n                    truncated.copy_from_slice(&array[..Self::SIZE_OUTPUT_COMPRESS]);\n                } else if shift_value <= (bits_in_cue as u32) {\n                    let bytes_to_shift = 1;\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    truncated[0] = array[starting_byte] << (bits_in_cue - shift_value as u8);\n                    truncated[0] ^= array[0] >> shift_value;\n                    for position in 1..Self::SIZE_OUTPUT_COMPRESS {\n                        truncated[position] ^= array[position - 1] << (8 - shift_value);\n                        truncated[position] ^= array[position] >> shift_value;\n                    }\n                } else {\n                    // First we need to decide which is the last byte and bit that will go to the first position.\n                    // Then, we build our truncated array from there. Recall that the last byte is not complete,\n                    // and we have a total of P % 8 hanging bits (this will always happen).\n                    let bytes_to_shift =\n                        (((shift_value - bits_in_cue as u32 - 1) / 8) + 2) as usize;\n                    // So then, the starting byte will be:\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    // And the starting bit:\n                    let remaining_bits = ((shift_value - bits_in_cue as u32) % 8) as u8;\n\n                    if remaining_bits != 0 {\n                        for position in 0..(bytes_to_shift - 1) {\n                            truncated[position] = array[starting_byte + position]\n                                << (8 - remaining_bits)\n                                | array[starting_byte + position + 1] >> remaining_bits;\n                        }\n\n                        // The last case is different, as we don't know if there are sufficient bits in the cue to fill\n                        // up a full byte. We have three cases: 1. where P % 8 (bits_in_cue) is larger than\n                        // starting_bit, 2. where it is equal, and 3. where it is smaller. But we can fill the bits, and\n                        // then decide how to proceed depending on the difference.\n                        let difference = bits_in_cue.checked_sub(8 - remaining_bits);\n\n                        match difference {\n                            Some(x) => {\n                                if x > 0 {\n                                    // the next position takes starting_bits from the byte with the remaining zeros, and\n                                    // `difference` from the first byte. Then we iterate by shifting 8 - difference bits.\n                                    truncated[bytes_to_shift - 1] ^= array\n                                        [starting_byte + bytes_to_shift - 1]\n                                        << (bits_in_cue - x);\n                                    truncated[bytes_to_shift - 1] ^= array[0] >> x;\n                                    for (index, position) in\n                                        (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                    {\n                                        truncated[position] ^= array[index] << (8 - x);\n                                        truncated[position] ^= array[index + 1] >> x;\n                                    }\n                                } else {\n                                    for (index, position) in ((bytes_to_shift - 1)\n                                        ..Self::SIZE_OUTPUT_COMPRESS)\n                                        .enumerate()\n                                    {\n                                        truncated[position] = array[index];\n                                    }\n                                }\n                            }\n                            None => {\n                                let positive_diff = (8 - remaining_bits) - bits_in_cue;\n                                // we need to fill the remainder with bits of the next byte.\n                                truncated[bytes_to_shift - 2] ^= array[0] >> (8 - positive_diff);\n                                for (index, position) in\n                                    ((bytes_to_shift - 1)..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                {\n                                    truncated[position] ^= array[index] << positive_diff;\n                                    truncated[position] ^= array[index + 1] >> (8 - positive_diff);\n                                }\n                            }\n                        }\n                    } else {\n                        truncated[..bytes_to_shift].clone_from_slice(\n                            &array[starting_byte..(starting_byte + bytes_to_shift)],\n                        );\n\n                        // we need to fill the remainder with bits of the next byte.\n                        truncated[bytes_to_shift - 1] ^= array[0] >> bits_in_cue;\n                        for (index, position) in\n                            (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                        {\n                            truncated[position] ^= array[index] << (8 - bits_in_cue);\n                            truncated[position] ^= array[index + 1] >> bits_in_cue;\n                        }\n                    }\n                }\n                truncated\n            }\n        }","impl AlgorithmName for $state {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_state))\n            }\n        }","impl BlockSizeUser for $state {\n            type BlockSize = $blocksize;\n        }","impl BufferKindUser for $state {\n            type BufferKind = Eager;\n        }","impl Default for $state {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    blocks_len: 0u64,\n                    state: [0u8; $r / 8],\n                }\n            }\n        }","impl FixedOutputCore for $state {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let block_bytes = self.blocks_len * Self::BlockSize::U64;\n                let bit_len = 8 * (block_bytes + buffer.get_pos() as u64);\n                let mut h = self.state;\n                buffer.len64_padding_be(bit_len, |b| Self::compress(&mut h, b));\n\n                let res = whirlpool::Whirlpool::digest(&h[..]);\n                let n = out.len();\n                out.copy_from_slice(&res[..n]);\n            }\n        }","impl HashMarker for $state {}","impl OutputSizeUser for $state {\n            type OutputSize = $outputsize;\n        }","impl Reset for $state {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $state {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                self.blocks_len += blocks.len() as u64;\n                for block in blocks {\n                    Self::compress(&mut self.state, block);\n                }\n            }\n        }","impl fmt::Debug for $state {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($state), \" { ... }\"))\n            }\n        }"],"Fsb224Core":["Clone","impl $state {\n            const SIZE_OUTPUT_COMPRESS: usize = $r / 8;\n            const SIZE_INPUT_COMPRESS: usize = $s / 8;\n            const SIZE_MSG_CHUNKS: usize = Self::SIZE_INPUT_COMPRESS - Self::SIZE_OUTPUT_COMPRESS;\n            const SIZE_VECTORS: usize = $p / 8 + 1;\n            const SHIFT: u8 = 8 - ($p % 8) as u8;\n\n            fn define_iv(index: usize) -> [u8; Self::SIZE_VECTORS] {\n                let mut subset_pi: [u8; Self::SIZE_VECTORS] = [0u8; Self::SIZE_VECTORS];\n                subset_pi.copy_from_slice(\n                    &PI[index * Self::SIZE_VECTORS..(index + 1) * Self::SIZE_VECTORS],\n                );\n\n                // Now we change the last byte of the vector. We shift right and left, basically to\n                // replace the last `shift` bits by zero.\n                if let Some(last) = subset_pi.last_mut() {\n                    *last >>= Self::SHIFT;\n                    *last <<= Self::SHIFT;\n                }\n\n                subset_pi\n            }\n\n            /// Vector XORing. Given the s input bits of the function, we derive a set of w indexes\n            /// $(W_i)_{i\\in[0;w-1]}$ between $0$ and $n - 1$. The value of each $W_i$ is computed\n            /// from the inputs bits like this:\n            /// $W_i = i \\times (n / w) + IV_i + M_i \\times 2^{r / w}.\n            fn computing_w_indices(\n                input_vector: &[u8; Self::SIZE_OUTPUT_COMPRESS],\n                message: &Block<Self>,\n            ) -> [u32; $w] {\n                let mut wind: [u32; $w] = [0; $w];\n                let divided_message: [u8; $w] = Self::dividing_bits(message, ($s - $r) / $w);\n                for i in 0..($w) {\n                    let message_i = divided_message[i] as u32;\n\n                    wind[i] = (i * $n / $w) as u32\n                        + input_vector[i] as u32\n                        + (message_i << ($r / $w) as u8);\n                }\n\n                wind\n            }\n\n            /// This function servers the purpose presented in table 3, of breaking a bit array into\n            /// batches of size not multiple of 8. Note that the IV will be broken always in size 8, which\n            /// is quite convenient. Also, the only numbers we'll have to worry for are 5 and 6.\n            fn dividing_bits(input_bits: &Block<Self>, size_batches: usize) -> [u8; $w] {\n                if size_batches != 5usize && size_batches != 6usize {\n                    panic!(\n                        \"Expecting batches of size 5 or 6. Other values do not follow \\\n                    the standard specification\"\n                    )\n                }\n\n                let mut new_bits = [0u8; $w];\n                let shifting_factor = (8 - size_batches) as u8;\n                for (i, new_bit) in new_bits.iter_mut().enumerate().take($w - 1) {\n                    let position = i * size_batches;\n                    let initial_byte = position / 8;\n                    let initial_bit = position % 8;\n                    let switch = (initial_bit + size_batches - 1) / 8; // check if we use the next byte\n\n                    if switch == 1 {\n                        *new_bit = (input_bits[initial_byte] << initial_bit as u8\n                            | input_bits[initial_byte + 1] >> (8 - initial_bit as u8))\n                            >> shifting_factor;\n                    } else {\n                        *new_bit =\n                            (input_bits[initial_byte] << initial_bit as u8) >> shifting_factor;\n                    }\n                }\n                new_bits[$w - 1] =\n                    (input_bits[Self::SIZE_MSG_CHUNKS - 1] << shifting_factor) >> shifting_factor;\n\n                new_bits\n            }\n\n            /// This function outputs r bits, which are used to chain to the next iteration.\n            fn compress(hash: &mut [u8; Self::SIZE_OUTPUT_COMPRESS], message_block: &Block<Self>) {\n                let mut initial_vector = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                let w_indices = Self::computing_w_indices(hash, message_block);\n                for w_index in w_indices.iter() {\n                    let chosen_vec = w_index / $r as u32;\n                    let shift_value = w_index % $r as u32;\n                    let mut vector = Self::define_iv(chosen_vec as usize);\n                    let truncated = Self::shift_and_truncate(&mut vector, shift_value);\n\n                    initial_vector\n                        .iter_mut()\n                        .zip(truncated.iter())\n                        .for_each(|(x1, x2)| *x1 ^= *x2);\n                }\n\n                *hash = initial_vector;\n            }\n\n            fn shift_and_truncate(\n                array: &mut [u8; Self::SIZE_VECTORS],\n                shift_value: u32,\n            ) -> [u8; Self::SIZE_OUTPUT_COMPRESS] {\n                let array_len = array.len();\n                let bits_in_cue = ($p % 8) as u8;\n                let mut truncated = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                if shift_value == 0 {\n                    truncated.copy_from_slice(&array[..Self::SIZE_OUTPUT_COMPRESS]);\n                } else if shift_value <= (bits_in_cue as u32) {\n                    let bytes_to_shift = 1;\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    truncated[0] = array[starting_byte] << (bits_in_cue - shift_value as u8);\n                    truncated[0] ^= array[0] >> shift_value;\n                    for position in 1..Self::SIZE_OUTPUT_COMPRESS {\n                        truncated[position] ^= array[position - 1] << (8 - shift_value);\n                        truncated[position] ^= array[position] >> shift_value;\n                    }\n                } else {\n                    // First we need to decide which is the last byte and bit that will go to the first position.\n                    // Then, we build our truncated array from there. Recall that the last byte is not complete,\n                    // and we have a total of P % 8 hanging bits (this will always happen).\n                    let bytes_to_shift =\n                        (((shift_value - bits_in_cue as u32 - 1) / 8) + 2) as usize;\n                    // So then, the starting byte will be:\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    // And the starting bit:\n                    let remaining_bits = ((shift_value - bits_in_cue as u32) % 8) as u8;\n\n                    if remaining_bits != 0 {\n                        for position in 0..(bytes_to_shift - 1) {\n                            truncated[position] = array[starting_byte + position]\n                                << (8 - remaining_bits)\n                                | array[starting_byte + position + 1] >> remaining_bits;\n                        }\n\n                        // The last case is different, as we don't know if there are sufficient bits in the cue to fill\n                        // up a full byte. We have three cases: 1. where P % 8 (bits_in_cue) is larger than\n                        // starting_bit, 2. where it is equal, and 3. where it is smaller. But we can fill the bits, and\n                        // then decide how to proceed depending on the difference.\n                        let difference = bits_in_cue.checked_sub(8 - remaining_bits);\n\n                        match difference {\n                            Some(x) => {\n                                if x > 0 {\n                                    // the next position takes starting_bits from the byte with the remaining zeros, and\n                                    // `difference` from the first byte. Then we iterate by shifting 8 - difference bits.\n                                    truncated[bytes_to_shift - 1] ^= array\n                                        [starting_byte + bytes_to_shift - 1]\n                                        << (bits_in_cue - x);\n                                    truncated[bytes_to_shift - 1] ^= array[0] >> x;\n                                    for (index, position) in\n                                        (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                    {\n                                        truncated[position] ^= array[index] << (8 - x);\n                                        truncated[position] ^= array[index + 1] >> x;\n                                    }\n                                } else {\n                                    for (index, position) in ((bytes_to_shift - 1)\n                                        ..Self::SIZE_OUTPUT_COMPRESS)\n                                        .enumerate()\n                                    {\n                                        truncated[position] = array[index];\n                                    }\n                                }\n                            }\n                            None => {\n                                let positive_diff = (8 - remaining_bits) - bits_in_cue;\n                                // we need to fill the remainder with bits of the next byte.\n                                truncated[bytes_to_shift - 2] ^= array[0] >> (8 - positive_diff);\n                                for (index, position) in\n                                    ((bytes_to_shift - 1)..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                {\n                                    truncated[position] ^= array[index] << positive_diff;\n                                    truncated[position] ^= array[index + 1] >> (8 - positive_diff);\n                                }\n                            }\n                        }\n                    } else {\n                        truncated[..bytes_to_shift].clone_from_slice(\n                            &array[starting_byte..(starting_byte + bytes_to_shift)],\n                        );\n\n                        // we need to fill the remainder with bits of the next byte.\n                        truncated[bytes_to_shift - 1] ^= array[0] >> bits_in_cue;\n                        for (index, position) in\n                            (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                        {\n                            truncated[position] ^= array[index] << (8 - bits_in_cue);\n                            truncated[position] ^= array[index + 1] >> bits_in_cue;\n                        }\n                    }\n                }\n                truncated\n            }\n        }","impl AlgorithmName for $state {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_state))\n            }\n        }","impl BlockSizeUser for $state {\n            type BlockSize = $blocksize;\n        }","impl BufferKindUser for $state {\n            type BufferKind = Eager;\n        }","impl Default for $state {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    blocks_len: 0u64,\n                    state: [0u8; $r / 8],\n                }\n            }\n        }","impl FixedOutputCore for $state {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let block_bytes = self.blocks_len * Self::BlockSize::U64;\n                let bit_len = 8 * (block_bytes + buffer.get_pos() as u64);\n                let mut h = self.state;\n                buffer.len64_padding_be(bit_len, |b| Self::compress(&mut h, b));\n\n                let res = whirlpool::Whirlpool::digest(&h[..]);\n                let n = out.len();\n                out.copy_from_slice(&res[..n]);\n            }\n        }","impl HashMarker for $state {}","impl OutputSizeUser for $state {\n            type OutputSize = $outputsize;\n        }","impl Reset for $state {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $state {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                self.blocks_len += blocks.len() as u64;\n                for block in blocks {\n                    Self::compress(&mut self.state, block);\n                }\n            }\n        }","impl fmt::Debug for $state {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($state), \" { ... }\"))\n            }\n        }"],"Fsb256Core":["Clone","impl $state {\n            const SIZE_OUTPUT_COMPRESS: usize = $r / 8;\n            const SIZE_INPUT_COMPRESS: usize = $s / 8;\n            const SIZE_MSG_CHUNKS: usize = Self::SIZE_INPUT_COMPRESS - Self::SIZE_OUTPUT_COMPRESS;\n            const SIZE_VECTORS: usize = $p / 8 + 1;\n            const SHIFT: u8 = 8 - ($p % 8) as u8;\n\n            fn define_iv(index: usize) -> [u8; Self::SIZE_VECTORS] {\n                let mut subset_pi: [u8; Self::SIZE_VECTORS] = [0u8; Self::SIZE_VECTORS];\n                subset_pi.copy_from_slice(\n                    &PI[index * Self::SIZE_VECTORS..(index + 1) * Self::SIZE_VECTORS],\n                );\n\n                // Now we change the last byte of the vector. We shift right and left, basically to\n                // replace the last `shift` bits by zero.\n                if let Some(last) = subset_pi.last_mut() {\n                    *last >>= Self::SHIFT;\n                    *last <<= Self::SHIFT;\n                }\n\n                subset_pi\n            }\n\n            /// Vector XORing. Given the s input bits of the function, we derive a set of w indexes\n            /// $(W_i)_{i\\in[0;w-1]}$ between $0$ and $n - 1$. The value of each $W_i$ is computed\n            /// from the inputs bits like this:\n            /// $W_i = i \\times (n / w) + IV_i + M_i \\times 2^{r / w}.\n            fn computing_w_indices(\n                input_vector: &[u8; Self::SIZE_OUTPUT_COMPRESS],\n                message: &Block<Self>,\n            ) -> [u32; $w] {\n                let mut wind: [u32; $w] = [0; $w];\n                let divided_message: [u8; $w] = Self::dividing_bits(message, ($s - $r) / $w);\n                for i in 0..($w) {\n                    let message_i = divided_message[i] as u32;\n\n                    wind[i] = (i * $n / $w) as u32\n                        + input_vector[i] as u32\n                        + (message_i << ($r / $w) as u8);\n                }\n\n                wind\n            }\n\n            /// This function servers the purpose presented in table 3, of breaking a bit array into\n            /// batches of size not multiple of 8. Note that the IV will be broken always in size 8, which\n            /// is quite convenient. Also, the only numbers we'll have to worry for are 5 and 6.\n            fn dividing_bits(input_bits: &Block<Self>, size_batches: usize) -> [u8; $w] {\n                if size_batches != 5usize && size_batches != 6usize {\n                    panic!(\n                        \"Expecting batches of size 5 or 6. Other values do not follow \\\n                    the standard specification\"\n                    )\n                }\n\n                let mut new_bits = [0u8; $w];\n                let shifting_factor = (8 - size_batches) as u8;\n                for (i, new_bit) in new_bits.iter_mut().enumerate().take($w - 1) {\n                    let position = i * size_batches;\n                    let initial_byte = position / 8;\n                    let initial_bit = position % 8;\n                    let switch = (initial_bit + size_batches - 1) / 8; // check if we use the next byte\n\n                    if switch == 1 {\n                        *new_bit = (input_bits[initial_byte] << initial_bit as u8\n                            | input_bits[initial_byte + 1] >> (8 - initial_bit as u8))\n                            >> shifting_factor;\n                    } else {\n                        *new_bit =\n                            (input_bits[initial_byte] << initial_bit as u8) >> shifting_factor;\n                    }\n                }\n                new_bits[$w - 1] =\n                    (input_bits[Self::SIZE_MSG_CHUNKS - 1] << shifting_factor) >> shifting_factor;\n\n                new_bits\n            }\n\n            /// This function outputs r bits, which are used to chain to the next iteration.\n            fn compress(hash: &mut [u8; Self::SIZE_OUTPUT_COMPRESS], message_block: &Block<Self>) {\n                let mut initial_vector = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                let w_indices = Self::computing_w_indices(hash, message_block);\n                for w_index in w_indices.iter() {\n                    let chosen_vec = w_index / $r as u32;\n                    let shift_value = w_index % $r as u32;\n                    let mut vector = Self::define_iv(chosen_vec as usize);\n                    let truncated = Self::shift_and_truncate(&mut vector, shift_value);\n\n                    initial_vector\n                        .iter_mut()\n                        .zip(truncated.iter())\n                        .for_each(|(x1, x2)| *x1 ^= *x2);\n                }\n\n                *hash = initial_vector;\n            }\n\n            fn shift_and_truncate(\n                array: &mut [u8; Self::SIZE_VECTORS],\n                shift_value: u32,\n            ) -> [u8; Self::SIZE_OUTPUT_COMPRESS] {\n                let array_len = array.len();\n                let bits_in_cue = ($p % 8) as u8;\n                let mut truncated = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                if shift_value == 0 {\n                    truncated.copy_from_slice(&array[..Self::SIZE_OUTPUT_COMPRESS]);\n                } else if shift_value <= (bits_in_cue as u32) {\n                    let bytes_to_shift = 1;\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    truncated[0] = array[starting_byte] << (bits_in_cue - shift_value as u8);\n                    truncated[0] ^= array[0] >> shift_value;\n                    for position in 1..Self::SIZE_OUTPUT_COMPRESS {\n                        truncated[position] ^= array[position - 1] << (8 - shift_value);\n                        truncated[position] ^= array[position] >> shift_value;\n                    }\n                } else {\n                    // First we need to decide which is the last byte and bit that will go to the first position.\n                    // Then, we build our truncated array from there. Recall that the last byte is not complete,\n                    // and we have a total of P % 8 hanging bits (this will always happen).\n                    let bytes_to_shift =\n                        (((shift_value - bits_in_cue as u32 - 1) / 8) + 2) as usize;\n                    // So then, the starting byte will be:\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    // And the starting bit:\n                    let remaining_bits = ((shift_value - bits_in_cue as u32) % 8) as u8;\n\n                    if remaining_bits != 0 {\n                        for position in 0..(bytes_to_shift - 1) {\n                            truncated[position] = array[starting_byte + position]\n                                << (8 - remaining_bits)\n                                | array[starting_byte + position + 1] >> remaining_bits;\n                        }\n\n                        // The last case is different, as we don't know if there are sufficient bits in the cue to fill\n                        // up a full byte. We have three cases: 1. where P % 8 (bits_in_cue) is larger than\n                        // starting_bit, 2. where it is equal, and 3. where it is smaller. But we can fill the bits, and\n                        // then decide how to proceed depending on the difference.\n                        let difference = bits_in_cue.checked_sub(8 - remaining_bits);\n\n                        match difference {\n                            Some(x) => {\n                                if x > 0 {\n                                    // the next position takes starting_bits from the byte with the remaining zeros, and\n                                    // `difference` from the first byte. Then we iterate by shifting 8 - difference bits.\n                                    truncated[bytes_to_shift - 1] ^= array\n                                        [starting_byte + bytes_to_shift - 1]\n                                        << (bits_in_cue - x);\n                                    truncated[bytes_to_shift - 1] ^= array[0] >> x;\n                                    for (index, position) in\n                                        (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                    {\n                                        truncated[position] ^= array[index] << (8 - x);\n                                        truncated[position] ^= array[index + 1] >> x;\n                                    }\n                                } else {\n                                    for (index, position) in ((bytes_to_shift - 1)\n                                        ..Self::SIZE_OUTPUT_COMPRESS)\n                                        .enumerate()\n                                    {\n                                        truncated[position] = array[index];\n                                    }\n                                }\n                            }\n                            None => {\n                                let positive_diff = (8 - remaining_bits) - bits_in_cue;\n                                // we need to fill the remainder with bits of the next byte.\n                                truncated[bytes_to_shift - 2] ^= array[0] >> (8 - positive_diff);\n                                for (index, position) in\n                                    ((bytes_to_shift - 1)..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                {\n                                    truncated[position] ^= array[index] << positive_diff;\n                                    truncated[position] ^= array[index + 1] >> (8 - positive_diff);\n                                }\n                            }\n                        }\n                    } else {\n                        truncated[..bytes_to_shift].clone_from_slice(\n                            &array[starting_byte..(starting_byte + bytes_to_shift)],\n                        );\n\n                        // we need to fill the remainder with bits of the next byte.\n                        truncated[bytes_to_shift - 1] ^= array[0] >> bits_in_cue;\n                        for (index, position) in\n                            (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                        {\n                            truncated[position] ^= array[index] << (8 - bits_in_cue);\n                            truncated[position] ^= array[index + 1] >> bits_in_cue;\n                        }\n                    }\n                }\n                truncated\n            }\n        }","impl AlgorithmName for $state {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_state))\n            }\n        }","impl BlockSizeUser for $state {\n            type BlockSize = $blocksize;\n        }","impl BufferKindUser for $state {\n            type BufferKind = Eager;\n        }","impl Default for $state {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    blocks_len: 0u64,\n                    state: [0u8; $r / 8],\n                }\n            }\n        }","impl FixedOutputCore for $state {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let block_bytes = self.blocks_len * Self::BlockSize::U64;\n                let bit_len = 8 * (block_bytes + buffer.get_pos() as u64);\n                let mut h = self.state;\n                buffer.len64_padding_be(bit_len, |b| Self::compress(&mut h, b));\n\n                let res = whirlpool::Whirlpool::digest(&h[..]);\n                let n = out.len();\n                out.copy_from_slice(&res[..n]);\n            }\n        }","impl HashMarker for $state {}","impl OutputSizeUser for $state {\n            type OutputSize = $outputsize;\n        }","impl Reset for $state {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $state {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                self.blocks_len += blocks.len() as u64;\n                for block in blocks {\n                    Self::compress(&mut self.state, block);\n                }\n            }\n        }","impl fmt::Debug for $state {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($state), \" { ... }\"))\n            }\n        }"],"Fsb384Core":["Clone","impl $state {\n            const SIZE_OUTPUT_COMPRESS: usize = $r / 8;\n            const SIZE_INPUT_COMPRESS: usize = $s / 8;\n            const SIZE_MSG_CHUNKS: usize = Self::SIZE_INPUT_COMPRESS - Self::SIZE_OUTPUT_COMPRESS;\n            const SIZE_VECTORS: usize = $p / 8 + 1;\n            const SHIFT: u8 = 8 - ($p % 8) as u8;\n\n            fn define_iv(index: usize) -> [u8; Self::SIZE_VECTORS] {\n                let mut subset_pi: [u8; Self::SIZE_VECTORS] = [0u8; Self::SIZE_VECTORS];\n                subset_pi.copy_from_slice(\n                    &PI[index * Self::SIZE_VECTORS..(index + 1) * Self::SIZE_VECTORS],\n                );\n\n                // Now we change the last byte of the vector. We shift right and left, basically to\n                // replace the last `shift` bits by zero.\n                if let Some(last) = subset_pi.last_mut() {\n                    *last >>= Self::SHIFT;\n                    *last <<= Self::SHIFT;\n                }\n\n                subset_pi\n            }\n\n            /// Vector XORing. Given the s input bits of the function, we derive a set of w indexes\n            /// $(W_i)_{i\\in[0;w-1]}$ between $0$ and $n - 1$. The value of each $W_i$ is computed\n            /// from the inputs bits like this:\n            /// $W_i = i \\times (n / w) + IV_i + M_i \\times 2^{r / w}.\n            fn computing_w_indices(\n                input_vector: &[u8; Self::SIZE_OUTPUT_COMPRESS],\n                message: &Block<Self>,\n            ) -> [u32; $w] {\n                let mut wind: [u32; $w] = [0; $w];\n                let divided_message: [u8; $w] = Self::dividing_bits(message, ($s - $r) / $w);\n                for i in 0..($w) {\n                    let message_i = divided_message[i] as u32;\n\n                    wind[i] = (i * $n / $w) as u32\n                        + input_vector[i] as u32\n                        + (message_i << ($r / $w) as u8);\n                }\n\n                wind\n            }\n\n            /// This function servers the purpose presented in table 3, of breaking a bit array into\n            /// batches of size not multiple of 8. Note that the IV will be broken always in size 8, which\n            /// is quite convenient. Also, the only numbers we'll have to worry for are 5 and 6.\n            fn dividing_bits(input_bits: &Block<Self>, size_batches: usize) -> [u8; $w] {\n                if size_batches != 5usize && size_batches != 6usize {\n                    panic!(\n                        \"Expecting batches of size 5 or 6. Other values do not follow \\\n                    the standard specification\"\n                    )\n                }\n\n                let mut new_bits = [0u8; $w];\n                let shifting_factor = (8 - size_batches) as u8;\n                for (i, new_bit) in new_bits.iter_mut().enumerate().take($w - 1) {\n                    let position = i * size_batches;\n                    let initial_byte = position / 8;\n                    let initial_bit = position % 8;\n                    let switch = (initial_bit + size_batches - 1) / 8; // check if we use the next byte\n\n                    if switch == 1 {\n                        *new_bit = (input_bits[initial_byte] << initial_bit as u8\n                            | input_bits[initial_byte + 1] >> (8 - initial_bit as u8))\n                            >> shifting_factor;\n                    } else {\n                        *new_bit =\n                            (input_bits[initial_byte] << initial_bit as u8) >> shifting_factor;\n                    }\n                }\n                new_bits[$w - 1] =\n                    (input_bits[Self::SIZE_MSG_CHUNKS - 1] << shifting_factor) >> shifting_factor;\n\n                new_bits\n            }\n\n            /// This function outputs r bits, which are used to chain to the next iteration.\n            fn compress(hash: &mut [u8; Self::SIZE_OUTPUT_COMPRESS], message_block: &Block<Self>) {\n                let mut initial_vector = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                let w_indices = Self::computing_w_indices(hash, message_block);\n                for w_index in w_indices.iter() {\n                    let chosen_vec = w_index / $r as u32;\n                    let shift_value = w_index % $r as u32;\n                    let mut vector = Self::define_iv(chosen_vec as usize);\n                    let truncated = Self::shift_and_truncate(&mut vector, shift_value);\n\n                    initial_vector\n                        .iter_mut()\n                        .zip(truncated.iter())\n                        .for_each(|(x1, x2)| *x1 ^= *x2);\n                }\n\n                *hash = initial_vector;\n            }\n\n            fn shift_and_truncate(\n                array: &mut [u8; Self::SIZE_VECTORS],\n                shift_value: u32,\n            ) -> [u8; Self::SIZE_OUTPUT_COMPRESS] {\n                let array_len = array.len();\n                let bits_in_cue = ($p % 8) as u8;\n                let mut truncated = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                if shift_value == 0 {\n                    truncated.copy_from_slice(&array[..Self::SIZE_OUTPUT_COMPRESS]);\n                } else if shift_value <= (bits_in_cue as u32) {\n                    let bytes_to_shift = 1;\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    truncated[0] = array[starting_byte] << (bits_in_cue - shift_value as u8);\n                    truncated[0] ^= array[0] >> shift_value;\n                    for position in 1..Self::SIZE_OUTPUT_COMPRESS {\n                        truncated[position] ^= array[position - 1] << (8 - shift_value);\n                        truncated[position] ^= array[position] >> shift_value;\n                    }\n                } else {\n                    // First we need to decide which is the last byte and bit that will go to the first position.\n                    // Then, we build our truncated array from there. Recall that the last byte is not complete,\n                    // and we have a total of P % 8 hanging bits (this will always happen).\n                    let bytes_to_shift =\n                        (((shift_value - bits_in_cue as u32 - 1) / 8) + 2) as usize;\n                    // So then, the starting byte will be:\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    // And the starting bit:\n                    let remaining_bits = ((shift_value - bits_in_cue as u32) % 8) as u8;\n\n                    if remaining_bits != 0 {\n                        for position in 0..(bytes_to_shift - 1) {\n                            truncated[position] = array[starting_byte + position]\n                                << (8 - remaining_bits)\n                                | array[starting_byte + position + 1] >> remaining_bits;\n                        }\n\n                        // The last case is different, as we don't know if there are sufficient bits in the cue to fill\n                        // up a full byte. We have three cases: 1. where P % 8 (bits_in_cue) is larger than\n                        // starting_bit, 2. where it is equal, and 3. where it is smaller. But we can fill the bits, and\n                        // then decide how to proceed depending on the difference.\n                        let difference = bits_in_cue.checked_sub(8 - remaining_bits);\n\n                        match difference {\n                            Some(x) => {\n                                if x > 0 {\n                                    // the next position takes starting_bits from the byte with the remaining zeros, and\n                                    // `difference` from the first byte. Then we iterate by shifting 8 - difference bits.\n                                    truncated[bytes_to_shift - 1] ^= array\n                                        [starting_byte + bytes_to_shift - 1]\n                                        << (bits_in_cue - x);\n                                    truncated[bytes_to_shift - 1] ^= array[0] >> x;\n                                    for (index, position) in\n                                        (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                    {\n                                        truncated[position] ^= array[index] << (8 - x);\n                                        truncated[position] ^= array[index + 1] >> x;\n                                    }\n                                } else {\n                                    for (index, position) in ((bytes_to_shift - 1)\n                                        ..Self::SIZE_OUTPUT_COMPRESS)\n                                        .enumerate()\n                                    {\n                                        truncated[position] = array[index];\n                                    }\n                                }\n                            }\n                            None => {\n                                let positive_diff = (8 - remaining_bits) - bits_in_cue;\n                                // we need to fill the remainder with bits of the next byte.\n                                truncated[bytes_to_shift - 2] ^= array[0] >> (8 - positive_diff);\n                                for (index, position) in\n                                    ((bytes_to_shift - 1)..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                {\n                                    truncated[position] ^= array[index] << positive_diff;\n                                    truncated[position] ^= array[index + 1] >> (8 - positive_diff);\n                                }\n                            }\n                        }\n                    } else {\n                        truncated[..bytes_to_shift].clone_from_slice(\n                            &array[starting_byte..(starting_byte + bytes_to_shift)],\n                        );\n\n                        // we need to fill the remainder with bits of the next byte.\n                        truncated[bytes_to_shift - 1] ^= array[0] >> bits_in_cue;\n                        for (index, position) in\n                            (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                        {\n                            truncated[position] ^= array[index] << (8 - bits_in_cue);\n                            truncated[position] ^= array[index + 1] >> bits_in_cue;\n                        }\n                    }\n                }\n                truncated\n            }\n        }","impl AlgorithmName for $state {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_state))\n            }\n        }","impl BlockSizeUser for $state {\n            type BlockSize = $blocksize;\n        }","impl BufferKindUser for $state {\n            type BufferKind = Eager;\n        }","impl Default for $state {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    blocks_len: 0u64,\n                    state: [0u8; $r / 8],\n                }\n            }\n        }","impl FixedOutputCore for $state {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let block_bytes = self.blocks_len * Self::BlockSize::U64;\n                let bit_len = 8 * (block_bytes + buffer.get_pos() as u64);\n                let mut h = self.state;\n                buffer.len64_padding_be(bit_len, |b| Self::compress(&mut h, b));\n\n                let res = whirlpool::Whirlpool::digest(&h[..]);\n                let n = out.len();\n                out.copy_from_slice(&res[..n]);\n            }\n        }","impl HashMarker for $state {}","impl OutputSizeUser for $state {\n            type OutputSize = $outputsize;\n        }","impl Reset for $state {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $state {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                self.blocks_len += blocks.len() as u64;\n                for block in blocks {\n                    Self::compress(&mut self.state, block);\n                }\n            }\n        }","impl fmt::Debug for $state {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($state), \" { ... }\"))\n            }\n        }"],"Fsb512Core":["Clone","impl $state {\n            const SIZE_OUTPUT_COMPRESS: usize = $r / 8;\n            const SIZE_INPUT_COMPRESS: usize = $s / 8;\n            const SIZE_MSG_CHUNKS: usize = Self::SIZE_INPUT_COMPRESS - Self::SIZE_OUTPUT_COMPRESS;\n            const SIZE_VECTORS: usize = $p / 8 + 1;\n            const SHIFT: u8 = 8 - ($p % 8) as u8;\n\n            fn define_iv(index: usize) -> [u8; Self::SIZE_VECTORS] {\n                let mut subset_pi: [u8; Self::SIZE_VECTORS] = [0u8; Self::SIZE_VECTORS];\n                subset_pi.copy_from_slice(\n                    &PI[index * Self::SIZE_VECTORS..(index + 1) * Self::SIZE_VECTORS],\n                );\n\n                // Now we change the last byte of the vector. We shift right and left, basically to\n                // replace the last `shift` bits by zero.\n                if let Some(last) = subset_pi.last_mut() {\n                    *last >>= Self::SHIFT;\n                    *last <<= Self::SHIFT;\n                }\n\n                subset_pi\n            }\n\n            /// Vector XORing. Given the s input bits of the function, we derive a set of w indexes\n            /// $(W_i)_{i\\in[0;w-1]}$ between $0$ and $n - 1$. The value of each $W_i$ is computed\n            /// from the inputs bits like this:\n            /// $W_i = i \\times (n / w) + IV_i + M_i \\times 2^{r / w}.\n            fn computing_w_indices(\n                input_vector: &[u8; Self::SIZE_OUTPUT_COMPRESS],\n                message: &Block<Self>,\n            ) -> [u32; $w] {\n                let mut wind: [u32; $w] = [0; $w];\n                let divided_message: [u8; $w] = Self::dividing_bits(message, ($s - $r) / $w);\n                for i in 0..($w) {\n                    let message_i = divided_message[i] as u32;\n\n                    wind[i] = (i * $n / $w) as u32\n                        + input_vector[i] as u32\n                        + (message_i << ($r / $w) as u8);\n                }\n\n                wind\n            }\n\n            /// This function servers the purpose presented in table 3, of breaking a bit array into\n            /// batches of size not multiple of 8. Note that the IV will be broken always in size 8, which\n            /// is quite convenient. Also, the only numbers we'll have to worry for are 5 and 6.\n            fn dividing_bits(input_bits: &Block<Self>, size_batches: usize) -> [u8; $w] {\n                if size_batches != 5usize && size_batches != 6usize {\n                    panic!(\n                        \"Expecting batches of size 5 or 6. Other values do not follow \\\n                    the standard specification\"\n                    )\n                }\n\n                let mut new_bits = [0u8; $w];\n                let shifting_factor = (8 - size_batches) as u8;\n                for (i, new_bit) in new_bits.iter_mut().enumerate().take($w - 1) {\n                    let position = i * size_batches;\n                    let initial_byte = position / 8;\n                    let initial_bit = position % 8;\n                    let switch = (initial_bit + size_batches - 1) / 8; // check if we use the next byte\n\n                    if switch == 1 {\n                        *new_bit = (input_bits[initial_byte] << initial_bit as u8\n                            | input_bits[initial_byte + 1] >> (8 - initial_bit as u8))\n                            >> shifting_factor;\n                    } else {\n                        *new_bit =\n                            (input_bits[initial_byte] << initial_bit as u8) >> shifting_factor;\n                    }\n                }\n                new_bits[$w - 1] =\n                    (input_bits[Self::SIZE_MSG_CHUNKS - 1] << shifting_factor) >> shifting_factor;\n\n                new_bits\n            }\n\n            /// This function outputs r bits, which are used to chain to the next iteration.\n            fn compress(hash: &mut [u8; Self::SIZE_OUTPUT_COMPRESS], message_block: &Block<Self>) {\n                let mut initial_vector = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                let w_indices = Self::computing_w_indices(hash, message_block);\n                for w_index in w_indices.iter() {\n                    let chosen_vec = w_index / $r as u32;\n                    let shift_value = w_index % $r as u32;\n                    let mut vector = Self::define_iv(chosen_vec as usize);\n                    let truncated = Self::shift_and_truncate(&mut vector, shift_value);\n\n                    initial_vector\n                        .iter_mut()\n                        .zip(truncated.iter())\n                        .for_each(|(x1, x2)| *x1 ^= *x2);\n                }\n\n                *hash = initial_vector;\n            }\n\n            fn shift_and_truncate(\n                array: &mut [u8; Self::SIZE_VECTORS],\n                shift_value: u32,\n            ) -> [u8; Self::SIZE_OUTPUT_COMPRESS] {\n                let array_len = array.len();\n                let bits_in_cue = ($p % 8) as u8;\n                let mut truncated = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                if shift_value == 0 {\n                    truncated.copy_from_slice(&array[..Self::SIZE_OUTPUT_COMPRESS]);\n                } else if shift_value <= (bits_in_cue as u32) {\n                    let bytes_to_shift = 1;\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    truncated[0] = array[starting_byte] << (bits_in_cue - shift_value as u8);\n                    truncated[0] ^= array[0] >> shift_value;\n                    for position in 1..Self::SIZE_OUTPUT_COMPRESS {\n                        truncated[position] ^= array[position - 1] << (8 - shift_value);\n                        truncated[position] ^= array[position] >> shift_value;\n                    }\n                } else {\n                    // First we need to decide which is the last byte and bit that will go to the first position.\n                    // Then, we build our truncated array from there. Recall that the last byte is not complete,\n                    // and we have a total of P % 8 hanging bits (this will always happen).\n                    let bytes_to_shift =\n                        (((shift_value - bits_in_cue as u32 - 1) / 8) + 2) as usize;\n                    // So then, the starting byte will be:\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    // And the starting bit:\n                    let remaining_bits = ((shift_value - bits_in_cue as u32) % 8) as u8;\n\n                    if remaining_bits != 0 {\n                        for position in 0..(bytes_to_shift - 1) {\n                            truncated[position] = array[starting_byte + position]\n                                << (8 - remaining_bits)\n                                | array[starting_byte + position + 1] >> remaining_bits;\n                        }\n\n                        // The last case is different, as we don't know if there are sufficient bits in the cue to fill\n                        // up a full byte. We have three cases: 1. where P % 8 (bits_in_cue) is larger than\n                        // starting_bit, 2. where it is equal, and 3. where it is smaller. But we can fill the bits, and\n                        // then decide how to proceed depending on the difference.\n                        let difference = bits_in_cue.checked_sub(8 - remaining_bits);\n\n                        match difference {\n                            Some(x) => {\n                                if x > 0 {\n                                    // the next position takes starting_bits from the byte with the remaining zeros, and\n                                    // `difference` from the first byte. Then we iterate by shifting 8 - difference bits.\n                                    truncated[bytes_to_shift - 1] ^= array\n                                        [starting_byte + bytes_to_shift - 1]\n                                        << (bits_in_cue - x);\n                                    truncated[bytes_to_shift - 1] ^= array[0] >> x;\n                                    for (index, position) in\n                                        (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                    {\n                                        truncated[position] ^= array[index] << (8 - x);\n                                        truncated[position] ^= array[index + 1] >> x;\n                                    }\n                                } else {\n                                    for (index, position) in ((bytes_to_shift - 1)\n                                        ..Self::SIZE_OUTPUT_COMPRESS)\n                                        .enumerate()\n                                    {\n                                        truncated[position] = array[index];\n                                    }\n                                }\n                            }\n                            None => {\n                                let positive_diff = (8 - remaining_bits) - bits_in_cue;\n                                // we need to fill the remainder with bits of the next byte.\n                                truncated[bytes_to_shift - 2] ^= array[0] >> (8 - positive_diff);\n                                for (index, position) in\n                                    ((bytes_to_shift - 1)..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                {\n                                    truncated[position] ^= array[index] << positive_diff;\n                                    truncated[position] ^= array[index + 1] >> (8 - positive_diff);\n                                }\n                            }\n                        }\n                    } else {\n                        truncated[..bytes_to_shift].clone_from_slice(\n                            &array[starting_byte..(starting_byte + bytes_to_shift)],\n                        );\n\n                        // we need to fill the remainder with bits of the next byte.\n                        truncated[bytes_to_shift - 1] ^= array[0] >> bits_in_cue;\n                        for (index, position) in\n                            (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                        {\n                            truncated[position] ^= array[index] << (8 - bits_in_cue);\n                            truncated[position] ^= array[index + 1] >> bits_in_cue;\n                        }\n                    }\n                }\n                truncated\n            }\n        }","impl AlgorithmName for $state {\n            fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(stringify!($full_state))\n            }\n        }","impl BlockSizeUser for $state {\n            type BlockSize = $blocksize;\n        }","impl BufferKindUser for $state {\n            type BufferKind = Eager;\n        }","impl Default for $state {\n            #[inline]\n            fn default() -> Self {\n                Self {\n                    blocks_len: 0u64,\n                    state: [0u8; $r / 8],\n                }\n            }\n        }","impl FixedOutputCore for $state {\n            #[inline]\n            fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n                let block_bytes = self.blocks_len * Self::BlockSize::U64;\n                let bit_len = 8 * (block_bytes + buffer.get_pos() as u64);\n                let mut h = self.state;\n                buffer.len64_padding_be(bit_len, |b| Self::compress(&mut h, b));\n\n                let res = whirlpool::Whirlpool::digest(&h[..]);\n                let n = out.len();\n                out.copy_from_slice(&res[..n]);\n            }\n        }","impl HashMarker for $state {}","impl OutputSizeUser for $state {\n            type OutputSize = $outputsize;\n        }","impl Reset for $state {\n            #[inline]\n            fn reset(&mut self) {\n                *self = Default::default();\n            }\n        }","impl UpdateCore for $state {\n            #[inline]\n            fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n                self.blocks_len += blocks.len() as u64;\n                for block in blocks {\n                    Self::compress(&mut self.state, block);\n                }\n            }\n        }","impl fmt::Debug for $state {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(concat!(stringify!($state), \" { ... }\"))\n            }\n        }"]},"single_path_import":{"digest":"digest","digest::Digest":"Digest"},"srcs":{"<Fsb160Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    blocks_len: 0u64,\n                    state: [0u8; $r / 8],\n                }\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb160Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($state), \" { ... }\"))\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb160Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb160Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_state))\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb160Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let block_bytes = self.blocks_len * Self::BlockSize::U64;\n                let bit_len = 8 * (block_bytes + buffer.get_pos() as u64);\n                let mut h = self.state;\n                buffer.len64_padding_be(bit_len, |b| Self::compress(&mut h, b));\n\n                let res = whirlpool::Whirlpool::digest(&h[..]);\n                let n = out.len();\n                out.copy_from_slice(&res[..n]);\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb160Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                self.blocks_len += blocks.len() as u64;\n                for block in blocks {\n                    Self::compress(&mut self.state, block);\n                }\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb224Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    blocks_len: 0u64,\n                    state: [0u8; $r / 8],\n                }\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb224Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($state), \" { ... }\"))\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb224Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb224Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_state))\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb224Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let block_bytes = self.blocks_len * Self::BlockSize::U64;\n                let bit_len = 8 * (block_bytes + buffer.get_pos() as u64);\n                let mut h = self.state;\n                buffer.len64_padding_be(bit_len, |b| Self::compress(&mut h, b));\n\n                let res = whirlpool::Whirlpool::digest(&h[..]);\n                let n = out.len();\n                out.copy_from_slice(&res[..n]);\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb224Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                self.blocks_len += blocks.len() as u64;\n                for block in blocks {\n                    Self::compress(&mut self.state, block);\n                }\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb256Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    blocks_len: 0u64,\n                    state: [0u8; $r / 8],\n                }\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb256Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($state), \" { ... }\"))\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb256Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb256Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_state))\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb256Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let block_bytes = self.blocks_len * Self::BlockSize::U64;\n                let bit_len = 8 * (block_bytes + buffer.get_pos() as u64);\n                let mut h = self.state;\n                buffer.len64_padding_be(bit_len, |b| Self::compress(&mut h, b));\n\n                let res = whirlpool::Whirlpool::digest(&h[..]);\n                let n = out.len();\n                out.copy_from_slice(&res[..n]);\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb256Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                self.blocks_len += blocks.len() as u64;\n                for block in blocks {\n                    Self::compress(&mut self.state, block);\n                }\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb384Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    blocks_len: 0u64,\n                    state: [0u8; $r / 8],\n                }\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb384Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($state), \" { ... }\"))\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb384Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb384Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_state))\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb384Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let block_bytes = self.blocks_len * Self::BlockSize::U64;\n                let bit_len = 8 * (block_bytes + buffer.get_pos() as u64);\n                let mut h = self.state;\n                buffer.len64_padding_be(bit_len, |b| Self::compress(&mut h, b));\n\n                let res = whirlpool::Whirlpool::digest(&h[..]);\n                let n = out.len();\n                out.copy_from_slice(&res[..n]);\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb384Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                self.blocks_len += blocks.len() as u64;\n                for block in blocks {\n                    Self::compress(&mut self.state, block);\n                }\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb512Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n                Self {\n                    blocks_len: 0u64,\n                    state: [0u8; $r / 8],\n                }\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb512Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(concat!(stringify!($state), \" { ... }\"))\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb512Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n                *self = Default::default();\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb512Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n                f.write_str(stringify!($full_state))\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb512Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n                let block_bytes = self.blocks_len * Self::BlockSize::U64;\n                let bit_len = 8 * (block_bytes + buffer.get_pos() as u64);\n                let mut h = self.state;\n                buffer.len64_padding_be(bit_len, |b| Self::compress(&mut h, b));\n\n                let res = whirlpool::Whirlpool::digest(&h[..]);\n                let n = out.len();\n                out.copy_from_slice(&res[..n]);\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"<Fsb512Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n                self.blocks_len += blocks.len() as u64;\n                for block in blocks {\n                    Self::compress(&mut self.state, block);\n                }\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb160Core":["#[doc=$doc]\npub struct $state {\n            blocks_len: u64,\n            state: [u8; $r / 8],\n        }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb160Core::compress":["/// This function outputs r bits, which are used to chain to the next iteration.\nfn compress(hash: &mut [u8; Self::SIZE_OUTPUT_COMPRESS], message_block: &Block<Self>){\n                let mut initial_vector = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                let w_indices = Self::computing_w_indices(hash, message_block);\n                for w_index in w_indices.iter() {\n                    let chosen_vec = w_index / $r as u32;\n                    let shift_value = w_index % $r as u32;\n                    let mut vector = Self::define_iv(chosen_vec as usize);\n                    let truncated = Self::shift_and_truncate(&mut vector, shift_value);\n\n                    initial_vector\n                        .iter_mut()\n                        .zip(truncated.iter())\n                        .for_each(|(x1, x2)| *x1 ^= *x2);\n                }\n\n                *hash = initial_vector;\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb160Core::computing_w_indices":["/// Vector XORing. Given the s input bits of the function, we derive a set of w indexes\n/// $(W_i)_{i\\in[0;w-1]}$ between $0$ and $n - 1$. The value of each $W_i$ is computed\n/// from the inputs bits like this:\n/// $W_i = i \\times (n / w) + IV_i + M_i \\times 2^{r / w}.\nfn computing_w_indices(\n                input_vector: &[u8; Self::SIZE_OUTPUT_COMPRESS],\n                message: &Block<Self>,\n            ) -> [u32; $w]{\n                let mut wind: [u32; $w] = [0; $w];\n                let divided_message: [u8; $w] = Self::dividing_bits(message, ($s - $r) / $w);\n                for i in 0..($w) {\n                    let message_i = divided_message[i] as u32;\n\n                    wind[i] = (i * $n / $w) as u32\n                        + input_vector[i] as u32\n                        + (message_i << ($r / $w) as u8);\n                }\n\n                wind\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb160Core::define_iv":["fn define_iv(index: usize) -> [u8; Self::SIZE_VECTORS]{\n                let mut subset_pi: [u8; Self::SIZE_VECTORS] = [0u8; Self::SIZE_VECTORS];\n                subset_pi.copy_from_slice(\n                    &PI[index * Self::SIZE_VECTORS..(index + 1) * Self::SIZE_VECTORS],\n                );\n\n                // Now we change the last byte of the vector. We shift right and left, basically to\n                // replace the last `shift` bits by zero.\n                if let Some(last) = subset_pi.last_mut() {\n                    *last >>= Self::SHIFT;\n                    *last <<= Self::SHIFT;\n                }\n\n                subset_pi\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb160Core::dividing_bits":["/// This function servers the purpose presented in table 3, of breaking a bit array into\n/// batches of size not multiple of 8. Note that the IV will be broken always in size 8, which\n/// is quite convenient. Also, the only numbers we'll have to worry for are 5 and 6.\nfn dividing_bits(input_bits: &Block<Self>, size_batches: usize) -> [u8; $w]{\n                if size_batches != 5usize && size_batches != 6usize {\n                    panic!(\n                        \"Expecting batches of size 5 or 6. Other values do not follow \\\n                    the standard specification\"\n                    )\n                }\n\n                let mut new_bits = [0u8; $w];\n                let shifting_factor = (8 - size_batches) as u8;\n                for (i, new_bit) in new_bits.iter_mut().enumerate().take($w - 1) {\n                    let position = i * size_batches;\n                    let initial_byte = position / 8;\n                    let initial_bit = position % 8;\n                    let switch = (initial_bit + size_batches - 1) / 8; // check if we use the next byte\n\n                    if switch == 1 {\n                        *new_bit = (input_bits[initial_byte] << initial_bit as u8\n                            | input_bits[initial_byte + 1] >> (8 - initial_bit as u8))\n                            >> shifting_factor;\n                    } else {\n                        *new_bit =\n                            (input_bits[initial_byte] << initial_bit as u8) >> shifting_factor;\n                    }\n                }\n                new_bits[$w - 1] =\n                    (input_bits[Self::SIZE_MSG_CHUNKS - 1] << shifting_factor) >> shifting_factor;\n\n                new_bits\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb160Core::shift_and_truncate":["fn shift_and_truncate(\n                array: &mut [u8; Self::SIZE_VECTORS],\n                shift_value: u32,\n            ) -> [u8; Self::SIZE_OUTPUT_COMPRESS]{\n                let array_len = array.len();\n                let bits_in_cue = ($p % 8) as u8;\n                let mut truncated = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                if shift_value == 0 {\n                    truncated.copy_from_slice(&array[..Self::SIZE_OUTPUT_COMPRESS]);\n                } else if shift_value <= (bits_in_cue as u32) {\n                    let bytes_to_shift = 1;\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    truncated[0] = array[starting_byte] << (bits_in_cue - shift_value as u8);\n                    truncated[0] ^= array[0] >> shift_value;\n                    for position in 1..Self::SIZE_OUTPUT_COMPRESS {\n                        truncated[position] ^= array[position - 1] << (8 - shift_value);\n                        truncated[position] ^= array[position] >> shift_value;\n                    }\n                } else {\n                    // First we need to decide which is the last byte and bit that will go to the first position.\n                    // Then, we build our truncated array from there. Recall that the last byte is not complete,\n                    // and we have a total of P % 8 hanging bits (this will always happen).\n                    let bytes_to_shift =\n                        (((shift_value - bits_in_cue as u32 - 1) / 8) + 2) as usize;\n                    // So then, the starting byte will be:\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    // And the starting bit:\n                    let remaining_bits = ((shift_value - bits_in_cue as u32) % 8) as u8;\n\n                    if remaining_bits != 0 {\n                        for position in 0..(bytes_to_shift - 1) {\n                            truncated[position] = array[starting_byte + position]\n                                << (8 - remaining_bits)\n                                | array[starting_byte + position + 1] >> remaining_bits;\n                        }\n\n                        // The last case is different, as we don't know if there are sufficient bits in the cue to fill\n                        // up a full byte. We have three cases: 1. where P % 8 (bits_in_cue) is larger than\n                        // starting_bit, 2. where it is equal, and 3. where it is smaller. But we can fill the bits, and\n                        // then decide how to proceed depending on the difference.\n                        let difference = bits_in_cue.checked_sub(8 - remaining_bits);\n\n                        match difference {\n                            Some(x) => {\n                                if x > 0 {\n                                    // the next position takes starting_bits from the byte with the remaining zeros, and\n                                    // `difference` from the first byte. Then we iterate by shifting 8 - difference bits.\n                                    truncated[bytes_to_shift - 1] ^= array\n                                        [starting_byte + bytes_to_shift - 1]\n                                        << (bits_in_cue - x);\n                                    truncated[bytes_to_shift - 1] ^= array[0] >> x;\n                                    for (index, position) in\n                                        (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                    {\n                                        truncated[position] ^= array[index] << (8 - x);\n                                        truncated[position] ^= array[index + 1] >> x;\n                                    }\n                                } else {\n                                    for (index, position) in ((bytes_to_shift - 1)\n                                        ..Self::SIZE_OUTPUT_COMPRESS)\n                                        .enumerate()\n                                    {\n                                        truncated[position] = array[index];\n                                    }\n                                }\n                            }\n                            None => {\n                                let positive_diff = (8 - remaining_bits) - bits_in_cue;\n                                // we need to fill the remainder with bits of the next byte.\n                                truncated[bytes_to_shift - 2] ^= array[0] >> (8 - positive_diff);\n                                for (index, position) in\n                                    ((bytes_to_shift - 1)..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                {\n                                    truncated[position] ^= array[index] << positive_diff;\n                                    truncated[position] ^= array[index + 1] >> (8 - positive_diff);\n                                }\n                            }\n                        }\n                    } else {\n                        truncated[..bytes_to_shift].clone_from_slice(\n                            &array[starting_byte..(starting_byte + bytes_to_shift)],\n                        );\n\n                        // we need to fill the remainder with bits of the next byte.\n                        truncated[bytes_to_shift - 1] ^= array[0] >> bits_in_cue;\n                        for (index, position) in\n                            (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                        {\n                            truncated[position] ^= array[index] << (8 - bits_in_cue);\n                            truncated[position] ^= array[index + 1] >> bits_in_cue;\n                        }\n                    }\n                }\n                truncated\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb224Core":["#[doc=$doc]\npub struct $state {\n            blocks_len: u64,\n            state: [u8; $r / 8],\n        }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb224Core::compress":["/// This function outputs r bits, which are used to chain to the next iteration.\nfn compress(hash: &mut [u8; Self::SIZE_OUTPUT_COMPRESS], message_block: &Block<Self>){\n                let mut initial_vector = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                let w_indices = Self::computing_w_indices(hash, message_block);\n                for w_index in w_indices.iter() {\n                    let chosen_vec = w_index / $r as u32;\n                    let shift_value = w_index % $r as u32;\n                    let mut vector = Self::define_iv(chosen_vec as usize);\n                    let truncated = Self::shift_and_truncate(&mut vector, shift_value);\n\n                    initial_vector\n                        .iter_mut()\n                        .zip(truncated.iter())\n                        .for_each(|(x1, x2)| *x1 ^= *x2);\n                }\n\n                *hash = initial_vector;\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb224Core::computing_w_indices":["/// Vector XORing. Given the s input bits of the function, we derive a set of w indexes\n/// $(W_i)_{i\\in[0;w-1]}$ between $0$ and $n - 1$. The value of each $W_i$ is computed\n/// from the inputs bits like this:\n/// $W_i = i \\times (n / w) + IV_i + M_i \\times 2^{r / w}.\nfn computing_w_indices(\n                input_vector: &[u8; Self::SIZE_OUTPUT_COMPRESS],\n                message: &Block<Self>,\n            ) -> [u32; $w]{\n                let mut wind: [u32; $w] = [0; $w];\n                let divided_message: [u8; $w] = Self::dividing_bits(message, ($s - $r) / $w);\n                for i in 0..($w) {\n                    let message_i = divided_message[i] as u32;\n\n                    wind[i] = (i * $n / $w) as u32\n                        + input_vector[i] as u32\n                        + (message_i << ($r / $w) as u8);\n                }\n\n                wind\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb224Core::define_iv":["fn define_iv(index: usize) -> [u8; Self::SIZE_VECTORS]{\n                let mut subset_pi: [u8; Self::SIZE_VECTORS] = [0u8; Self::SIZE_VECTORS];\n                subset_pi.copy_from_slice(\n                    &PI[index * Self::SIZE_VECTORS..(index + 1) * Self::SIZE_VECTORS],\n                );\n\n                // Now we change the last byte of the vector. We shift right and left, basically to\n                // replace the last `shift` bits by zero.\n                if let Some(last) = subset_pi.last_mut() {\n                    *last >>= Self::SHIFT;\n                    *last <<= Self::SHIFT;\n                }\n\n                subset_pi\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb224Core::dividing_bits":["/// This function servers the purpose presented in table 3, of breaking a bit array into\n/// batches of size not multiple of 8. Note that the IV will be broken always in size 8, which\n/// is quite convenient. Also, the only numbers we'll have to worry for are 5 and 6.\nfn dividing_bits(input_bits: &Block<Self>, size_batches: usize) -> [u8; $w]{\n                if size_batches != 5usize && size_batches != 6usize {\n                    panic!(\n                        \"Expecting batches of size 5 or 6. Other values do not follow \\\n                    the standard specification\"\n                    )\n                }\n\n                let mut new_bits = [0u8; $w];\n                let shifting_factor = (8 - size_batches) as u8;\n                for (i, new_bit) in new_bits.iter_mut().enumerate().take($w - 1) {\n                    let position = i * size_batches;\n                    let initial_byte = position / 8;\n                    let initial_bit = position % 8;\n                    let switch = (initial_bit + size_batches - 1) / 8; // check if we use the next byte\n\n                    if switch == 1 {\n                        *new_bit = (input_bits[initial_byte] << initial_bit as u8\n                            | input_bits[initial_byte + 1] >> (8 - initial_bit as u8))\n                            >> shifting_factor;\n                    } else {\n                        *new_bit =\n                            (input_bits[initial_byte] << initial_bit as u8) >> shifting_factor;\n                    }\n                }\n                new_bits[$w - 1] =\n                    (input_bits[Self::SIZE_MSG_CHUNKS - 1] << shifting_factor) >> shifting_factor;\n\n                new_bits\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb224Core::shift_and_truncate":["fn shift_and_truncate(\n                array: &mut [u8; Self::SIZE_VECTORS],\n                shift_value: u32,\n            ) -> [u8; Self::SIZE_OUTPUT_COMPRESS]{\n                let array_len = array.len();\n                let bits_in_cue = ($p % 8) as u8;\n                let mut truncated = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                if shift_value == 0 {\n                    truncated.copy_from_slice(&array[..Self::SIZE_OUTPUT_COMPRESS]);\n                } else if shift_value <= (bits_in_cue as u32) {\n                    let bytes_to_shift = 1;\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    truncated[0] = array[starting_byte] << (bits_in_cue - shift_value as u8);\n                    truncated[0] ^= array[0] >> shift_value;\n                    for position in 1..Self::SIZE_OUTPUT_COMPRESS {\n                        truncated[position] ^= array[position - 1] << (8 - shift_value);\n                        truncated[position] ^= array[position] >> shift_value;\n                    }\n                } else {\n                    // First we need to decide which is the last byte and bit that will go to the first position.\n                    // Then, we build our truncated array from there. Recall that the last byte is not complete,\n                    // and we have a total of P % 8 hanging bits (this will always happen).\n                    let bytes_to_shift =\n                        (((shift_value - bits_in_cue as u32 - 1) / 8) + 2) as usize;\n                    // So then, the starting byte will be:\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    // And the starting bit:\n                    let remaining_bits = ((shift_value - bits_in_cue as u32) % 8) as u8;\n\n                    if remaining_bits != 0 {\n                        for position in 0..(bytes_to_shift - 1) {\n                            truncated[position] = array[starting_byte + position]\n                                << (8 - remaining_bits)\n                                | array[starting_byte + position + 1] >> remaining_bits;\n                        }\n\n                        // The last case is different, as we don't know if there are sufficient bits in the cue to fill\n                        // up a full byte. We have three cases: 1. where P % 8 (bits_in_cue) is larger than\n                        // starting_bit, 2. where it is equal, and 3. where it is smaller. But we can fill the bits, and\n                        // then decide how to proceed depending on the difference.\n                        let difference = bits_in_cue.checked_sub(8 - remaining_bits);\n\n                        match difference {\n                            Some(x) => {\n                                if x > 0 {\n                                    // the next position takes starting_bits from the byte with the remaining zeros, and\n                                    // `difference` from the first byte. Then we iterate by shifting 8 - difference bits.\n                                    truncated[bytes_to_shift - 1] ^= array\n                                        [starting_byte + bytes_to_shift - 1]\n                                        << (bits_in_cue - x);\n                                    truncated[bytes_to_shift - 1] ^= array[0] >> x;\n                                    for (index, position) in\n                                        (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                    {\n                                        truncated[position] ^= array[index] << (8 - x);\n                                        truncated[position] ^= array[index + 1] >> x;\n                                    }\n                                } else {\n                                    for (index, position) in ((bytes_to_shift - 1)\n                                        ..Self::SIZE_OUTPUT_COMPRESS)\n                                        .enumerate()\n                                    {\n                                        truncated[position] = array[index];\n                                    }\n                                }\n                            }\n                            None => {\n                                let positive_diff = (8 - remaining_bits) - bits_in_cue;\n                                // we need to fill the remainder with bits of the next byte.\n                                truncated[bytes_to_shift - 2] ^= array[0] >> (8 - positive_diff);\n                                for (index, position) in\n                                    ((bytes_to_shift - 1)..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                {\n                                    truncated[position] ^= array[index] << positive_diff;\n                                    truncated[position] ^= array[index + 1] >> (8 - positive_diff);\n                                }\n                            }\n                        }\n                    } else {\n                        truncated[..bytes_to_shift].clone_from_slice(\n                            &array[starting_byte..(starting_byte + bytes_to_shift)],\n                        );\n\n                        // we need to fill the remainder with bits of the next byte.\n                        truncated[bytes_to_shift - 1] ^= array[0] >> bits_in_cue;\n                        for (index, position) in\n                            (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                        {\n                            truncated[position] ^= array[index] << (8 - bits_in_cue);\n                            truncated[position] ^= array[index + 1] >> bits_in_cue;\n                        }\n                    }\n                }\n                truncated\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb256Core":["#[doc=$doc]\npub struct $state {\n            blocks_len: u64,\n            state: [u8; $r / 8],\n        }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb256Core::compress":["/// This function outputs r bits, which are used to chain to the next iteration.\nfn compress(hash: &mut [u8; Self::SIZE_OUTPUT_COMPRESS], message_block: &Block<Self>){\n                let mut initial_vector = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                let w_indices = Self::computing_w_indices(hash, message_block);\n                for w_index in w_indices.iter() {\n                    let chosen_vec = w_index / $r as u32;\n                    let shift_value = w_index % $r as u32;\n                    let mut vector = Self::define_iv(chosen_vec as usize);\n                    let truncated = Self::shift_and_truncate(&mut vector, shift_value);\n\n                    initial_vector\n                        .iter_mut()\n                        .zip(truncated.iter())\n                        .for_each(|(x1, x2)| *x1 ^= *x2);\n                }\n\n                *hash = initial_vector;\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb256Core::computing_w_indices":["/// Vector XORing. Given the s input bits of the function, we derive a set of w indexes\n/// $(W_i)_{i\\in[0;w-1]}$ between $0$ and $n - 1$. The value of each $W_i$ is computed\n/// from the inputs bits like this:\n/// $W_i = i \\times (n / w) + IV_i + M_i \\times 2^{r / w}.\nfn computing_w_indices(\n                input_vector: &[u8; Self::SIZE_OUTPUT_COMPRESS],\n                message: &Block<Self>,\n            ) -> [u32; $w]{\n                let mut wind: [u32; $w] = [0; $w];\n                let divided_message: [u8; $w] = Self::dividing_bits(message, ($s - $r) / $w);\n                for i in 0..($w) {\n                    let message_i = divided_message[i] as u32;\n\n                    wind[i] = (i * $n / $w) as u32\n                        + input_vector[i] as u32\n                        + (message_i << ($r / $w) as u8);\n                }\n\n                wind\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb256Core::define_iv":["fn define_iv(index: usize) -> [u8; Self::SIZE_VECTORS]{\n                let mut subset_pi: [u8; Self::SIZE_VECTORS] = [0u8; Self::SIZE_VECTORS];\n                subset_pi.copy_from_slice(\n                    &PI[index * Self::SIZE_VECTORS..(index + 1) * Self::SIZE_VECTORS],\n                );\n\n                // Now we change the last byte of the vector. We shift right and left, basically to\n                // replace the last `shift` bits by zero.\n                if let Some(last) = subset_pi.last_mut() {\n                    *last >>= Self::SHIFT;\n                    *last <<= Self::SHIFT;\n                }\n\n                subset_pi\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb256Core::dividing_bits":["/// This function servers the purpose presented in table 3, of breaking a bit array into\n/// batches of size not multiple of 8. Note that the IV will be broken always in size 8, which\n/// is quite convenient. Also, the only numbers we'll have to worry for are 5 and 6.\nfn dividing_bits(input_bits: &Block<Self>, size_batches: usize) -> [u8; $w]{\n                if size_batches != 5usize && size_batches != 6usize {\n                    panic!(\n                        \"Expecting batches of size 5 or 6. Other values do not follow \\\n                    the standard specification\"\n                    )\n                }\n\n                let mut new_bits = [0u8; $w];\n                let shifting_factor = (8 - size_batches) as u8;\n                for (i, new_bit) in new_bits.iter_mut().enumerate().take($w - 1) {\n                    let position = i * size_batches;\n                    let initial_byte = position / 8;\n                    let initial_bit = position % 8;\n                    let switch = (initial_bit + size_batches - 1) / 8; // check if we use the next byte\n\n                    if switch == 1 {\n                        *new_bit = (input_bits[initial_byte] << initial_bit as u8\n                            | input_bits[initial_byte + 1] >> (8 - initial_bit as u8))\n                            >> shifting_factor;\n                    } else {\n                        *new_bit =\n                            (input_bits[initial_byte] << initial_bit as u8) >> shifting_factor;\n                    }\n                }\n                new_bits[$w - 1] =\n                    (input_bits[Self::SIZE_MSG_CHUNKS - 1] << shifting_factor) >> shifting_factor;\n\n                new_bits\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb256Core::shift_and_truncate":["fn shift_and_truncate(\n                array: &mut [u8; Self::SIZE_VECTORS],\n                shift_value: u32,\n            ) -> [u8; Self::SIZE_OUTPUT_COMPRESS]{\n                let array_len = array.len();\n                let bits_in_cue = ($p % 8) as u8;\n                let mut truncated = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                if shift_value == 0 {\n                    truncated.copy_from_slice(&array[..Self::SIZE_OUTPUT_COMPRESS]);\n                } else if shift_value <= (bits_in_cue as u32) {\n                    let bytes_to_shift = 1;\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    truncated[0] = array[starting_byte] << (bits_in_cue - shift_value as u8);\n                    truncated[0] ^= array[0] >> shift_value;\n                    for position in 1..Self::SIZE_OUTPUT_COMPRESS {\n                        truncated[position] ^= array[position - 1] << (8 - shift_value);\n                        truncated[position] ^= array[position] >> shift_value;\n                    }\n                } else {\n                    // First we need to decide which is the last byte and bit that will go to the first position.\n                    // Then, we build our truncated array from there. Recall that the last byte is not complete,\n                    // and we have a total of P % 8 hanging bits (this will always happen).\n                    let bytes_to_shift =\n                        (((shift_value - bits_in_cue as u32 - 1) / 8) + 2) as usize;\n                    // So then, the starting byte will be:\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    // And the starting bit:\n                    let remaining_bits = ((shift_value - bits_in_cue as u32) % 8) as u8;\n\n                    if remaining_bits != 0 {\n                        for position in 0..(bytes_to_shift - 1) {\n                            truncated[position] = array[starting_byte + position]\n                                << (8 - remaining_bits)\n                                | array[starting_byte + position + 1] >> remaining_bits;\n                        }\n\n                        // The last case is different, as we don't know if there are sufficient bits in the cue to fill\n                        // up a full byte. We have three cases: 1. where P % 8 (bits_in_cue) is larger than\n                        // starting_bit, 2. where it is equal, and 3. where it is smaller. But we can fill the bits, and\n                        // then decide how to proceed depending on the difference.\n                        let difference = bits_in_cue.checked_sub(8 - remaining_bits);\n\n                        match difference {\n                            Some(x) => {\n                                if x > 0 {\n                                    // the next position takes starting_bits from the byte with the remaining zeros, and\n                                    // `difference` from the first byte. Then we iterate by shifting 8 - difference bits.\n                                    truncated[bytes_to_shift - 1] ^= array\n                                        [starting_byte + bytes_to_shift - 1]\n                                        << (bits_in_cue - x);\n                                    truncated[bytes_to_shift - 1] ^= array[0] >> x;\n                                    for (index, position) in\n                                        (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                    {\n                                        truncated[position] ^= array[index] << (8 - x);\n                                        truncated[position] ^= array[index + 1] >> x;\n                                    }\n                                } else {\n                                    for (index, position) in ((bytes_to_shift - 1)\n                                        ..Self::SIZE_OUTPUT_COMPRESS)\n                                        .enumerate()\n                                    {\n                                        truncated[position] = array[index];\n                                    }\n                                }\n                            }\n                            None => {\n                                let positive_diff = (8 - remaining_bits) - bits_in_cue;\n                                // we need to fill the remainder with bits of the next byte.\n                                truncated[bytes_to_shift - 2] ^= array[0] >> (8 - positive_diff);\n                                for (index, position) in\n                                    ((bytes_to_shift - 1)..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                {\n                                    truncated[position] ^= array[index] << positive_diff;\n                                    truncated[position] ^= array[index + 1] >> (8 - positive_diff);\n                                }\n                            }\n                        }\n                    } else {\n                        truncated[..bytes_to_shift].clone_from_slice(\n                            &array[starting_byte..(starting_byte + bytes_to_shift)],\n                        );\n\n                        // we need to fill the remainder with bits of the next byte.\n                        truncated[bytes_to_shift - 1] ^= array[0] >> bits_in_cue;\n                        for (index, position) in\n                            (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                        {\n                            truncated[position] ^= array[index] << (8 - bits_in_cue);\n                            truncated[position] ^= array[index + 1] >> bits_in_cue;\n                        }\n                    }\n                }\n                truncated\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb384Core":["#[doc=$doc]\npub struct $state {\n            blocks_len: u64,\n            state: [u8; $r / 8],\n        }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb384Core::compress":["/// This function outputs r bits, which are used to chain to the next iteration.\nfn compress(hash: &mut [u8; Self::SIZE_OUTPUT_COMPRESS], message_block: &Block<Self>){\n                let mut initial_vector = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                let w_indices = Self::computing_w_indices(hash, message_block);\n                for w_index in w_indices.iter() {\n                    let chosen_vec = w_index / $r as u32;\n                    let shift_value = w_index % $r as u32;\n                    let mut vector = Self::define_iv(chosen_vec as usize);\n                    let truncated = Self::shift_and_truncate(&mut vector, shift_value);\n\n                    initial_vector\n                        .iter_mut()\n                        .zip(truncated.iter())\n                        .for_each(|(x1, x2)| *x1 ^= *x2);\n                }\n\n                *hash = initial_vector;\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb384Core::computing_w_indices":["/// Vector XORing. Given the s input bits of the function, we derive a set of w indexes\n/// $(W_i)_{i\\in[0;w-1]}$ between $0$ and $n - 1$. The value of each $W_i$ is computed\n/// from the inputs bits like this:\n/// $W_i = i \\times (n / w) + IV_i + M_i \\times 2^{r / w}.\nfn computing_w_indices(\n                input_vector: &[u8; Self::SIZE_OUTPUT_COMPRESS],\n                message: &Block<Self>,\n            ) -> [u32; $w]{\n                let mut wind: [u32; $w] = [0; $w];\n                let divided_message: [u8; $w] = Self::dividing_bits(message, ($s - $r) / $w);\n                for i in 0..($w) {\n                    let message_i = divided_message[i] as u32;\n\n                    wind[i] = (i * $n / $w) as u32\n                        + input_vector[i] as u32\n                        + (message_i << ($r / $w) as u8);\n                }\n\n                wind\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb384Core::define_iv":["fn define_iv(index: usize) -> [u8; Self::SIZE_VECTORS]{\n                let mut subset_pi: [u8; Self::SIZE_VECTORS] = [0u8; Self::SIZE_VECTORS];\n                subset_pi.copy_from_slice(\n                    &PI[index * Self::SIZE_VECTORS..(index + 1) * Self::SIZE_VECTORS],\n                );\n\n                // Now we change the last byte of the vector. We shift right and left, basically to\n                // replace the last `shift` bits by zero.\n                if let Some(last) = subset_pi.last_mut() {\n                    *last >>= Self::SHIFT;\n                    *last <<= Self::SHIFT;\n                }\n\n                subset_pi\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb384Core::dividing_bits":["/// This function servers the purpose presented in table 3, of breaking a bit array into\n/// batches of size not multiple of 8. Note that the IV will be broken always in size 8, which\n/// is quite convenient. Also, the only numbers we'll have to worry for are 5 and 6.\nfn dividing_bits(input_bits: &Block<Self>, size_batches: usize) -> [u8; $w]{\n                if size_batches != 5usize && size_batches != 6usize {\n                    panic!(\n                        \"Expecting batches of size 5 or 6. Other values do not follow \\\n                    the standard specification\"\n                    )\n                }\n\n                let mut new_bits = [0u8; $w];\n                let shifting_factor = (8 - size_batches) as u8;\n                for (i, new_bit) in new_bits.iter_mut().enumerate().take($w - 1) {\n                    let position = i * size_batches;\n                    let initial_byte = position / 8;\n                    let initial_bit = position % 8;\n                    let switch = (initial_bit + size_batches - 1) / 8; // check if we use the next byte\n\n                    if switch == 1 {\n                        *new_bit = (input_bits[initial_byte] << initial_bit as u8\n                            | input_bits[initial_byte + 1] >> (8 - initial_bit as u8))\n                            >> shifting_factor;\n                    } else {\n                        *new_bit =\n                            (input_bits[initial_byte] << initial_bit as u8) >> shifting_factor;\n                    }\n                }\n                new_bits[$w - 1] =\n                    (input_bits[Self::SIZE_MSG_CHUNKS - 1] << shifting_factor) >> shifting_factor;\n\n                new_bits\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb384Core::shift_and_truncate":["fn shift_and_truncate(\n                array: &mut [u8; Self::SIZE_VECTORS],\n                shift_value: u32,\n            ) -> [u8; Self::SIZE_OUTPUT_COMPRESS]{\n                let array_len = array.len();\n                let bits_in_cue = ($p % 8) as u8;\n                let mut truncated = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                if shift_value == 0 {\n                    truncated.copy_from_slice(&array[..Self::SIZE_OUTPUT_COMPRESS]);\n                } else if shift_value <= (bits_in_cue as u32) {\n                    let bytes_to_shift = 1;\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    truncated[0] = array[starting_byte] << (bits_in_cue - shift_value as u8);\n                    truncated[0] ^= array[0] >> shift_value;\n                    for position in 1..Self::SIZE_OUTPUT_COMPRESS {\n                        truncated[position] ^= array[position - 1] << (8 - shift_value);\n                        truncated[position] ^= array[position] >> shift_value;\n                    }\n                } else {\n                    // First we need to decide which is the last byte and bit that will go to the first position.\n                    // Then, we build our truncated array from there. Recall that the last byte is not complete,\n                    // and we have a total of P % 8 hanging bits (this will always happen).\n                    let bytes_to_shift =\n                        (((shift_value - bits_in_cue as u32 - 1) / 8) + 2) as usize;\n                    // So then, the starting byte will be:\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    // And the starting bit:\n                    let remaining_bits = ((shift_value - bits_in_cue as u32) % 8) as u8;\n\n                    if remaining_bits != 0 {\n                        for position in 0..(bytes_to_shift - 1) {\n                            truncated[position] = array[starting_byte + position]\n                                << (8 - remaining_bits)\n                                | array[starting_byte + position + 1] >> remaining_bits;\n                        }\n\n                        // The last case is different, as we don't know if there are sufficient bits in the cue to fill\n                        // up a full byte. We have three cases: 1. where P % 8 (bits_in_cue) is larger than\n                        // starting_bit, 2. where it is equal, and 3. where it is smaller. But we can fill the bits, and\n                        // then decide how to proceed depending on the difference.\n                        let difference = bits_in_cue.checked_sub(8 - remaining_bits);\n\n                        match difference {\n                            Some(x) => {\n                                if x > 0 {\n                                    // the next position takes starting_bits from the byte with the remaining zeros, and\n                                    // `difference` from the first byte. Then we iterate by shifting 8 - difference bits.\n                                    truncated[bytes_to_shift - 1] ^= array\n                                        [starting_byte + bytes_to_shift - 1]\n                                        << (bits_in_cue - x);\n                                    truncated[bytes_to_shift - 1] ^= array[0] >> x;\n                                    for (index, position) in\n                                        (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                    {\n                                        truncated[position] ^= array[index] << (8 - x);\n                                        truncated[position] ^= array[index + 1] >> x;\n                                    }\n                                } else {\n                                    for (index, position) in ((bytes_to_shift - 1)\n                                        ..Self::SIZE_OUTPUT_COMPRESS)\n                                        .enumerate()\n                                    {\n                                        truncated[position] = array[index];\n                                    }\n                                }\n                            }\n                            None => {\n                                let positive_diff = (8 - remaining_bits) - bits_in_cue;\n                                // we need to fill the remainder with bits of the next byte.\n                                truncated[bytes_to_shift - 2] ^= array[0] >> (8 - positive_diff);\n                                for (index, position) in\n                                    ((bytes_to_shift - 1)..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                {\n                                    truncated[position] ^= array[index] << positive_diff;\n                                    truncated[position] ^= array[index + 1] >> (8 - positive_diff);\n                                }\n                            }\n                        }\n                    } else {\n                        truncated[..bytes_to_shift].clone_from_slice(\n                            &array[starting_byte..(starting_byte + bytes_to_shift)],\n                        );\n\n                        // we need to fill the remainder with bits of the next byte.\n                        truncated[bytes_to_shift - 1] ^= array[0] >> bits_in_cue;\n                        for (index, position) in\n                            (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                        {\n                            truncated[position] ^= array[index] << (8 - bits_in_cue);\n                            truncated[position] ^= array[index + 1] >> bits_in_cue;\n                        }\n                    }\n                }\n                truncated\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb512Core":["#[doc=$doc]\npub struct $state {\n            blocks_len: u64,\n            state: [u8; $r / 8],\n        }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb512Core::compress":["/// This function outputs r bits, which are used to chain to the next iteration.\nfn compress(hash: &mut [u8; Self::SIZE_OUTPUT_COMPRESS], message_block: &Block<Self>){\n                let mut initial_vector = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                let w_indices = Self::computing_w_indices(hash, message_block);\n                for w_index in w_indices.iter() {\n                    let chosen_vec = w_index / $r as u32;\n                    let shift_value = w_index % $r as u32;\n                    let mut vector = Self::define_iv(chosen_vec as usize);\n                    let truncated = Self::shift_and_truncate(&mut vector, shift_value);\n\n                    initial_vector\n                        .iter_mut()\n                        .zip(truncated.iter())\n                        .for_each(|(x1, x2)| *x1 ^= *x2);\n                }\n\n                *hash = initial_vector;\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb512Core::computing_w_indices":["/// Vector XORing. Given the s input bits of the function, we derive a set of w indexes\n/// $(W_i)_{i\\in[0;w-1]}$ between $0$ and $n - 1$. The value of each $W_i$ is computed\n/// from the inputs bits like this:\n/// $W_i = i \\times (n / w) + IV_i + M_i \\times 2^{r / w}.\nfn computing_w_indices(\n                input_vector: &[u8; Self::SIZE_OUTPUT_COMPRESS],\n                message: &Block<Self>,\n            ) -> [u32; $w]{\n                let mut wind: [u32; $w] = [0; $w];\n                let divided_message: [u8; $w] = Self::dividing_bits(message, ($s - $r) / $w);\n                for i in 0..($w) {\n                    let message_i = divided_message[i] as u32;\n\n                    wind[i] = (i * $n / $w) as u32\n                        + input_vector[i] as u32\n                        + (message_i << ($r / $w) as u8);\n                }\n\n                wind\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb512Core::define_iv":["fn define_iv(index: usize) -> [u8; Self::SIZE_VECTORS]{\n                let mut subset_pi: [u8; Self::SIZE_VECTORS] = [0u8; Self::SIZE_VECTORS];\n                subset_pi.copy_from_slice(\n                    &PI[index * Self::SIZE_VECTORS..(index + 1) * Self::SIZE_VECTORS],\n                );\n\n                // Now we change the last byte of the vector. We shift right and left, basically to\n                // replace the last `shift` bits by zero.\n                if let Some(last) = subset_pi.last_mut() {\n                    *last >>= Self::SHIFT;\n                    *last <<= Self::SHIFT;\n                }\n\n                subset_pi\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb512Core::dividing_bits":["/// This function servers the purpose presented in table 3, of breaking a bit array into\n/// batches of size not multiple of 8. Note that the IV will be broken always in size 8, which\n/// is quite convenient. Also, the only numbers we'll have to worry for are 5 and 6.\nfn dividing_bits(input_bits: &Block<Self>, size_batches: usize) -> [u8; $w]{\n                if size_batches != 5usize && size_batches != 6usize {\n                    panic!(\n                        \"Expecting batches of size 5 or 6. Other values do not follow \\\n                    the standard specification\"\n                    )\n                }\n\n                let mut new_bits = [0u8; $w];\n                let shifting_factor = (8 - size_batches) as u8;\n                for (i, new_bit) in new_bits.iter_mut().enumerate().take($w - 1) {\n                    let position = i * size_batches;\n                    let initial_byte = position / 8;\n                    let initial_bit = position % 8;\n                    let switch = (initial_bit + size_batches - 1) / 8; // check if we use the next byte\n\n                    if switch == 1 {\n                        *new_bit = (input_bits[initial_byte] << initial_bit as u8\n                            | input_bits[initial_byte + 1] >> (8 - initial_bit as u8))\n                            >> shifting_factor;\n                    } else {\n                        *new_bit =\n                            (input_bits[initial_byte] << initial_bit as u8) >> shifting_factor;\n                    }\n                }\n                new_bits[$w - 1] =\n                    (input_bits[Self::SIZE_MSG_CHUNKS - 1] << shifting_factor) >> shifting_factor;\n\n                new_bits\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"],"Fsb512Core::shift_and_truncate":["fn shift_and_truncate(\n                array: &mut [u8; Self::SIZE_VECTORS],\n                shift_value: u32,\n            ) -> [u8; Self::SIZE_OUTPUT_COMPRESS]{\n                let array_len = array.len();\n                let bits_in_cue = ($p % 8) as u8;\n                let mut truncated = [0u8; Self::SIZE_OUTPUT_COMPRESS];\n\n                if shift_value == 0 {\n                    truncated.copy_from_slice(&array[..Self::SIZE_OUTPUT_COMPRESS]);\n                } else if shift_value <= (bits_in_cue as u32) {\n                    let bytes_to_shift = 1;\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    truncated[0] = array[starting_byte] << (bits_in_cue - shift_value as u8);\n                    truncated[0] ^= array[0] >> shift_value;\n                    for position in 1..Self::SIZE_OUTPUT_COMPRESS {\n                        truncated[position] ^= array[position - 1] << (8 - shift_value);\n                        truncated[position] ^= array[position] >> shift_value;\n                    }\n                } else {\n                    // First we need to decide which is the last byte and bit that will go to the first position.\n                    // Then, we build our truncated array from there. Recall that the last byte is not complete,\n                    // and we have a total of P % 8 hanging bits (this will always happen).\n                    let bytes_to_shift =\n                        (((shift_value - bits_in_cue as u32 - 1) / 8) + 2) as usize;\n                    // So then, the starting byte will be:\n                    let starting_byte = (array_len - bytes_to_shift) as usize;\n\n                    // And the starting bit:\n                    let remaining_bits = ((shift_value - bits_in_cue as u32) % 8) as u8;\n\n                    if remaining_bits != 0 {\n                        for position in 0..(bytes_to_shift - 1) {\n                            truncated[position] = array[starting_byte + position]\n                                << (8 - remaining_bits)\n                                | array[starting_byte + position + 1] >> remaining_bits;\n                        }\n\n                        // The last case is different, as we don't know if there are sufficient bits in the cue to fill\n                        // up a full byte. We have three cases: 1. where P % 8 (bits_in_cue) is larger than\n                        // starting_bit, 2. where it is equal, and 3. where it is smaller. But we can fill the bits, and\n                        // then decide how to proceed depending on the difference.\n                        let difference = bits_in_cue.checked_sub(8 - remaining_bits);\n\n                        match difference {\n                            Some(x) => {\n                                if x > 0 {\n                                    // the next position takes starting_bits from the byte with the remaining zeros, and\n                                    // `difference` from the first byte. Then we iterate by shifting 8 - difference bits.\n                                    truncated[bytes_to_shift - 1] ^= array\n                                        [starting_byte + bytes_to_shift - 1]\n                                        << (bits_in_cue - x);\n                                    truncated[bytes_to_shift - 1] ^= array[0] >> x;\n                                    for (index, position) in\n                                        (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                    {\n                                        truncated[position] ^= array[index] << (8 - x);\n                                        truncated[position] ^= array[index + 1] >> x;\n                                    }\n                                } else {\n                                    for (index, position) in ((bytes_to_shift - 1)\n                                        ..Self::SIZE_OUTPUT_COMPRESS)\n                                        .enumerate()\n                                    {\n                                        truncated[position] = array[index];\n                                    }\n                                }\n                            }\n                            None => {\n                                let positive_diff = (8 - remaining_bits) - bits_in_cue;\n                                // we need to fill the remainder with bits of the next byte.\n                                truncated[bytes_to_shift - 2] ^= array[0] >> (8 - positive_diff);\n                                for (index, position) in\n                                    ((bytes_to_shift - 1)..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                                {\n                                    truncated[position] ^= array[index] << positive_diff;\n                                    truncated[position] ^= array[index + 1] >> (8 - positive_diff);\n                                }\n                            }\n                        }\n                    } else {\n                        truncated[..bytes_to_shift].clone_from_slice(\n                            &array[starting_byte..(starting_byte + bytes_to_shift)],\n                        );\n\n                        // we need to fill the remainder with bits of the next byte.\n                        truncated[bytes_to_shift - 1] ^= array[0] >> bits_in_cue;\n                        for (index, position) in\n                            (bytes_to_shift..Self::SIZE_OUTPUT_COMPRESS).enumerate()\n                        {\n                            truncated[position] ^= array[index] << (8 - bits_in_cue);\n                            truncated[position] ^= array[index + 1] >> bits_in_cue;\n                        }\n                    }\n                }\n                truncated\n            }","Real(LocalPath(\"fsb/src/macros.rs\"))"]},"struct_constructor":{"Fsb160Core":["clone","default"],"Fsb224Core":["clone","default"],"Fsb256Core":["clone","default"],"Fsb384Core":["clone","default"],"Fsb512Core":["clone","default"],"[u32; 112]":["computing_w_indices"],"[u32; 128]":["computing_w_indices"],"[u32; 184]":["computing_w_indices"],"[u32; 248]":["computing_w_indices"],"[u32; 80]":["computing_w_indices"],"[u8; 112]":["dividing_bits"],"[u8; 128]":["dividing_bits"],"[u8; 184]":["dividing_bits"],"[u8; 248]":["dividing_bits"],"[u8; 80]":["dividing_bits"],"[u8; _]":["define_iv","shift_and_truncate"],"core::result::Result":["fmt","write_alg_name"]},"struct_to_trait":{"Fsb160Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Fsb224Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Fsb256Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Fsb384Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"Fsb512Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"]},"targets":{"<Fsb160Core as core::default::Default>::default":["default","Real(LocalPath(\"fsb/src/macros.rs\"))","core::default::Default"],"<Fsb160Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"fsb/src/macros.rs\"))","core::fmt::Debug"],"<Fsb160Core as digest::Reset>::reset":["reset","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::Reset"],"<Fsb160Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Fsb160Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Fsb160Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Fsb224Core as core::default::Default>::default":["default","Real(LocalPath(\"fsb/src/macros.rs\"))","core::default::Default"],"<Fsb224Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"fsb/src/macros.rs\"))","core::fmt::Debug"],"<Fsb224Core as digest::Reset>::reset":["reset","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::Reset"],"<Fsb224Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Fsb224Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Fsb224Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Fsb256Core as core::default::Default>::default":["default","Real(LocalPath(\"fsb/src/macros.rs\"))","core::default::Default"],"<Fsb256Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"fsb/src/macros.rs\"))","core::fmt::Debug"],"<Fsb256Core as digest::Reset>::reset":["reset","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::Reset"],"<Fsb256Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Fsb256Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Fsb256Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Fsb384Core as core::default::Default>::default":["default","Real(LocalPath(\"fsb/src/macros.rs\"))","core::default::Default"],"<Fsb384Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"fsb/src/macros.rs\"))","core::fmt::Debug"],"<Fsb384Core as digest::Reset>::reset":["reset","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::Reset"],"<Fsb384Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Fsb384Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Fsb384Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::UpdateCore"],"<Fsb512Core as core::default::Default>::default":["default","Real(LocalPath(\"fsb/src/macros.rs\"))","core::default::Default"],"<Fsb512Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"fsb/src/macros.rs\"))","core::fmt::Debug"],"<Fsb512Core as digest::Reset>::reset":["reset","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::Reset"],"<Fsb512Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::AlgorithmName"],"<Fsb512Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::FixedOutputCore"],"<Fsb512Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"fsb/src/macros.rs\"))","digest::core_api::UpdateCore"],"Fsb160Core::compress":["compress","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb160Core::computing_w_indices":["computing_w_indices","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb160Core::define_iv":["define_iv","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb160Core::dividing_bits":["dividing_bits","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb160Core::shift_and_truncate":["shift_and_truncate","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb224Core::compress":["compress","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb224Core::computing_w_indices":["computing_w_indices","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb224Core::define_iv":["define_iv","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb224Core::dividing_bits":["dividing_bits","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb224Core::shift_and_truncate":["shift_and_truncate","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb256Core::compress":["compress","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb256Core::computing_w_indices":["computing_w_indices","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb256Core::define_iv":["define_iv","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb256Core::dividing_bits":["dividing_bits","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb256Core::shift_and_truncate":["shift_and_truncate","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb384Core::compress":["compress","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb384Core::computing_w_indices":["computing_w_indices","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb384Core::define_iv":["define_iv","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb384Core::dividing_bits":["dividing_bits","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb384Core::shift_and_truncate":["shift_and_truncate","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb512Core::compress":["compress","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb512Core::computing_w_indices":["computing_w_indices","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb512Core::define_iv":["define_iv","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb512Core::dividing_bits":["dividing_bits","Real(LocalPath(\"fsb/src/macros.rs\"))",""],"Fsb512Core::shift_and_truncate":["shift_and_truncate","Real(LocalPath(\"fsb/src/macros.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["Fsb160Core","Fsb224Core","Fsb256Core","Fsb384Core","Fsb512Core"],"core::default::Default":["Fsb160Core","Fsb224Core","Fsb256Core","Fsb384Core","Fsb512Core"],"core::fmt::Debug":["Fsb160Core","Fsb224Core","Fsb256Core","Fsb384Core","Fsb512Core"],"digest::HashMarker":["Fsb160Core","Fsb224Core","Fsb256Core","Fsb384Core","Fsb512Core"],"digest::OutputSizeUser":["Fsb160Core","Fsb224Core","Fsb256Core","Fsb384Core","Fsb512Core"],"digest::Reset":["Fsb160Core","Fsb224Core","Fsb256Core","Fsb384Core","Fsb512Core"],"digest::core_api::AlgorithmName":["Fsb160Core","Fsb224Core","Fsb256Core","Fsb384Core","Fsb512Core"],"digest::core_api::BlockSizeUser":["Fsb160Core","Fsb224Core","Fsb256Core","Fsb384Core","Fsb512Core"],"digest::core_api::BufferKindUser":["Fsb160Core","Fsb224Core","Fsb256Core","Fsb384Core","Fsb512Core"],"digest::core_api::FixedOutputCore":["Fsb160Core","Fsb224Core","Fsb256Core","Fsb384Core","Fsb512Core"],"digest::core_api::UpdateCore":["Fsb160Core","Fsb224Core","Fsb256Core","Fsb384Core","Fsb512Core"]},"type_to_def_path":{"Fsb160Core":"Fsb160Core","Fsb224Core":"Fsb224Core","Fsb256Core":"Fsb256Core","Fsb384Core":"Fsb384Core","Fsb512Core":"Fsb512Core"}}