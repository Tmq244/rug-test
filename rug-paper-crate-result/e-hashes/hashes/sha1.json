{"dependencies":{"<Sha1Core as core::clone::Clone>::clone":["Sha1Core"],"<Sha1Core as core::default::Default>::default":["Sha1Core"],"<Sha1Core as core::fmt::Debug>::fmt":["Sha1Core","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Sha1Core as digest::Reset>::reset":["Sha1Core"],"<Sha1Core as digest::core_api::AlgorithmName>::write_alg_name":["core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<Sha1Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["Sha1Core","core::marker::Sized","digest::block_buffer::BlockBuffer","digest::block_buffer::BufferKind","digest::generic_array::ArrayLength","digest::generic_array::GenericArray","digest::typenum::IsLess","digest::typenum::NonZero"],"<Sha1Core as digest::core_api::UpdateCore>::update_blocks":["Sha1Core","core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"<compress::x86::shani_cpuid::InitToken as core::clone::Clone>::clone":["compress::x86::shani_cpuid::InitToken"],"<compress::x86::shani_cpuid::InitToken as core::fmt::Debug>::fmt":["compress::x86::shani_cpuid::InitToken","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"Sha1Core":["Sha1Core"],"compress::compress":["core::marker::Sized","digest::generic_array::ArrayLength","digest::generic_array::GenericArray"],"compress::soft::add":[],"compress::soft::compress":[],"compress::soft::sha1_digest_block_u32":[],"compress::soft::sha1_digest_round_x4":[],"compress::soft::sha1_first_add":[],"compress::soft::sha1_first_half":[],"compress::soft::sha1msg1":[],"compress::soft::sha1msg2":[],"compress::soft::sha1rnds4c":[],"compress::soft::sha1rnds4m":[],"compress::soft::sha1rnds4p":[],"compress::soft::xor":[],"compress::x86::compress":[],"compress::x86::digest_blocks":[],"compress::x86::shani_cpuid::InitToken":["compress::x86::shani_cpuid::InitToken"],"compress::x86::shani_cpuid::InitToken::get":["compress::x86::shani_cpuid::InitToken"],"compress::x86::shani_cpuid::get":[],"compress::x86::shani_cpuid::init":["compress::x86::shani_cpuid::InitToken"],"compress::x86::shani_cpuid::init_get":["compress::x86::shani_cpuid::InitToken"],"compress::x86::shani_cpuid::init_get::cpuid":["core::arch::x86_64::CpuidResult"],"compress::x86::shani_cpuid::init_get::cpuid_count":["core::arch::x86_64::CpuidResult"]},"glob_path_import":{},"self_to_fn":{"Sha1Core":["Clone","impl AlgorithmName for Sha1Core {\n    fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"Sha1\")\n    }\n}","impl BlockSizeUser for Sha1Core {\n    type BlockSize = U64;\n}","impl BufferKindUser for Sha1Core {\n    type BufferKind = Eager;\n}","impl Default for Sha1Core {\n    #[inline]\n    fn default() -> Self {\n        Self {\n            h: [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],\n            block_len: 0,\n        }\n    }\n}","impl FixedOutputCore for Sha1Core {\n    #[inline]\n    fn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {\n        let bs = Self::BlockSize::U64;\n        let bit_len = 8 * (buffer.get_pos() as u64 + bs * self.block_len);\n\n        let mut h = self.h;\n        buffer.len64_padding_be(bit_len, |b| compress(&mut h, from_ref(b)));\n        for (chunk, v) in out.chunks_exact_mut(4).zip(h.iter()) {\n            chunk.copy_from_slice(&v.to_be_bytes());\n        }\n    }\n}","impl HashMarker for Sha1Core {}","impl OutputSizeUser for Sha1Core {\n    type OutputSize = U20;\n}","impl Reset for Sha1Core {\n    #[inline]\n    fn reset(&mut self) {\n        *self = Default::default();\n    }\n}","impl UpdateCore for Sha1Core {\n    #[inline]\n    fn update_blocks(&mut self, blocks: &[Block<Self>]) {\n        self.block_len += blocks.len() as u64;\n        compress(&mut self.h, blocks);\n    }\n}","impl fmt::Debug for Sha1Core {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"Sha1Core { ... }\")\n    }\n}"],"compress::x86::shani_cpuid::InitToken":["Clone","Copy","Debug","impl InitToken {\n                /// Get initialized value\n                #[inline(always)]\n                pub fn get(&self) -> bool {\n                    $crate::__unless_target_features! {\n                        $($tf),+ => {\n                            STORAGE.load(Relaxed) == 1\n                        }\n                    }\n                }\n            }"]},"single_path_import":{"digest":"digest","digest::Digest":"Digest"},"srcs":{"<Sha1Core as core::default::Default>::default":["#[inline]\nfn default() -> Self{\n        Self {\n            h: [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],\n            block_len: 0,\n        }\n    }","Real(LocalPath(\"sha1/src/lib.rs\"))"],"<Sha1Core as core::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"Sha1Core { ... }\")\n    }","Real(LocalPath(\"sha1/src/lib.rs\"))"],"<Sha1Core as digest::Reset>::reset":["#[inline]\nfn reset(&mut self){\n        *self = Default::default();\n    }","Real(LocalPath(\"sha1/src/lib.rs\"))"],"<Sha1Core as digest::core_api::AlgorithmName>::write_alg_name":["fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"Sha1\")\n    }","Real(LocalPath(\"sha1/src/lib.rs\"))"],"<Sha1Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["#[inline]\nfn finalize_fixed_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>){\n        let bs = Self::BlockSize::U64;\n        let bit_len = 8 * (buffer.get_pos() as u64 + bs * self.block_len);\n\n        let mut h = self.h;\n        buffer.len64_padding_be(bit_len, |b| compress(&mut h, from_ref(b)));\n        for (chunk, v) in out.chunks_exact_mut(4).zip(h.iter()) {\n            chunk.copy_from_slice(&v.to_be_bytes());\n        }\n    }","Real(LocalPath(\"sha1/src/lib.rs\"))"],"<Sha1Core as digest::core_api::UpdateCore>::update_blocks":["#[inline]\nfn update_blocks(&mut self, blocks: &[Block<Self>]){\n        self.block_len += blocks.len() as u64;\n        compress(&mut self.h, blocks);\n    }","Real(LocalPath(\"sha1/src/lib.rs\"))"],"Sha1Core":["/// Core SHA-1 hasher state.\npub struct Sha1Core {\n    h: [u32; STATE_LEN],\n    block_len: u64,\n}","Real(LocalPath(\"sha1/src/lib.rs\"))"],"compress::compress":["/// SHA-1 compression function\npub fn compress(state: &mut [u32; 5], blocks: &[Block<Sha1Core>]){\n    // SAFETY: GenericArray<u8, U64> and [u8; 64] have\n    // exactly the same memory layout\n    let blocks: &[[u8; BLOCK_SIZE]] =\n        unsafe { &*(blocks as *const _ as *const [[u8; BLOCK_SIZE]]) };\n    compress_inner(state, blocks);\n}","Real(LocalPath(\"sha1/src/compress.rs\"))"],"compress::soft::add":["#[inline(always)]\nfn add(a: [u32; 4], b: [u32; 4]) -> [u32; 4]{\n    [\n        a[0].wrapping_add(b[0]),\n        a[1].wrapping_add(b[1]),\n        a[2].wrapping_add(b[2]),\n        a[3].wrapping_add(b[3]),\n    ]\n}","Real(LocalPath(\"sha1/src/compress/soft.rs\"))"],"compress::soft::compress":["pub fn compress(state: &mut [u32; 5], blocks: &[[u8; BLOCK_SIZE]]){\n    let mut block_u32 = [0u32; BLOCK_SIZE / 4];\n    // since LLVM can't properly use aliasing yet it will make\n    // unnecessary state stores without this copy\n    let mut state_cpy = *state;\n    for block in blocks.iter() {\n        for (o, chunk) in block_u32.iter_mut().zip(block.chunks_exact(4)) {\n            *o = u32::from_be_bytes(chunk.try_into().unwrap());\n        }\n        sha1_digest_block_u32(&mut state_cpy, &block_u32);\n    }\n    *state = state_cpy;\n}","Real(LocalPath(\"sha1/src/compress/soft.rs\"))"],"compress::soft::sha1_digest_block_u32":["#[inline(always)]\nfn sha1_digest_block_u32(state: &mut [u32; 5], block: &[u32; 16]){\n    let mut w0 = [block[0], block[1], block[2], block[3]];\n    let mut w1 = [block[4], block[5], block[6], block[7]];\n    let mut w2 = [block[8], block[9], block[10], block[11]];\n    let mut w3 = [block[12], block[13], block[14], block[15]];\n    #[allow(clippy::needless_late_init)]\n    let mut w4;\n\n    let mut h0 = [state[0], state[1], state[2], state[3]];\n    let mut h1 = sha1_first_add(state[4], w0);\n\n    // Rounds 0..20\n    h1 = sha1_digest_round_x4(h0, h1, 0);\n    h0 = rounds4!(h1, h0, w1, 0);\n    h1 = rounds4!(h0, h1, w2, 0);\n    h0 = rounds4!(h1, h0, w3, 0);\n    schedule_rounds4!(h0, h1, w0, w1, w2, w3, w4, 0);\n\n    // Rounds 20..40\n    schedule_rounds4!(h1, h0, w1, w2, w3, w4, w0, 1);\n    schedule_rounds4!(h0, h1, w2, w3, w4, w0, w1, 1);\n    schedule_rounds4!(h1, h0, w3, w4, w0, w1, w2, 1);\n    schedule_rounds4!(h0, h1, w4, w0, w1, w2, w3, 1);\n    schedule_rounds4!(h1, h0, w0, w1, w2, w3, w4, 1);\n\n    // Rounds 40..60\n    schedule_rounds4!(h0, h1, w1, w2, w3, w4, w0, 2);\n    schedule_rounds4!(h1, h0, w2, w3, w4, w0, w1, 2);\n    schedule_rounds4!(h0, h1, w3, w4, w0, w1, w2, 2);\n    schedule_rounds4!(h1, h0, w4, w0, w1, w2, w3, 2);\n    schedule_rounds4!(h0, h1, w0, w1, w2, w3, w4, 2);\n\n    // Rounds 60..80\n    schedule_rounds4!(h1, h0, w1, w2, w3, w4, w0, 3);\n    schedule_rounds4!(h0, h1, w2, w3, w4, w0, w1, 3);\n    schedule_rounds4!(h1, h0, w3, w4, w0, w1, w2, 3);\n    schedule_rounds4!(h0, h1, w4, w0, w1, w2, w3, 3);\n    schedule_rounds4!(h1, h0, w0, w1, w2, w3, w4, 3);\n\n    let e = h1[0].rotate_left(30);\n    let [a, b, c, d] = h0;\n\n    state[0] = state[0].wrapping_add(a);\n    state[1] = state[1].wrapping_add(b);\n    state[2] = state[2].wrapping_add(c);\n    state[3] = state[3].wrapping_add(d);\n    state[4] = state[4].wrapping_add(e);\n}","Real(LocalPath(\"sha1/src/compress/soft.rs\"))"],"compress::soft::sha1_digest_round_x4":["fn sha1_digest_round_x4(abcd: [u32; 4], work: [u32; 4], i: i8) -> [u32; 4]{\n    match i {\n        0 => sha1rnds4c(abcd, add(work, [K[0]; 4])),\n        1 => sha1rnds4p(abcd, add(work, [K[1]; 4])),\n        2 => sha1rnds4m(abcd, add(work, [K[2]; 4])),\n        3 => sha1rnds4p(abcd, add(work, [K[3]; 4])),\n        _ => unreachable!(\"unknown icosaround index\"),\n    }\n}","Real(LocalPath(\"sha1/src/compress/soft.rs\"))"],"compress::soft::sha1_first_add":["#[inline]\npub fn sha1_first_add(e: u32, w0: [u32; 4]) -> [u32; 4]{\n    let [a, b, c, d] = w0;\n    [e.wrapping_add(a), b, c, d]\n}","Real(LocalPath(\"sha1/src/compress/soft.rs\"))"],"compress::soft::sha1_first_half":["#[inline]\nfn sha1_first_half(abcd: [u32; 4], msg: [u32; 4]) -> [u32; 4]{\n    sha1_first_add(abcd[0].rotate_left(30), msg)\n}","Real(LocalPath(\"sha1/src/compress/soft.rs\"))"],"compress::soft::sha1msg1":["fn sha1msg1(a: [u32; 4], b: [u32; 4]) -> [u32; 4]{\n    let [_, _, w2, w3] = a;\n    let [w4, w5, _, _] = b;\n    [a[0] ^ w2, a[1] ^ w3, a[2] ^ w4, a[3] ^ w5]\n}","Real(LocalPath(\"sha1/src/compress/soft.rs\"))"],"compress::soft::sha1msg2":["fn sha1msg2(a: [u32; 4], b: [u32; 4]) -> [u32; 4]{\n    let [x0, x1, x2, x3] = a;\n    let [_, w13, w14, w15] = b;\n\n    let w16 = (x0 ^ w13).rotate_left(1);\n    let w17 = (x1 ^ w14).rotate_left(1);\n    let w18 = (x2 ^ w15).rotate_left(1);\n    let w19 = (x3 ^ w16).rotate_left(1);\n\n    [w16, w17, w18, w19]\n}","Real(LocalPath(\"sha1/src/compress/soft.rs\"))"],"compress::soft::sha1rnds4c":["fn sha1rnds4c(abcd: [u32; 4], msg: [u32; 4]) -> [u32; 4]{\n    let [mut a, mut b, mut c, mut d] = abcd;\n    let [t, u, v, w] = msg;\n    let mut e = 0u32;\n\n    macro_rules! bool3ary_202 {\n        ($a:expr, $b:expr, $c:expr) => {\n            $c ^ ($a & ($b ^ $c))\n        };\n    } // Choose, MD5F, SHA1C\n\n    e = e\n        .wrapping_add(a.rotate_left(5))\n        .wrapping_add(bool3ary_202!(b, c, d))\n        .wrapping_add(t);\n    b = b.rotate_left(30);\n\n    d = d\n        .wrapping_add(e.rotate_left(5))\n        .wrapping_add(bool3ary_202!(a, b, c))\n        .wrapping_add(u);\n    a = a.rotate_left(30);\n\n    c = c\n        .wrapping_add(d.rotate_left(5))\n        .wrapping_add(bool3ary_202!(e, a, b))\n        .wrapping_add(v);\n    e = e.rotate_left(30);\n\n    b = b\n        .wrapping_add(c.rotate_left(5))\n        .wrapping_add(bool3ary_202!(d, e, a))\n        .wrapping_add(w);\n    d = d.rotate_left(30);\n\n    [b, c, d, e]\n}","Real(LocalPath(\"sha1/src/compress/soft.rs\"))"],"compress::soft::sha1rnds4m":["fn sha1rnds4m(abcd: [u32; 4], msg: [u32; 4]) -> [u32; 4]{\n    let [mut a, mut b, mut c, mut d] = abcd;\n    let [t, u, v, w] = msg;\n    let mut e = 0u32;\n\n    macro_rules! bool3ary_232 {\n        ($a:expr, $b:expr, $c:expr) => {\n            ($a & $b) ^ ($a & $c) ^ ($b & $c)\n        };\n    } // Majority, SHA1M\n\n    e = e\n        .wrapping_add(a.rotate_left(5))\n        .wrapping_add(bool3ary_232!(b, c, d))\n        .wrapping_add(t);\n    b = b.rotate_left(30);\n\n    d = d\n        .wrapping_add(e.rotate_left(5))\n        .wrapping_add(bool3ary_232!(a, b, c))\n        .wrapping_add(u);\n    a = a.rotate_left(30);\n\n    c = c\n        .wrapping_add(d.rotate_left(5))\n        .wrapping_add(bool3ary_232!(e, a, b))\n        .wrapping_add(v);\n    e = e.rotate_left(30);\n\n    b = b\n        .wrapping_add(c.rotate_left(5))\n        .wrapping_add(bool3ary_232!(d, e, a))\n        .wrapping_add(w);\n    d = d.rotate_left(30);\n\n    [b, c, d, e]\n}","Real(LocalPath(\"sha1/src/compress/soft.rs\"))"],"compress::soft::sha1rnds4p":["fn sha1rnds4p(abcd: [u32; 4], msg: [u32; 4]) -> [u32; 4]{\n    let [mut a, mut b, mut c, mut d] = abcd;\n    let [t, u, v, w] = msg;\n    let mut e = 0u32;\n\n    macro_rules! bool3ary_150 {\n        ($a:expr, $b:expr, $c:expr) => {\n            $a ^ $b ^ $c\n        };\n    } // Parity, XOR, MD5H, SHA1P\n\n    e = e\n        .wrapping_add(a.rotate_left(5))\n        .wrapping_add(bool3ary_150!(b, c, d))\n        .wrapping_add(t);\n    b = b.rotate_left(30);\n\n    d = d\n        .wrapping_add(e.rotate_left(5))\n        .wrapping_add(bool3ary_150!(a, b, c))\n        .wrapping_add(u);\n    a = a.rotate_left(30);\n\n    c = c\n        .wrapping_add(d.rotate_left(5))\n        .wrapping_add(bool3ary_150!(e, a, b))\n        .wrapping_add(v);\n    e = e.rotate_left(30);\n\n    b = b\n        .wrapping_add(c.rotate_left(5))\n        .wrapping_add(bool3ary_150!(d, e, a))\n        .wrapping_add(w);\n    d = d.rotate_left(30);\n\n    [b, c, d, e]\n}","Real(LocalPath(\"sha1/src/compress/soft.rs\"))"],"compress::soft::xor":["#[inline(always)]\nfn xor(a: [u32; 4], b: [u32; 4]) -> [u32; 4]{\n    [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]\n}","Real(LocalPath(\"sha1/src/compress/soft.rs\"))"],"compress::x86::compress":["pub fn compress(state: &mut [u32; 5], blocks: &[[u8; 64]]){\n    // TODO: Replace with https://github.com/rust-lang/rfcs/pull/2725\n    // after stabilization\n    if shani_cpuid::get() {\n        unsafe {\n            digest_blocks(state, blocks);\n        }\n    } else {\n        super::soft::compress(state, blocks);\n    }\n}","Real(LocalPath(\"sha1/src/compress/x86.rs\"))"],"compress::x86::digest_blocks":["#[target_feature(enable = \"sha,sse2,ssse3,sse4.1\")]\nunsafe fn digest_blocks(state: &mut [u32; 5], blocks: &[[u8; 64]]){\n    #[allow(non_snake_case)]\n    let MASK: __m128i = _mm_set_epi64x(0x0001_0203_0405_0607, 0x0809_0A0B_0C0D_0E0F);\n\n    let mut state_abcd = _mm_set_epi32(\n        state[0] as i32,\n        state[1] as i32,\n        state[2] as i32,\n        state[3] as i32,\n    );\n    let mut state_e = _mm_set_epi32(state[4] as i32, 0, 0, 0);\n\n    for block in blocks {\n        // SAFETY: we use only unaligned loads with this pointer\n        #[allow(clippy::cast_ptr_alignment)]\n        let block_ptr = block.as_ptr() as *const __m128i;\n\n        let mut w0 = _mm_shuffle_epi8(_mm_loadu_si128(block_ptr.offset(0)), MASK);\n        let mut w1 = _mm_shuffle_epi8(_mm_loadu_si128(block_ptr.offset(1)), MASK);\n        let mut w2 = _mm_shuffle_epi8(_mm_loadu_si128(block_ptr.offset(2)), MASK);\n        let mut w3 = _mm_shuffle_epi8(_mm_loadu_si128(block_ptr.offset(3)), MASK);\n        #[allow(clippy::needless_late_init)]\n        let mut w4;\n\n        let mut h0 = state_abcd;\n        let mut h1 = _mm_add_epi32(state_e, w0);\n\n        // Rounds 0..20\n        h1 = _mm_sha1rnds4_epu32(h0, h1, 0);\n        h0 = rounds4!(h1, h0, w1, 0);\n        h1 = rounds4!(h0, h1, w2, 0);\n        h0 = rounds4!(h1, h0, w3, 0);\n        schedule_rounds4!(h0, h1, w0, w1, w2, w3, w4, 0);\n\n        // Rounds 20..40\n        schedule_rounds4!(h1, h0, w1, w2, w3, w4, w0, 1);\n        schedule_rounds4!(h0, h1, w2, w3, w4, w0, w1, 1);\n        schedule_rounds4!(h1, h0, w3, w4, w0, w1, w2, 1);\n        schedule_rounds4!(h0, h1, w4, w0, w1, w2, w3, 1);\n        schedule_rounds4!(h1, h0, w0, w1, w2, w3, w4, 1);\n\n        // Rounds 40..60\n        schedule_rounds4!(h0, h1, w1, w2, w3, w4, w0, 2);\n        schedule_rounds4!(h1, h0, w2, w3, w4, w0, w1, 2);\n        schedule_rounds4!(h0, h1, w3, w4, w0, w1, w2, 2);\n        schedule_rounds4!(h1, h0, w4, w0, w1, w2, w3, 2);\n        schedule_rounds4!(h0, h1, w0, w1, w2, w3, w4, 2);\n\n        // Rounds 60..80\n        schedule_rounds4!(h1, h0, w1, w2, w3, w4, w0, 3);\n        schedule_rounds4!(h0, h1, w2, w3, w4, w0, w1, 3);\n        schedule_rounds4!(h1, h0, w3, w4, w0, w1, w2, 3);\n        schedule_rounds4!(h0, h1, w4, w0, w1, w2, w3, 3);\n        schedule_rounds4!(h1, h0, w0, w1, w2, w3, w4, 3);\n\n        state_abcd = _mm_add_epi32(state_abcd, h0);\n        state_e = _mm_sha1nexte_epu32(h1, state_e);\n    }\n\n    state[0] = _mm_extract_epi32(state_abcd, 3) as u32;\n    state[1] = _mm_extract_epi32(state_abcd, 2) as u32;\n    state[2] = _mm_extract_epi32(state_abcd, 1) as u32;\n    state[3] = _mm_extract_epi32(state_abcd, 0) as u32;\n    state[4] = _mm_extract_epi32(state_e, 3) as u32;\n}","Real(LocalPath(\"sha1/src/compress/x86.rs\"))"],"compress::x86::shani_cpuid::InitToken":["/// Initialization token\npub struct InitToken(());","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"compress::x86::shani_cpuid::InitToken::get":["/// Get initialized value\n#[inline(always)]\npub fn get(&self) -> bool{\n                    $crate::__unless_target_features! {\n                        $($tf),+ => {\n                            STORAGE.load(Relaxed) == 1\n                        }\n                    }\n                }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"compress::x86::shani_cpuid::get":["/// Initialize underlying storage if needed and get\n/// stored value.\n#[inline]\npub fn get() -> bool{\n                init_get().1\n            }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"compress::x86::shani_cpuid::init":["/// Initialize underlying storage if needed and get\n/// initialization token.\n#[inline]\npub fn init() -> InitToken{\n                init_get().0\n            }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"compress::x86::shani_cpuid::init_get":["/// Initialize underlying storage if needed and get\n/// stored value and initialization token.\n#[inline]\npub fn init_get() -> (InitToken, bool){\n                let res = $crate::__unless_target_features! {\n                    $($tf),+ => {\n                        // Relaxed ordering is fine, as we only have a single atomic variable.\n                        let val = STORAGE.load(Relaxed);\n\n                        if val == UNINIT {\n                            let res = $crate::__detect_target_features!($($tf),+);\n                            STORAGE.store(res as u8, Relaxed);\n                            res\n                        } else {\n                            val == 1\n                        }\n                    }\n                };\n\n                (InitToken(()), res)\n            }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))"],"compress::x86::shani_cpuid::init_get::cpuid":["#[inline(never)]\nunsafe fn cpuid(leaf: u32) -> CpuidResult{\n            __cpuid(leaf)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/x86.rs\"))"],"compress::x86::shani_cpuid::init_get::cpuid_count":["#[inline(never)]\nunsafe fn cpuid_count(leaf: u32, sub_leaf: u32) -> CpuidResult{\n            __cpuid_count(leaf, sub_leaf)\n        }","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/x86.rs\"))"]},"struct_constructor":{"(compress::x86::shani_cpuid::InitToken, bool)":["init_get"],"Sha1Core":["clone","default"],"bool":["get"],"compress::x86::shani_cpuid::InitToken":["clone","init"],"core::arch::x86_64::CpuidResult":["cpuid","cpuid_count"],"core::result::Result":["fmt","write_alg_name"]},"struct_to_trait":{"Sha1Core":["core::clone::Clone","core::default::Default","core::fmt::Debug","digest::HashMarker","digest::OutputSizeUser","digest::Reset","digest::core_api::AlgorithmName","digest::core_api::BlockSizeUser","digest::core_api::BufferKindUser","digest::core_api::FixedOutputCore","digest::core_api::UpdateCore"],"compress::x86::shani_cpuid::InitToken":["core::clone::Clone","core::fmt::Debug","core::marker::Copy"]},"targets":{"<Sha1Core as core::default::Default>::default":["default","Real(LocalPath(\"sha1/src/lib.rs\"))","core::default::Default"],"<Sha1Core as core::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"sha1/src/lib.rs\"))","core::fmt::Debug"],"<Sha1Core as digest::Reset>::reset":["reset","Real(LocalPath(\"sha1/src/lib.rs\"))","digest::Reset"],"<Sha1Core as digest::core_api::AlgorithmName>::write_alg_name":["write_alg_name","Real(LocalPath(\"sha1/src/lib.rs\"))","digest::core_api::AlgorithmName"],"<Sha1Core as digest::core_api::FixedOutputCore>::finalize_fixed_core":["finalize_fixed_core","Real(LocalPath(\"sha1/src/lib.rs\"))","digest::core_api::FixedOutputCore"],"<Sha1Core as digest::core_api::UpdateCore>::update_blocks":["update_blocks","Real(LocalPath(\"sha1/src/lib.rs\"))","digest::core_api::UpdateCore"],"compress::compress":["compress","Real(LocalPath(\"sha1/src/compress.rs\"))",""],"compress::soft::add":["add","Real(LocalPath(\"sha1/src/compress/soft.rs\"))",""],"compress::soft::compress":["compress","Real(LocalPath(\"sha1/src/compress/soft.rs\"))",""],"compress::soft::sha1_digest_block_u32":["sha1_digest_block_u32","Real(LocalPath(\"sha1/src/compress/soft.rs\"))",""],"compress::soft::sha1_digest_round_x4":["sha1_digest_round_x4","Real(LocalPath(\"sha1/src/compress/soft.rs\"))",""],"compress::soft::sha1_first_add":["sha1_first_add","Real(LocalPath(\"sha1/src/compress/soft.rs\"))",""],"compress::soft::sha1_first_half":["sha1_first_half","Real(LocalPath(\"sha1/src/compress/soft.rs\"))",""],"compress::soft::sha1msg1":["sha1msg1","Real(LocalPath(\"sha1/src/compress/soft.rs\"))",""],"compress::soft::sha1msg2":["sha1msg2","Real(LocalPath(\"sha1/src/compress/soft.rs\"))",""],"compress::soft::sha1rnds4c":["sha1rnds4c","Real(LocalPath(\"sha1/src/compress/soft.rs\"))",""],"compress::soft::sha1rnds4m":["sha1rnds4m","Real(LocalPath(\"sha1/src/compress/soft.rs\"))",""],"compress::soft::sha1rnds4p":["sha1rnds4p","Real(LocalPath(\"sha1/src/compress/soft.rs\"))",""],"compress::soft::xor":["xor","Real(LocalPath(\"sha1/src/compress/soft.rs\"))",""],"compress::x86::compress":["compress","Real(LocalPath(\"sha1/src/compress/x86.rs\"))",""],"compress::x86::digest_blocks":["digest_blocks","Real(LocalPath(\"sha1/src/compress/x86.rs\"))",""],"compress::x86::shani_cpuid::InitToken::get":["get","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))",""],"compress::x86::shani_cpuid::get":["get","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))",""],"compress::x86::shani_cpuid::init":["init","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))",""],"compress::x86::shani_cpuid::init_get":["init_get","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/lib.rs\"))",""],"compress::x86::shani_cpuid::init_get::cpuid":["cpuid","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/x86.rs\"))",""],"compress::x86::shani_cpuid::init_get::cpuid_count":["cpuid_count","Real(LocalPath(\"/home/tmq244/.cargo/registry/src/github.com-1ecc6299db9ec823/cpufeatures-0.2.7/src/x86.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["Sha1Core","compress::x86::shani_cpuid::InitToken"],"core::default::Default":["Sha1Core"],"core::fmt::Debug":["Sha1Core","compress::x86::shani_cpuid::InitToken"],"core::marker::Copy":["compress::x86::shani_cpuid::InitToken"],"digest::HashMarker":["Sha1Core"],"digest::OutputSizeUser":["Sha1Core"],"digest::Reset":["Sha1Core"],"digest::core_api::AlgorithmName":["Sha1Core"],"digest::core_api::BlockSizeUser":["Sha1Core"],"digest::core_api::BufferKindUser":["Sha1Core"],"digest::core_api::FixedOutputCore":["Sha1Core"],"digest::core_api::UpdateCore":["Sha1Core"]},"type_to_def_path":{"Sha1Core":"Sha1Core","compress::x86::shani_cpuid::InitToken":"compress::x86::shani_cpuid::InitToken"}}