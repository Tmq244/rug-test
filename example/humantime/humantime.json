{"dependencies":{"<date::Error as std::clone::Clone>::clone":["date::Error"],"<date::Error as std::cmp::PartialEq>::eq":["date::Error"],"<date::Error as std::fmt::Debug>::fmt":["date::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<date::Error as std::fmt::Display>::fmt":["date::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<date::Precision as std::clone::Clone>::clone":["date::Precision"],"<date::Precision as std::cmp::Eq>::assert_receiver_is_total_eq":["date::Precision"],"<date::Precision as std::cmp::PartialEq>::eq":["date::Precision"],"<date::Precision as std::fmt::Debug>::fmt":["date::Precision","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<date::Rfc3339Timestamp as std::clone::Clone>::clone":["date::Precision","date::Rfc3339Timestamp","std::time::SystemTime"],"<date::Rfc3339Timestamp as std::fmt::Debug>::fmt":["date::Precision","date::Rfc3339Timestamp","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::time::SystemTime"],"<date::Rfc3339Timestamp as std::fmt::Display>::fmt":["date::Precision","date::Rfc3339Timestamp","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::time::SystemTime"],"<duration::Error as std::clone::Clone>::clone":["duration::Error","std::string::String"],"<duration::Error as std::cmp::PartialEq>::eq":["duration::Error","std::string::String"],"<duration::Error as std::fmt::Debug>::fmt":["duration::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<duration::Error as std::fmt::Display>::fmt":["duration::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<duration::FormattedDuration as std::clone::Clone>::clone":["duration::FormattedDuration","std::time::Duration"],"<duration::FormattedDuration as std::fmt::Debug>::fmt":["duration::FormattedDuration","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::time::Duration"],"<duration::FormattedDuration as std::fmt::Display>::fmt":["duration::FormattedDuration","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::time::Duration"],"<duration::Fraction as std::clone::Clone>::clone":["duration::Fraction"],"<duration::Fraction as std::fmt::Debug>::fmt":["duration::Fraction","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<duration::Unit as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<u64 as duration::OverflowOp>::add":["std::marker::Sized","std::result::Result"],"<u64 as duration::OverflowOp>::div":["std::marker::Sized","std::result::Result"],"<u64 as duration::OverflowOp>::mul":["std::marker::Sized","std::result::Result"],"<wrapper::Duration as std::clone::Clone>::clone":["std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::cmp::Eq>::assert_receiver_is_total_eq":["std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::cmp::Ord>::cmp":["std::cmp::Ordering","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::cmp::PartialEq>::eq":["std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::convert::AsRef<std::time::Duration>>::as_ref":["std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::convert::From<std::time::Duration>>::from":["std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::default::Default>::default":["std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::ops::Deref>::deref":["std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<wrapper::Timestamp as std::clone::Clone>::clone":["std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::cmp::Eq>::assert_receiver_is_total_eq":["std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::cmp::Ord>::cmp":["std::cmp::Ordering","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::cmp::PartialEq>::eq":["std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::convert::AsRef<std::time::SystemTime>>::as_ref":["std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::convert::From<std::time::SystemTime>>::from":["std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::ops::Deref>::deref":["std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"date::Error":["date::Error"],"date::Precision":["date::Precision"],"date::Rfc3339Timestamp":["date::Precision","date::Rfc3339Timestamp","std::time::SystemTime"],"date::Rfc3339Timestamp::get_ref":["date::Precision","date::Rfc3339Timestamp","std::time::SystemTime"],"date::format_rfc3339":["date::Precision","date::Rfc3339Timestamp","std::time::SystemTime"],"date::format_rfc3339_micros":["date::Precision","date::Rfc3339Timestamp","std::time::SystemTime"],"date::format_rfc3339_millis":["date::Precision","date::Rfc3339Timestamp","std::time::SystemTime"],"date::format_rfc3339_nanos":["date::Precision","date::Rfc3339Timestamp","std::time::SystemTime"],"date::format_rfc3339_seconds":["date::Precision","date::Rfc3339Timestamp","std::time::SystemTime"],"date::is_leap_year":[],"date::parse_rfc3339":["std::marker::Sized","std::result::Result"],"date::parse_rfc3339_weak":["std::marker::Sized","std::result::Result"],"date::two_digits":["std::marker::Sized","std::result::Result"],"date::two_digits::two_digits_inner":["std::marker::Sized","std::option::Option"],"duration::Error":["duration::Error","std::string::String"],"duration::FormattedDuration":["duration::FormattedDuration","std::time::Duration"],"duration::FormattedDuration::get_ref":["duration::FormattedDuration","std::time::Duration"],"duration::Fraction":["duration::Fraction"],"duration::OverflowOp::add":["std::marker::Sized","std::result::Result"],"duration::OverflowOp::div":["std::marker::Sized","std::result::Result"],"duration::OverflowOp::mul":["std::marker::Sized","std::result::Result"],"duration::Parser":["duration::Parser","std::str::Chars"],"duration::Parser::<'_>::off":["duration::Parser","std::str::Chars"],"duration::Parser::<'_>::parse":["duration::Parser","std::marker::Sized","std::result::Result","std::str::Chars"],"duration::Parser::<'_>::parse_first_char":["duration::Parser","std::marker::Sized","std::result::Result","std::str::Chars"],"duration::Parser::<'_>::parse_fractional_part":["duration::Parser","std::marker::Sized","std::result::Result","std::str::Chars"],"duration::Parser::<'_>::parse_unit":["duration::Parser","std::marker::Sized","std::option::Option","std::result::Result","std::str::Chars","std::time::Duration"],"duration::Unit":["duration::Unit"],"duration::add_current":["std::marker::Sized","std::result::Result","std::time::Duration"],"duration::format_duration":["duration::FormattedDuration","std::time::Duration"],"duration::item":["std::fmt::Formatter","std::marker::Sized","std::result::Result"],"duration::item_plural":["std::fmt::Formatter","std::marker::Sized","std::result::Result"],"duration::parse_duration":["std::marker::Sized","std::result::Result"],"wrapper::<impl std::convert::From<wrapper::Duration> for std::time::Duration>::from":["std::time::Duration","wrapper::Duration"],"wrapper::<impl std::convert::From<wrapper::Timestamp> for std::time::SystemTime>::from":["std::time::SystemTime","wrapper::Timestamp"],"wrapper::Duration":["std::time::Duration","wrapper::Duration"],"wrapper::Timestamp":["std::time::SystemTime","wrapper::Timestamp"]},"glob_path_import":{},"self_to_fn":{"date::Error":["Clone","Copy","Debug","PartialEq","impl StdError for Error {}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Error::OutOfRange => write!(f, \"numeric component is out of range\"),\n            Error::InvalidDigit => write!(f, \"bad character where digit is expected\"),\n            Error::InvalidFormat => write!(f, \"timestamp format is invalid\"),\n        }\n    }\n}"],"date::Precision":["Clone","Debug","Eq","PartialEq"],"date::Rfc3339Timestamp":["Clone","Debug","impl Rfc3339Timestamp {\n    /// Returns a reference to the [`SystemTime`][] that is being formatted.\n    pub fn get_ref(&self) -> &SystemTime {\n        &self.0\n    }\n}","impl fmt::Display for Rfc3339Timestamp {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::Precision::*;\n\n        let dur = self\n            .0\n            .duration_since(UNIX_EPOCH)\n            .expect(\"all times should be after the epoch\");\n        let secs_since_epoch = dur.as_secs();\n        let nanos = dur.subsec_nanos();\n\n        if secs_since_epoch >= 253_402_300_800 {\n            // year 9999\n            return Err(fmt::Error);\n        }\n\n        /* 2000-03-01 (mod 400 year, immediately after feb29 */\n        const LEAPOCH: i64 = 11017;\n        const DAYS_PER_400Y: i64 = 365 * 400 + 97;\n        const DAYS_PER_100Y: i64 = 365 * 100 + 24;\n        const DAYS_PER_4Y: i64 = 365 * 4 + 1;\n\n        let days = (secs_since_epoch / 86400) as i64 - LEAPOCH;\n        let secs_of_day = secs_since_epoch % 86400;\n\n        let mut qc_cycles = days / DAYS_PER_400Y;\n        let mut remdays = days % DAYS_PER_400Y;\n\n        if remdays < 0 {\n            remdays += DAYS_PER_400Y;\n            qc_cycles -= 1;\n        }\n\n        let mut c_cycles = remdays / DAYS_PER_100Y;\n        if c_cycles == 4 {\n            c_cycles -= 1;\n        }\n        remdays -= c_cycles * DAYS_PER_100Y;\n\n        let mut q_cycles = remdays / DAYS_PER_4Y;\n        if q_cycles == 25 {\n            q_cycles -= 1;\n        }\n        remdays -= q_cycles * DAYS_PER_4Y;\n\n        let mut remyears = remdays / 365;\n        if remyears == 4 {\n            remyears -= 1;\n        }\n        remdays -= remyears * 365;\n\n        let mut year = 2000 + remyears + 4 * q_cycles + 100 * c_cycles + 400 * qc_cycles;\n\n        let months = [31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 29];\n        let mut mon = 0;\n        for mon_len in months.iter() {\n            mon += 1;\n            if remdays < *mon_len {\n                break;\n            }\n            remdays -= *mon_len;\n        }\n        let mday = remdays + 1;\n        let mon = if mon + 2 > 12 {\n            year += 1;\n            mon - 10\n        } else {\n            mon + 2\n        };\n\n        const BUF_INIT: [u8; 30] = *b\"0000-00-00T00:00:00.000000000Z\";\n\n        let mut buf: [u8; 30] = BUF_INIT;\n        buf[0] = b'0' + (year / 1000) as u8;\n        buf[1] = b'0' + (year / 100 % 10) as u8;\n        buf[2] = b'0' + (year / 10 % 10) as u8;\n        buf[3] = b'0' + (year % 10) as u8;\n        buf[5] = b'0' + (mon / 10) as u8;\n        buf[6] = b'0' + (mon % 10) as u8;\n        buf[8] = b'0' + (mday / 10) as u8;\n        buf[9] = b'0' + (mday % 10) as u8;\n        buf[11] = b'0' + (secs_of_day / 3600 / 10) as u8;\n        buf[12] = b'0' + (secs_of_day / 3600 % 10) as u8;\n        buf[14] = b'0' + (secs_of_day / 60 / 10 % 6) as u8;\n        buf[15] = b'0' + (secs_of_day / 60 % 10) as u8;\n        buf[17] = b'0' + (secs_of_day / 10 % 6) as u8;\n        buf[18] = b'0' + (secs_of_day % 10) as u8;\n\n        let offset = if self.1 == Seconds || nanos == 0 && self.1 == Smart {\n            buf[19] = b'Z';\n            19\n        } else if self.1 == Millis {\n            buf[20] = b'0' + (nanos / 100_000_000) as u8;\n            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;\n            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;\n            buf[23] = b'Z';\n            23\n        } else if self.1 == Micros {\n            buf[20] = b'0' + (nanos / 100_000_000) as u8;\n            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;\n            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;\n            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;\n            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;\n            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;\n            buf[26] = b'Z';\n            26\n        } else {\n            buf[20] = b'0' + (nanos / 100_000_000) as u8;\n            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;\n            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;\n            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;\n            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;\n            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;\n            buf[26] = b'0' + (nanos / 100 % 10) as u8;\n            buf[27] = b'0' + (nanos / 10 % 10) as u8;\n            buf[28] = b'0' + (nanos % 10) as u8;\n            // 29th is 'Z'\n            29\n        };\n\n        // we know our chars are all ascii\n        f.write_str(str::from_utf8(&buf[..=offset]).expect(\"Conversion to utf8 failed\"))\n    }\n}"],"duration::Error":["Clone","Debug","PartialEq","impl StdError for Error {}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Error::InvalidCharacter(offset) => write!(f, \"invalid character at {}\", offset),\n            Error::NumberExpected(offset) => write!(f, \"expected number at {}\", offset),\n            Error::UnknownUnit { unit, value, .. } if unit.is_empty() => {\n                write!(f, \"time unit needed, for example {0}sec or {0}ms\", value)\n            }\n            Error::UnknownUnit { unit, .. } => {\n                write!(\n                    f,\n                    \"unknown time unit {:?}, \\\n                    supported units: ns, us/µs, ms, sec, min, hours, days, \\\n                    weeks, months, years (and few variations)\",\n                    unit\n                )\n            }\n            Error::NumberOverflow => write!(f, \"number is too large or cannot be represented without a lack of precision (values below 1ns are not supported)\"),\n            Error::Empty => write!(f, \"value was empty\"),\n        }\n    }\n}"],"duration::FormattedDuration":["Clone","Debug","impl FormattedDuration {\n    /// Returns a reference to the [`Duration`][] that is being formatted.\n    pub fn get_ref(&self) -> &Duration {\n        &self.0\n    }\n}","impl fmt::Display for FormattedDuration {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let secs = self.0.as_secs();\n        let nanos = self.0.subsec_nanos();\n\n        if secs == 0 && nanos == 0 {\n            f.write_str(\"0s\")?;\n            return Ok(());\n        }\n\n        let years = secs / 31_557_600; // 365.25d\n        let ydays = secs % 31_557_600;\n        let months = ydays / 2_630_016; // 30.44d\n        let mdays = ydays % 2_630_016;\n        let days = mdays / 86400;\n        let day_secs = mdays % 86400;\n        let hours = day_secs / 3600;\n        let minutes = day_secs % 3600 / 60;\n        let seconds = day_secs % 60;\n\n        let millis = nanos / 1_000_000;\n        let micros = nanos / 1000 % 1000;\n        let nanosec = nanos % 1000;\n\n        let started = &mut false;\n        item_plural(f, started, \"year\", years)?;\n        item_plural(f, started, \"month\", months)?;\n        item_plural(f, started, \"day\", days)?;\n        item(f, started, \"h\", hours as u32)?;\n        item(f, started, \"m\", minutes as u32)?;\n        item(f, started, \"s\", seconds as u32)?;\n        item(f, started, \"ms\", millis)?;\n        #[cfg(feature = \"mu\")]\n        item(f, started, \"µs\", micros)?;\n        #[cfg(not(feature = \"mu\"))]\n        item(f, started, \"us\", micros)?;\n        item(f, started, \"ns\", nanosec)?;\n        Ok(())\n    }\n}"],"duration::Fraction":["Clone","Copy","Debug"],"duration::Parser":["impl Parser<'_> {\n    fn parse(mut self) -> Result<Duration, Error> {\n        let mut n = self.parse_first_char()?.ok_or(Error::Empty)?; // integer part\n        let mut out = Duration::ZERO;\n        'outer: loop {\n            let mut frac = None; // fractional part\n            let mut off = self.off();\n            while let Some(c) = self.iter.next() {\n                match c {\n                    '0'..='9' => {\n                        n = n\n                            .checked_mul(10)\n                            .and_then(|x| x.checked_add(c as u64 - '0' as u64))\n                            .ok_or(Error::NumberOverflow)?;\n                    }\n                    c if c.is_whitespace() => {}\n                    'a'..='z' | 'A'..='Z' | 'µ' => {\n                        break;\n                    }\n                    '.' => {\n                        // decimal separator, the fractional part begins now\n                        frac = Some(self.parse_fractional_part(&mut off)?);\n                        break;\n                    }\n                    _ => {\n                        return Err(Error::InvalidCharacter(off));\n                    }\n                }\n                off = self.off();\n            }\n            let start = off;\n            let mut off = self.off();\n            while let Some(c) = self.iter.next() {\n                match c {\n                    '0'..='9' => {\n                        self.parse_unit(n, frac, start, off, &mut out)?;\n                        n = c as u64 - '0' as u64;\n                        continue 'outer;\n                    }\n                    c if c.is_whitespace() => break,\n                    'a'..='z' | 'A'..='Z' | 'µ' => {}\n                    _ => {\n                        return Err(Error::InvalidCharacter(off));\n                    }\n                }\n                off = self.off();\n            }\n\n            self.parse_unit(n, frac, start, off, &mut out)?;\n            n = match self.parse_first_char()? {\n                Some(n) => n,\n                None => return Ok(out),\n            };\n        }\n    }\n\n    fn parse_first_char(&mut self) -> Result<Option<u64>, Error> {\n        let off = self.off();\n        for c in self.iter.by_ref() {\n            match c {\n                '0'..='9' => {\n                    return Ok(Some(c as u64 - '0' as u64));\n                }\n                c if c.is_whitespace() => continue,\n                _ => {\n                    return Err(Error::NumberExpected(off));\n                }\n            }\n        }\n        Ok(None)\n    }\n\n    fn parse_fractional_part(&mut self, off: &mut usize) -> Result<Fraction, Error> {\n        let mut numerator = 0u64;\n        let mut denominator = 1u64;\n        let mut zeros = true;\n        while let Some(c) = self.iter.next() {\n            match c {\n                '0' => {\n                    denominator = denominator.checked_mul(10).ok_or(Error::NumberOverflow)?;\n                    if !zeros {\n                        numerator = numerator.checked_mul(10).ok_or(Error::NumberOverflow)?;\n                    }\n                }\n                '1'..='9' => {\n                    zeros = false;\n                    denominator = denominator.checked_mul(10).ok_or(Error::NumberOverflow)?;\n                    numerator = numerator\n                        .checked_mul(10)\n                        .and_then(|x| x.checked_add(c as u64 - '0' as u64))\n                        .ok_or(Error::NumberOverflow)?;\n                }\n                c if c.is_whitespace() => {}\n                'a'..='z' | 'A'..='Z' | 'µ' => {\n                    break;\n                }\n                _ => {\n                    return Err(Error::InvalidCharacter(*off));\n                }\n            };\n            // update the offset used by the parsing loop\n            *off = self.off();\n        }\n        if denominator == 1 {\n            // no digits were given after the separator, e.g. \"1.\"\n            return Err(Error::InvalidCharacter(*off));\n        }\n        Ok(Fraction {\n            numerator,\n            denominator,\n        })\n    }\n\n    fn off(&self) -> usize {\n        self.src.len() - self.iter.as_str().len()\n    }\n\n    fn parse_unit(\n        &mut self,\n        n: u64,\n        frac: Option<Fraction>,\n        start: usize,\n        end: usize,\n        out: &mut Duration,\n    ) -> Result<(), Error> {\n        let unit = match Unit::from_str(&self.src[start..end]) {\n            Ok(u) => u,\n            Err(()) => {\n                return Err(Error::UnknownUnit {\n                    start,\n                    end,\n                    unit: self.src[start..end].to_owned(),\n                    value: n,\n                });\n            }\n        };\n\n        // add the integer part\n        let (sec, nsec) = match unit {\n            Unit::Nanosecond => (0u64, n),\n            Unit::Microsecond => (0u64, n.mul(1000)?),\n            Unit::Millisecond => (0u64, n.mul(1_000_000)?),\n            Unit::Second => (n, 0),\n            Unit::Minute => (n.mul(60)?, 0),\n            Unit::Hour => (n.mul(3600)?, 0),\n            Unit::Day => (n.mul(86400)?, 0),\n            Unit::Week => (n.mul(86400 * 7)?, 0),\n            Unit::Month => (n.mul(2_630_016)?, 0), // 30.44d\n            Unit::Year => (n.mul(31_557_600)?, 0), // 365.25d\n        };\n        add_current(sec, nsec, out)?;\n\n        // add the fractional part\n        if let Some(Fraction {\n            numerator: n,\n            denominator: d,\n        }) = frac\n        {\n            let (sec, nsec) = match unit {\n                Unit::Nanosecond => return Err(Error::NumberOverflow),\n                Unit::Microsecond => (0, n.mul(1000)?.div(d)?),\n                Unit::Millisecond => (0, n.mul(1_000_000)?.div(d)?),\n                Unit::Second => (0, n.mul(1_000_000_000)?.div(d)?),\n                Unit::Minute => (0, n.mul(60_000_000_000)?.div(d)?),\n                Unit::Hour => (n.mul(3600)?.div(d)?, 0),\n                Unit::Day => (n.mul(86400)?.div(d)?, 0),\n                Unit::Week => (n.mul(86400 * 7)?.div(d)?, 0),\n                Unit::Month => (n.mul(2_630_016)?.div(d)?, 0), // 30.44d\n                Unit::Year => (n.mul(31_557_600)?.div(d)?, 0), // 365.25d\n            };\n            add_current(sec, nsec, out)?;\n        }\n\n        Ok(())\n    }\n}"],"duration::Unit":["impl FromStr for Unit {\n    type Err = ();\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"nanos\" | \"nsec\" | \"ns\" => Ok(Self::Nanosecond),\n            \"usec\" | \"us\" | \"µs\" => Ok(Self::Microsecond),\n            \"millis\" | \"msec\" | \"ms\" => Ok(Self::Millisecond),\n            \"seconds\" | \"second\" | \"secs\" | \"sec\" | \"s\" => Ok(Self::Second),\n            \"minutes\" | \"minute\" | \"min\" | \"mins\" | \"m\" => Ok(Self::Minute),\n            \"hours\" | \"hour\" | \"hr\" | \"hrs\" | \"h\" => Ok(Self::Hour),\n            \"days\" | \"day\" | \"d\" => Ok(Self::Day),\n            \"weeks\" | \"week\" | \"wk\" | \"wks\" | \"w\" => Ok(Self::Week),\n            \"months\" | \"month\" | \"M\" => Ok(Self::Month),\n            \"years\" | \"year\" | \"yr\" | \"yrs\" | \"y\" => Ok(Self::Year),\n            _ => Err(()),\n        }\n    }\n}"],"std::time::Duration":["impl From<Duration> for StdDuration {\n    fn from(val: Duration) -> Self {\n        val.0\n    }\n}"],"std::time::SystemTime":["impl From<Timestamp> for SystemTime {\n    fn from(val: Timestamp) -> Self {\n        val.0\n    }\n}"],"wrapper::Duration":["Clone","Copy","Debug","Default","Eq","Hash","Ord","PartialEq","PartialOrd","impl AsRef<StdDuration> for Duration {\n    fn as_ref(&self) -> &StdDuration {\n        &self.0\n    }\n}","impl Deref for Duration {\n    type Target = StdDuration;\n    fn deref(&self) -> &StdDuration {\n        &self.0\n    }\n}","impl From<StdDuration> for Duration {\n    fn from(dur: StdDuration) -> Duration {\n        Duration(dur)\n    }\n}","impl FromStr for Duration {\n    type Err = duration::Error;\n    fn from_str(s: &str) -> Result<Duration, Self::Err> {\n        parse_duration(s).map(Duration)\n    }\n}","impl fmt::Display for Duration {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        format_duration(self.0).fmt(f)\n    }\n}"],"wrapper::Timestamp":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl AsRef<SystemTime> for Timestamp {\n    fn as_ref(&self) -> &SystemTime {\n        &self.0\n    }\n}","impl Deref for Timestamp {\n    type Target = SystemTime;\n    fn deref(&self) -> &SystemTime {\n        &self.0\n    }\n}","impl From<SystemTime> for Timestamp {\n    fn from(dur: SystemTime) -> Timestamp {\n        Timestamp(dur)\n    }\n}","impl FromStr for Timestamp {\n    type Err = date::Error;\n    fn from_str(s: &str) -> Result<Timestamp, Self::Err> {\n        parse_rfc3339_weak(s).map(Timestamp)\n    }\n}","impl fmt::Display for Timestamp {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        format_rfc3339(self.0).fmt(f)\n    }\n}"]},"single_path_import":{"date::Error":"Error","date::Rfc3339Timestamp":"Rfc3339Timestamp","date::format_rfc3339":"format_rfc3339","date::format_rfc3339_micros":"format_rfc3339_micros","date::format_rfc3339_millis":"format_rfc3339_millis","date::format_rfc3339_nanos":"format_rfc3339_nanos","date::format_rfc3339_seconds":"format_rfc3339_seconds","date::parse_rfc3339":"parse_rfc3339","date::parse_rfc3339_weak":"parse_rfc3339_weak","duration::Error":"Error","duration::FormattedDuration":"FormattedDuration","duration::format_duration":"format_duration","duration::parse_duration":"parse_duration","wrapper::Duration":"Duration","wrapper::Timestamp":"Timestamp"},"srcs":{"<date::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match self {\n            Error::OutOfRange => write!(f, \"numeric component is out of range\"),\n            Error::InvalidDigit => write!(f, \"bad character where digit is expected\"),\n            Error::InvalidFormat => write!(f, \"timestamp format is invalid\"),\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Rfc3339Timestamp as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use self::Precision::*;\n\n        let dur = self\n            .0\n            .duration_since(UNIX_EPOCH)\n            .expect(\"all times should be after the epoch\");\n        let secs_since_epoch = dur.as_secs();\n        let nanos = dur.subsec_nanos();\n\n        if secs_since_epoch >= 253_402_300_800 {\n            // year 9999\n            return Err(fmt::Error);\n        }\n\n        /* 2000-03-01 (mod 400 year, immediately after feb29 */\n        const LEAPOCH: i64 = 11017;\n        const DAYS_PER_400Y: i64 = 365 * 400 + 97;\n        const DAYS_PER_100Y: i64 = 365 * 100 + 24;\n        const DAYS_PER_4Y: i64 = 365 * 4 + 1;\n\n        let days = (secs_since_epoch / 86400) as i64 - LEAPOCH;\n        let secs_of_day = secs_since_epoch % 86400;\n\n        let mut qc_cycles = days / DAYS_PER_400Y;\n        let mut remdays = days % DAYS_PER_400Y;\n\n        if remdays < 0 {\n            remdays += DAYS_PER_400Y;\n            qc_cycles -= 1;\n        }\n\n        let mut c_cycles = remdays / DAYS_PER_100Y;\n        if c_cycles == 4 {\n            c_cycles -= 1;\n        }\n        remdays -= c_cycles * DAYS_PER_100Y;\n\n        let mut q_cycles = remdays / DAYS_PER_4Y;\n        if q_cycles == 25 {\n            q_cycles -= 1;\n        }\n        remdays -= q_cycles * DAYS_PER_4Y;\n\n        let mut remyears = remdays / 365;\n        if remyears == 4 {\n            remyears -= 1;\n        }\n        remdays -= remyears * 365;\n\n        let mut year = 2000 + remyears + 4 * q_cycles + 100 * c_cycles + 400 * qc_cycles;\n\n        let months = [31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 29];\n        let mut mon = 0;\n        for mon_len in months.iter() {\n            mon += 1;\n            if remdays < *mon_len {\n                break;\n            }\n            remdays -= *mon_len;\n        }\n        let mday = remdays + 1;\n        let mon = if mon + 2 > 12 {\n            year += 1;\n            mon - 10\n        } else {\n            mon + 2\n        };\n\n        const BUF_INIT: [u8; 30] = *b\"0000-00-00T00:00:00.000000000Z\";\n\n        let mut buf: [u8; 30] = BUF_INIT;\n        buf[0] = b'0' + (year / 1000) as u8;\n        buf[1] = b'0' + (year / 100 % 10) as u8;\n        buf[2] = b'0' + (year / 10 % 10) as u8;\n        buf[3] = b'0' + (year % 10) as u8;\n        buf[5] = b'0' + (mon / 10) as u8;\n        buf[6] = b'0' + (mon % 10) as u8;\n        buf[8] = b'0' + (mday / 10) as u8;\n        buf[9] = b'0' + (mday % 10) as u8;\n        buf[11] = b'0' + (secs_of_day / 3600 / 10) as u8;\n        buf[12] = b'0' + (secs_of_day / 3600 % 10) as u8;\n        buf[14] = b'0' + (secs_of_day / 60 / 10 % 6) as u8;\n        buf[15] = b'0' + (secs_of_day / 60 % 10) as u8;\n        buf[17] = b'0' + (secs_of_day / 10 % 6) as u8;\n        buf[18] = b'0' + (secs_of_day % 10) as u8;\n\n        let offset = if self.1 == Seconds || nanos == 0 && self.1 == Smart {\n            buf[19] = b'Z';\n            19\n        } else if self.1 == Millis {\n            buf[20] = b'0' + (nanos / 100_000_000) as u8;\n            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;\n            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;\n            buf[23] = b'Z';\n            23\n        } else if self.1 == Micros {\n            buf[20] = b'0' + (nanos / 100_000_000) as u8;\n            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;\n            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;\n            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;\n            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;\n            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;\n            buf[26] = b'Z';\n            26\n        } else {\n            buf[20] = b'0' + (nanos / 100_000_000) as u8;\n            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;\n            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;\n            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;\n            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;\n            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;\n            buf[26] = b'0' + (nanos / 100 % 10) as u8;\n            buf[27] = b'0' + (nanos / 10 % 10) as u8;\n            buf[28] = b'0' + (nanos % 10) as u8;\n            // 29th is 'Z'\n            29\n        };\n\n        // we know our chars are all ascii\n        f.write_str(str::from_utf8(&buf[..=offset]).expect(\"Conversion to utf8 failed\"))\n    }","Real(LocalPath(\"src/date.rs\"))"],"<duration::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match self {\n            Error::InvalidCharacter(offset) => write!(f, \"invalid character at {}\", offset),\n            Error::NumberExpected(offset) => write!(f, \"expected number at {}\", offset),\n            Error::UnknownUnit { unit, value, .. } if unit.is_empty() => {\n                write!(f, \"time unit needed, for example {0}sec or {0}ms\", value)\n            }\n            Error::UnknownUnit { unit, .. } => {\n                write!(\n                    f,\n                    \"unknown time unit {:?}, \\\n                    supported units: ns, us/µs, ms, sec, min, hours, days, \\\n                    weeks, months, years (and few variations)\",\n                    unit\n                )\n            }\n            Error::NumberOverflow => write!(f, \"number is too large or cannot be represented without a lack of precision (values below 1ns are not supported)\"),\n            Error::Empty => write!(f, \"value was empty\"),\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::FormattedDuration as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let secs = self.0.as_secs();\n        let nanos = self.0.subsec_nanos();\n\n        if secs == 0 && nanos == 0 {\n            f.write_str(\"0s\")?;\n            return Ok(());\n        }\n\n        let years = secs / 31_557_600; // 365.25d\n        let ydays = secs % 31_557_600;\n        let months = ydays / 2_630_016; // 30.44d\n        let mdays = ydays % 2_630_016;\n        let days = mdays / 86400;\n        let day_secs = mdays % 86400;\n        let hours = day_secs / 3600;\n        let minutes = day_secs % 3600 / 60;\n        let seconds = day_secs % 60;\n\n        let millis = nanos / 1_000_000;\n        let micros = nanos / 1000 % 1000;\n        let nanosec = nanos % 1000;\n\n        let started = &mut false;\n        item_plural(f, started, \"year\", years)?;\n        item_plural(f, started, \"month\", months)?;\n        item_plural(f, started, \"day\", days)?;\n        item(f, started, \"h\", hours as u32)?;\n        item(f, started, \"m\", minutes as u32)?;\n        item(f, started, \"s\", seconds as u32)?;\n        item(f, started, \"ms\", millis)?;\n        #[cfg(feature = \"mu\")]\n        item(f, started, \"µs\", micros)?;\n        #[cfg(not(feature = \"mu\"))]\n        item(f, started, \"us\", micros)?;\n        item(f, started, \"ns\", nanosec)?;\n        Ok(())\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Unit as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Self, Self::Err>{\n        match s {\n            \"nanos\" | \"nsec\" | \"ns\" => Ok(Self::Nanosecond),\n            \"usec\" | \"us\" | \"µs\" => Ok(Self::Microsecond),\n            \"millis\" | \"msec\" | \"ms\" => Ok(Self::Millisecond),\n            \"seconds\" | \"second\" | \"secs\" | \"sec\" | \"s\" => Ok(Self::Second),\n            \"minutes\" | \"minute\" | \"min\" | \"mins\" | \"m\" => Ok(Self::Minute),\n            \"hours\" | \"hour\" | \"hr\" | \"hrs\" | \"h\" => Ok(Self::Hour),\n            \"days\" | \"day\" | \"d\" => Ok(Self::Day),\n            \"weeks\" | \"week\" | \"wk\" | \"wks\" | \"w\" => Ok(Self::Week),\n            \"months\" | \"month\" | \"M\" => Ok(Self::Month),\n            \"years\" | \"year\" | \"yr\" | \"yrs\" | \"y\" => Ok(Self::Year),\n            _ => Err(()),\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<u64 as duration::OverflowOp>::add":["fn add(self, other: Self) -> Result<Self, Error>{\n        self.checked_add(other).ok_or(Error::NumberOverflow)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<u64 as duration::OverflowOp>::div":["fn div(self, other: Self) -> Result<Self, Error>{\n        match self % other {\n            0 => Ok(self / other),\n            _ => Err(Error::NumberOverflow),\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<u64 as duration::OverflowOp>::mul":["fn mul(self, other: Self) -> Result<Self, Error>{\n        self.checked_mul(other).ok_or(Error::NumberOverflow)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<wrapper::Duration as std::convert::AsRef<std::time::Duration>>::as_ref":["fn as_ref(&self) -> &StdDuration{\n        &self.0\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Duration as std::convert::From<std::time::Duration>>::from":["fn from(dur: StdDuration) -> Duration{\n        Duration(dur)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Duration as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        format_duration(self.0).fmt(f)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Duration as std::ops::Deref>::deref":["fn deref(&self) -> &StdDuration{\n        &self.0\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Duration as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Duration, Self::Err>{\n        parse_duration(s).map(Duration)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Timestamp as std::convert::AsRef<std::time::SystemTime>>::as_ref":["fn as_ref(&self) -> &SystemTime{\n        &self.0\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Timestamp as std::convert::From<std::time::SystemTime>>::from":["fn from(dur: SystemTime) -> Timestamp{\n        Timestamp(dur)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Timestamp as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        format_rfc3339(self.0).fmt(f)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Timestamp as std::ops::Deref>::deref":["fn deref(&self) -> &SystemTime{\n        &self.0\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Timestamp as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Timestamp, Self::Err>{\n        parse_rfc3339_weak(s).map(Timestamp)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"date::Error":["/// Error parsing datetime (timestamp)\npub enum Error {\n    /// Numeric component is out of range\n    OutOfRange,\n    /// Bad character where digit is expected\n    InvalidDigit,\n    /// Other formatting errors\n    InvalidFormat,\n}","Real(LocalPath(\"src/date.rs\"))"],"date::Precision":["enum Precision {\n    Smart,\n    Seconds,\n    Millis,\n    Micros,\n    Nanos,\n}","Real(LocalPath(\"src/date.rs\"))"],"date::Rfc3339Timestamp":["/// A wrapper type that allows you to Display a SystemTime\npub struct Rfc3339Timestamp(SystemTime, Precision);","Real(LocalPath(\"src/date.rs\"))"],"date::Rfc3339Timestamp::get_ref":["/// Returns a reference to the [`SystemTime`][] that is being formatted.\npub fn get_ref(&self) -> &SystemTime{\n        &self.0\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::format_rfc3339":["/// Format an RFC3339 timestamp `2018-02-14T00:28:07Z`\n///\n/// This function formats timestamp with smart precision: i.e. if it has no\n/// fractional seconds, they aren't written at all. And up to nine digits if\n/// they are.\n///\n/// The value is always UTC and ignores system timezone.\npub fn format_rfc3339(system_time: SystemTime) -> Rfc3339Timestamp{\n    Rfc3339Timestamp(system_time, Precision::Smart)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::format_rfc3339_micros":["/// Format an RFC3339 timestamp `2018-02-14T00:28:07.000000Z`\n///\n/// This format always shows microseconds even if microsecond value is zero.\n///\n/// The value is always UTC and ignores system timezone.\npub fn format_rfc3339_micros(system_time: SystemTime) -> Rfc3339Timestamp{\n    Rfc3339Timestamp(system_time, Precision::Micros)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::format_rfc3339_millis":["/// Format an RFC3339 timestamp `2018-02-14T00:28:07.000Z`\n///\n/// This format always shows milliseconds even if millisecond value is zero.\n///\n/// The value is always UTC and ignores system timezone.\npub fn format_rfc3339_millis(system_time: SystemTime) -> Rfc3339Timestamp{\n    Rfc3339Timestamp(system_time, Precision::Millis)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::format_rfc3339_nanos":["/// Format an RFC3339 timestamp `2018-02-14T00:28:07.000000000Z`\n///\n/// This format always shows nanoseconds even if nanosecond value is zero.\n///\n/// The value is always UTC and ignores system timezone.\npub fn format_rfc3339_nanos(system_time: SystemTime) -> Rfc3339Timestamp{\n    Rfc3339Timestamp(system_time, Precision::Nanos)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::format_rfc3339_seconds":["/// Format an RFC3339 timestamp `2018-02-14T00:28:07Z`\n///\n/// This format always shows timestamp without fractional seconds.\n///\n/// The value is always UTC and ignores system timezone.\npub fn format_rfc3339_seconds(system_time: SystemTime) -> Rfc3339Timestamp{\n    Rfc3339Timestamp(system_time, Precision::Seconds)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::is_leap_year":["fn is_leap_year(y: u64) -> bool{\n    y % 4 == 0 && (y % 100 != 0 || y % 400 == 0)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::parse_rfc3339":["/// Parse RFC3339 timestamp `2018-02-14T00:28:07Z`\n///\n/// Supported features:\n/// - Any precision of fractional digits `2018-02-14T00:28:07.133Z`.\n/// - The UTC timezone can be indicated with `Z` or `+00:00`.\n///\n/// Unsupported feature: localized timestamps. Only UTC is supported.\npub fn parse_rfc3339(s: &str) -> Result<SystemTime, Error>{\n    if s.len() < \"2018-02-14T00:28:07Z\".len() {\n        return Err(Error::InvalidFormat);\n    }\n    let b = s.as_bytes();\n    if b[10] != b'T' || (b.last() != Some(&b'Z') && !s.ends_with(\"+00:00\")) {\n        return Err(Error::InvalidFormat);\n    }\n    parse_rfc3339_weak(s)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::parse_rfc3339_weak":["/// Parse RFC3339-like timestamp `2018-02-14 00:28:07`\n///\n/// Supported features:\n///\n/// 1. Any precision of fractional digits `2018-02-14 00:28:07.133`.\n/// 2. Supports timestamp with or without either of `T`, `Z` or `+00:00`.\n/// 3. Anything valid for [`parse_rfc3339`](parse_rfc3339) is valid for this function\n///\n/// Unsupported feature: localized timestamps. Only UTC is supported, even if\n/// `Z` is not specified.\n///\n/// This function is intended to use for parsing human input. Whereas\n/// `parse_rfc3339` is for strings generated programmatically.\npub fn parse_rfc3339_weak(s: &str) -> Result<SystemTime, Error>{\n    if s.len() < \"2018-02-14T00:28:07\".len() {\n        return Err(Error::InvalidFormat);\n    }\n    let b = s.as_bytes(); // for careless slicing\n    if b[4] != b'-'\n        || b[7] != b'-'\n        || (b[10] != b'T' && b[10] != b' ')\n        || b[13] != b':'\n        || b[16] != b':'\n    {\n        return Err(Error::InvalidFormat);\n    }\n    let year = two_digits(b[0], b[1])? * 100 + two_digits(b[2], b[3])?;\n    let month = two_digits(b[5], b[6])?;\n    let day = two_digits(b[8], b[9])?;\n    let hour = two_digits(b[11], b[12])?;\n    let minute = two_digits(b[14], b[15])?;\n    let mut second = two_digits(b[17], b[18])?;\n\n    if year < 1970 || hour > 23 || minute > 59 || second > 60 {\n        return Err(Error::OutOfRange);\n    }\n    // TODO(tailhook) should we check that leaps second is only on midnight ?\n    if second == 60 {\n        second = 59;\n    }\n\n    let leap = is_leap_year(year);\n    let (mut ydays, mdays) = match month {\n        1 => (0, 31),\n        2 if leap => (31, 29),\n        2 => (31, 28),\n        3 => (59, 31),\n        4 => (90, 30),\n        5 => (120, 31),\n        6 => (151, 30),\n        7 => (181, 31),\n        8 => (212, 31),\n        9 => (243, 30),\n        10 => (273, 31),\n        11 => (304, 30),\n        12 => (334, 31),\n        _ => return Err(Error::OutOfRange),\n    };\n    if day > mdays || day == 0 {\n        return Err(Error::OutOfRange);\n    }\n    ydays += day - 1;\n    if leap && month > 2 {\n        ydays += 1;\n    }\n\n    let leap_years =\n        ((year - 1) - 1968) / 4 - ((year - 1) - 1900) / 100 + ((year - 1) - 1600) / 400;\n    let days = (year - 1970) * 365 + leap_years + ydays;\n\n    let time = second + minute * 60 + hour * 3600;\n\n    let mut nanos = 0;\n    let mut mult = 100_000_000;\n    if b.get(19) == Some(&b'.') {\n        for idx in 20..b.len() {\n            if b[idx] == b'Z' {\n                if idx == b.len() - 1 {\n                    break;\n                }\n                return Err(Error::InvalidDigit);\n            } else if b[idx] == b'+' {\n                // start of \"+00:00\", which must be at the end\n                if idx == b.len() - 6 {\n                    break;\n                }\n                return Err(Error::InvalidDigit);\n            }\n\n            nanos += mult * (b[idx] as char).to_digit(10).ok_or(Error::InvalidDigit)?;\n            mult /= 10;\n        }\n    } else if b.len() != 19 && (b.len() > 25 || (b[19] != b'Z' && (&b[19..] != b\"+00:00\"))) {\n        return Err(Error::InvalidFormat);\n    }\n\n    let total_seconds = time + days * 86400;\n    if total_seconds > max::SECONDS {\n        return Err(Error::OutOfRange);\n    }\n\n    Ok(UNIX_EPOCH + Duration::new(total_seconds, nanos))\n}","Real(LocalPath(\"src/date.rs\"))"],"date::two_digits":["#[inline]\n/// Converts two digits given in ASCII to its proper decimal representation.\nfn two_digits(b1: u8, b2: u8) -> Result<u64, Error>{\n    fn two_digits_inner(a: char, b: char) -> Option<u64> {\n        let a = a.to_digit(10)?;\n        let b = b.to_digit(10)?;\n\n        Some((a * 10 + b) as u64)\n    }\n\n    two_digits_inner(b1 as char, b2 as char).ok_or(Error::InvalidDigit)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::two_digits::two_digits_inner":["fn two_digits_inner(a: char, b: char) -> Option<u64>{\n        let a = a.to_digit(10)?;\n        let b = b.to_digit(10)?;\n\n        Some((a * 10 + b) as u64)\n    }","Real(LocalPath(\"src/date.rs\"))"],"duration::Error":["/// Error parsing human-friendly duration\npub enum Error {\n    /// Invalid character during parsing\n    ///\n    /// More specifically anything that is not alphanumeric is prohibited\n    ///\n    /// The field is an byte offset of the character in the string.\n    InvalidCharacter(usize),\n    /// Non-numeric value where number is expected\n    ///\n    /// This usually means that either time unit is broken into words,\n    /// e.g. `m sec` instead of `msec`, or just number is omitted,\n    /// for example `2 hours min` instead of `2 hours 1 min`\n    ///\n    /// The field is an byte offset of the errorneous character\n    /// in the string.\n    NumberExpected(usize),\n    /// Unit in the number is not one of allowed units\n    ///\n    /// See documentation of `parse_duration` for the list of supported\n    /// time units.\n    ///\n    /// The two fields are start and end (exclusive) of the slice from\n    /// the original string, containing errorneous value\n    UnknownUnit {\n        /// Start of the invalid unit inside the original string\n        start: usize,\n        /// End of the invalid unit inside the original string\n        end: usize,\n        /// The unit verbatim\n        unit: String,\n        /// A number associated with the unit\n        value: u64,\n    },\n    /// The numeric value exceeds the limits of this library.\n    ///\n    /// This can mean two things:\n    /// - The value is too large to be useful.\n    ///   For instance, the maximum duration written with subseconds unit is about 3000 years.\n    /// - The attempted precision is not supported.\n    ///   For instance, a duration of `0.5ns` is not supported,\n    ///   because durations below one nanosecond cannot be represented.\n    // NOTE: it would be more logical to create a separate `NumberPrecisionLimit` error,\n    // but that would be a breaking change. Reconsider this for the next major version.\n    NumberOverflow,\n    /// The value was an empty string (or consists only whitespace)\n    Empty,\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::FormattedDuration":["/// A wrapper type that allows you to Display a Duration\npub struct FormattedDuration(Duration);","Real(LocalPath(\"src/duration.rs\"))"],"duration::FormattedDuration::get_ref":["/// Returns a reference to the [`Duration`][] that is being formatted.\npub fn get_ref(&self) -> &Duration{\n        &self.0\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Fraction":["struct Fraction {\n    numerator: u64,\n    denominator: u64,\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::OverflowOp":["trait OverflowOp: Sized {\n    fn mul(self, other: Self) -> Result<Self, Error>;\n    fn add(self, other: Self) -> Result<Self, Error>;\n    fn div(self, other: Self) -> Result<Self, Error>;\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::Parser":["struct Parser<'a> {\n    iter: Chars<'a>,\n    src: &'a str,\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::Parser::<'_>::off":["fn off(&self) -> usize{\n        self.src.len() - self.iter.as_str().len()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Parser::<'_>::parse":["fn parse(mut self) -> Result<Duration, Error>{\n        let mut n = self.parse_first_char()?.ok_or(Error::Empty)?; // integer part\n        let mut out = Duration::ZERO;\n        'outer: loop {\n            let mut frac = None; // fractional part\n            let mut off = self.off();\n            while let Some(c) = self.iter.next() {\n                match c {\n                    '0'..='9' => {\n                        n = n\n                            .checked_mul(10)\n                            .and_then(|x| x.checked_add(c as u64 - '0' as u64))\n                            .ok_or(Error::NumberOverflow)?;\n                    }\n                    c if c.is_whitespace() => {}\n                    'a'..='z' | 'A'..='Z' | 'µ' => {\n                        break;\n                    }\n                    '.' => {\n                        // decimal separator, the fractional part begins now\n                        frac = Some(self.parse_fractional_part(&mut off)?);\n                        break;\n                    }\n                    _ => {\n                        return Err(Error::InvalidCharacter(off));\n                    }\n                }\n                off = self.off();\n            }\n            let start = off;\n            let mut off = self.off();\n            while let Some(c) = self.iter.next() {\n                match c {\n                    '0'..='9' => {\n                        self.parse_unit(n, frac, start, off, &mut out)?;\n                        n = c as u64 - '0' as u64;\n                        continue 'outer;\n                    }\n                    c if c.is_whitespace() => break,\n                    'a'..='z' | 'A'..='Z' | 'µ' => {}\n                    _ => {\n                        return Err(Error::InvalidCharacter(off));\n                    }\n                }\n                off = self.off();\n            }\n\n            self.parse_unit(n, frac, start, off, &mut out)?;\n            n = match self.parse_first_char()? {\n                Some(n) => n,\n                None => return Ok(out),\n            };\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Parser::<'_>::parse_first_char":["fn parse_first_char(&mut self) -> Result<Option<u64>, Error>{\n        let off = self.off();\n        for c in self.iter.by_ref() {\n            match c {\n                '0'..='9' => {\n                    return Ok(Some(c as u64 - '0' as u64));\n                }\n                c if c.is_whitespace() => continue,\n                _ => {\n                    return Err(Error::NumberExpected(off));\n                }\n            }\n        }\n        Ok(None)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Parser::<'_>::parse_fractional_part":["fn parse_fractional_part(&mut self, off: &mut usize) -> Result<Fraction, Error>{\n        let mut numerator = 0u64;\n        let mut denominator = 1u64;\n        let mut zeros = true;\n        while let Some(c) = self.iter.next() {\n            match c {\n                '0' => {\n                    denominator = denominator.checked_mul(10).ok_or(Error::NumberOverflow)?;\n                    if !zeros {\n                        numerator = numerator.checked_mul(10).ok_or(Error::NumberOverflow)?;\n                    }\n                }\n                '1'..='9' => {\n                    zeros = false;\n                    denominator = denominator.checked_mul(10).ok_or(Error::NumberOverflow)?;\n                    numerator = numerator\n                        .checked_mul(10)\n                        .and_then(|x| x.checked_add(c as u64 - '0' as u64))\n                        .ok_or(Error::NumberOverflow)?;\n                }\n                c if c.is_whitespace() => {}\n                'a'..='z' | 'A'..='Z' | 'µ' => {\n                    break;\n                }\n                _ => {\n                    return Err(Error::InvalidCharacter(*off));\n                }\n            };\n            // update the offset used by the parsing loop\n            *off = self.off();\n        }\n        if denominator == 1 {\n            // no digits were given after the separator, e.g. \"1.\"\n            return Err(Error::InvalidCharacter(*off));\n        }\n        Ok(Fraction {\n            numerator,\n            denominator,\n        })\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Parser::<'_>::parse_unit":["fn parse_unit(\n        &mut self,\n        n: u64,\n        frac: Option<Fraction>,\n        start: usize,\n        end: usize,\n        out: &mut Duration,\n    ) -> Result<(), Error>{\n        let unit = match Unit::from_str(&self.src[start..end]) {\n            Ok(u) => u,\n            Err(()) => {\n                return Err(Error::UnknownUnit {\n                    start,\n                    end,\n                    unit: self.src[start..end].to_owned(),\n                    value: n,\n                });\n            }\n        };\n\n        // add the integer part\n        let (sec, nsec) = match unit {\n            Unit::Nanosecond => (0u64, n),\n            Unit::Microsecond => (0u64, n.mul(1000)?),\n            Unit::Millisecond => (0u64, n.mul(1_000_000)?),\n            Unit::Second => (n, 0),\n            Unit::Minute => (n.mul(60)?, 0),\n            Unit::Hour => (n.mul(3600)?, 0),\n            Unit::Day => (n.mul(86400)?, 0),\n            Unit::Week => (n.mul(86400 * 7)?, 0),\n            Unit::Month => (n.mul(2_630_016)?, 0), // 30.44d\n            Unit::Year => (n.mul(31_557_600)?, 0), // 365.25d\n        };\n        add_current(sec, nsec, out)?;\n\n        // add the fractional part\n        if let Some(Fraction {\n            numerator: n,\n            denominator: d,\n        }) = frac\n        {\n            let (sec, nsec) = match unit {\n                Unit::Nanosecond => return Err(Error::NumberOverflow),\n                Unit::Microsecond => (0, n.mul(1000)?.div(d)?),\n                Unit::Millisecond => (0, n.mul(1_000_000)?.div(d)?),\n                Unit::Second => (0, n.mul(1_000_000_000)?.div(d)?),\n                Unit::Minute => (0, n.mul(60_000_000_000)?.div(d)?),\n                Unit::Hour => (n.mul(3600)?.div(d)?, 0),\n                Unit::Day => (n.mul(86400)?.div(d)?, 0),\n                Unit::Week => (n.mul(86400 * 7)?.div(d)?, 0),\n                Unit::Month => (n.mul(2_630_016)?.div(d)?, 0), // 30.44d\n                Unit::Year => (n.mul(31_557_600)?.div(d)?, 0), // 365.25d\n            };\n            add_current(sec, nsec, out)?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Unit":["enum Unit {\n    Nanosecond,\n    Microsecond,\n    Millisecond,\n    Second,\n    Minute,\n    Hour,\n    Day,\n    Week,\n    Month,\n    Year,\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::add_current":["fn add_current(mut sec: u64, nsec: u64, out: &mut Duration) -> Result<(), Error>{\n    let mut nsec = (out.subsec_nanos() as u64).add(nsec)?;\n    if nsec > 1_000_000_000 {\n        sec = sec.add(nsec / 1_000_000_000)?;\n        nsec %= 1_000_000_000;\n    }\n    sec = out.as_secs().add(sec)?;\n    *out = Duration::new(sec, nsec as u32);\n    Ok(())\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::format_duration":["/// Formats duration into a human-readable string\n///\n/// Note: this format is guaranteed to have same value when using\n/// parse_duration, but we can change some details of the exact composition\n/// of the value.\n///\n/// # Examples\n///\n/// ```\n/// use std::time::Duration;\n/// use humantime::format_duration;\n///\n/// let val1 = Duration::new(9420, 0);\n/// assert_eq!(format_duration(val1).to_string(), \"2h 37m\");\n/// let val2 = Duration::new(0, 32_000_000);\n/// assert_eq!(format_duration(val2).to_string(), \"32ms\");\n/// ```\npub fn format_duration(val: Duration) -> FormattedDuration{\n    FormattedDuration(val)\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::item":["fn item(f: &mut fmt::Formatter, started: &mut bool, name: &str, value: u32) -> fmt::Result{\n    if value > 0 {\n        if *started {\n            f.write_str(\" \")?;\n        }\n        write!(f, \"{}{}\", value, name)?;\n        *started = true;\n    }\n    Ok(())\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::item_plural":["fn item_plural(f: &mut fmt::Formatter, started: &mut bool, name: &str, value: u64) -> fmt::Result{\n    if value > 0 {\n        if *started {\n            f.write_str(\" \")?;\n        }\n        write!(f, \"{}{}\", value, name)?;\n        if value > 1 {\n            f.write_str(\"s\")?;\n        }\n        *started = true;\n    }\n    Ok(())\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::parse_duration":["/// Parse duration object `1hour 12min 5s`\n///\n/// The duration object is a concatenation of time spans. Where each time\n/// span is an integer number and a suffix. Supported suffixes:\n///\n/// * `nsec`, `ns` -- nanoseconds\n/// * `usec`, `us`, `µs` -- microseconds\n/// * `msec`, `ms` -- milliseconds\n/// * `seconds`, `second`, `sec`, `s`\n/// * `minutes`, `minute`, `min`, `m`\n/// * `hours`, `hour`, `hr`, `hrs`, `h`\n/// * `days`, `day`, `d`\n/// * `weeks`, `week`, `wk`, `wks`, `w`\n/// * `months`, `month`, `M` -- defined as 30.44 days\n/// * `years`, `year`, `yr`, `yrs`, `y` -- defined as 365.25 days\n///\n/// # Examples\n///\n/// ```\n/// use std::time::Duration;\n/// use humantime::parse_duration;\n///\n/// assert_eq!(parse_duration(\"2h 37min\"), Ok(Duration::new(9420, 0)));\n/// assert_eq!(parse_duration(\"32ms\"), Ok(Duration::new(0, 32_000_000)));\n/// assert_eq!(parse_duration(\"4.2s\"), Ok(Duration::new(4, 200_000_000)));\n/// ```\npub fn parse_duration(s: &str) -> Result<Duration, Error>{\n    if s == \"0\" {\n        return Ok(Duration::ZERO);\n    }\n    Parser {\n        iter: s.chars(),\n        src: s,\n    }\n    .parse()\n}","Real(LocalPath(\"src/duration.rs\"))"],"wrapper::<impl std::convert::From<wrapper::Duration> for std::time::Duration>::from":["fn from(val: Duration) -> Self{\n        val.0\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"wrapper::<impl std::convert::From<wrapper::Timestamp> for std::time::SystemTime>::from":["fn from(val: Timestamp) -> Self{\n        val.0\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"wrapper::Duration":["/// A wrapper for duration that has `FromStr` implementation\n///\n/// This is useful if you want to use it somewhere where `FromStr` is\n/// expected.\n///\n/// See `parse_duration` for the description of the format.\n///\n/// # Example\n///\n/// ```\n/// use std::time::Duration;\n/// let x: Duration;\n/// x = \"12h 5min 2ns\".parse::<humantime::Duration>().unwrap().into();\n/// assert_eq!(x, Duration::new(12*3600 + 5*60, 2))\n/// ```\n///\npub struct Duration(StdDuration);","Real(LocalPath(\"src/wrapper.rs\"))"],"wrapper::Timestamp":["/// A wrapper for SystemTime that has `FromStr` implementation\n///\n/// This is useful if you want to use it somewhere where `FromStr` is\n/// expected.\n///\n/// See `parse_rfc3339_weak` for the description of the format. The \"weak\"\n/// format is used as it's more pemissive for human input as this is the\n/// expected use of the type (e.g. command-line parsing).\n///\n/// # Example\n///\n/// ```\n/// use std::time::SystemTime;\n/// let x: SystemTime;\n/// x = \"2018-02-16T00:31:37Z\".parse::<humantime::Timestamp>().unwrap().into();\n/// assert_eq!(humantime::format_rfc3339(x).to_string(), \"2018-02-16T00:31:37Z\");\n/// ```\n///\npub struct Timestamp(SystemTime);","Real(LocalPath(\"src/wrapper.rs\"))"]},"struct_constructor":{"&std::time::Duration":["as_ref","deref","get_ref"],"&std::time::SystemTime":["as_ref","deref","get_ref"],"bool":["eq","is_leap_year"],"date::Error":["clone"],"date::Precision":["clone"],"date::Rfc3339Timestamp":["clone","format_rfc3339","format_rfc3339_micros","format_rfc3339_millis","format_rfc3339_nanos","format_rfc3339_seconds"],"duration::Error":["clone"],"duration::FormattedDuration":["clone","format_duration"],"duration::Fraction":["clone","parse_fractional_part"],"duration::Unit":["from_str"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::time::Duration":["from","parse","parse_duration"],"std::time::SystemTime":["from","parse_rfc3339","parse_rfc3339_weak"],"u64":["parse_first_char","two_digits","two_digits_inner"],"usize":["off"],"wrapper::Duration":["clone","default","from","from_str"],"wrapper::Timestamp":["clone","from","from_str"]},"struct_to_trait":{"date::Error":["std::clone::Clone","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralPartialEq"],"date::Precision":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"date::Rfc3339Timestamp":["std::clone::Clone","std::fmt::Debug","std::fmt::Display"],"duration::Error":["std::clone::Clone","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralPartialEq"],"duration::FormattedDuration":["std::clone::Clone","std::fmt::Debug","std::fmt::Display"],"duration::Fraction":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"duration::Unit":["std::str::FromStr"],"std::time::Duration":["std::convert::From"],"std::time::SystemTime":["std::convert::From"],"wrapper::Duration":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref","std::str::FromStr"],"wrapper::Timestamp":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref","std::str::FromStr"]},"targets":{"<date::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/date.rs\"))","std::fmt::Display"],"<date::Rfc3339Timestamp as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/date.rs\"))","std::fmt::Display"],"<duration::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/duration.rs\"))","std::fmt::Display"],"<duration::FormattedDuration as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/duration.rs\"))","std::fmt::Display"],"<duration::Unit as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/duration.rs\"))","std::str::FromStr"],"<u64 as duration::OverflowOp>::add":["add","Real(LocalPath(\"src/duration.rs\"))","duration::OverflowOp"],"<u64 as duration::OverflowOp>::div":["div","Real(LocalPath(\"src/duration.rs\"))","duration::OverflowOp"],"<u64 as duration::OverflowOp>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","duration::OverflowOp"],"<wrapper::Duration as std::convert::AsRef<std::time::Duration>>::as_ref":["as_ref","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::AsRef"],"<wrapper::Duration as std::convert::From<std::time::Duration>>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"<wrapper::Duration as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Display"],"<wrapper::Duration as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/wrapper.rs\"))","std::ops::Deref"],"<wrapper::Duration as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/wrapper.rs\"))","std::str::FromStr"],"<wrapper::Timestamp as std::convert::AsRef<std::time::SystemTime>>::as_ref":["as_ref","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::AsRef"],"<wrapper::Timestamp as std::convert::From<std::time::SystemTime>>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"<wrapper::Timestamp as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Display"],"<wrapper::Timestamp as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/wrapper.rs\"))","std::ops::Deref"],"<wrapper::Timestamp as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/wrapper.rs\"))","std::str::FromStr"],"date::Rfc3339Timestamp::get_ref":["get_ref","Real(LocalPath(\"src/date.rs\"))",""],"date::format_rfc3339":["format_rfc3339","Real(LocalPath(\"src/date.rs\"))",""],"date::format_rfc3339_micros":["format_rfc3339_micros","Real(LocalPath(\"src/date.rs\"))",""],"date::format_rfc3339_millis":["format_rfc3339_millis","Real(LocalPath(\"src/date.rs\"))",""],"date::format_rfc3339_nanos":["format_rfc3339_nanos","Real(LocalPath(\"src/date.rs\"))",""],"date::format_rfc3339_seconds":["format_rfc3339_seconds","Real(LocalPath(\"src/date.rs\"))",""],"date::is_leap_year":["is_leap_year","Real(LocalPath(\"src/date.rs\"))",""],"date::parse_rfc3339":["parse_rfc3339","Real(LocalPath(\"src/date.rs\"))",""],"date::parse_rfc3339_weak":["parse_rfc3339_weak","Real(LocalPath(\"src/date.rs\"))",""],"date::two_digits":["two_digits","Real(LocalPath(\"src/date.rs\"))",""],"date::two_digits::two_digits_inner":["two_digits_inner","Real(LocalPath(\"src/date.rs\"))",""],"duration::FormattedDuration::get_ref":["get_ref","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Parser::<'_>::off":["off","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Parser::<'_>::parse":["parse","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Parser::<'_>::parse_first_char":["parse_first_char","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Parser::<'_>::parse_fractional_part":["parse_fractional_part","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Parser::<'_>::parse_unit":["parse_unit","Real(LocalPath(\"src/duration.rs\"))",""],"duration::add_current":["add_current","Real(LocalPath(\"src/duration.rs\"))",""],"duration::format_duration":["format_duration","Real(LocalPath(\"src/duration.rs\"))",""],"duration::item":["item","Real(LocalPath(\"src/duration.rs\"))",""],"duration::item_plural":["item_plural","Real(LocalPath(\"src/duration.rs\"))",""],"duration::parse_duration":["parse_duration","Real(LocalPath(\"src/duration.rs\"))",""],"wrapper::<impl std::convert::From<wrapper::Duration> for std::time::Duration>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"wrapper::<impl std::convert::From<wrapper::Timestamp> for std::time::SystemTime>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"]},"trait_to_struct":{"std::clone::Clone":["date::Error","date::Precision","date::Rfc3339Timestamp","duration::Error","duration::FormattedDuration","duration::Fraction","wrapper::Duration","wrapper::Timestamp"],"std::cmp::Eq":["date::Precision","wrapper::Duration","wrapper::Timestamp"],"std::cmp::Ord":["wrapper::Duration","wrapper::Timestamp"],"std::cmp::PartialEq":["date::Error","date::Precision","duration::Error","wrapper::Duration","wrapper::Timestamp"],"std::cmp::PartialOrd":["wrapper::Duration","wrapper::Timestamp"],"std::convert::AsRef":["wrapper::Duration","wrapper::Timestamp"],"std::convert::From":["std::time::Duration","std::time::SystemTime","wrapper::Duration","wrapper::Timestamp"],"std::default::Default":["wrapper::Duration"],"std::error::Error":["date::Error","duration::Error"],"std::fmt::Debug":["date::Error","date::Precision","date::Rfc3339Timestamp","duration::Error","duration::FormattedDuration","duration::Fraction","wrapper::Duration","wrapper::Timestamp"],"std::fmt::Display":["date::Error","date::Rfc3339Timestamp","duration::Error","duration::FormattedDuration","wrapper::Duration","wrapper::Timestamp"],"std::hash::Hash":["wrapper::Duration","wrapper::Timestamp"],"std::marker::Copy":["date::Error","duration::Fraction","wrapper::Duration","wrapper::Timestamp"],"std::marker::StructuralEq":["date::Precision","wrapper::Duration","wrapper::Timestamp"],"std::marker::StructuralPartialEq":["date::Error","date::Precision","duration::Error","wrapper::Duration","wrapper::Timestamp"],"std::ops::Deref":["wrapper::Duration","wrapper::Timestamp"],"std::str::FromStr":["duration::Unit","wrapper::Duration","wrapper::Timestamp"]},"type_to_def_path":{"date::Error":"date::Error","date::Precision":"date::Precision","date::Rfc3339Timestamp":"date::Rfc3339Timestamp","duration::Error":"duration::Error","duration::FormattedDuration":"duration::FormattedDuration","duration::Fraction":"duration::Fraction","duration::Parser<'a>":"duration::Parser","duration::Unit":"duration::Unit","wrapper::Duration":"wrapper::Duration","wrapper::Timestamp":"wrapper::Timestamp"}}