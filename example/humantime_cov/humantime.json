{"dependencies":{"<date::Error as std::clone::Clone>::clone":["date::Error"],"<date::Error as std::cmp::PartialEq>::eq":["date::Error"],"<date::Error as std::fmt::Debug>::fmt":["date::Error","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<date::Error as std::fmt::Display>::fmt":["date::Error","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<date::Precision as std::clone::Clone>::clone":["date::Precision"],"<date::Precision as std::cmp::Eq>::assert_receiver_is_total_eq":["date::Precision"],"<date::Precision as std::cmp::PartialEq>::eq":["date::Precision"],"<date::Precision as std::fmt::Debug>::fmt":["date::Precision","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"<date::Rfc3339Timestamp as std::clone::Clone>::clone":["date::Precision","date::Rfc3339Timestamp","std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime"],"<date::Rfc3339Timestamp as std::fmt::Debug>::fmt":["date::Precision","date::Rfc3339Timestamp","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime"],"<date::Rfc3339Timestamp as std::fmt::Display>::fmt":["date::Precision","date::Rfc3339Timestamp","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime"],"<duration::Error as std::clone::Clone>::clone":["alloc::raw_vec::RawVec","duration::Error","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<duration::Error as std::cmp::PartialEq>::eq":["alloc::raw_vec::RawVec","duration::Error","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"<duration::Error as std::fmt::Debug>::fmt":["alloc::raw_vec::RawVec","duration::Error","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<duration::Error as std::fmt::Display>::fmt":["alloc::raw_vec::RawVec","duration::Error","std::alloc::Allocator","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::PhantomData","std::marker::Sized","std::option::Option","std::ptr::NonNull","std::ptr::Unique","std::result::Result","std::string::String","std::vec::Vec"],"<duration::FormattedDuration as std::clone::Clone>::clone":["core::time::Nanoseconds","duration::FormattedDuration","std::time::Duration"],"<duration::FormattedDuration as std::fmt::Debug>::fmt":["core::time::Nanoseconds","duration::FormattedDuration","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","std::time::Duration"],"<duration::FormattedDuration as std::fmt::Display>::fmt":["core::time::Nanoseconds","duration::FormattedDuration","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","std::time::Duration"],"<u64 as duration::OverflowOp>::add":["std::marker::Sized","std::result::Result"],"<u64 as duration::OverflowOp>::mul":["std::marker::Sized","std::result::Result"],"<wrapper::Duration as std::clone::Clone>::clone":["core::time::Nanoseconds","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::cmp::Eq>::assert_receiver_is_total_eq":["core::time::Nanoseconds","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::cmp::PartialEq>::eq":["core::time::Nanoseconds","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::convert::AsRef<std::time::Duration>>::as_ref":["core::time::Nanoseconds","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::convert::From<std::time::Duration>>::from":["core::time::Nanoseconds","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::convert::Into<std::time::Duration>>::into":["core::time::Nanoseconds","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::fmt::Debug>::fmt":["core::time::Nanoseconds","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::fmt::Display>::fmt":["core::time::Nanoseconds","std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::hash::Hash>::hash":["core::time::Nanoseconds","std::hash::Hasher","std::marker::Sized","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::ops::Deref>::deref":["core::time::Nanoseconds","std::time::Duration","wrapper::Duration"],"<wrapper::Duration as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<wrapper::Timestamp as std::clone::Clone>::clone":["std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::cmp::Eq>::assert_receiver_is_total_eq":["std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::cmp::PartialEq>::eq":["std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::convert::AsRef<std::time::SystemTime>>::as_ref":["std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::convert::From<std::time::SystemTime>>::from":["std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::convert::Into<std::time::SystemTime>>::into":["std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::fmt::Display>::fmt":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result","std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::ops::Deref>::deref":["std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime","wrapper::Timestamp"],"<wrapper::Timestamp as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"date::Error":["date::Error"],"date::Precision":["date::Precision"],"date::Rfc3339Timestamp":["date::Precision","date::Rfc3339Timestamp","std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime"],"date::Rfc3339Timestamp::get_ref":["date::Precision","date::Rfc3339Timestamp","std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime"],"date::format_rfc3339":["date::Precision","date::Rfc3339Timestamp","std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime"],"date::format_rfc3339_micros":["date::Precision","date::Rfc3339Timestamp","std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime"],"date::format_rfc3339_millis":["date::Precision","date::Rfc3339Timestamp","std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime"],"date::format_rfc3339_nanos":["date::Precision","date::Rfc3339Timestamp","std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime"],"date::format_rfc3339_seconds":["date::Precision","date::Rfc3339Timestamp","std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime"],"date::is_leap_year":[],"date::parse_rfc3339":["std::marker::Sized","std::result::Result"],"date::parse_rfc3339_weak":["std::marker::Sized","std::result::Result"],"date::two_digits":["std::marker::Sized","std::result::Result"],"date::two_digits::two_digits_inner":["std::marker::Sized","std::option::Option"],"duration::Error":["alloc::raw_vec::RawVec","duration::Error","std::alloc::Allocator","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::ptr::Unique","std::string::String","std::vec::Vec"],"duration::FormattedDuration":["core::time::Nanoseconds","duration::FormattedDuration","std::time::Duration"],"duration::FormattedDuration::get_ref":["core::time::Nanoseconds","duration::FormattedDuration","std::time::Duration"],"duration::OverflowOp::add":["std::marker::Sized","std::result::Result"],"duration::OverflowOp::mul":["std::marker::Sized","std::result::Result"],"duration::Parser":["duration::Parser","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"duration::Parser::<'a>::off":["duration::Parser","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::slice::Iter","std::str::Chars"],"duration::Parser::<'a>::parse":["duration::Parser","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::slice::Iter","std::str::Chars"],"duration::Parser::<'a>::parse_first_char":["duration::Parser","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::slice::Iter","std::str::Chars"],"duration::Parser::<'a>::parse_unit":["duration::Parser","std::marker::PhantomData","std::marker::Sized","std::ptr::NonNull","std::result::Result","std::slice::Iter","std::str::Chars"],"duration::format_duration":["core::time::Nanoseconds","duration::FormattedDuration","std::time::Duration"],"duration::item":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"duration::item_plural":["std::fmt::Formatter","std::fmt::rt::v1::Alignment","std::marker::Sized","std::option::Option","std::result::Result"],"duration::parse_duration":["std::marker::Sized","std::result::Result"],"wrapper::Duration":["core::time::Nanoseconds","std::time::Duration","wrapper::Duration"],"wrapper::Timestamp":["std::sys::unix::time::Nanoseconds","std::sys::unix::time::SystemTime","std::sys::unix::time::Timespec","std::time::SystemTime","wrapper::Timestamp"]},"glob_path_import":{},"self_to_fn":{"date::Error":["Clone","Copy","Debug","PartialEq","impl StdError for Error {}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Error::OutOfRange => write!(f, \"numeric component is out of range\"),\n            Error::InvalidDigit => write!(f, \"bad character where digit is expected\"),\n            Error::InvalidFormat => write!(f, \"timestamp format is invalid\"),\n        }\n    }\n}"],"date::Precision":["Clone","Debug","Eq","PartialEq"],"date::Rfc3339Timestamp":["Clone","Debug","impl Rfc3339Timestamp {\n    /// Returns a reference to the [`SystemTime`][] that is being formatted.\n    pub fn get_ref(&self) -> &SystemTime {\n        &self.0\n    }\n}","impl fmt::Display for Rfc3339Timestamp {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use self::Precision::*;\n\n        let dur = self.0.duration_since(UNIX_EPOCH)\n            .expect(\"all times should be after the epoch\");\n        let secs_since_epoch = dur.as_secs();\n        let nanos = dur.subsec_nanos();\n\n        if secs_since_epoch >= 253_402_300_800 { // year 9999\n            return Err(fmt::Error);\n        }\n\n        /* 2000-03-01 (mod 400 year, immediately after feb29 */\n        const LEAPOCH: i64 = 11017;\n        const DAYS_PER_400Y: i64 = 365*400 + 97;\n        const DAYS_PER_100Y: i64 = 365*100 + 24;\n        const DAYS_PER_4Y: i64 = 365*4 + 1;\n\n        let days = (secs_since_epoch / 86400) as i64 - LEAPOCH;\n        let secs_of_day = secs_since_epoch % 86400;\n\n        let mut qc_cycles = days / DAYS_PER_400Y;\n        let mut remdays = days % DAYS_PER_400Y;\n\n        if remdays < 0 {\n            remdays += DAYS_PER_400Y;\n            qc_cycles -= 1;\n        }\n\n        let mut c_cycles = remdays / DAYS_PER_100Y;\n        if c_cycles == 4 { c_cycles -= 1; }\n        remdays -= c_cycles * DAYS_PER_100Y;\n\n        let mut q_cycles = remdays / DAYS_PER_4Y;\n        if q_cycles == 25 { q_cycles -= 1; }\n        remdays -= q_cycles * DAYS_PER_4Y;\n\n        let mut remyears = remdays / 365;\n        if remyears == 4 { remyears -= 1; }\n        remdays -= remyears * 365;\n\n        let mut year = 2000 +\n            remyears + 4*q_cycles + 100*c_cycles + 400*qc_cycles;\n\n        let months = [31,30,31,30,31,31,30,31,30,31,31,29];\n        let mut mon = 0;\n        for mon_len in months.iter() {\n            mon += 1;\n            if remdays < *mon_len {\n                break;\n            }\n            remdays -= *mon_len;\n        }\n        let mday = remdays+1;\n        let mon = if mon + 2 > 12 {\n            year += 1;\n            mon - 10\n        } else {\n            mon + 2\n        };\n\n        const BUF_INIT: [u8; 30] = *b\"0000-00-00T00:00:00.000000000Z\";\n\n        let mut buf: [u8; 30] = BUF_INIT;\n        buf[0] = b'0' + (year / 1000) as u8;\n        buf[1] = b'0' + (year / 100 % 10) as u8;\n        buf[2] = b'0' + (year / 10 % 10) as u8;\n        buf[3] = b'0' + (year % 10) as u8;\n        buf[5] = b'0' + (mon / 10) as u8;\n        buf[6] = b'0' + (mon % 10) as u8;\n        buf[8] = b'0' + (mday / 10) as u8;\n        buf[9] = b'0' + (mday % 10) as u8;\n        buf[11] = b'0' + (secs_of_day / 3600 / 10) as u8;\n        buf[12] = b'0' + (secs_of_day / 3600 % 10) as u8;\n        buf[14] = b'0' + (secs_of_day / 60 / 10 % 6) as u8;\n        buf[15] = b'0' + (secs_of_day / 60 % 10) as u8;\n        buf[17] = b'0' + (secs_of_day / 10 % 6) as u8;\n        buf[18] = b'0' + (secs_of_day % 10) as u8;\n\n        let offset = if self.1 == Seconds || nanos == 0 && self.1 == Smart {\n            buf[19] = b'Z';\n            19\n        } else if self.1 == Millis {\n            buf[20] = b'0' + (nanos / 100_000_000) as u8;\n            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;\n            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;\n            buf[23] = b'Z';\n            23\n        } else if self.1 == Micros {\n            buf[20] = b'0' + (nanos / 100_000_000) as u8;\n            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;\n            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;\n            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;\n            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;\n            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;\n            buf[26] = b'Z';\n            26\n        } else {\n            buf[20] = b'0' + (nanos / 100_000_000) as u8;\n            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;\n            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;\n            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;\n            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;\n            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;\n            buf[26] = b'0' + (nanos / 100 % 10) as u8;\n            buf[27] = b'0' + (nanos / 10 % 10) as u8;\n            buf[28] = b'0' + (nanos % 10) as u8;\n            // 29th is 'Z'\n            29\n        };\n\n        // we know our chars are all ascii\n        f.write_str(str::from_utf8(&buf[..=offset]).expect(\"Conversion to utf8 failed\"))\n    }\n}"],"duration::Error":["Clone","Debug","PartialEq","impl StdError for Error {}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Error::InvalidCharacter(offset) => write!(f, \"invalid character at {}\", offset),\n            Error::NumberExpected(offset) => write!(f, \"expected number at {}\", offset),\n            Error::UnknownUnit { unit, value, .. } if unit.is_empty() => {\n                write!(f,\n                    \"time unit needed, for example {0}sec or {0}ms\",\n                    value,\n                )\n            }\n            Error::UnknownUnit { unit, .. } => {\n                write!(\n                    f,\n                    \"unknown time unit {:?}, \\\n                    supported units: ns, us, ms, sec, min, hours, days, \\\n                    weeks, months, years (and few variations)\",\n                    unit\n                )\n            }\n            Error::NumberOverflow => write!(f, \"number is too large\"),\n            Error::Empty => write!(f, \"value was empty\"),\n        }\n    }\n}"],"duration::FormattedDuration":["Clone","Debug","impl FormattedDuration {\n    /// Returns a reference to the [`Duration`][] that is being formatted.\n    pub fn get_ref(&self) -> &Duration {\n        &self.0\n    }\n}","impl fmt::Display for FormattedDuration {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let secs = self.0.as_secs();\n        let nanos = self.0.subsec_nanos();\n\n        if secs == 0 && nanos == 0 {\n            f.write_str(\"0s\")?;\n            return Ok(());\n        }\n\n        let years = secs / 31_557_600;  // 365.25d\n        let ydays = secs % 31_557_600;\n        let months = ydays / 2_630_016;  // 30.44d\n        let mdays = ydays % 2_630_016;\n        let days = mdays / 86400;\n        let day_secs = mdays % 86400;\n        let hours = day_secs / 3600;\n        let minutes = day_secs % 3600 / 60;\n        let seconds = day_secs % 60;\n\n        let millis = nanos / 1_000_000;\n        let micros = nanos / 1000 % 1000;\n        let nanosec = nanos % 1000;\n\n        let started = &mut false;\n        item_plural(f, started, \"year\", years)?;\n        item_plural(f, started, \"month\", months)?;\n        item_plural(f, started, \"day\", days)?;\n        item(f, started, \"h\", hours as u32)?;\n        item(f, started, \"m\", minutes as u32)?;\n        item(f, started, \"s\", seconds as u32)?;\n        item(f, started, \"ms\", millis)?;\n        item(f, started, \"us\", micros)?;\n        item(f, started, \"ns\", nanosec)?;\n        Ok(())\n    }\n}"],"duration::Parser":["impl<'a> Parser<'a> {\n    fn off(&self) -> usize {\n        self.src.len() - self.iter.as_str().len()\n    }\n\n    fn parse_first_char(&mut self) -> Result<Option<u64>, Error> {\n        let off = self.off();\n        for c in self.iter.by_ref() {\n            match c {\n                '0'..='9' => {\n                    return Ok(Some(c as u64 - '0' as u64));\n                }\n                c if c.is_whitespace() => continue,\n                _ => {\n                    return Err(Error::NumberExpected(off));\n                }\n            }\n        }\n        Ok(None)\n    }\n    fn parse_unit(&mut self, n: u64, start: usize, end: usize)\n        -> Result<(), Error>\n    {\n        let (mut sec, nsec) = match &self.src[start..end] {\n            \"nanos\" | \"nsec\" | \"ns\" => (0u64, n),\n            \"usec\" | \"us\" => (0u64, n.mul(1000)?),\n            \"millis\" | \"msec\" | \"ms\" => (0u64, n.mul(1_000_000)?),\n            \"seconds\" | \"second\" | \"secs\" | \"sec\" | \"s\" => (n, 0),\n            \"minutes\" | \"minute\" | \"min\" | \"mins\" | \"m\"\n            => (n.mul(60)?, 0),\n            \"hours\" | \"hour\" | \"hr\" | \"hrs\" | \"h\" => (n.mul(3600)?, 0),\n            \"days\" | \"day\" | \"d\" => (n.mul(86400)?, 0),\n            \"weeks\" | \"week\" | \"w\" => (n.mul(86400*7)?, 0),\n            \"months\" | \"month\" | \"M\" => (n.mul(2_630_016)?, 0), // 30.44d\n            \"years\" | \"year\" | \"y\" => (n.mul(31_557_600)?, 0), // 365.25d\n            _ => {\n                return Err(Error::UnknownUnit {\n                    start, end,\n                    unit: self.src[start..end].to_string(),\n                    value: n,\n                });\n            }\n        };\n        let mut nsec = self.current.1.add(nsec)?;\n        if nsec > 1_000_000_000 {\n            sec = sec.add(nsec / 1_000_000_000)?;\n            nsec %= 1_000_000_000;\n        }\n        sec = self.current.0.add(sec)?;\n        self.current = (sec, nsec);\n        Ok(())\n    }\n\n    fn parse(mut self) -> Result<Duration, Error> {\n        let mut n = self.parse_first_char()?.ok_or(Error::Empty)?;\n        'outer: loop {\n            let mut off = self.off();\n            while let Some(c) = self.iter.next() {\n                match c {\n                    '0'..='9' => {\n                        n = n.checked_mul(10)\n                            .and_then(|x| x.checked_add(c as u64 - '0' as u64))\n                            .ok_or(Error::NumberOverflow)?;\n                    }\n                    c if c.is_whitespace() => {}\n                    'a'..='z' | 'A'..='Z' => {\n                        break;\n                    }\n                    _ => {\n                        return Err(Error::InvalidCharacter(off));\n                    }\n                }\n                off = self.off();\n            }\n            let start = off;\n            let mut off = self.off();\n            while let Some(c) = self.iter.next() {\n                match c {\n                    '0'..='9' => {\n                        self.parse_unit(n, start, off)?;\n                        n = c as u64 - '0' as u64;\n                        continue 'outer;\n                    }\n                    c if c.is_whitespace() => break,\n                    'a'..='z' | 'A'..='Z' => {}\n                    _ => {\n                        return Err(Error::InvalidCharacter(off));\n                    }\n                }\n                off = self.off();\n            }\n            self.parse_unit(n, start, off)?;\n            n = match self.parse_first_char()? {\n                Some(n) => n,\n                None => return Ok(\n                    Duration::new(self.current.0, self.current.1 as u32)),\n            };\n        }\n    }\n\n}"],"wrapper::Duration":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl AsRef<StdDuration> for Duration {\n    fn as_ref(&self) -> &StdDuration { &self.0 }\n}","impl Deref for Duration {\n    type Target = StdDuration;\n    fn deref(&self) -> &StdDuration { &self.0 }\n}","impl From<StdDuration> for Duration {\n    fn from(dur: StdDuration) -> Duration { Duration(dur) }\n}","impl FromStr for Duration {\n    type Err = duration::Error;\n    fn from_str(s: &str) -> Result<Duration, Self::Err> {\n        parse_duration(s).map(Duration)\n    }\n}","impl Into<StdDuration> for Duration {\n    fn into(self) -> StdDuration { self.0 }\n}","impl fmt::Display for Duration {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        format_duration(self.0).fmt(f)\n    }\n}"],"wrapper::Timestamp":["Clone","Debug","Eq","PartialEq","impl AsRef<SystemTime> for Timestamp {\n    fn as_ref(&self) -> &SystemTime { &self.0 }\n}","impl Deref for Timestamp {\n    type Target = SystemTime;\n    fn deref(&self) -> &SystemTime { &self.0 }\n}","impl From<SystemTime> for Timestamp {\n    fn from(dur: SystemTime) -> Timestamp { Timestamp(dur) }\n}","impl FromStr for Timestamp {\n    type Err = date::Error;\n    fn from_str(s: &str) -> Result<Timestamp, Self::Err> {\n        parse_rfc3339_weak(s).map(Timestamp)\n    }\n}","impl Into<SystemTime> for Timestamp {\n    fn into(self) -> SystemTime { self.0 }\n}","impl fmt::Display for Timestamp {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        format_rfc3339(self.0).fmt(f)\n    }\n}"]},"single_path_import":{"date::Error":"Error","date::Rfc3339Timestamp":"Rfc3339Timestamp","date::format_rfc3339":"format_rfc3339","date::format_rfc3339_micros":"format_rfc3339_micros","date::format_rfc3339_millis":"format_rfc3339_millis","date::format_rfc3339_nanos":"format_rfc3339_nanos","date::format_rfc3339_seconds":"format_rfc3339_seconds","date::parse_rfc3339":"parse_rfc3339","date::parse_rfc3339_weak":"parse_rfc3339_weak","duration::Error":"Error","duration::FormattedDuration":"FormattedDuration","duration::format_duration":"format_duration","duration::parse_duration":"parse_duration","wrapper::Duration":"Duration","wrapper::Timestamp":"Timestamp"},"srcs":{"<date::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match self {\n            Error::OutOfRange => write!(f, \"numeric component is out of range\"),\n            Error::InvalidDigit => write!(f, \"bad character where digit is expected\"),\n            Error::InvalidFormat => write!(f, \"timestamp format is invalid\"),\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Rfc3339Timestamp as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use self::Precision::*;\n\n        let dur = self.0.duration_since(UNIX_EPOCH)\n            .expect(\"all times should be after the epoch\");\n        let secs_since_epoch = dur.as_secs();\n        let nanos = dur.subsec_nanos();\n\n        if secs_since_epoch >= 253_402_300_800 { // year 9999\n            return Err(fmt::Error);\n        }\n\n        /* 2000-03-01 (mod 400 year, immediately after feb29 */\n        const LEAPOCH: i64 = 11017;\n        const DAYS_PER_400Y: i64 = 365*400 + 97;\n        const DAYS_PER_100Y: i64 = 365*100 + 24;\n        const DAYS_PER_4Y: i64 = 365*4 + 1;\n\n        let days = (secs_since_epoch / 86400) as i64 - LEAPOCH;\n        let secs_of_day = secs_since_epoch % 86400;\n\n        let mut qc_cycles = days / DAYS_PER_400Y;\n        let mut remdays = days % DAYS_PER_400Y;\n\n        if remdays < 0 {\n            remdays += DAYS_PER_400Y;\n            qc_cycles -= 1;\n        }\n\n        let mut c_cycles = remdays / DAYS_PER_100Y;\n        if c_cycles == 4 { c_cycles -= 1; }\n        remdays -= c_cycles * DAYS_PER_100Y;\n\n        let mut q_cycles = remdays / DAYS_PER_4Y;\n        if q_cycles == 25 { q_cycles -= 1; }\n        remdays -= q_cycles * DAYS_PER_4Y;\n\n        let mut remyears = remdays / 365;\n        if remyears == 4 { remyears -= 1; }\n        remdays -= remyears * 365;\n\n        let mut year = 2000 +\n            remyears + 4*q_cycles + 100*c_cycles + 400*qc_cycles;\n\n        let months = [31,30,31,30,31,31,30,31,30,31,31,29];\n        let mut mon = 0;\n        for mon_len in months.iter() {\n            mon += 1;\n            if remdays < *mon_len {\n                break;\n            }\n            remdays -= *mon_len;\n        }\n        let mday = remdays+1;\n        let mon = if mon + 2 > 12 {\n            year += 1;\n            mon - 10\n        } else {\n            mon + 2\n        };\n\n        const BUF_INIT: [u8; 30] = *b\"0000-00-00T00:00:00.000000000Z\";\n\n        let mut buf: [u8; 30] = BUF_INIT;\n        buf[0] = b'0' + (year / 1000) as u8;\n        buf[1] = b'0' + (year / 100 % 10) as u8;\n        buf[2] = b'0' + (year / 10 % 10) as u8;\n        buf[3] = b'0' + (year % 10) as u8;\n        buf[5] = b'0' + (mon / 10) as u8;\n        buf[6] = b'0' + (mon % 10) as u8;\n        buf[8] = b'0' + (mday / 10) as u8;\n        buf[9] = b'0' + (mday % 10) as u8;\n        buf[11] = b'0' + (secs_of_day / 3600 / 10) as u8;\n        buf[12] = b'0' + (secs_of_day / 3600 % 10) as u8;\n        buf[14] = b'0' + (secs_of_day / 60 / 10 % 6) as u8;\n        buf[15] = b'0' + (secs_of_day / 60 % 10) as u8;\n        buf[17] = b'0' + (secs_of_day / 10 % 6) as u8;\n        buf[18] = b'0' + (secs_of_day % 10) as u8;\n\n        let offset = if self.1 == Seconds || nanos == 0 && self.1 == Smart {\n            buf[19] = b'Z';\n            19\n        } else if self.1 == Millis {\n            buf[20] = b'0' + (nanos / 100_000_000) as u8;\n            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;\n            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;\n            buf[23] = b'Z';\n            23\n        } else if self.1 == Micros {\n            buf[20] = b'0' + (nanos / 100_000_000) as u8;\n            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;\n            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;\n            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;\n            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;\n            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;\n            buf[26] = b'Z';\n            26\n        } else {\n            buf[20] = b'0' + (nanos / 100_000_000) as u8;\n            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;\n            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;\n            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;\n            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;\n            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;\n            buf[26] = b'0' + (nanos / 100 % 10) as u8;\n            buf[27] = b'0' + (nanos / 10 % 10) as u8;\n            buf[28] = b'0' + (nanos % 10) as u8;\n            // 29th is 'Z'\n            29\n        };\n\n        // we know our chars are all ascii\n        f.write_str(str::from_utf8(&buf[..=offset]).expect(\"Conversion to utf8 failed\"))\n    }","Real(LocalPath(\"src/date.rs\"))"],"<duration::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match self {\n            Error::InvalidCharacter(offset) => write!(f, \"invalid character at {}\", offset),\n            Error::NumberExpected(offset) => write!(f, \"expected number at {}\", offset),\n            Error::UnknownUnit { unit, value, .. } if unit.is_empty() => {\n                write!(f,\n                    \"time unit needed, for example {0}sec or {0}ms\",\n                    value,\n                )\n            }\n            Error::UnknownUnit { unit, .. } => {\n                write!(\n                    f,\n                    \"unknown time unit {:?}, \\\n                    supported units: ns, us, ms, sec, min, hours, days, \\\n                    weeks, months, years (and few variations)\",\n                    unit\n                )\n            }\n            Error::NumberOverflow => write!(f, \"number is too large\"),\n            Error::Empty => write!(f, \"value was empty\"),\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::FormattedDuration as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let secs = self.0.as_secs();\n        let nanos = self.0.subsec_nanos();\n\n        if secs == 0 && nanos == 0 {\n            f.write_str(\"0s\")?;\n            return Ok(());\n        }\n\n        let years = secs / 31_557_600;  // 365.25d\n        let ydays = secs % 31_557_600;\n        let months = ydays / 2_630_016;  // 30.44d\n        let mdays = ydays % 2_630_016;\n        let days = mdays / 86400;\n        let day_secs = mdays % 86400;\n        let hours = day_secs / 3600;\n        let minutes = day_secs % 3600 / 60;\n        let seconds = day_secs % 60;\n\n        let millis = nanos / 1_000_000;\n        let micros = nanos / 1000 % 1000;\n        let nanosec = nanos % 1000;\n\n        let started = &mut false;\n        item_plural(f, started, \"year\", years)?;\n        item_plural(f, started, \"month\", months)?;\n        item_plural(f, started, \"day\", days)?;\n        item(f, started, \"h\", hours as u32)?;\n        item(f, started, \"m\", minutes as u32)?;\n        item(f, started, \"s\", seconds as u32)?;\n        item(f, started, \"ms\", millis)?;\n        item(f, started, \"us\", micros)?;\n        item(f, started, \"ns\", nanosec)?;\n        Ok(())\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<u64 as duration::OverflowOp>::add":["fn add(self, other: Self) -> Result<Self, Error>{\n        self.checked_add(other).ok_or(Error::NumberOverflow)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<u64 as duration::OverflowOp>::mul":["fn mul(self, other: Self) -> Result<Self, Error>{\n        self.checked_mul(other).ok_or(Error::NumberOverflow)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<wrapper::Duration as std::convert::AsRef<std::time::Duration>>::as_ref":["fn as_ref(&self) -> &StdDuration{ &self.0 }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Duration as std::convert::From<std::time::Duration>>::from":["fn from(dur: StdDuration) -> Duration{ Duration(dur) }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Duration as std::convert::Into<std::time::Duration>>::into":["fn into(self) -> StdDuration{ self.0 }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Duration as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        format_duration(self.0).fmt(f)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Duration as std::ops::Deref>::deref":["fn deref(&self) -> &StdDuration{ &self.0 }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Duration as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Duration, Self::Err>{\n        parse_duration(s).map(Duration)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Timestamp as std::convert::AsRef<std::time::SystemTime>>::as_ref":["fn as_ref(&self) -> &SystemTime{ &self.0 }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Timestamp as std::convert::From<std::time::SystemTime>>::from":["fn from(dur: SystemTime) -> Timestamp{ Timestamp(dur) }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Timestamp as std::convert::Into<std::time::SystemTime>>::into":["fn into(self) -> SystemTime{ self.0 }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Timestamp as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        format_rfc3339(self.0).fmt(f)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Timestamp as std::ops::Deref>::deref":["fn deref(&self) -> &SystemTime{ &self.0 }","Real(LocalPath(\"src/wrapper.rs\"))"],"<wrapper::Timestamp as std::str::FromStr>::from_str":["fn from_str(s: &str) -> Result<Timestamp, Self::Err>{\n        parse_rfc3339_weak(s).map(Timestamp)\n    }","Real(LocalPath(\"src/wrapper.rs\"))"],"date::Error":["/// Error parsing datetime (timestamp)\npub enum Error {\n    /// Numeric component is out of range\n    OutOfRange,\n    /// Bad character where digit is expected\n    InvalidDigit,\n    /// Other formatting errors\n    InvalidFormat,\n}","Real(LocalPath(\"src/date.rs\"))"],"date::Precision":["enum Precision {\n    Smart,\n    Seconds,\n    Millis,\n    Micros,\n    Nanos,\n}","Real(LocalPath(\"src/date.rs\"))"],"date::Rfc3339Timestamp":["/// A wrapper type that allows you to Display a SystemTime\npub struct Rfc3339Timestamp(SystemTime, Precision);","Real(LocalPath(\"src/date.rs\"))"],"date::Rfc3339Timestamp::get_ref":["/// Returns a reference to the [`SystemTime`][] that is being formatted.\npub fn get_ref(&self) -> &SystemTime{\n        &self.0\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::format_rfc3339":["/// Format an RFC3339 timestamp `2018-02-14T00:28:07Z`\n///\n/// This function formats timestamp with smart precision: i.e. if it has no\n/// fractional seconds, they aren't written at all. And up to nine digits if\n/// they are.\n///\n/// The value is always UTC and ignores system timezone.\npub fn format_rfc3339(system_time: SystemTime) -> Rfc3339Timestamp{\n    Rfc3339Timestamp(system_time, Precision::Smart)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::format_rfc3339_micros":["/// Format an RFC3339 timestamp `2018-02-14T00:28:07.000000Z`\n///\n/// This format always shows microseconds even if microsecond value is zero.\n///\n/// The value is always UTC and ignores system timezone.\npub fn format_rfc3339_micros(system_time: SystemTime) -> Rfc3339Timestamp{\n    Rfc3339Timestamp(system_time, Precision::Micros)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::format_rfc3339_millis":["/// Format an RFC3339 timestamp `2018-02-14T00:28:07.000Z`\n///\n/// This format always shows milliseconds even if millisecond value is zero.\n///\n/// The value is always UTC and ignores system timezone.\npub fn format_rfc3339_millis(system_time: SystemTime) -> Rfc3339Timestamp{\n    Rfc3339Timestamp(system_time, Precision::Millis)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::format_rfc3339_nanos":["/// Format an RFC3339 timestamp `2018-02-14T00:28:07.000000000Z`\n///\n/// This format always shows nanoseconds even if nanosecond value is zero.\n///\n/// The value is always UTC and ignores system timezone.\npub fn format_rfc3339_nanos(system_time: SystemTime) -> Rfc3339Timestamp{\n    Rfc3339Timestamp(system_time, Precision::Nanos)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::format_rfc3339_seconds":["/// Format an RFC3339 timestamp `2018-02-14T00:28:07Z`\n///\n/// This format always shows timestamp without fractional seconds.\n///\n/// The value is always UTC and ignores system timezone.\npub fn format_rfc3339_seconds(system_time: SystemTime) -> Rfc3339Timestamp{\n    Rfc3339Timestamp(system_time, Precision::Seconds)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::is_leap_year":["fn is_leap_year(y: u64) -> bool{\n    y % 4 == 0 && (y % 100 != 0 || y % 400 == 0)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::parse_rfc3339":["/// Parse RFC3339 timestamp `2018-02-14T00:28:07Z`\n///\n/// Supported feature: any precision of fractional\n/// digits `2018-02-14T00:28:07.133Z`.\n///\n/// Unsupported feature: localized timestamps. Only UTC is supported.\npub fn parse_rfc3339(s: &str) -> Result<SystemTime, Error>{\n    if s.len() < \"2018-02-14T00:28:07Z\".len() {\n        return Err(Error::InvalidFormat);\n    }\n    let b = s.as_bytes();\n    if b[10] != b'T' || b.last() != Some(&b'Z') {\n        return Err(Error::InvalidFormat);\n    }\n    parse_rfc3339_weak(s)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::parse_rfc3339_weak":["/// Parse RFC3339-like timestamp `2018-02-14 00:28:07`\n///\n/// Supported features:\n///\n/// 1. Any precision of fractional digits `2018-02-14 00:28:07.133`.\n/// 2. Supports timestamp with or without either of `T` or `Z`\n/// 3. Anything valid for [`parse_rfc3339`](parse_rfc3339) is valid for this function\n///\n/// Unsupported feature: localized timestamps. Only UTC is supported, even if\n/// `Z` is not specified.\n///\n/// This function is intended to use for parsing human input. Whereas\n/// `parse_rfc3339` is for strings generated programmatically.\npub fn parse_rfc3339_weak(s: &str) -> Result<SystemTime, Error>{\n    if s.len() < \"2018-02-14T00:28:07\".len() {\n        return Err(Error::InvalidFormat);\n    }\n    let b = s.as_bytes();  // for careless slicing\n    if b[4] != b'-' || b[7] != b'-' || (b[10] != b'T' && b[10] != b' ') ||\n       b[13] != b':' || b[16] != b':'\n    {\n        return Err(Error::InvalidFormat);\n    }\n    let year = two_digits(b[0], b[1])? * 100 + two_digits(b[2], b[3])?;\n    let month = two_digits(b[5], b[6])?;\n    let day = two_digits(b[8], b[9])?;\n    let hour = two_digits(b[11], b[12])?;\n    let minute = two_digits(b[14], b[15])?;\n    let mut second = two_digits(b[17], b[18])?;\n\n    if year < 1970 || hour > 23 || minute > 59 || second > 60 {\n        return Err(Error::OutOfRange);\n    }\n    // TODO(tailhook) should we check that leaps second is only on midnight ?\n    if second == 60 {\n        second = 59;\n    }\n\n    let leap = is_leap_year(year);\n    let (mut ydays, mdays) = match month {\n        1 => (0, 31),\n        2 if leap => (31, 29),\n        2 => (31, 28),\n        3 => (59, 31),\n        4 => (90, 30),\n        5 => (120, 31),\n        6 => (151, 30),\n        7 => (181, 31),\n        8 => (212, 31),\n        9 => (243, 30),\n        10 => (273, 31),\n        11 => (304, 30),\n        12 => (334, 31),\n        _ => return Err(Error::OutOfRange),\n    };\n    if day > mdays || day == 0 {\n        return Err(Error::OutOfRange);\n    }\n    ydays += day - 1;\n    if leap && month > 2 {\n        ydays += 1;\n    }\n\n    let leap_years = ((year - 1) - 1968) / 4 - ((year - 1) - 1900) / 100 + ((year - 1) - 1600) / 400;\n    let days = (year - 1970) * 365 + leap_years + ydays;\n\n    let time = second + minute * 60 + hour * 3600;\n\n    let mut nanos = 0;\n    let mut mult = 100_000_000;\n    if b.get(19) == Some(&b'.') {\n        for idx in 20..b.len() {\n            if b[idx] == b'Z' {\n                if idx == b.len()-1 {\n                    break;\n                }\n\n                return Err(Error::InvalidDigit);\n            }\n\n            nanos += mult * (b[idx] as char).to_digit(10).ok_or(Error::InvalidDigit)?;\n            mult /= 10;\n        }\n    } else if b.len() != 19 && (b.len() > 20 || b[19] != b'Z') {\n        return Err(Error::InvalidFormat);\n    }\n\n    let total_seconds = time + days * 86400;\n    if total_seconds > max::SECONDS {\n        return Err(Error::OutOfRange);\n    }\n\n    Ok(UNIX_EPOCH + Duration::new(total_seconds, nanos))\n}","Real(LocalPath(\"src/date.rs\"))"],"date::two_digits":["#[inline]\n/// Converts two digits given in ASCII to its proper decimal representation.\nfn two_digits(b1: u8, b2: u8) -> Result<u64, Error>{\n    fn two_digits_inner(a: char, b: char) -> Option<u64> {\n        let a = a.to_digit(10)?;\n        let b = b.to_digit(10)?;\n\n        Some((a*10 + b) as u64)\n    }\n\n    two_digits_inner(b1 as char, b2 as char).ok_or(Error::InvalidDigit)\n}","Real(LocalPath(\"src/date.rs\"))"],"date::two_digits::two_digits_inner":["fn two_digits_inner(a: char, b: char) -> Option<u64>{\n        let a = a.to_digit(10)?;\n        let b = b.to_digit(10)?;\n\n        Some((a*10 + b) as u64)\n    }","Real(LocalPath(\"src/date.rs\"))"],"duration::Error":["/// Error parsing human-friendly duration\npub enum Error {\n    /// Invalid character during parsing\n    ///\n    /// More specifically anything that is not alphanumeric is prohibited\n    ///\n    /// The field is an byte offset of the character in the string.\n    InvalidCharacter(usize),\n    /// Non-numeric value where number is expected\n    ///\n    /// This usually means that either time unit is broken into words,\n    /// e.g. `m sec` instead of `msec`, or just number is omitted,\n    /// for example `2 hours min` instead of `2 hours 1 min`\n    ///\n    /// The field is an byte offset of the errorneous character\n    /// in the string.\n    NumberExpected(usize),\n    /// Unit in the number is not one of allowed units\n    ///\n    /// See documentation of `parse_duration` for the list of supported\n    /// time units.\n    ///\n    /// The two fields are start and end (exclusive) of the slice from\n    /// the original string, containing errorneous value\n    UnknownUnit {\n        /// Start of the invalid unit inside the original string\n        start: usize,\n        /// End of the invalid unit inside the original string\n        end: usize,\n        /// The unit verbatim\n        unit: String,\n        /// A number associated with the unit\n        value: u64,\n    },\n    /// The numeric value is too large\n    ///\n    /// Usually this means value is too large to be useful. If user writes\n    /// data in subsecond units, then the maximum is about 3k years. When\n    /// using seconds, or larger units, the limit is even larger.\n    NumberOverflow,\n    /// The value was an empty string (or consists only whitespace)\n    Empty,\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::FormattedDuration":["/// A wrapper type that allows you to Display a Duration\npub struct FormattedDuration(Duration);","Real(LocalPath(\"src/duration.rs\"))"],"duration::FormattedDuration::get_ref":["/// Returns a reference to the [`Duration`][] that is being formatted.\npub fn get_ref(&self) -> &Duration{\n        &self.0\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::OverflowOp":["trait OverflowOp: Sized {\n    fn mul(self, other: Self) -> Result<Self, Error>;\n    fn add(self, other: Self) -> Result<Self, Error>;\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::Parser":["struct Parser<'a> {\n    iter: Chars<'a>,\n    src: &'a str,\n    current: (u64, u64),\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::Parser::<'a>::off":["fn off(&self) -> usize{\n        self.src.len() - self.iter.as_str().len()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Parser::<'a>::parse":["fn parse(mut self) -> Result<Duration, Error>{\n        let mut n = self.parse_first_char()?.ok_or(Error::Empty)?;\n        'outer: loop {\n            let mut off = self.off();\n            while let Some(c) = self.iter.next() {\n                match c {\n                    '0'..='9' => {\n                        n = n.checked_mul(10)\n                            .and_then(|x| x.checked_add(c as u64 - '0' as u64))\n                            .ok_or(Error::NumberOverflow)?;\n                    }\n                    c if c.is_whitespace() => {}\n                    'a'..='z' | 'A'..='Z' => {\n                        break;\n                    }\n                    _ => {\n                        return Err(Error::InvalidCharacter(off));\n                    }\n                }\n                off = self.off();\n            }\n            let start = off;\n            let mut off = self.off();\n            while let Some(c) = self.iter.next() {\n                match c {\n                    '0'..='9' => {\n                        self.parse_unit(n, start, off)?;\n                        n = c as u64 - '0' as u64;\n                        continue 'outer;\n                    }\n                    c if c.is_whitespace() => break,\n                    'a'..='z' | 'A'..='Z' => {}\n                    _ => {\n                        return Err(Error::InvalidCharacter(off));\n                    }\n                }\n                off = self.off();\n            }\n            self.parse_unit(n, start, off)?;\n            n = match self.parse_first_char()? {\n                Some(n) => n,\n                None => return Ok(\n                    Duration::new(self.current.0, self.current.1 as u32)),\n            };\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Parser::<'a>::parse_first_char":["fn parse_first_char(&mut self) -> Result<Option<u64>, Error>{\n        let off = self.off();\n        for c in self.iter.by_ref() {\n            match c {\n                '0'..='9' => {\n                    return Ok(Some(c as u64 - '0' as u64));\n                }\n                c if c.is_whitespace() => continue,\n                _ => {\n                    return Err(Error::NumberExpected(off));\n                }\n            }\n        }\n        Ok(None)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Parser::<'a>::parse_unit":["fn parse_unit(&mut self, n: u64, start: usize, end: usize)\n        -> Result<(), Error>{\n        let (mut sec, nsec) = match &self.src[start..end] {\n            \"nanos\" | \"nsec\" | \"ns\" => (0u64, n),\n            \"usec\" | \"us\" => (0u64, n.mul(1000)?),\n            \"millis\" | \"msec\" | \"ms\" => (0u64, n.mul(1_000_000)?),\n            \"seconds\" | \"second\" | \"secs\" | \"sec\" | \"s\" => (n, 0),\n            \"minutes\" | \"minute\" | \"min\" | \"mins\" | \"m\"\n            => (n.mul(60)?, 0),\n            \"hours\" | \"hour\" | \"hr\" | \"hrs\" | \"h\" => (n.mul(3600)?, 0),\n            \"days\" | \"day\" | \"d\" => (n.mul(86400)?, 0),\n            \"weeks\" | \"week\" | \"w\" => (n.mul(86400*7)?, 0),\n            \"months\" | \"month\" | \"M\" => (n.mul(2_630_016)?, 0), // 30.44d\n            \"years\" | \"year\" | \"y\" => (n.mul(31_557_600)?, 0), // 365.25d\n            _ => {\n                return Err(Error::UnknownUnit {\n                    start, end,\n                    unit: self.src[start..end].to_string(),\n                    value: n,\n                });\n            }\n        };\n        let mut nsec = self.current.1.add(nsec)?;\n        if nsec > 1_000_000_000 {\n            sec = sec.add(nsec / 1_000_000_000)?;\n            nsec %= 1_000_000_000;\n        }\n        sec = self.current.0.add(sec)?;\n        self.current = (sec, nsec);\n        Ok(())\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::format_duration":["/// Formats duration into a human-readable string\n///\n/// Note: this format is guaranteed to have same value when using\n/// parse_duration, but we can change some details of the exact composition\n/// of the value.\n///\n/// # Examples\n///\n/// ```\n/// use std::time::Duration;\n/// use humantime::format_duration;\n///\n/// let val1 = Duration::new(9420, 0);\n/// assert_eq!(format_duration(val1).to_string(), \"2h 37m\");\n/// let val2 = Duration::new(0, 32_000_000);\n/// assert_eq!(format_duration(val2).to_string(), \"32ms\");\n/// ```\npub fn format_duration(val: Duration) -> FormattedDuration{\n    FormattedDuration(val)\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::item":["fn item(f: &mut fmt::Formatter, started: &mut bool, name: &str, value: u32)\n    -> fmt::Result{\n    if value > 0 {\n        if *started {\n            f.write_str(\" \")?;\n        }\n        write!(f, \"{}{}\", value, name)?;\n        *started = true;\n    }\n    Ok(())\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::item_plural":["fn item_plural(f: &mut fmt::Formatter, started: &mut bool,\n    name: &str, value: u64)\n    -> fmt::Result{\n    if value > 0 {\n        if *started {\n            f.write_str(\" \")?;\n        }\n        write!(f, \"{}{}\", value, name)?;\n        if value > 1 {\n            f.write_str(\"s\")?;\n        }\n        *started = true;\n    }\n    Ok(())\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::parse_duration":["/// Parse duration object `1hour 12min 5s`\n///\n/// The duration object is a concatenation of time spans. Where each time\n/// span is an integer number and a suffix. Supported suffixes:\n///\n/// * `nsec`, `ns` -- nanoseconds\n/// * `usec`, `us` -- microseconds\n/// * `msec`, `ms` -- milliseconds\n/// * `seconds`, `second`, `sec`, `s`\n/// * `minutes`, `minute`, `min`, `m`\n/// * `hours`, `hour`, `hr`, `h`\n/// * `days`, `day`, `d`\n/// * `weeks`, `week`, `w`\n/// * `months`, `month`, `M` -- defined as 30.44 days\n/// * `years`, `year`, `y` -- defined as 365.25 days\n///\n/// # Examples\n///\n/// ```\n/// use std::time::Duration;\n/// use humantime::parse_duration;\n///\n/// assert_eq!(parse_duration(\"2h 37min\"), Ok(Duration::new(9420, 0)));\n/// assert_eq!(parse_duration(\"32ms\"), Ok(Duration::new(0, 32_000_000)));\n/// ```\npub fn parse_duration(s: &str) -> Result<Duration, Error>{\n    Parser {\n        iter: s.chars(),\n        src: s,\n        current: (0, 0),\n    }.parse()\n}","Real(LocalPath(\"src/duration.rs\"))"],"wrapper::Duration":["/// A wrapper for duration that has `FromStr` implementation\n///\n/// This is useful if you want to use it somewhere where `FromStr` is\n/// expected.\n///\n/// See `parse_duration` for the description of the format.\n///\n/// # Example\n///\n/// ```\n/// use std::time::Duration;\n/// let x: Duration;\n/// x = \"12h 5min 2ns\".parse::<humantime::Duration>().unwrap().into();\n/// assert_eq!(x, Duration::new(12*3600 + 5*60, 2))\n/// ```\n///\npub struct Duration(StdDuration);","Real(LocalPath(\"src/wrapper.rs\"))"],"wrapper::Timestamp":["/// A wrapper for SystemTime that has `FromStr` implementation\n///\n/// This is useful if you want to use it somewhere where `FromStr` is\n/// expected.\n///\n/// See `parse_rfc3339_weak` for the description of the format. The \"weak\"\n/// format is used as it's more pemissive for human input as this is the\n/// expected use of the type (e.g. command-line parsing).\n///\n/// # Example\n///\n/// ```\n/// use std::time::SystemTime;\n/// let x: SystemTime;\n/// x = \"2018-02-16T00:31:37Z\".parse::<humantime::Timestamp>().unwrap().into();\n/// assert_eq!(humantime::format_rfc3339(x).to_string(), \"2018-02-16T00:31:37Z\");\n/// ```\n///\npub struct Timestamp(SystemTime);","Real(LocalPath(\"src/wrapper.rs\"))"]},"struct_constructor":{"&std::time::Duration":["as_ref","deref","get_ref"],"&std::time::SystemTime":["as_ref","deref","get_ref"],"bool":["eq","is_leap_year"],"date::Error":["clone"],"date::Precision":["clone"],"date::Rfc3339Timestamp":["clone","format_rfc3339","format_rfc3339_micros","format_rfc3339_millis","format_rfc3339_nanos","format_rfc3339_seconds"],"duration::Error":["clone"],"duration::FormattedDuration":["clone","format_duration"],"std::time::Duration":["into","parse","parse_duration"],"std::time::SystemTime":["into","parse_rfc3339","parse_rfc3339_weak"],"u64":["parse_first_char","two_digits","two_digits_inner"],"usize":["off"],"wrapper::Duration":["clone","from","from_str"],"wrapper::Timestamp":["clone","from","from_str"]},"struct_to_trait":{"date::Error":["std::clone::Clone","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralPartialEq"],"date::Precision":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"date::Rfc3339Timestamp":["std::clone::Clone","std::fmt::Debug","std::fmt::Display"],"duration::Error":["std::clone::Clone","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralPartialEq"],"duration::FormattedDuration":["std::clone::Clone","std::fmt::Debug","std::fmt::Display"],"wrapper::Duration":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::AsRef","std::convert::From","std::convert::Into","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref","std::str::FromStr"],"wrapper::Timestamp":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::AsRef","std::convert::From","std::convert::Into","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Deref","std::str::FromStr"]},"targets":{"<date::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/date.rs\"))","std::fmt::Display"],"<date::Rfc3339Timestamp as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/date.rs\"))","std::fmt::Display"],"<duration::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/duration.rs\"))","std::fmt::Display"],"<duration::FormattedDuration as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/duration.rs\"))","std::fmt::Display"],"<u64 as duration::OverflowOp>::add":["add","Real(LocalPath(\"src/duration.rs\"))","duration::OverflowOp"],"<u64 as duration::OverflowOp>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","duration::OverflowOp"],"<wrapper::Duration as std::convert::AsRef<std::time::Duration>>::as_ref":["as_ref","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::AsRef"],"<wrapper::Duration as std::convert::From<std::time::Duration>>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"<wrapper::Duration as std::convert::Into<std::time::Duration>>::into":["into","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::Into"],"<wrapper::Duration as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Display"],"<wrapper::Duration as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/wrapper.rs\"))","std::ops::Deref"],"<wrapper::Duration as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/wrapper.rs\"))","std::str::FromStr"],"<wrapper::Timestamp as std::convert::AsRef<std::time::SystemTime>>::as_ref":["as_ref","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::AsRef"],"<wrapper::Timestamp as std::convert::From<std::time::SystemTime>>::from":["from","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::From"],"<wrapper::Timestamp as std::convert::Into<std::time::SystemTime>>::into":["into","Real(LocalPath(\"src/wrapper.rs\"))","std::convert::Into"],"<wrapper::Timestamp as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/wrapper.rs\"))","std::fmt::Display"],"<wrapper::Timestamp as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/wrapper.rs\"))","std::ops::Deref"],"<wrapper::Timestamp as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/wrapper.rs\"))","std::str::FromStr"],"date::Rfc3339Timestamp::get_ref":["get_ref","Real(LocalPath(\"src/date.rs\"))",""],"date::format_rfc3339":["format_rfc3339","Real(LocalPath(\"src/date.rs\"))",""],"date::format_rfc3339_micros":["format_rfc3339_micros","Real(LocalPath(\"src/date.rs\"))",""],"date::format_rfc3339_millis":["format_rfc3339_millis","Real(LocalPath(\"src/date.rs\"))",""],"date::format_rfc3339_nanos":["format_rfc3339_nanos","Real(LocalPath(\"src/date.rs\"))",""],"date::format_rfc3339_seconds":["format_rfc3339_seconds","Real(LocalPath(\"src/date.rs\"))",""],"date::is_leap_year":["is_leap_year","Real(LocalPath(\"src/date.rs\"))",""],"date::parse_rfc3339":["parse_rfc3339","Real(LocalPath(\"src/date.rs\"))",""],"date::parse_rfc3339_weak":["parse_rfc3339_weak","Real(LocalPath(\"src/date.rs\"))",""],"date::two_digits":["two_digits","Real(LocalPath(\"src/date.rs\"))",""],"date::two_digits::two_digits_inner":["two_digits_inner","Real(LocalPath(\"src/date.rs\"))",""],"duration::FormattedDuration::get_ref":["get_ref","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Parser::<'a>::off":["off","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Parser::<'a>::parse":["parse","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Parser::<'a>::parse_first_char":["parse_first_char","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Parser::<'a>::parse_unit":["parse_unit","Real(LocalPath(\"src/duration.rs\"))",""],"duration::format_duration":["format_duration","Real(LocalPath(\"src/duration.rs\"))",""],"duration::item":["item","Real(LocalPath(\"src/duration.rs\"))",""],"duration::item_plural":["item_plural","Real(LocalPath(\"src/duration.rs\"))",""],"duration::parse_duration":["parse_duration","Real(LocalPath(\"src/duration.rs\"))",""]},"trait_to_struct":{"std::clone::Clone":["date::Error","date::Precision","date::Rfc3339Timestamp","duration::Error","duration::FormattedDuration","wrapper::Duration","wrapper::Timestamp"],"std::cmp::Eq":["date::Precision","wrapper::Duration","wrapper::Timestamp"],"std::cmp::PartialEq":["date::Error","date::Precision","duration::Error","wrapper::Duration","wrapper::Timestamp"],"std::convert::AsRef":["wrapper::Duration","wrapper::Timestamp"],"std::convert::From":["wrapper::Duration","wrapper::Timestamp"],"std::convert::Into":["wrapper::Duration","wrapper::Timestamp"],"std::error::Error":["date::Error","duration::Error"],"std::fmt::Debug":["date::Error","date::Precision","date::Rfc3339Timestamp","duration::Error","duration::FormattedDuration","wrapper::Duration","wrapper::Timestamp"],"std::fmt::Display":["date::Error","date::Rfc3339Timestamp","duration::Error","duration::FormattedDuration","wrapper::Duration","wrapper::Timestamp"],"std::hash::Hash":["wrapper::Duration"],"std::marker::Copy":["date::Error","wrapper::Duration"],"std::marker::StructuralEq":["date::Precision","wrapper::Duration","wrapper::Timestamp"],"std::marker::StructuralPartialEq":["date::Error","date::Precision","duration::Error","wrapper::Duration","wrapper::Timestamp"],"std::ops::Deref":["wrapper::Duration","wrapper::Timestamp"],"std::str::FromStr":["wrapper::Duration","wrapper::Timestamp"]},"type_to_def_path":{"date::Error":"date::Error","date::Precision":"date::Precision","date::Rfc3339Timestamp":"date::Rfc3339Timestamp","duration::Error":"duration::Error","duration::FormattedDuration":"duration::FormattedDuration","duration::Parser<'a>":"duration::Parser","wrapper::Duration":"wrapper::Duration","wrapper::Timestamp":"wrapper::Timestamp"}}