{
    "dependencies": {
        "<&'a [u8] as reader::XmlSource<'a, ()>>::peek_one": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::read_bang_element": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::read_bytes_until": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::read_element": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::skip_one": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::skip_whitespace": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::peek_one": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::read_bang_element": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::read_bytes_until": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::read_element": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::skip_one": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::skip_whitespace": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<errors::Error as std::convert::From<escapei::EscapeError>>::from": [
            "errors::Error",
            "escapei::EscapeError",
            "events::attributes::AttrError",
            "std::io::Error",
            "std::marker::Sized",
            "std::ops::Range",
            "std::option::Option",
            "std::result::Result",
            "std::str::Utf8Error",
            "std::string::String"
        ],
        "<errors::Error as std::convert::From<events::attributes::AttrError>>::from": [
            "errors::Error",
            "escapei::EscapeError",
            "events::attributes::AttrError",
            "std::io::Error",
            "std::marker::Sized",
            "std::ops::Range",
            "std::option::Option",
            "std::result::Result",
            "std::str::Utf8Error",
            "std::string::String"
        ],
        "<errors::Error as std::convert::From<std::io::Error>>::from": [
            "errors::Error",
            "escapei::EscapeError",
            "events::attributes::AttrError",
            "std::io::Error",
            "std::marker::Sized",
            "std::ops::Range",
            "std::option::Option",
            "std::result::Result",
            "std::str::Utf8Error",
            "std::string::String"
        ],
        "<errors::Error as std::convert::From<std::str::Utf8Error>>::from": [
            "errors::Error",
            "escapei::EscapeError",
            "events::attributes::AttrError",
            "std::io::Error",
            "std::marker::Sized",
            "std::ops::Range",
            "std::option::Option",
            "std::result::Result",
            "std::str::Utf8Error",
            "std::string::String"
        ],
        "<errors::Error as std::error::Error>::source": [
            "errors::Error",
            "escapei::EscapeError",
            "events::attributes::AttrError",
            "std::io::Error",
            "std::marker::Sized",
            "std::ops::Range",
            "std::option::Option",
            "std::result::Result",
            "std::str::Utf8Error",
            "std::string::String"
        ],
        "<errors::Error as std::fmt::Debug>::fmt": [
            "errors::Error",
            "escapei::EscapeError",
            "events::attributes::AttrError",
            "std::fmt::Formatter",
            "std::io::Error",
            "std::marker::Sized",
            "std::ops::Range",
            "std::option::Option",
            "std::result::Result",
            "std::str::Utf8Error",
            "std::string::String"
        ],
        "<errors::Error as std::fmt::Display>::fmt": [
            "errors::Error",
            "escapei::EscapeError",
            "events::attributes::AttrError",
            "std::fmt::Formatter",
            "std::io::Error",
            "std::marker::Sized",
            "std::ops::Range",
            "std::option::Option",
            "std::result::Result",
            "std::str::Utf8Error",
            "std::string::String"
        ],
        "<escapei::EscapeError as std::fmt::Debug>::fmt": [
            "escapei::EscapeError",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::ops::Range",
            "std::result::Result"
        ],
        "<escapei::EscapeError as std::fmt::Display>::fmt": [
            "escapei::EscapeError",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::ops::Range",
            "std::result::Result"
        ],
        "<events::BytesCData<'a> as std::clone::Clone>::clone": [
            "events::BytesCData",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesCData<'a> as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "events::BytesCData",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesCData<'a> as std::cmp::PartialEq>::eq": [
            "events::BytesCData",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesCData<'a> as std::fmt::Debug>::fmt": [
            "events::BytesCData",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<events::BytesCData<'a> as std::ops::Deref>::deref": [
            "events::BytesCData",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesDecl<'a> as std::clone::Clone>::clone": [
            "events::BytesDecl",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesDecl<'a> as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "events::BytesDecl",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesDecl<'a> as std::cmp::PartialEq>::eq": [
            "events::BytesDecl",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesDecl<'a> as std::fmt::Debug>::fmt": [
            "events::BytesDecl",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<events::BytesDecl<'a> as std::ops::Deref>::deref": [
            "events::BytesDecl",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesEnd<'a> as std::clone::Clone>::clone": [
            "events::BytesEnd",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesEnd<'a> as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "events::BytesEnd",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesEnd<'a> as std::cmp::PartialEq>::eq": [
            "events::BytesEnd",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesEnd<'a> as std::fmt::Debug>::fmt": [
            "events::BytesEnd",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<events::BytesEnd<'a> as std::ops::Deref>::deref": [
            "events::BytesEnd",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesStart<'a> as std::clone::Clone>::clone": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesStart<'a> as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesStart<'a> as std::cmp::PartialEq>::eq": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesStart<'a> as std::fmt::Debug>::fmt": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<events::BytesStart<'a> as std::ops::Deref>::deref": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesText<'a> as std::clone::Clone>::clone": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesText<'a> as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesText<'a> as std::cmp::PartialEq>::eq": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::BytesText<'a> as std::fmt::Debug>::fmt": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<events::BytesText<'a> as std::ops::Deref>::deref": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::Event<'a> as std::clone::Clone>::clone": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::Event<'a> as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::Event<'a> as std::cmp::PartialEq>::eq": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::Event<'a> as std::convert::AsRef<events::Event<'a>>>::as_ref": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::Event<'a> as std::fmt::Debug>::fmt": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<events::Event<'a> as std::ops::Deref>::deref": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::attributes::Attr<T> as std::clone::Clone>::clone": [
            "events::attributes::Attr",
            "std::marker::Sized"
        ],
        "<events::attributes::Attr<T> as std::cmp::Eq>::assert_receiver_is_total_eq": [
            "events::attributes::Attr",
            "std::marker::Sized"
        ],
        "<events::attributes::Attr<T> as std::cmp::Ord>::cmp": [
            "events::attributes::Attr",
            "std::cmp::Ordering",
            "std::marker::Sized"
        ],
        "<events::attributes::Attr<T> as std::cmp::PartialEq>::eq": [
            "events::attributes::Attr",
            "std::marker::Sized"
        ],
        "<events::attributes::Attr<T> as std::cmp::PartialOrd>::partial_cmp": [
            "events::attributes::Attr",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "<events::attributes::Attr<T> as std::fmt::Debug>::fmt": [
            "events::attributes::Attr",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<events::attributes::Attr<T> as std::hash::Hash>::hash": [
            "events::attributes::Attr",
            "std::hash::Hasher",
            "std::marker::Sized"
        ],
        "<events::attributes::AttrError as std::cmp::PartialEq>::eq": [
            "events::attributes::AttrError"
        ],
        "<events::attributes::AttrError as std::fmt::Debug>::fmt": [
            "events::attributes::AttrError",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<events::attributes::AttrError as std::fmt::Display>::fmt": [
            "events::attributes::AttrError",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<events::attributes::Attribute<'a> as std::clone::Clone>::clone": [
            "events::attributes::Attribute",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::attributes::Attribute<'a> as std::cmp::PartialEq>::eq": [
            "events::attributes::Attribute",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::attributes::Attribute<'a> as std::convert::From<(&'a [u8], &'a [u8])>>::from": [
            "events::attributes::Attribute",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::attributes::Attribute<'a> as std::convert::From<(&'a str, &'a str)>>::from": [
            "events::attributes::Attribute",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "<events::attributes::Attribute<'a> as std::convert::From<events::attributes::Attr<&'a [u8]>>>::from": [
            "events::attributes::Attr",
            "events::attributes::Attribute",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized"
        ],
        "<events::attributes::Attribute<'a> as std::fmt::Debug>::fmt": [
            "events::attributes::Attribute",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<events::attributes::Attributes<'a> as std::clone::Clone>::clone": [
            "events::attributes::Attributes",
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "<events::attributes::Attributes<'a> as std::fmt::Debug>::fmt": [
            "events::attributes::Attributes",
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<events::attributes::Attributes<'a> as std::iter::Iterator>::next": [
            "events::attributes::Attributes",
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "<events::attributes::IterState as std::clone::Clone>::clone": [
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "<events::attributes::IterState as std::fmt::Debug>::fmt": [
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<events::attributes::State as std::clone::Clone>::clone": [
            "events::attributes::State"
        ],
        "<events::attributes::State as std::fmt::Debug>::fmt": [
            "events::attributes::State",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<reader::BangType as std::cmp::PartialEq>::eq": [
            "reader::BangType"
        ],
        "<reader::BangType as std::fmt::Debug>::fmt": [
            "reader::BangType",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<reader::Decoder as std::clone::Clone>::clone": [
            "reader::Decoder"
        ],
        "<reader::Decoder as std::fmt::Debug>::fmt": [
            "reader::Decoder",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<reader::NamespaceEntry as std::clone::Clone>::clone": [
            "reader::NamespaceEntry"
        ],
        "<reader::NamespaceEntry as std::fmt::Debug>::fmt": [
            "reader::NamespaceEntry",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "<reader::NamespaceResolver as std::clone::Clone>::clone": [
            "reader::NamespaceResolver",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "<reader::NamespaceResolver as std::default::Default>::default": [
            "reader::NamespaceResolver",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "<reader::NamespaceResolver as std::fmt::Debug>::fmt": [
            "reader::NamespaceResolver",
            "std::alloc::Allocator",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "<reader::ReadElementState as std::clone::Clone>::clone": [
            "reader::ReadElementState"
        ],
        "<reader::Reader<R> as std::clone::Clone>::clone": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "<reader::TagState as std::clone::Clone>::clone": [
            "reader::TagState"
        ],
        "<utils::ByteBuf as std::cmp::PartialEq>::eq": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec",
            "utils::ByteBuf"
        ],
        "<utils::ByteBuf as std::fmt::Debug>::fmt": [
            "std::alloc::Allocator",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec",
            "utils::ByteBuf"
        ],
        "<utils::Bytes<'de> as std::cmp::PartialEq>::eq": [
            "utils::Bytes"
        ],
        "<utils::Bytes<'de> as std::fmt::Debug>::fmt": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result",
            "utils::Bytes"
        ],
        "<writer::Indentation as std::clone::Clone>::clone": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec",
            "writer::Indentation"
        ],
        "<writer::Writer<W> as std::clone::Clone>::clone": [
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "writer::Writer"
        ],
        "errors::Error": [
            "errors::Error",
            "escapei::EscapeError",
            "events::attributes::AttrError",
            "std::io::Error",
            "std::marker::Sized",
            "std::ops::Range",
            "std::option::Option",
            "std::result::Result",
            "std::str::Utf8Error",
            "std::string::String"
        ],
        "escapei::EscapeError": [
            "escapei::EscapeError",
            "std::marker::Sized",
            "std::ops::Range",
            "std::result::Result"
        ],
        "escapei::_escape": [
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::ops::Fn"
        ],
        "escapei::do_unescape": [
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "escapei::escape": [
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "escapei::escape::to_escape": [],
        "escapei::named_entity": [
            "std::marker::Sized",
            "std::option::Option"
        ],
        "escapei::parse_decimal": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "escapei::parse_hexadecimal": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "escapei::parse_number": [
            "std::marker::Sized",
            "std::ops::Range",
            "std::result::Result"
        ],
        "escapei::partial_escape": [
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "escapei::partial_escape::to_escape": [],
        "escapei::push_utf8": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "escapei::unescape": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "escapei::unescape_with": [
            "std::collections::HashMap",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "events::BytesCData": [
            "events::BytesCData",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesCData::<'a>::escape": [
            "events::BytesCData",
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesCData::<'a>::from_str": [
            "events::BytesCData",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesCData::<'a>::into_inner": [
            "events::BytesCData",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesCData::<'a>::into_owned": [
            "events::BytesCData",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesCData::<'a>::new": [
            "events::BytesCData",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::Into",
            "std::marker::Sized"
        ],
        "events::BytesCData::<'a>::partial_escape": [
            "events::BytesCData",
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesDecl": [
            "events::BytesDecl",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesDecl::<'a>::encoding": [
            "events::BytesDecl",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "events::BytesDecl::<'a>::from_start": [
            "events::BytesDecl",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesDecl::<'a>::into_owned": [
            "events::BytesDecl",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesDecl::<'a>::new": [
            "events::BytesDecl",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "events::BytesDecl::<'a>::standalone": [
            "events::BytesDecl",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "events::BytesDecl::<'a>::version": [
            "events::BytesDecl",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "events::BytesEnd": [
            "events::BytesEnd",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesEnd::<'a>::borrowed": [
            "events::BytesEnd",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesEnd::<'a>::into_owned": [
            "events::BytesEnd",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesEnd::<'a>::local_name": [
            "events::BytesEnd",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesEnd::<'a>::name": [
            "events::BytesEnd",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesEnd::<'a>::owned": [
            "events::BytesEnd",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "events::BytesStart": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesStart::<'a>::attributes": [
            "events::BytesStart",
            "events::attributes::Attributes",
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "events::BytesStart::<'a>::attributes_raw": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesStart::<'a>::borrowed": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesStart::<'a>::borrowed_name": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesStart::<'a>::clear_attributes": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesStart::<'a>::do_unescape_and_decode_with_custom_entities": [
            "events::BytesStart",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::BytesStart::<'a>::extend_attributes": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::Into",
            "std::iter::IntoIterator",
            "std::marker::Sized"
        ],
        "events::BytesStart::<'a>::html_attributes": [
            "events::BytesStart",
            "events::attributes::Attributes",
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "events::BytesStart::<'a>::into_owned": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesStart::<'a>::local_name": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesStart::<'a>::make_unescaped": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "events::BytesStart::<'a>::name": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesStart::<'a>::owned": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::Into",
            "std::marker::Sized"
        ],
        "events::BytesStart::<'a>::owned_name": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::Into",
            "std::marker::Sized"
        ],
        "events::BytesStart::<'a>::push_attribute": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::Into",
            "std::marker::Sized"
        ],
        "events::BytesStart::<'a>::set_name": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesStart::<'a>::to_borrowed": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesStart::<'a>::to_end": [
            "events::BytesEnd",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesStart::<'a>::to_owned": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesStart::<'a>::try_get_attribute": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::AsRef",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "events::BytesStart::<'a>::unescape_and_decode": [
            "events::BytesStart",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::BytesStart::<'a>::unescape_and_decode_with_custom_entities": [
            "events::BytesStart",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::collections::HashMap",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::BytesStart::<'a>::unescaped": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "events::BytesStart::<'a>::unescaped_with_custom_entities": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::collections::HashMap",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "events::BytesStart::<'a>::with_attributes": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::Into",
            "std::iter::IntoIterator",
            "std::marker::Sized"
        ],
        "events::BytesText": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesText::<'a>::do_unescape_and_decode_with_custom_entities": [
            "events::BytesText",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::BytesText::<'a>::do_unescape_and_decode_without_bom": [
            "events::BytesText",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::BytesText::<'a>::escaped": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesText::<'a>::from_escaped": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::Into",
            "std::marker::Sized"
        ],
        "events::BytesText::<'a>::from_escaped_str": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::Into",
            "std::marker::Sized"
        ],
        "events::BytesText::<'a>::from_plain": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesText::<'a>::from_plain_str": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesText::<'a>::into_inner": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesText::<'a>::into_owned": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::BytesText::<'a>::make_unescaped": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "events::BytesText::<'a>::unescape_and_decode": [
            "events::BytesText",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::BytesText::<'a>::unescape_and_decode_with_custom_entities": [
            "events::BytesText",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::collections::HashMap",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::BytesText::<'a>::unescape_and_decode_without_bom": [
            "events::BytesText",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::BytesText::<'a>::unescape_and_decode_without_bom_with_custom_entities": [
            "events::BytesText",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::collections::HashMap",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::BytesText::<'a>::unescaped": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "events::BytesText::<'a>::unescaped_with_custom_entities": [
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::collections::HashMap",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "events::Event": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::Event::<'a>::into_owned": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::attributes::<impl std::convert::From<events::attributes::Attr<T>> for (T, std::option::Option<T>)>::from": [
            "events::attributes::Attr",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "events::attributes::Attr": [
            "events::attributes::Attr",
            "std::marker::Sized"
        ],
        "events::attributes::Attr::<&'a [u8]>::key": [
            "events::attributes::Attr",
            "std::marker::Sized"
        ],
        "events::attributes::Attr::<&'a [u8]>::value": [
            "events::attributes::Attr",
            "std::marker::Sized"
        ],
        "events::attributes::Attr::<T>::map": [
            "events::attributes::Attr",
            "std::marker::Sized",
            "std::ops::FnMut"
        ],
        "events::attributes::AttrError": [
            "events::attributes::AttrError"
        ],
        "events::attributes::Attribute": [
            "events::attributes::Attribute",
            "std::borrow::Cow",
            "std::borrow::ToOwned"
        ],
        "events::attributes::Attribute::<'a>::do_unescape_and_decode_value": [
            "events::attributes::Attribute",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::attributes::Attribute::<'a>::do_unescape_and_decode_without_bom": [
            "events::attributes::Attribute",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::attributes::Attribute::<'a>::make_unescaped_value": [
            "events::attributes::Attribute",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "events::attributes::Attribute::<'a>::unescape_and_decode_value": [
            "events::attributes::Attribute",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::attributes::Attribute::<'a>::unescape_and_decode_value_with_custom_entities": [
            "events::attributes::Attribute",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::collections::HashMap",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::attributes::Attribute::<'a>::unescape_and_decode_without_bom": [
            "events::attributes::Attribute",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::attributes::Attribute::<'a>::unescape_and_decode_without_bom_with_custom_entities": [
            "events::attributes::Attribute",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::collections::HashMap",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::attributes::Attribute::<'a>::unescaped_value": [
            "events::attributes::Attribute",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "events::attributes::Attribute::<'a>::unescaped_value_with_custom_entities": [
            "events::attributes::Attribute",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::collections::HashMap",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "events::attributes::Attributes": [
            "events::attributes::Attributes",
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "events::attributes::Attributes::<'a>::html": [
            "events::attributes::Attributes",
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "events::attributes::Attributes::<'a>::new": [
            "events::attributes::Attributes",
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "events::attributes::Attributes::<'a>::with_checks": [
            "events::attributes::Attributes",
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "events::attributes::IterState": [
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "events::attributes::IterState::check_for_duplicates": [
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::ops::Range",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "events::attributes::IterState::double_q": [
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::ops::Range",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "events::attributes::IterState::key_only": [
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::ops::Range",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "events::attributes::IterState::new": [
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "events::attributes::IterState::next": [
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "events::attributes::IterState::recover": [
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "events::attributes::IterState::single_q": [
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::ops::Range",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "events::attributes::IterState::skip_eq_value": [
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "events::attributes::IterState::skip_value": [
            "events::attributes::IterState",
            "events::attributes::State",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "events::attributes::State": [
            "events::attributes::State"
        ],
        "reader::BangType": [
            "reader::BangType"
        ],
        "reader::BangType::new": [
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result"
        ],
        "reader::BangType::parse": [
            "reader::BangType",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "reader::BangType::to_err": [
            "errors::Error",
            "escapei::EscapeError",
            "events::attributes::AttrError",
            "reader::BangType",
            "std::io::Error",
            "std::marker::Sized",
            "std::ops::Range",
            "std::option::Option",
            "std::result::Result",
            "std::str::Utf8Error",
            "std::string::String"
        ],
        "reader::Decoder": [
            "reader::Decoder"
        ],
        "reader::Decoder::decode": [
            "reader::Decoder",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "reader::Decoder::decode_owned": [
            "reader::Decoder",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::NamespaceEntry": [
            "reader::NamespaceEntry"
        ],
        "reader::NamespaceEntry::is_match": [
            "reader::NamespaceEntry"
        ],
        "reader::NamespaceEntry::namespace": [
            "reader::NamespaceEntry",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "reader::NamespaceResolver": [
            "reader::NamespaceResolver",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::NamespaceResolver::find": [
            "reader::NamespaceResolver",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "reader::NamespaceResolver::pop": [
            "reader::NamespaceResolver",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::NamespaceResolver::push": [
            "events::BytesStart",
            "reader::NamespaceResolver",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::NamespaceResolver::resolve": [
            "reader::NamespaceResolver",
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "reader::ReadElementState": [
            "reader::ReadElementState"
        ],
        "reader::ReadElementState::change": [
            "reader::ReadElementState",
            "std::marker::Sized",
            "std::option::Option"
        ],
        "reader::Reader": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<&'a [u8]>::from_bytes": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<&'a [u8]>::from_str": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<&'a [u8]>::read_event_unbuffered": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<&'a [u8]>::read_to_end_unbuffered": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::AsRef",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::attribute_namespace": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::buffer_position": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::check_comments": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::check_end_names": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::close_expanded_empty": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::decode": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::decode_without_bom": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::decoder": [
            "reader::Decoder",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::event_namespace": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::option::Option",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::expand_empty_elements": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::from_reader": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::get_mut": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::get_ref": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::into_inner": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::read_bang": [
            "reader::BangType",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::read_end": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::read_event": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::read_event_buffered": [
            "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::R",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "reader::XmlSource",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::read_namespaced_event": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::read_question_mark": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::read_start": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::read_text": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::AsRef",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::read_to_end": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::AsRef",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::read_until_close": [
            "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::R",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "reader::XmlSource",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::read_until_open": [
            "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::R",
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "reader::XmlSource",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::result::Result",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::trim_markup_names_in_closing_tags": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::trim_text": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<R>::trim_text_end": [
            "reader::NamespaceResolver",
            "reader::Reader",
            "reader::TagState",
            "std::alloc::Allocator",
            "std::io::BufRead",
            "std::marker::Sized",
            "std::vec::Vec"
        ],
        "reader::Reader::<std::io::BufReader<std::fs::File>>::from_file": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::AsRef",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "reader::TagState": [
            "reader::TagState"
        ],
        "reader::XmlSource::peek_one": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "reader::XmlSource::read_bang_element": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "reader::XmlSource::read_bytes_until": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "reader::XmlSource::read_element": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "reader::XmlSource::skip_one": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "reader::XmlSource::skip_whitespace": [
            "std::marker::Sized",
            "std::result::Result"
        ],
        "reader::is_whitespace": [],
        "utils::ByteBuf": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec",
            "utils::ByteBuf"
        ],
        "utils::Bytes": [
            "utils::Bytes"
        ],
        "utils::write_byte_string": [
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "utils::write_cow_string": [
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::fmt::Formatter",
            "std::marker::Sized",
            "std::result::Result"
        ],
        "writer::ElementWriter": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "writer::ElementWriter",
            "writer::Writer"
        ],
        "writer::ElementWriter::<'a, W>::with_attribute": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::Into",
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "writer::ElementWriter",
            "writer::Writer"
        ],
        "writer::ElementWriter::<'a, W>::with_attributes": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::Into",
            "std::io::Write",
            "std::iter::IntoIterator",
            "std::marker::Sized",
            "std::option::Option",
            "writer::ElementWriter",
            "writer::Writer"
        ],
        "writer::ElementWriter::<'a, W>::write_cdata_content": [
            "events::BytesCData",
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "writer::ElementWriter",
            "writer::Writer"
        ],
        "writer::ElementWriter::<'a, W>::write_empty": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "writer::ElementWriter",
            "writer::Writer"
        ],
        "writer::ElementWriter::<'a, W>::write_inner_content": [
            "events::BytesStart",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::Write",
            "std::marker::Sized",
            "std::ops::Fn",
            "std::option::Option",
            "std::result::Result",
            "writer::ElementWriter",
            "writer::Writer"
        ],
        "writer::ElementWriter::<'a, W>::write_pi_content": [
            "events::BytesStart",
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "writer::ElementWriter",
            "writer::Writer"
        ],
        "writer::ElementWriter::<'a, W>::write_text_content": [
            "events::BytesStart",
            "events::BytesText",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "writer::ElementWriter",
            "writer::Writer"
        ],
        "writer::Indentation": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec",
            "writer::Indentation"
        ],
        "writer::Indentation::grow": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec",
            "writer::Indentation"
        ],
        "writer::Indentation::new": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec",
            "writer::Indentation"
        ],
        "writer::Indentation::shrink": [
            "std::alloc::Allocator",
            "std::marker::Sized",
            "std::vec::Vec",
            "writer::Indentation"
        ],
        "writer::Writer": [
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "writer::Writer"
        ],
        "writer::Writer::<W>::create_element": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::AsRef",
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "writer::ElementWriter",
            "writer::Writer"
        ],
        "writer::Writer::<W>::inner": [
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "writer::Writer"
        ],
        "writer::Writer::<W>::into_inner": [
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "writer::Writer"
        ],
        "writer::Writer::<W>::new": [
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "writer::Writer"
        ],
        "writer::Writer::<W>::new_with_indent": [
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "writer::Writer"
        ],
        "writer::Writer::<W>::write": [
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "writer::Writer"
        ],
        "writer::Writer::<W>::write_event": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "std::borrow::Cow",
            "std::borrow::ToOwned",
            "std::convert::AsRef",
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "writer::Writer"
        ],
        "writer::Writer::<W>::write_indent": [
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "writer::Writer"
        ],
        "writer::Writer::<W>::write_wrapped": [
            "std::io::Write",
            "std::marker::Sized",
            "std::option::Option",
            "std::result::Result",
            "writer::Writer"
        ]
    },
    "glob_path_import": {},
    "self_to_fn": {
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::R": [
            "impl<'b, R: BufRead> XmlSource<'b, &'b mut Vec<u8>> for R {\n    #[inline]\n    fn read_bytes_until(\n        &mut self,\n        byte: u8,\n        buf: &'b mut Vec<u8>,\n        position: &mut usize,\n    ) -> Result<Option<&'b [u8]>> {\n        let mut read = 0;\n        let mut done = false;\n        let start = buf.len();\n        while !done {\n            let used = {\n                let available = match self.fill_buf() {\n                    Ok(n) if n.is_empty() => break,\n                    Ok(n) => n,\n                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                    Err(e) => {\n                        *position += read;\n                        return Err(Error::Io(e));\n                    }\n                };\n\n                match memchr::memchr(byte, available) {\n                    Some(i) => {\n                        buf.extend_from_slice(&available[..i]);\n                        done = true;\n                        i + 1\n                    }\n                    None => {\n                        buf.extend_from_slice(available);\n                        available.len()\n                    }\n                }\n            };\n            self.consume(used);\n            read += used;\n        }\n        *position += read;\n\n        if read == 0 {\n            Ok(None)\n        } else {\n            Ok(Some(&buf[start..]))\n        }\n    }\n\n    fn read_bang_element(\n        &mut self,\n        buf: &'b mut Vec<u8>,\n        position: &mut usize,\n    ) -> Result<Option<(BangType, &'b [u8])>> {\n        // Peeked one bang ('!') before being called, so it's guaranteed to\n        // start with it.\n        let start = buf.len();\n        let mut read = 1;\n        buf.push(b'!');\n        self.consume(1);\n\n        let bang_type = BangType::new(self.peek_one()?)?;\n\n        loop {\n            match self.fill_buf() {\n                // Note: Do not update position, so the error points to\n                // somewhere sane rather than at the EOF\n                Ok(n) if n.is_empty() => return Err(bang_type.to_err()),\n                Ok(available) => {\n                    if let Some((consumed, used)) = bang_type.parse(available, read) {\n                        buf.extend_from_slice(consumed);\n\n                        self.consume(used);\n                        read += used;\n\n                        *position += read;\n                        break;\n                    } else {\n                        buf.extend_from_slice(available);\n\n                        let used = available.len();\n                        self.consume(used);\n                        read += used;\n                    }\n                }\n                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => {\n                    *position += read;\n                    return Err(Error::Io(e));\n                }\n            }\n        }\n\n        if read == 0 {\n            Ok(None)\n        } else {\n            Ok(Some((bang_type, &buf[start..])))\n        }\n    }\n\n    #[inline]\n    fn read_element(\n        &mut self,\n        buf: &'b mut Vec<u8>,\n        position: &mut usize,\n    ) -> Result<Option<&'b [u8]>> {\n        let mut state = ReadElementState::Elem;\n        let mut read = 0;\n\n        let start = buf.len();\n        loop {\n            match self.fill_buf() {\n                Ok(n) if n.is_empty() => break,\n                Ok(available) => {\n                    if let Some((consumed, used)) = state.change(available) {\n                        buf.extend_from_slice(consumed);\n\n                        self.consume(used);\n                        read += used;\n\n                        *position += read;\n                        break;\n                    } else {\n                        buf.extend_from_slice(available);\n\n                        let used = available.len();\n                        self.consume(used);\n                        read += used;\n                    }\n                }\n                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => {\n                    *position += read;\n                    return Err(Error::Io(e));\n                }\n            };\n        }\n\n        if read == 0 {\n            Ok(None)\n        } else {\n            Ok(Some(&buf[start..]))\n        }\n    }\n\n    /// Consume and discard all the whitespace until the next non-whitespace\n    /// character or EOF.\n    fn skip_whitespace(&mut self, position: &mut usize) -> Result<()> {\n        loop {\n            break match self.fill_buf() {\n                Ok(n) => {\n                    let count = n.iter().position(|b| !is_whitespace(*b)).unwrap_or(n.len());\n                    if count > 0 {\n                        self.consume(count);\n                        *position += count;\n                        continue;\n                    } else {\n                        Ok(())\n                    }\n                }\n                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => Err(Error::Io(e)),\n            };\n        }\n    }\n\n    /// Consume and discard one character if it matches the given byte. Return\n    /// true if it matched.\n    fn skip_one(&mut self, byte: u8, position: &mut usize) -> Result<bool> {\n        match self.peek_one()? {\n            Some(b) if b == byte => {\n                *position += 1;\n                self.consume(1);\n                Ok(true)\n            }\n            _ => Ok(false),\n        }\n    }\n\n    /// Return one character without consuming it, so that future `read_*` calls\n    /// will still include it. On EOF, return None.\n    fn peek_one(&mut self) -> Result<Option<u8>> {\n        loop {\n            break match self.fill_buf() {\n                Ok(n) if n.is_empty() => Ok(None),\n                Ok(n) => Ok(Some(n[0])),\n                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => Err(Error::Io(e)),\n            };\n        }\n    }\n}"
        ],
        "errors::Error": [
            "Debug",
            "impl From<::std::io::Error> for Error {\n    /// Creates a new `Error::Io` from the given error\n    #[inline]\n    fn from(error: ::std::io::Error) -> Error {\n        Error::Io(error)\n    }\n}",
            "impl From<AttrError> for Error {\n    #[inline]\n    fn from(error: AttrError) -> Self {\n        Error::InvalidAttr(error)\n    }\n}",
            "impl From<EscapeError> for Error {\n    /// Creates a new `Error::EscapeError` from the given error\n    #[inline]\n    fn from(error: EscapeError) -> Error {\n        Error::EscapeError(error)\n    }\n}",
            "impl From<Utf8Error> for Error {\n    /// Creates a new `Error::Utf8` from the given error\n    #[inline]\n    fn from(error: Utf8Error) -> Error {\n        Error::Utf8(error)\n    }\n}",
            "impl std::error::Error for Error {\n    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n        match self {\n            Error::Io(e) => Some(e),\n            Error::Utf8(e) => Some(e),\n            Error::InvalidAttr(e) => Some(e),\n            Error::EscapeError(e) => Some(e),\n            _ => None,\n        }\n    }\n}",
            "impl std::fmt::Display for Error {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        match self {\n            Error::Io(e) => write!(f, \"I/O error: {}\", e),\n            Error::Utf8(e) => write!(f, \"UTF8 error: {}\", e),\n            Error::UnexpectedEof(e) => write!(f, \"Unexpected EOF during reading {}\", e),\n            Error::EndEventMismatch { expected, found } => {\n                write!(f, \"Expecting </{}> found </{}>\", expected, found)\n            }\n            Error::UnexpectedToken(e) => write!(f, \"Unexpected token '{}'\", e),\n            Error::UnexpectedBang(b) => write!(\n                f,\n                \"Only Comment (`--`), CDATA (`[CDATA[`) and DOCTYPE (`DOCTYPE`) nodes can start with a '!', but symbol `{}` found\",\n                *b as char\n            ),\n            Error::TextNotFound => write!(f, \"Cannot read text, expecting Event::Text\"),\n            Error::XmlDeclWithoutVersion(e) => write!(\n                f,\n                \"XmlDecl must start with 'version' attribute, found {:?}\",\n                e\n            ),\n            Error::InvalidAttr(e) => write!(f, \"error while parsing attribute: {}\", e),\n            Error::EscapeError(e) => write!(f, \"{}\", e),\n        }\n    }\n}"
        ],
        "escapei::EscapeError": [
            "Debug",
            "impl std::error::Error for EscapeError {}",
            "impl std::fmt::Display for EscapeError {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        match self {\n            EscapeError::EntityWithNull(e) => write!(\n                f,\n                \"Error while escaping character at range {:?}: Null character entity not allowed\",\n                e\n            ),\n            EscapeError::UnrecognizedSymbol(rge, res) => write!(\n                f,\n                \"Error while escaping character at range {:?}: Unrecognized escape symbol: {:?}\",\n                rge, res\n            ),\n            EscapeError::UnterminatedEntity(e) => write!(\n                f,\n                \"Error while escaping character at range {:?}: Cannot find ';' after '&'\",\n                e\n            ),\n            EscapeError::TooLongHexadecimal => write!(f, \"Cannot convert hexadecimal to utf8\"),\n            EscapeError::InvalidHexadecimal(e) => {\n                write!(f, \"'{}' is not a valid hexadecimal character\", e)\n            }\n            EscapeError::TooLongDecimal => write!(f, \"Cannot convert decimal to utf8\"),\n            EscapeError::InvalidDecimal(e) => write!(f, \"'{}' is not a valid decimal character\", e),\n            EscapeError::InvalidCodepoint(n) => write!(f, \"'{}' is not a valid codepoint\", n),\n        }\n    }\n}"
        ],
        "events::BytesCData": [
            "Clone",
            "Eq",
            "PartialEq",
            "impl<'a> BytesCData<'a> {\n    /// Creates a new `BytesCData` from a byte sequence.\n    #[inline]\n    pub fn new<C: Into<Cow<'a, [u8]>>>(content: C) -> Self {\n        Self {\n            content: content.into(),\n        }\n    }\n\n    /// Creates a new `BytesCData` from a string\n    #[inline]\n    pub fn from_str(content: &'a str) -> Self {\n        Self::new(content.as_bytes())\n    }\n\n    /// Ensures that all data is owned to extend the object's lifetime if\n    /// necessary.\n    #[inline]\n    pub fn into_owned(self) -> BytesCData<'static> {\n        BytesCData {\n            content: self.content.into_owned().into(),\n        }\n    }\n\n    /// Extracts the inner `Cow` from the `BytesCData` event container.\n    #[inline]\n    pub fn into_inner(self) -> Cow<'a, [u8]> {\n        self.content\n    }\n\n    /// Converts this CDATA content to an escaped version, that can be written\n    /// as an usual text in XML.\n    ///\n    /// This function performs following replacements:\n    ///\n    /// | Character | Replacement\n    /// |-----------|------------\n    /// | `<`       | `&lt;`\n    /// | `>`       | `&gt;`\n    /// | `&`       | `&amp;`\n    /// | `'`       | `&apos;`\n    /// | `\"`       | `&quot;`\n    pub fn escape(self) -> BytesText<'a> {\n        BytesText::from_escaped(match escape(&self.content) {\n            Cow::Borrowed(_) => self.content,\n            Cow::Owned(escaped) => Cow::Owned(escaped),\n        })\n    }\n\n    /// Converts this CDATA content to an escaped version, that can be written\n    /// as an usual text in XML.\n    ///\n    /// In XML text content, it is allowed (though not recommended) to leave\n    /// the quote special characters `\"` and `'` unescaped.\n    ///\n    /// This function performs following replacements:\n    ///\n    /// | Character | Replacement\n    /// |-----------|------------\n    /// | `<`       | `&lt;`\n    /// | `>`       | `&gt;`\n    /// | `&`       | `&amp;`\n    pub fn partial_escape(self) -> BytesText<'a> {\n        BytesText::from_escaped(match partial_escape(&self.content) {\n            Cow::Borrowed(_) => self.content,\n            Cow::Owned(escaped) => Cow::Owned(escaped),\n        })\n    }\n\n    /// Gets content of this text buffer in the specified encoding\n    #[cfg(feature = \"serialize\")]\n    pub(crate) fn decode(&self, decoder: crate::reader::Decoder) -> Result<Cow<'a, str>> {\n        Ok(match &self.content {\n            Cow::Borrowed(bytes) => {\n                #[cfg(feature = \"encoding\")]\n                {\n                    decoder.decode(bytes)\n                }\n                #[cfg(not(feature = \"encoding\"))]\n                {\n                    decoder.decode(bytes)?.into()\n                }\n            }\n            Cow::Owned(bytes) => {\n                #[cfg(feature = \"encoding\")]\n                let decoded = decoder.decode(bytes).into_owned();\n\n                #[cfg(not(feature = \"encoding\"))]\n                let decoded = decoder.decode(bytes)?.to_string();\n\n                decoded.into()\n            }\n        })\n    }\n}",
            "impl<'a> Deref for BytesCData<'a> {\n    type Target = [u8];\n\n    fn deref(&self) -> &[u8] {\n        &*self.content\n    }\n}",
            "impl<'a> std::fmt::Debug for BytesCData<'a> {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"BytesCData {{ content: \")?;\n        write_cow_string(f, &self.content)?;\n        write!(f, \" }}\")\n    }\n}"
        ],
        "events::BytesDecl": [
            "Clone",
            "Debug",
            "Eq",
            "PartialEq",
            "impl<'a> BytesDecl<'a> {\n    /// Creates a `BytesDecl` from a `BytesStart`\n    pub fn from_start(start: BytesStart<'a>) -> BytesDecl<'a> {\n        BytesDecl { element: start }\n    }\n\n    /// Gets xml version, excluding quotes (`'` or `\"`).\n    ///\n    /// According to the [grammar], the version *must* be the first thing in the declaration.\n    /// This method tries to extract the first thing in the declaration and return it.\n    /// In case of multiple attributes value of the first one is returned.\n    ///\n    /// If version is missed in the declaration, or the first thing is not a version,\n    /// [`Error::XmlDeclWithoutVersion`] will be returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    /// use quick_xml::Error;\n    /// use quick_xml::events::{BytesDecl, BytesStart};\n    ///\n    /// // <?xml version='1.1'?>\n    /// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" version='1.1'\", 0));\n    /// assert_eq!(\n    ///     decl.version().unwrap(),\n    ///     Cow::Borrowed(b\"1.1\".as_ref())\n    /// );\n    ///\n    /// // <?xml version='1.0' version='1.1'?>\n    /// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" version='1.0' version='1.1'\", 0));\n    /// assert_eq!(\n    ///     decl.version().unwrap(),\n    ///     Cow::Borrowed(b\"1.0\".as_ref())\n    /// );\n    ///\n    /// // <?xml encoding='utf-8'?>\n    /// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" encoding='utf-8'\", 0));\n    /// match decl.version() {\n    ///     Err(Error::XmlDeclWithoutVersion(Some(key))) => assert_eq!(key, \"encoding\".to_string()),\n    ///     _ => assert!(false),\n    /// }\n    ///\n    /// // <?xml encoding='utf-8' version='1.1'?>\n    /// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" encoding='utf-8' version='1.1'\", 0));\n    /// match decl.version() {\n    ///     Err(Error::XmlDeclWithoutVersion(Some(key))) => assert_eq!(key, \"encoding\".to_string()),\n    ///     _ => assert!(false),\n    /// }\n    ///\n    /// // <?xml?>\n    /// let decl = BytesDecl::from_start(BytesStart::borrowed(b\"\", 0));\n    /// match decl.version() {\n    ///     Err(Error::XmlDeclWithoutVersion(None)) => {},\n    ///     _ => assert!(false),\n    /// }\n    /// ```\n    ///\n    /// [grammar]: https://www.w3.org/TR/xml11/#NT-XMLDecl\n    pub fn version(&self) -> Result<Cow<[u8]>> {\n        // The version *must* be the first thing in the declaration.\n        match self.element.attributes().with_checks(false).next() {\n            Some(Ok(a)) if a.key == b\"version\" => Ok(a.value),\n            // first attribute was not \"version\"\n            Some(Ok(a)) => {\n                let found = from_utf8(a.key).map_err(Error::Utf8)?.to_string();\n                Err(Error::XmlDeclWithoutVersion(Some(found)))\n            }\n            // error parsing attributes\n            Some(Err(e)) => Err(e.into()),\n            // no attributes\n            None => Err(Error::XmlDeclWithoutVersion(None)),\n        }\n    }\n\n    /// Gets xml encoding, excluding quotes (`'` or `\"`).\n    ///\n    /// Although according to the [grammar] encoding must appear before `\"standalone\"`\n    /// and after `\"version\"`, this method does not check that. The first occurrence\n    /// of the attribute will be returned even if there are several. Also, method does\n    /// not restrict symbols that can forming the encoding, so the returned encoding\n    /// name may not correspond to the grammar.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    /// use quick_xml::Error;\n    /// use quick_xml::events::{BytesDecl, BytesStart};\n    ///\n    /// // <?xml version='1.1'?>\n    /// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" version='1.1'\", 0));\n    /// assert!(decl.encoding().is_none());\n    ///\n    /// // <?xml encoding='utf-8'?>\n    /// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" encoding='utf-8'\", 0));\n    /// match decl.encoding() {\n    ///     Some(Ok(Cow::Borrowed(encoding))) => assert_eq!(encoding, b\"utf-8\"),\n    ///     _ => assert!(false),\n    /// }\n    ///\n    /// // <?xml encoding='something_WRONG' encoding='utf-8'?>\n    /// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" encoding='something_WRONG' encoding='utf-8'\", 0));\n    /// match decl.encoding() {\n    ///     Some(Ok(Cow::Borrowed(encoding))) => assert_eq!(encoding, b\"something_WRONG\"),\n    ///     _ => assert!(false),\n    /// }\n    /// ```\n    ///\n    /// [grammar]: https://www.w3.org/TR/xml11/#NT-XMLDecl\n    pub fn encoding(&self) -> Option<Result<Cow<[u8]>>> {\n        self.element\n            .try_get_attribute(\"encoding\")\n            .map(|a| a.map(|a| a.value))\n            .transpose()\n    }\n\n    /// Gets xml standalone, excluding quotes (`'` or `\"`).\n    ///\n    /// Although according to the [grammar] standalone flag must appear after `\"version\"`\n    /// and `\"encoding\"`, this method does not check that. The first occurrence of the\n    /// attribute will be returned even if there are several. Also, method does not\n    /// restrict symbols that can forming the value, so the returned flag name may not\n    /// correspond to the grammar.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    /// use quick_xml::Error;\n    /// use quick_xml::events::{BytesDecl, BytesStart};\n    ///\n    /// // <?xml version='1.1'?>\n    /// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" version='1.1'\", 0));\n    /// assert!(decl.standalone().is_none());\n    ///\n    /// // <?xml standalone='yes'?>\n    /// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" standalone='yes'\", 0));\n    /// match decl.standalone() {\n    ///     Some(Ok(Cow::Borrowed(encoding))) => assert_eq!(encoding, b\"yes\"),\n    ///     _ => assert!(false),\n    /// }\n    ///\n    /// // <?xml standalone='something_WRONG' encoding='utf-8'?>\n    /// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" standalone='something_WRONG' encoding='utf-8'\", 0));\n    /// match decl.standalone() {\n    ///     Some(Ok(Cow::Borrowed(flag))) => assert_eq!(flag, b\"something_WRONG\"),\n    ///     _ => assert!(false),\n    /// }\n    /// ```\n    ///\n    /// [grammar]: https://www.w3.org/TR/xml11/#NT-XMLDecl\n    pub fn standalone(&self) -> Option<Result<Cow<[u8]>>> {\n        self.element\n            .try_get_attribute(\"standalone\")\n            .map(|a| a.map(|a| a.value))\n            .transpose()\n    }\n\n    /// Constructs a new `XmlDecl` from the (mandatory) _version_ (should be `1.0` or `1.1`),\n    /// the optional _encoding_ (e.g., `UTF-8`) and the optional _standalone_ (`yes` or `no`)\n    /// attribute.\n    ///\n    /// Does not escape any of its inputs. Always uses double quotes to wrap the attribute values.\n    /// The caller is responsible for escaping attribute values. Shouldn't usually be relevant since\n    /// the double quote character is not allowed in any of the attribute values.\n    pub fn new(\n        version: &[u8],\n        encoding: Option<&[u8]>,\n        standalone: Option<&[u8]>,\n    ) -> BytesDecl<'static> {\n        // Compute length of the buffer based on supplied attributes\n        // ' encoding=\"\"'   => 12\n        let encoding_attr_len = if let Some(xs) = encoding {\n            12 + xs.len()\n        } else {\n            0\n        };\n        // ' standalone=\"\"' => 14\n        let standalone_attr_len = if let Some(xs) = standalone {\n            14 + xs.len()\n        } else {\n            0\n        };\n        // 'xml version=\"\"' => 14\n        let mut buf = Vec::with_capacity(14 + encoding_attr_len + standalone_attr_len);\n\n        buf.extend_from_slice(b\"xml version=\\\"\");\n        buf.extend_from_slice(version);\n\n        if let Some(encoding_val) = encoding {\n            buf.extend_from_slice(b\"\\\" encoding=\\\"\");\n            buf.extend_from_slice(encoding_val);\n        }\n\n        if let Some(standalone_val) = standalone {\n            buf.extend_from_slice(b\"\\\" standalone=\\\"\");\n            buf.extend_from_slice(standalone_val);\n        }\n        buf.push(b'\"');\n\n        BytesDecl {\n            element: BytesStart::owned(buf, 3),\n        }\n    }\n\n    /// Gets the decoder struct\n    #[cfg(feature = \"encoding_rs\")]\n    pub fn encoder(&self) -> Option<&'static Encoding> {\n        self.encoding()\n            .and_then(|e| e.ok())\n            .and_then(|e| Encoding::for_label(&*e))\n    }\n\n    /// Converts the event into an owned event.\n    pub fn into_owned(self) -> BytesDecl<'static> {\n        BytesDecl {\n            element: self.element.into_owned(),\n        }\n    }\n}",
            "impl<'a> Deref for BytesDecl<'a> {\n    type Target = [u8];\n    fn deref(&self) -> &[u8] {\n        &*self.element\n    }\n}"
        ],
        "events::BytesEnd": [
            "Clone",
            "Eq",
            "PartialEq",
            "impl<'a> BytesEnd<'a> {\n    /// Creates a new `BytesEnd` borrowing a slice\n    #[inline]\n    pub fn borrowed(name: &'a [u8]) -> BytesEnd<'a> {\n        BytesEnd {\n            name: Cow::Borrowed(name),\n        }\n    }\n\n    /// Creates a new `BytesEnd` owning its name\n    #[inline]\n    pub fn owned(name: Vec<u8>) -> BytesEnd<'static> {\n        BytesEnd {\n            name: Cow::Owned(name),\n        }\n    }\n\n    /// Converts the event into an owned event.\n    pub fn into_owned(self) -> BytesEnd<'static> {\n        BytesEnd {\n            name: Cow::Owned(self.name.into_owned()),\n        }\n    }\n\n    /// Gets `BytesEnd` event name\n    #[inline]\n    pub fn name(&self) -> &[u8] {\n        &*self.name\n    }\n\n    /// local name (excluding namespace) as &[u8] (without eventual attributes)\n    /// returns the name() with any leading namespace removed (all content up to\n    /// and including the first ':' character)\n    #[inline]\n    pub fn local_name(&self) -> &[u8] {\n        if let Some(i) = self.name().iter().position(|b| *b == b':') {\n            &self.name()[i + 1..]\n        } else {\n            self.name()\n        }\n    }\n}",
            "impl<'a> Deref for BytesEnd<'a> {\n    type Target = [u8];\n    fn deref(&self) -> &[u8] {\n        &*self.name\n    }\n}",
            "impl<'a> std::fmt::Debug for BytesEnd<'a> {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"BytesEnd {{ name: \")?;\n        write_cow_string(f, &self.name)?;\n        write!(f, \" }}\")\n    }\n}"
        ],
        "events::BytesStart": [
            "Clone",
            "Eq",
            "PartialEq",
            "impl<'a> BytesStart<'a> {\n    /// Consumes `self` and yield a new `BytesStart` with additional attributes from an iterator.\n    ///\n    /// The yielded items must be convertible to [`Attribute`] using `Into`.\n    pub fn with_attributes<'b, I>(mut self, attributes: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Into<Attribute<'b>>,\n    {\n        self.extend_attributes(attributes);\n        self\n    }\n\n    /// Add additional attributes to this tag using an iterator.\n    ///\n    /// The yielded items must be convertible to [`Attribute`] using `Into`.\n    pub fn extend_attributes<'b, I>(&mut self, attributes: I) -> &mut BytesStart<'a>\n    where\n        I: IntoIterator,\n        I::Item: Into<Attribute<'b>>,\n    {\n        for attr in attributes {\n            self.push_attribute(attr);\n        }\n        self\n    }\n\n    /// Adds an attribute to this element.\n    pub fn push_attribute<'b, A>(&mut self, attr: A)\n    where\n        A: Into<Attribute<'b>>,\n    {\n        let a = attr.into();\n        let bytes = self.buf.to_mut();\n        bytes.push(b' ');\n        bytes.extend_from_slice(a.key);\n        bytes.extend_from_slice(b\"=\\\"\");\n        bytes.extend_from_slice(&*a.value);\n        bytes.push(b'\"');\n    }\n\n    /// Remove all attributes from the ByteStart\n    pub fn clear_attributes(&mut self) -> &mut BytesStart<'a> {\n        self.buf.to_mut().truncate(self.name_len);\n        self\n    }\n\n    /// Returns an iterator over the attributes of this tag.\n    pub fn attributes(&self) -> Attributes {\n        Attributes::new(&self.buf, self.name_len)\n    }\n\n    /// Returns an iterator over the HTML-like attributes of this tag (no mandatory quotes or `=`).\n    pub fn html_attributes(&self) -> Attributes {\n        Attributes::html(self, self.name_len)\n    }\n\n    /// Gets the undecoded raw string with the attributes of this tag as a `&[u8]`,\n    /// including the whitespace after the tag name if there is any.\n    #[inline]\n    pub fn attributes_raw(&self) -> &[u8] {\n        &self.buf[self.name_len..]\n    }\n\n    /// Try to get an attribute\n    pub fn try_get_attribute<N: AsRef<[u8]> + Sized>(\n        &'a self,\n        attr_name: N,\n    ) -> Result<Option<Attribute<'a>>> {\n        for a in self.attributes() {\n            let a = a?;\n            if a.key == attr_name.as_ref() {\n                return Ok(Some(a));\n            }\n        }\n        Ok(None)\n    }\n}",
            "impl<'a> BytesStart<'a> {\n    /// Creates a new `BytesStart` from the given content (name + attributes).\n    ///\n    /// # Warning\n    ///\n    /// `&content[..name_len]` is not checked to be a valid name\n    #[inline]\n    pub fn borrowed(content: &'a [u8], name_len: usize) -> Self {\n        BytesStart {\n            buf: Cow::Borrowed(content),\n            name_len,\n        }\n    }\n\n    /// Creates a new `BytesStart` from the given name.\n    ///\n    /// # Warning\n    ///\n    /// `&content` is not checked to be a valid name\n    #[inline]\n    pub fn borrowed_name(name: &'a [u8]) -> BytesStart<'a> {\n        Self::borrowed(name, name.len())\n    }\n\n    /// Creates a new `BytesStart` from the given content (name + attributes)\n    ///\n    /// Owns its contents.\n    #[inline]\n    pub fn owned<C: Into<Vec<u8>>>(content: C, name_len: usize) -> BytesStart<'static> {\n        BytesStart {\n            buf: Cow::Owned(content.into()),\n            name_len,\n        }\n    }\n\n    /// Creates a new `BytesStart` from the given name\n    ///\n    /// Owns its contents.\n    #[inline]\n    pub fn owned_name<C: Into<Vec<u8>>>(name: C) -> BytesStart<'static> {\n        let content = name.into();\n        BytesStart {\n            name_len: content.len(),\n            buf: Cow::Owned(content),\n        }\n    }\n\n    /// Converts the event into an owned event.\n    pub fn into_owned(self) -> BytesStart<'static> {\n        Self::owned(self.buf.into_owned(), self.name_len)\n    }\n\n    /// Converts the event into an owned event without taking ownership of Event\n    pub fn to_owned(&self) -> BytesStart<'static> {\n        Self::owned(self.buf.to_owned(), self.name_len)\n    }\n\n    /// Converts the event into a borrowed event. Most useful when paired with [`to_end`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use quick_xml::{Error, Writer};\n    /// use quick_xml::events::{BytesStart, Event};\n    ///\n    /// struct SomeStruct<'a> {\n    ///     attrs: BytesStart<'a>,\n    ///     // ...\n    /// }\n    /// # impl<'a> SomeStruct<'a> {\n    /// # fn example(&self) -> Result<(), Error> {\n    /// # let mut writer = Writer::new(Vec::new());\n    ///\n    /// writer.write_event(Event::Start(self.attrs.to_borrowed()))?;\n    /// // ...\n    /// writer.write_event(Event::End(self.attrs.to_end()))?;\n    /// # Ok(())\n    /// # }}\n    /// ```\n    ///\n    /// [`to_end`]: #method.to_end\n    pub fn to_borrowed(&self) -> BytesStart {\n        BytesStart::borrowed(&self.buf, self.name_len)\n    }\n\n    /// Creates new paired close tag\n    pub fn to_end(&self) -> BytesEnd {\n        BytesEnd::borrowed(self.name())\n    }\n\n    /// Gets the undecoded raw tag name as a `&[u8]`.\n    #[inline]\n    pub fn name(&self) -> &[u8] {\n        &self.buf[..self.name_len]\n    }\n\n    /// Gets the undecoded raw local tag name (excluding namespace) as a `&[u8]`.\n    ///\n    /// All content up to and including the first `:` character is removed from the tag name.\n    #[inline]\n    pub fn local_name(&self) -> &[u8] {\n        let name = self.name();\n        memchr::memchr(b':', name).map_or(name, |i| &name[i + 1..])\n    }\n\n    /// Gets the unescaped tag name.\n    ///\n    /// XML escape sequences like \"`&lt;`\" will be replaced by their unescaped characters like\n    /// \"`<`\".\n    ///\n    /// See also [`unescaped_with_custom_entities()`](#method.unescaped_with_custom_entities)\n    #[inline]\n    pub fn unescaped(&self) -> Result<Cow<[u8]>> {\n        self.make_unescaped(None)\n    }\n\n    /// Gets the unescaped tag name, using custom entities.\n    ///\n    /// XML escape sequences like \"`&lt;`\" will be replaced by their unescaped characters like\n    /// \"`<`\".\n    /// Additional entities can be provided in `custom_entities`.\n    ///\n    /// # Pre-condition\n    ///\n    /// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n    ///\n    /// See also [`unescaped()`](#method.unescaped)\n    #[inline]\n    pub fn unescaped_with_custom_entities<'s>(\n        &'s self,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> Result<Cow<'s, [u8]>> {\n        self.make_unescaped(Some(custom_entities))\n    }\n\n    #[inline]\n    fn make_unescaped<'s>(\n        &'s self,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<Cow<'s, [u8]>> {\n        do_unescape(&*self.buf, custom_entities).map_err(Error::EscapeError)\n    }\n\n    /// Returns the unescaped and decoded string value.\n    ///\n    /// This allocates a `String` in all cases. For performance reasons it might be a better idea to\n    /// instead use one of:\n    ///\n    /// * [`unescaped()`], as it doesn't allocate when no escape sequences are used.\n    /// * [`Reader::decode()`], as it only allocates when the decoding can't be performed otherwise.\n    ///\n    /// [`unescaped()`]: #method.unescaped\n    /// [`Reader::decode()`]: ../reader/struct.Reader.html#method.decode\n    #[inline]\n    pub fn unescape_and_decode<B: BufRead>(&self, reader: &Reader<B>) -> Result<String> {\n        self.do_unescape_and_decode_with_custom_entities(reader, None)\n    }\n\n    /// Returns the unescaped and decoded string value with custom entities.\n    ///\n    /// This allocates a `String` in all cases. For performance reasons it might be a better idea to\n    /// instead use one of:\n    ///\n    /// * [`unescaped_with_custom_entities()`], as it doesn't allocate when no escape sequences are used.\n    /// * [`Reader::decode()`], as it only allocates when the decoding can't be performed otherwise.\n    ///\n    /// [`unescaped_with_custom_entities()`]: #method.unescaped_with_custom_entities\n    /// [`Reader::decode()`]: ../reader/struct.Reader.html#method.decode\n    ///\n    /// # Pre-condition\n    ///\n    /// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n    #[inline]\n    pub fn unescape_and_decode_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> Result<String> {\n        self.do_unescape_and_decode_with_custom_entities(reader, Some(custom_entities))\n    }\n\n    #[cfg(feature = \"encoding\")]\n    #[inline]\n    fn do_unescape_and_decode_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<String> {\n        let decoded = reader.decode(&*self);\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }\n\n    #[cfg(not(feature = \"encoding\"))]\n    #[inline]\n    fn do_unescape_and_decode_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<String> {\n        let decoded = reader.decode(&*self)?;\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }\n\n    /// Edit the name of the BytesStart in-place\n    ///\n    /// # Warning\n    ///\n    /// `name` is not checked to be a valid name\n    pub fn set_name(&mut self, name: &[u8]) -> &mut BytesStart<'a> {\n        let bytes = self.buf.to_mut();\n        bytes.splice(..self.name_len, name.iter().cloned());\n        self.name_len = name.len();\n        self\n    }\n}",
            "impl<'a> Deref for BytesStart<'a> {\n    type Target = [u8];\n    fn deref(&self) -> &[u8] {\n        &*self.buf\n    }\n}",
            "impl<'a> std::fmt::Debug for BytesStart<'a> {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"BytesStart {{ buf: \")?;\n        write_cow_string(f, &self.buf)?;\n        write!(f, \", name_len: {} }}\", self.name_len)\n    }\n}"
        ],
        "events::BytesText": [
            "Clone",
            "Eq",
            "PartialEq",
            "impl<'a> BytesText<'a> {\n    /// Creates a new `BytesText` from an escaped byte sequence.\n    #[inline]\n    pub fn from_escaped<C: Into<Cow<'a, [u8]>>>(content: C) -> Self {\n        Self {\n            content: content.into(),\n        }\n    }\n\n    /// Creates a new `BytesText` from a byte sequence. The byte sequence is\n    /// expected not to be escaped.\n    #[inline]\n    pub fn from_plain(content: &'a [u8]) -> Self {\n        Self {\n            content: escape(content),\n        }\n    }\n\n    /// Creates a new `BytesText` from an escaped string.\n    #[inline]\n    pub fn from_escaped_str<C: Into<Cow<'a, str>>>(content: C) -> Self {\n        Self::from_escaped(match content.into() {\n            Cow::Owned(o) => Cow::Owned(o.into_bytes()),\n            Cow::Borrowed(b) => Cow::Borrowed(b.as_bytes()),\n        })\n    }\n\n    /// Creates a new `BytesText` from a string. The string is expected not to\n    /// be escaped.\n    #[inline]\n    pub fn from_plain_str(content: &'a str) -> Self {\n        Self::from_plain(content.as_bytes())\n    }\n\n    /// Ensures that all data is owned to extend the object's lifetime if\n    /// necessary.\n    #[inline]\n    pub fn into_owned(self) -> BytesText<'static> {\n        BytesText {\n            content: self.content.into_owned().into(),\n        }\n    }\n\n    /// Extracts the inner `Cow` from the `BytesText` event container.\n    #[inline]\n    pub fn into_inner(self) -> Cow<'a, [u8]> {\n        self.content\n    }\n\n    /// Returns unescaped version of the text content, that can be written\n    /// as CDATA in XML\n    #[cfg(feature = \"serialize\")]\n    pub(crate) fn unescape(self) -> std::result::Result<BytesCData<'a>, EscapeError> {\n        //TODO: need to think about better API instead of dozens similar functions\n        // Maybe use builder pattern. After that expose function as public API\n        //FIXME: need to take into account entities defined in the document\n        Ok(BytesCData::new(match do_unescape(&self.content, None)? {\n            Cow::Borrowed(_) => self.content,\n            Cow::Owned(unescaped) => Cow::Owned(unescaped),\n        }))\n    }\n\n    /// gets escaped content\n    ///\n    /// Searches for '&' into content and try to escape the coded character if possible\n    /// returns Malformed error with index within element if '&' is not followed by ';'\n    ///\n    /// See also [`unescaped_with_custom_entities()`](#method.unescaped_with_custom_entities)\n    pub fn unescaped(&self) -> Result<Cow<[u8]>> {\n        self.make_unescaped(None)\n    }\n\n    /// gets escaped content with custom entities\n    ///\n    /// Searches for '&' into content and try to escape the coded character if possible\n    /// returns Malformed error with index within element if '&' is not followed by ';'\n    /// Additional entities can be provided in `custom_entities`.\n    ///\n    /// # Pre-condition\n    ///\n    /// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n    ///\n    /// See also [`unescaped()`](#method.unescaped)\n    pub fn unescaped_with_custom_entities<'s>(\n        &'s self,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> Result<Cow<'s, [u8]>> {\n        self.make_unescaped(Some(custom_entities))\n    }\n\n    fn make_unescaped<'s>(\n        &'s self,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<Cow<'s, [u8]>> {\n        do_unescape(self, custom_entities).map_err(Error::EscapeError)\n    }\n\n    /// helper method to unescape then decode self using the reader encoding\n    /// but without BOM (Byte order mark)\n    ///\n    /// for performance reasons (could avoid allocating a `String`),\n    /// it might be wiser to manually use\n    /// 1. BytesText::unescaped()\n    /// 2. Reader::decode(...)\n    #[cfg(feature = \"encoding\")]\n    pub fn unescape_and_decode_without_bom<B: BufRead>(\n        &self,\n        reader: &mut Reader<B>,\n    ) -> Result<String> {\n        self.do_unescape_and_decode_without_bom(reader, None)\n    }\n\n    /// helper method to unescape then decode self using the reader encoding\n    /// but without BOM (Byte order mark)\n    ///\n    /// for performance reasons (could avoid allocating a `String`),\n    /// it might be wiser to manually use\n    /// 1. BytesText::unescaped()\n    /// 2. Reader::decode(...)\n    #[cfg(not(feature = \"encoding\"))]\n    pub fn unescape_and_decode_without_bom<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n    ) -> Result<String> {\n        self.do_unescape_and_decode_without_bom(reader, None)\n    }\n\n    /// helper method to unescape then decode self using the reader encoding with custom entities\n    /// but without BOM (Byte order mark)\n    ///\n    /// for performance reasons (could avoid allocating a `String`),\n    /// it might be wiser to manually use\n    /// 1. BytesText::unescaped()\n    /// 2. Reader::decode(...)\n    ///\n    /// # Pre-condition\n    ///\n    /// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n    #[cfg(feature = \"encoding\")]\n    pub fn unescape_and_decode_without_bom_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &mut Reader<B>,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> Result<String> {\n        self.do_unescape_and_decode_without_bom(reader, Some(custom_entities))\n    }\n\n    /// helper method to unescape then decode self using the reader encoding with custom entities\n    /// but without BOM (Byte order mark)\n    ///\n    /// for performance reasons (could avoid allocating a `String`),\n    /// it might be wiser to manually use\n    /// 1. BytesText::unescaped()\n    /// 2. Reader::decode(...)\n    ///\n    /// # Pre-condition\n    ///\n    /// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n    #[cfg(not(feature = \"encoding\"))]\n    pub fn unescape_and_decode_without_bom_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> Result<String> {\n        self.do_unescape_and_decode_without_bom(reader, Some(custom_entities))\n    }\n\n    #[cfg(feature = \"encoding\")]\n    fn do_unescape_and_decode_without_bom<B: BufRead>(\n        &self,\n        reader: &mut Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<String> {\n        let decoded = reader.decode_without_bom(&*self);\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }\n\n    #[cfg(not(feature = \"encoding\"))]\n    fn do_unescape_and_decode_without_bom<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<String> {\n        let decoded = reader.decode_without_bom(&*self)?;\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }\n\n    /// helper method to unescape then decode self using the reader encoding\n    ///\n    /// for performance reasons (could avoid allocating a `String`),\n    /// it might be wiser to manually use\n    /// 1. BytesText::unescaped()\n    /// 2. Reader::decode(...)\n    pub fn unescape_and_decode<B: BufRead>(&self, reader: &Reader<B>) -> Result<String> {\n        self.do_unescape_and_decode_with_custom_entities(reader, None)\n    }\n\n    /// helper method to unescape then decode self using the reader encoding with custom entities\n    ///\n    /// for performance reasons (could avoid allocating a `String`),\n    /// it might be wiser to manually use\n    /// 1. BytesText::unescaped()\n    /// 2. Reader::decode(...)\n    ///\n    /// # Pre-condition\n    ///\n    /// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n    pub fn unescape_and_decode_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> Result<String> {\n        self.do_unescape_and_decode_with_custom_entities(reader, Some(custom_entities))\n    }\n\n    #[cfg(feature = \"encoding\")]\n    fn do_unescape_and_decode_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<String> {\n        let decoded = reader.decode(&*self);\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }\n\n    #[cfg(not(feature = \"encoding\"))]\n    fn do_unescape_and_decode_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<String> {\n        let decoded = reader.decode(&*self)?;\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }\n\n    /// Gets escaped content.\n    pub fn escaped(&self) -> &[u8] {\n        self.content.as_ref()\n    }\n}",
            "impl<'a> Deref for BytesText<'a> {\n    type Target = [u8];\n    fn deref(&self) -> &[u8] {\n        &*self.content\n    }\n}",
            "impl<'a> std::fmt::Debug for BytesText<'a> {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"BytesText {{ content: \")?;\n        write_cow_string(f, &self.content)?;\n        write!(f, \" }}\")\n    }\n}"
        ],
        "events::Event": [
            "Clone",
            "Debug",
            "Eq",
            "PartialEq",
            "impl<'a> AsRef<Event<'a>> for Event<'a> {\n    fn as_ref(&self) -> &Event<'a> {\n        self\n    }\n}",
            "impl<'a> Deref for Event<'a> {\n    type Target = [u8];\n    fn deref(&self) -> &[u8] {\n        match *self {\n            Event::Start(ref e) | Event::Empty(ref e) => &*e,\n            Event::End(ref e) => &*e,\n            Event::Text(ref e) => &*e,\n            Event::Decl(ref e) => &*e,\n            Event::PI(ref e) => &*e,\n            Event::CData(ref e) => &*e,\n            Event::Comment(ref e) => &*e,\n            Event::DocType(ref e) => &*e,\n            Event::Eof => &[],\n        }\n    }\n}",
            "impl<'a> Event<'a> {\n    /// Converts the event to an owned version, untied to the lifetime of\n    /// buffer used when reading but incurring a new, separate allocation.\n    pub fn into_owned(self) -> Event<'static> {\n        match self {\n            Event::Start(e) => Event::Start(e.into_owned()),\n            Event::End(e) => Event::End(e.into_owned()),\n            Event::Empty(e) => Event::Empty(e.into_owned()),\n            Event::Text(e) => Event::Text(e.into_owned()),\n            Event::Comment(e) => Event::Comment(e.into_owned()),\n            Event::CData(e) => Event::CData(e.into_owned()),\n            Event::Decl(e) => Event::Decl(e.into_owned()),\n            Event::PI(e) => Event::PI(e.into_owned()),\n            Event::DocType(e) => Event::DocType(e.into_owned()),\n            Event::Eof => Event::Eof,\n        }\n    }\n}"
        ],
        "events::attributes::Attr": [
            "Clone",
            "Eq",
            "Hash",
            "Ord",
            "PartialEq",
            "PartialOrd",
            "impl<'a> Attr<&'a [u8]> {\n    /// Returns the key value\n    #[inline]\n    pub fn key(&self) -> &'a [u8] {\n        match self {\n            Attr::DoubleQ(key, _) => key,\n            Attr::SingleQ(key, _) => key,\n            Attr::Empty(key) => key,\n            Attr::Unquoted(key, _) => key,\n        }\n    }\n    /// Returns the attribute value. For [`Self::Empty`] variant an empty slice\n    /// is returned according to the [HTML specification].\n    ///\n    /// [HTML specification]: https://www.w3.org/TR/2012/WD-html-markup-20120329/syntax.html#syntax-attr-empty\n    #[inline]\n    pub fn value(&self) -> &'a [u8] {\n        match self {\n            Attr::DoubleQ(_, value) => value,\n            Attr::SingleQ(_, value) => value,\n            Attr::Empty(_) => &[],\n            Attr::Unquoted(_, value) => value,\n        }\n    }\n}",
            "impl<T: AsRef<[u8]>> Debug for Attr<T> {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        match self {\n            Attr::DoubleQ(key, value) => f\n                .debug_tuple(\"Attr::DoubleQ\")\n                .field(&Bytes(key.as_ref()))\n                .field(&Bytes(value.as_ref()))\n                .finish(),\n            Attr::SingleQ(key, value) => f\n                .debug_tuple(\"Attr::SingleQ\")\n                .field(&Bytes(key.as_ref()))\n                .field(&Bytes(value.as_ref()))\n                .finish(),\n            Attr::Empty(key) => f\n                .debug_tuple(\"Attr::Empty\")\n                // Comment to prevent formatting and keep style consistent\n                .field(&Bytes(key.as_ref()))\n                .finish(),\n            Attr::Unquoted(key, value) => f\n                .debug_tuple(\"Attr::Unquoted\")\n                .field(&Bytes(key.as_ref()))\n                .field(&Bytes(value.as_ref()))\n                .finish(),\n        }\n    }\n}",
            "impl<T> Attr<T> {\n    /// Maps an `Attr<T>` to `Attr<U>` by applying a function to a contained key and value.\n    #[inline]\n    pub fn map<U, F>(self, mut f: F) -> Attr<U>\n    where\n        F: FnMut(T) -> U,\n    {\n        match self {\n            Attr::DoubleQ(key, value) => Attr::DoubleQ(f(key), f(value)),\n            Attr::SingleQ(key, value) => Attr::SingleQ(f(key), f(value)),\n            Attr::Empty(key) => Attr::Empty(f(key)),\n            Attr::Unquoted(key, value) => Attr::Unquoted(f(key), f(value)),\n        }\n    }\n}"
        ],
        "events::attributes::AttrError": [
            "Debug",
            "PartialEq",
            "impl Display for AttrError {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        match self {\n            Self::ExpectedEq(pos) => write!(\n                f,\n                r#\"position {}: attribute key must be directly followed by `=` or space\"#,\n                pos\n            ),\n            Self::ExpectedValue(pos) => write!(\n                f,\n                r#\"position {}: `=` must be followed by an attribute value\"#,\n                pos\n            ),\n            Self::UnquotedValue(pos) => write!(\n                f,\n                r#\"position {}: attribute value must be enclosed in `\"` or `'`\"#,\n                pos\n            ),\n            Self::ExpectedQuote(pos, quote) => write!(\n                f,\n                r#\"position {}: missing closing quote `{}` in attribute value\"#,\n                pos, *quote as char\n            ),\n            Self::Duplicated(pos1, pos2) => write!(\n                f,\n                r#\"position {}: duplicated attribute, previous declaration at position {}\"#,\n                pos1, pos2\n            ),\n        }\n    }\n}",
            "impl std::error::Error for AttrError {}"
        ],
        "events::attributes::Attribute": [
            "Clone",
            "PartialEq",
            "impl<'a> Attribute<'a> {\n    /// Returns the unescaped value.\n    ///\n    /// This is normally the value you are interested in. Escape sequences such as `&gt;` are\n    /// replaced with their unescaped equivalents such as `>`.\n    ///\n    /// This will allocate if the value contains any escape sequences.\n    ///\n    /// See also [`unescaped_value_with_custom_entities()`](#method.unescaped_value_with_custom_entities)\n    pub fn unescaped_value(&self) -> XmlResult<Cow<[u8]>> {\n        self.make_unescaped_value(None)\n    }\n\n    /// Returns the unescaped value, using custom entities.\n    ///\n    /// This is normally the value you are interested in. Escape sequences such as `&gt;` are\n    /// replaced with their unescaped equivalents such as `>`.\n    /// Additional entities can be provided in `custom_entities`.\n    ///\n    /// This will allocate if the value contains any escape sequences.\n    ///\n    /// See also [`unescaped_value()`](#method.unescaped_value)\n    ///\n    /// # Pre-condition\n    ///\n    /// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n    pub fn unescaped_value_with_custom_entities(\n        &self,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> XmlResult<Cow<[u8]>> {\n        self.make_unescaped_value(Some(custom_entities))\n    }\n\n    fn make_unescaped_value(\n        &self,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> XmlResult<Cow<[u8]>> {\n        do_unescape(&*self.value, custom_entities).map_err(Error::EscapeError)\n    }\n\n    /// Decode then unescapes the value\n    ///\n    /// This allocates a `String` in all cases. For performance reasons it might be a better idea to\n    /// instead use one of:\n    ///\n    /// * [`Reader::decode()`], as it only allocates when the decoding can't be performed otherwise.\n    /// * [`unescaped_value()`], as it doesn't allocate when no escape sequences are used.\n    ///\n    /// [`unescaped_value()`]: #method.unescaped_value\n    /// [`Reader::decode()`]: ../../reader/struct.Reader.html#method.decode\n    pub fn unescape_and_decode_value<B: BufRead>(&self, reader: &Reader<B>) -> XmlResult<String> {\n        self.do_unescape_and_decode_value(reader, None)\n    }\n\n    /// Decode then unescapes the value with custom entities\n    ///\n    /// This allocates a `String` in all cases. For performance reasons it might be a better idea to\n    /// instead use one of:\n    ///\n    /// * [`Reader::decode()`], as it only allocates when the decoding can't be performed otherwise.\n    /// * [`unescaped_value_with_custom_entities()`], as it doesn't allocate when no escape sequences are used.\n    ///\n    /// [`unescaped_value_with_custom_entities()`]: #method.unescaped_value_with_custom_entities\n    /// [`Reader::decode()`]: ../../reader/struct.Reader.html#method.decode\n    ///\n    /// # Pre-condition\n    ///\n    /// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n    pub fn unescape_and_decode_value_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> XmlResult<String> {\n        self.do_unescape_and_decode_value(reader, Some(custom_entities))\n    }\n\n    /// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n    #[cfg(feature = \"encoding\")]\n    fn do_unescape_and_decode_value<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> XmlResult<String> {\n        let decoded = reader.decode(&*self.value);\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }\n\n    #[cfg(not(feature = \"encoding\"))]\n    fn do_unescape_and_decode_value<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> XmlResult<String> {\n        let decoded = reader.decode(&*self.value)?;\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }\n\n    /// helper method to unescape then decode self using the reader encoding\n    /// but without BOM (Byte order mark)\n    ///\n    /// for performance reasons (could avoid allocating a `String`),\n    /// it might be wiser to manually use\n    /// 1. BytesText::unescaped()\n    /// 2. Reader::decode(...)\n    #[cfg(feature = \"encoding\")]\n    pub fn unescape_and_decode_without_bom<B: BufRead>(\n        &self,\n        reader: &mut Reader<B>,\n    ) -> XmlResult<String> {\n        self.do_unescape_and_decode_without_bom(reader, None)\n    }\n\n    /// helper method to unescape then decode self using the reader encoding\n    /// but without BOM (Byte order mark)\n    ///\n    /// for performance reasons (could avoid allocating a `String`),\n    /// it might be wiser to manually use\n    /// 1. BytesText::unescaped()\n    /// 2. Reader::decode(...)\n    #[cfg(not(feature = \"encoding\"))]\n    pub fn unescape_and_decode_without_bom<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n    ) -> XmlResult<String> {\n        self.do_unescape_and_decode_without_bom(reader, None)\n    }\n\n    /// helper method to unescape then decode self using the reader encoding with custom entities\n    /// but without BOM (Byte order mark)\n    ///\n    /// for performance reasons (could avoid allocating a `String`),\n    /// it might be wiser to manually use\n    /// 1. BytesText::unescaped()\n    /// 2. Reader::decode(...)\n    ///\n    /// # Pre-condition\n    ///\n    /// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n    #[cfg(feature = \"encoding\")]\n    pub fn unescape_and_decode_without_bom_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &mut Reader<B>,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> XmlResult<String> {\n        self.do_unescape_and_decode_without_bom(reader, Some(custom_entities))\n    }\n\n    /// helper method to unescape then decode self using the reader encoding with custom entities\n    /// but without BOM (Byte order mark)\n    ///\n    /// for performance reasons (could avoid allocating a `String`),\n    /// it might be wiser to manually use\n    /// 1. BytesText::unescaped()\n    /// 2. Reader::decode(...)\n    ///\n    /// # Pre-condition\n    ///\n    /// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n    #[cfg(not(feature = \"encoding\"))]\n    pub fn unescape_and_decode_without_bom_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> XmlResult<String> {\n        self.do_unescape_and_decode_without_bom(reader, Some(custom_entities))\n    }\n\n    #[cfg(feature = \"encoding\")]\n    fn do_unescape_and_decode_without_bom<B: BufRead>(\n        &self,\n        reader: &mut Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> XmlResult<String> {\n        let decoded = reader.decode_without_bom(&*self.value);\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }\n\n    #[cfg(not(feature = \"encoding\"))]\n    fn do_unescape_and_decode_without_bom<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> XmlResult<String> {\n        let decoded = reader.decode_without_bom(&*self.value)?;\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }\n}",
            "impl<'a> Debug for Attribute<'a> {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        write!(f, \"Attribute {{ key: \")?;\n        write_byte_string(f, self.key)?;\n        write!(f, \", value: \")?;\n        write_cow_string(f, &self.value)?;\n        write!(f, \" }}\")\n    }\n}",
            "impl<'a> From<(&'a [u8], &'a [u8])> for Attribute<'a> {\n    /// Creates new attribute from raw bytes.\n    /// Does not apply any transformation to both key and value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use pretty_assertions::assert_eq;\n    /// use quick_xml::events::attributes::Attribute;\n    ///\n    /// let features = Attribute::from((\"features\".as_bytes(), \"Bells &amp; whistles\".as_bytes()));\n    /// assert_eq!(features.value, \"Bells &amp; whistles\".as_bytes());\n    /// ```\n    fn from(val: (&'a [u8], &'a [u8])) -> Attribute<'a> {\n        Attribute {\n            key: val.0,\n            value: Cow::from(val.1),\n        }\n    }\n}",
            "impl<'a> From<(&'a str, &'a str)> for Attribute<'a> {\n    /// Creates new attribute from text representation.\n    /// Key is stored as-is, but the value will be escaped.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use pretty_assertions::assert_eq;\n    /// use quick_xml::events::attributes::Attribute;\n    ///\n    /// let features = Attribute::from((\"features\", \"Bells & whistles\"));\n    /// assert_eq!(features.value, \"Bells &amp; whistles\".as_bytes());\n    /// ```\n    fn from(val: (&'a str, &'a str)) -> Attribute<'a> {\n        Attribute {\n            key: val.0.as_bytes(),\n            value: escape(val.1.as_bytes()),\n        }\n    }\n}",
            "impl<'a> From<Attr<&'a [u8]>> for Attribute<'a> {\n    #[inline]\n    fn from(attr: Attr<&'a [u8]>) -> Self {\n        Self {\n            key: attr.key(),\n            value: Cow::Borrowed(attr.value()),\n        }\n    }\n}"
        ],
        "events::attributes::Attributes": [
            "Clone",
            "Debug",
            "impl<'a> Attributes<'a> {\n    /// Creates a new attribute iterator from a buffer.\n    pub fn new(buf: &'a [u8], pos: usize) -> Self {\n        Self {\n            bytes: buf,\n            state: IterState::new(pos, false),\n        }\n    }\n\n    /// Creates a new attribute iterator from a buffer, allowing HTML attribute syntax.\n    pub fn html(buf: &'a [u8], pos: usize) -> Self {\n        Self {\n            bytes: buf,\n            state: IterState::new(pos, true),\n        }\n    }\n\n    /// Changes whether attributes should be checked for uniqueness.\n    ///\n    /// The XML specification requires attribute keys in the same element to be unique. This check\n    /// can be disabled to improve performance slightly.\n    ///\n    /// (`true` by default)\n    pub fn with_checks(&mut self, val: bool) -> &mut Attributes<'a> {\n        self.state.check_duplicates = val;\n        self\n    }\n}",
            "impl<'a> FusedIterator for Attributes<'a> {}",
            "impl<'a> Iterator for Attributes<'a> {\n    type Item = Result<Attribute<'a>, AttrError>;\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }\n}"
        ],
        "events::attributes::IterState": [
            "Clone",
            "Debug",
            "impl IterState {\n    pub fn new(offset: usize, html: bool) -> Self {\n        Self {\n            state: State::Next(offset),\n            html,\n            check_duplicates: true,\n            keys: Vec::new(),\n        }\n    }\n\n    /// Recover from an error that could have been made on a previous step.\n    /// Returns an offset from which parsing should continue.\n    /// If there no input left, returns `None`.\n    fn recover(&self, slice: &[u8]) -> Option<usize> {\n        match self.state {\n            State::Done => None,\n            State::Next(offset) => Some(offset),\n            State::SkipValue(offset) => self.skip_value(slice, offset),\n            State::SkipEqValue(offset) => self.skip_eq_value(slice, offset),\n        }\n    }\n\n    /// Skip all characters up to first space symbol or end-of-input\n    #[inline]\n    fn skip_value(&self, slice: &[u8], offset: usize) -> Option<usize> {\n        let mut iter = (offset..).zip(slice[offset..].iter());\n\n        match iter.find(|(_, &b)| is_whitespace(b)) {\n            // Input: `    key  =  value `\n            //                     |    ^\n            //                offset    e\n            Some((e, _)) => Some(e),\n            // Input: `    key  =  value`\n            //                     |    ^\n            //                offset    e = len()\n            None => None,\n        }\n    }\n\n    /// Skip all characters up to first space symbol or end-of-input\n    #[inline]\n    fn skip_eq_value(&self, slice: &[u8], offset: usize) -> Option<usize> {\n        let mut iter = (offset..).zip(slice[offset..].iter());\n\n        // Skip all up to the quote and get the quote type\n        let quote = match iter.find(|(_, &b)| !is_whitespace(b)) {\n            // Input: `    key  =  \"`\n            //                  |  ^\n            //             offset\n            Some((_, b'\"')) => b'\"',\n            // Input: `    key  =  '`\n            //                  |  ^\n            //             offset\n            Some((_, b'\\'')) => b'\\'',\n\n            // Input: `    key  =  x`\n            //                  |  ^\n            //             offset\n            Some((offset, _)) => return self.skip_value(slice, offset),\n            // Input: `    key  =  `\n            //                  |  ^\n            //             offset\n            None => return None,\n        };\n\n        match iter.find(|(_, &b)| b == quote) {\n            // Input: `    key  =  \"   \"`\n            //                         ^\n            Some((e, b'\"')) => Some(e),\n            // Input: `    key  =  '   '`\n            //                         ^\n            Some((e, _)) => Some(e),\n\n            // Input: `    key  =  \"   `\n            // Input: `    key  =  '   `\n            //                         ^\n            // Closing quote not found\n            None => None,\n        }\n    }\n\n    #[inline]\n    fn check_for_duplicates(\n        &mut self,\n        slice: &[u8],\n        key: Range<usize>,\n    ) -> Result<Range<usize>, AttrError> {\n        if self.check_duplicates {\n            if let Some(prev) = self\n                .keys\n                .iter()\n                .find(|r| slice[(*r).clone()] == slice[key.clone()])\n            {\n                return Err(AttrError::Duplicated(key.start, prev.start));\n            }\n            self.keys.push(key.clone());\n        }\n        Ok(key)\n    }\n\n    /// # Parameters\n    ///\n    /// - `slice`: content of the tag, used for checking for duplicates\n    /// - `key`: Range of key in slice, if iterator in HTML mode\n    /// - `offset`: Position of error if iterator in XML mode\n    #[inline]\n    fn key_only(&mut self, slice: &[u8], key: Range<usize>, offset: usize) -> Option<AttrResult> {\n        Some(if self.html {\n            self.check_for_duplicates(slice, key).map(Attr::Empty)\n        } else {\n            Err(AttrError::ExpectedEq(offset))\n        })\n    }\n\n    #[inline]\n    fn double_q(&mut self, key: Range<usize>, value: Range<usize>) -> Option<AttrResult> {\n        self.state = State::Next(value.end + 1); // +1 for `\"`\n\n        Some(Ok(Attr::DoubleQ(key, value)))\n    }\n\n    #[inline]\n    fn single_q(&mut self, key: Range<usize>, value: Range<usize>) -> Option<AttrResult> {\n        self.state = State::Next(value.end + 1); // +1 for `'`\n\n        Some(Ok(Attr::SingleQ(key, value)))\n    }\n\n    pub fn next(&mut self, slice: &[u8]) -> Option<AttrResult> {\n        let mut iter = match self.recover(slice) {\n            Some(offset) => (offset..).zip(slice[offset..].iter()),\n            None => return None,\n        };\n\n        // Index where next key started\n        let start_key = match iter.find(|(_, &b)| !is_whitespace(b)) {\n            // Input: `    key`\n            //             ^\n            Some((s, _)) => s,\n            // Input: `    `\n            //             ^\n            None => {\n                // Because we reach end-of-input, stop iteration on next call\n                self.state = State::Done;\n                return None;\n            }\n        };\n        // Span of a key\n        let (key, offset) = match iter.find(|(_, &b)| b == b'=' || is_whitespace(b)) {\n            // Input: `    key=`\n            //             |  ^\n            //             s  e\n            Some((e, b'=')) => (start_key..e, e),\n\n            // Input: `    key `\n            //                ^\n            Some((e, _)) => match iter.find(|(_, &b)| !is_whitespace(b)) {\n                // Input: `    key  =`\n                //             |  | ^\n                //     start_key  e\n                Some((offset, b'=')) => (start_key..e, offset),\n                // Input: `    key  x`\n                //             |  | ^\n                //     start_key  e\n                // If HTML-like attributes is allowed, this is the result, otherwise error\n                Some((offset, _)) => {\n                    // In any case, recovering is not required\n                    self.state = State::Next(offset);\n                    return self.key_only(slice, start_key..e, offset);\n                }\n                // Input: `    key  `\n                //             |  | ^\n                //     start_key  e\n                // If HTML-like attributes is allowed, this is the result, otherwise error\n                None => {\n                    // Because we reach end-of-input, stop iteration on next call\n                    self.state = State::Done;\n                    return self.key_only(slice, start_key..e, slice.len());\n                }\n            },\n\n            // Input: `    key`\n            //             |  ^\n            //             s  e = len()\n            // If HTML-like attributes is allowed, this is the result, otherwise error\n            None => {\n                // Because we reach end-of-input, stop iteration on next call\n                self.state = State::Done;\n                let e = slice.len();\n                return self.key_only(slice, start_key..e, e);\n            }\n        };\n\n        let key = match self.check_for_duplicates(slice, key) {\n            Err(e) => {\n                self.state = State::SkipEqValue(offset);\n                return Some(Err(e));\n            }\n            Ok(key) => key,\n        };\n\n        ////////////////////////////////////////////////////////////////////////\n\n        // Gets the position of quote and quote type\n        let (start_value, quote) = match iter.find(|(_, &b)| !is_whitespace(b)) {\n            // Input: `    key  =  \"`\n            //                     ^\n            Some((s, b'\"')) => (s + 1, b'\"'),\n            // Input: `    key  =  '`\n            //                     ^\n            Some((s, b'\\'')) => (s + 1, b'\\''),\n\n            // Input: `    key  =  x`\n            //                     ^\n            // If HTML-like attributes is allowed, this is the start of the value\n            Some((s, _)) if self.html => {\n                // We do not check validity of attribute value characters as required\n                // according to https://html.spec.whatwg.org/#unquoted. It can be done\n                // during validation phase\n                let end = match iter.find(|(_, &b)| is_whitespace(b)) {\n                    // Input: `    key  =  value `\n                    //                     |    ^\n                    //                     s    e\n                    Some((e, _)) => e,\n                    // Input: `    key  =  value`\n                    //                     |    ^\n                    //                     s    e = len()\n                    None => slice.len(),\n                };\n                self.state = State::Next(end);\n                return Some(Ok(Attr::Unquoted(key, s..end)));\n            }\n            // Input: `    key  =  x`\n            //                     ^\n            Some((s, _)) => {\n                self.state = State::SkipValue(s);\n                return Some(Err(AttrError::UnquotedValue(s)));\n            }\n\n            // Input: `    key  =  `\n            //                     ^\n            None => {\n                // Because we reach end-of-input, stop iteration on next call\n                self.state = State::Done;\n                return Some(Err(AttrError::ExpectedValue(slice.len())));\n            }\n        };\n\n        match iter.find(|(_, &b)| b == quote) {\n            // Input: `    key  =  \"   \"`\n            //                         ^\n            Some((e, b'\"')) => self.double_q(key, start_value..e),\n            // Input: `    key  =  '   '`\n            //                         ^\n            Some((e, _)) => self.single_q(key, start_value..e),\n\n            // Input: `    key  =  \"   `\n            // Input: `    key  =  '   `\n            //                         ^\n            // Closing quote not found\n            None => {\n                // Because we reach end-of-input, stop iteration on next call\n                self.state = State::Done;\n                return Some(Err(AttrError::ExpectedQuote(slice.len(), quote)));\n            }\n        }\n    }\n}"
        ],
        "events::attributes::State": [
            "Clone",
            "Copy",
            "Debug"
        ],
        "reader::BangType": [
            "Debug",
            "PartialEq",
            "impl BangType {\n    #[inline(always)]\n    fn new(byte: Option<u8>) -> Result<Self> {\n        Ok(match byte {\n            Some(b'[') => Self::CData,\n            Some(b'-') => Self::Comment,\n            Some(b'D') | Some(b'd') => Self::DocType,\n            Some(b) => return Err(Error::UnexpectedBang(b)),\n            None => return Err(Error::UnexpectedEof(\"Bang\".to_string())),\n        })\n    }\n\n    /// If element is finished, returns its content up to `>` symbol and\n    /// an index of this symbol, otherwise returns `None`\n    #[inline(always)]\n    fn parse<'b>(&self, chunk: &'b [u8], offset: usize) -> Option<(&'b [u8], usize)> {\n        for i in memchr::memchr_iter(b'>', chunk) {\n            match self {\n                // Need to read at least 6 symbols (`!---->`) for properly finished comment\n                // <!----> - XML comment\n                //  012345 - i\n                Self::Comment => {\n                    if offset + i > 4 && chunk[..i].ends_with(b\"--\") {\n                        // We cannot strip last `--` from the buffer because we need it in case of\n                        // check_comments enabled option. XML standard requires that comment\n                        // will not end with `--->` sequence because this is a special case of\n                        // `--` in the comment (https://www.w3.org/TR/xml11/#sec-comments)\n                        return Some((&chunk[..i], i + 1)); // +1 for `>`\n                    }\n                }\n                Self::CData => {\n                    if chunk[..i].ends_with(b\"]]\") {\n                        return Some((&chunk[..i - 2], i + 1)); // +1 for `>`\n                    }\n                }\n                Self::DocType => {\n                    let content = &chunk[..i];\n                    let balance = memchr::memchr2_iter(b'<', b'>', content)\n                        .map(|p| if content[p] == b'<' { 1i32 } else { -1 })\n                        .sum::<i32>();\n                    if balance == 0 {\n                        return Some((content, i + 1)); // +1 for `>`\n                    }\n                }\n            }\n        }\n        None\n    }\n    #[inline]\n    fn to_err(self) -> Error {\n        let bang_str = match self {\n            Self::CData => \"CData\",\n            Self::Comment => \"Comment\",\n            Self::DocType => \"DOCTYPE\",\n        };\n        Error::UnexpectedEof(bang_str.to_string())\n    }\n}"
        ],
        "reader::Decoder": [
            "Clone",
            "Copy",
            "Debug",
            "impl Decoder {\n    #[cfg(not(feature = \"encoding\"))]\n    pub fn decode<'c>(&self, bytes: &'c [u8]) -> Result<&'c str> {\n        from_utf8(bytes).map_err(Error::Utf8)\n    }\n\n    #[cfg(not(feature = \"encoding\"))]\n    pub fn decode_owned<'c>(&self, bytes: Vec<u8>) -> Result<String> {\n        String::from_utf8(bytes).map_err(|e| Error::Utf8(e.utf8_error()))\n    }\n\n    #[cfg(feature = \"encoding\")]\n    pub fn decode<'c>(&self, bytes: &'c [u8]) -> Cow<'c, str> {\n        self.encoding.decode(bytes).0\n    }\n}"
        ],
        "reader::NamespaceEntry": [
            "Clone",
            "Debug",
            "impl NamespaceEntry {\n    /// Gets the namespace name (the URI) slice out of namespace buffer\n    ///\n    /// Returns `None` if namespace for this prefix was explicitly removed from\n    /// scope, using `xmlns[:prefix]=\"\"`\n    #[inline]\n    fn namespace<'b>(&self, buffer: &'b [u8]) -> Option<&'b [u8]> {\n        if self.value_len == 0 {\n            None\n        } else {\n            let start = self.start + self.prefix_len;\n            Some(&buffer[start..start + self.value_len])\n        }\n    }\n\n    /// Check if the namespace matches the potentially qualified name\n    #[inline]\n    fn is_match(&self, buffer: &[u8], qname: &[u8]) -> bool {\n        if self.prefix_len == 0 {\n            !qname.contains(&b':')\n        } else {\n            qname.get(self.prefix_len).map_or(false, |n| *n == b':')\n                && qname.starts_with(&buffer[self.start..self.start + self.prefix_len])\n        }\n    }\n}"
        ],
        "reader::NamespaceResolver": [
            "Clone",
            "Debug",
            "Default",
            "impl NamespaceResolver {\n    /// Finds a [namespace name] for a given qualified name of element, borrow it\n    /// from the specified buffer.\n    ///\n    /// Returns `None`, if:\n    /// - name is unqualified\n    /// - prefix not found in the current scope\n    /// - prefix was [unbound] using `xmlns:prefix=\"\"`\n    ///\n    /// # Lifetimes\n    ///\n    /// - `'n`: lifetime of an element name\n    /// - `'b`: lifetime of a namespaces buffer, where all found namespaces are stored\n    ///\n    /// [namespace name]: https://www.w3.org/TR/xml-names11/#dt-NSName\n    /// [unbound]: https://www.w3.org/TR/xml-names11/#scoping\n    #[inline]\n    fn find<'n, 'b>(&self, element_name: &'n [u8], buffer: &'b [u8]) -> Option<&'b [u8]> {\n        self.bindings\n            .iter()\n            .rfind(|n| n.is_match(buffer, element_name))\n            .and_then(|n| n.namespace(buffer))\n    }\n\n    /// Ends a top-most scope by popping all [namespace binding], that was added by\n    /// last call to [`Self::push()`].\n    ///\n    /// [namespace binding]: https://www.w3.org/TR/xml-names11/#dt-NSDecl\n    fn pop(&mut self, buffer: &mut Vec<u8>) {\n        if !self.pending_pop {\n            return;\n        }\n        self.pending_pop = false;\n        self.nesting_level -= 1;\n        let current_level = self.nesting_level;\n        // from the back (most deeply nested scope), look for the first scope that is still valid\n        match self.bindings.iter().rposition(|n| n.level <= current_level) {\n            // none of the namespaces are valid, remove all of them\n            None => {\n                buffer.clear();\n                self.bindings.clear();\n            }\n            // drop all namespaces past the last valid namespace\n            Some(last_valid_pos) => {\n                if let Some(len) = self.bindings.get(last_valid_pos + 1).map(|n| n.start) {\n                    buffer.truncate(len);\n                    self.bindings.truncate(last_valid_pos + 1);\n                }\n            }\n        }\n    }\n\n    /// Begins a new scope and add to it all [namespace bindings] that found in\n    /// the specified start element.\n    ///\n    /// [namespace binding]: https://www.w3.org/TR/xml-names11/#dt-NSDecl\n    fn push(&mut self, start: &BytesStart, buffer: &mut Vec<u8>) {\n        self.nesting_level += 1;\n        let level = self.nesting_level;\n        // adds new namespaces for attributes starting with 'xmlns:' and for the 'xmlns'\n        // (default namespace) attribute.\n        for a in start.attributes().with_checks(false) {\n            if let Ok(Attribute { key: k, value: v }) = a {\n                if k.starts_with(b\"xmlns\") {\n                    match k.get(5) {\n                        None => {\n                            let start = buffer.len();\n                            buffer.extend_from_slice(&*v);\n                            self.bindings.push(NamespaceEntry {\n                                start,\n                                prefix_len: 0,\n                                value_len: v.len(),\n                                level,\n                            });\n                        }\n                        Some(&b':') => {\n                            let start = buffer.len();\n                            buffer.extend_from_slice(&k[6..]);\n                            buffer.extend_from_slice(&*v);\n                            self.bindings.push(NamespaceEntry {\n                                start,\n                                prefix_len: k.len() - 6,\n                                value_len: v.len(),\n                                level,\n                            });\n                        }\n                        _ => break,\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    /// Resolves a potentially qualified **attribute name** into (namespace name, local name).\n    ///\n    /// *Qualified* attribute names have the form `prefix:local-name` where the `prefix` is defined\n    /// on any containing XML element via `xmlns:prefix=\"the:namespace:uri\"`. The namespace prefix\n    /// can be defined on the same element as the attribute in question.\n    ///\n    /// *Unqualified* attribute names do *not* inherit the current *default namespace*.\n    ///\n    /// # Lifetimes\n    ///\n    /// - `'n`: lifetime of an attribute or an element name\n    /// - `'b`: lifetime of a namespaces buffer, where all found namespaces are stored\n    #[inline]\n    fn resolve<'n, 'b>(\n        &self,\n        qname: &'n [u8],\n        buffer: &'b [u8],\n        use_default: bool,\n    ) -> (Option<&'b [u8]>, &'n [u8]) {\n        self.bindings\n            .iter()\n            .rfind(|n| n.is_match(buffer, qname))\n            .map_or((None, qname), |n| {\n                let len = n.prefix_len;\n                if len > 0 {\n                    (n.namespace(buffer), &qname[len + 1..])\n                } else if use_default {\n                    (n.namespace(buffer), qname)\n                } else {\n                    (None, qname)\n                }\n            })\n    }\n}"
        ],
        "reader::ReadElementState": [
            "Clone",
            "Copy",
            "impl ReadElementState {\n    /// Changes state by analyzing part of input.\n    /// Returns a tuple with part of chunk up to element closing symbol `>`\n    /// and a position after that symbol or `None` if such symbol was not found\n    #[inline(always)]\n    fn change<'b>(&mut self, chunk: &'b [u8]) -> Option<(&'b [u8], usize)> {\n        for i in memchr::memchr3_iter(b'>', b'\\'', b'\"', chunk) {\n            *self = match (*self, chunk[i]) {\n                // only allowed to match `>` while we are in state `Elem`\n                (Self::Elem, b'>') => return Some((&chunk[..i], i + 1)),\n                (Self::Elem, b'\\'') => Self::SingleQ,\n                (Self::Elem, b'\\\"') => Self::DoubleQ,\n\n                // the only end_byte that gets us out if the same character\n                (Self::SingleQ, b'\\'') | (Self::DoubleQ, b'\"') => Self::Elem,\n\n                // all other bytes: no state change\n                _ => *self,\n            };\n        }\n        None\n    }\n}"
        ],
        "reader::Reader": [
            "Clone",
            "impl Reader<BufReader<File>> {\n    /// Creates an XML reader from a file path.\n    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Reader<BufReader<File>>> {\n        let file = File::open(path).map_err(Error::Io)?;\n        let reader = BufReader::new(file);\n        Ok(Reader::from_reader(reader))\n    }\n}",
            "impl<'a> Reader<&'a [u8]> {\n    /// Creates an XML reader from a string slice.\n    pub fn from_str(s: &'a str) -> Reader<&'a [u8]> {\n        Reader::from_reader(s.as_bytes())\n    }\n\n    /// Creates an XML reader from a slice of bytes.\n    pub fn from_bytes(s: &'a [u8]) -> Reader<&'a [u8]> {\n        Reader::from_reader(s)\n    }\n\n    /// Read an event that borrows from the input rather than a buffer.\n    #[inline]\n    pub fn read_event_unbuffered(&mut self) -> Result<Event<'a>> {\n        self.read_event_buffered(())\n    }\n\n    /// Reads until end element is found\n    ///\n    /// Manages nested cases where parent and child elements have the same name\n    pub fn read_to_end_unbuffered<K: AsRef<[u8]>>(&mut self, end: K) -> Result<()> {\n        let mut depth = 0;\n        let end = end.as_ref();\n        loop {\n            match self.read_event_unbuffered() {\n                Ok(Event::End(ref e)) if e.name() == end => {\n                    if depth == 0 {\n                        return Ok(());\n                    }\n                    depth -= 1;\n                }\n                Ok(Event::Start(ref e)) if e.name() == end => depth += 1,\n                Err(e) => return Err(e),\n                Ok(Event::Eof) => {\n                    return Err(Error::UnexpectedEof(format!(\"</{:?}>\", from_utf8(end))));\n                }\n                _ => (),\n            }\n        }\n    }\n}",
            "impl<R: BufRead> Reader<R> {\n    /// Creates a `Reader` that reads from a reader implementing `BufRead`.\n    pub fn from_reader(reader: R) -> Reader<R> {\n        Reader {\n            reader,\n            opened_buffer: Vec::new(),\n            opened_starts: Vec::new(),\n            tag_state: TagState::Closed,\n            expand_empty_elements: false,\n            trim_text_start: false,\n            trim_text_end: false,\n            trim_markup_names_in_closing_tags: true,\n            check_end_names: true,\n            buf_position: 0,\n            check_comments: false,\n            ns_resolver: NamespaceResolver::default(),\n            #[cfg(feature = \"encoding\")]\n            encoding: ::encoding_rs::UTF_8,\n            #[cfg(feature = \"encoding\")]\n            is_encoding_set: false,\n        }\n    }\n\n    /// Changes whether empty elements should be split into an `Open` and a `Close` event.\n    ///\n    /// When set to `true`, all [`Empty`] events produced by a self-closing tag like `<tag/>` are\n    /// expanded into a [`Start`] event followed by an [`End`] event. When set to `false` (the\n    /// default), those tags are represented by an [`Empty`] event instead.\n    ///\n    /// Note, that setting this to `true` will lead to additional allocates that\n    /// needed to store tag name for an [`End`] event. There is no additional\n    /// allocation, however, if [`Self::check_end_names()`] is also set.\n    ///\n    /// (`false` by default)\n    ///\n    /// [`Empty`]: events/enum.Event.html#variant.Empty\n    /// [`Start`]: events/enum.Event.html#variant.Start\n    /// [`End`]: events/enum.Event.html#variant.End\n    pub fn expand_empty_elements(&mut self, val: bool) -> &mut Reader<R> {\n        self.expand_empty_elements = val;\n        self\n    }\n\n    /// Changes whether whitespace before and after character data should be removed.\n    ///\n    /// When set to `true`, all [`Text`] events are trimmed. If they are empty, no event will be\n    /// pushed.\n    ///\n    /// (`false` by default)\n    ///\n    /// [`Text`]: events/enum.Event.html#variant.Text\n    pub fn trim_text(&mut self, val: bool) -> &mut Reader<R> {\n        self.trim_text_start = val;\n        self.trim_text_end = val;\n        self\n    }\n\n    /// Changes whether whitespace after character data should be removed.\n    ///\n    /// When set to `true`, trailing whitespace is trimmed in [`Text`] events.\n    ///\n    /// (`false` by default)\n    ///\n    /// [`Text`]: events/enum.Event.html#variant.Text\n    pub fn trim_text_end(&mut self, val: bool) -> &mut Reader<R> {\n        self.trim_text_end = val;\n        self\n    }\n\n    /// Changes whether trailing whitespaces after the markup name are trimmed in closing tags\n    /// `</a >`.\n    ///\n    /// If true the emitted [`End`] event is stripped of trailing whitespace after the markup name.\n    ///\n    /// Note that if set to `false` and `check_end_names` is true the comparison of markup names is\n    /// going to fail erronously if a closing tag contains trailing whitespaces.\n    ///\n    /// (`true` by default)\n    ///\n    /// [`End`]: events/enum.Event.html#variant.End\n    pub fn trim_markup_names_in_closing_tags(&mut self, val: bool) -> &mut Reader<R> {\n        self.trim_markup_names_in_closing_tags = val;\n        self\n    }\n\n    /// Changes whether mismatched closing tag names should be detected.\n    ///\n    /// When set to `false`, it won't check if a closing tag matches the corresponding opening tag.\n    /// For example, `<mytag></different_tag>` will be permitted.\n    ///\n    /// If the XML is known to be sane (already processed, etc.) this saves extra time.\n    ///\n    /// Note that the emitted [`End`] event will not be modified if this is disabled, ie. it will\n    /// contain the data of the mismatched end tag.\n    ///\n    /// Note, that setting this to `true` will lead to additional allocates that\n    /// needed to store tag name for an [`End`] event. There is no additional\n    /// allocation, however, if [`Self::expand_empty_elements()`] is also set.\n    ///\n    /// (`true` by default)\n    ///\n    /// [`End`]: events/enum.Event.html#variant.End\n    pub fn check_end_names(&mut self, val: bool) -> &mut Reader<R> {\n        self.check_end_names = val;\n        self\n    }\n\n    /// Changes whether comments should be validated.\n    ///\n    /// When set to `true`, every [`Comment`] event will be checked for not containing `--`, which\n    /// is not allowed in XML comments. Most of the time we don't want comments at all so we don't\n    /// really care about comment correctness, thus the default value is `false` to improve\n    /// performance.\n    ///\n    /// (`false` by default)\n    ///\n    /// [`Comment`]: events/enum.Event.html#variant.Comment\n    pub fn check_comments(&mut self, val: bool) -> &mut Reader<R> {\n        self.check_comments = val;\n        self\n    }\n\n    /// Gets the current byte position in the input data.\n    ///\n    /// Useful when debugging errors.\n    pub fn buffer_position(&self) -> usize {\n        // when internal state is Opened, we have actually read until '<',\n        // which we don't want to show\n        if let TagState::Opened = self.tag_state {\n            self.buf_position - 1\n        } else {\n            self.buf_position\n        }\n    }\n\n    /// private function to read until '<' is found\n    /// return a `Text` event\n    fn read_until_open<'i, B>(&mut self, buf: B) -> Result<Event<'i>>\n    where\n        R: XmlSource<'i, B>,\n    {\n        self.tag_state = TagState::Opened;\n\n        if self.trim_text_start {\n            self.reader.skip_whitespace(&mut self.buf_position)?;\n            if self.reader.skip_one(b'<', &mut self.buf_position)? {\n                return self.read_event_buffered(buf);\n            }\n        }\n\n        match self\n            .reader\n            .read_bytes_until(b'<', buf, &mut self.buf_position)\n        {\n            Ok(Some(bytes)) if self.trim_text_end => {\n                // Skip the ending '<\n                let len = bytes\n                    .iter()\n                    .rposition(|&b| !is_whitespace(b))\n                    .map_or_else(|| bytes.len(), |p| p + 1);\n                Ok(Event::Text(BytesText::from_escaped(&bytes[..len])))\n            }\n            Ok(Some(bytes)) => Ok(Event::Text(BytesText::from_escaped(bytes))),\n            Ok(None) => Ok(Event::Eof),\n            Err(e) => Err(e),\n        }\n    }\n\n    /// Private function to read until `>` is found. This function expects that\n    /// it was called just after encounter a `<` symbol.\n    fn read_until_close<'i, B>(&mut self, buf: B) -> Result<Event<'i>>\n    where\n        R: XmlSource<'i, B>,\n    {\n        self.tag_state = TagState::Closed;\n\n        match self.reader.peek_one() {\n            // `<!` - comment, CDATA or DOCTYPE declaration\n            Ok(Some(b'!')) => match self.reader.read_bang_element(buf, &mut self.buf_position) {\n                Ok(None) => Ok(Event::Eof),\n                Ok(Some((bang_type, bytes))) => self.read_bang(bang_type, bytes),\n                Err(e) => Err(e),\n            },\n            // `</` - closing tag\n            Ok(Some(b'/')) => match self\n                .reader\n                .read_bytes_until(b'>', buf, &mut self.buf_position)\n            {\n                Ok(None) => Ok(Event::Eof),\n                Ok(Some(bytes)) => self.read_end(bytes),\n                Err(e) => Err(e),\n            },\n            // `<?` - processing instruction\n            Ok(Some(b'?')) => match self\n                .reader\n                .read_bytes_until(b'>', buf, &mut self.buf_position)\n            {\n                Ok(None) => Ok(Event::Eof),\n                Ok(Some(bytes)) => self.read_question_mark(bytes),\n                Err(e) => Err(e),\n            },\n            // `<...` - opening or self-closed tag\n            Ok(Some(_)) => match self.reader.read_element(buf, &mut self.buf_position) {\n                Ok(None) => Ok(Event::Eof),\n                Ok(Some(bytes)) => self.read_start(bytes),\n                Err(e) => Err(e),\n            },\n            Ok(None) => Ok(Event::Eof),\n            Err(e) => Err(e),\n        }\n    }\n\n    /// reads `BytesElement` starting with a `/`,\n    /// if `self.check_end_names`, checks that element matches last opened element\n    /// return `End` event\n    fn read_end<'a, 'b>(&'a mut self, buf: &'b [u8]) -> Result<Event<'b>> {\n        // XML standard permits whitespaces after the markup name in closing tags.\n        // Let's strip them from the buffer before comparing tag names.\n        let name = if self.trim_markup_names_in_closing_tags {\n            if let Some(pos_end_name) = buf[1..].iter().rposition(|&b| !b.is_ascii_whitespace()) {\n                let (name, _) = buf[1..].split_at(pos_end_name + 1);\n                name\n            } else {\n                &buf[1..]\n            }\n        } else {\n            &buf[1..]\n        };\n        if self.check_end_names {\n            let mismatch_err = |expected: &[u8], found: &[u8], buf_position: &mut usize| {\n                *buf_position -= buf.len();\n                Err(Error::EndEventMismatch {\n                    expected: from_utf8(expected).unwrap_or(\"\").to_owned(),\n                    found: from_utf8(found).unwrap_or(\"\").to_owned(),\n                })\n            };\n            match self.opened_starts.pop() {\n                Some(start) => {\n                    let expected = &self.opened_buffer[start..];\n                    if name != expected {\n                        mismatch_err(expected, name, &mut self.buf_position)\n                    } else {\n                        self.opened_buffer.truncate(start);\n                        Ok(Event::End(BytesEnd::borrowed(name)))\n                    }\n                }\n                None => mismatch_err(b\"\", &buf[1..], &mut self.buf_position),\n            }\n        } else {\n            Ok(Event::End(BytesEnd::borrowed(name)))\n        }\n    }\n\n    /// reads `BytesElement` starting with a `!`,\n    /// return `Comment`, `CData` or `DocType` event\n    fn read_bang<'a, 'b>(&'a mut self, bang_type: BangType, buf: &'b [u8]) -> Result<Event<'b>> {\n        let uncased_starts_with = |string: &[u8], prefix: &[u8]| {\n            string.len() >= prefix.len() && string[..prefix.len()].eq_ignore_ascii_case(prefix)\n        };\n\n        let len = buf.len();\n        match bang_type {\n            BangType::Comment if buf.starts_with(b\"!--\") => {\n                if self.check_comments {\n                    // search if '--' not in comments\n                    if let Some(p) = memchr::memchr_iter(b'-', &buf[3..len - 2])\n                        .position(|p| buf[3 + p + 1] == b'-')\n                    {\n                        self.buf_position += len - p;\n                        return Err(Error::UnexpectedToken(\"--\".to_string()));\n                    }\n                }\n                Ok(Event::Comment(BytesText::from_escaped(&buf[3..len - 2])))\n            }\n            BangType::CData if uncased_starts_with(buf, b\"![CDATA[\") => {\n                Ok(Event::CData(BytesCData::new(&buf[8..])))\n            }\n            BangType::DocType if uncased_starts_with(buf, b\"!DOCTYPE\") => {\n                let start = buf[8..]\n                    .iter()\n                    .position(|b| !is_whitespace(*b))\n                    .unwrap_or_else(|| len - 8);\n                debug_assert!(start < len - 8, \"DocType must have a name\");\n                Ok(Event::DocType(BytesText::from_escaped(&buf[8 + start..])))\n            }\n            _ => Err(bang_type.to_err()),\n        }\n    }\n\n    /// reads `BytesElement` starting with a `?`,\n    /// return `Decl` or `PI` event\n    fn read_question_mark<'a, 'b>(&'a mut self, buf: &'b [u8]) -> Result<Event<'b>> {\n        let len = buf.len();\n        if len > 2 && buf[len - 1] == b'?' {\n            if len > 5 && &buf[1..4] == b\"xml\" && is_whitespace(buf[4]) {\n                let event = BytesDecl::from_start(BytesStart::borrowed(&buf[1..len - 1], 3));\n\n                // Try getting encoding from the declaration event\n                #[cfg(feature = \"encoding\")]\n                if let Some(enc) = event.encoder() {\n                    self.encoding = enc;\n                    self.is_encoding_set = true;\n                }\n\n                Ok(Event::Decl(event))\n            } else {\n                Ok(Event::PI(BytesText::from_escaped(&buf[1..len - 1])))\n            }\n        } else {\n            self.buf_position -= len;\n            Err(Error::UnexpectedEof(\"XmlDecl\".to_string()))\n        }\n    }\n\n    #[inline]\n    fn close_expanded_empty(&mut self) -> Result<Event<'static>> {\n        self.tag_state = TagState::Closed;\n        let name = self\n            .opened_buffer\n            .split_off(self.opened_starts.pop().unwrap());\n        Ok(Event::End(BytesEnd::owned(name)))\n    }\n\n    /// reads `BytesElement` starting with any character except `/`, `!` or ``?`\n    /// return `Start` or `Empty` event\n    fn read_start<'a, 'b>(&'a mut self, buf: &'b [u8]) -> Result<Event<'b>> {\n        // TODO: do this directly when reading bufreader ...\n        let len = buf.len();\n        let name_end = buf.iter().position(|&b| is_whitespace(b)).unwrap_or(len);\n        if let Some(&b'/') = buf.last() {\n            let end = if name_end < len { name_end } else { len - 1 };\n            if self.expand_empty_elements {\n                self.tag_state = TagState::Empty;\n                self.opened_starts.push(self.opened_buffer.len());\n                self.opened_buffer.extend(&buf[..end]);\n                Ok(Event::Start(BytesStart::borrowed(&buf[..len - 1], end)))\n            } else {\n                Ok(Event::Empty(BytesStart::borrowed(&buf[..len - 1], end)))\n            }\n        } else {\n            if self.check_end_names {\n                self.opened_starts.push(self.opened_buffer.len());\n                self.opened_buffer.extend(&buf[..name_end]);\n            }\n            Ok(Event::Start(BytesStart::borrowed(buf, name_end)))\n        }\n    }\n\n    /// Reads the next `Event`.\n    ///\n    /// This is the main entry point for reading XML `Event`s.\n    ///\n    /// `Event`s borrow `buf` and can be converted to own their data if needed (uses `Cow`\n    /// internally).\n    ///\n    /// Having the possibility to control the internal buffers gives you some additional benefits\n    /// such as:\n    ///\n    /// - Reduce the number of allocations by reusing the same buffer. For constrained systems,\n    ///   you can call `buf.clear()` once you are done with processing the event (typically at the\n    ///   end of your loop).\n    /// - Reserve the buffer length if you know the file size (using `Vec::with_capacity`).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use quick_xml::Reader;\n    /// use quick_xml::events::Event;\n    ///\n    /// let xml = r#\"<tag1 att1 = \"test\">\n    ///                 <tag2><!--Test comment-->Test</tag2>\n    ///                 <tag2>Test 2</tag2>\n    ///             </tag1>\"#;\n    /// let mut reader = Reader::from_str(xml);\n    /// reader.trim_text(true);\n    /// let mut count = 0;\n    /// let mut buf = Vec::new();\n    /// let mut txt = Vec::new();\n    /// loop {\n    ///     match reader.read_event(&mut buf) {\n    ///         Ok(Event::Start(ref e)) => count += 1,\n    ///         Ok(Event::Text(e)) => txt.push(e.unescape_and_decode(&reader).expect(\"Error!\")),\n    ///         Err(e) => panic!(\"Error at position {}: {:?}\", reader.buffer_position(), e),\n    ///         Ok(Event::Eof) => break,\n    ///         _ => (),\n    ///     }\n    ///     buf.clear();\n    /// }\n    /// println!(\"Found {} start events\", count);\n    /// println!(\"Text events: {:?}\", txt);\n    /// ```\n    #[inline]\n    pub fn read_event<'a, 'b>(&'a mut self, buf: &'b mut Vec<u8>) -> Result<Event<'b>> {\n        self.read_event_buffered(buf)\n    }\n\n    /// Read text into the given buffer, and return an event that borrows from\n    /// either that buffer or from the input itself, based on the type of the\n    /// reader.\n    fn read_event_buffered<'i, B>(&mut self, buf: B) -> Result<Event<'i>>\n    where\n        R: XmlSource<'i, B>,\n    {\n        let event = match self.tag_state {\n            TagState::Opened => self.read_until_close(buf),\n            TagState::Closed => self.read_until_open(buf),\n            TagState::Empty => self.close_expanded_empty(),\n            TagState::Exit => return Ok(Event::Eof),\n        };\n        match event {\n            Err(_) | Ok(Event::Eof) => self.tag_state = TagState::Exit,\n            _ => {}\n        }\n        event\n    }\n\n    /// Resolves a potentially qualified **event name** into (namespace name, local name).\n    ///\n    /// *Qualified* attribute names have the form `prefix:local-name` where the`prefix` is defined\n    /// on any containing XML element via `xmlns:prefix=\"the:namespace:uri\"`. The namespace prefix\n    /// can be defined on the same element as the attribute in question.\n    ///\n    /// *Unqualified* event inherits the current *default namespace*.\n    #[inline]\n    pub fn event_namespace<'a, 'b, 'c>(\n        &'a self,\n        qname: &'b [u8],\n        namespace_buffer: &'c [u8],\n    ) -> (Option<&'c [u8]>, &'b [u8]) {\n        self.ns_resolver.resolve(qname, namespace_buffer, true)\n    }\n\n    /// Resolves a potentially qualified **attribute name** into (namespace name, local name).\n    ///\n    /// *Qualified* attribute names have the form `prefix:local-name` where the`prefix` is defined\n    /// on any containing XML element via `xmlns:prefix=\"the:namespace:uri\"`. The namespace prefix\n    /// can be defined on the same element as the attribute in question.\n    ///\n    /// *Unqualified* attribute names do *not* inherit the current *default namespace*.\n    #[inline]\n    pub fn attribute_namespace<'a, 'b, 'c>(\n        &'a self,\n        qname: &'b [u8],\n        namespace_buffer: &'c [u8],\n    ) -> (Option<&'c [u8]>, &'b [u8]) {\n        self.ns_resolver.resolve(qname, namespace_buffer, false)\n    }\n\n    /// Reads the next event and resolves its namespace (if applicable).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::str::from_utf8;\n    /// use quick_xml::Reader;\n    /// use quick_xml::events::Event;\n    ///\n    /// let xml = r#\"<x:tag1 xmlns:x=\"www.xxxx\" xmlns:y=\"www.yyyy\" att1 = \"test\">\n    ///                 <y:tag2><!--Test comment-->Test</y:tag2>\n    ///                 <y:tag2>Test 2</y:tag2>\n    ///             </x:tag1>\"#;\n    /// let mut reader = Reader::from_str(xml);\n    /// reader.trim_text(true);\n    /// let mut count = 0;\n    /// let mut buf = Vec::new();\n    /// let mut ns_buf = Vec::new();\n    /// let mut txt = Vec::new();\n    /// loop {\n    ///     match reader.read_namespaced_event(&mut buf, &mut ns_buf) {\n    ///         Ok((ref ns, Event::Start(ref e))) => {\n    ///             count += 1;\n    ///             match (*ns, e.local_name()) {\n    ///                 (Some(b\"www.xxxx\"), b\"tag1\") => (),\n    ///                 (Some(b\"www.yyyy\"), b\"tag2\") => (),\n    ///                 (ns, n) => panic!(\"Namespace and local name mismatch\"),\n    ///             }\n    ///             println!(\"Resolved namespace: {:?}\", ns.and_then(|ns| from_utf8(ns).ok()));\n    ///         }\n    ///         Ok((_, Event::Text(e))) => {\n    ///             txt.push(e.unescape_and_decode(&reader).expect(\"Error!\"))\n    ///         },\n    ///         Err(e) => panic!(\"Error at position {}: {:?}\", reader.buffer_position(), e),\n    ///         Ok((_, Event::Eof)) => break,\n    ///         _ => (),\n    ///     }\n    ///     buf.clear();\n    /// }\n    /// println!(\"Found {} start events\", count);\n    /// println!(\"Text events: {:?}\", txt);\n    /// ```\n    pub fn read_namespaced_event<'a, 'b, 'c>(\n        &'a mut self,\n        buf: &'b mut Vec<u8>,\n        namespace_buffer: &'c mut Vec<u8>,\n    ) -> Result<(Option<&'c [u8]>, Event<'b>)> {\n        self.ns_resolver.pop(namespace_buffer);\n        match self.read_event(buf) {\n            Ok(Event::Eof) => Ok((None, Event::Eof)),\n            Ok(Event::Start(e)) => {\n                self.ns_resolver.push(&e, namespace_buffer);\n                Ok((\n                    self.ns_resolver.find(e.name(), &**namespace_buffer),\n                    Event::Start(e),\n                ))\n            }\n            Ok(Event::Empty(e)) => {\n                // For empty elements we need to 'artificially' keep the namespace scope on the\n                // stack until the next `next()` call occurs.\n                // Otherwise the caller has no chance to use `resolve` in the context of the\n                // namespace declarations that are 'in scope' for the empty element alone.\n                // Ex: <img rdf:nodeID=\"abc\" xmlns:rdf=\"urn:the-rdf-uri\" />\n                self.ns_resolver.push(&e, namespace_buffer);\n                // notify next `read_namespaced_event()` invocation that it needs to pop this\n                // namespace scope\n                self.ns_resolver.pending_pop = true;\n                Ok((\n                    self.ns_resolver.find(e.name(), &**namespace_buffer),\n                    Event::Empty(e),\n                ))\n            }\n            Ok(Event::End(e)) => {\n                // notify next `read_namespaced_event()` invocation that it needs to pop this\n                // namespace scope\n                self.ns_resolver.pending_pop = true;\n                Ok((\n                    self.ns_resolver.find(e.name(), &**namespace_buffer),\n                    Event::End(e),\n                ))\n            }\n            Ok(e) => Ok((None, e)),\n            Err(e) => Err(e),\n        }\n    }\n\n    /// Returns the `Reader`s encoding.\n    ///\n    /// The used encoding may change after parsing the XML declaration.\n    ///\n    /// This encoding will be used by [`decode`].\n    ///\n    /// [`decode`]: #method.decode\n    #[cfg(feature = \"encoding\")]\n    pub fn encoding(&self) -> &'static Encoding {\n        self.encoding\n    }\n\n    /// Decodes a slice using the encoding specified in the XML declaration.\n    ///\n    /// Decode `bytes` with BOM sniffing and with malformed sequences replaced with the\n    /// `U+FFFD REPLACEMENT CHARACTER`.\n    ///\n    /// If no encoding is specified, defaults to UTF-8.\n    #[inline]\n    #[cfg(feature = \"encoding\")]\n    pub fn decode<'b, 'c>(&'b self, bytes: &'c [u8]) -> Cow<'c, str> {\n        self.encoding.decode(bytes).0\n    }\n\n    /// Decodes a UTF8 slice without BOM (Byte order mark) regardless of XML declaration.\n    ///\n    /// Decode `bytes` without BOM and with malformed sequences replaced with the\n    /// `U+FFFD REPLACEMENT CHARACTER`.\n    ///\n    /// # Note\n    ///\n    /// If you instead want to use XML declared encoding, use the `encoding` feature\n    #[inline]\n    #[cfg(not(feature = \"encoding\"))]\n    pub fn decode_without_bom<'c>(&self, bytes: &'c [u8]) -> Result<&'c str> {\n        if bytes.starts_with(b\"\\xEF\\xBB\\xBF\") {\n            from_utf8(&bytes[3..]).map_err(Error::Utf8)\n        } else {\n            from_utf8(bytes).map_err(Error::Utf8)\n        }\n    }\n\n    /// Decodes a slice using without BOM (Byte order mark) the encoding specified in the XML declaration.\n    ///\n    /// Decode `bytes` without BOM and with malformed sequences replaced with the\n    /// `U+FFFD REPLACEMENT CHARACTER`.\n    ///\n    /// If no encoding is specified, defaults to UTF-8.\n    #[inline]\n    #[cfg(feature = \"encoding\")]\n    pub fn decode_without_bom<'b, 'c>(&'b mut self, mut bytes: &'c [u8]) -> Cow<'c, str> {\n        if self.is_encoding_set {\n            return self.encoding.decode_with_bom_removal(bytes).0;\n        }\n        if bytes.starts_with(b\"\\xEF\\xBB\\xBF\") {\n            self.is_encoding_set = true;\n            bytes = &bytes[3..];\n        } else if bytes.starts_with(b\"\\xFF\\xFE\") {\n            self.is_encoding_set = true;\n            self.encoding = UTF_16LE;\n            bytes = &bytes[2..];\n        } else if bytes.starts_with(b\"\\xFE\\xFF\") {\n            self.is_encoding_set = true;\n            self.encoding = UTF_16BE;\n            bytes = &bytes[3..];\n        };\n        self.encoding.decode_without_bom_handling(bytes).0\n    }\n\n    /// Decodes a UTF8 slice regardless of XML declaration.\n    ///\n    /// Decode `bytes` with BOM sniffing and with malformed sequences replaced with the\n    /// `U+FFFD REPLACEMENT CHARACTER`.\n    ///\n    /// # Note\n    ///\n    /// If you instead want to use XML declared encoding, use the `encoding` feature\n    #[inline]\n    #[cfg(not(feature = \"encoding\"))]\n    pub fn decode<'c>(&self, bytes: &'c [u8]) -> Result<&'c str> {\n        from_utf8(bytes).map_err(Error::Utf8)\n    }\n\n    /// Get utf8 decoder\n    #[cfg(feature = \"encoding\")]\n    pub fn decoder(&self) -> Decoder {\n        Decoder {\n            encoding: self.encoding,\n        }\n    }\n\n    /// Get utf8 decoder\n    #[cfg(not(feature = \"encoding\"))]\n    pub fn decoder(&self) -> Decoder {\n        Decoder\n    }\n\n    /// Reads until end element is found\n    ///\n    /// Manages nested cases where parent and child elements have the same name\n    pub fn read_to_end<K: AsRef<[u8]>>(&mut self, end: K, buf: &mut Vec<u8>) -> Result<()> {\n        let mut depth = 0;\n        let end = end.as_ref();\n        loop {\n            match self.read_event(buf) {\n                Ok(Event::End(ref e)) if e.name() == end => {\n                    if depth == 0 {\n                        return Ok(());\n                    }\n                    depth -= 1;\n                }\n                Ok(Event::Start(ref e)) if e.name() == end => depth += 1,\n                Err(e) => return Err(e),\n                Ok(Event::Eof) => {\n                    return Err(Error::UnexpectedEof(format!(\"</{:?}>\", from_utf8(end))));\n                }\n                _ => (),\n            }\n            buf.clear();\n        }\n    }\n\n    /// Reads optional text between start and end tags.\n    ///\n    /// If the next event is a [`Text`] event, returns the decoded and unescaped content as a\n    /// `String`. If the next event is an [`End`] event, returns the empty string. In all other\n    /// cases, returns an error.\n    ///\n    /// Any text will be decoded using the XML encoding specified in the XML declaration (or UTF-8\n    /// if none is specified).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use pretty_assertions::assert_eq;\n    /// use quick_xml::Reader;\n    /// use quick_xml::events::Event;\n    ///\n    /// let mut xml = Reader::from_reader(b\"\n    ///     <a>&lt;b&gt;</a>\n    ///     <a></a>\n    /// \" as &[u8]);\n    /// xml.trim_text(true);\n    ///\n    /// let expected = [\"<b>\", \"\"];\n    /// for &content in expected.iter() {\n    ///     match xml.read_event(&mut Vec::new()) {\n    ///         Ok(Event::Start(ref e)) => {\n    ///             assert_eq!(&xml.read_text(e.name(), &mut Vec::new()).unwrap(), content);\n    ///         },\n    ///         e => panic!(\"Expecting Start event, found {:?}\", e),\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`Text`]: events/enum.Event.html#variant.Text\n    /// [`End`]: events/enum.Event.html#variant.End\n    pub fn read_text<K: AsRef<[u8]>>(&mut self, end: K, buf: &mut Vec<u8>) -> Result<String> {\n        let s = match self.read_event(buf) {\n            Ok(Event::Text(e)) => e.unescape_and_decode(self),\n            Ok(Event::End(ref e)) if e.name() == end.as_ref() => return Ok(\"\".to_string()),\n            Err(e) => return Err(e),\n            Ok(Event::Eof) => return Err(Error::UnexpectedEof(\"Text\".to_string())),\n            _ => return Err(Error::TextNotFound),\n        };\n        self.read_to_end(end, buf)?;\n        s\n    }\n\n    /// Consumes `Reader` returning the underlying reader\n    ///\n    /// Can be used to compute line and column of a parsing error position\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use pretty_assertions::assert_eq;\n    /// use std::{str, io::Cursor};\n    /// use quick_xml::Reader;\n    /// use quick_xml::events::Event;\n    ///\n    /// let xml = r#\"<tag1 att1 = \"test\">\n    ///                 <tag2><!--Test comment-->Test</tag2>\n    ///                 <tag3>Test 2</tag3>\n    ///             </tag1>\"#;\n    /// let mut reader = Reader::from_reader(Cursor::new(xml.as_bytes()));\n    /// let mut buf = Vec::new();\n    ///\n    /// fn into_line_and_column(reader: Reader<Cursor<&[u8]>>) -> (usize, usize) {\n    ///     let end_pos = reader.buffer_position();\n    ///     let mut cursor = reader.into_inner();\n    ///     let s = String::from_utf8(cursor.into_inner()[0..end_pos].to_owned())\n    ///         .expect(\"can't make a string\");\n    ///     let mut line = 1;\n    ///     let mut column = 0;\n    ///     for c in s.chars() {\n    ///         if c == '\\n' {\n    ///             line += 1;\n    ///             column = 0;\n    ///         } else {\n    ///             column += 1;\n    ///         }\n    ///     }\n    ///     (line, column)\n    /// }\n    ///\n    /// loop {\n    ///     match reader.read_event(&mut buf) {\n    ///         Ok(Event::Start(ref e)) => match e.name() {\n    ///             b\"tag1\" | b\"tag2\" => (),\n    ///             tag => {\n    ///                 assert_eq!(b\"tag3\", tag);\n    ///                 assert_eq!((3, 22), into_line_and_column(reader));\n    ///                 break;\n    ///             }\n    ///         },\n    ///         Ok(Event::Eof) => unreachable!(),\n    ///         _ => (),\n    ///     }\n    ///     buf.clear();\n    /// }\n    /// ```\n    pub fn into_inner(self) -> R {\n        self.reader\n    }\n\n    /// Gets a reference to the underlying reader.\n    pub fn get_ref(&self) -> &R {\n        &self.reader\n    }\n\n    /// Gets a mutable reference to the underlying reader.\n    pub fn get_mut(&mut self) -> &mut R {\n        &mut self.reader\n    }\n}"
        ],
        "reader::TagState": [
            "Clone"
        ],
        "utils::ByteBuf": [
            "PartialEq",
            "impl<'de> Debug for ByteBuf {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        write_byte_string(f, &self.0)\n    }\n}"
        ],
        "utils::Bytes": [
            "PartialEq",
            "impl<'de> Debug for Bytes<'de> {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        write_byte_string(f, &self.0)\n    }\n}"
        ],
        "writer::ElementWriter": [
            "impl<'a, W: Write> ElementWriter<'a, W> {\n    /// Adds an attribute to this element.\n    pub fn with_attribute<'b, I>(mut self, attr: I) -> Self\n    where\n        I: Into<Attribute<'b>>,\n    {\n        self.start_tag.push_attribute(attr);\n        self\n    }\n\n    /// Add additional attributes to this element using an iterator.\n    ///\n    /// The yielded items must be convertible to [`Attribute`] using `Into`.\n    pub fn with_attributes<'b, I>(mut self, attributes: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Into<Attribute<'b>>,\n    {\n        self.start_tag.extend_attributes(attributes);\n        self\n    }\n\n    /// Write some text inside the current element.\n    pub fn write_text_content(self, text: BytesText) -> Result<&'a mut Writer<W>> {\n        self.writer\n            .write_event(Event::Start(self.start_tag.to_borrowed()))?;\n        self.writer.write_event(Event::Text(text))?;\n        self.writer\n            .write_event(Event::End(self.start_tag.to_end()))?;\n        Ok(self.writer)\n    }\n\n    /// Write a CData event `<![CDATA[...]]>` inside the current element.\n    pub fn write_cdata_content(self, text: BytesCData) -> Result<&'a mut Writer<W>> {\n        self.writer\n            .write_event(Event::Start(self.start_tag.to_borrowed()))?;\n        self.writer.write_event(Event::CData(text))?;\n        self.writer\n            .write_event(Event::End(self.start_tag.to_end()))?;\n        Ok(self.writer)\n    }\n\n    /// Write a processing instruction `<?...?>` inside the current element.\n    pub fn write_pi_content(self, text: BytesText) -> Result<&'a mut Writer<W>> {\n        self.writer\n            .write_event(Event::Start(self.start_tag.to_borrowed()))?;\n        self.writer.write_event(Event::PI(text))?;\n        self.writer\n            .write_event(Event::End(self.start_tag.to_end()))?;\n        Ok(self.writer)\n    }\n\n    /// Write an empty (self-closing) tag.\n    pub fn write_empty(self) -> Result<&'a mut Writer<W>> {\n        self.writer.write_event(Event::Empty(self.start_tag))?;\n        Ok(self.writer)\n    }\n\n    /// Create a new scope for writing XML inside the current element.\n    pub fn write_inner_content<F>(mut self, closure: F) -> Result<&'a mut Writer<W>>\n    where\n        F: Fn(&mut Writer<W>) -> Result<()>,\n    {\n        self.writer\n            .write_event(Event::Start(self.start_tag.to_borrowed()))?;\n        closure(&mut self.writer)?;\n        self.writer\n            .write_event(Event::End(self.start_tag.to_end()))?;\n        Ok(self.writer)\n    }\n}"
        ],
        "writer::Indentation": [
            "Clone",
            "impl Indentation {\n    fn new(indent_char: u8, indent_size: usize) -> Indentation {\n        Indentation {\n            should_line_break: false,\n            indent_char,\n            indent_size,\n            indents: vec![indent_char; 128],\n            indents_len: 0,\n        }\n    }\n\n    fn grow(&mut self) {\n        self.indents_len += self.indent_size;\n        if self.indents_len > self.indents.len() {\n            self.indents.resize(self.indents_len, self.indent_char);\n        }\n    }\n\n    fn shrink(&mut self) {\n        self.indents_len = match self.indents_len.checked_sub(self.indent_size) {\n            Some(result) => result,\n            None => 0,\n        };\n    }\n}"
        ],
        "writer::Writer": [
            "Clone",
            "impl<W: Write> Writer<W> {\n    /// Creates a Writer from a generic Write\n    pub fn new(inner: W) -> Writer<W> {\n        Writer {\n            writer: inner,\n            indent: None,\n        }\n    }\n\n    /// Creates a Writer with configured whitespace indents from a generic Write\n    pub fn new_with_indent(inner: W, indent_char: u8, indent_size: usize) -> Writer<W> {\n        Writer {\n            writer: inner,\n            indent: Some(Indentation::new(indent_char, indent_size)),\n        }\n    }\n\n    /// Consumes this `Writer`, returning the underlying writer.\n    pub fn into_inner(self) -> W {\n        self.writer\n    }\n\n    /// Get inner writer, keeping ownership\n    pub fn inner(&mut self) -> &mut W {\n        &mut self.writer\n    }\n\n    /// Writes the given event to the underlying writer.\n    pub fn write_event<'a, E: AsRef<Event<'a>>>(&mut self, event: E) -> Result<()> {\n        let mut next_should_line_break = true;\n        let result = match *event.as_ref() {\n            Event::Start(ref e) => {\n                let result = self.write_wrapped(b\"<\", e, b\">\");\n                if let Some(i) = self.indent.as_mut() {\n                    i.grow();\n                }\n                result\n            }\n            Event::End(ref e) => {\n                if let Some(i) = self.indent.as_mut() {\n                    i.shrink();\n                }\n                self.write_wrapped(b\"</\", e, b\">\")\n            }\n            Event::Empty(ref e) => self.write_wrapped(b\"<\", e, b\"/>\"),\n            Event::Text(ref e) => {\n                next_should_line_break = false;\n                self.write(&e.escaped())\n            }\n            Event::Comment(ref e) => self.write_wrapped(b\"<!--\", e, b\"-->\"),\n            Event::CData(ref e) => {\n                next_should_line_break = false;\n                self.write(b\"<![CDATA[\")?;\n                self.write(e)?;\n                self.write(b\"]]>\")\n            }\n            Event::Decl(ref e) => self.write_wrapped(b\"<?\", e, b\"?>\"),\n            Event::PI(ref e) => self.write_wrapped(b\"<?\", e, b\"?>\"),\n            Event::DocType(ref e) => self.write_wrapped(b\"<!DOCTYPE \", e, b\">\"),\n            Event::Eof => Ok(()),\n        };\n        if let Some(i) = self.indent.as_mut() {\n            i.should_line_break = next_should_line_break;\n        }\n        result\n    }\n\n    /// Writes bytes\n    #[inline]\n    pub fn write(&mut self, value: &[u8]) -> Result<()> {\n        self.writer.write_all(value).map_err(Error::Io)\n    }\n\n    #[inline]\n    fn write_wrapped(&mut self, before: &[u8], value: &[u8], after: &[u8]) -> Result<()> {\n        if let Some(ref i) = self.indent {\n            if i.should_line_break {\n                self.writer.write_all(b\"\\n\").map_err(Error::Io)?;\n                self.writer\n                    .write_all(&i.indents[..i.indents_len])\n                    .map_err(Error::Io)?;\n            }\n        }\n        self.write(before)?;\n        self.write(value)?;\n        self.write(after)?;\n        Ok(())\n    }\n\n    /// Manually write a newline and indentation at the proper level.\n    ///\n    /// This can be used when the heuristic to line break and indent after any [Event] apart\n    /// from [Text] fails such as when a [Start] occurs directly after [Text].\n    /// This method will do nothing if `Writer` was not constructed with `new_with_indent`.\n    ///\n    /// [Event]: events/enum.Event.html\n    /// [Text]: events/enum.Event.html#variant.Text\n    /// [Start]: events/enum.Event.html#variant.Start\n    pub fn write_indent(&mut self) -> Result<()> {\n        if let Some(ref i) = self.indent {\n            self.writer.write_all(b\"\\n\").map_err(Error::Io)?;\n            self.writer\n                .write_all(&i.indents[..i.indents_len])\n                .map_err(Error::Io)?;\n        }\n        Ok(())\n    }\n\n    /// Provides a simple, high-level API for writing XML elements.\n    ///\n    /// Returns an [ElementWriter] that simplifies setting attributes and writing content inside the element.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use quick_xml::Result;\n    /// # fn main() -> Result<()> {\n    /// use quick_xml::{Error, Writer};\n    /// use quick_xml::events::{BytesStart, BytesText, Event};\n    /// use std::io::Cursor;\n    ///\n    /// let mut writer = Writer::new(Cursor::new(Vec::new()));\n    ///\n    /// // writes <tag attr1=\"value1\"/>\n    /// writer.create_element(\"tag\")\n    ///     .with_attribute((\"attr1\", \"value1\"))  // chain `with_attribute()` calls to add many attributes\n    ///     .write_empty()?;\n    ///\n    /// // writes <tag attr1=\"value1\" attr2=\"value2\">with some text inside</tag>\n    /// writer.create_element(\"tag\")\n    ///     .with_attributes(vec![(\"attr1\", \"value1\"), (\"attr2\", \"value2\")].into_iter())  // or add attributes from an iterator\n    ///     .write_text_content(BytesText::from_plain_str(\"with some text inside\"))?;\n    ///\n    /// // writes <tag><fruit quantity=\"0\">apple</fruit><fruit quantity=\"1\">orange</fruit></tag>\n    /// writer.create_element(\"tag\")\n    ///     .write_inner_content(|writer| {\n    ///         let fruits = [\"apple\", \"orange\"];\n    ///         for (quant, item) in fruits.iter().enumerate() {\n    ///             writer\n    ///                 .create_element(\"fruit\")\n    ///                 .with_attribute((\"quantity\", quant.to_string().as_str()))\n    ///                 .write_text_content(BytesText::from_plain_str(item))?;\n    ///         }\n    ///         Ok(())\n    ///     })?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[must_use]\n    pub fn create_element<'a, N>(&'a mut self, name: &'a N) -> ElementWriter<W>\n    where\n        N: 'a + AsRef<[u8]> + ?Sized,\n    {\n        ElementWriter {\n            writer: self,\n            start_tag: BytesStart::borrowed_name(name.as_ref()),\n        }\n    }\n}"
        ]
    },
    "single_path_import": {
        "errors::Error": "Error",
        "errors::Result": "Result",
        "escapei::escape": "escape::escape",
        "escapei::partial_escape": "escape::partial_escape",
        "escapei::unescape": "escape::unescape",
        "escapei::unescape_with": "escape::unescape_with",
        "reader::Reader": "Reader",
        "writer::ElementWriter": "ElementWriter",
        "writer::Writer": "Writer"
    },
    "srcs": {
        "<&'a [u8] as reader::XmlSource<'a, ()>>::peek_one": [
            "fn peek_one(&mut self) -> Result<Option<u8>>{\n        Ok(self.first().copied())\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::read_bang_element": [
            "fn read_bang_element(\n        &mut self,\n        _buf: (),\n        position: &mut usize,\n    ) -> Result<Option<(BangType, &'a [u8])>>{\n        // Peeked one bang ('!') before being called, so it's guaranteed to\n        // start with it.\n        debug_assert_eq!(self[0], b'!');\n\n        let bang_type = BangType::new(self[1..].first().copied())?;\n\n        if let Some((bytes, i)) = bang_type.parse(self, 0) {\n            *position += i;\n            *self = &self[i..];\n            return Ok(Some((bang_type, bytes)));\n        }\n\n        // Note: Do not update position, so the error points to\n        // somewhere sane rather than at the EOF\n        Err(bang_type.to_err())\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::read_bytes_until": [
            "fn read_bytes_until(\n        &mut self,\n        byte: u8,\n        _buf: (),\n        position: &mut usize,\n    ) -> Result<Option<&'a [u8]>>{\n        if self.is_empty() {\n            return Ok(None);\n        }\n\n        Ok(Some(if let Some(i) = memchr::memchr(byte, self) {\n            *position += i + 1;\n            let bytes = &self[..i];\n            *self = &self[i + 1..];\n            bytes\n        } else {\n            *position += self.len();\n            let bytes = &self[..];\n            *self = &[];\n            bytes\n        }))\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::read_element": [
            "fn read_element(&mut self, _buf: (), position: &mut usize) -> Result<Option<&'a [u8]>>{\n        if self.is_empty() {\n            return Ok(None);\n        }\n\n        let mut state = ReadElementState::Elem;\n\n        if let Some((bytes, i)) = state.change(self) {\n            *position += i;\n            *self = &self[i..];\n            return Ok(Some(bytes));\n        }\n\n        // Note: Do not update position, so the error points to a sane place\n        // rather than at the EOF.\n        Err(Error::UnexpectedEof(\"Element\".to_string()))\n\n        // FIXME: Figure out why the other one works without UnexpectedEof\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::skip_one": [
            "fn skip_one(&mut self, byte: u8, position: &mut usize) -> Result<bool>{\n        if self.first() == Some(&byte) {\n            *self = &self[1..];\n            *position += 1;\n            Ok(true)\n        } else {\n            Ok(false)\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::skip_whitespace": [
            "fn skip_whitespace(&mut self, position: &mut usize) -> Result<()>{\n        let whitespaces = self\n            .iter()\n            .position(|b| !is_whitespace(*b))\n            .unwrap_or(self.len());\n        *position += whitespaces;\n        *self = &self[whitespaces..];\n        Ok(())\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::peek_one": [
            "/// Return one character without consuming it, so that future `read_*` calls\n/// will still include it. On EOF, return None.\nfn peek_one(&mut self) -> Result<Option<u8>>{\n        loop {\n            break match self.fill_buf() {\n                Ok(n) if n.is_empty() => Ok(None),\n                Ok(n) => Ok(Some(n[0])),\n                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => Err(Error::Io(e)),\n            };\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::read_bang_element": [
            "fn read_bang_element(\n        &mut self,\n        buf: &'b mut Vec<u8>,\n        position: &mut usize,\n    ) -> Result<Option<(BangType, &'b [u8])>>{\n        // Peeked one bang ('!') before being called, so it's guaranteed to\n        // start with it.\n        let start = buf.len();\n        let mut read = 1;\n        buf.push(b'!');\n        self.consume(1);\n\n        let bang_type = BangType::new(self.peek_one()?)?;\n\n        loop {\n            match self.fill_buf() {\n                // Note: Do not update position, so the error points to\n                // somewhere sane rather than at the EOF\n                Ok(n) if n.is_empty() => return Err(bang_type.to_err()),\n                Ok(available) => {\n                    if let Some((consumed, used)) = bang_type.parse(available, read) {\n                        buf.extend_from_slice(consumed);\n\n                        self.consume(used);\n                        read += used;\n\n                        *position += read;\n                        break;\n                    } else {\n                        buf.extend_from_slice(available);\n\n                        let used = available.len();\n                        self.consume(used);\n                        read += used;\n                    }\n                }\n                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => {\n                    *position += read;\n                    return Err(Error::Io(e));\n                }\n            }\n        }\n\n        if read == 0 {\n            Ok(None)\n        } else {\n            Ok(Some((bang_type, &buf[start..])))\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::read_bytes_until": [
            "#[inline]\nfn read_bytes_until(\n        &mut self,\n        byte: u8,\n        buf: &'b mut Vec<u8>,\n        position: &mut usize,\n    ) -> Result<Option<&'b [u8]>>{\n        let mut read = 0;\n        let mut done = false;\n        let start = buf.len();\n        while !done {\n            let used = {\n                let available = match self.fill_buf() {\n                    Ok(n) if n.is_empty() => break,\n                    Ok(n) => n,\n                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                    Err(e) => {\n                        *position += read;\n                        return Err(Error::Io(e));\n                    }\n                };\n\n                match memchr::memchr(byte, available) {\n                    Some(i) => {\n                        buf.extend_from_slice(&available[..i]);\n                        done = true;\n                        i + 1\n                    }\n                    None => {\n                        buf.extend_from_slice(available);\n                        available.len()\n                    }\n                }\n            };\n            self.consume(used);\n            read += used;\n        }\n        *position += read;\n\n        if read == 0 {\n            Ok(None)\n        } else {\n            Ok(Some(&buf[start..]))\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::read_element": [
            "#[inline]\nfn read_element(\n        &mut self,\n        buf: &'b mut Vec<u8>,\n        position: &mut usize,\n    ) -> Result<Option<&'b [u8]>>{\n        let mut state = ReadElementState::Elem;\n        let mut read = 0;\n\n        let start = buf.len();\n        loop {\n            match self.fill_buf() {\n                Ok(n) if n.is_empty() => break,\n                Ok(available) => {\n                    if let Some((consumed, used)) = state.change(available) {\n                        buf.extend_from_slice(consumed);\n\n                        self.consume(used);\n                        read += used;\n\n                        *position += read;\n                        break;\n                    } else {\n                        buf.extend_from_slice(available);\n\n                        let used = available.len();\n                        self.consume(used);\n                        read += used;\n                    }\n                }\n                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => {\n                    *position += read;\n                    return Err(Error::Io(e));\n                }\n            };\n        }\n\n        if read == 0 {\n            Ok(None)\n        } else {\n            Ok(Some(&buf[start..]))\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::skip_one": [
            "/// Consume and discard one character if it matches the given byte. Return\n/// true if it matched.\nfn skip_one(&mut self, byte: u8, position: &mut usize) -> Result<bool>{\n        match self.peek_one()? {\n            Some(b) if b == byte => {\n                *position += 1;\n                self.consume(1);\n                Ok(true)\n            }\n            _ => Ok(false),\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::skip_whitespace": [
            "/// Consume and discard all the whitespace until the next non-whitespace\n/// character or EOF.\nfn skip_whitespace(&mut self, position: &mut usize) -> Result<()>{\n        loop {\n            break match self.fill_buf() {\n                Ok(n) => {\n                    let count = n.iter().position(|b| !is_whitespace(*b)).unwrap_or(n.len());\n                    if count > 0 {\n                        self.consume(count);\n                        *position += count;\n                        continue;\n                    } else {\n                        Ok(())\n                    }\n                }\n                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => Err(Error::Io(e)),\n            };\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "<errors::Error as std::convert::From<escapei::EscapeError>>::from": [
            "/// Creates a new `Error::EscapeError` from the given error\n#[inline]\nfn from(error: EscapeError) -> Error{\n        Error::EscapeError(error)\n    }",
            "Real(LocalPath(\"src/errors.rs\"))"
        ],
        "<errors::Error as std::convert::From<events::attributes::AttrError>>::from": [
            "#[inline]\nfn from(error: AttrError) -> Self{\n        Error::InvalidAttr(error)\n    }",
            "Real(LocalPath(\"src/errors.rs\"))"
        ],
        "<errors::Error as std::convert::From<std::io::Error>>::from": [
            "/// Creates a new `Error::Io` from the given error\n#[inline]\nfn from(error: ::std::io::Error) -> Error{\n        Error::Io(error)\n    }",
            "Real(LocalPath(\"src/errors.rs\"))"
        ],
        "<errors::Error as std::convert::From<std::str::Utf8Error>>::from": [
            "/// Creates a new `Error::Utf8` from the given error\n#[inline]\nfn from(error: Utf8Error) -> Error{\n        Error::Utf8(error)\n    }",
            "Real(LocalPath(\"src/errors.rs\"))"
        ],
        "<errors::Error as std::error::Error>::source": [
            "fn source(&self) -> Option<&(dyn std::error::Error + 'static)>{\n        match self {\n            Error::Io(e) => Some(e),\n            Error::Utf8(e) => Some(e),\n            Error::InvalidAttr(e) => Some(e),\n            Error::EscapeError(e) => Some(e),\n            _ => None,\n        }\n    }",
            "Real(LocalPath(\"src/errors.rs\"))"
        ],
        "<errors::Error as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result{\n        match self {\n            Error::Io(e) => write!(f, \"I/O error: {}\", e),\n            Error::Utf8(e) => write!(f, \"UTF8 error: {}\", e),\n            Error::UnexpectedEof(e) => write!(f, \"Unexpected EOF during reading {}\", e),\n            Error::EndEventMismatch { expected, found } => {\n                write!(f, \"Expecting </{}> found </{}>\", expected, found)\n            }\n            Error::UnexpectedToken(e) => write!(f, \"Unexpected token '{}'\", e),\n            Error::UnexpectedBang(b) => write!(\n                f,\n                \"Only Comment (`--`), CDATA (`[CDATA[`) and DOCTYPE (`DOCTYPE`) nodes can start with a '!', but symbol `{}` found\",\n                *b as char\n            ),\n            Error::TextNotFound => write!(f, \"Cannot read text, expecting Event::Text\"),\n            Error::XmlDeclWithoutVersion(e) => write!(\n                f,\n                \"XmlDecl must start with 'version' attribute, found {:?}\",\n                e\n            ),\n            Error::InvalidAttr(e) => write!(f, \"error while parsing attribute: {}\", e),\n            Error::EscapeError(e) => write!(f, \"{}\", e),\n        }\n    }",
            "Real(LocalPath(\"src/errors.rs\"))"
        ],
        "<escapei::EscapeError as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result{\n        match self {\n            EscapeError::EntityWithNull(e) => write!(\n                f,\n                \"Error while escaping character at range {:?}: Null character entity not allowed\",\n                e\n            ),\n            EscapeError::UnrecognizedSymbol(rge, res) => write!(\n                f,\n                \"Error while escaping character at range {:?}: Unrecognized escape symbol: {:?}\",\n                rge, res\n            ),\n            EscapeError::UnterminatedEntity(e) => write!(\n                f,\n                \"Error while escaping character at range {:?}: Cannot find ';' after '&'\",\n                e\n            ),\n            EscapeError::TooLongHexadecimal => write!(f, \"Cannot convert hexadecimal to utf8\"),\n            EscapeError::InvalidHexadecimal(e) => {\n                write!(f, \"'{}' is not a valid hexadecimal character\", e)\n            }\n            EscapeError::TooLongDecimal => write!(f, \"Cannot convert decimal to utf8\"),\n            EscapeError::InvalidDecimal(e) => write!(f, \"'{}' is not a valid decimal character\", e),\n            EscapeError::InvalidCodepoint(n) => write!(f, \"'{}' is not a valid codepoint\", n),\n        }\n    }",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "<events::BytesCData<'a> as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result{\n        write!(f, \"BytesCData {{ content: \")?;\n        write_cow_string(f, &self.content)?;\n        write!(f, \" }}\")\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "<events::BytesCData<'a> as std::ops::Deref>::deref": [
            "fn deref(&self) -> &[u8]{\n        &*self.content\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "<events::BytesDecl<'a> as std::ops::Deref>::deref": [
            "fn deref(&self) -> &[u8]{\n        &*self.element\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "<events::BytesEnd<'a> as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result{\n        write!(f, \"BytesEnd {{ name: \")?;\n        write_cow_string(f, &self.name)?;\n        write!(f, \" }}\")\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "<events::BytesEnd<'a> as std::ops::Deref>::deref": [
            "fn deref(&self) -> &[u8]{\n        &*self.name\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "<events::BytesStart<'a> as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result{\n        write!(f, \"BytesStart {{ buf: \")?;\n        write_cow_string(f, &self.buf)?;\n        write!(f, \", name_len: {} }}\", self.name_len)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "<events::BytesStart<'a> as std::ops::Deref>::deref": [
            "fn deref(&self) -> &[u8]{\n        &*self.buf\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "<events::BytesText<'a> as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result{\n        write!(f, \"BytesText {{ content: \")?;\n        write_cow_string(f, &self.content)?;\n        write!(f, \" }}\")\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "<events::BytesText<'a> as std::ops::Deref>::deref": [
            "fn deref(&self) -> &[u8]{\n        &*self.content\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "<events::Event<'a> as std::convert::AsRef<events::Event<'a>>>::as_ref": [
            "fn as_ref(&self) -> &Event<'a>{\n        self\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "<events::Event<'a> as std::ops::Deref>::deref": [
            "fn deref(&self) -> &[u8]{\n        match *self {\n            Event::Start(ref e) | Event::Empty(ref e) => &*e,\n            Event::End(ref e) => &*e,\n            Event::Text(ref e) => &*e,\n            Event::Decl(ref e) => &*e,\n            Event::PI(ref e) => &*e,\n            Event::CData(ref e) => &*e,\n            Event::Comment(ref e) => &*e,\n            Event::DocType(ref e) => &*e,\n            Event::Eof => &[],\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "<events::attributes::Attr<T> as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut Formatter) -> fmt::Result{\n        match self {\n            Attr::DoubleQ(key, value) => f\n                .debug_tuple(\"Attr::DoubleQ\")\n                .field(&Bytes(key.as_ref()))\n                .field(&Bytes(value.as_ref()))\n                .finish(),\n            Attr::SingleQ(key, value) => f\n                .debug_tuple(\"Attr::SingleQ\")\n                .field(&Bytes(key.as_ref()))\n                .field(&Bytes(value.as_ref()))\n                .finish(),\n            Attr::Empty(key) => f\n                .debug_tuple(\"Attr::Empty\")\n                // Comment to prevent formatting and keep style consistent\n                .field(&Bytes(key.as_ref()))\n                .finish(),\n            Attr::Unquoted(key, value) => f\n                .debug_tuple(\"Attr::Unquoted\")\n                .field(&Bytes(key.as_ref()))\n                .field(&Bytes(value.as_ref()))\n                .finish(),\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "<events::attributes::AttrError as std::fmt::Display>::fmt": [
            "fn fmt(&self, f: &mut Formatter) -> fmt::Result{\n        match self {\n            Self::ExpectedEq(pos) => write!(\n                f,\n                r#\"position {}: attribute key must be directly followed by `=` or space\"#,\n                pos\n            ),\n            Self::ExpectedValue(pos) => write!(\n                f,\n                r#\"position {}: `=` must be followed by an attribute value\"#,\n                pos\n            ),\n            Self::UnquotedValue(pos) => write!(\n                f,\n                r#\"position {}: attribute value must be enclosed in `\"` or `'`\"#,\n                pos\n            ),\n            Self::ExpectedQuote(pos, quote) => write!(\n                f,\n                r#\"position {}: missing closing quote `{}` in attribute value\"#,\n                pos, *quote as char\n            ),\n            Self::Duplicated(pos1, pos2) => write!(\n                f,\n                r#\"position {}: duplicated attribute, previous declaration at position {}\"#,\n                pos1, pos2\n            ),\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "<events::attributes::Attribute<'a> as std::convert::From<(&'a [u8], &'a [u8])>>::from": [
            "/// Creates new attribute from raw bytes.\n/// Does not apply any transformation to both key and value.\n///\n/// # Examples\n///\n/// ```\n/// # use pretty_assertions::assert_eq;\n/// use quick_xml::events::attributes::Attribute;\n///\n/// let features = Attribute::from((\"features\".as_bytes(), \"Bells &amp; whistles\".as_bytes()));\n/// assert_eq!(features.value, \"Bells &amp; whistles\".as_bytes());\n/// ```\nfn from(val: (&'a [u8], &'a [u8])) -> Attribute<'a>{\n        Attribute {\n            key: val.0,\n            value: Cow::from(val.1),\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "<events::attributes::Attribute<'a> as std::convert::From<(&'a str, &'a str)>>::from": [
            "/// Creates new attribute from text representation.\n/// Key is stored as-is, but the value will be escaped.\n///\n/// # Examples\n///\n/// ```\n/// # use pretty_assertions::assert_eq;\n/// use quick_xml::events::attributes::Attribute;\n///\n/// let features = Attribute::from((\"features\", \"Bells & whistles\"));\n/// assert_eq!(features.value, \"Bells &amp; whistles\".as_bytes());\n/// ```\nfn from(val: (&'a str, &'a str)) -> Attribute<'a>{\n        Attribute {\n            key: val.0.as_bytes(),\n            value: escape(val.1.as_bytes()),\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "<events::attributes::Attribute<'a> as std::convert::From<events::attributes::Attr<&'a [u8]>>>::from": [
            "#[inline]\nfn from(attr: Attr<&'a [u8]>) -> Self{\n        Self {\n            key: attr.key(),\n            value: Cow::Borrowed(attr.value()),\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "<events::attributes::Attribute<'a> as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut Formatter) -> fmt::Result{\n        write!(f, \"Attribute {{ key: \")?;\n        write_byte_string(f, self.key)?;\n        write!(f, \", value: \")?;\n        write_cow_string(f, &self.value)?;\n        write!(f, \" }}\")\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "<events::attributes::Attributes<'a> as std::iter::Iterator>::next": [
            "#[inline]\nfn next(&mut self) -> Option<Self::Item>{\n        match self.state.next(self.bytes) {\n            None => None,\n            Some(Ok(a)) => Some(Ok(a.map(|range| &self.bytes[range]).into())),\n            Some(Err(e)) => Some(Err(e)),\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "<utils::ByteBuf as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut Formatter) -> fmt::Result{\n        write_byte_string(f, &self.0)\n    }",
            "Real(LocalPath(\"src/utils.rs\"))"
        ],
        "<utils::Bytes<'de> as std::fmt::Debug>::fmt": [
            "fn fmt(&self, f: &mut Formatter) -> fmt::Result{\n        write_byte_string(f, &self.0)\n    }",
            "Real(LocalPath(\"src/utils.rs\"))"
        ],
        "errors::Error": [
            "/// The error type used by this crate.\npub enum Error {\n    /// IO error\n    Io(::std::io::Error),\n    /// Utf8 error\n    Utf8(Utf8Error),\n    /// Unexpected End of File\n    UnexpectedEof(String),\n    /// End event mismatch\n    EndEventMismatch {\n        /// Expected end event\n        expected: String,\n        /// Found end event\n        found: String,\n    },\n    /// Unexpected token\n    UnexpectedToken(String),\n    /// Unexpected <!>\n    UnexpectedBang(u8),\n    /// Text not found, expected `Event::Text`\n    TextNotFound,\n    /// `Event::XmlDecl` must start with *version* attribute\n    XmlDeclWithoutVersion(Option<String>),\n    /// Attribute parsing error\n    InvalidAttr(AttrError),\n    /// Escape error\n    EscapeError(EscapeError),\n}",
            "Real(LocalPath(\"src/errors.rs\"))"
        ],
        "escapei::EscapeError": [
            "/// Error for XML escape/unescqpe.\npub enum EscapeError {\n    /// Entity with Null character\n    EntityWithNull(::std::ops::Range<usize>),\n    /// Unrecognized escape symbol\n    UnrecognizedSymbol(\n        ::std::ops::Range<usize>,\n        ::std::result::Result<String, ::std::string::FromUtf8Error>,\n    ),\n    /// Cannot find `;` after `&`\n    UnterminatedEntity(::std::ops::Range<usize>),\n    /// Cannot convert Hexa to utf8\n    TooLongHexadecimal,\n    /// Character is not a valid hexadecimal value\n    InvalidHexadecimal(char),\n    /// Cannot convert decimal to hexa\n    TooLongDecimal,\n    /// Character is not a valid decimal value\n    InvalidDecimal(char),\n    /// Not a valid unicode codepoint\n    InvalidCodepoint(u32),\n}",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::_escape": [
            "/// Escapes a `&[u8]` and replaces a subset of xml special characters (<, >, &, ', \") with their\n/// corresponding xml escaped value.\nfn _escape<F: Fn(u8) -> bool>(raw: &[u8], escape_chars: F) -> Cow<[u8]>{\n    let mut escaped = None;\n    let mut bytes = raw.iter();\n    let mut pos = 0;\n    while let Some(i) = bytes.position(|&b| escape_chars(b)) {\n        if escaped.is_none() {\n            escaped = Some(Vec::with_capacity(raw.len()));\n        }\n        let escaped = escaped.as_mut().expect(\"initialized\");\n        let new_pos = pos + i;\n        escaped.extend_from_slice(&raw[pos..new_pos]);\n        match raw[new_pos] {\n            b'<' => escaped.extend_from_slice(b\"&lt;\"),\n            b'>' => escaped.extend_from_slice(b\"&gt;\"),\n            b'\\'' => escaped.extend_from_slice(b\"&apos;\"),\n            b'&' => escaped.extend_from_slice(b\"&amp;\"),\n            b'\"' => escaped.extend_from_slice(b\"&quot;\"),\n            _ => unreachable!(\"Only '<', '>','\\', '&' and '\\\"' are escaped\"),\n        }\n        pos = new_pos + 1;\n    }\n\n    if let Some(mut escaped) = escaped {\n        if let Some(raw) = raw.get(pos..) {\n            escaped.extend_from_slice(raw);\n        }\n        Cow::Owned(escaped)\n    } else {\n        Cow::Borrowed(raw)\n    }\n}",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::do_unescape": [
            "/// Unescape a `&[u8]` and replaces all xml escaped characters ('&...;') into their corresponding\n/// value, using an optional dictionary of custom entities.\n///\n/// # Pre-condition\n///\n/// The keys and values of `custom_entities`, if any, must be valid UTF-8.\npub fn do_unescape<'a>(\n    raw: &'a [u8],\n    custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n) -> Result<Cow<'a, [u8]>, EscapeError>{\n    let mut unescaped = None;\n    let mut last_end = 0;\n    let mut iter = memchr::memchr2_iter(b'&', b';', raw);\n    while let Some(start) = iter.by_ref().find(|p| raw[*p] == b'&') {\n        match iter.next() {\n            Some(end) if raw[end] == b';' => {\n                // append valid data\n                if unescaped.is_none() {\n                    unescaped = Some(Vec::with_capacity(raw.len()));\n                }\n                let unescaped = unescaped.as_mut().expect(\"initialized\");\n                unescaped.extend_from_slice(&raw[last_end..start]);\n\n                // search for character correctness\n                let pat = &raw[start + 1..end];\n                if let Some(s) = named_entity(pat) {\n                    unescaped.extend_from_slice(s.as_bytes());\n                } else if pat.starts_with(b\"#\") {\n                    push_utf8(unescaped, parse_number(&pat[1..], start..end)?);\n                } else if let Some(value) = custom_entities.and_then(|hm| hm.get(pat)) {\n                    unescaped.extend_from_slice(&value);\n                } else {\n                    return Err(EscapeError::UnrecognizedSymbol(\n                        start + 1..end,\n                        String::from_utf8(pat.to_vec()),\n                    ));\n                }\n\n                last_end = end + 1;\n            }\n            _ => return Err(EscapeError::UnterminatedEntity(start..raw.len())),\n        }\n    }\n\n    if let Some(mut unescaped) = unescaped {\n        if let Some(raw) = raw.get(last_end..) {\n            unescaped.extend_from_slice(raw);\n        }\n        Ok(Cow::Owned(unescaped))\n    } else {\n        Ok(Cow::Borrowed(raw))\n    }\n}",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::escape": [
            "/// Escapes a `&[u8]` and replaces all xml special characters (<, >, &, ', \") with their\n/// corresponding xml escaped value.\npub fn escape(raw: &[u8]) -> Cow<[u8]>{\n    #[inline]\n    fn to_escape(b: u8) -> bool {\n        match b {\n            b'<' | b'>' | b'\\'' | b'&' | b'\"' => true,\n            _ => false,\n        }\n    }\n\n    _escape(raw, to_escape)\n}",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::escape::to_escape": [
            "#[inline]\nfn to_escape(b: u8) -> bool{\n        match b {\n            b'<' | b'>' | b'\\'' | b'&' | b'\"' => true,\n            _ => false,\n        }\n    }",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::named_entity": [
            "#[cfg(not(feature = \"escape-html\"))]\nconst fn named_entity(name: &[u8]) -> Option<&str>{\n    let s = match name {\n        b\"lt\" => \"<\",\n        b\"gt\" => \">\",\n        b\"amp\" => \"&\",\n        b\"apos\" => \"'\",\n        b\"quot\" => \"\\\"\",\n        _ => return None,\n    };\n    Some(s)\n}",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::parse_decimal": [
            "fn parse_decimal(bytes: &[u8]) -> Result<u32, EscapeError>{\n    // maximum code is 0x10FFFF = 1114111 => 7 characters\n    if bytes.len() > 7 {\n        return Err(EscapeError::TooLongDecimal);\n    }\n    let mut code = 0;\n    for &b in bytes {\n        code *= 10;\n        code += match b {\n            b'0'..=b'9' => b - b'0',\n            b => return Err(EscapeError::InvalidDecimal(b as char)),\n        } as u32;\n    }\n    Ok(code)\n}",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::parse_hexadecimal": [
            "fn parse_hexadecimal(bytes: &[u8]) -> Result<u32, EscapeError>{\n    // maximum code is 0x10FFFF => 6 characters\n    if bytes.len() > 6 {\n        return Err(EscapeError::TooLongHexadecimal);\n    }\n    let mut code = 0;\n    for &b in bytes {\n        code <<= 4;\n        code += match b {\n            b'0'..=b'9' => b - b'0',\n            b'a'..=b'f' => b - b'a' + 10,\n            b'A'..=b'F' => b - b'A' + 10,\n            b => return Err(EscapeError::InvalidHexadecimal(b as char)),\n        } as u32;\n    }\n    Ok(code)\n}",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::parse_number": [
            "fn parse_number(bytes: &[u8], range: Range<usize>) -> Result<char, EscapeError>{\n    let code = if bytes.starts_with(b\"x\") {\n        parse_hexadecimal(&bytes[1..])\n    } else {\n        parse_decimal(&bytes)\n    }?;\n    if code == 0 {\n        return Err(EscapeError::EntityWithNull(range));\n    }\n    match std::char::from_u32(code) {\n        Some(c) => Ok(c),\n        None => Err(EscapeError::InvalidCodepoint(code)),\n    }\n}",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::partial_escape": [
            "/// Should only be used for escaping text content. In xml text content, it is allowed\n/// (though not recommended) to leave the quote special characters \" and ' unescaped.\n/// This function escapes a `&[u8]` and replaces xml special characters (<, >, &) with\n/// their corresponding xml escaped value, but does not escape quote characters.\npub fn partial_escape(raw: &[u8]) -> Cow<[u8]>{\n    #[inline]\n    fn to_escape(b: u8) -> bool {\n        match b {\n            b'<' | b'>' | b'&' => true,\n            _ => false,\n        }\n    }\n\n    _escape(raw, to_escape)\n}",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::partial_escape::to_escape": [
            "#[inline]\nfn to_escape(b: u8) -> bool{\n        match b {\n            b'<' | b'>' | b'&' => true,\n            _ => false,\n        }\n    }",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::push_utf8": [
            "fn push_utf8(out: &mut Vec<u8>, code: char){\n    let mut buf = [0u8; 4];\n    out.extend_from_slice(code.encode_utf8(&mut buf).as_bytes());\n}",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::unescape": [
            "/// Unescape a `&[u8]` and replaces all xml escaped characters ('&...;') into their corresponding\n/// value\npub fn unescape(raw: &[u8]) -> Result<Cow<[u8]>, EscapeError>{\n    do_unescape(raw, None)\n}",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "escapei::unescape_with": [
            "/// Unescape a `&[u8]` and replaces all xml escaped characters ('&...;') into their corresponding\n/// value, using a dictionnary of custom entities.\n///\n/// # Pre-condition\n///\n/// The keys and values of `custom_entities`, if any, must be valid UTF-8.\npub fn unescape_with<'a>(\n    raw: &'a [u8],\n    custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n) -> Result<Cow<'a, [u8]>, EscapeError>{\n    do_unescape(raw, Some(custom_entities))\n}",
            "Real(LocalPath(\"src/escapei.rs\"))"
        ],
        "events::BytesCData": [
            "/// CDATA content contains unescaped data from the reader. If you want to write them as a text,\n/// [convert](Self::escape) it to [`BytesText`]\npub struct BytesCData<'a> {\n    content: Cow<'a, [u8]>,\n}",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesCData::<'a>::escape": [
            "/// Converts this CDATA content to an escaped version, that can be written\n/// as an usual text in XML.\n///\n/// This function performs following replacements:\n///\n/// | Character | Replacement\n/// |-----------|------------\n/// | `<`       | `&lt;`\n/// | `>`       | `&gt;`\n/// | `&`       | `&amp;`\n/// | `'`       | `&apos;`\n/// | `\"`       | `&quot;`\npub fn escape(self) -> BytesText<'a>{\n        BytesText::from_escaped(match escape(&self.content) {\n            Cow::Borrowed(_) => self.content,\n            Cow::Owned(escaped) => Cow::Owned(escaped),\n        })\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesCData::<'a>::from_str": [
            "/// Creates a new `BytesCData` from a string\n#[inline]\npub fn from_str(content: &'a str) -> Self{\n        Self::new(content.as_bytes())\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesCData::<'a>::into_inner": [
            "/// Extracts the inner `Cow` from the `BytesCData` event container.\n#[inline]\npub fn into_inner(self) -> Cow<'a, [u8]>{\n        self.content\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesCData::<'a>::into_owned": [
            "/// Ensures that all data is owned to extend the object's lifetime if\n/// necessary.\n#[inline]\npub fn into_owned(self) -> BytesCData<'static>{\n        BytesCData {\n            content: self.content.into_owned().into(),\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesCData::<'a>::new": [
            "/// Creates a new `BytesCData` from a byte sequence.\n#[inline]\npub fn new<C: Into<Cow<'a, [u8]>>>(content: C) -> Self{\n        Self {\n            content: content.into(),\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesCData::<'a>::partial_escape": [
            "/// Converts this CDATA content to an escaped version, that can be written\n/// as an usual text in XML.\n///\n/// In XML text content, it is allowed (though not recommended) to leave\n/// the quote special characters `\"` and `'` unescaped.\n///\n/// This function performs following replacements:\n///\n/// | Character | Replacement\n/// |-----------|------------\n/// | `<`       | `&lt;`\n/// | `>`       | `&gt;`\n/// | `&`       | `&amp;`\npub fn partial_escape(self) -> BytesText<'a>{\n        BytesText::from_escaped(match partial_escape(&self.content) {\n            Cow::Borrowed(_) => self.content,\n            Cow::Owned(escaped) => Cow::Owned(escaped),\n        })\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesDecl": [
            "/// An XML declaration (`Event::Decl`).\n///\n/// [W3C XML 1.1 Prolog and Document Type Declaration](http://w3.org/TR/xml11/#sec-prolog-dtd)\npub struct BytesDecl<'a> {\n    element: BytesStart<'a>,\n}",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesDecl::<'a>::encoding": [
            "/// Gets xml encoding, excluding quotes (`'` or `\"`).\n///\n/// Although according to the [grammar] encoding must appear before `\"standalone\"`\n/// and after `\"version\"`, this method does not check that. The first occurrence\n/// of the attribute will be returned even if there are several. Also, method does\n/// not restrict symbols that can forming the encoding, so the returned encoding\n/// name may not correspond to the grammar.\n///\n/// # Examples\n///\n/// ```\n/// use std::borrow::Cow;\n/// use quick_xml::Error;\n/// use quick_xml::events::{BytesDecl, BytesStart};\n///\n/// // <?xml version='1.1'?>\n/// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" version='1.1'\", 0));\n/// assert!(decl.encoding().is_none());\n///\n/// // <?xml encoding='utf-8'?>\n/// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" encoding='utf-8'\", 0));\n/// match decl.encoding() {\n///     Some(Ok(Cow::Borrowed(encoding))) => assert_eq!(encoding, b\"utf-8\"),\n///     _ => assert!(false),\n/// }\n///\n/// // <?xml encoding='something_WRONG' encoding='utf-8'?>\n/// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" encoding='something_WRONG' encoding='utf-8'\", 0));\n/// match decl.encoding() {\n///     Some(Ok(Cow::Borrowed(encoding))) => assert_eq!(encoding, b\"something_WRONG\"),\n///     _ => assert!(false),\n/// }\n/// ```\n///\n/// [grammar]: https://www.w3.org/TR/xml11/#NT-XMLDecl\npub fn encoding(&self) -> Option<Result<Cow<[u8]>>>{\n        self.element\n            .try_get_attribute(\"encoding\")\n            .map(|a| a.map(|a| a.value))\n            .transpose()\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesDecl::<'a>::from_start": [
            "/// Creates a `BytesDecl` from a `BytesStart`\npub fn from_start(start: BytesStart<'a>) -> BytesDecl<'a>{\n        BytesDecl { element: start }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesDecl::<'a>::into_owned": [
            "/// Converts the event into an owned event.\npub fn into_owned(self) -> BytesDecl<'static>{\n        BytesDecl {\n            element: self.element.into_owned(),\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesDecl::<'a>::new": [
            "/// Constructs a new `XmlDecl` from the (mandatory) _version_ (should be `1.0` or `1.1`),\n/// the optional _encoding_ (e.g., `UTF-8`) and the optional _standalone_ (`yes` or `no`)\n/// attribute.\n///\n/// Does not escape any of its inputs. Always uses double quotes to wrap the attribute values.\n/// The caller is responsible for escaping attribute values. Shouldn't usually be relevant since\n/// the double quote character is not allowed in any of the attribute values.\npub fn new(\n        version: &[u8],\n        encoding: Option<&[u8]>,\n        standalone: Option<&[u8]>,\n    ) -> BytesDecl<'static>{\n        // Compute length of the buffer based on supplied attributes\n        // ' encoding=\"\"'   => 12\n        let encoding_attr_len = if let Some(xs) = encoding {\n            12 + xs.len()\n        } else {\n            0\n        };\n        // ' standalone=\"\"' => 14\n        let standalone_attr_len = if let Some(xs) = standalone {\n            14 + xs.len()\n        } else {\n            0\n        };\n        // 'xml version=\"\"' => 14\n        let mut buf = Vec::with_capacity(14 + encoding_attr_len + standalone_attr_len);\n\n        buf.extend_from_slice(b\"xml version=\\\"\");\n        buf.extend_from_slice(version);\n\n        if let Some(encoding_val) = encoding {\n            buf.extend_from_slice(b\"\\\" encoding=\\\"\");\n            buf.extend_from_slice(encoding_val);\n        }\n\n        if let Some(standalone_val) = standalone {\n            buf.extend_from_slice(b\"\\\" standalone=\\\"\");\n            buf.extend_from_slice(standalone_val);\n        }\n        buf.push(b'\"');\n\n        BytesDecl {\n            element: BytesStart::owned(buf, 3),\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesDecl::<'a>::standalone": [
            "/// Gets xml standalone, excluding quotes (`'` or `\"`).\n///\n/// Although according to the [grammar] standalone flag must appear after `\"version\"`\n/// and `\"encoding\"`, this method does not check that. The first occurrence of the\n/// attribute will be returned even if there are several. Also, method does not\n/// restrict symbols that can forming the value, so the returned flag name may not\n/// correspond to the grammar.\n///\n/// # Examples\n///\n/// ```\n/// use std::borrow::Cow;\n/// use quick_xml::Error;\n/// use quick_xml::events::{BytesDecl, BytesStart};\n///\n/// // <?xml version='1.1'?>\n/// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" version='1.1'\", 0));\n/// assert!(decl.standalone().is_none());\n///\n/// // <?xml standalone='yes'?>\n/// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" standalone='yes'\", 0));\n/// match decl.standalone() {\n///     Some(Ok(Cow::Borrowed(encoding))) => assert_eq!(encoding, b\"yes\"),\n///     _ => assert!(false),\n/// }\n///\n/// // <?xml standalone='something_WRONG' encoding='utf-8'?>\n/// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" standalone='something_WRONG' encoding='utf-8'\", 0));\n/// match decl.standalone() {\n///     Some(Ok(Cow::Borrowed(flag))) => assert_eq!(flag, b\"something_WRONG\"),\n///     _ => assert!(false),\n/// }\n/// ```\n///\n/// [grammar]: https://www.w3.org/TR/xml11/#NT-XMLDecl\npub fn standalone(&self) -> Option<Result<Cow<[u8]>>>{\n        self.element\n            .try_get_attribute(\"standalone\")\n            .map(|a| a.map(|a| a.value))\n            .transpose()\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesDecl::<'a>::version": [
            "/// Gets xml version, excluding quotes (`'` or `\"`).\n///\n/// According to the [grammar], the version *must* be the first thing in the declaration.\n/// This method tries to extract the first thing in the declaration and return it.\n/// In case of multiple attributes value of the first one is returned.\n///\n/// If version is missed in the declaration, or the first thing is not a version,\n/// [`Error::XmlDeclWithoutVersion`] will be returned.\n///\n/// # Examples\n///\n/// ```\n/// use std::borrow::Cow;\n/// use quick_xml::Error;\n/// use quick_xml::events::{BytesDecl, BytesStart};\n///\n/// // <?xml version='1.1'?>\n/// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" version='1.1'\", 0));\n/// assert_eq!(\n///     decl.version().unwrap(),\n///     Cow::Borrowed(b\"1.1\".as_ref())\n/// );\n///\n/// // <?xml version='1.0' version='1.1'?>\n/// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" version='1.0' version='1.1'\", 0));\n/// assert_eq!(\n///     decl.version().unwrap(),\n///     Cow::Borrowed(b\"1.0\".as_ref())\n/// );\n///\n/// // <?xml encoding='utf-8'?>\n/// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" encoding='utf-8'\", 0));\n/// match decl.version() {\n///     Err(Error::XmlDeclWithoutVersion(Some(key))) => assert_eq!(key, \"encoding\".to_string()),\n///     _ => assert!(false),\n/// }\n///\n/// // <?xml encoding='utf-8' version='1.1'?>\n/// let decl = BytesDecl::from_start(BytesStart::borrowed(b\" encoding='utf-8' version='1.1'\", 0));\n/// match decl.version() {\n///     Err(Error::XmlDeclWithoutVersion(Some(key))) => assert_eq!(key, \"encoding\".to_string()),\n///     _ => assert!(false),\n/// }\n///\n/// // <?xml?>\n/// let decl = BytesDecl::from_start(BytesStart::borrowed(b\"\", 0));\n/// match decl.version() {\n///     Err(Error::XmlDeclWithoutVersion(None)) => {},\n///     _ => assert!(false),\n/// }\n/// ```\n///\n/// [grammar]: https://www.w3.org/TR/xml11/#NT-XMLDecl\npub fn version(&self) -> Result<Cow<[u8]>>{\n        // The version *must* be the first thing in the declaration.\n        match self.element.attributes().with_checks(false).next() {\n            Some(Ok(a)) if a.key == b\"version\" => Ok(a.value),\n            // first attribute was not \"version\"\n            Some(Ok(a)) => {\n                let found = from_utf8(a.key).map_err(Error::Utf8)?.to_string();\n                Err(Error::XmlDeclWithoutVersion(Some(found)))\n            }\n            // error parsing attributes\n            Some(Err(e)) => Err(e.into()),\n            // no attributes\n            None => Err(Error::XmlDeclWithoutVersion(None)),\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesEnd": [
            "/// A struct to manage `Event::End` events\npub struct BytesEnd<'a> {\n    name: Cow<'a, [u8]>,\n}",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesEnd::<'a>::borrowed": [
            "/// Creates a new `BytesEnd` borrowing a slice\n#[inline]\npub fn borrowed(name: &'a [u8]) -> BytesEnd<'a>{\n        BytesEnd {\n            name: Cow::Borrowed(name),\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesEnd::<'a>::into_owned": [
            "/// Converts the event into an owned event.\npub fn into_owned(self) -> BytesEnd<'static>{\n        BytesEnd {\n            name: Cow::Owned(self.name.into_owned()),\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesEnd::<'a>::local_name": [
            "/// local name (excluding namespace) as &[u8] (without eventual attributes)\n/// returns the name() with any leading namespace removed (all content up to\n/// and including the first ':' character)\n#[inline]\npub fn local_name(&self) -> &[u8]{\n        if let Some(i) = self.name().iter().position(|b| *b == b':') {\n            &self.name()[i + 1..]\n        } else {\n            self.name()\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesEnd::<'a>::name": [
            "/// Gets `BytesEnd` event name\n#[inline]\npub fn name(&self) -> &[u8]{\n        &*self.name\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesEnd::<'a>::owned": [
            "/// Creates a new `BytesEnd` owning its name\n#[inline]\npub fn owned(name: Vec<u8>) -> BytesEnd<'static>{\n        BytesEnd {\n            name: Cow::Owned(name),\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart": [
            "/// Opening tag data (`Event::Start`), with optional attributes.\n///\n/// `<name attr=\"value\">`.\n///\n/// The name can be accessed using the [`name`], [`local_name`] or [`unescaped`] methods. An\n/// iterator over the attributes is returned by the [`attributes`] method.\n///\n/// [`name`]: #method.name\n/// [`local_name`]: #method.local_name\n/// [`unescaped`]: #method.unescaped\n/// [`attributes`]: #method.attributes\npub struct BytesStart<'a> {\n    /// content of the element, before any utf8 conversion\n    buf: Cow<'a, [u8]>,\n    /// end of the element name, the name starts at that the start of `buf`\n    name_len: usize,\n}",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::attributes": [
            "/// Returns an iterator over the attributes of this tag.\npub fn attributes(&self) -> Attributes{\n        Attributes::new(&self.buf, self.name_len)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::attributes_raw": [
            "/// Gets the undecoded raw string with the attributes of this tag as a `&[u8]`,\n/// including the whitespace after the tag name if there is any.\n#[inline]\npub fn attributes_raw(&self) -> &[u8]{\n        &self.buf[self.name_len..]\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::borrowed": [
            "/// Creates a new `BytesStart` from the given content (name + attributes).\n///\n/// # Warning\n///\n/// `&content[..name_len]` is not checked to be a valid name\n#[inline]\npub fn borrowed(content: &'a [u8], name_len: usize) -> Self{\n        BytesStart {\n            buf: Cow::Borrowed(content),\n            name_len,\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::borrowed_name": [
            "/// Creates a new `BytesStart` from the given name.\n///\n/// # Warning\n///\n/// `&content` is not checked to be a valid name\n#[inline]\npub fn borrowed_name(name: &'a [u8]) -> BytesStart<'a>{\n        Self::borrowed(name, name.len())\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::clear_attributes": [
            "/// Remove all attributes from the ByteStart\npub fn clear_attributes(&mut self) -> &mut BytesStart<'a>{\n        self.buf.to_mut().truncate(self.name_len);\n        self\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::do_unescape_and_decode_with_custom_entities": [
            "#[cfg(not(feature = \"encoding\"))]\n#[inline]\nfn do_unescape_and_decode_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<String>{\n        let decoded = reader.decode(&*self)?;\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::extend_attributes": [
            "/// Add additional attributes to this tag using an iterator.\n///\n/// The yielded items must be convertible to [`Attribute`] using `Into`.\npub fn extend_attributes<'b, I>(&mut self, attributes: I) -> &mut BytesStart<'a>\n    where\n        I: IntoIterator,\n        I::Item: Into<Attribute<'b>>,{\n        for attr in attributes {\n            self.push_attribute(attr);\n        }\n        self\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::html_attributes": [
            "/// Returns an iterator over the HTML-like attributes of this tag (no mandatory quotes or `=`).\npub fn html_attributes(&self) -> Attributes{\n        Attributes::html(self, self.name_len)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::into_owned": [
            "/// Converts the event into an owned event.\npub fn into_owned(self) -> BytesStart<'static>{\n        Self::owned(self.buf.into_owned(), self.name_len)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::local_name": [
            "/// Gets the undecoded raw local tag name (excluding namespace) as a `&[u8]`.\n///\n/// All content up to and including the first `:` character is removed from the tag name.\n#[inline]\npub fn local_name(&self) -> &[u8]{\n        let name = self.name();\n        memchr::memchr(b':', name).map_or(name, |i| &name[i + 1..])\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::make_unescaped": [
            "#[inline]\nfn make_unescaped<'s>(\n        &'s self,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<Cow<'s, [u8]>>{\n        do_unescape(&*self.buf, custom_entities).map_err(Error::EscapeError)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::name": [
            "/// Gets the undecoded raw tag name as a `&[u8]`.\n#[inline]\npub fn name(&self) -> &[u8]{\n        &self.buf[..self.name_len]\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::owned": [
            "/// Creates a new `BytesStart` from the given content (name + attributes)\n///\n/// Owns its contents.\n#[inline]\npub fn owned<C: Into<Vec<u8>>>(content: C, name_len: usize) -> BytesStart<'static>{\n        BytesStart {\n            buf: Cow::Owned(content.into()),\n            name_len,\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::owned_name": [
            "/// Creates a new `BytesStart` from the given name\n///\n/// Owns its contents.\n#[inline]\npub fn owned_name<C: Into<Vec<u8>>>(name: C) -> BytesStart<'static>{\n        let content = name.into();\n        BytesStart {\n            name_len: content.len(),\n            buf: Cow::Owned(content),\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::push_attribute": [
            "/// Adds an attribute to this element.\npub fn push_attribute<'b, A>(&mut self, attr: A)\n    where\n        A: Into<Attribute<'b>>,{\n        let a = attr.into();\n        let bytes = self.buf.to_mut();\n        bytes.push(b' ');\n        bytes.extend_from_slice(a.key);\n        bytes.extend_from_slice(b\"=\\\"\");\n        bytes.extend_from_slice(&*a.value);\n        bytes.push(b'\"');\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::set_name": [
            "/// Edit the name of the BytesStart in-place\n///\n/// # Warning\n///\n/// `name` is not checked to be a valid name\npub fn set_name(&mut self, name: &[u8]) -> &mut BytesStart<'a>{\n        let bytes = self.buf.to_mut();\n        bytes.splice(..self.name_len, name.iter().cloned());\n        self.name_len = name.len();\n        self\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::to_borrowed": [
            "/// Converts the event into a borrowed event. Most useful when paired with [`to_end`].\n///\n/// # Example\n///\n/// ```rust\n/// # use quick_xml::{Error, Writer};\n/// use quick_xml::events::{BytesStart, Event};\n///\n/// struct SomeStruct<'a> {\n///     attrs: BytesStart<'a>,\n///     // ...\n/// }\n/// # impl<'a> SomeStruct<'a> {\n/// # fn example(&self) -> Result<(), Error> {\n/// # let mut writer = Writer::new(Vec::new());\n///\n/// writer.write_event(Event::Start(self.attrs.to_borrowed()))?;\n/// // ...\n/// writer.write_event(Event::End(self.attrs.to_end()))?;\n/// # Ok(())\n/// # }}\n/// ```\n///\n/// [`to_end`]: #method.to_end\npub fn to_borrowed(&self) -> BytesStart{\n        BytesStart::borrowed(&self.buf, self.name_len)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::to_end": [
            "/// Creates new paired close tag\npub fn to_end(&self) -> BytesEnd{\n        BytesEnd::borrowed(self.name())\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::to_owned": [
            "/// Converts the event into an owned event without taking ownership of Event\npub fn to_owned(&self) -> BytesStart<'static>{\n        Self::owned(self.buf.to_owned(), self.name_len)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::try_get_attribute": [
            "/// Try to get an attribute\npub fn try_get_attribute<N: AsRef<[u8]> + Sized>(\n        &'a self,\n        attr_name: N,\n    ) -> Result<Option<Attribute<'a>>>{\n        for a in self.attributes() {\n            let a = a?;\n            if a.key == attr_name.as_ref() {\n                return Ok(Some(a));\n            }\n        }\n        Ok(None)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::unescape_and_decode": [
            "/// Returns the unescaped and decoded string value.\n///\n/// This allocates a `String` in all cases. For performance reasons it might be a better idea to\n/// instead use one of:\n///\n/// * [`unescaped()`], as it doesn't allocate when no escape sequences are used.\n/// * [`Reader::decode()`], as it only allocates when the decoding can't be performed otherwise.\n///\n/// [`unescaped()`]: #method.unescaped\n/// [`Reader::decode()`]: ../reader/struct.Reader.html#method.decode\n#[inline]\npub fn unescape_and_decode<B: BufRead>(&self, reader: &Reader<B>) -> Result<String>{\n        self.do_unescape_and_decode_with_custom_entities(reader, None)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::unescape_and_decode_with_custom_entities": [
            "/// Returns the unescaped and decoded string value with custom entities.\n///\n/// This allocates a `String` in all cases. For performance reasons it might be a better idea to\n/// instead use one of:\n///\n/// * [`unescaped_with_custom_entities()`], as it doesn't allocate when no escape sequences are used.\n/// * [`Reader::decode()`], as it only allocates when the decoding can't be performed otherwise.\n///\n/// [`unescaped_with_custom_entities()`]: #method.unescaped_with_custom_entities\n/// [`Reader::decode()`]: ../reader/struct.Reader.html#method.decode\n///\n/// # Pre-condition\n///\n/// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n#[inline]\npub fn unescape_and_decode_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> Result<String>{\n        self.do_unescape_and_decode_with_custom_entities(reader, Some(custom_entities))\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::unescaped": [
            "/// Gets the unescaped tag name.\n///\n/// XML escape sequences like \"`&lt;`\" will be replaced by their unescaped characters like\n/// \"`<`\".\n///\n/// See also [`unescaped_with_custom_entities()`](#method.unescaped_with_custom_entities)\n#[inline]\npub fn unescaped(&self) -> Result<Cow<[u8]>>{\n        self.make_unescaped(None)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::unescaped_with_custom_entities": [
            "/// Gets the unescaped tag name, using custom entities.\n///\n/// XML escape sequences like \"`&lt;`\" will be replaced by their unescaped characters like\n/// \"`<`\".\n/// Additional entities can be provided in `custom_entities`.\n///\n/// # Pre-condition\n///\n/// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n///\n/// See also [`unescaped()`](#method.unescaped)\n#[inline]\npub fn unescaped_with_custom_entities<'s>(\n        &'s self,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> Result<Cow<'s, [u8]>>{\n        self.make_unescaped(Some(custom_entities))\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesStart::<'a>::with_attributes": [
            "/// Consumes `self` and yield a new `BytesStart` with additional attributes from an iterator.\n///\n/// The yielded items must be convertible to [`Attribute`] using `Into`.\npub fn with_attributes<'b, I>(mut self, attributes: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Into<Attribute<'b>>,{\n        self.extend_attributes(attributes);\n        self\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText": [
            "/// Data from various events (most notably, `Event::Text`) that stored in XML\n/// in escaped form. Internally data is stored in escaped form\npub struct BytesText<'a> {\n    // Invariant: The content is always escaped.\n    content: Cow<'a, [u8]>,\n}",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::do_unescape_and_decode_with_custom_entities": [
            "#[cfg(not(feature = \"encoding\"))]\nfn do_unescape_and_decode_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<String>{\n        let decoded = reader.decode(&*self)?;\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::do_unescape_and_decode_without_bom": [
            "#[cfg(not(feature = \"encoding\"))]\nfn do_unescape_and_decode_without_bom<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<String>{\n        let decoded = reader.decode_without_bom(&*self)?;\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::escaped": [
            "/// Gets escaped content.\npub fn escaped(&self) -> &[u8]{\n        self.content.as_ref()\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::from_escaped": [
            "/// Creates a new `BytesText` from an escaped byte sequence.\n#[inline]\npub fn from_escaped<C: Into<Cow<'a, [u8]>>>(content: C) -> Self{\n        Self {\n            content: content.into(),\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::from_escaped_str": [
            "/// Creates a new `BytesText` from an escaped string.\n#[inline]\npub fn from_escaped_str<C: Into<Cow<'a, str>>>(content: C) -> Self{\n        Self::from_escaped(match content.into() {\n            Cow::Owned(o) => Cow::Owned(o.into_bytes()),\n            Cow::Borrowed(b) => Cow::Borrowed(b.as_bytes()),\n        })\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::from_plain": [
            "/// Creates a new `BytesText` from a byte sequence. The byte sequence is\n/// expected not to be escaped.\n#[inline]\npub fn from_plain(content: &'a [u8]) -> Self{\n        Self {\n            content: escape(content),\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::from_plain_str": [
            "/// Creates a new `BytesText` from a string. The string is expected not to\n/// be escaped.\n#[inline]\npub fn from_plain_str(content: &'a str) -> Self{\n        Self::from_plain(content.as_bytes())\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::into_inner": [
            "/// Extracts the inner `Cow` from the `BytesText` event container.\n#[inline]\npub fn into_inner(self) -> Cow<'a, [u8]>{\n        self.content\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::into_owned": [
            "/// Ensures that all data is owned to extend the object's lifetime if\n/// necessary.\n#[inline]\npub fn into_owned(self) -> BytesText<'static>{\n        BytesText {\n            content: self.content.into_owned().into(),\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::make_unescaped": [
            "fn make_unescaped<'s>(\n        &'s self,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> Result<Cow<'s, [u8]>>{\n        do_unescape(self, custom_entities).map_err(Error::EscapeError)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::unescape_and_decode": [
            "/// helper method to unescape then decode self using the reader encoding\n///\n/// for performance reasons (could avoid allocating a `String`),\n/// it might be wiser to manually use\n/// 1. BytesText::unescaped()\n/// 2. Reader::decode(...)\npub fn unescape_and_decode<B: BufRead>(&self, reader: &Reader<B>) -> Result<String>{\n        self.do_unescape_and_decode_with_custom_entities(reader, None)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::unescape_and_decode_with_custom_entities": [
            "/// helper method to unescape then decode self using the reader encoding with custom entities\n///\n/// for performance reasons (could avoid allocating a `String`),\n/// it might be wiser to manually use\n/// 1. BytesText::unescaped()\n/// 2. Reader::decode(...)\n///\n/// # Pre-condition\n///\n/// The keys and values of `custom_entities`, if any, must be valid UTF-8.\npub fn unescape_and_decode_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> Result<String>{\n        self.do_unescape_and_decode_with_custom_entities(reader, Some(custom_entities))\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::unescape_and_decode_without_bom": [
            "/// helper method to unescape then decode self using the reader encoding\n/// but without BOM (Byte order mark)\n///\n/// for performance reasons (could avoid allocating a `String`),\n/// it might be wiser to manually use\n/// 1. BytesText::unescaped()\n/// 2. Reader::decode(...)\n#[cfg(not(feature = \"encoding\"))]\npub fn unescape_and_decode_without_bom<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n    ) -> Result<String>{\n        self.do_unescape_and_decode_without_bom(reader, None)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::unescape_and_decode_without_bom_with_custom_entities": [
            "/// helper method to unescape then decode self using the reader encoding with custom entities\n/// but without BOM (Byte order mark)\n///\n/// for performance reasons (could avoid allocating a `String`),\n/// it might be wiser to manually use\n/// 1. BytesText::unescaped()\n/// 2. Reader::decode(...)\n///\n/// # Pre-condition\n///\n/// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n#[cfg(not(feature = \"encoding\"))]\npub fn unescape_and_decode_without_bom_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> Result<String>{\n        self.do_unescape_and_decode_without_bom(reader, Some(custom_entities))\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::unescaped": [
            "/// gets escaped content\n///\n/// Searches for '&' into content and try to escape the coded character if possible\n/// returns Malformed error with index within element if '&' is not followed by ';'\n///\n/// See also [`unescaped_with_custom_entities()`](#method.unescaped_with_custom_entities)\npub fn unescaped(&self) -> Result<Cow<[u8]>>{\n        self.make_unescaped(None)\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::BytesText::<'a>::unescaped_with_custom_entities": [
            "/// gets escaped content with custom entities\n///\n/// Searches for '&' into content and try to escape the coded character if possible\n/// returns Malformed error with index within element if '&' is not followed by ';'\n/// Additional entities can be provided in `custom_entities`.\n///\n/// # Pre-condition\n///\n/// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n///\n/// See also [`unescaped()`](#method.unescaped)\npub fn unescaped_with_custom_entities<'s>(\n        &'s self,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> Result<Cow<'s, [u8]>>{\n        self.make_unescaped(Some(custom_entities))\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::Event": [
            "/// Event emitted by [`Reader::read_event`].\n///\n/// [`Reader::read_event`]: ../reader/struct.Reader.html#method.read_event\npub enum Event<'a> {\n    /// Start tag (with attributes) `<tag attr=\"value\">`.\n    Start(BytesStart<'a>),\n    /// End tag `</tag>`.\n    End(BytesEnd<'a>),\n    /// Empty element tag (with attributes) `<tag attr=\"value\" />`.\n    Empty(BytesStart<'a>),\n    /// Character data between `Start` and `End` element.\n    Text(BytesText<'a>),\n    /// Comment `<!-- ... -->`.\n    Comment(BytesText<'a>),\n    /// CData `<![CDATA[...]]>`.\n    CData(BytesCData<'a>),\n    /// XML declaration `<?xml ...?>`.\n    Decl(BytesDecl<'a>),\n    /// Processing instruction `<?...?>`.\n    PI(BytesText<'a>),\n    /// Doctype `<!DOCTYPE ...>`.\n    DocType(BytesText<'a>),\n    /// End of XML document.\n    Eof,\n}",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::Event::<'a>::into_owned": [
            "/// Converts the event to an owned version, untied to the lifetime of\n/// buffer used when reading but incurring a new, separate allocation.\npub fn into_owned(self) -> Event<'static>{\n        match self {\n            Event::Start(e) => Event::Start(e.into_owned()),\n            Event::End(e) => Event::End(e.into_owned()),\n            Event::Empty(e) => Event::Empty(e.into_owned()),\n            Event::Text(e) => Event::Text(e.into_owned()),\n            Event::Comment(e) => Event::Comment(e.into_owned()),\n            Event::CData(e) => Event::CData(e.into_owned()),\n            Event::Decl(e) => Event::Decl(e.into_owned()),\n            Event::PI(e) => Event::PI(e.into_owned()),\n            Event::DocType(e) => Event::DocType(e.into_owned()),\n            Event::Eof => Event::Eof,\n        }\n    }",
            "Real(LocalPath(\"src/events/mod.rs\"))"
        ],
        "events::attributes::<impl std::convert::From<events::attributes::Attr<T>> for (T, std::option::Option<T>)>::from": [
            "#[inline]\nfn from(attr: Attr<T>) -> Self{\n        match attr {\n            Attr::DoubleQ(key, value) => (key, Some(value)),\n            Attr::SingleQ(key, value) => (key, Some(value)),\n            Attr::Empty(key) => (key, None),\n            Attr::Unquoted(key, value) => (key, Some(value)),\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attr": [
            "/// A struct representing a key/value XML or HTML [attribute].\n///\n/// [attribute]: https://www.w3.org/TR/xml11/#NT-Attribute\npub enum Attr<T> {\n    /// Attribute with value enclosed in double quotes (`\"`). Attribute key and\n    /// value provided. This is a canonical XML-style attribute.\n    DoubleQ(T, T),\n    /// Attribute with value enclosed in single quotes (`'`). Attribute key and\n    /// value provided. This is an XML-style attribute.\n    SingleQ(T, T),\n    /// Attribute with value not enclosed in quotes. Attribute key and value\n    /// provided. This is HTML-style attribute, it can be returned in HTML-mode\n    /// parsing only. In an XML mode [`AttrError::UnquotedValue`] will be raised\n    /// instead.\n    ///\n    /// Attribute value can be invalid according to the [HTML specification],\n    /// in particular, it can contain `\"`, `'`, `=`, `<`, and <code>&#96;</code>\n    /// characters. The absence of the `>` character is nevertheless guaranteed,\n    /// since the parser extracts [events] based on them even before the start\n    /// of parsing attributes.\n    ///\n    /// [HTML specification]: https://html.spec.whatwg.org/#unquoted\n    /// [events]: crate::events::Event::Start\n    Unquoted(T, T),\n    /// Attribute without value. Attribute key provided. This is HTML-style attribute,\n    /// it can be returned in HTML-mode parsing only. In XML mode\n    /// [`AttrError::ExpectedEq`] will be raised instead.\n    Empty(T),\n}",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attr::<&'a [u8]>::key": [
            "/// Returns the key value\n#[inline]\npub fn key(&self) -> &'a [u8]{\n        match self {\n            Attr::DoubleQ(key, _) => key,\n            Attr::SingleQ(key, _) => key,\n            Attr::Empty(key) => key,\n            Attr::Unquoted(key, _) => key,\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attr::<&'a [u8]>::value": [
            "/// Returns the attribute value. For [`Self::Empty`] variant an empty slice\n/// is returned according to the [HTML specification].\n///\n/// [HTML specification]: https://www.w3.org/TR/2012/WD-html-markup-20120329/syntax.html#syntax-attr-empty\n#[inline]\npub fn value(&self) -> &'a [u8]{\n        match self {\n            Attr::DoubleQ(_, value) => value,\n            Attr::SingleQ(_, value) => value,\n            Attr::Empty(_) => &[],\n            Attr::Unquoted(_, value) => value,\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attr::<T>::map": [
            "/// Maps an `Attr<T>` to `Attr<U>` by applying a function to a contained key and value.\n#[inline]\npub fn map<U, F>(self, mut f: F) -> Attr<U>\n    where\n        F: FnMut(T) -> U,{\n        match self {\n            Attr::DoubleQ(key, value) => Attr::DoubleQ(f(key), f(value)),\n            Attr::SingleQ(key, value) => Attr::SingleQ(f(key), f(value)),\n            Attr::Empty(key) => Attr::Empty(f(key)),\n            Attr::Unquoted(key, value) => Attr::Unquoted(f(key), f(value)),\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::AttrError": [
            "/// Errors that can be raised during parsing attributes.\n///\n/// Recovery position in examples shows the position from which parsing of the\n/// next attribute will be attempted.\npub enum AttrError {\n    /// Attribute key was not followed by `=`, position relative to the start of\n    /// the owning tag is provided.\n    ///\n    /// Example of input that raises this error:\n    ///\n    /// ```xml\n    /// <tag key another=\"attribute\"/>\n    /// <!--     ^~~ error position, recovery position (8) -->\n    /// ```\n    ///\n    /// This error can be raised only when the iterator is in XML mode.\n    ExpectedEq(usize),\n    /// Attribute value was not found after `=`, position relative to the start\n    /// of the owning tag is provided.\n    ///\n    /// Example of input that raises this error:\n    ///\n    /// ```xml\n    /// <tag key = />\n    /// <!--       ^~~ error position, recovery position (10) -->\n    /// ```\n    ///\n    /// This error can be returned only for the last attribute in the list,\n    /// because otherwise any content after `=` will be threated as a value.\n    /// The XML\n    ///\n    /// ```xml\n    /// <tag key = another-key = \"value\"/>\n    /// <!--                   ^ ^- recovery position (24) -->\n    /// <!--                   '~~ error position (22) -->\n    /// ```\n    ///\n    /// will be treated as `Attribute { key = b\"key\", value = b\"another-key\" }`\n    /// and or [`Attribute`] is returned, or [`AttrError::UnquotedValue`] is raised,\n    /// depending on the parsing mode.\n    ExpectedValue(usize),\n    /// Attribute value is not quoted, position relative to the start of the\n    /// owning tag is provided.\n    ///\n    /// Example of input that raises this error:\n    ///\n    /// ```xml\n    /// <tag key = value />\n    /// <!--       ^    ^~~ recovery position (15) -->\n    /// <!--       '~~ error position (10) -->\n    /// ```\n    ///\n    /// This error can be raised only when the iterator is in XML mode.\n    UnquotedValue(usize),\n    /// Attribute value was not finished with a matching quote, position relative\n    /// to the start of owning tag and a quote is provided. That position is always\n    /// a last character in the tag content.\n    ///\n    /// Example of input that raises this error:\n    ///\n    /// ```xml\n    /// <tag key = \"value  />\n    /// <tag key = 'value  />\n    /// <!--               ^~~ error position, recovery position (18) -->\n    /// ```\n    ///\n    /// This error can be returned only for the last attribute in the list,\n    /// because all input was consumed during scanning for a quote.\n    ExpectedQuote(usize, u8),\n    /// An attribute with the same name was already encountered. Two parameters\n    /// define (1) the error position relative to the start of the owning tag\n    /// for a new attribute and (2) the start position of a previously encountered\n    /// attribute with the same name.\n    ///\n    /// Example of input that raises this error:\n    ///\n    /// ```xml\n    /// <tag key = 'value'  key=\"value2\" attr3='value3' />\n    /// <!-- ^              ^            ^~~ recovery position (32) -->\n    /// <!-- |              '~~ error position (19) -->\n    /// <!-- '~~ previous position (4) -->\n    /// ```\n    ///\n    /// This error is returned only when [`Attributes::with_checks()`] is set\n    /// to `true` (that is default behavior).\n    Duplicated(usize, usize),\n}",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attribute": [
            "/// A struct representing a key/value XML attribute.\n///\n/// Field `value` stores raw bytes, possibly containing escape-sequences. Most users will likely\n/// want to access the value using one of the [`unescaped_value`] and [`unescape_and_decode_value`]\n/// functions.\n///\n/// [`unescaped_value`]: #method.unescaped_value\n/// [`unescape_and_decode_value`]: #method.unescape_and_decode_value\npub struct Attribute<'a> {\n    /// The key to uniquely define the attribute.\n    ///\n    /// If [`Attributes::with_checks`] is turned off, the key might not be unique.\n    ///\n    /// [`Attributes::with_checks`]: struct.Attributes.html#method.with_checks\n    pub key: &'a [u8],\n    /// The raw value of the attribute.\n    pub value: Cow<'a, [u8]>,\n}",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attribute::<'a>::do_unescape_and_decode_value": [
            "#[cfg(not(feature = \"encoding\"))]\nfn do_unescape_and_decode_value<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> XmlResult<String>{\n        let decoded = reader.decode(&*self.value)?;\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attribute::<'a>::do_unescape_and_decode_without_bom": [
            "#[cfg(not(feature = \"encoding\"))]\nfn do_unescape_and_decode_without_bom<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> XmlResult<String>{\n        let decoded = reader.decode_without_bom(&*self.value)?;\n        let unescaped =\n            do_unescape(decoded.as_bytes(), custom_entities).map_err(Error::EscapeError)?;\n        String::from_utf8(unescaped.into_owned()).map_err(|e| Error::Utf8(e.utf8_error()))\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attribute::<'a>::make_unescaped_value": [
            "fn make_unescaped_value(\n        &self,\n        custom_entities: Option<&HashMap<Vec<u8>, Vec<u8>>>,\n    ) -> XmlResult<Cow<[u8]>>{\n        do_unescape(&*self.value, custom_entities).map_err(Error::EscapeError)\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attribute::<'a>::unescape_and_decode_value": [
            "/// Decode then unescapes the value\n///\n/// This allocates a `String` in all cases. For performance reasons it might be a better idea to\n/// instead use one of:\n///\n/// * [`Reader::decode()`], as it only allocates when the decoding can't be performed otherwise.\n/// * [`unescaped_value()`], as it doesn't allocate when no escape sequences are used.\n///\n/// [`unescaped_value()`]: #method.unescaped_value\n/// [`Reader::decode()`]: ../../reader/struct.Reader.html#method.decode\npub fn unescape_and_decode_value<B: BufRead>(&self, reader: &Reader<B>) -> XmlResult<String>{\n        self.do_unescape_and_decode_value(reader, None)\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attribute::<'a>::unescape_and_decode_value_with_custom_entities": [
            "/// Decode then unescapes the value with custom entities\n///\n/// This allocates a `String` in all cases. For performance reasons it might be a better idea to\n/// instead use one of:\n///\n/// * [`Reader::decode()`], as it only allocates when the decoding can't be performed otherwise.\n/// * [`unescaped_value_with_custom_entities()`], as it doesn't allocate when no escape sequences are used.\n///\n/// [`unescaped_value_with_custom_entities()`]: #method.unescaped_value_with_custom_entities\n/// [`Reader::decode()`]: ../../reader/struct.Reader.html#method.decode\n///\n/// # Pre-condition\n///\n/// The keys and values of `custom_entities`, if any, must be valid UTF-8.\npub fn unescape_and_decode_value_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> XmlResult<String>{\n        self.do_unescape_and_decode_value(reader, Some(custom_entities))\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attribute::<'a>::unescape_and_decode_without_bom": [
            "/// helper method to unescape then decode self using the reader encoding\n/// but without BOM (Byte order mark)\n///\n/// for performance reasons (could avoid allocating a `String`),\n/// it might be wiser to manually use\n/// 1. BytesText::unescaped()\n/// 2. Reader::decode(...)\n#[cfg(not(feature = \"encoding\"))]\npub fn unescape_and_decode_without_bom<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n    ) -> XmlResult<String>{\n        self.do_unescape_and_decode_without_bom(reader, None)\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attribute::<'a>::unescape_and_decode_without_bom_with_custom_entities": [
            "/// helper method to unescape then decode self using the reader encoding with custom entities\n/// but without BOM (Byte order mark)\n///\n/// for performance reasons (could avoid allocating a `String`),\n/// it might be wiser to manually use\n/// 1. BytesText::unescaped()\n/// 2. Reader::decode(...)\n///\n/// # Pre-condition\n///\n/// The keys and values of `custom_entities`, if any, must be valid UTF-8.\n#[cfg(not(feature = \"encoding\"))]\npub fn unescape_and_decode_without_bom_with_custom_entities<B: BufRead>(\n        &self,\n        reader: &Reader<B>,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> XmlResult<String>{\n        self.do_unescape_and_decode_without_bom(reader, Some(custom_entities))\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attribute::<'a>::unescaped_value": [
            "/// Returns the unescaped value.\n///\n/// This is normally the value you are interested in. Escape sequences such as `&gt;` are\n/// replaced with their unescaped equivalents such as `>`.\n///\n/// This will allocate if the value contains any escape sequences.\n///\n/// See also [`unescaped_value_with_custom_entities()`](#method.unescaped_value_with_custom_entities)\npub fn unescaped_value(&self) -> XmlResult<Cow<[u8]>>{\n        self.make_unescaped_value(None)\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attribute::<'a>::unescaped_value_with_custom_entities": [
            "/// Returns the unescaped value, using custom entities.\n///\n/// This is normally the value you are interested in. Escape sequences such as `&gt;` are\n/// replaced with their unescaped equivalents such as `>`.\n/// Additional entities can be provided in `custom_entities`.\n///\n/// This will allocate if the value contains any escape sequences.\n///\n/// See also [`unescaped_value()`](#method.unescaped_value)\n///\n/// # Pre-condition\n///\n/// The keys and values of `custom_entities`, if any, must be valid UTF-8.\npub fn unescaped_value_with_custom_entities(\n        &self,\n        custom_entities: &HashMap<Vec<u8>, Vec<u8>>,\n    ) -> XmlResult<Cow<[u8]>>{\n        self.make_unescaped_value(Some(custom_entities))\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attributes": [
            "/// Iterator over XML attributes.\n///\n/// Yields `Result<Attribute>`. An `Err` will be yielded if an attribute is malformed or duplicated.\n/// The duplicate check can be turned off by calling [`with_checks(false)`].\n///\n/// [`with_checks(false)`]: #method.with_checks\npub struct Attributes<'a> {\n    /// slice of `Element` corresponding to attributes\n    bytes: &'a [u8],\n    /// Iterator state, independent from the actual source of bytes\n    state: IterState,\n}",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attributes::<'a>::html": [
            "/// Creates a new attribute iterator from a buffer, allowing HTML attribute syntax.\npub fn html(buf: &'a [u8], pos: usize) -> Self{\n        Self {\n            bytes: buf,\n            state: IterState::new(pos, true),\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attributes::<'a>::new": [
            "/// Creates a new attribute iterator from a buffer.\npub fn new(buf: &'a [u8], pos: usize) -> Self{\n        Self {\n            bytes: buf,\n            state: IterState::new(pos, false),\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::Attributes::<'a>::with_checks": [
            "/// Changes whether attributes should be checked for uniqueness.\n///\n/// The XML specification requires attribute keys in the same element to be unique. This check\n/// can be disabled to improve performance slightly.\n///\n/// (`true` by default)\npub fn with_checks(&mut self, val: bool) -> &mut Attributes<'a>{\n        self.state.check_duplicates = val;\n        self\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::IterState": [
            "/// External iterator over spans of attribute key and value\npub(crate) struct IterState {\n    /// Iteration state that determines what actions should be done before the\n    /// actual parsing of the next attribute\n    state: State,\n    /// If `true`, enables ability to parse unquoted values and key-only (empty)\n    /// attributes\n    html: bool,\n    /// If `true`, checks for duplicate names\n    check_duplicates: bool,\n    /// If `check_duplicates` is set, contains the ranges of already parsed attribute\n    /// names. We store a ranges instead of slices to able to report a previous\n    /// attribute position\n    keys: Vec<Range<usize>>,\n}",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::IterState::check_for_duplicates": [
            "#[inline]\nfn check_for_duplicates(\n        &mut self,\n        slice: &[u8],\n        key: Range<usize>,\n    ) -> Result<Range<usize>, AttrError>{\n        if self.check_duplicates {\n            if let Some(prev) = self\n                .keys\n                .iter()\n                .find(|r| slice[(*r).clone()] == slice[key.clone()])\n            {\n                return Err(AttrError::Duplicated(key.start, prev.start));\n            }\n            self.keys.push(key.clone());\n        }\n        Ok(key)\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::IterState::double_q": [
            "#[inline]\nfn double_q(&mut self, key: Range<usize>, value: Range<usize>) -> Option<AttrResult>{\n        self.state = State::Next(value.end + 1); // +1 for `\"`\n\n        Some(Ok(Attr::DoubleQ(key, value)))\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::IterState::key_only": [
            "/// # Parameters\n///\n/// - `slice`: content of the tag, used for checking for duplicates\n/// - `key`: Range of key in slice, if iterator in HTML mode\n/// - `offset`: Position of error if iterator in XML mode\n#[inline]\nfn key_only(&mut self, slice: &[u8], key: Range<usize>, offset: usize) -> Option<AttrResult>{\n        Some(if self.html {\n            self.check_for_duplicates(slice, key).map(Attr::Empty)\n        } else {\n            Err(AttrError::ExpectedEq(offset))\n        })\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::IterState::new": [
            "pub fn new(offset: usize, html: bool) -> Self{\n        Self {\n            state: State::Next(offset),\n            html,\n            check_duplicates: true,\n            keys: Vec::new(),\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::IterState::next": [
            "pub fn next(&mut self, slice: &[u8]) -> Option<AttrResult>{\n        let mut iter = match self.recover(slice) {\n            Some(offset) => (offset..).zip(slice[offset..].iter()),\n            None => return None,\n        };\n\n        // Index where next key started\n        let start_key = match iter.find(|(_, &b)| !is_whitespace(b)) {\n            // Input: `    key`\n            //             ^\n            Some((s, _)) => s,\n            // Input: `    `\n            //             ^\n            None => {\n                // Because we reach end-of-input, stop iteration on next call\n                self.state = State::Done;\n                return None;\n            }\n        };\n        // Span of a key\n        let (key, offset) = match iter.find(|(_, &b)| b == b'=' || is_whitespace(b)) {\n            // Input: `    key=`\n            //             |  ^\n            //             s  e\n            Some((e, b'=')) => (start_key..e, e),\n\n            // Input: `    key `\n            //                ^\n            Some((e, _)) => match iter.find(|(_, &b)| !is_whitespace(b)) {\n                // Input: `    key  =`\n                //             |  | ^\n                //     start_key  e\n                Some((offset, b'=')) => (start_key..e, offset),\n                // Input: `    key  x`\n                //             |  | ^\n                //     start_key  e\n                // If HTML-like attributes is allowed, this is the result, otherwise error\n                Some((offset, _)) => {\n                    // In any case, recovering is not required\n                    self.state = State::Next(offset);\n                    return self.key_only(slice, start_key..e, offset);\n                }\n                // Input: `    key  `\n                //             |  | ^\n                //     start_key  e\n                // If HTML-like attributes is allowed, this is the result, otherwise error\n                None => {\n                    // Because we reach end-of-input, stop iteration on next call\n                    self.state = State::Done;\n                    return self.key_only(slice, start_key..e, slice.len());\n                }\n            },\n\n            // Input: `    key`\n            //             |  ^\n            //             s  e = len()\n            // If HTML-like attributes is allowed, this is the result, otherwise error\n            None => {\n                // Because we reach end-of-input, stop iteration on next call\n                self.state = State::Done;\n                let e = slice.len();\n                return self.key_only(slice, start_key..e, e);\n            }\n        };\n\n        let key = match self.check_for_duplicates(slice, key) {\n            Err(e) => {\n                self.state = State::SkipEqValue(offset);\n                return Some(Err(e));\n            }\n            Ok(key) => key,\n        };\n\n        ////////////////////////////////////////////////////////////////////////\n\n        // Gets the position of quote and quote type\n        let (start_value, quote) = match iter.find(|(_, &b)| !is_whitespace(b)) {\n            // Input: `    key  =  \"`\n            //                     ^\n            Some((s, b'\"')) => (s + 1, b'\"'),\n            // Input: `    key  =  '`\n            //                     ^\n            Some((s, b'\\'')) => (s + 1, b'\\''),\n\n            // Input: `    key  =  x`\n            //                     ^\n            // If HTML-like attributes is allowed, this is the start of the value\n            Some((s, _)) if self.html => {\n                // We do not check validity of attribute value characters as required\n                // according to https://html.spec.whatwg.org/#unquoted. It can be done\n                // during validation phase\n                let end = match iter.find(|(_, &b)| is_whitespace(b)) {\n                    // Input: `    key  =  value `\n                    //                     |    ^\n                    //                     s    e\n                    Some((e, _)) => e,\n                    // Input: `    key  =  value`\n                    //                     |    ^\n                    //                     s    e = len()\n                    None => slice.len(),\n                };\n                self.state = State::Next(end);\n                return Some(Ok(Attr::Unquoted(key, s..end)));\n            }\n            // Input: `    key  =  x`\n            //                     ^\n            Some((s, _)) => {\n                self.state = State::SkipValue(s);\n                return Some(Err(AttrError::UnquotedValue(s)));\n            }\n\n            // Input: `    key  =  `\n            //                     ^\n            None => {\n                // Because we reach end-of-input, stop iteration on next call\n                self.state = State::Done;\n                return Some(Err(AttrError::ExpectedValue(slice.len())));\n            }\n        };\n\n        match iter.find(|(_, &b)| b == quote) {\n            // Input: `    key  =  \"   \"`\n            //                         ^\n            Some((e, b'\"')) => self.double_q(key, start_value..e),\n            // Input: `    key  =  '   '`\n            //                         ^\n            Some((e, _)) => self.single_q(key, start_value..e),\n\n            // Input: `    key  =  \"   `\n            // Input: `    key  =  '   `\n            //                         ^\n            // Closing quote not found\n            None => {\n                // Because we reach end-of-input, stop iteration on next call\n                self.state = State::Done;\n                return Some(Err(AttrError::ExpectedQuote(slice.len(), quote)));\n            }\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::IterState::recover": [
            "/// Recover from an error that could have been made on a previous step.\n/// Returns an offset from which parsing should continue.\n/// If there no input left, returns `None`.\nfn recover(&self, slice: &[u8]) -> Option<usize>{\n        match self.state {\n            State::Done => None,\n            State::Next(offset) => Some(offset),\n            State::SkipValue(offset) => self.skip_value(slice, offset),\n            State::SkipEqValue(offset) => self.skip_eq_value(slice, offset),\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::IterState::single_q": [
            "#[inline]\nfn single_q(&mut self, key: Range<usize>, value: Range<usize>) -> Option<AttrResult>{\n        self.state = State::Next(value.end + 1); // +1 for `'`\n\n        Some(Ok(Attr::SingleQ(key, value)))\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::IterState::skip_eq_value": [
            "/// Skip all characters up to first space symbol or end-of-input\n#[inline]\nfn skip_eq_value(&self, slice: &[u8], offset: usize) -> Option<usize>{\n        let mut iter = (offset..).zip(slice[offset..].iter());\n\n        // Skip all up to the quote and get the quote type\n        let quote = match iter.find(|(_, &b)| !is_whitespace(b)) {\n            // Input: `    key  =  \"`\n            //                  |  ^\n            //             offset\n            Some((_, b'\"')) => b'\"',\n            // Input: `    key  =  '`\n            //                  |  ^\n            //             offset\n            Some((_, b'\\'')) => b'\\'',\n\n            // Input: `    key  =  x`\n            //                  |  ^\n            //             offset\n            Some((offset, _)) => return self.skip_value(slice, offset),\n            // Input: `    key  =  `\n            //                  |  ^\n            //             offset\n            None => return None,\n        };\n\n        match iter.find(|(_, &b)| b == quote) {\n            // Input: `    key  =  \"   \"`\n            //                         ^\n            Some((e, b'\"')) => Some(e),\n            // Input: `    key  =  '   '`\n            //                         ^\n            Some((e, _)) => Some(e),\n\n            // Input: `    key  =  \"   `\n            // Input: `    key  =  '   `\n            //                         ^\n            // Closing quote not found\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::IterState::skip_value": [
            "/// Skip all characters up to first space symbol or end-of-input\n#[inline]\nfn skip_value(&self, slice: &[u8], offset: usize) -> Option<usize>{\n        let mut iter = (offset..).zip(slice[offset..].iter());\n\n        match iter.find(|(_, &b)| is_whitespace(b)) {\n            // Input: `    key  =  value `\n            //                     |    ^\n            //                offset    e\n            Some((e, _)) => Some(e),\n            // Input: `    key  =  value`\n            //                     |    ^\n            //                offset    e = len()\n            None => None,\n        }\n    }",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "events::attributes::State": [
            "enum State {\n    /// Iteration finished, iterator will return `None` to all [`IterState::next`]\n    /// requests.\n    Done,\n    /// The last attribute returned was deserialized successfully. Contains an\n    /// offset from which next attribute should be searched.\n    Next(usize),\n    /// The last attribute returns [`AttrError::UnquotedValue`], offset pointed\n    /// to the beginning of the value. Recover should skip a value\n    SkipValue(usize),\n    /// The last attribute returns [`AttrError::Duplicated`], offset pointed to\n    /// the equal (`=`) sign. Recover should skip it and a value\n    SkipEqValue(usize),\n}",
            "Real(LocalPath(\"src/events/attributes.rs\"))"
        ],
        "reader::BangType": [
            "/// Possible elements started with `<!`\nenum BangType {\n    /// <![CDATA[...]]>\n    CData,\n    /// <!--...-->\n    Comment,\n    /// <!DOCTYPE...>\n    DocType,\n}",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::BangType::new": [
            "#[inline(always)]\nfn new(byte: Option<u8>) -> Result<Self>{\n        Ok(match byte {\n            Some(b'[') => Self::CData,\n            Some(b'-') => Self::Comment,\n            Some(b'D') | Some(b'd') => Self::DocType,\n            Some(b) => return Err(Error::UnexpectedBang(b)),\n            None => return Err(Error::UnexpectedEof(\"Bang\".to_string())),\n        })\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::BangType::parse": [
            "/// If element is finished, returns its content up to `>` symbol and\n/// an index of this symbol, otherwise returns `None`\n#[inline(always)]\nfn parse<'b>(&self, chunk: &'b [u8], offset: usize) -> Option<(&'b [u8], usize)>{\n        for i in memchr::memchr_iter(b'>', chunk) {\n            match self {\n                // Need to read at least 6 symbols (`!---->`) for properly finished comment\n                // <!----> - XML comment\n                //  012345 - i\n                Self::Comment => {\n                    if offset + i > 4 && chunk[..i].ends_with(b\"--\") {\n                        // We cannot strip last `--` from the buffer because we need it in case of\n                        // check_comments enabled option. XML standard requires that comment\n                        // will not end with `--->` sequence because this is a special case of\n                        // `--` in the comment (https://www.w3.org/TR/xml11/#sec-comments)\n                        return Some((&chunk[..i], i + 1)); // +1 for `>`\n                    }\n                }\n                Self::CData => {\n                    if chunk[..i].ends_with(b\"]]\") {\n                        return Some((&chunk[..i - 2], i + 1)); // +1 for `>`\n                    }\n                }\n                Self::DocType => {\n                    let content = &chunk[..i];\n                    let balance = memchr::memchr2_iter(b'<', b'>', content)\n                        .map(|p| if content[p] == b'<' { 1i32 } else { -1 })\n                        .sum::<i32>();\n                    if balance == 0 {\n                        return Some((content, i + 1)); // +1 for `>`\n                    }\n                }\n            }\n        }\n        None\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::BangType::to_err": [
            "#[inline]\nfn to_err(self) -> Error{\n        let bang_str = match self {\n            Self::CData => \"CData\",\n            Self::Comment => \"Comment\",\n            Self::DocType => \"DOCTYPE\",\n        };\n        Error::UnexpectedEof(bang_str.to_string())\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Decoder": [
            "/// Utf8 Decoder\n#[cfg(not(feature = \"encoding\"))]\npub struct Decoder;",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Decoder::decode": [
            "#[cfg(not(feature = \"encoding\"))]\npub fn decode<'c>(&self, bytes: &'c [u8]) -> Result<&'c str>{\n        from_utf8(bytes).map_err(Error::Utf8)\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Decoder::decode_owned": [
            "#[cfg(not(feature = \"encoding\"))]\npub fn decode_owned<'c>(&self, bytes: Vec<u8>) -> Result<String>{\n        String::from_utf8(bytes).map_err(|e| Error::Utf8(e.utf8_error()))\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::NamespaceEntry": [
            "/// An entry that contains index into the buffer with namespace bindings.\n///\n/// Defines a mapping from *[namespace prefix]* to *[namespace name]*.\n/// If prefix is empty, defines a *default namespace* binding that applies to\n/// unprefixed element names (unprefixed attribute names do not bind to any\n/// namespace and they processing is dependent on the element in which their\n/// defined).\n///\n/// [namespace prefix]: https://www.w3.org/TR/xml-names11/#dt-prefix\n/// [namespace name]: https://www.w3.org/TR/xml-names11/#dt-NSName\nstruct NamespaceEntry {\n    /// Index of the namespace in the buffer\n    start: usize,\n    /// Length of the prefix\n    /// * if greater than zero, then binds this namespace to the slice\n    ///   `[start..start + prefix_len]` in the buffer.\n    /// * else defines the current default namespace.\n    prefix_len: usize,\n    /// The length of a namespace name (the URI) of this namespace declaration.\n    /// Name started just after prefix and extend for `value_len` bytes.\n    ///\n    /// The XML standard [specifies] that an empty namespace value 'removes' a namespace declaration\n    /// for the extent of its scope. For prefix declarations that's not very interesting, but it is\n    /// vital for default namespace declarations. With `xmlns=\"\"` you can revert back to the default\n    /// behaviour of leaving unqualified element names unqualified.\n    ///\n    /// [specifies]: https://www.w3.org/TR/xml-names11/#scoping\n    value_len: usize,\n    /// Level of nesting at which this namespace was declared. The declaring element is included,\n    /// i.e., a declaration on the document root has `level = 1`.\n    /// This is used to pop the namespace when the element gets closed.\n    level: i32,\n}",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::NamespaceEntry::is_match": [
            "/// Check if the namespace matches the potentially qualified name\n#[inline]\nfn is_match(&self, buffer: &[u8], qname: &[u8]) -> bool{\n        if self.prefix_len == 0 {\n            !qname.contains(&b':')\n        } else {\n            qname.get(self.prefix_len).map_or(false, |n| *n == b':')\n                && qname.starts_with(&buffer[self.start..self.start + self.prefix_len])\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::NamespaceEntry::namespace": [
            "/// Gets the namespace name (the URI) slice out of namespace buffer\n///\n/// Returns `None` if namespace for this prefix was explicitly removed from\n/// scope, using `xmlns[:prefix]=\"\"`\n#[inline]\nfn namespace<'b>(&self, buffer: &'b [u8]) -> Option<&'b [u8]>{\n        if self.value_len == 0 {\n            None\n        } else {\n            let start = self.start + self.prefix_len;\n            Some(&buffer[start..start + self.value_len])\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::NamespaceResolver": [
            "/// A namespace management buffer.\n///\n/// Holds all internal logic to push/pop namespaces with their levels.\nstruct NamespaceResolver {\n    /// A stack of namespace bindings to prefixes that currently in scope\n    bindings: Vec<NamespaceEntry>,\n    /// The number of open tags at the moment. We need to keep track of this to know which namespace\n    /// declarations to remove when we encounter an `End` event.\n    nesting_level: i32,\n    /// For `Empty` events keep the 'scope' of the element on the stack artificially. That way, the\n    /// consumer has a chance to use `resolve` in the context of the empty element. We perform the\n    /// pop as the first operation in the next `next()` call.\n    pending_pop: bool,\n}",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::NamespaceResolver::find": [
            "/// Finds a [namespace name] for a given qualified name of element, borrow it\n/// from the specified buffer.\n///\n/// Returns `None`, if:\n/// - name is unqualified\n/// - prefix not found in the current scope\n/// - prefix was [unbound] using `xmlns:prefix=\"\"`\n///\n/// # Lifetimes\n///\n/// - `'n`: lifetime of an element name\n/// - `'b`: lifetime of a namespaces buffer, where all found namespaces are stored\n///\n/// [namespace name]: https://www.w3.org/TR/xml-names11/#dt-NSName\n/// [unbound]: https://www.w3.org/TR/xml-names11/#scoping\n#[inline]\nfn find<'n, 'b>(&self, element_name: &'n [u8], buffer: &'b [u8]) -> Option<&'b [u8]>{\n        self.bindings\n            .iter()\n            .rfind(|n| n.is_match(buffer, element_name))\n            .and_then(|n| n.namespace(buffer))\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::NamespaceResolver::pop": [
            "/// Ends a top-most scope by popping all [namespace binding], that was added by\n/// last call to [`Self::push()`].\n///\n/// [namespace binding]: https://www.w3.org/TR/xml-names11/#dt-NSDecl\nfn pop(&mut self, buffer: &mut Vec<u8>){\n        if !self.pending_pop {\n            return;\n        }\n        self.pending_pop = false;\n        self.nesting_level -= 1;\n        let current_level = self.nesting_level;\n        // from the back (most deeply nested scope), look for the first scope that is still valid\n        match self.bindings.iter().rposition(|n| n.level <= current_level) {\n            // none of the namespaces are valid, remove all of them\n            None => {\n                buffer.clear();\n                self.bindings.clear();\n            }\n            // drop all namespaces past the last valid namespace\n            Some(last_valid_pos) => {\n                if let Some(len) = self.bindings.get(last_valid_pos + 1).map(|n| n.start) {\n                    buffer.truncate(len);\n                    self.bindings.truncate(last_valid_pos + 1);\n                }\n            }\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::NamespaceResolver::push": [
            "/// Begins a new scope and add to it all [namespace bindings] that found in\n/// the specified start element.\n///\n/// [namespace binding]: https://www.w3.org/TR/xml-names11/#dt-NSDecl\nfn push(&mut self, start: &BytesStart, buffer: &mut Vec<u8>){\n        self.nesting_level += 1;\n        let level = self.nesting_level;\n        // adds new namespaces for attributes starting with 'xmlns:' and for the 'xmlns'\n        // (default namespace) attribute.\n        for a in start.attributes().with_checks(false) {\n            if let Ok(Attribute { key: k, value: v }) = a {\n                if k.starts_with(b\"xmlns\") {\n                    match k.get(5) {\n                        None => {\n                            let start = buffer.len();\n                            buffer.extend_from_slice(&*v);\n                            self.bindings.push(NamespaceEntry {\n                                start,\n                                prefix_len: 0,\n                                value_len: v.len(),\n                                level,\n                            });\n                        }\n                        Some(&b':') => {\n                            let start = buffer.len();\n                            buffer.extend_from_slice(&k[6..]);\n                            buffer.extend_from_slice(&*v);\n                            self.bindings.push(NamespaceEntry {\n                                start,\n                                prefix_len: k.len() - 6,\n                                value_len: v.len(),\n                                level,\n                            });\n                        }\n                        _ => break,\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::NamespaceResolver::resolve": [
            "/// Resolves a potentially qualified **attribute name** into (namespace name, local name).\n///\n/// *Qualified* attribute names have the form `prefix:local-name` where the `prefix` is defined\n/// on any containing XML element via `xmlns:prefix=\"the:namespace:uri\"`. The namespace prefix\n/// can be defined on the same element as the attribute in question.\n///\n/// *Unqualified* attribute names do *not* inherit the current *default namespace*.\n///\n/// # Lifetimes\n///\n/// - `'n`: lifetime of an attribute or an element name\n/// - `'b`: lifetime of a namespaces buffer, where all found namespaces are stored\n#[inline]\nfn resolve<'n, 'b>(\n        &self,\n        qname: &'n [u8],\n        buffer: &'b [u8],\n        use_default: bool,\n    ) -> (Option<&'b [u8]>, &'n [u8]){\n        self.bindings\n            .iter()\n            .rfind(|n| n.is_match(buffer, qname))\n            .map_or((None, qname), |n| {\n                let len = n.prefix_len;\n                if len > 0 {\n                    (n.namespace(buffer), &qname[len + 1..])\n                } else if use_default {\n                    (n.namespace(buffer), qname)\n                } else {\n                    (None, qname)\n                }\n            })\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::ReadElementState": [
            "/// State machine for the [`XmlSource::read_element`]\nenum ReadElementState {\n    /// The initial state (inside element, but outside of attribute value)\n    Elem,\n    /// Inside a single-quoted attribute value\n    SingleQ,\n    /// Inside a double-quoted attribute value\n    DoubleQ,\n}",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::ReadElementState::change": [
            "/// Changes state by analyzing part of input.\n/// Returns a tuple with part of chunk up to element closing symbol `>`\n/// and a position after that symbol or `None` if such symbol was not found\n#[inline(always)]\nfn change<'b>(&mut self, chunk: &'b [u8]) -> Option<(&'b [u8], usize)>{\n        for i in memchr::memchr3_iter(b'>', b'\\'', b'\"', chunk) {\n            *self = match (*self, chunk[i]) {\n                // only allowed to match `>` while we are in state `Elem`\n                (Self::Elem, b'>') => return Some((&chunk[..i], i + 1)),\n                (Self::Elem, b'\\'') => Self::SingleQ,\n                (Self::Elem, b'\\\"') => Self::DoubleQ,\n\n                // the only end_byte that gets us out if the same character\n                (Self::SingleQ, b'\\'') | (Self::DoubleQ, b'\"') => Self::Elem,\n\n                // all other bytes: no state change\n                _ => *self,\n            };\n        }\n        None\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader": [
            "/// A low level encoding-agnostic XML event reader.\n///\n/// Consumes a `BufRead` and streams XML `Event`s.\n///\n/// # Examples\n///\n/// ```\n/// use quick_xml::Reader;\n/// use quick_xml::events::Event;\n///\n/// let xml = r#\"<tag1 att1 = \"test\">\n///                 <tag2><!--Test comment-->Test</tag2>\n///                 <tag2>Test 2</tag2>\n///             </tag1>\"#;\n/// let mut reader = Reader::from_str(xml);\n/// reader.trim_text(true);\n/// let mut count = 0;\n/// let mut txt = Vec::new();\n/// let mut buf = Vec::new();\n/// loop {\n///     match reader.read_event(&mut buf) {\n///         Ok(Event::Start(ref e)) => {\n///             match e.name() {\n///                 b\"tag1\" => println!(\"attributes values: {:?}\",\n///                                     e.attributes().map(|a| a.unwrap().value)\n///                                     .collect::<Vec<_>>()),\n///                 b\"tag2\" => count += 1,\n///                 _ => (),\n///             }\n///         },\n///         Ok(Event::Text(e)) => txt.push(e.unescape_and_decode(&reader).unwrap()),\n///         Err(e) => panic!(\"Error at position {}: {:?}\", reader.buffer_position(), e),\n///         Ok(Event::Eof) => break,\n///         _ => (),\n///     }\n///     buf.clear();\n/// }\n/// ```\npub struct Reader<R: BufRead> {\n    /// reader\n    pub(crate) reader: R,\n    /// current buffer position, useful for debugging errors\n    buf_position: usize,\n    /// current state Open/Close\n    tag_state: TagState,\n    /// expand empty element into an opening and closing element\n    expand_empty_elements: bool,\n    /// trims leading whitespace in Text events, skip the element if text is empty\n    trim_text_start: bool,\n    /// trims trailing whitespace in Text events.\n    trim_text_end: bool,\n    /// trims trailing whitespaces from markup names in closing tags `</a >`\n    trim_markup_names_in_closing_tags: bool,\n    /// check if End nodes match last Start node\n    check_end_names: bool,\n    /// check if comments contains `--` (false per default)\n    check_comments: bool,\n    /// All currently Started elements which didn't have a matching\n    /// End element yet.\n    ///\n    /// For an XML\n    ///\n    /// ```xml\n    /// <root><one/><inner attr=\"value\">|<tag></inner></root>\n    /// ```\n    /// when cursor at the `|` position buffer contains:\n    ///\n    /// ```text\n    /// rootinner\n    /// ^   ^\n    /// ```\n    ///\n    /// The `^` symbols shows which positions stored in the [`Self::opened_starts`]\n    /// (0 and 4 in that case).\n    opened_buffer: Vec<u8>,\n    /// Opened name start indexes into [`Self::opened_buffer`]. See documentation\n    /// for that field for details\n    opened_starts: Vec<usize>,\n    /// a buffer to manage namespaces\n    ns_resolver: NamespaceResolver,\n    #[cfg(feature = \"encoding\")]\n    /// the encoding specified in the xml, defaults to utf8\n    encoding: &'static Encoding,\n    #[cfg(feature = \"encoding\")]\n    /// check if quick-rs could find out the encoding\n    is_encoding_set: bool,\n}",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<&'a [u8]>::from_bytes": [
            "/// Creates an XML reader from a slice of bytes.\npub fn from_bytes(s: &'a [u8]) -> Reader<&'a [u8]>{\n        Reader::from_reader(s)\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<&'a [u8]>::from_str": [
            "/// Creates an XML reader from a string slice.\npub fn from_str(s: &'a str) -> Reader<&'a [u8]>{\n        Reader::from_reader(s.as_bytes())\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<&'a [u8]>::read_event_unbuffered": [
            "/// Read an event that borrows from the input rather than a buffer.\n#[inline]\npub fn read_event_unbuffered(&mut self) -> Result<Event<'a>>{\n        self.read_event_buffered(())\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<&'a [u8]>::read_to_end_unbuffered": [
            "/// Reads until end element is found\n///\n/// Manages nested cases where parent and child elements have the same name\npub fn read_to_end_unbuffered<K: AsRef<[u8]>>(&mut self, end: K) -> Result<()>{\n        let mut depth = 0;\n        let end = end.as_ref();\n        loop {\n            match self.read_event_unbuffered() {\n                Ok(Event::End(ref e)) if e.name() == end => {\n                    if depth == 0 {\n                        return Ok(());\n                    }\n                    depth -= 1;\n                }\n                Ok(Event::Start(ref e)) if e.name() == end => depth += 1,\n                Err(e) => return Err(e),\n                Ok(Event::Eof) => {\n                    return Err(Error::UnexpectedEof(format!(\"</{:?}>\", from_utf8(end))));\n                }\n                _ => (),\n            }\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::attribute_namespace": [
            "/// Resolves a potentially qualified **attribute name** into (namespace name, local name).\n///\n/// *Qualified* attribute names have the form `prefix:local-name` where the`prefix` is defined\n/// on any containing XML element via `xmlns:prefix=\"the:namespace:uri\"`. The namespace prefix\n/// can be defined on the same element as the attribute in question.\n///\n/// *Unqualified* attribute names do *not* inherit the current *default namespace*.\n#[inline]\npub fn attribute_namespace<'a, 'b, 'c>(\n        &'a self,\n        qname: &'b [u8],\n        namespace_buffer: &'c [u8],\n    ) -> (Option<&'c [u8]>, &'b [u8]){\n        self.ns_resolver.resolve(qname, namespace_buffer, false)\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::buffer_position": [
            "/// Gets the current byte position in the input data.\n///\n/// Useful when debugging errors.\npub fn buffer_position(&self) -> usize{\n        // when internal state is Opened, we have actually read until '<',\n        // which we don't want to show\n        if let TagState::Opened = self.tag_state {\n            self.buf_position - 1\n        } else {\n            self.buf_position\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::check_comments": [
            "/// Changes whether comments should be validated.\n///\n/// When set to `true`, every [`Comment`] event will be checked for not containing `--`, which\n/// is not allowed in XML comments. Most of the time we don't want comments at all so we don't\n/// really care about comment correctness, thus the default value is `false` to improve\n/// performance.\n///\n/// (`false` by default)\n///\n/// [`Comment`]: events/enum.Event.html#variant.Comment\npub fn check_comments(&mut self, val: bool) -> &mut Reader<R>{\n        self.check_comments = val;\n        self\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::check_end_names": [
            "/// Changes whether mismatched closing tag names should be detected.\n///\n/// When set to `false`, it won't check if a closing tag matches the corresponding opening tag.\n/// For example, `<mytag></different_tag>` will be permitted.\n///\n/// If the XML is known to be sane (already processed, etc.) this saves extra time.\n///\n/// Note that the emitted [`End`] event will not be modified if this is disabled, ie. it will\n/// contain the data of the mismatched end tag.\n///\n/// Note, that setting this to `true` will lead to additional allocates that\n/// needed to store tag name for an [`End`] event. There is no additional\n/// allocation, however, if [`Self::expand_empty_elements()`] is also set.\n///\n/// (`true` by default)\n///\n/// [`End`]: events/enum.Event.html#variant.End\npub fn check_end_names(&mut self, val: bool) -> &mut Reader<R>{\n        self.check_end_names = val;\n        self\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::close_expanded_empty": [
            "#[inline]\nfn close_expanded_empty(&mut self) -> Result<Event<'static>>{\n        self.tag_state = TagState::Closed;\n        let name = self\n            .opened_buffer\n            .split_off(self.opened_starts.pop().unwrap());\n        Ok(Event::End(BytesEnd::owned(name)))\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::decode": [
            "/// Decodes a UTF8 slice regardless of XML declaration.\n///\n/// Decode `bytes` with BOM sniffing and with malformed sequences replaced with the\n/// `U+FFFD REPLACEMENT CHARACTER`.\n///\n/// # Note\n///\n/// If you instead want to use XML declared encoding, use the `encoding` feature\n#[inline]\n#[cfg(not(feature = \"encoding\"))]\npub fn decode<'c>(&self, bytes: &'c [u8]) -> Result<&'c str>{\n        from_utf8(bytes).map_err(Error::Utf8)\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::decode_without_bom": [
            "/// Decodes a UTF8 slice without BOM (Byte order mark) regardless of XML declaration.\n///\n/// Decode `bytes` without BOM and with malformed sequences replaced with the\n/// `U+FFFD REPLACEMENT CHARACTER`.\n///\n/// # Note\n///\n/// If you instead want to use XML declared encoding, use the `encoding` feature\n#[inline]\n#[cfg(not(feature = \"encoding\"))]\npub fn decode_without_bom<'c>(&self, bytes: &'c [u8]) -> Result<&'c str>{\n        if bytes.starts_with(b\"\\xEF\\xBB\\xBF\") {\n            from_utf8(&bytes[3..]).map_err(Error::Utf8)\n        } else {\n            from_utf8(bytes).map_err(Error::Utf8)\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::decoder": [
            "/// Get utf8 decoder\n#[cfg(not(feature = \"encoding\"))]\npub fn decoder(&self) -> Decoder{\n        Decoder\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::event_namespace": [
            "/// Resolves a potentially qualified **event name** into (namespace name, local name).\n///\n/// *Qualified* attribute names have the form `prefix:local-name` where the`prefix` is defined\n/// on any containing XML element via `xmlns:prefix=\"the:namespace:uri\"`. The namespace prefix\n/// can be defined on the same element as the attribute in question.\n///\n/// *Unqualified* event inherits the current *default namespace*.\n#[inline]\npub fn event_namespace<'a, 'b, 'c>(\n        &'a self,\n        qname: &'b [u8],\n        namespace_buffer: &'c [u8],\n    ) -> (Option<&'c [u8]>, &'b [u8]){\n        self.ns_resolver.resolve(qname, namespace_buffer, true)\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::expand_empty_elements": [
            "/// Changes whether empty elements should be split into an `Open` and a `Close` event.\n///\n/// When set to `true`, all [`Empty`] events produced by a self-closing tag like `<tag/>` are\n/// expanded into a [`Start`] event followed by an [`End`] event. When set to `false` (the\n/// default), those tags are represented by an [`Empty`] event instead.\n///\n/// Note, that setting this to `true` will lead to additional allocates that\n/// needed to store tag name for an [`End`] event. There is no additional\n/// allocation, however, if [`Self::check_end_names()`] is also set.\n///\n/// (`false` by default)\n///\n/// [`Empty`]: events/enum.Event.html#variant.Empty\n/// [`Start`]: events/enum.Event.html#variant.Start\n/// [`End`]: events/enum.Event.html#variant.End\npub fn expand_empty_elements(&mut self, val: bool) -> &mut Reader<R>{\n        self.expand_empty_elements = val;\n        self\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::from_reader": [
            "/// Creates a `Reader` that reads from a reader implementing `BufRead`.\npub fn from_reader(reader: R) -> Reader<R>{\n        Reader {\n            reader,\n            opened_buffer: Vec::new(),\n            opened_starts: Vec::new(),\n            tag_state: TagState::Closed,\n            expand_empty_elements: false,\n            trim_text_start: false,\n            trim_text_end: false,\n            trim_markup_names_in_closing_tags: true,\n            check_end_names: true,\n            buf_position: 0,\n            check_comments: false,\n            ns_resolver: NamespaceResolver::default(),\n            #[cfg(feature = \"encoding\")]\n            encoding: ::encoding_rs::UTF_8,\n            #[cfg(feature = \"encoding\")]\n            is_encoding_set: false,\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::get_mut": [
            "/// Gets a mutable reference to the underlying reader.\npub fn get_mut(&mut self) -> &mut R{\n        &mut self.reader\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::get_ref": [
            "/// Gets a reference to the underlying reader.\npub fn get_ref(&self) -> &R{\n        &self.reader\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::into_inner": [
            "/// Consumes `Reader` returning the underlying reader\n///\n/// Can be used to compute line and column of a parsing error position\n///\n/// # Examples\n///\n/// ```\n/// # use pretty_assertions::assert_eq;\n/// use std::{str, io::Cursor};\n/// use quick_xml::Reader;\n/// use quick_xml::events::Event;\n///\n/// let xml = r#\"<tag1 att1 = \"test\">\n///                 <tag2><!--Test comment-->Test</tag2>\n///                 <tag3>Test 2</tag3>\n///             </tag1>\"#;\n/// let mut reader = Reader::from_reader(Cursor::new(xml.as_bytes()));\n/// let mut buf = Vec::new();\n///\n/// fn into_line_and_column(reader: Reader<Cursor<&[u8]>>) -> (usize, usize) {\n///     let end_pos = reader.buffer_position();\n///     let mut cursor = reader.into_inner();\n///     let s = String::from_utf8(cursor.into_inner()[0..end_pos].to_owned())\n///         .expect(\"can't make a string\");\n///     let mut line = 1;\n///     let mut column = 0;\n///     for c in s.chars() {\n///         if c == '\\n' {\n///             line += 1;\n///             column = 0;\n///         } else {\n///             column += 1;\n///         }\n///     }\n///     (line, column)\n/// }\n///\n/// loop {\n///     match reader.read_event(&mut buf) {\n///         Ok(Event::Start(ref e)) => match e.name() {\n///             b\"tag1\" | b\"tag2\" => (),\n///             tag => {\n///                 assert_eq!(b\"tag3\", tag);\n///                 assert_eq!((3, 22), into_line_and_column(reader));\n///                 break;\n///             }\n///         },\n///         Ok(Event::Eof) => unreachable!(),\n///         _ => (),\n///     }\n///     buf.clear();\n/// }\n/// ```\npub fn into_inner(self) -> R{\n        self.reader\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::read_bang": [
            "/// reads `BytesElement` starting with a `!`,\n/// return `Comment`, `CData` or `DocType` event\nfn read_bang<'a, 'b>(&'a mut self, bang_type: BangType, buf: &'b [u8]) -> Result<Event<'b>>{\n        let uncased_starts_with = |string: &[u8], prefix: &[u8]| {\n            string.len() >= prefix.len() && string[..prefix.len()].eq_ignore_ascii_case(prefix)\n        };\n\n        let len = buf.len();\n        match bang_type {\n            BangType::Comment if buf.starts_with(b\"!--\") => {\n                if self.check_comments {\n                    // search if '--' not in comments\n                    if let Some(p) = memchr::memchr_iter(b'-', &buf[3..len - 2])\n                        .position(|p| buf[3 + p + 1] == b'-')\n                    {\n                        self.buf_position += len - p;\n                        return Err(Error::UnexpectedToken(\"--\".to_string()));\n                    }\n                }\n                Ok(Event::Comment(BytesText::from_escaped(&buf[3..len - 2])))\n            }\n            BangType::CData if uncased_starts_with(buf, b\"![CDATA[\") => {\n                Ok(Event::CData(BytesCData::new(&buf[8..])))\n            }\n            BangType::DocType if uncased_starts_with(buf, b\"!DOCTYPE\") => {\n                let start = buf[8..]\n                    .iter()\n                    .position(|b| !is_whitespace(*b))\n                    .unwrap_or_else(|| len - 8);\n                debug_assert!(start < len - 8, \"DocType must have a name\");\n                Ok(Event::DocType(BytesText::from_escaped(&buf[8 + start..])))\n            }\n            _ => Err(bang_type.to_err()),\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::read_end": [
            "/// reads `BytesElement` starting with a `/`,\n/// if `self.check_end_names`, checks that element matches last opened element\n/// return `End` event\nfn read_end<'a, 'b>(&'a mut self, buf: &'b [u8]) -> Result<Event<'b>>{\n        // XML standard permits whitespaces after the markup name in closing tags.\n        // Let's strip them from the buffer before comparing tag names.\n        let name = if self.trim_markup_names_in_closing_tags {\n            if let Some(pos_end_name) = buf[1..].iter().rposition(|&b| !b.is_ascii_whitespace()) {\n                let (name, _) = buf[1..].split_at(pos_end_name + 1);\n                name\n            } else {\n                &buf[1..]\n            }\n        } else {\n            &buf[1..]\n        };\n        if self.check_end_names {\n            let mismatch_err = |expected: &[u8], found: &[u8], buf_position: &mut usize| {\n                *buf_position -= buf.len();\n                Err(Error::EndEventMismatch {\n                    expected: from_utf8(expected).unwrap_or(\"\").to_owned(),\n                    found: from_utf8(found).unwrap_or(\"\").to_owned(),\n                })\n            };\n            match self.opened_starts.pop() {\n                Some(start) => {\n                    let expected = &self.opened_buffer[start..];\n                    if name != expected {\n                        mismatch_err(expected, name, &mut self.buf_position)\n                    } else {\n                        self.opened_buffer.truncate(start);\n                        Ok(Event::End(BytesEnd::borrowed(name)))\n                    }\n                }\n                None => mismatch_err(b\"\", &buf[1..], &mut self.buf_position),\n            }\n        } else {\n            Ok(Event::End(BytesEnd::borrowed(name)))\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::read_event": [
            "/// Reads the next `Event`.\n///\n/// This is the main entry point for reading XML `Event`s.\n///\n/// `Event`s borrow `buf` and can be converted to own their data if needed (uses `Cow`\n/// internally).\n///\n/// Having the possibility to control the internal buffers gives you some additional benefits\n/// such as:\n///\n/// - Reduce the number of allocations by reusing the same buffer. For constrained systems,\n///   you can call `buf.clear()` once you are done with processing the event (typically at the\n///   end of your loop).\n/// - Reserve the buffer length if you know the file size (using `Vec::with_capacity`).\n///\n/// # Examples\n///\n/// ```\n/// use quick_xml::Reader;\n/// use quick_xml::events::Event;\n///\n/// let xml = r#\"<tag1 att1 = \"test\">\n///                 <tag2><!--Test comment-->Test</tag2>\n///                 <tag2>Test 2</tag2>\n///             </tag1>\"#;\n/// let mut reader = Reader::from_str(xml);\n/// reader.trim_text(true);\n/// let mut count = 0;\n/// let mut buf = Vec::new();\n/// let mut txt = Vec::new();\n/// loop {\n///     match reader.read_event(&mut buf) {\n///         Ok(Event::Start(ref e)) => count += 1,\n///         Ok(Event::Text(e)) => txt.push(e.unescape_and_decode(&reader).expect(\"Error!\")),\n///         Err(e) => panic!(\"Error at position {}: {:?}\", reader.buffer_position(), e),\n///         Ok(Event::Eof) => break,\n///         _ => (),\n///     }\n///     buf.clear();\n/// }\n/// println!(\"Found {} start events\", count);\n/// println!(\"Text events: {:?}\", txt);\n/// ```\n#[inline]\npub fn read_event<'a, 'b>(&'a mut self, buf: &'b mut Vec<u8>) -> Result<Event<'b>>{\n        self.read_event_buffered(buf)\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::read_event_buffered": [
            "/// Read text into the given buffer, and return an event that borrows from\n/// either that buffer or from the input itself, based on the type of the\n/// reader.\nfn read_event_buffered<'i, B>(&mut self, buf: B) -> Result<Event<'i>>\n    where\n        R: XmlSource<'i, B>,{\n        let event = match self.tag_state {\n            TagState::Opened => self.read_until_close(buf),\n            TagState::Closed => self.read_until_open(buf),\n            TagState::Empty => self.close_expanded_empty(),\n            TagState::Exit => return Ok(Event::Eof),\n        };\n        match event {\n            Err(_) | Ok(Event::Eof) => self.tag_state = TagState::Exit,\n            _ => {}\n        }\n        event\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::read_namespaced_event": [
            "/// Reads the next event and resolves its namespace (if applicable).\n///\n/// # Examples\n///\n/// ```\n/// use std::str::from_utf8;\n/// use quick_xml::Reader;\n/// use quick_xml::events::Event;\n///\n/// let xml = r#\"<x:tag1 xmlns:x=\"www.xxxx\" xmlns:y=\"www.yyyy\" att1 = \"test\">\n///                 <y:tag2><!--Test comment-->Test</y:tag2>\n///                 <y:tag2>Test 2</y:tag2>\n///             </x:tag1>\"#;\n/// let mut reader = Reader::from_str(xml);\n/// reader.trim_text(true);\n/// let mut count = 0;\n/// let mut buf = Vec::new();\n/// let mut ns_buf = Vec::new();\n/// let mut txt = Vec::new();\n/// loop {\n///     match reader.read_namespaced_event(&mut buf, &mut ns_buf) {\n///         Ok((ref ns, Event::Start(ref e))) => {\n///             count += 1;\n///             match (*ns, e.local_name()) {\n///                 (Some(b\"www.xxxx\"), b\"tag1\") => (),\n///                 (Some(b\"www.yyyy\"), b\"tag2\") => (),\n///                 (ns, n) => panic!(\"Namespace and local name mismatch\"),\n///             }\n///             println!(\"Resolved namespace: {:?}\", ns.and_then(|ns| from_utf8(ns).ok()));\n///         }\n///         Ok((_, Event::Text(e))) => {\n///             txt.push(e.unescape_and_decode(&reader).expect(\"Error!\"))\n///         },\n///         Err(e) => panic!(\"Error at position {}: {:?}\", reader.buffer_position(), e),\n///         Ok((_, Event::Eof)) => break,\n///         _ => (),\n///     }\n///     buf.clear();\n/// }\n/// println!(\"Found {} start events\", count);\n/// println!(\"Text events: {:?}\", txt);\n/// ```\npub fn read_namespaced_event<'a, 'b, 'c>(\n        &'a mut self,\n        buf: &'b mut Vec<u8>,\n        namespace_buffer: &'c mut Vec<u8>,\n    ) -> Result<(Option<&'c [u8]>, Event<'b>)>{\n        self.ns_resolver.pop(namespace_buffer);\n        match self.read_event(buf) {\n            Ok(Event::Eof) => Ok((None, Event::Eof)),\n            Ok(Event::Start(e)) => {\n                self.ns_resolver.push(&e, namespace_buffer);\n                Ok((\n                    self.ns_resolver.find(e.name(), &**namespace_buffer),\n                    Event::Start(e),\n                ))\n            }\n            Ok(Event::Empty(e)) => {\n                // For empty elements we need to 'artificially' keep the namespace scope on the\n                // stack until the next `next()` call occurs.\n                // Otherwise the caller has no chance to use `resolve` in the context of the\n                // namespace declarations that are 'in scope' for the empty element alone.\n                // Ex: <img rdf:nodeID=\"abc\" xmlns:rdf=\"urn:the-rdf-uri\" />\n                self.ns_resolver.push(&e, namespace_buffer);\n                // notify next `read_namespaced_event()` invocation that it needs to pop this\n                // namespace scope\n                self.ns_resolver.pending_pop = true;\n                Ok((\n                    self.ns_resolver.find(e.name(), &**namespace_buffer),\n                    Event::Empty(e),\n                ))\n            }\n            Ok(Event::End(e)) => {\n                // notify next `read_namespaced_event()` invocation that it needs to pop this\n                // namespace scope\n                self.ns_resolver.pending_pop = true;\n                Ok((\n                    self.ns_resolver.find(e.name(), &**namespace_buffer),\n                    Event::End(e),\n                ))\n            }\n            Ok(e) => Ok((None, e)),\n            Err(e) => Err(e),\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::read_question_mark": [
            "/// reads `BytesElement` starting with a `?`,\n/// return `Decl` or `PI` event\nfn read_question_mark<'a, 'b>(&'a mut self, buf: &'b [u8]) -> Result<Event<'b>>{\n        let len = buf.len();\n        if len > 2 && buf[len - 1] == b'?' {\n            if len > 5 && &buf[1..4] == b\"xml\" && is_whitespace(buf[4]) {\n                let event = BytesDecl::from_start(BytesStart::borrowed(&buf[1..len - 1], 3));\n\n                // Try getting encoding from the declaration event\n                #[cfg(feature = \"encoding\")]\n                if let Some(enc) = event.encoder() {\n                    self.encoding = enc;\n                    self.is_encoding_set = true;\n                }\n\n                Ok(Event::Decl(event))\n            } else {\n                Ok(Event::PI(BytesText::from_escaped(&buf[1..len - 1])))\n            }\n        } else {\n            self.buf_position -= len;\n            Err(Error::UnexpectedEof(\"XmlDecl\".to_string()))\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::read_start": [
            "/// reads `BytesElement` starting with any character except `/`, `!` or ``?`\n/// return `Start` or `Empty` event\nfn read_start<'a, 'b>(&'a mut self, buf: &'b [u8]) -> Result<Event<'b>>{\n        // TODO: do this directly when reading bufreader ...\n        let len = buf.len();\n        let name_end = buf.iter().position(|&b| is_whitespace(b)).unwrap_or(len);\n        if let Some(&b'/') = buf.last() {\n            let end = if name_end < len { name_end } else { len - 1 };\n            if self.expand_empty_elements {\n                self.tag_state = TagState::Empty;\n                self.opened_starts.push(self.opened_buffer.len());\n                self.opened_buffer.extend(&buf[..end]);\n                Ok(Event::Start(BytesStart::borrowed(&buf[..len - 1], end)))\n            } else {\n                Ok(Event::Empty(BytesStart::borrowed(&buf[..len - 1], end)))\n            }\n        } else {\n            if self.check_end_names {\n                self.opened_starts.push(self.opened_buffer.len());\n                self.opened_buffer.extend(&buf[..name_end]);\n            }\n            Ok(Event::Start(BytesStart::borrowed(buf, name_end)))\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::read_text": [
            "/// Reads optional text between start and end tags.\n///\n/// If the next event is a [`Text`] event, returns the decoded and unescaped content as a\n/// `String`. If the next event is an [`End`] event, returns the empty string. In all other\n/// cases, returns an error.\n///\n/// Any text will be decoded using the XML encoding specified in the XML declaration (or UTF-8\n/// if none is specified).\n///\n/// # Examples\n///\n/// ```\n/// # use pretty_assertions::assert_eq;\n/// use quick_xml::Reader;\n/// use quick_xml::events::Event;\n///\n/// let mut xml = Reader::from_reader(b\"\n///     <a>&lt;b&gt;</a>\n///     <a></a>\n/// \" as &[u8]);\n/// xml.trim_text(true);\n///\n/// let expected = [\"<b>\", \"\"];\n/// for &content in expected.iter() {\n///     match xml.read_event(&mut Vec::new()) {\n///         Ok(Event::Start(ref e)) => {\n///             assert_eq!(&xml.read_text(e.name(), &mut Vec::new()).unwrap(), content);\n///         },\n///         e => panic!(\"Expecting Start event, found {:?}\", e),\n///     }\n/// }\n/// ```\n///\n/// [`Text`]: events/enum.Event.html#variant.Text\n/// [`End`]: events/enum.Event.html#variant.End\npub fn read_text<K: AsRef<[u8]>>(&mut self, end: K, buf: &mut Vec<u8>) -> Result<String>{\n        let s = match self.read_event(buf) {\n            Ok(Event::Text(e)) => e.unescape_and_decode(self),\n            Ok(Event::End(ref e)) if e.name() == end.as_ref() => return Ok(\"\".to_string()),\n            Err(e) => return Err(e),\n            Ok(Event::Eof) => return Err(Error::UnexpectedEof(\"Text\".to_string())),\n            _ => return Err(Error::TextNotFound),\n        };\n        self.read_to_end(end, buf)?;\n        s\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::read_to_end": [
            "/// Reads until end element is found\n///\n/// Manages nested cases where parent and child elements have the same name\npub fn read_to_end<K: AsRef<[u8]>>(&mut self, end: K, buf: &mut Vec<u8>) -> Result<()>{\n        let mut depth = 0;\n        let end = end.as_ref();\n        loop {\n            match self.read_event(buf) {\n                Ok(Event::End(ref e)) if e.name() == end => {\n                    if depth == 0 {\n                        return Ok(());\n                    }\n                    depth -= 1;\n                }\n                Ok(Event::Start(ref e)) if e.name() == end => depth += 1,\n                Err(e) => return Err(e),\n                Ok(Event::Eof) => {\n                    return Err(Error::UnexpectedEof(format!(\"</{:?}>\", from_utf8(end))));\n                }\n                _ => (),\n            }\n            buf.clear();\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::read_until_close": [
            "/// Private function to read until `>` is found. This function expects that\n/// it was called just after encounter a `<` symbol.\nfn read_until_close<'i, B>(&mut self, buf: B) -> Result<Event<'i>>\n    where\n        R: XmlSource<'i, B>,{\n        self.tag_state = TagState::Closed;\n\n        match self.reader.peek_one() {\n            // `<!` - comment, CDATA or DOCTYPE declaration\n            Ok(Some(b'!')) => match self.reader.read_bang_element(buf, &mut self.buf_position) {\n                Ok(None) => Ok(Event::Eof),\n                Ok(Some((bang_type, bytes))) => self.read_bang(bang_type, bytes),\n                Err(e) => Err(e),\n            },\n            // `</` - closing tag\n            Ok(Some(b'/')) => match self\n                .reader\n                .read_bytes_until(b'>', buf, &mut self.buf_position)\n            {\n                Ok(None) => Ok(Event::Eof),\n                Ok(Some(bytes)) => self.read_end(bytes),\n                Err(e) => Err(e),\n            },\n            // `<?` - processing instruction\n            Ok(Some(b'?')) => match self\n                .reader\n                .read_bytes_until(b'>', buf, &mut self.buf_position)\n            {\n                Ok(None) => Ok(Event::Eof),\n                Ok(Some(bytes)) => self.read_question_mark(bytes),\n                Err(e) => Err(e),\n            },\n            // `<...` - opening or self-closed tag\n            Ok(Some(_)) => match self.reader.read_element(buf, &mut self.buf_position) {\n                Ok(None) => Ok(Event::Eof),\n                Ok(Some(bytes)) => self.read_start(bytes),\n                Err(e) => Err(e),\n            },\n            Ok(None) => Ok(Event::Eof),\n            Err(e) => Err(e),\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::read_until_open": [
            "/// private function to read until '<' is found\n/// return a `Text` event\nfn read_until_open<'i, B>(&mut self, buf: B) -> Result<Event<'i>>\n    where\n        R: XmlSource<'i, B>,{\n        self.tag_state = TagState::Opened;\n\n        if self.trim_text_start {\n            self.reader.skip_whitespace(&mut self.buf_position)?;\n            if self.reader.skip_one(b'<', &mut self.buf_position)? {\n                return self.read_event_buffered(buf);\n            }\n        }\n\n        match self\n            .reader\n            .read_bytes_until(b'<', buf, &mut self.buf_position)\n        {\n            Ok(Some(bytes)) if self.trim_text_end => {\n                // Skip the ending '<\n                let len = bytes\n                    .iter()\n                    .rposition(|&b| !is_whitespace(b))\n                    .map_or_else(|| bytes.len(), |p| p + 1);\n                Ok(Event::Text(BytesText::from_escaped(&bytes[..len])))\n            }\n            Ok(Some(bytes)) => Ok(Event::Text(BytesText::from_escaped(bytes))),\n            Ok(None) => Ok(Event::Eof),\n            Err(e) => Err(e),\n        }\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::trim_markup_names_in_closing_tags": [
            "/// Changes whether trailing whitespaces after the markup name are trimmed in closing tags\n/// `</a >`.\n///\n/// If true the emitted [`End`] event is stripped of trailing whitespace after the markup name.\n///\n/// Note that if set to `false` and `check_end_names` is true the comparison of markup names is\n/// going to fail erronously if a closing tag contains trailing whitespaces.\n///\n/// (`true` by default)\n///\n/// [`End`]: events/enum.Event.html#variant.End\npub fn trim_markup_names_in_closing_tags(&mut self, val: bool) -> &mut Reader<R>{\n        self.trim_markup_names_in_closing_tags = val;\n        self\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::trim_text": [
            "/// Changes whether whitespace before and after character data should be removed.\n///\n/// When set to `true`, all [`Text`] events are trimmed. If they are empty, no event will be\n/// pushed.\n///\n/// (`false` by default)\n///\n/// [`Text`]: events/enum.Event.html#variant.Text\npub fn trim_text(&mut self, val: bool) -> &mut Reader<R>{\n        self.trim_text_start = val;\n        self.trim_text_end = val;\n        self\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<R>::trim_text_end": [
            "/// Changes whether whitespace after character data should be removed.\n///\n/// When set to `true`, trailing whitespace is trimmed in [`Text`] events.\n///\n/// (`false` by default)\n///\n/// [`Text`]: events/enum.Event.html#variant.Text\npub fn trim_text_end(&mut self, val: bool) -> &mut Reader<R>{\n        self.trim_text_end = val;\n        self\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::Reader::<std::io::BufReader<std::fs::File>>::from_file": [
            "/// Creates an XML reader from a file path.\npub fn from_file<P: AsRef<Path>>(path: P) -> Result<Reader<BufReader<File>>>{\n        let file = File::open(path).map_err(Error::Io)?;\n        let reader = BufReader::new(file);\n        Ok(Reader::from_reader(reader))\n    }",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::TagState": [
            "enum TagState {\n    Opened,\n    Closed,\n    Empty,\n    /// Either Eof or Errored\n    Exit,\n}",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::XmlSource": [
            "/// Represents an input for a reader that can return borrowed data.\n///\n/// There are two implementors of this trait: generic one that read data from\n/// `Self`, copies some part of it into a provided buffer of type `B` and then\n/// returns data that borrow from that buffer.\n///\n/// The other implementor is for `&[u8]` and instead of copying data returns\n/// borrowed data from `Self` instead. This implementation allows zero-copy\n/// deserialization.\n///\n/// # Parameters\n/// - `'r`: lifetime of a buffer from which events will borrow\n/// - `B`: a type of a buffer that can be used to store data read from `Self` and\n///   from which events can borrow\ntrait XmlSource<'r, B> {\n    /// Read input until `byte` is found or end of input is reached.\n    ///\n    /// Returns a slice of data read up to `byte`, which does not include into result.\n    /// If input (`Self`) is exhausted, returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let mut position = 0;\n    /// let mut input = b\"abc*def\".as_ref();\n    /// //                    ^= 4\n    ///\n    /// assert_eq!(\n    ///     input.read_bytes_until(b'*', (), &mut position).unwrap(),\n    ///     Some(b\"abc\".as_ref())\n    /// );\n    /// assert_eq!(position, 4); // position after the symbol matched\n    /// ```\n    ///\n    /// # Parameters\n    /// - `byte`: Byte for search\n    /// - `buf`: Buffer that could be filled from an input (`Self`) and\n    ///   from which [events] could borrow their data\n    /// - `position`: Will be increased by amount of bytes consumed\n    ///\n    /// [events]: crate::events::Event\n    fn read_bytes_until(\n        &mut self,\n        byte: u8,\n        buf: B,\n        position: &mut usize,\n    ) -> Result<Option<&'r [u8]>>;\n\n    /// Read input until comment, CDATA or processing instruction is finished.\n    ///\n    /// This method expect that `<` already was read.\n    ///\n    /// Returns a slice of data read up to end of comment, CDATA or processing\n    /// instruction (`>`), which does not include into result.\n    ///\n    /// If input (`Self`) is exhausted and nothing was read, returns `None`.\n    ///\n    /// # Parameters\n    /// - `buf`: Buffer that could be filled from an input (`Self`) and\n    ///   from which [events] could borrow their data\n    /// - `position`: Will be increased by amount of bytes consumed\n    ///\n    /// [events]: crate::events::Event\n    fn read_bang_element(\n        &mut self,\n        buf: B,\n        position: &mut usize,\n    ) -> Result<Option<(BangType, &'r [u8])>>;\n\n    /// Read input until XML element is closed by approaching a `>` symbol.\n    /// Returns `Some(buffer)` that contains a data between `<` and `>` or\n    /// `None` if end-of-input was reached and nothing was read.\n    ///\n    /// Derived from `read_until`, but modified to handle XML attributes\n    /// using a minimal state machine.\n    ///\n    /// Attribute values are [defined] as follows:\n    /// ```plain\n    /// AttValue := '\"' (([^<&\"]) | Reference)* '\"'\n    ///           | \"'\" (([^<&']) | Reference)* \"'\"\n    /// ```\n    /// (`Reference` is something like `&quot;`, but we don't care about\n    /// escaped characters at this level)\n    ///\n    /// # Parameters\n    /// - `buf`: Buffer that could be filled from an input (`Self`) and\n    ///   from which [events] could borrow their data\n    /// - `position`: Will be increased by amount of bytes consumed\n    ///\n    /// [defined]: https://www.w3.org/TR/xml11/#NT-AttValue\n    /// [events]: crate::events::Event\n    fn read_element(&mut self, buf: B, position: &mut usize) -> Result<Option<&'r [u8]>>;\n\n    fn skip_whitespace(&mut self, position: &mut usize) -> Result<()>;\n\n    fn skip_one(&mut self, byte: u8, position: &mut usize) -> Result<bool>;\n\n    fn peek_one(&mut self) -> Result<Option<u8>>;\n}",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "reader::is_whitespace": [
            "/// A function to check whether the byte is a whitespace (blank, new line, carriage return or tab)\n#[inline]\npub(crate) fn is_whitespace(b: u8) -> bool{\n    match b {\n        b' ' | b'\\r' | b'\\n' | b'\\t' => true,\n        _ => false,\n    }\n}",
            "Real(LocalPath(\"src/reader.rs\"))"
        ],
        "utils::ByteBuf": [
            "/// Wrapper around `Vec<u8>` that has a human-readable debug representation:\n/// printable ASCII symbols output as is, all other output in HEX notation.\n///\n/// Also, when `serialize` feature is on, this type deserialized using\n/// [`deserialize_byte_buf`](serde::Deserializer::deserialize_byte_buf) instead\n/// of vector's generic [`deserialize_seq`](serde::Deserializer::deserialize_seq)\npub struct ByteBuf(pub Vec<u8>);",
            "Real(LocalPath(\"src/utils.rs\"))"
        ],
        "utils::Bytes": [
            "/// Wrapper around `&[u8]` that has a human-readable debug representation:\n/// printable ASCII symbols output as is, all other output in HEX notation.\n///\n/// Also, when `serialize` feature is on, this type deserialized using\n/// [`deserialize_bytes`](serde::Deserializer::deserialize_bytes) instead\n/// of vector's generic [`deserialize_seq`](serde::Deserializer::deserialize_seq)\npub struct Bytes<'de>(pub &'de [u8]);",
            "Real(LocalPath(\"src/utils.rs\"))"
        ],
        "utils::write_byte_string": [
            "pub fn write_byte_string(f: &mut Formatter, byte_string: &[u8]) -> fmt::Result{\n    write!(f, \"\\\"\")?;\n    for b in byte_string {\n        match *b {\n            32..=33 | 35..=126 => write!(f, \"{}\", *b as char)?,\n            34 => write!(f, \"\\\\\\\"\")?,\n            _ => write!(f, \"{:#02X}\", b)?,\n        }\n    }\n    write!(f, \"\\\"\")?;\n    Ok(())\n}",
            "Real(LocalPath(\"src/utils.rs\"))"
        ],
        "utils::write_cow_string": [
            "pub fn write_cow_string(f: &mut Formatter, cow_string: &Cow<[u8]>) -> fmt::Result{\n    match cow_string {\n        Cow::Owned(s) => {\n            write!(f, \"Owned(\")?;\n            write_byte_string(f, &s)?;\n        }\n        Cow::Borrowed(s) => {\n            write!(f, \"Borrowed(\")?;\n            write_byte_string(f, s)?;\n        }\n    }\n    write!(f, \")\")\n}",
            "Real(LocalPath(\"src/utils.rs\"))"
        ],
        "writer::ElementWriter": [
            "/// A struct to write an element. Contains methods to add attributes and inner\n/// elements to the element\npub struct ElementWriter<'a, W: Write> {\n    writer: &'a mut Writer<W>,\n    start_tag: BytesStart<'a>,\n}",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::ElementWriter::<'a, W>::with_attribute": [
            "/// Adds an attribute to this element.\npub fn with_attribute<'b, I>(mut self, attr: I) -> Self\n    where\n        I: Into<Attribute<'b>>,{\n        self.start_tag.push_attribute(attr);\n        self\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::ElementWriter::<'a, W>::with_attributes": [
            "/// Add additional attributes to this element using an iterator.\n///\n/// The yielded items must be convertible to [`Attribute`] using `Into`.\npub fn with_attributes<'b, I>(mut self, attributes: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Into<Attribute<'b>>,{\n        self.start_tag.extend_attributes(attributes);\n        self\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::ElementWriter::<'a, W>::write_cdata_content": [
            "/// Write a CData event `<![CDATA[...]]>` inside the current element.\npub fn write_cdata_content(self, text: BytesCData) -> Result<&'a mut Writer<W>>{\n        self.writer\n            .write_event(Event::Start(self.start_tag.to_borrowed()))?;\n        self.writer.write_event(Event::CData(text))?;\n        self.writer\n            .write_event(Event::End(self.start_tag.to_end()))?;\n        Ok(self.writer)\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::ElementWriter::<'a, W>::write_empty": [
            "/// Write an empty (self-closing) tag.\npub fn write_empty(self) -> Result<&'a mut Writer<W>>{\n        self.writer.write_event(Event::Empty(self.start_tag))?;\n        Ok(self.writer)\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::ElementWriter::<'a, W>::write_inner_content": [
            "/// Create a new scope for writing XML inside the current element.\npub fn write_inner_content<F>(mut self, closure: F) -> Result<&'a mut Writer<W>>\n    where\n        F: Fn(&mut Writer<W>) -> Result<()>,{\n        self.writer\n            .write_event(Event::Start(self.start_tag.to_borrowed()))?;\n        closure(&mut self.writer)?;\n        self.writer\n            .write_event(Event::End(self.start_tag.to_end()))?;\n        Ok(self.writer)\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::ElementWriter::<'a, W>::write_pi_content": [
            "/// Write a processing instruction `<?...?>` inside the current element.\npub fn write_pi_content(self, text: BytesText) -> Result<&'a mut Writer<W>>{\n        self.writer\n            .write_event(Event::Start(self.start_tag.to_borrowed()))?;\n        self.writer.write_event(Event::PI(text))?;\n        self.writer\n            .write_event(Event::End(self.start_tag.to_end()))?;\n        Ok(self.writer)\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::ElementWriter::<'a, W>::write_text_content": [
            "/// Write some text inside the current element.\npub fn write_text_content(self, text: BytesText) -> Result<&'a mut Writer<W>>{\n        self.writer\n            .write_event(Event::Start(self.start_tag.to_borrowed()))?;\n        self.writer.write_event(Event::Text(text))?;\n        self.writer\n            .write_event(Event::End(self.start_tag.to_end()))?;\n        Ok(self.writer)\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Indentation": [
            "struct Indentation {\n    should_line_break: bool,\n    indent_char: u8,\n    indent_size: usize,\n    indents: Vec<u8>,\n    indents_len: usize,\n}",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Indentation::grow": [
            "fn grow(&mut self){\n        self.indents_len += self.indent_size;\n        if self.indents_len > self.indents.len() {\n            self.indents.resize(self.indents_len, self.indent_char);\n        }\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Indentation::new": [
            "fn new(indent_char: u8, indent_size: usize) -> Indentation{\n        Indentation {\n            should_line_break: false,\n            indent_char,\n            indent_size,\n            indents: vec![indent_char; 128],\n            indents_len: 0,\n        }\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Indentation::shrink": [
            "fn shrink(&mut self){\n        self.indents_len = match self.indents_len.checked_sub(self.indent_size) {\n            Some(result) => result,\n            None => 0,\n        };\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Writer": [
            "/// XML writer.\n///\n/// Writes XML `Event`s to a `Write` implementor.\n///\n/// # Examples\n///\n/// ```rust\n/// # use pretty_assertions::assert_eq;\n/// use quick_xml::{Reader, Writer};\n/// use quick_xml::events::{Event, BytesEnd, BytesStart};\n/// use std::io::Cursor;\n///\n/// let xml = r#\"<this_tag k1=\"v1\" k2=\"v2\"><child>text</child></this_tag>\"#;\n/// let mut reader = Reader::from_str(xml);\n/// reader.trim_text(true);\n/// let mut writer = Writer::new(Cursor::new(Vec::new()));\n/// let mut buf = Vec::new();\n/// loop {\n///     match reader.read_event(&mut buf) {\n///         Ok(Event::Start(ref e)) if e.name() == b\"this_tag\" => {\n///\n///             // crates a new element ... alternatively we could reuse `e` by calling\n///             // `e.into_owned()`\n///             let mut elem = BytesStart::owned(b\"my_elem\".to_vec(), \"my_elem\".len());\n///\n///             // collect existing attributes\n///             elem.extend_attributes(e.attributes().map(|attr| attr.unwrap()));\n///\n///             // copy existing attributes, adds a new my-key=\"some value\" attribute\n///             elem.push_attribute((\"my-key\", \"some value\"));\n///\n///             // writes the event to the writer\n///             assert!(writer.write_event(Event::Start(elem)).is_ok());\n///         },\n///         Ok(Event::End(ref e)) if e.name() == b\"this_tag\" => {\n///             assert!(writer.write_event(Event::End(BytesEnd::borrowed(b\"my_elem\"))).is_ok());\n///         },\n///         Ok(Event::Eof) => break,\n///         // we can either move or borrow the event to write, depending on your use-case\n///         Ok(e) => assert!(writer.write_event(&e).is_ok()),\n///         Err(e) => panic!(\"{}\", e),\n///     }\n///     buf.clear();\n/// }\n///\n/// let result = writer.into_inner().into_inner();\n/// let expected = r#\"<my_elem k1=\"v1\" k2=\"v2\" my-key=\"some value\"><child>text</child></my_elem>\"#;\n/// assert_eq!(result, expected.as_bytes());\n/// ```\npub struct Writer<W: Write> {\n    /// underlying writer\n    writer: W,\n    indent: Option<Indentation>,\n}",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Writer::<W>::create_element": [
            "/// Provides a simple, high-level API for writing XML elements.\n///\n/// Returns an [ElementWriter] that simplifies setting attributes and writing content inside the element.\n///\n/// # Example\n///\n/// ```rust\n/// # use quick_xml::Result;\n/// # fn main() -> Result<()> {\n/// use quick_xml::{Error, Writer};\n/// use quick_xml::events::{BytesStart, BytesText, Event};\n/// use std::io::Cursor;\n///\n/// let mut writer = Writer::new(Cursor::new(Vec::new()));\n///\n/// // writes <tag attr1=\"value1\"/>\n/// writer.create_element(\"tag\")\n///     .with_attribute((\"attr1\", \"value1\"))  // chain `with_attribute()` calls to add many attributes\n///     .write_empty()?;\n///\n/// // writes <tag attr1=\"value1\" attr2=\"value2\">with some text inside</tag>\n/// writer.create_element(\"tag\")\n///     .with_attributes(vec![(\"attr1\", \"value1\"), (\"attr2\", \"value2\")].into_iter())  // or add attributes from an iterator\n///     .write_text_content(BytesText::from_plain_str(\"with some text inside\"))?;\n///\n/// // writes <tag><fruit quantity=\"0\">apple</fruit><fruit quantity=\"1\">orange</fruit></tag>\n/// writer.create_element(\"tag\")\n///     .write_inner_content(|writer| {\n///         let fruits = [\"apple\", \"orange\"];\n///         for (quant, item) in fruits.iter().enumerate() {\n///             writer\n///                 .create_element(\"fruit\")\n///                 .with_attribute((\"quantity\", quant.to_string().as_str()))\n///                 .write_text_content(BytesText::from_plain_str(item))?;\n///         }\n///         Ok(())\n///     })?;\n/// # Ok(())\n/// # }\n/// ```\n#[must_use]\npub fn create_element<'a, N>(&'a mut self, name: &'a N) -> ElementWriter<W>\n    where\n        N: 'a + AsRef<[u8]> + ?Sized,{\n        ElementWriter {\n            writer: self,\n            start_tag: BytesStart::borrowed_name(name.as_ref()),\n        }\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Writer::<W>::inner": [
            "/// Get inner writer, keeping ownership\npub fn inner(&mut self) -> &mut W{\n        &mut self.writer\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Writer::<W>::into_inner": [
            "/// Consumes this `Writer`, returning the underlying writer.\npub fn into_inner(self) -> W{\n        self.writer\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Writer::<W>::new": [
            "/// Creates a Writer from a generic Write\npub fn new(inner: W) -> Writer<W>{\n        Writer {\n            writer: inner,\n            indent: None,\n        }\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Writer::<W>::new_with_indent": [
            "/// Creates a Writer with configured whitespace indents from a generic Write\npub fn new_with_indent(inner: W, indent_char: u8, indent_size: usize) -> Writer<W>{\n        Writer {\n            writer: inner,\n            indent: Some(Indentation::new(indent_char, indent_size)),\n        }\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Writer::<W>::write": [
            "/// Writes bytes\n#[inline]\npub fn write(&mut self, value: &[u8]) -> Result<()>{\n        self.writer.write_all(value).map_err(Error::Io)\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Writer::<W>::write_event": [
            "/// Writes the given event to the underlying writer.\npub fn write_event<'a, E: AsRef<Event<'a>>>(&mut self, event: E) -> Result<()>{\n        let mut next_should_line_break = true;\n        let result = match *event.as_ref() {\n            Event::Start(ref e) => {\n                let result = self.write_wrapped(b\"<\", e, b\">\");\n                if let Some(i) = self.indent.as_mut() {\n                    i.grow();\n                }\n                result\n            }\n            Event::End(ref e) => {\n                if let Some(i) = self.indent.as_mut() {\n                    i.shrink();\n                }\n                self.write_wrapped(b\"</\", e, b\">\")\n            }\n            Event::Empty(ref e) => self.write_wrapped(b\"<\", e, b\"/>\"),\n            Event::Text(ref e) => {\n                next_should_line_break = false;\n                self.write(&e.escaped())\n            }\n            Event::Comment(ref e) => self.write_wrapped(b\"<!--\", e, b\"-->\"),\n            Event::CData(ref e) => {\n                next_should_line_break = false;\n                self.write(b\"<![CDATA[\")?;\n                self.write(e)?;\n                self.write(b\"]]>\")\n            }\n            Event::Decl(ref e) => self.write_wrapped(b\"<?\", e, b\"?>\"),\n            Event::PI(ref e) => self.write_wrapped(b\"<?\", e, b\"?>\"),\n            Event::DocType(ref e) => self.write_wrapped(b\"<!DOCTYPE \", e, b\">\"),\n            Event::Eof => Ok(()),\n        };\n        if let Some(i) = self.indent.as_mut() {\n            i.should_line_break = next_should_line_break;\n        }\n        result\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Writer::<W>::write_indent": [
            "/// Manually write a newline and indentation at the proper level.\n///\n/// This can be used when the heuristic to line break and indent after any [Event] apart\n/// from [Text] fails such as when a [Start] occurs directly after [Text].\n/// This method will do nothing if `Writer` was not constructed with `new_with_indent`.\n///\n/// [Event]: events/enum.Event.html\n/// [Text]: events/enum.Event.html#variant.Text\n/// [Start]: events/enum.Event.html#variant.Start\npub fn write_indent(&mut self) -> Result<()>{\n        if let Some(ref i) = self.indent {\n            self.writer.write_all(b\"\\n\").map_err(Error::Io)?;\n            self.writer\n                .write_all(&i.indents[..i.indents_len])\n                .map_err(Error::Io)?;\n        }\n        Ok(())\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ],
        "writer::Writer::<W>::write_wrapped": [
            "#[inline]\nfn write_wrapped(&mut self, before: &[u8], value: &[u8], after: &[u8]) -> Result<()>{\n        if let Some(ref i) = self.indent {\n            if i.should_line_break {\n                self.writer.write_all(b\"\\n\").map_err(Error::Io)?;\n                self.writer\n                    .write_all(&i.indents[..i.indents_len])\n                    .map_err(Error::Io)?;\n            }\n        }\n        self.write(before)?;\n        self.write(value)?;\n        self.write(after)?;\n        Ok(())\n    }",
            "Real(LocalPath(\"src/writer.rs\"))"
        ]
    },
    "struct_constructor": {
        "&'a [u8]": [
            "key",
            "read_bytes_until",
            "read_element",
            "value"
        ],
        "&'b [u8]": [
            "read_bytes_until",
            "read_element"
        ],
        "&'c str": [
            "decode",
            "decode_without_bom"
        ],
        "&'r [u8]": [
            "read_bytes_until",
            "read_element"
        ],
        "&(dyn std::error::Error + 'static)": [
            "source"
        ],
        "&[u8]": [
            "attributes_raw",
            "deref",
            "escaped",
            "local_name",
            "name"
        ],
        "&str": [
            "named_entity"
        ],
        "(&'b [u8], usize)": [
            "change",
            "parse"
        ],
        "(T, std::option::Option<T>)": [
            "from"
        ],
        "(reader::BangType, &'a [u8])": [
            "read_bang_element"
        ],
        "(reader::BangType, &'b [u8])": [
            "read_bang_element"
        ],
        "(reader::BangType, &'r [u8])": [
            "read_bang_element"
        ],
        "(std::option::Option<&'b [u8]>, &'n [u8])": [
            "resolve"
        ],
        "(std::option::Option<&'c [u8]>, &'b [u8])": [
            "attribute_namespace",
            "event_namespace"
        ],
        "(std::option::Option<&'c [u8]>, events::Event<'b>)": [
            "read_namespaced_event"
        ],
        "<events::attributes::Attributes<'a> as std::iter::Iterator>::Item": [
            "next"
        ],
        "bool": [
            "eq",
            "is_match",
            "is_whitespace",
            "skip_one",
            "to_escape"
        ],
        "char": [
            "parse_number"
        ],
        "errors::Error": [
            "from",
            "to_err"
        ],
        "events::BytesCData": [
            "clone",
            "from_str",
            "new"
        ],
        "events::BytesDecl": [
            "clone",
            "from_start",
            "new"
        ],
        "events::BytesEnd": [
            "borrowed",
            "clone",
            "owned",
            "to_end"
        ],
        "events::BytesStart": [
            "borrowed",
            "borrowed_name",
            "clone",
            "owned",
            "owned_name",
            "to_borrowed",
            "to_owned"
        ],
        "events::BytesText": [
            "clone",
            "escape",
            "from_escaped",
            "from_escaped_str",
            "from_plain",
            "from_plain_str",
            "partial_escape"
        ],
        "events::Event": [
            "clone",
            "close_expanded_empty",
            "read_bang",
            "read_end",
            "read_event",
            "read_event_buffered",
            "read_event_unbuffered",
            "read_question_mark",
            "read_start",
            "read_until_close",
            "read_until_open"
        ],
        "events::attributes::Attr": [
            "clone",
            "double_q",
            "key_only",
            "next",
            "single_q"
        ],
        "events::attributes::Attribute": [
            "clone",
            "from",
            "try_get_attribute"
        ],
        "events::attributes::Attributes": [
            "attributes",
            "clone",
            "html",
            "html_attributes",
            "new"
        ],
        "events::attributes::IterState": [
            "clone",
            "new"
        ],
        "events::attributes::State": [
            "clone"
        ],
        "reader::BangType": [
            "new"
        ],
        "reader::Decoder": [
            "clone",
            "decoder"
        ],
        "reader::NamespaceEntry": [
            "clone"
        ],
        "reader::NamespaceResolver": [
            "clone",
            "default"
        ],
        "reader::ReadElementState": [
            "clone"
        ],
        "reader::Reader": [
            "clone",
            "from_bytes",
            "from_file",
            "from_reader",
            "from_str"
        ],
        "reader::TagState": [
            "clone"
        ],
        "std::borrow::Cow": [
            "_escape",
            "do_unescape",
            "encoding",
            "escape",
            "into_inner",
            "make_unescaped",
            "make_unescaped_value",
            "partial_escape",
            "standalone",
            "unescape",
            "unescape_with",
            "unescaped",
            "unescaped_value",
            "unescaped_value_with_custom_entities",
            "unescaped_with_custom_entities",
            "version"
        ],
        "std::cmp::Ordering": [
            "cmp",
            "partial_cmp"
        ],
        "std::string::String": [
            "decode_owned",
            "do_unescape_and_decode_value",
            "do_unescape_and_decode_with_custom_entities",
            "do_unescape_and_decode_without_bom",
            "read_text",
            "unescape_and_decode",
            "unescape_and_decode_value",
            "unescape_and_decode_value_with_custom_entities",
            "unescape_and_decode_with_custom_entities",
            "unescape_and_decode_without_bom",
            "unescape_and_decode_without_bom_with_custom_entities"
        ],
        "u32": [
            "parse_decimal",
            "parse_hexadecimal"
        ],
        "u8": [
            "peek_one"
        ],
        "usize": [
            "buffer_position",
            "recover"
        ],
        "writer::ElementWriter": [
            "create_element"
        ],
        "writer::Indentation": [
            "clone",
            "new"
        ],
        "writer::Writer": [
            "clone",
            "new",
            "new_with_indent"
        ]
    },
    "struct_to_trait": {
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::R": [
            "reader::XmlSource"
        ],
        "errors::Error": [
            "std::convert::From",
            "std::error::Error",
            "std::fmt::Debug",
            "std::fmt::Display"
        ],
        "escapei::EscapeError": [
            "std::error::Error",
            "std::fmt::Debug",
            "std::fmt::Display"
        ],
        "events::BytesCData": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::marker::StructuralEq",
            "std::marker::StructuralPartialEq",
            "std::ops::Deref"
        ],
        "events::BytesDecl": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::marker::StructuralEq",
            "std::marker::StructuralPartialEq",
            "std::ops::Deref"
        ],
        "events::BytesEnd": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::marker::StructuralEq",
            "std::marker::StructuralPartialEq",
            "std::ops::Deref"
        ],
        "events::BytesStart": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::marker::StructuralEq",
            "std::marker::StructuralPartialEq",
            "std::ops::Deref"
        ],
        "events::BytesText": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::marker::StructuralEq",
            "std::marker::StructuralPartialEq",
            "std::ops::Deref"
        ],
        "events::Event": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::PartialEq",
            "std::convert::AsRef",
            "std::fmt::Debug",
            "std::marker::StructuralEq",
            "std::marker::StructuralPartialEq",
            "std::ops::Deref"
        ],
        "events::attributes::Attr": [
            "std::clone::Clone",
            "std::cmp::Eq",
            "std::cmp::Ord",
            "std::cmp::PartialEq",
            "std::cmp::PartialOrd",
            "std::fmt::Debug",
            "std::hash::Hash",
            "std::marker::StructuralEq",
            "std::marker::StructuralPartialEq"
        ],
        "events::attributes::AttrError": [
            "std::cmp::PartialEq",
            "std::error::Error",
            "std::fmt::Debug",
            "std::fmt::Display",
            "std::marker::StructuralPartialEq"
        ],
        "events::attributes::Attribute": [
            "std::clone::Clone",
            "std::cmp::PartialEq",
            "std::convert::From",
            "std::fmt::Debug",
            "std::marker::StructuralPartialEq"
        ],
        "events::attributes::Attributes": [
            "std::clone::Clone",
            "std::fmt::Debug",
            "std::iter::FusedIterator",
            "std::iter::Iterator"
        ],
        "events::attributes::IterState": [
            "std::clone::Clone",
            "std::fmt::Debug"
        ],
        "events::attributes::State": [
            "std::clone::Clone",
            "std::fmt::Debug",
            "std::marker::Copy"
        ],
        "reader::BangType": [
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::marker::StructuralPartialEq"
        ],
        "reader::Decoder": [
            "std::clone::Clone",
            "std::fmt::Debug",
            "std::marker::Copy"
        ],
        "reader::NamespaceEntry": [
            "std::clone::Clone",
            "std::fmt::Debug"
        ],
        "reader::NamespaceResolver": [
            "std::clone::Clone",
            "std::default::Default",
            "std::fmt::Debug"
        ],
        "reader::ReadElementState": [
            "std::clone::Clone",
            "std::marker::Copy"
        ],
        "reader::Reader": [
            "std::clone::Clone"
        ],
        "reader::TagState": [
            "std::clone::Clone"
        ],
        "utils::ByteBuf": [
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::marker::StructuralPartialEq"
        ],
        "utils::Bytes": [
            "std::cmp::PartialEq",
            "std::fmt::Debug",
            "std::marker::StructuralPartialEq"
        ],
        "writer::Indentation": [
            "std::clone::Clone"
        ],
        "writer::Writer": [
            "std::clone::Clone"
        ]
    },
    "targets": {
        "<&'a [u8] as reader::XmlSource<'a, ()>>::peek_one": [
            "peek_one",
            "Real(LocalPath(\"src/reader.rs\"))",
            "reader::XmlSource"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::read_bang_element": [
            "read_bang_element",
            "Real(LocalPath(\"src/reader.rs\"))",
            "reader::XmlSource"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::read_bytes_until": [
            "read_bytes_until",
            "Real(LocalPath(\"src/reader.rs\"))",
            "reader::XmlSource"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::read_element": [
            "read_element",
            "Real(LocalPath(\"src/reader.rs\"))",
            "reader::XmlSource"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::skip_one": [
            "skip_one",
            "Real(LocalPath(\"src/reader.rs\"))",
            "reader::XmlSource"
        ],
        "<&'a [u8] as reader::XmlSource<'a, ()>>::skip_whitespace": [
            "skip_whitespace",
            "Real(LocalPath(\"src/reader.rs\"))",
            "reader::XmlSource"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::peek_one": [
            "peek_one",
            "Real(LocalPath(\"src/reader.rs\"))",
            "reader::XmlSource"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::read_bang_element": [
            "read_bang_element",
            "Real(LocalPath(\"src/reader.rs\"))",
            "reader::XmlSource"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::read_bytes_until": [
            "read_bytes_until",
            "Real(LocalPath(\"src/reader.rs\"))",
            "reader::XmlSource"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::read_element": [
            "read_element",
            "Real(LocalPath(\"src/reader.rs\"))",
            "reader::XmlSource"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::skip_one": [
            "skip_one",
            "Real(LocalPath(\"src/reader.rs\"))",
            "reader::XmlSource"
        ],
        "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::skip_whitespace": [
            "skip_whitespace",
            "Real(LocalPath(\"src/reader.rs\"))",
            "reader::XmlSource"
        ],
        "<errors::Error as std::convert::From<escapei::EscapeError>>::from": [
            "from",
            "Real(LocalPath(\"src/errors.rs\"))",
            "std::convert::From"
        ],
        "<errors::Error as std::convert::From<events::attributes::AttrError>>::from": [
            "from",
            "Real(LocalPath(\"src/errors.rs\"))",
            "std::convert::From"
        ],
        "<errors::Error as std::convert::From<std::io::Error>>::from": [
            "from",
            "Real(LocalPath(\"src/errors.rs\"))",
            "std::convert::From"
        ],
        "<errors::Error as std::convert::From<std::str::Utf8Error>>::from": [
            "from",
            "Real(LocalPath(\"src/errors.rs\"))",
            "std::convert::From"
        ],
        "<errors::Error as std::error::Error>::source": [
            "source",
            "Real(LocalPath(\"src/errors.rs\"))",
            "std::error::Error"
        ],
        "<errors::Error as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/errors.rs\"))",
            "std::fmt::Display"
        ],
        "<escapei::EscapeError as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/escapei.rs\"))",
            "std::fmt::Display"
        ],
        "<events::BytesCData<'a> as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            "std::fmt::Debug"
        ],
        "<events::BytesCData<'a> as std::ops::Deref>::deref": [
            "deref",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            "std::ops::Deref"
        ],
        "<events::BytesDecl<'a> as std::ops::Deref>::deref": [
            "deref",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            "std::ops::Deref"
        ],
        "<events::BytesEnd<'a> as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            "std::fmt::Debug"
        ],
        "<events::BytesEnd<'a> as std::ops::Deref>::deref": [
            "deref",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            "std::ops::Deref"
        ],
        "<events::BytesStart<'a> as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            "std::fmt::Debug"
        ],
        "<events::BytesStart<'a> as std::ops::Deref>::deref": [
            "deref",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            "std::ops::Deref"
        ],
        "<events::BytesText<'a> as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            "std::fmt::Debug"
        ],
        "<events::BytesText<'a> as std::ops::Deref>::deref": [
            "deref",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            "std::ops::Deref"
        ],
        "<events::Event<'a> as std::convert::AsRef<events::Event<'a>>>::as_ref": [
            "as_ref",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            "std::convert::AsRef"
        ],
        "<events::Event<'a> as std::ops::Deref>::deref": [
            "deref",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            "std::ops::Deref"
        ],
        "<events::attributes::Attr<T> as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            "std::fmt::Debug"
        ],
        "<events::attributes::AttrError as std::fmt::Display>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            "std::fmt::Display"
        ],
        "<events::attributes::Attribute<'a> as std::convert::From<(&'a [u8], &'a [u8])>>::from": [
            "from",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            "std::convert::From"
        ],
        "<events::attributes::Attribute<'a> as std::convert::From<(&'a str, &'a str)>>::from": [
            "from",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            "std::convert::From"
        ],
        "<events::attributes::Attribute<'a> as std::convert::From<events::attributes::Attr<&'a [u8]>>>::from": [
            "from",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            "std::convert::From"
        ],
        "<events::attributes::Attribute<'a> as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            "std::fmt::Debug"
        ],
        "<events::attributes::Attributes<'a> as std::iter::Iterator>::next": [
            "next",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            "std::iter::Iterator"
        ],
        "<utils::ByteBuf as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/utils.rs\"))",
            "std::fmt::Debug"
        ],
        "<utils::Bytes<'de> as std::fmt::Debug>::fmt": [
            "fmt",
            "Real(LocalPath(\"src/utils.rs\"))",
            "std::fmt::Debug"
        ],
        "escapei::_escape": [
            "_escape",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "escapei::do_unescape": [
            "do_unescape",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "escapei::escape": [
            "escape",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "escapei::escape::to_escape": [
            "to_escape",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "escapei::named_entity": [
            "named_entity",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "escapei::parse_decimal": [
            "parse_decimal",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "escapei::parse_hexadecimal": [
            "parse_hexadecimal",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "escapei::parse_number": [
            "parse_number",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "escapei::partial_escape": [
            "partial_escape",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "escapei::partial_escape::to_escape": [
            "to_escape",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "escapei::push_utf8": [
            "push_utf8",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "escapei::unescape": [
            "unescape",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "escapei::unescape_with": [
            "unescape_with",
            "Real(LocalPath(\"src/escapei.rs\"))",
            ""
        ],
        "events::BytesCData::<'a>::escape": [
            "escape",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesCData::<'a>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesCData::<'a>::into_inner": [
            "into_inner",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesCData::<'a>::into_owned": [
            "into_owned",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesCData::<'a>::new": [
            "new",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesCData::<'a>::partial_escape": [
            "partial_escape",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesDecl::<'a>::encoding": [
            "encoding",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesDecl::<'a>::from_start": [
            "from_start",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesDecl::<'a>::into_owned": [
            "into_owned",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesDecl::<'a>::new": [
            "new",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesDecl::<'a>::standalone": [
            "standalone",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesDecl::<'a>::version": [
            "version",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesEnd::<'a>::borrowed": [
            "borrowed",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesEnd::<'a>::into_owned": [
            "into_owned",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesEnd::<'a>::local_name": [
            "local_name",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesEnd::<'a>::name": [
            "name",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesEnd::<'a>::owned": [
            "owned",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::attributes": [
            "attributes",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::attributes_raw": [
            "attributes_raw",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::borrowed": [
            "borrowed",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::borrowed_name": [
            "borrowed_name",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::clear_attributes": [
            "clear_attributes",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::do_unescape_and_decode_with_custom_entities": [
            "do_unescape_and_decode_with_custom_entities",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::extend_attributes": [
            "extend_attributes",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::html_attributes": [
            "html_attributes",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::into_owned": [
            "into_owned",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::local_name": [
            "local_name",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::make_unescaped": [
            "make_unescaped",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::name": [
            "name",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::owned": [
            "owned",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::owned_name": [
            "owned_name",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::push_attribute": [
            "push_attribute",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::set_name": [
            "set_name",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::to_borrowed": [
            "to_borrowed",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::to_end": [
            "to_end",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::to_owned": [
            "to_owned",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::try_get_attribute": [
            "try_get_attribute",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::unescape_and_decode": [
            "unescape_and_decode",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::unescape_and_decode_with_custom_entities": [
            "unescape_and_decode_with_custom_entities",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::unescaped": [
            "unescaped",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::unescaped_with_custom_entities": [
            "unescaped_with_custom_entities",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesStart::<'a>::with_attributes": [
            "with_attributes",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::do_unescape_and_decode_with_custom_entities": [
            "do_unescape_and_decode_with_custom_entities",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::do_unescape_and_decode_without_bom": [
            "do_unescape_and_decode_without_bom",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::escaped": [
            "escaped",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::from_escaped": [
            "from_escaped",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::from_escaped_str": [
            "from_escaped_str",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::from_plain": [
            "from_plain",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::from_plain_str": [
            "from_plain_str",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::into_inner": [
            "into_inner",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::into_owned": [
            "into_owned",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::make_unescaped": [
            "make_unescaped",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::unescape_and_decode": [
            "unescape_and_decode",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::unescape_and_decode_with_custom_entities": [
            "unescape_and_decode_with_custom_entities",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::unescape_and_decode_without_bom": [
            "unescape_and_decode_without_bom",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::unescape_and_decode_without_bom_with_custom_entities": [
            "unescape_and_decode_without_bom_with_custom_entities",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::unescaped": [
            "unescaped",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::BytesText::<'a>::unescaped_with_custom_entities": [
            "unescaped_with_custom_entities",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::Event::<'a>::into_owned": [
            "into_owned",
            "Real(LocalPath(\"src/events/mod.rs\"))",
            ""
        ],
        "events::attributes::<impl std::convert::From<events::attributes::Attr<T>> for (T, std::option::Option<T>)>::from": [
            "from",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            "std::convert::From"
        ],
        "events::attributes::Attr::<&'a [u8]>::key": [
            "key",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attr::<&'a [u8]>::value": [
            "value",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attr::<T>::map": [
            "map",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attribute::<'a>::do_unescape_and_decode_value": [
            "do_unescape_and_decode_value",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attribute::<'a>::do_unescape_and_decode_without_bom": [
            "do_unescape_and_decode_without_bom",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attribute::<'a>::make_unescaped_value": [
            "make_unescaped_value",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attribute::<'a>::unescape_and_decode_value": [
            "unescape_and_decode_value",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attribute::<'a>::unescape_and_decode_value_with_custom_entities": [
            "unescape_and_decode_value_with_custom_entities",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attribute::<'a>::unescape_and_decode_without_bom": [
            "unescape_and_decode_without_bom",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attribute::<'a>::unescape_and_decode_without_bom_with_custom_entities": [
            "unescape_and_decode_without_bom_with_custom_entities",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attribute::<'a>::unescaped_value": [
            "unescaped_value",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attribute::<'a>::unescaped_value_with_custom_entities": [
            "unescaped_value_with_custom_entities",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attributes::<'a>::html": [
            "html",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attributes::<'a>::new": [
            "new",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::Attributes::<'a>::with_checks": [
            "with_checks",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::IterState::check_for_duplicates": [
            "check_for_duplicates",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::IterState::double_q": [
            "double_q",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::IterState::key_only": [
            "key_only",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::IterState::new": [
            "new",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::IterState::next": [
            "next",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::IterState::recover": [
            "recover",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::IterState::single_q": [
            "single_q",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::IterState::skip_eq_value": [
            "skip_eq_value",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "events::attributes::IterState::skip_value": [
            "skip_value",
            "Real(LocalPath(\"src/events/attributes.rs\"))",
            ""
        ],
        "reader::BangType::new": [
            "new",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::BangType::parse": [
            "parse",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::BangType::to_err": [
            "to_err",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Decoder::decode": [
            "decode",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Decoder::decode_owned": [
            "decode_owned",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::NamespaceEntry::is_match": [
            "is_match",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::NamespaceEntry::namespace": [
            "namespace",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::NamespaceResolver::find": [
            "find",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::NamespaceResolver::pop": [
            "pop",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::NamespaceResolver::push": [
            "push",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::NamespaceResolver::resolve": [
            "resolve",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::ReadElementState::change": [
            "change",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<&'a [u8]>::from_bytes": [
            "from_bytes",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<&'a [u8]>::from_str": [
            "from_str",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<&'a [u8]>::read_event_unbuffered": [
            "read_event_unbuffered",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<&'a [u8]>::read_to_end_unbuffered": [
            "read_to_end_unbuffered",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::attribute_namespace": [
            "attribute_namespace",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::buffer_position": [
            "buffer_position",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::check_comments": [
            "check_comments",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::check_end_names": [
            "check_end_names",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::close_expanded_empty": [
            "close_expanded_empty",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::decode": [
            "decode",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::decode_without_bom": [
            "decode_without_bom",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::decoder": [
            "decoder",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::event_namespace": [
            "event_namespace",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::expand_empty_elements": [
            "expand_empty_elements",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::from_reader": [
            "from_reader",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::get_mut": [
            "get_mut",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::get_ref": [
            "get_ref",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::into_inner": [
            "into_inner",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::read_bang": [
            "read_bang",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::read_end": [
            "read_end",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::read_event": [
            "read_event",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::read_event_buffered": [
            "read_event_buffered",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::read_namespaced_event": [
            "read_namespaced_event",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::read_question_mark": [
            "read_question_mark",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::read_start": [
            "read_start",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::read_text": [
            "read_text",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::read_to_end": [
            "read_to_end",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::read_until_close": [
            "read_until_close",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::read_until_open": [
            "read_until_open",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::trim_markup_names_in_closing_tags": [
            "trim_markup_names_in_closing_tags",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::trim_text": [
            "trim_text",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<R>::trim_text_end": [
            "trim_text_end",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::Reader::<std::io::BufReader<std::fs::File>>::from_file": [
            "from_file",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "reader::is_whitespace": [
            "is_whitespace",
            "Real(LocalPath(\"src/reader.rs\"))",
            ""
        ],
        "utils::write_byte_string": [
            "write_byte_string",
            "Real(LocalPath(\"src/utils.rs\"))",
            ""
        ],
        "utils::write_cow_string": [
            "write_cow_string",
            "Real(LocalPath(\"src/utils.rs\"))",
            ""
        ],
        "writer::ElementWriter::<'a, W>::with_attribute": [
            "with_attribute",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::ElementWriter::<'a, W>::with_attributes": [
            "with_attributes",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::ElementWriter::<'a, W>::write_cdata_content": [
            "write_cdata_content",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::ElementWriter::<'a, W>::write_empty": [
            "write_empty",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::ElementWriter::<'a, W>::write_inner_content": [
            "write_inner_content",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::ElementWriter::<'a, W>::write_pi_content": [
            "write_pi_content",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::ElementWriter::<'a, W>::write_text_content": [
            "write_text_content",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::Indentation::grow": [
            "grow",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::Indentation::new": [
            "new",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::Indentation::shrink": [
            "shrink",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::Writer::<W>::create_element": [
            "create_element",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::Writer::<W>::inner": [
            "inner",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::Writer::<W>::into_inner": [
            "into_inner",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::Writer::<W>::new": [
            "new",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::Writer::<W>::new_with_indent": [
            "new_with_indent",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::Writer::<W>::write": [
            "write",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::Writer::<W>::write_event": [
            "write_event",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::Writer::<W>::write_indent": [
            "write_indent",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ],
        "writer::Writer::<W>::write_wrapped": [
            "write_wrapped",
            "Real(LocalPath(\"src/writer.rs\"))",
            ""
        ]
    },
    "trait_to_struct": {
        "reader::XmlSource": [
            "<R as reader::XmlSource<'b, &'b mut std::vec::Vec<u8>>>::R"
        ],
        "std::clone::Clone": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "events::attributes::Attr",
            "events::attributes::Attribute",
            "events::attributes::Attributes",
            "events::attributes::IterState",
            "events::attributes::State",
            "reader::Decoder",
            "reader::NamespaceEntry",
            "reader::NamespaceResolver",
            "reader::ReadElementState",
            "reader::Reader",
            "reader::TagState",
            "writer::Indentation",
            "writer::Writer"
        ],
        "std::cmp::Eq": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "events::attributes::Attr"
        ],
        "std::cmp::Ord": [
            "events::attributes::Attr"
        ],
        "std::cmp::PartialEq": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "events::attributes::Attr",
            "events::attributes::AttrError",
            "events::attributes::Attribute",
            "reader::BangType",
            "utils::ByteBuf",
            "utils::Bytes"
        ],
        "std::cmp::PartialOrd": [
            "events::attributes::Attr"
        ],
        "std::convert::AsRef": [
            "events::Event"
        ],
        "std::convert::From": [
            "errors::Error",
            "events::attributes::Attribute"
        ],
        "std::default::Default": [
            "reader::NamespaceResolver"
        ],
        "std::error::Error": [
            "errors::Error",
            "escapei::EscapeError",
            "events::attributes::AttrError"
        ],
        "std::fmt::Debug": [
            "errors::Error",
            "escapei::EscapeError",
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "events::attributes::Attr",
            "events::attributes::AttrError",
            "events::attributes::Attribute",
            "events::attributes::Attributes",
            "events::attributes::IterState",
            "events::attributes::State",
            "reader::BangType",
            "reader::Decoder",
            "reader::NamespaceEntry",
            "reader::NamespaceResolver",
            "utils::ByteBuf",
            "utils::Bytes"
        ],
        "std::fmt::Display": [
            "errors::Error",
            "escapei::EscapeError",
            "events::attributes::AttrError"
        ],
        "std::hash::Hash": [
            "events::attributes::Attr"
        ],
        "std::iter::FusedIterator": [
            "events::attributes::Attributes"
        ],
        "std::iter::Iterator": [
            "events::attributes::Attributes"
        ],
        "std::marker::Copy": [
            "events::attributes::State",
            "reader::Decoder",
            "reader::ReadElementState"
        ],
        "std::marker::StructuralEq": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "events::attributes::Attr"
        ],
        "std::marker::StructuralPartialEq": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event",
            "events::attributes::Attr",
            "events::attributes::AttrError",
            "events::attributes::Attribute",
            "reader::BangType",
            "utils::ByteBuf",
            "utils::Bytes"
        ],
        "std::ops::Deref": [
            "events::BytesCData",
            "events::BytesDecl",
            "events::BytesEnd",
            "events::BytesStart",
            "events::BytesText",
            "events::Event"
        ]
    },
    "type_to_def_path": {
        "errors::Error": "errors::Error",
        "escapei::EscapeError": "escapei::EscapeError",
        "events::BytesCData<'a>": "events::BytesCData",
        "events::BytesDecl<'a>": "events::BytesDecl",
        "events::BytesEnd<'a>": "events::BytesEnd",
        "events::BytesStart<'a>": "events::BytesStart",
        "events::BytesText<'a>": "events::BytesText",
        "events::Event<'a>": "events::Event",
        "events::attributes::Attr<T>": "events::attributes::Attr",
        "events::attributes::AttrError": "events::attributes::AttrError",
        "events::attributes::Attribute<'a>": "events::attributes::Attribute",
        "events::attributes::Attributes<'a>": "events::attributes::Attributes",
        "events::attributes::IterState": "events::attributes::IterState",
        "events::attributes::State": "events::attributes::State",
        "reader::BangType": "reader::BangType",
        "reader::Decoder": "reader::Decoder",
        "reader::NamespaceEntry": "reader::NamespaceEntry",
        "reader::NamespaceResolver": "reader::NamespaceResolver",
        "reader::ReadElementState": "reader::ReadElementState",
        "reader::Reader<R>": "reader::Reader",
        "reader::TagState": "reader::TagState",
        "utils::ByteBuf": "utils::ByteBuf",
        "utils::Bytes<'de>": "utils::Bytes",
        "writer::ElementWriter<'a, W>": "writer::ElementWriter",
        "writer::Indentation": "writer::Indentation",
        "writer::Writer<W>": "writer::Writer"
    }
}