{"dependencies":{"<date::Date as std::clone::Clone>::clone":["date::Date"],"<date::Date as std::cmp::Eq>::assert_receiver_is_total_eq":["date::Date"],"<date::Date as std::cmp::Ord>::cmp":["date::Date","std::cmp::Ordering"],"<date::Date as std::cmp::PartialEq>::eq":["date::Date"],"<date::Date as std::cmp::PartialOrd>::partial_cmp":["date::Date","std::marker::Sized","std::option::Option"],"<date::Date as std::fmt::Debug>::fmt":["date::Date","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<date::Date as std::fmt::Display>::fmt":["date::Date","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<date::Date as std::hash::Hash>::hash":["date::Date","std::hash::Hasher","std::marker::Sized"],"<date::Date as std::ops::Add<duration::Duration>>::add":["date::Date","duration::Duration","duration::Padding"],"<date::Date as std::ops::Add<std::time::Duration>>::add":["date::Date","std::time::Duration"],"<date::Date as std::ops::AddAssign<duration::Duration>>::add_assign":["date::Date","duration::Duration","duration::Padding"],"<date::Date as std::ops::AddAssign<std::time::Duration>>::add_assign":["date::Date","std::time::Duration"],"<date::Date as std::ops::Sub<duration::Duration>>::sub":["date::Date","duration::Duration","duration::Padding"],"<date::Date as std::ops::Sub<std::time::Duration>>::sub":["date::Date","std::time::Duration"],"<date::Date as std::ops::Sub>::sub":["date::Date"],"<date::Date as std::ops::SubAssign<duration::Duration>>::sub_assign":["date::Date","duration::Duration","duration::Padding"],"<date::Date as std::ops::SubAssign<std::time::Duration>>::sub_assign":["date::Date","std::time::Duration"],"<duration::Duration as std::clone::Clone>::clone":["duration::Duration","duration::Padding"],"<duration::Duration as std::cmp::Eq>::assert_receiver_is_total_eq":["duration::Duration","duration::Padding"],"<duration::Duration as std::cmp::Ord>::cmp":["duration::Duration","duration::Padding","std::cmp::Ordering"],"<duration::Duration as std::cmp::PartialEq<std::time::Duration>>::eq":["duration::Duration","duration::Padding","std::time::Duration"],"<duration::Duration as std::cmp::PartialEq>::eq":["duration::Duration","duration::Padding"],"<duration::Duration as std::cmp::PartialOrd<std::time::Duration>>::partial_cmp":["duration::Duration","duration::Padding","std::marker::Sized","std::option::Option","std::time::Duration"],"<duration::Duration as std::cmp::PartialOrd>::partial_cmp":["duration::Duration","duration::Padding","std::marker::Sized","std::option::Option"],"<duration::Duration as std::convert::TryFrom<std::time::Duration>>::try_from":["std::marker::Sized","std::result::Result","std::time::Duration"],"<duration::Duration as std::default::Default>::default":["duration::Duration","duration::Padding"],"<duration::Duration as std::fmt::Debug>::fmt":["duration::Duration","duration::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<duration::Duration as std::hash::Hash>::hash":["duration::Duration","duration::Padding","std::hash::Hasher","std::marker::Sized"],"<duration::Duration as std::iter::Sum<&'a duration::Duration>>::sum":["duration::Duration","duration::Padding","std::iter::Iterator","std::marker::Sized"],"<duration::Duration as std::iter::Sum>::sum":["duration::Duration","duration::Padding","std::iter::Iterator","std::marker::Sized"],"<duration::Duration as std::ops::Add<std::time::Duration>>::add":["duration::Duration","duration::Padding","std::time::Duration"],"<duration::Duration as std::ops::Add>::add":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::AddAssign<std::time::Duration>>::add_assign":["duration::Duration","duration::Padding","std::time::Duration"],"<duration::Duration as std::ops::AddAssign>::add_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Div<f32>>::div":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Div<f64>>::div":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Div<i16>>::div":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Div<i32>>::div":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Div<i8>>::div":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Div<std::time::Duration>>::div":["duration::Duration","duration::Padding","std::time::Duration"],"<duration::Duration as std::ops::Div<u16>>::div":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Div<u32>>::div":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Div<u8>>::div":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Div>::div":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::DivAssign<f32>>::div_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::DivAssign<f64>>::div_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::DivAssign<i16>>::div_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::DivAssign<i32>>::div_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::DivAssign<i8>>::div_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::DivAssign<u16>>::div_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::DivAssign<u32>>::div_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::DivAssign<u8>>::div_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Mul<f32>>::mul":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Mul<f64>>::mul":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Mul<i16>>::mul":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Mul<i32>>::mul":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Mul<i8>>::mul":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Mul<u16>>::mul":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Mul<u32>>::mul":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Mul<u8>>::mul":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::MulAssign<f32>>::mul_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::MulAssign<f64>>::mul_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::MulAssign<i16>>::mul_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::MulAssign<i32>>::mul_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::MulAssign<i8>>::mul_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::MulAssign<u16>>::mul_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::MulAssign<u32>>::mul_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::MulAssign<u8>>::mul_assign":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Neg>::neg":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::Sub<std::time::Duration>>::sub":["duration::Duration","duration::Padding","std::time::Duration"],"<duration::Duration as std::ops::Sub>::sub":["duration::Duration","duration::Padding"],"<duration::Duration as std::ops::SubAssign<std::time::Duration>>::sub_assign":["duration::Duration","duration::Padding","std::time::Duration"],"<duration::Duration as std::ops::SubAssign>::sub_assign":["duration::Duration","duration::Padding"],"<duration::Padding as std::clone::Clone>::clone":["duration::Padding"],"<duration::Padding as std::cmp::Eq>::assert_receiver_is_total_eq":["duration::Padding"],"<duration::Padding as std::cmp::Ord>::cmp":["duration::Padding","std::cmp::Ordering"],"<duration::Padding as std::cmp::PartialEq>::eq":["duration::Padding"],"<duration::Padding as std::cmp::PartialOrd>::partial_cmp":["duration::Padding","std::marker::Sized","std::option::Option"],"<duration::Padding as std::default::Default>::default":["duration::Padding"],"<duration::Padding as std::fmt::Debug>::fmt":["duration::Padding","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<duration::Padding as std::hash::Hash>::hash":["duration::Padding","std::hash::Hasher","std::marker::Sized"],"<error::Error as std::error::Error>::source":["error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","std::marker::Sized","std::option::Option"],"<error::Error as std::fmt::Debug>::fmt":["error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Error as std::fmt::Display>::fmt":["error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::component_range::ComponentRange as std::clone::Clone>::clone":["error::component_range::ComponentRange"],"<error::component_range::ComponentRange as std::cmp::Eq>::assert_receiver_is_total_eq":["error::component_range::ComponentRange"],"<error::component_range::ComponentRange as std::cmp::PartialEq>::eq":["error::component_range::ComponentRange"],"<error::component_range::ComponentRange as std::convert::TryFrom<error::Error>>::try_from":["error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","std::marker::Sized","std::result::Result"],"<error::component_range::ComponentRange as std::fmt::Debug>::fmt":["error::component_range::ComponentRange","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::component_range::ComponentRange as std::fmt::Display>::fmt":["error::component_range::ComponentRange","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::component_range::ComponentRange as std::hash::Hash>::hash":["error::component_range::ComponentRange","std::hash::Hasher","std::marker::Sized"],"<error::conversion_range::ConversionRange as std::clone::Clone>::clone":["error::conversion_range::ConversionRange"],"<error::conversion_range::ConversionRange as std::cmp::Eq>::assert_receiver_is_total_eq":["error::conversion_range::ConversionRange"],"<error::conversion_range::ConversionRange as std::cmp::PartialEq>::eq":["error::conversion_range::ConversionRange"],"<error::conversion_range::ConversionRange as std::convert::TryFrom<error::Error>>::try_from":["error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","std::marker::Sized","std::result::Result"],"<error::conversion_range::ConversionRange as std::fmt::Debug>::fmt":["error::conversion_range::ConversionRange","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::conversion_range::ConversionRange as std::fmt::Display>::fmt":["error::conversion_range::ConversionRange","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::different_variant::DifferentVariant as std::clone::Clone>::clone":["error::different_variant::DifferentVariant"],"<error::different_variant::DifferentVariant as std::cmp::Eq>::assert_receiver_is_total_eq":["error::different_variant::DifferentVariant"],"<error::different_variant::DifferentVariant as std::cmp::PartialEq>::eq":["error::different_variant::DifferentVariant"],"<error::different_variant::DifferentVariant as std::convert::TryFrom<error::Error>>::try_from":["error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","std::marker::Sized","std::result::Result"],"<error::different_variant::DifferentVariant as std::fmt::Debug>::fmt":["error::different_variant::DifferentVariant","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::different_variant::DifferentVariant as std::fmt::Display>::fmt":["error::different_variant::DifferentVariant","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<f64 as ext::NumericalDuration>::days":["duration::Duration","duration::Padding"],"<f64 as ext::NumericalDuration>::hours":["duration::Duration","duration::Padding"],"<f64 as ext::NumericalDuration>::microseconds":["duration::Duration","duration::Padding"],"<f64 as ext::NumericalDuration>::milliseconds":["duration::Duration","duration::Padding"],"<f64 as ext::NumericalDuration>::minutes":["duration::Duration","duration::Padding"],"<f64 as ext::NumericalDuration>::nanoseconds":["duration::Duration","duration::Padding"],"<f64 as ext::NumericalDuration>::seconds":["duration::Duration","duration::Padding"],"<f64 as ext::NumericalDuration>::weeks":["duration::Duration","duration::Padding"],"<f64 as ext::NumericalStdDuration>::std_days":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_hours":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_microseconds":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_milliseconds":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_minutes":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_nanoseconds":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_seconds":["std::time::Duration"],"<f64 as ext::NumericalStdDuration>::std_weeks":["std::time::Duration"],"<i64 as ext::NumericalDuration>::days":["duration::Duration","duration::Padding"],"<i64 as ext::NumericalDuration>::hours":["duration::Duration","duration::Padding"],"<i64 as ext::NumericalDuration>::microseconds":["duration::Duration","duration::Padding"],"<i64 as ext::NumericalDuration>::milliseconds":["duration::Duration","duration::Padding"],"<i64 as ext::NumericalDuration>::minutes":["duration::Duration","duration::Padding"],"<i64 as ext::NumericalDuration>::nanoseconds":["duration::Duration","duration::Padding"],"<i64 as ext::NumericalDuration>::seconds":["duration::Duration","duration::Padding"],"<i64 as ext::NumericalDuration>::weeks":["duration::Duration","duration::Padding"],"<instant::Instant as std::borrow::Borrow<std::time::Instant>>::borrow":["instant::Instant","std::time::Instant"],"<instant::Instant as std::clone::Clone>::clone":["instant::Instant","std::time::Instant"],"<instant::Instant as std::cmp::Eq>::assert_receiver_is_total_eq":["instant::Instant","std::time::Instant"],"<instant::Instant as std::cmp::Ord>::cmp":["instant::Instant","std::cmp::Ordering","std::time::Instant"],"<instant::Instant as std::cmp::PartialEq<std::time::Instant>>::eq":["instant::Instant","std::time::Instant"],"<instant::Instant as std::cmp::PartialEq>::eq":["instant::Instant","std::time::Instant"],"<instant::Instant as std::cmp::PartialOrd<std::time::Instant>>::partial_cmp":["instant::Instant","std::marker::Sized","std::option::Option","std::time::Instant"],"<instant::Instant as std::cmp::PartialOrd>::partial_cmp":["instant::Instant","std::marker::Sized","std::option::Option","std::time::Instant"],"<instant::Instant as std::convert::AsRef<std::time::Instant>>::as_ref":["instant::Instant","std::time::Instant"],"<instant::Instant as std::convert::From<std::time::Instant>>::from":["instant::Instant","std::time::Instant"],"<instant::Instant as std::fmt::Debug>::fmt":["instant::Instant","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::time::Instant"],"<instant::Instant as std::hash::Hash>::hash":["instant::Instant","std::hash::Hasher","std::marker::Sized","std::time::Instant"],"<instant::Instant as std::ops::Add<duration::Duration>>::add":["duration::Duration","duration::Padding","instant::Instant","std::time::Instant"],"<instant::Instant as std::ops::Add<std::time::Duration>>::add":["instant::Instant","std::time::Duration","std::time::Instant"],"<instant::Instant as std::ops::AddAssign<duration::Duration>>::add_assign":["duration::Duration","duration::Padding","instant::Instant","std::time::Instant"],"<instant::Instant as std::ops::AddAssign<std::time::Duration>>::add_assign":["instant::Instant","std::time::Duration","std::time::Instant"],"<instant::Instant as std::ops::Sub<duration::Duration>>::sub":["duration::Duration","duration::Padding","instant::Instant","std::time::Instant"],"<instant::Instant as std::ops::Sub<std::time::Duration>>::sub":["instant::Instant","std::time::Duration","std::time::Instant"],"<instant::Instant as std::ops::Sub<std::time::Instant>>::sub":["instant::Instant","std::time::Instant"],"<instant::Instant as std::ops::Sub>::sub":["instant::Instant","std::time::Instant"],"<instant::Instant as std::ops::SubAssign<duration::Duration>>::sub_assign":["duration::Duration","duration::Padding","instant::Instant","std::time::Instant"],"<instant::Instant as std::ops::SubAssign<std::time::Duration>>::sub_assign":["instant::Instant","std::time::Duration","std::time::Instant"],"<month::Month as std::clone::Clone>::clone":["month::Month"],"<month::Month as std::cmp::Eq>::assert_receiver_is_total_eq":["month::Month"],"<month::Month as std::cmp::PartialEq>::eq":["month::Month"],"<month::Month as std::convert::TryFrom<u8>>::try_from":["std::marker::Sized","std::result::Result"],"<month::Month as std::fmt::Debug>::fmt":["month::Month","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<month::Month as std::fmt::Display>::fmt":["month::Month","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<month::Month as std::hash::Hash>::hash":["month::Month","std::hash::Hasher","std::marker::Sized"],"<offset_date_time::OffsetDateTime as std::clone::Clone>::clone":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::cmp::Eq>::assert_receiver_is_total_eq":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::cmp::Ord>::cmp":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::cmp::Ordering","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::cmp::PartialEq>::eq":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","std::time::SystemTime","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::cmp::PartialOrd>::partial_cmp":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::convert::From<std::time::SystemTime>>::from":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::fmt::Debug>::fmt":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::fmt::Formatter","std::marker::Sized","std::result::Result","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::fmt::Display>::fmt":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::fmt::Formatter","std::marker::Sized","std::result::Result","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::hash::Hash>::hash":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::hash::Hasher","std::marker::Sized","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::Add<T>>::add":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::AddAssign<duration::Duration>>::add_assign":["date::Date","duration::Duration","duration::Padding","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::Sub<T>>::sub":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::SystemTime>>::sub":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::Sub>::sub":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign":["date::Date","duration::Duration","duration::Padding","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"<offset_date_time::OffsetDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","time::Padding","time::Time","utc_offset::UtcOffset"],"<primitive_date_time::PrimitiveDateTime as std::clone::Clone>::clone":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::cmp::Eq>::assert_receiver_is_total_eq":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::cmp::Ord>::cmp":["date::Date","primitive_date_time::PrimitiveDateTime","std::cmp::Ordering","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::cmp::PartialEq>::eq":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::cmp::PartialOrd>::partial_cmp":["date::Date","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::fmt::Debug>::fmt":["date::Date","primitive_date_time::PrimitiveDateTime","std::fmt::Formatter","std::marker::Sized","std::result::Result","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::fmt::Display>::fmt":["date::Date","primitive_date_time::PrimitiveDateTime","std::fmt::Formatter","std::marker::Sized","std::result::Result","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::hash::Hash>::hash":["date::Date","primitive_date_time::PrimitiveDateTime","std::hash::Hasher","std::marker::Sized","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<duration::Duration>>::add":["date::Date","duration::Duration","duration::Padding","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<std::time::Duration>>::add":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::Duration","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<duration::Duration>>::add_assign":["date::Date","duration::Duration","duration::Padding","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::Duration","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<duration::Duration>>::sub":["date::Date","duration::Duration","duration::Padding","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::Duration>>::sub":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::Duration","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub>::sub":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign":["date::Date","duration::Duration","duration::Padding","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign":["date::Date","primitive_date_time::PrimitiveDateTime","std::time::Duration","time::Padding","time::Time"],"<time::Padding as std::clone::Clone>::clone":["time::Padding"],"<time::Padding as std::cmp::Eq>::assert_receiver_is_total_eq":["time::Padding"],"<time::Padding as std::cmp::Ord>::cmp":["std::cmp::Ordering","time::Padding"],"<time::Padding as std::cmp::PartialEq>::eq":["time::Padding"],"<time::Padding as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","time::Padding"],"<time::Padding as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","time::Padding"],"<time::Time as std::clone::Clone>::clone":["time::Padding","time::Time"],"<time::Time as std::cmp::Eq>::assert_receiver_is_total_eq":["time::Padding","time::Time"],"<time::Time as std::cmp::Ord>::cmp":["std::cmp::Ordering","time::Padding","time::Time"],"<time::Time as std::cmp::PartialEq>::eq":["time::Padding","time::Time"],"<time::Time as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","time::Padding","time::Time"],"<time::Time as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","time::Padding","time::Time"],"<time::Time as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","time::Padding","time::Time"],"<time::Time as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","time::Padding","time::Time"],"<time::Time as std::ops::Add<duration::Duration>>::add":["duration::Duration","duration::Padding","time::Padding","time::Time"],"<time::Time as std::ops::Add<std::time::Duration>>::add":["std::time::Duration","time::Padding","time::Time"],"<time::Time as std::ops::AddAssign<duration::Duration>>::add_assign":["duration::Duration","duration::Padding","time::Padding","time::Time"],"<time::Time as std::ops::AddAssign<std::time::Duration>>::add_assign":["std::time::Duration","time::Padding","time::Time"],"<time::Time as std::ops::Sub<duration::Duration>>::sub":["duration::Duration","duration::Padding","time::Padding","time::Time"],"<time::Time as std::ops::Sub<std::time::Duration>>::sub":["std::time::Duration","time::Padding","time::Time"],"<time::Time as std::ops::Sub>::sub":["time::Padding","time::Time"],"<time::Time as std::ops::SubAssign<duration::Duration>>::sub_assign":["duration::Duration","duration::Padding","time::Padding","time::Time"],"<time::Time as std::ops::SubAssign<std::time::Duration>>::sub_assign":["std::time::Duration","time::Padding","time::Time"],"<u64 as ext::NumericalStdDuration>::std_days":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_hours":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_microseconds":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_milliseconds":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_minutes":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_nanoseconds":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_seconds":["std::time::Duration"],"<u64 as ext::NumericalStdDuration>::std_weeks":["std::time::Duration"],"<utc_offset::UtcOffset as std::clone::Clone>::clone":["utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::cmp::Eq>::assert_receiver_is_total_eq":["utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::cmp::Ord>::cmp":["std::cmp::Ordering","utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::cmp::PartialEq>::eq":["utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::cmp::PartialOrd>::partial_cmp":["std::marker::Sized","std::option::Option","utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","utc_offset::UtcOffset"],"<utc_offset::UtcOffset as std::ops::Neg>::neg":["utc_offset::UtcOffset"],"<weekday::Weekday as std::clone::Clone>::clone":["weekday::Weekday"],"<weekday::Weekday as std::cmp::Eq>::assert_receiver_is_total_eq":["weekday::Weekday"],"<weekday::Weekday as std::cmp::PartialEq>::eq":["weekday::Weekday"],"<weekday::Weekday as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","weekday::Weekday"],"<weekday::Weekday as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","weekday::Weekday"],"<weekday::Weekday as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","weekday::Weekday"],"date::Date":["date::Date"],"date::Date::__from_ordinal_date_unchecked":["date::Date"],"date::Date::checked_add":["date::Date","duration::Duration","duration::Padding","std::marker::Sized","std::option::Option"],"date::Date::checked_sub":["date::Date","duration::Duration","duration::Padding","std::marker::Sized","std::option::Option"],"date::Date::day":["date::Date"],"date::Date::from_calendar_date":["month::Month","std::marker::Sized","std::result::Result"],"date::Date::from_iso_week_date":["std::marker::Sized","std::result::Result","weekday::Weekday"],"date::Date::from_julian_day":["std::marker::Sized","std::result::Result"],"date::Date::from_julian_day_unchecked":["date::Date"],"date::Date::from_ordinal_date":["std::marker::Sized","std::result::Result"],"date::Date::iso_week":["date::Date"],"date::Date::iso_year_week":["date::Date"],"date::Date::midnight":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"date::Date::monday_based_week":["date::Date"],"date::Date::month":["date::Date","month::Month"],"date::Date::month_day":["date::Date","month::Month"],"date::Date::next_day":["date::Date","std::marker::Sized","std::option::Option"],"date::Date::ordinal":["date::Date"],"date::Date::previous_day":["date::Date","std::marker::Sized","std::option::Option"],"date::Date::saturating_add":["date::Date","duration::Duration","duration::Padding"],"date::Date::saturating_sub":["date::Date","duration::Duration","duration::Padding"],"date::Date::sunday_based_week":["date::Date"],"date::Date::to_calendar_date":["date::Date","month::Month"],"date::Date::to_iso_week_date":["date::Date","weekday::Weekday"],"date::Date::to_julian_day":["date::Date"],"date::Date::to_ordinal_date":["date::Date"],"date::Date::weekday":["date::Date","weekday::Weekday"],"date::Date::with_hms":["date::Date","std::marker::Sized","std::result::Result"],"date::Date::with_hms_micro":["date::Date","std::marker::Sized","std::result::Result"],"date::Date::with_hms_milli":["date::Date","std::marker::Sized","std::result::Result"],"date::Date::with_hms_nano":["date::Date","std::marker::Sized","std::result::Result"],"date::Date::with_time":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"date::Date::year":["date::Date"],"duration::<impl std::cmp::PartialEq<duration::Duration> for std::time::Duration>::eq":["duration::Duration","duration::Padding","std::time::Duration"],"duration::<impl std::cmp::PartialOrd<duration::Duration> for std::time::Duration>::partial_cmp":["duration::Duration","duration::Padding","std::marker::Sized","std::option::Option","std::time::Duration"],"duration::<impl std::convert::TryFrom<duration::Duration> for std::time::Duration>::try_from":["duration::Duration","duration::Padding","std::marker::Sized","std::result::Result"],"duration::<impl std::ops::Add<duration::Duration> for std::time::Duration>::add":["duration::Duration","duration::Padding","std::time::Duration"],"duration::<impl std::ops::Div<duration::Duration> for std::time::Duration>::div":["duration::Duration","duration::Padding","std::time::Duration"],"duration::<impl std::ops::Mul<duration::Duration> for f32>::mul":["duration::Duration","duration::Padding"],"duration::<impl std::ops::Mul<duration::Duration> for f64>::mul":["duration::Duration","duration::Padding"],"duration::<impl std::ops::Mul<duration::Duration> for i16>::mul":["duration::Duration","duration::Padding"],"duration::<impl std::ops::Mul<duration::Duration> for i32>::mul":["duration::Duration","duration::Padding"],"duration::<impl std::ops::Mul<duration::Duration> for i8>::mul":["duration::Duration","duration::Padding"],"duration::<impl std::ops::Mul<duration::Duration> for u16>::mul":["duration::Duration","duration::Padding"],"duration::<impl std::ops::Mul<duration::Duration> for u32>::mul":["duration::Duration","duration::Padding"],"duration::<impl std::ops::Mul<duration::Duration> for u8>::mul":["duration::Duration","duration::Padding"],"duration::<impl std::ops::Sub<duration::Duration> for std::time::Duration>::sub":["duration::Duration","duration::Padding","std::time::Duration"],"duration::<impl std::ops::SubAssign<duration::Duration> for std::time::Duration>::sub_assign":["duration::Duration","duration::Padding","std::time::Duration"],"duration::Duration":["duration::Duration","duration::Padding"],"duration::Duration::abs":["duration::Duration","duration::Padding"],"duration::Duration::abs_std":["duration::Duration","duration::Padding","std::time::Duration"],"duration::Duration::as_seconds_f32":["duration::Duration","duration::Padding"],"duration::Duration::as_seconds_f64":["duration::Duration","duration::Padding"],"duration::Duration::checked_add":["duration::Duration","duration::Padding","std::marker::Sized","std::option::Option"],"duration::Duration::checked_div":["duration::Duration","duration::Padding","std::marker::Sized","std::option::Option"],"duration::Duration::checked_mul":["duration::Duration","duration::Padding","std::marker::Sized","std::option::Option"],"duration::Duration::checked_sub":["duration::Duration","duration::Padding","std::marker::Sized","std::option::Option"],"duration::Duration::days":["duration::Duration","duration::Padding"],"duration::Duration::hours":["duration::Duration","duration::Padding"],"duration::Duration::is_negative":["duration::Duration","duration::Padding"],"duration::Duration::is_positive":["duration::Duration","duration::Padding"],"duration::Duration::is_zero":["duration::Duration","duration::Padding"],"duration::Duration::microseconds":["duration::Duration","duration::Padding"],"duration::Duration::milliseconds":["duration::Duration","duration::Padding"],"duration::Duration::minutes":["duration::Duration","duration::Padding"],"duration::Duration::nanoseconds":["duration::Duration","duration::Padding"],"duration::Duration::nanoseconds_i128":["duration::Duration","duration::Padding"],"duration::Duration::new":["duration::Duration","duration::Padding"],"duration::Duration::new_unchecked":["duration::Duration","duration::Padding"],"duration::Duration::saturating_add":["duration::Duration","duration::Padding"],"duration::Duration::saturating_mul":["duration::Duration","duration::Padding"],"duration::Duration::saturating_sub":["duration::Duration","duration::Padding"],"duration::Duration::seconds":["duration::Duration","duration::Padding"],"duration::Duration::seconds_f32":["duration::Duration","duration::Padding"],"duration::Duration::seconds_f64":["duration::Duration","duration::Padding"],"duration::Duration::subsec_microseconds":["duration::Duration","duration::Padding"],"duration::Duration::subsec_milliseconds":["duration::Duration","duration::Padding"],"duration::Duration::subsec_nanoseconds":["duration::Duration","duration::Padding"],"duration::Duration::time_fn":["duration::Duration","duration::Padding","std::marker::Sized","std::ops::FnOnce"],"duration::Duration::weeks":["duration::Duration","duration::Padding"],"duration::Duration::whole_days":["duration::Duration","duration::Padding"],"duration::Duration::whole_hours":["duration::Duration","duration::Padding"],"duration::Duration::whole_microseconds":["duration::Duration","duration::Padding"],"duration::Duration::whole_milliseconds":["duration::Duration","duration::Padding"],"duration::Duration::whole_minutes":["duration::Duration","duration::Padding"],"duration::Duration::whole_nanoseconds":["duration::Duration","duration::Padding"],"duration::Duration::whole_seconds":["duration::Duration","duration::Padding"],"duration::Duration::whole_weeks":["duration::Duration","duration::Padding"],"duration::Padding":["duration::Padding"],"error::Error":["error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant"],"error::component_range::<impl std::convert::From<error::component_range::ComponentRange> for error::Error>::from":["error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant"],"error::component_range::ComponentRange":["error::component_range::ComponentRange"],"error::component_range::ComponentRange::name":["error::component_range::ComponentRange"],"error::conversion_range::<impl std::convert::From<error::conversion_range::ConversionRange> for error::Error>::from":["error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant"],"error::conversion_range::ConversionRange":["error::conversion_range::ConversionRange"],"error::different_variant::<impl std::convert::From<error::different_variant::DifferentVariant> for error::Error>::from":["error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant"],"error::different_variant::DifferentVariant":["error::different_variant::DifferentVariant"],"ext::NumericalDuration::days":["duration::Duration","duration::Padding"],"ext::NumericalDuration::hours":["duration::Duration","duration::Padding"],"ext::NumericalDuration::microseconds":["duration::Duration","duration::Padding"],"ext::NumericalDuration::milliseconds":["duration::Duration","duration::Padding"],"ext::NumericalDuration::minutes":["duration::Duration","duration::Padding"],"ext::NumericalDuration::nanoseconds":["duration::Duration","duration::Padding"],"ext::NumericalDuration::seconds":["duration::Duration","duration::Padding"],"ext::NumericalDuration::weeks":["duration::Duration","duration::Padding"],"ext::NumericalStdDuration::std_days":["std::time::Duration"],"ext::NumericalStdDuration::std_hours":["std::time::Duration"],"ext::NumericalStdDuration::std_microseconds":["std::time::Duration"],"ext::NumericalStdDuration::std_milliseconds":["std::time::Duration"],"ext::NumericalStdDuration::std_minutes":["std::time::Duration"],"ext::NumericalStdDuration::std_nanoseconds":["std::time::Duration"],"ext::NumericalStdDuration::std_seconds":["std::time::Duration"],"ext::NumericalStdDuration::std_weeks":["std::time::Duration"],"instant::<impl std::cmp::PartialEq<instant::Instant> for std::time::Instant>::eq":["instant::Instant","std::time::Instant"],"instant::<impl std::cmp::PartialOrd<instant::Instant> for std::time::Instant>::partial_cmp":["instant::Instant","std::marker::Sized","std::option::Option","std::time::Instant"],"instant::<impl std::convert::From<instant::Instant> for std::time::Instant>::from":["instant::Instant","std::time::Instant"],"instant::<impl std::ops::Add<duration::Duration> for std::time::Instant>::add":["duration::Duration","duration::Padding","std::time::Instant"],"instant::<impl std::ops::AddAssign<duration::Duration> for std::time::Instant>::add_assign":["duration::Duration","duration::Padding","std::time::Instant"],"instant::<impl std::ops::Sub<duration::Duration> for std::time::Instant>::sub":["duration::Duration","duration::Padding","std::time::Instant"],"instant::<impl std::ops::Sub<instant::Instant> for std::time::Instant>::sub":["instant::Instant","std::time::Instant"],"instant::<impl std::ops::SubAssign<duration::Duration> for std::time::Instant>::sub_assign":["duration::Duration","duration::Padding","std::time::Instant"],"instant::Instant":["instant::Instant","std::time::Instant"],"instant::Instant::checked_add":["duration::Duration","duration::Padding","instant::Instant","std::marker::Sized","std::option::Option","std::time::Instant"],"instant::Instant::checked_sub":["duration::Duration","duration::Padding","instant::Instant","std::marker::Sized","std::option::Option","std::time::Instant"],"instant::Instant::elapsed":["duration::Duration","duration::Padding","instant::Instant","std::time::Instant"],"instant::Instant::into_inner":["instant::Instant","std::time::Instant"],"instant::Instant::now":["instant::Instant","std::time::Instant"],"month::<impl std::convert::From<month::Month> for u8>::from":["month::Month"],"month::Month":["month::Month"],"month::Month::from_number":["std::marker::Sized","std::num::NonZeroU8","std::result::Result"],"month::Month::next":["month::Month"],"month::Month::previous":["month::Month"],"offset_date_time::<impl std::cmp::PartialEq<offset_date_time::OffsetDateTime> for std::time::SystemTime>::eq":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::<impl std::cmp::PartialOrd<offset_date_time::OffsetDateTime> for std::time::SystemTime>::partial_cmp":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","std::time::SystemTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::<impl std::convert::From<offset_date_time::OffsetDateTime> for std::time::SystemTime>::from":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::<impl std::ops::Add<duration::Duration> for std::time::SystemTime>::add":["duration::Duration","duration::Padding","std::time::SystemTime"],"offset_date_time::<impl std::ops::AddAssign<duration::Duration> for std::time::SystemTime>::add_assign":["duration::Duration","duration::Padding","std::time::SystemTime"],"offset_date_time::<impl std::ops::Sub<duration::Duration> for std::time::SystemTime>::sub":["duration::Duration","duration::Padding","std::time::SystemTime"],"offset_date_time::<impl std::ops::Sub<offset_date_time::OffsetDateTime> for std::time::SystemTime>::sub":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::SystemTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::<impl std::ops::SubAssign<duration::Duration> for std::time::SystemTime>::sub_assign":["duration::Duration","duration::Padding","std::time::SystemTime"],"offset_date_time::OffsetDateTime":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::checked_add":["date::Date","duration::Duration","duration::Padding","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::checked_sub":["date::Date","duration::Duration","duration::Padding","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::date":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::day":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::from_unix_timestamp":["std::marker::Sized","std::result::Result"],"offset_date_time::OffsetDateTime::from_unix_timestamp_nanos":["std::marker::Sized","std::result::Result"],"offset_date_time::OffsetDateTime::hour":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::iso_week":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::microsecond":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::millisecond":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::minute":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::monday_based_week":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::month":["date::Date","month::Month","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::nanosecond":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::now_utc":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::offset":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::ordinal":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::replace_date":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::replace_date_time":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::replace_offset":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::replace_time":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::saturating_add":["date::Date","duration::Duration","duration::Padding","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::saturating_sub":["date::Date","duration::Duration","duration::Padding","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::second":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::sunday_based_week":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::time":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::to_calendar_date":["date::Date","month::Month","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::to_hms":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::to_hms_micro":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::to_hms_milli":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::to_hms_nano":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::to_iso_week_date":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset","weekday::Weekday"],"offset_date_time::OffsetDateTime::to_julian_day":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::to_offset":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::to_ordinal_date":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::unix_timestamp":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::unix_timestamp_nanos":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"offset_date_time::OffsetDateTime::weekday":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset","weekday::Weekday"],"offset_date_time::OffsetDateTime::year":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"primitive_date_time::PrimitiveDateTime":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::as_hms":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::as_hms_micro":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::as_hms_milli":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::as_hms_nano":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::assume_offset":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"primitive_date_time::PrimitiveDateTime::assume_utc":["date::Date","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"primitive_date_time::PrimitiveDateTime::checked_add":["date::Date","duration::Duration","duration::Padding","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::checked_sub":["date::Date","duration::Duration","duration::Padding","primitive_date_time::PrimitiveDateTime","std::marker::Sized","std::option::Option","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::date":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::day":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::hour":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::iso_week":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::microsecond":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::millisecond":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::minute":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::monday_based_week":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::month":["date::Date","month::Month","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::nanosecond":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::new":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::offset_to_utc":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"primitive_date_time::PrimitiveDateTime::ordinal":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::replace_date":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::replace_time":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::saturating_add":["date::Date","duration::Duration","duration::Padding","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::saturating_sub":["date::Date","duration::Duration","duration::Padding","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::second":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::sunday_based_week":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::time":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::to_calendar_date":["date::Date","month::Month","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::to_iso_week_date":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","weekday::Weekday"],"primitive_date_time::PrimitiveDateTime::to_julian_day":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::to_ordinal_date":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"primitive_date_time::PrimitiveDateTime::utc_to_offset":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"primitive_date_time::PrimitiveDateTime::weekday":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","weekday::Weekday"],"primitive_date_time::PrimitiveDateTime::year":["date::Date","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time"],"time::Padding":["time::Padding"],"time::Time":["time::Padding","time::Time"],"time::Time::__from_hms_nanos_unchecked":["time::Padding","time::Time"],"time::Time::adjusting_add":["duration::Duration","duration::Padding","time::Padding","time::Time","util::DateAdjustment"],"time::Time::adjusting_add_std":["std::time::Duration","time::Padding","time::Time"],"time::Time::adjusting_sub":["duration::Duration","duration::Padding","time::Padding","time::Time","util::DateAdjustment"],"time::Time::adjusting_sub_std":["std::time::Duration","time::Padding","time::Time"],"time::Time::as_hms":["time::Padding","time::Time"],"time::Time::as_hms_micro":["time::Padding","time::Time"],"time::Time::as_hms_milli":["time::Padding","time::Time"],"time::Time::as_hms_nano":["time::Padding","time::Time"],"time::Time::from_hms":["std::marker::Sized","std::result::Result"],"time::Time::from_hms_micro":["std::marker::Sized","std::result::Result"],"time::Time::from_hms_milli":["std::marker::Sized","std::result::Result"],"time::Time::from_hms_nano":["std::marker::Sized","std::result::Result"],"time::Time::hour":["time::Padding","time::Time"],"time::Time::microsecond":["time::Padding","time::Time"],"time::Time::millisecond":["time::Padding","time::Time"],"time::Time::minute":["time::Padding","time::Time"],"time::Time::nanosecond":["time::Padding","time::Time"],"time::Time::second":["time::Padding","time::Time"],"utc_offset::UtcOffset":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::__from_hms_unchecked":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::as_hms":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::from_hms":["std::marker::Sized","std::result::Result"],"utc_offset::UtcOffset::from_whole_seconds":["std::marker::Sized","std::result::Result"],"utc_offset::UtcOffset::is_negative":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::is_positive":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::is_utc":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::minutes_past_hour":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::seconds_past_minute":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::whole_hours":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::whole_minutes":["utc_offset::UtcOffset"],"utc_offset::UtcOffset::whole_seconds":["utc_offset::UtcOffset"],"util::DateAdjustment":["util::DateAdjustment"],"util::days_in_year":[],"util::days_in_year_month":["month::Month"],"util::is_leap_year":[],"util::weeks_in_year":[],"weekday::Weekday":["weekday::Weekday"],"weekday::Weekday::next":["weekday::Weekday"],"weekday::Weekday::number_days_from_monday":["weekday::Weekday"],"weekday::Weekday::number_days_from_sunday":["weekday::Weekday"],"weekday::Weekday::number_from_monday":["weekday::Weekday"],"weekday::Weekday::number_from_sunday":["weekday::Weekday"],"weekday::Weekday::previous":["weekday::Weekday"]},"glob_path_import":{},"self_to_fn":{"date::Date":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl Add<Duration> for Date {\n    type Output = Self;\n\n    fn add(self, duration: Duration) -> Self::Output {\n        self.checked_add(duration)\n            .expect(\"overflow adding duration to date\")\n    }\n}","impl Add<StdDuration> for Date {\n    type Output = Self;\n\n    fn add(self, duration: StdDuration) -> Self::Output {\n        Self::from_julian_day(self.to_julian_day() + (duration.as_secs() / 86_400) as i32)\n            .expect(\"overflow adding duration to date\")\n    }\n}","impl Date {\n    /// Create a [`PrimitiveDateTime`] using the existing date. The [`Time`] component will be set\n    /// to midnight.\n    ///\n    /// ```rust\n    /// # use time::macros::{date, datetime};\n    /// assert_eq!(date!(1970-01-01).midnight(), datetime!(1970-01-01 0:00));\n    /// ```\n    pub const fn midnight(self) -> PrimitiveDateTime {\n        PrimitiveDateTime::new(self, Time::MIDNIGHT)\n    }\n\n    /// Create a [`PrimitiveDateTime`] using the existing date and the provided [`Time`].\n    ///\n    /// ```rust\n    /// # use time::macros::{date, datetime, time};\n    /// assert_eq!(\n    ///     date!(1970-01-01).with_time(time!(0:00)),\n    ///     datetime!(1970-01-01 0:00),\n    /// );\n    /// ```\n    pub const fn with_time(self, time: Time) -> PrimitiveDateTime {\n        PrimitiveDateTime::new(self, time)\n    }\n\n    /// Attempt to create a [`PrimitiveDateTime`] using the existing date and the provided time.\n    ///\n    /// ```rust\n    /// # use time::macros::date;\n    /// assert!(date!(1970 - 01 - 01).with_hms(0, 0, 0).is_ok());\n    /// assert!(date!(1970 - 01 - 01).with_hms(24, 0, 0).is_err());\n    /// ```\n    pub const fn with_hms(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange> {\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::from_hms(hour, minute, second)),\n        ))\n    }\n\n    /// Attempt to create a [`PrimitiveDateTime`] using the existing date and the provided time.\n    ///\n    /// ```rust\n    /// # use time::macros::date;\n    /// assert!(date!(1970 - 01 - 01).with_hms_milli(0, 0, 0, 0).is_ok());\n    /// assert!(date!(1970 - 01 - 01).with_hms_milli(24, 0, 0, 0).is_err());\n    /// ```\n    pub const fn with_hms_milli(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        millisecond: u16,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange> {\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::from_hms_milli(hour, minute, second, millisecond)),\n        ))\n    }\n\n    /// Attempt to create a [`PrimitiveDateTime`] using the existing date and the provided time.\n    ///\n    /// ```rust\n    /// # use time::macros::date;\n    /// assert!(date!(1970 - 01 - 01).with_hms_micro(0, 0, 0, 0).is_ok());\n    /// assert!(date!(1970 - 01 - 01).with_hms_micro(24, 0, 0, 0).is_err());\n    /// ```\n    pub const fn with_hms_micro(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        microsecond: u32,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange> {\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::from_hms_micro(hour, minute, second, microsecond)),\n        ))\n    }\n\n    /// Attempt to create a [`PrimitiveDateTime`] using the existing date and the provided time.\n    ///\n    /// ```rust\n    /// # use time::macros::date;\n    /// assert!(date!(1970 - 01 - 01).with_hms_nano(0, 0, 0, 0).is_ok());\n    /// assert!(date!(1970 - 01 - 01).with_hms_nano(24, 0, 0, 0).is_err());\n    /// ```\n    pub const fn with_hms_nano(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange> {\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::from_hms_nano(hour, minute, second, nanosecond)),\n        ))\n    }\n}","impl Date {\n    /// The minimum valid `Date`.\n    ///\n    /// The value of this may vary depending on the feature flags enabled.\n    pub const MIN: Self = Self::__from_ordinal_date_unchecked(MIN_YEAR, 1);\n\n    /// The maximum valid `Date`.\n    ///\n    /// The value of this may vary depending on the feature flags enabled.\n    pub const MAX: Self = Self::__from_ordinal_date_unchecked(MAX_YEAR, days_in_year(MAX_YEAR));\n\n    // region: constructors\n    /// Construct a `Date` from the year and ordinal values, the validity of which must be\n    /// guaranteed by the caller.\n    #[doc(hidden)]\n    pub const fn __from_ordinal_date_unchecked(year: i32, ordinal: u16) -> Self {\n        Self {\n            value: (year << 9) | ordinal as i32,\n        }\n    }\n\n    /// Attempt to create a `Date` from the year, month, and day.\n    ///\n    /// ```rust\n    /// # use time::{Date, Month};\n    /// assert!(Date::from_calendar_date(2019, Month::January, 1).is_ok());\n    /// assert!(Date::from_calendar_date(2019, Month::December, 31).is_ok());\n    /// ```\n    ///\n    /// ```rust\n    /// # use time::{Date, Month};\n    /// assert!(Date::from_calendar_date(2019, Month::February, 29).is_err()); // 2019 isn't a leap year.\n    /// ```\n    pub const fn from_calendar_date(\n        year: i32,\n        month: Month,\n        day: u8,\n    ) -> Result<Self, error::ComponentRange> {\n        /// Cumulative days through the beginning of a month in both common and leap years.\n        const DAYS_CUMULATIVE_COMMON_LEAP: [[u16; 12]; 2] = [\n            [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n            [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n        ];\n\n        ensure_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        ensure_value_in_range!(day conditionally in 1 => days_in_year_month(year, month));\n\n        Ok(Self::__from_ordinal_date_unchecked(\n            year,\n            DAYS_CUMULATIVE_COMMON_LEAP[is_leap_year(year) as usize][month as usize - 1]\n                + day as u16,\n        ))\n    }\n\n    /// Attempt to create a `Date` from the year and ordinal day number.\n    ///\n    /// ```rust\n    /// # use time::Date;\n    /// assert!(Date::from_ordinal_date(2019, 1).is_ok());\n    /// assert!(Date::from_ordinal_date(2019, 365).is_ok());\n    /// ```\n    ///\n    /// ```rust\n    /// # use time::Date;\n    /// assert!(Date::from_ordinal_date(2019, 366).is_err()); // 2019 isn't a leap year.\n    /// ```\n    pub const fn from_ordinal_date(year: i32, ordinal: u16) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        ensure_value_in_range!(ordinal conditionally in 1 => days_in_year(year));\n        Ok(Self::__from_ordinal_date_unchecked(year, ordinal))\n    }\n\n    /// Attempt to create a `Date` from the ISO year, week, and weekday.\n    ///\n    /// ```rust\n    /// # use time::{Date, Weekday::*};\n    /// assert!(Date::from_iso_week_date(2019, 1, Monday).is_ok());\n    /// assert!(Date::from_iso_week_date(2019, 1, Tuesday).is_ok());\n    /// assert!(Date::from_iso_week_date(2020, 53, Friday).is_ok());\n    /// ```\n    ///\n    /// ```rust\n    /// # use time::{Date, Weekday::*};\n    /// assert!(Date::from_iso_week_date(2019, 53, Monday).is_err()); // 2019 doesn't have 53 weeks.\n    /// ```\n    pub const fn from_iso_week_date(\n        year: i32,\n        week: u8,\n        weekday: Weekday,\n    ) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        ensure_value_in_range!(week conditionally in 1 => weeks_in_year(year));\n\n        let adj_year = year - 1;\n        let raw = 365 * adj_year + div_floor!(adj_year, 4) - div_floor!(adj_year, 100)\n            + div_floor!(adj_year, 400);\n        let jan_4 = match (raw % 7) as i8 {\n            -6 | 1 => 8,\n            -5 | 2 => 9,\n            -4 | 3 => 10,\n            -3 | 4 => 4,\n            -2 | 5 => 5,\n            -1 | 6 => 6,\n            _ => 7,\n        };\n        let ordinal = week as i16 * 7 + weekday.number_from_monday() as i16 - jan_4;\n\n        Ok(if ordinal <= 0 {\n            Self::__from_ordinal_date_unchecked(\n                year - 1,\n                (ordinal as u16).wrapping_add(days_in_year(year - 1)),\n            )\n        } else if ordinal > days_in_year(year) as i16 {\n            Self::__from_ordinal_date_unchecked(year + 1, ordinal as u16 - days_in_year(year))\n        } else {\n            Self::__from_ordinal_date_unchecked(year, ordinal as _)\n        })\n    }\n\n    /// Create a `Date` from the Julian day.\n    ///\n    /// The algorithm to perform this conversion is derived from one provided by Peter Baum; it is\n    /// freely available [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).\n    ///\n    /// ```rust\n    /// # use time::{Date, macros::date};\n    /// assert_eq!(Date::from_julian_day(0), Ok(date!(-4713 - 11 - 24)));\n    /// assert_eq!(Date::from_julian_day(2_451_545), Ok(date!(2000 - 01 - 01)));\n    /// assert_eq!(Date::from_julian_day(2_458_485), Ok(date!(2019 - 01 - 01)));\n    /// assert_eq!(Date::from_julian_day(2_458_849), Ok(date!(2019 - 12 - 31)));\n    /// ```\n    #[doc(alias = \"from_julian_date\")]\n    pub const fn from_julian_day(julian_day: i32) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(\n            julian_day in Self::MIN.to_julian_day() => Self::MAX.to_julian_day()\n        );\n        Ok(Self::from_julian_day_unchecked(julian_day))\n    }\n\n    /// Create a `Date` from the Julian day.\n    ///\n    /// This does not check the validity of the provided Julian day, and as such may result in an\n    /// internally invalid value.\n    #[doc(alias = \"from_julian_date_unchecked\")]\n    pub(crate) const fn from_julian_day_unchecked(julian_day: i32) -> Self {\n        #![allow(trivial_numeric_casts)] // cast depends on type alias\n\n        /// A type that is either `i32` or `i64`. This subtle difference allows for optimization\n        /// based on the valid values.\n        #[cfg(feature = \"large-dates\")]\n        type MaybeWidened = i64;\n        #[allow(clippy::missing_docs_in_private_items)]\n        #[cfg(not(feature = \"large-dates\"))]\n        type MaybeWidened = i32;\n\n        // To avoid a potential overflow, the value may need to be widened for some arithmetic.\n\n        let z = julian_day - 1_721_119;\n        let g = 100 * z as MaybeWidened - 25;\n        let a = (g / 3_652_425) as i32;\n        let b = a - a / 4;\n        let mut year = div_floor!(100 * b as MaybeWidened + g, 36525) as i32;\n        let mut ordinal = (b + z - div_floor!(36525 * year as MaybeWidened, 100) as i32) as _;\n\n        if is_leap_year(year) {\n            ordinal += 60;\n            cascade!(ordinal in 1..367 => year);\n        } else {\n            ordinal += 59;\n            cascade!(ordinal in 1..366 => year);\n        }\n\n        Self::__from_ordinal_date_unchecked(year, ordinal)\n    }\n    // endregion constructors\n\n    // region: getters\n    /// Get the year of the date.\n    ///\n    /// ```rust\n    /// # use time::macros::date;\n    /// assert_eq!(date!(2019 - 01 - 01).year(), 2019);\n    /// assert_eq!(date!(2019 - 12 - 31).year(), 2019);\n    /// assert_eq!(date!(2020 - 01 - 01).year(), 2020);\n    /// ```\n    pub const fn year(self) -> i32 {\n        self.value >> 9\n    }\n\n    /// Get the month.\n    ///\n    /// ```rust\n    /// # use time::{macros::date, Month};\n    /// assert_eq!(date!(2019 - 01 - 01).month(), Month::January);\n    /// assert_eq!(date!(2019 - 12 - 31).month(), Month::December);\n    /// ```\n    pub const fn month(self) -> Month {\n        self.month_day().0\n    }\n\n    /// Get the day of the month.\n    ///\n    /// The returned value will always be in the range `1..=31`.\n    ///\n    /// ```rust\n    /// # use time::macros::date;\n    /// assert_eq!(date!(2019 - 01 - 01).day(), 1);\n    /// assert_eq!(date!(2019 - 12 - 31).day(), 31);\n    /// ```\n    pub const fn day(self) -> u8 {\n        self.month_day().1\n    }\n\n    /// Get the month and day. This is more efficient than fetching the components individually.\n    // For whatever reason, rustc has difficulty optimizing this function. It's significantly faster\n    // to write the statements out by hand.\n    pub(crate) const fn month_day(self) -> (Month, u8) {\n        /// The number of days up to and including the given month. Common years\n        /// are first, followed by leap years.\n        const CUMULATIVE_DAYS_IN_MONTH_COMMON_LEAP: [[u16; 11]; 2] = [\n            [31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n            [31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n        ];\n\n        let days = CUMULATIVE_DAYS_IN_MONTH_COMMON_LEAP[is_leap_year(self.year()) as usize];\n        let ordinal = self.ordinal();\n\n        if ordinal > days[10] {\n            (Month::December, (ordinal - days[10]) as _)\n        } else if ordinal > days[9] {\n            (Month::November, (ordinal - days[9]) as _)\n        } else if ordinal > days[8] {\n            (Month::October, (ordinal - days[8]) as _)\n        } else if ordinal > days[7] {\n            (Month::September, (ordinal - days[7]) as _)\n        } else if ordinal > days[6] {\n            (Month::August, (ordinal - days[6]) as _)\n        } else if ordinal > days[5] {\n            (Month::July, (ordinal - days[5]) as _)\n        } else if ordinal > days[4] {\n            (Month::June, (ordinal - days[4]) as _)\n        } else if ordinal > days[3] {\n            (Month::May, (ordinal - days[3]) as _)\n        } else if ordinal > days[2] {\n            (Month::April, (ordinal - days[2]) as _)\n        } else if ordinal > days[1] {\n            (Month::March, (ordinal - days[1]) as _)\n        } else if ordinal > days[0] {\n            (Month::February, (ordinal - days[0]) as _)\n        } else {\n            (Month::January, ordinal as _)\n        }\n    }\n\n    /// Get the day of the year.\n    ///\n    /// The returned value will always be in the range `1..=366` (`1..=365` for common years).\n    ///\n    /// ```rust\n    /// # use time::macros::date;\n    /// assert_eq!(date!(2019 - 01 - 01).ordinal(), 1);\n    /// assert_eq!(date!(2019 - 12 - 31).ordinal(), 365);\n    /// ```\n    pub const fn ordinal(self) -> u16 {\n        (self.value & 0x1FF) as _\n    }\n\n    /// Get the ISO 8601 year and week number.\n    pub(crate) const fn iso_year_week(self) -> (i32, u8) {\n        let (year, ordinal) = self.to_ordinal_date();\n\n        match ((ordinal + 10 - self.weekday().number_from_monday() as u16) / 7) as _ {\n            0 => (year - 1, weeks_in_year(year - 1)),\n            53 if weeks_in_year(year) == 52 => (year + 1, 1),\n            week => (year, week),\n        }\n    }\n\n    /// Get the ISO week number.\n    ///\n    /// The returned value will always be in the range `1..=53`.\n    ///\n    /// ```rust\n    /// # use time::macros::date;\n    /// assert_eq!(date!(2019 - 01 - 01).iso_week(), 1);\n    /// assert_eq!(date!(2019 - 10 - 04).iso_week(), 40);\n    /// assert_eq!(date!(2020 - 01 - 01).iso_week(), 1);\n    /// assert_eq!(date!(2020 - 12 - 31).iso_week(), 53);\n    /// assert_eq!(date!(2021 - 01 - 01).iso_week(), 53);\n    /// ```\n    pub const fn iso_week(self) -> u8 {\n        self.iso_year_week().1\n    }\n\n    /// Get the week number where week 1 begins on the first Sunday.\n    ///\n    /// The returned value will always be in the range `0..=53`.\n    ///\n    /// ```rust\n    /// # use time::macros::date;\n    /// assert_eq!(date!(2019 - 01 - 01).sunday_based_week(), 0);\n    /// assert_eq!(date!(2020 - 01 - 01).sunday_based_week(), 0);\n    /// assert_eq!(date!(2020 - 12 - 31).sunday_based_week(), 52);\n    /// assert_eq!(date!(2021 - 01 - 01).sunday_based_week(), 0);\n    /// ```\n    pub const fn sunday_based_week(self) -> u8 {\n        ((self.ordinal() as i16 - self.weekday().number_days_from_sunday() as i16 + 6) / 7) as _\n    }\n\n    /// Get the week number where week 1 begins on the first Monday.\n    ///\n    /// The returned value will always be in the range `0..=53`.\n    ///\n    /// ```rust\n    /// # use time::macros::date;\n    /// assert_eq!(date!(2019 - 01 - 01).monday_based_week(), 0);\n    /// assert_eq!(date!(2020 - 01 - 01).monday_based_week(), 0);\n    /// assert_eq!(date!(2020 - 12 - 31).monday_based_week(), 52);\n    /// assert_eq!(date!(2021 - 01 - 01).monday_based_week(), 0);\n    /// ```\n    pub const fn monday_based_week(self) -> u8 {\n        ((self.ordinal() as i16 - self.weekday().number_days_from_monday() as i16 + 6) / 7) as _\n    }\n\n    /// Get the year, month, and day.\n    ///\n    /// ```rust\n    /// # use time::{macros::date, Month};\n    /// assert_eq!(\n    ///     date!(2019 - 01 - 01).to_calendar_date(),\n    ///     (2019, Month::January, 1)\n    /// );\n    /// ```\n    pub const fn to_calendar_date(self) -> (i32, Month, u8) {\n        let (month, day) = self.month_day();\n        (self.year(), month, day)\n    }\n\n    /// Get the year and ordinal day number.\n    ///\n    /// ```rust\n    /// # use time::macros::date;\n    /// assert_eq!(date!(2019 - 01 - 01).to_ordinal_date(), (2019, 1));\n    /// ```\n    pub const fn to_ordinal_date(self) -> (i32, u16) {\n        (self.year(), self.ordinal())\n    }\n\n    /// Get the ISO 8601 year, week number, and weekday.\n    ///\n    /// ```rust\n    /// # use time::{Weekday::*, macros::date};\n    /// assert_eq!(date!(2019 - 01 - 01).to_iso_week_date(), (2019, 1, Tuesday));\n    /// assert_eq!(date!(2019 - 10 - 04).to_iso_week_date(), (2019, 40, Friday));\n    /// assert_eq!(\n    ///     date!(2020 - 01 - 01).to_iso_week_date(),\n    ///     (2020, 1, Wednesday)\n    /// );\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).to_iso_week_date(),\n    ///     (2020, 53, Thursday)\n    /// );\n    /// assert_eq!(date!(2021 - 01 - 01).to_iso_week_date(), (2020, 53, Friday));\n    /// ```\n    pub const fn to_iso_week_date(self) -> (i32, u8, Weekday) {\n        let (year, ordinal) = self.to_ordinal_date();\n        let weekday = self.weekday();\n\n        match ((ordinal + 10 - self.weekday().number_from_monday() as u16) / 7) as _ {\n            0 => (year - 1, weeks_in_year(year - 1), weekday),\n            53 if weeks_in_year(year) == 52 => (year + 1, 1, weekday),\n            week => (year, week, weekday),\n        }\n    }\n\n    /// Get the weekday.\n    ///\n    /// ```rust\n    /// # use time::{Weekday::*, macros::date};\n    /// assert_eq!(date!(2019 - 01 - 01).weekday(), Tuesday);\n    /// assert_eq!(date!(2019 - 02 - 01).weekday(), Friday);\n    /// assert_eq!(date!(2019 - 03 - 01).weekday(), Friday);\n    /// assert_eq!(date!(2019 - 04 - 01).weekday(), Monday);\n    /// assert_eq!(date!(2019 - 05 - 01).weekday(), Wednesday);\n    /// assert_eq!(date!(2019 - 06 - 01).weekday(), Saturday);\n    /// assert_eq!(date!(2019 - 07 - 01).weekday(), Monday);\n    /// assert_eq!(date!(2019 - 08 - 01).weekday(), Thursday);\n    /// assert_eq!(date!(2019 - 09 - 01).weekday(), Sunday);\n    /// assert_eq!(date!(2019 - 10 - 01).weekday(), Tuesday);\n    /// assert_eq!(date!(2019 - 11 - 01).weekday(), Friday);\n    /// assert_eq!(date!(2019 - 12 - 01).weekday(), Sunday);\n    /// ```\n    pub const fn weekday(self) -> Weekday {\n        match self.to_julian_day() % 7 {\n            -6 | 1 => Weekday::Tuesday,\n            -5 | 2 => Weekday::Wednesday,\n            -4 | 3 => Weekday::Thursday,\n            -3 | 4 => Weekday::Friday,\n            -2 | 5 => Weekday::Saturday,\n            -1 | 6 => Weekday::Sunday,\n            _ => Weekday::Monday,\n        }\n    }\n\n    /// Get the next calendar date.\n    ///\n    /// ```rust\n    /// # use time::{Date, macros::date};\n    /// assert_eq!(\n    ///     date!(2019 - 01 - 01).next_day(),\n    ///     Some(date!(2019 - 01 - 02))\n    /// );\n    /// assert_eq!(\n    ///     date!(2019 - 01 - 31).next_day(),\n    ///     Some(date!(2019 - 02 - 01))\n    /// );\n    /// assert_eq!(\n    ///     date!(2019 - 12 - 31).next_day(),\n    ///     Some(date!(2020 - 01 - 01))\n    /// );\n    /// assert_eq!(Date::MAX.next_day(), None);\n    /// ```\n    pub const fn next_day(self) -> Option<Self> {\n        if self.ordinal() == 366 || (self.ordinal() == 365 && !is_leap_year(self.year())) {\n            if self.value == Self::MAX.value {\n                None\n            } else {\n                Some(Self::__from_ordinal_date_unchecked(self.year() + 1, 1))\n            }\n        } else {\n            Some(Self {\n                value: self.value + 1,\n            })\n        }\n    }\n\n    /// Get the previous calendar date.\n    ///\n    /// ```rust\n    /// # use time::{Date, macros::date};\n    /// assert_eq!(\n    ///     date!(2019 - 01 - 02).previous_day(),\n    ///     Some(date!(2019 - 01 - 01))\n    /// );\n    /// assert_eq!(\n    ///     date!(2019 - 02 - 01).previous_day(),\n    ///     Some(date!(2019 - 01 - 31))\n    /// );\n    /// assert_eq!(\n    ///     date!(2020 - 01 - 01).previous_day(),\n    ///     Some(date!(2019 - 12 - 31))\n    /// );\n    /// assert_eq!(Date::MIN.previous_day(), None);\n    /// ```\n    pub const fn previous_day(self) -> Option<Self> {\n        if self.ordinal() != 1 {\n            Some(Self {\n                value: self.value - 1,\n            })\n        } else if self.value == Self::MIN.value {\n            None\n        } else {\n            Some(Self::__from_ordinal_date_unchecked(\n                self.year() - 1,\n                days_in_year(self.year() - 1),\n            ))\n        }\n    }\n\n    /// Get the Julian day for the date.\n    ///\n    /// The algorithm to perform this conversion is derived from one provided by Peter Baum; it is\n    /// freely available [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).\n    ///\n    /// ```rust\n    /// # use time::macros::date;\n    /// assert_eq!(date!(-4713 - 11 - 24).to_julian_day(), 0);\n    /// assert_eq!(date!(2000 - 01 - 01).to_julian_day(), 2_451_545);\n    /// assert_eq!(date!(2019 - 01 - 01).to_julian_day(), 2_458_485);\n    /// assert_eq!(date!(2019 - 12 - 31).to_julian_day(), 2_458_849);\n    /// ```\n    pub const fn to_julian_day(self) -> i32 {\n        let year = self.year() - 1;\n        let ordinal = self.ordinal() as i32;\n\n        ordinal + 365 * year + div_floor!(year, 4) - div_floor!(year, 100)\n            + div_floor!(year, 400)\n            + 1_721_425\n    }\n    // endregion getters\n\n    // region: checked arithmetic\n    /// Computes `self + duration`, returning `None` if an overflow occurred.\n    ///\n    /// ```rust\n    /// # use time::{Date, ext::NumericalDuration, macros::date};\n    /// assert_eq!(Date::MAX.checked_add(1.days()), None);\n    /// assert_eq!(Date::MIN.checked_add((-2).days()), None);\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).checked_add(2.days()),\n    ///     Some(date!(2021 - 01 - 02))\n    /// );\n    /// ```\n    ///\n    /// # Note\n    ///\n    /// This function only takes whole days into account.\n    ///\n    /// ```rust\n    /// # use time::{Date, ext::NumericalDuration, macros::date};\n    /// assert_eq!(Date::MAX.checked_add(23.hours()), Some(Date::MAX));\n    /// assert_eq!(Date::MIN.checked_add((-23).hours()), Some(Date::MIN));\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).checked_add(23.hours()),\n    ///     Some(date!(2020 - 12 - 31))\n    /// );\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).checked_add(47.hours()),\n    ///     Some(date!(2021 - 01 - 01))\n    /// );\n    /// ```\n    pub const fn checked_add(self, duration: Duration) -> Option<Self> {\n        let whole_days = duration.whole_days();\n        if whole_days < i32::MIN as i64 || whole_days > i32::MAX as i64 {\n            return None;\n        }\n\n        let julian_day = const_try_opt!(self.to_julian_day().checked_add(whole_days as _));\n        if let Ok(date) = Self::from_julian_day(julian_day) {\n            Some(date)\n        } else {\n            None\n        }\n    }\n\n    /// Computes `self - duration`, returning `None` if an overflow occurred.\n    ///\n    /// ```\n    /// # use time::{Date, ext::NumericalDuration, macros::date};\n    /// assert_eq!(Date::MAX.checked_sub((-2).days()), None);\n    /// assert_eq!(Date::MIN.checked_sub(1.days()), None);\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).checked_sub(2.days()),\n    ///     Some(date!(2020 - 12 - 29))\n    /// );\n    /// ```\n    ///\n    /// # Note\n    ///\n    /// This function only takes whole days into account.\n    ///\n    /// ```\n    /// # use time::{Date, ext::NumericalDuration, macros::date};\n    /// assert_eq!(Date::MAX.checked_sub((-23).hours()), Some(Date::MAX));\n    /// assert_eq!(Date::MIN.checked_sub(23.hours()), Some(Date::MIN));\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).checked_sub(23.hours()),\n    ///     Some(date!(2020 - 12 - 31))\n    /// );\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).checked_sub(47.hours()),\n    ///     Some(date!(2020 - 12 - 30))\n    /// );\n    /// ```\n    pub const fn checked_sub(self, duration: Duration) -> Option<Self> {\n        let whole_days = duration.whole_days();\n        if whole_days < i32::MIN as i64 || whole_days > i32::MAX as i64 {\n            return None;\n        }\n\n        let julian_day = const_try_opt!(self.to_julian_day().checked_sub(whole_days as _));\n        if let Ok(date) = Self::from_julian_day(julian_day) {\n            Some(date)\n        } else {\n            None\n        }\n    }\n    // endregion: checked arithmetic\n\n    // region: saturating arithmetic\n    /// Computes `self + duration`, saturating value on overflow.\n    ///\n    /// ```rust\n    /// # use time::{Date, ext::NumericalDuration, macros::date};\n    /// assert_eq!(Date::MAX.saturating_add(1.days()), Date::MAX);\n    /// assert_eq!(Date::MIN.saturating_add((-2).days()), Date::MIN);\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).saturating_add(2.days()),\n    ///     date!(2021 - 01 - 02)\n    /// );\n    /// ```\n    ///\n    /// # Note\n    ///\n    /// This function only takes whole days into account.\n    ///\n    /// ```rust\n    /// # use time::{ext::NumericalDuration, macros::date};\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).saturating_add(23.hours()),\n    ///     date!(2020 - 12 - 31)\n    /// );\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).saturating_add(47.hours()),\n    ///     date!(2021 - 01 - 01)\n    /// );\n    /// ```\n    pub const fn saturating_add(self, duration: Duration) -> Self {\n        if let Some(datetime) = self.checked_add(duration) {\n            datetime\n        } else if duration.is_negative() {\n            Self::MIN\n        } else {\n            Self::MAX\n        }\n    }\n\n    /// Computes `self - duration`, saturating value on overflow.\n    ///\n    /// ```\n    /// # use time::{Date, ext::NumericalDuration, macros::date};\n    /// assert_eq!(Date::MAX.saturating_sub((-2).days()), Date::MAX);\n    /// assert_eq!(Date::MIN.saturating_sub(1.days()), Date::MIN);\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).saturating_sub(2.days()),\n    ///     date!(2020 - 12 - 29)\n    /// );\n    /// ```\n    ///\n    /// # Note\n    ///\n    /// This function only takes whole days into account.\n    ///\n    /// ```\n    /// # use time::{ext::NumericalDuration, macros::date};\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).saturating_sub(23.hours()),\n    ///     date!(2020 - 12 - 31)\n    /// );\n    /// assert_eq!(\n    ///     date!(2020 - 12 - 31).saturating_sub(47.hours()),\n    ///     date!(2020 - 12 - 30)\n    /// );\n    /// ```\n    pub const fn saturating_sub(self, duration: Duration) -> Self {\n        if let Some(datetime) = self.checked_sub(duration) {\n            datetime\n        } else if duration.is_negative() {\n            Self::MAX\n        } else {\n            Self::MIN\n        }\n    }\n    // region: saturating arithmetic\n}","impl Sub for Date {\n    type Output = Duration;\n\n    fn sub(self, other: Self) -> Self::Output {\n        Duration::days((self.to_julian_day() - other.to_julian_day()) as _)\n    }\n}","impl Sub<Duration> for Date {\n    type Output = Self;\n\n    fn sub(self, duration: Duration) -> Self::Output {\n        self.checked_sub(duration)\n            .expect(\"overflow subtracting duration from date\")\n    }\n}","impl Sub<StdDuration> for Date {\n    type Output = Self;\n\n    fn sub(self, duration: StdDuration) -> Self::Output {\n        Self::from_julian_day(self.to_julian_day() - (duration.as_secs() / 86_400) as i32)\n            .expect(\"overflow subtracting duration from date\")\n    }\n}","impl core::ops::$op<$t> for $target {\n            fn $fn(&mut self, rhs: $t) {\n                *self = *self $sym rhs;\n            }\n        }","impl fmt::Debug for Date {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        f.debug_struct(\"Date\")\n            .field(\"year\", &self.year())\n            .field(\"ordinal\", &self.ordinal())\n            .finish()\n    }\n}","impl fmt::Display for Date {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if cfg!(feature = \"large-dates\") && self.year().abs() >= 10_000 {\n            write!(\n                f,\n                \"{:+}-{:02}-{:02}\",\n                self.year(),\n                self.month() as u8,\n                self.day()\n            )\n        } else {\n            write!(\n                f,\n                \"{:0width$}-{:02}-{:02}\",\n                self.year(),\n                self.month() as u8,\n                self.day(),\n                width = 4 + (self.year() < 0) as usize\n            )\n        }\n    }\n}"],"duration::Duration":["Clone","Copy","Default","Eq","Hash","Ord","PartialEq","PartialOrd","impl Add for Duration {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self::Output {\n        self.checked_add(rhs)\n            .expect(\"overflow when adding durations\")\n    }\n}","impl Add<StdDuration> for Duration {\n    type Output = Self;\n\n    fn add(self, std_duration: StdDuration) -> Self::Output {\n        self + Self::try_from(std_duration)\n            .expect(\"overflow converting `std::time::Duration` to `time::Duration`\")\n    }\n}","impl Div for Duration {\n    type Output = f64;\n\n    fn div(self, rhs: Self) -> Self::Output {\n        self.as_seconds_f64() / rhs.as_seconds_f64()\n    }\n}","impl Div<$type> for Duration {\n            type Output = Self;\n\n            fn div(self, rhs: $type) -> Self::Output {\n                Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n            }\n        }","impl Div<StdDuration> for Duration {\n    type Output = f64;\n\n    fn div(self, rhs: StdDuration) -> Self::Output {\n        self.as_seconds_f64() / rhs.as_secs_f64()\n    }\n}","impl Div<f32> for Duration {\n    type Output = Self;\n\n    fn div(self, rhs: f32) -> Self::Output {\n        Self::seconds_f32(self.as_seconds_f32() / rhs)\n    }\n}","impl Div<f64> for Duration {\n    type Output = Self;\n\n    fn div(self, rhs: f64) -> Self::Output {\n        Self::seconds_f64(self.as_seconds_f64() / rhs)\n    }\n}","impl Duration {\n    // region: constants\n    /// Equivalent to `0.seconds()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::ZERO, 0.seconds());\n    /// ```\n    pub const ZERO: Self = Self::seconds(0);\n\n    /// Equivalent to `1.nanoseconds()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::NANOSECOND, 1.nanoseconds());\n    /// ```\n    pub const NANOSECOND: Self = Self::nanoseconds(1);\n\n    /// Equivalent to `1.microseconds()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::MICROSECOND, 1.microseconds());\n    /// ```\n    pub const MICROSECOND: Self = Self::microseconds(1);\n\n    /// Equivalent to `1.milliseconds()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::MILLISECOND, 1.milliseconds());\n    /// ```\n    pub const MILLISECOND: Self = Self::milliseconds(1);\n\n    /// Equivalent to `1.seconds()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::SECOND, 1.seconds());\n    /// ```\n    pub const SECOND: Self = Self::seconds(1);\n\n    /// Equivalent to `1.minutes()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::MINUTE, 1.minutes());\n    /// ```\n    pub const MINUTE: Self = Self::minutes(1);\n\n    /// Equivalent to `1.hours()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::HOUR, 1.hours());\n    /// ```\n    pub const HOUR: Self = Self::hours(1);\n\n    /// Equivalent to `1.days()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::DAY, 1.days());\n    /// ```\n    pub const DAY: Self = Self::days(1);\n\n    /// Equivalent to `1.weeks()`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::WEEK, 1.weeks());\n    /// ```\n    pub const WEEK: Self = Self::weeks(1);\n\n    /// The minimum possible duration. Adding any negative duration to this will cause an overflow.\n    pub const MIN: Self = Self::new_unchecked(i64::MIN, -999_999_999);\n\n    /// The maximum possible duration. Adding any positive duration to this will cause an overflow.\n    pub const MAX: Self = Self::new_unchecked(i64::MAX, 999_999_999);\n    // endregion constants\n\n    // region: is_{sign}\n    /// Check if a duration is exactly zero.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert!(0.seconds().is_zero());\n    /// assert!(!1.nanoseconds().is_zero());\n    /// ```\n    pub const fn is_zero(self) -> bool {\n        self.seconds == 0 && self.nanoseconds == 0\n    }\n\n    /// Check if a duration is negative.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert!((-1).seconds().is_negative());\n    /// assert!(!0.seconds().is_negative());\n    /// assert!(!1.seconds().is_negative());\n    /// ```\n    pub const fn is_negative(self) -> bool {\n        self.seconds < 0 || self.nanoseconds < 0\n    }\n\n    /// Check if a duration is positive.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert!(1.seconds().is_positive());\n    /// assert!(!0.seconds().is_positive());\n    /// assert!(!(-1).seconds().is_positive());\n    /// ```\n    pub const fn is_positive(self) -> bool {\n        self.seconds > 0 || self.nanoseconds > 0\n    }\n    // endregion is_{sign}\n\n    // region: abs\n    /// Get the absolute value of the duration.\n    ///\n    /// This method saturates the returned value if it would otherwise overflow.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.seconds().abs(), 1.seconds());\n    /// assert_eq!(0.seconds().abs(), 0.seconds());\n    /// assert_eq!((-1).seconds().abs(), 1.seconds());\n    /// ```\n    pub const fn abs(self) -> Self {\n        Self::new_unchecked(self.seconds.saturating_abs(), self.nanoseconds.abs())\n    }\n\n    /// Convert the existing `Duration` to a `std::time::Duration` and its sign. This doesn't\n    /// actually require the standard library, but is currently only used when it's enabled.\n    #[allow(clippy::missing_const_for_fn)] // false positive\n    #[cfg(feature = \"std\")]\n    pub(crate) fn abs_std(self) -> StdDuration {\n        StdDuration::new(self.seconds.unsigned_abs(), self.nanoseconds.unsigned_abs())\n    }\n    // endregion abs\n\n    // region: constructors\n    /// Create a new `Duration` without checking the validity of the components.\n    pub(crate) const fn new_unchecked(seconds: i64, nanoseconds: i32) -> Self {\n        Self {\n            seconds,\n            nanoseconds,\n            padding: Padding::Optimize,\n        }\n    }\n\n    /// Create a new `Duration` with the provided seconds and nanoseconds. If nanoseconds is at\n    /// least ±10<sup>9</sup>, it will wrap to the number of seconds.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::new(1, 0), 1.seconds());\n    /// assert_eq!(Duration::new(-1, 0), (-1).seconds());\n    /// assert_eq!(Duration::new(1, 2_000_000_000), 3.seconds());\n    /// ```\n    pub const fn new(mut seconds: i64, mut nanoseconds: i32) -> Self {\n        seconds += nanoseconds as i64 / 1_000_000_000;\n        nanoseconds %= 1_000_000_000;\n\n        if seconds > 0 && nanoseconds < 0 {\n            seconds -= 1;\n            nanoseconds += 1_000_000_000;\n        } else if seconds < 0 && nanoseconds > 0 {\n            seconds += 1;\n            nanoseconds -= 1_000_000_000;\n        }\n\n        Self::new_unchecked(seconds, nanoseconds)\n    }\n\n    /// Create a new `Duration` with the given number of weeks. Equivalent to\n    /// `Duration::seconds(weeks * 604_800)`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::weeks(1), 604_800.seconds());\n    /// ```\n    pub const fn weeks(weeks: i64) -> Self {\n        Self::seconds(weeks * 604_800)\n    }\n\n    /// Create a new `Duration` with the given number of days. Equivalent to\n    /// `Duration::seconds(days * 86_400)`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::days(1), 86_400.seconds());\n    /// ```\n    pub const fn days(days: i64) -> Self {\n        Self::seconds(days * 86_400)\n    }\n\n    /// Create a new `Duration` with the given number of hours. Equivalent to\n    /// `Duration::seconds(hours * 3_600)`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::hours(1), 3_600.seconds());\n    /// ```\n    pub const fn hours(hours: i64) -> Self {\n        Self::seconds(hours * 3_600)\n    }\n\n    /// Create a new `Duration` with the given number of minutes. Equivalent to\n    /// `Duration::seconds(minutes * 60)`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::minutes(1), 60.seconds());\n    /// ```\n    pub const fn minutes(minutes: i64) -> Self {\n        Self::seconds(minutes * 60)\n    }\n\n    /// Create a new `Duration` with the given number of seconds.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::seconds(1), 1_000.milliseconds());\n    /// ```\n    pub const fn seconds(seconds: i64) -> Self {\n        Self::new_unchecked(seconds, 0)\n    }\n\n    /// Creates a new `Duration` from the specified number of seconds represented as `f64`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::seconds_f64(0.5), 0.5.seconds());\n    /// assert_eq!(Duration::seconds_f64(-0.5), -0.5.seconds());\n    /// ```\n    pub fn seconds_f64(seconds: f64) -> Self {\n        Self::new_unchecked(seconds as _, ((seconds % 1.) * 1_000_000_000.) as _)\n    }\n\n    /// Creates a new `Duration` from the specified number of seconds represented as `f32`.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::seconds_f32(0.5), 0.5.seconds());\n    /// assert_eq!(Duration::seconds_f32(-0.5), (-0.5).seconds());\n    /// ```\n    pub fn seconds_f32(seconds: f32) -> Self {\n        Self::new_unchecked(seconds as _, ((seconds % 1.) * 1_000_000_000.) as _)\n    }\n\n    /// Create a new `Duration` with the given number of milliseconds.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::milliseconds(1), 1_000.microseconds());\n    /// assert_eq!(Duration::milliseconds(-1), (-1_000).microseconds());\n    /// ```\n    pub const fn milliseconds(milliseconds: i64) -> Self {\n        Self::new_unchecked(\n            milliseconds / 1_000,\n            ((milliseconds % 1_000) * 1_000_000) as _,\n        )\n    }\n\n    /// Create a new `Duration` with the given number of microseconds.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::microseconds(1), 1_000.nanoseconds());\n    /// assert_eq!(Duration::microseconds(-1), (-1_000).nanoseconds());\n    /// ```\n    pub const fn microseconds(microseconds: i64) -> Self {\n        Self::new_unchecked(\n            microseconds / 1_000_000,\n            ((microseconds % 1_000_000) * 1_000) as _,\n        )\n    }\n\n    /// Create a new `Duration` with the given number of nanoseconds.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(Duration::nanoseconds(1), 1.microseconds() / 1_000);\n    /// assert_eq!(Duration::nanoseconds(-1), (-1).microseconds() / 1_000);\n    /// ```\n    pub const fn nanoseconds(nanoseconds: i64) -> Self {\n        Self::new_unchecked(\n            nanoseconds / 1_000_000_000,\n            (nanoseconds % 1_000_000_000) as _,\n        )\n    }\n\n    /// Create a new `Duration` with the given number of nanoseconds.\n    ///\n    /// As the input range cannot be fully mapped to the output, this should only be used where it's\n    /// known to result in a valid value.\n    pub(crate) const fn nanoseconds_i128(nanoseconds: i128) -> Self {\n        Self::new_unchecked(\n            (nanoseconds / 1_000_000_000) as _,\n            (nanoseconds % 1_000_000_000) as _,\n        )\n    }\n    // endregion constructors\n\n    // region: getters\n    /// Get the number of whole weeks in the duration.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.weeks().whole_weeks(), 1);\n    /// assert_eq!((-1).weeks().whole_weeks(), -1);\n    /// assert_eq!(6.days().whole_weeks(), 0);\n    /// assert_eq!((-6).days().whole_weeks(), 0);\n    /// ```\n    pub const fn whole_weeks(self) -> i64 {\n        self.whole_seconds() / 604_800\n    }\n\n    /// Get the number of whole days in the duration.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.days().whole_days(), 1);\n    /// assert_eq!((-1).days().whole_days(), -1);\n    /// assert_eq!(23.hours().whole_days(), 0);\n    /// assert_eq!((-23).hours().whole_days(), 0);\n    /// ```\n    pub const fn whole_days(self) -> i64 {\n        self.whole_seconds() / 86_400\n    }\n\n    /// Get the number of whole hours in the duration.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.hours().whole_hours(), 1);\n    /// assert_eq!((-1).hours().whole_hours(), -1);\n    /// assert_eq!(59.minutes().whole_hours(), 0);\n    /// assert_eq!((-59).minutes().whole_hours(), 0);\n    /// ```\n    pub const fn whole_hours(self) -> i64 {\n        self.whole_seconds() / 3_600\n    }\n\n    /// Get the number of whole minutes in the duration.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.minutes().whole_minutes(), 1);\n    /// assert_eq!((-1).minutes().whole_minutes(), -1);\n    /// assert_eq!(59.seconds().whole_minutes(), 0);\n    /// assert_eq!((-59).seconds().whole_minutes(), 0);\n    /// ```\n    pub const fn whole_minutes(self) -> i64 {\n        self.whole_seconds() / 60\n    }\n\n    /// Get the number of whole seconds in the duration.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.seconds().whole_seconds(), 1);\n    /// assert_eq!((-1).seconds().whole_seconds(), -1);\n    /// assert_eq!(1.minutes().whole_seconds(), 60);\n    /// assert_eq!((-1).minutes().whole_seconds(), -60);\n    /// ```\n    pub const fn whole_seconds(self) -> i64 {\n        self.seconds\n    }\n\n    /// Get the number of fractional seconds in the duration.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.5.seconds().as_seconds_f64(), 1.5);\n    /// assert_eq!((-1.5).seconds().as_seconds_f64(), -1.5);\n    /// ```\n    pub fn as_seconds_f64(self) -> f64 {\n        self.seconds as f64 + self.nanoseconds as f64 / 1_000_000_000.\n    }\n\n    /// Get the number of fractional seconds in the duration.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.5.seconds().as_seconds_f32(), 1.5);\n    /// assert_eq!((-1.5).seconds().as_seconds_f32(), -1.5);\n    /// ```\n    pub fn as_seconds_f32(self) -> f32 {\n        self.seconds as f32 + self.nanoseconds as f32 / 1_000_000_000.\n    }\n\n    /// Get the number of whole milliseconds in the duration.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.seconds().whole_milliseconds(), 1_000);\n    /// assert_eq!((-1).seconds().whole_milliseconds(), -1_000);\n    /// assert_eq!(1.milliseconds().whole_milliseconds(), 1);\n    /// assert_eq!((-1).milliseconds().whole_milliseconds(), -1);\n    /// ```\n    pub const fn whole_milliseconds(self) -> i128 {\n        self.seconds as i128 * 1_000 + self.nanoseconds as i128 / 1_000_000\n    }\n\n    /// Get the number of milliseconds past the number of whole seconds.\n    ///\n    /// Always in the range `-1_000..1_000`.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.4.seconds().subsec_milliseconds(), 400);\n    /// assert_eq!((-1.4).seconds().subsec_milliseconds(), -400);\n    /// ```\n    // Allow the lint, as the value is guaranteed to be less than 1000.\n    pub const fn subsec_milliseconds(self) -> i16 {\n        (self.nanoseconds / 1_000_000) as _\n    }\n\n    /// Get the number of whole microseconds in the duration.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.milliseconds().whole_microseconds(), 1_000);\n    /// assert_eq!((-1).milliseconds().whole_microseconds(), -1_000);\n    /// assert_eq!(1.microseconds().whole_microseconds(), 1);\n    /// assert_eq!((-1).microseconds().whole_microseconds(), -1);\n    /// ```\n    pub const fn whole_microseconds(self) -> i128 {\n        self.seconds as i128 * 1_000_000 + self.nanoseconds as i128 / 1_000\n    }\n\n    /// Get the number of microseconds past the number of whole seconds.\n    ///\n    /// Always in the range `-1_000_000..1_000_000`.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.0004.seconds().subsec_microseconds(), 400);\n    /// assert_eq!((-1.0004).seconds().subsec_microseconds(), -400);\n    /// ```\n    pub const fn subsec_microseconds(self) -> i32 {\n        self.nanoseconds / 1_000\n    }\n\n    /// Get the number of nanoseconds in the duration.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.microseconds().whole_nanoseconds(), 1_000);\n    /// assert_eq!((-1).microseconds().whole_nanoseconds(), -1_000);\n    /// assert_eq!(1.nanoseconds().whole_nanoseconds(), 1);\n    /// assert_eq!((-1).nanoseconds().whole_nanoseconds(), -1);\n    /// ```\n    pub const fn whole_nanoseconds(self) -> i128 {\n        self.seconds as i128 * 1_000_000_000 + self.nanoseconds as i128\n    }\n\n    /// Get the number of nanoseconds past the number of whole seconds.\n    ///\n    /// The returned value will always be in the range `-1_000_000_000..1_000_000_000`.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(1.000_000_400.seconds().subsec_nanoseconds(), 400);\n    /// assert_eq!((-1.000_000_400).seconds().subsec_nanoseconds(), -400);\n    /// ```\n    pub const fn subsec_nanoseconds(self) -> i32 {\n        self.nanoseconds\n    }\n    // endregion getters\n\n    // region: checked arithmetic\n    /// Computes `self + rhs`, returning `None` if an overflow occurred.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(5.seconds().checked_add(5.seconds()), Some(10.seconds()));\n    /// assert_eq!(Duration::MAX.checked_add(1.nanoseconds()), None);\n    /// assert_eq!((-5).seconds().checked_add(5.seconds()), Some(0.seconds()));\n    /// ```\n    pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n        let mut seconds = const_try_opt!(self.seconds.checked_add(rhs.seconds));\n        let mut nanoseconds = self.nanoseconds + rhs.nanoseconds;\n\n        if nanoseconds >= 1_000_000_000 || seconds < 0 && nanoseconds > 0 {\n            nanoseconds -= 1_000_000_000;\n            seconds = const_try_opt!(seconds.checked_add(1));\n        } else if nanoseconds <= -1_000_000_000 || seconds > 0 && nanoseconds < 0 {\n            nanoseconds += 1_000_000_000;\n            seconds = const_try_opt!(seconds.checked_sub(1));\n        }\n\n        Some(Self::new_unchecked(seconds, nanoseconds))\n    }\n\n    /// Computes `self - rhs`, returning `None` if an overflow occurred.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(5.seconds().checked_sub(5.seconds()), Some(Duration::ZERO));\n    /// assert_eq!(Duration::MIN.checked_sub(1.nanoseconds()), None);\n    /// assert_eq!(5.seconds().checked_sub(10.seconds()), Some((-5).seconds()));\n    /// ```\n    pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n        let mut seconds = const_try_opt!(self.seconds.checked_sub(rhs.seconds));\n        let mut nanoseconds = self.nanoseconds - rhs.nanoseconds;\n\n        if nanoseconds >= 1_000_000_000 || seconds < 0 && nanoseconds > 0 {\n            nanoseconds -= 1_000_000_000;\n            seconds = const_try_opt!(seconds.checked_add(1));\n        } else if nanoseconds <= -1_000_000_000 || seconds > 0 && nanoseconds < 0 {\n            nanoseconds += 1_000_000_000;\n            seconds = const_try_opt!(seconds.checked_sub(1));\n        }\n\n        Some(Self::new_unchecked(seconds, nanoseconds))\n    }\n\n    /// Computes `self * rhs`, returning `None` if an overflow occurred.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(5.seconds().checked_mul(2), Some(10.seconds()));\n    /// assert_eq!(5.seconds().checked_mul(-2), Some((-10).seconds()));\n    /// assert_eq!(5.seconds().checked_mul(0), Some(0.seconds()));\n    /// assert_eq!(Duration::MAX.checked_mul(2), None);\n    /// assert_eq!(Duration::MIN.checked_mul(2), None);\n    /// ```\n    pub const fn checked_mul(self, rhs: i32) -> Option<Self> {\n        // Multiply nanoseconds as i64, because it cannot overflow that way.\n        let total_nanos = self.nanoseconds as i64 * rhs as i64;\n        let extra_secs = total_nanos / 1_000_000_000;\n        let nanoseconds = (total_nanos % 1_000_000_000) as _;\n        let seconds = const_try_opt!(\n            const_try_opt!(self.seconds.checked_mul(rhs as _)).checked_add(extra_secs)\n        );\n\n        Some(Self::new_unchecked(seconds, nanoseconds))\n    }\n\n    /// Computes `self / rhs`, returning `None` if `rhs == 0` or if the result would overflow.\n    ///\n    /// ```rust\n    /// # use time::ext::NumericalDuration;\n    /// assert_eq!(10.seconds().checked_div(2), Some(5.seconds()));\n    /// assert_eq!(10.seconds().checked_div(-2), Some((-5).seconds()));\n    /// assert_eq!(1.seconds().checked_div(0), None);\n    /// ```\n    pub const fn checked_div(self, rhs: i32) -> Option<Self> {\n        let seconds = const_try_opt!(self.seconds.checked_div(rhs as i64));\n        let carry = self.seconds - seconds * (rhs as i64);\n        let extra_nanos = const_try_opt!((carry * 1_000_000_000).checked_div(rhs as i64));\n        let nanoseconds = const_try_opt!(self.nanoseconds.checked_div(rhs)) + (extra_nanos as i32);\n\n        Some(Self::new_unchecked(seconds, nanoseconds))\n    }\n    // endregion checked arithmetic\n\n    // region: saturating arithmetic\n    /// Computes `self + rhs`, saturating if an overflow occurred.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(5.seconds().saturating_add(5.seconds()), 10.seconds());\n    /// assert_eq!(Duration::MAX.saturating_add(1.nanoseconds()), Duration::MAX);\n    /// assert_eq!(\n    ///     Duration::MIN.saturating_add((-1).nanoseconds()),\n    ///     Duration::MIN\n    /// );\n    /// assert_eq!((-5).seconds().saturating_add(5.seconds()), Duration::ZERO);\n    /// ```\n    pub const fn saturating_add(self, rhs: Self) -> Self {\n        let (mut seconds, overflow) = self.seconds.overflowing_add(rhs.seconds);\n        if overflow {\n            if self.seconds > 0 {\n                return Self::MAX;\n            }\n            return Self::MIN;\n        }\n        let mut nanoseconds = self.nanoseconds + rhs.nanoseconds;\n\n        if nanoseconds >= 1_000_000_000 || seconds < 0 && nanoseconds > 0 {\n            nanoseconds -= 1_000_000_000;\n            seconds = match seconds.checked_add(1) {\n                Some(seconds) => seconds,\n                None => return Self::MAX,\n            };\n        } else if nanoseconds <= -1_000_000_000 || seconds > 0 && nanoseconds < 0 {\n            nanoseconds += 1_000_000_000;\n            seconds = match seconds.checked_sub(1) {\n                Some(seconds) => seconds,\n                None => return Self::MIN,\n            };\n        }\n\n        Self::new_unchecked(seconds, nanoseconds)\n    }\n\n    /// Computes `self - rhs`, saturating if an overflow occurred.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(5.seconds().saturating_sub(5.seconds()), Duration::ZERO);\n    /// assert_eq!(Duration::MIN.saturating_sub(1.nanoseconds()), Duration::MIN);\n    /// assert_eq!(\n    ///     Duration::MAX.saturating_sub((-1).nanoseconds()),\n    ///     Duration::MAX\n    /// );\n    /// assert_eq!(5.seconds().saturating_sub(10.seconds()), (-5).seconds());\n    /// ```\n    pub const fn saturating_sub(self, rhs: Self) -> Self {\n        let (mut seconds, overflow) = self.seconds.overflowing_sub(rhs.seconds);\n        if overflow {\n            if self.seconds > 0 {\n                return Self::MAX;\n            }\n            return Self::MIN;\n        }\n        let mut nanoseconds = self.nanoseconds - rhs.nanoseconds;\n\n        if nanoseconds >= 1_000_000_000 || seconds < 0 && nanoseconds > 0 {\n            nanoseconds -= 1_000_000_000;\n            seconds = match seconds.checked_add(1) {\n                Some(seconds) => seconds,\n                None => return Self::MAX,\n            };\n        } else if nanoseconds <= -1_000_000_000 || seconds > 0 && nanoseconds < 0 {\n            nanoseconds += 1_000_000_000;\n            seconds = match seconds.checked_sub(1) {\n                Some(seconds) => seconds,\n                None => return Self::MIN,\n            };\n        }\n\n        Self::new_unchecked(seconds, nanoseconds)\n    }\n\n    /// Computes `self * rhs`, saturating if an overflow occurred.\n    ///\n    /// ```rust\n    /// # use time::{Duration, ext::NumericalDuration};\n    /// assert_eq!(5.seconds().saturating_mul(2), 10.seconds());\n    /// assert_eq!(5.seconds().saturating_mul(-2), (-10).seconds());\n    /// assert_eq!(5.seconds().saturating_mul(0), Duration::ZERO);\n    /// assert_eq!(Duration::MAX.saturating_mul(2), Duration::MAX);\n    /// assert_eq!(Duration::MIN.saturating_mul(2), Duration::MIN);\n    /// assert_eq!(Duration::MAX.saturating_mul(-2), Duration::MIN);\n    /// assert_eq!(Duration::MIN.saturating_mul(-2), Duration::MAX);\n    /// ```\n    pub const fn saturating_mul(self, rhs: i32) -> Self {\n        // Multiply nanoseconds as i64, because it cannot overflow that way.\n        let total_nanos = self.nanoseconds as i64 * rhs as i64;\n        let extra_secs = total_nanos / 1_000_000_000;\n        let nanoseconds = (total_nanos % 1_000_000_000) as _;\n        let (seconds, overflow1) = self.seconds.overflowing_mul(rhs as _);\n        if overflow1 {\n            if self.seconds > 0 && rhs > 0 || self.seconds < 0 && rhs < 0 {\n                return Self::MAX;\n            }\n            return Self::MIN;\n        }\n        let (seconds, overflow2) = seconds.overflowing_add(extra_secs);\n        if overflow2 {\n            if self.seconds > 0 && rhs > 0 {\n                return Self::MAX;\n            }\n            return Self::MIN;\n        }\n\n        Self::new_unchecked(seconds, nanoseconds)\n    }\n    // endregion saturating arithmetic\n\n    /// Runs a closure, returning the duration of time it took to run. The return value of the\n    /// closure is provided in the second part of the tuple.\n    #[cfg(feature = \"std\")]\n    pub fn time_fn<T>(f: impl FnOnce() -> T) -> (Self, T) {\n        let start = Instant::now();\n        let return_value = f();\n        let end = Instant::now();\n\n        (end - start, return_value)\n    }\n}","impl Mul<$type> for Duration {\n            type Output = Self;\n\n            fn mul(self, rhs: $type) -> Self::Output {\n                Self::nanoseconds_i128(\n                    self.whole_nanoseconds()\n                        .checked_mul(rhs as _)\n                        .expect(\"overflow when multiplying duration\")\n                )\n            }\n        }","impl Mul<f32> for Duration {\n    type Output = Self;\n\n    fn mul(self, rhs: f32) -> Self::Output {\n        Self::seconds_f32(self.as_seconds_f32() * rhs)\n    }\n}","impl Mul<f64> for Duration {\n    type Output = Self;\n\n    fn mul(self, rhs: f64) -> Self::Output {\n        Self::seconds_f64(self.as_seconds_f64() * rhs)\n    }\n}","impl Neg for Duration {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        Self::new_unchecked(-self.seconds, -self.nanoseconds)\n    }\n}","impl PartialEq<StdDuration> for Duration {\n    fn eq(&self, rhs: &StdDuration) -> bool {\n        Ok(*self) == Self::try_from(*rhs)\n    }\n}","impl PartialOrd<StdDuration> for Duration {\n    fn partial_cmp(&self, rhs: &StdDuration) -> Option<Ordering> {\n        if rhs.as_secs() > i64::MAX as _ {\n            return Some(Ordering::Less);\n        }\n\n        Some(\n            self.seconds\n                .cmp(&(rhs.as_secs() as _))\n                .then_with(|| self.nanoseconds.cmp(&(rhs.subsec_nanos() as _))),\n        )\n    }\n}","impl Sub for Duration {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -> Self::Output {\n        self.checked_sub(rhs)\n            .expect(\"overflow when subtracting durations\")\n    }\n}","impl Sub<StdDuration> for Duration {\n    type Output = Self;\n\n    fn sub(self, rhs: StdDuration) -> Self::Output {\n        self - Self::try_from(rhs)\n            .expect(\"overflow converting `std::time::Duration` to `time::Duration`\")\n    }\n}","impl Sum for Duration {\n    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.reduce(|a, b| a + b).unwrap_or_default()\n    }\n}","impl TryFrom<StdDuration> for Duration {\n    type Error = error::ConversionRange;\n\n    fn try_from(original: StdDuration) -> Result<Self, error::ConversionRange> {\n        Ok(Self::new(\n            original\n                .as_secs()\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n            original.subsec_nanos() as _,\n        ))\n    }\n}","impl core::ops::$op<$t> for $target {\n            fn $fn(&mut self, rhs: $t) {\n                *self = *self $sym rhs;\n            }\n        }","impl fmt::Debug for Duration {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Duration\")\n            .field(\"seconds\", &self.seconds)\n            .field(\"nanoseconds\", &self.nanoseconds)\n            .finish()\n    }\n}","impl<'a> Sum<&'a Self> for Duration {\n    fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n        iter.copied().sum()\n    }\n}"],"duration::Padding":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Default for Padding {\n    fn default() -> Self {\n        Self::Optimize\n    }\n}"],"error::Error":["Debug","impl From<ComponentRange> for crate::Error {\n    fn from(original: ComponentRange) -> Self {\n        Self::ComponentRange(original)\n    }\n}","impl From<ConversionRange> for crate::Error {\n    fn from(err: ConversionRange) -> Self {\n        Self::ConversionRange(err)\n    }\n}","impl From<DifferentVariant> for crate::Error {\n    fn from(err: DifferentVariant) -> Self {\n        Self::DifferentVariant(err)\n    }\n}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::ConversionRange(e) => e.fmt(f),\n            Self::ComponentRange(e) => e.fmt(f),\n            #[cfg(feature = \"local-offset\")]\n            Self::IndeterminateOffset(e) => e.fmt(f),\n            #[cfg(feature = \"formatting\")]\n            Self::Format(e) => e.fmt(f),\n            #[cfg(feature = \"parsing\")]\n            Self::ParseFromDescription(e) => e.fmt(f),\n            #[cfg(feature = \"parsing\")]\n            Self::UnexpectedTrailingCharacters => f.write_str(\"unexpected trailing characters\"),\n            #[cfg(feature = \"parsing\")]\n            Self::TryFromParsed(e) => e.fmt(f),\n            #[cfg(all(any(feature = \"formatting\", feature = \"parsing\"), feature = \"alloc\"))]\n            Self::InvalidFormatDescription(e) => e.fmt(f),\n            Self::DifferentVariant(e) => e.fmt(f),\n        }\n    }\n}","impl std::error::Error for Error {\n    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n        match self {\n            Self::ConversionRange(err) => Some(err),\n            Self::ComponentRange(err) => Some(err),\n            #[cfg(feature = \"local-offset\")]\n            Self::IndeterminateOffset(err) => Some(err),\n            #[cfg(feature = \"formatting\")]\n            Self::Format(err) => Some(err),\n            #[cfg(feature = \"parsing\")]\n            Self::ParseFromDescription(err) => Some(err),\n            #[cfg(feature = \"parsing\")]\n            Self::UnexpectedTrailingCharacters => None,\n            #[cfg(feature = \"parsing\")]\n            Self::TryFromParsed(err) => Some(err),\n            #[cfg(all(any(feature = \"formatting\", feature = \"parsing\"), feature = \"alloc\"))]\n            Self::InvalidFormatDescription(err) => Some(err),\n            Self::DifferentVariant(err) => Some(err),\n        }\n    }\n}"],"error::component_range::ComponentRange":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl ComponentRange {\n    /// Obtain the name of the component whose value was out of range.\n    pub const fn name(self) -> &'static str {\n        self.name\n    }\n}","impl TryFrom<crate::Error> for ComponentRange {\n    type Error = error::DifferentVariant;\n\n    fn try_from(err: crate::Error) -> Result<Self, Self::Error> {\n        match err {\n            crate::Error::ComponentRange(err) => Ok(err),\n            _ => Err(error::DifferentVariant),\n        }\n    }\n}","impl fmt::Display for ComponentRange {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"{} must be in the range {}..={}\",\n            self.name, self.minimum, self.maximum\n        )?;\n\n        if self.conditional_range {\n            f.write_str(\", given values of other parameters\")?;\n        }\n\n        Ok(())\n    }\n}","impl std::error::Error for ComponentRange {}"],"error::conversion_range::ConversionRange":["Clone","Copy","Debug","Eq","PartialEq","impl TryFrom<crate::Error> for ConversionRange {\n    type Error = error::DifferentVariant;\n\n    fn try_from(err: crate::Error) -> Result<Self, Self::Error> {\n        match err {\n            crate::Error::ConversionRange(err) => Ok(err),\n            _ => Err(error::DifferentVariant),\n        }\n    }\n}","impl fmt::Display for ConversionRange {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"Source value is out of range for the target type\")\n    }\n}","impl std::error::Error for ConversionRange {}"],"error::different_variant::DifferentVariant":["Clone","Copy","Debug","Eq","PartialEq","impl TryFrom<crate::Error> for DifferentVariant {\n    type Error = Self;\n\n    fn try_from(err: crate::Error) -> Result<Self, Self::Error> {\n        match err {\n            crate::Error::DifferentVariant(err) => Ok(err),\n            _ => Err(Self),\n        }\n    }\n}","impl fmt::Display for DifferentVariant {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"value was of a different variant than required\")\n    }\n}","impl std::error::Error for DifferentVariant {}"],"instant::Instant":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Add<Duration> for Instant {\n    type Output = Self;\n\n    fn add(self, duration: Duration) -> Self::Output {\n        if duration.is_positive() {\n            Self(self.0 + duration.abs_std())\n        } else if duration.is_negative() {\n            Self(self.0 - duration.abs_std())\n        } else {\n            self\n        }\n    }\n}","impl Add<StdDuration> for Instant {\n    type Output = Self;\n\n    fn add(self, duration: StdDuration) -> Self::Output {\n        Self(self.0 + duration)\n    }\n}","impl AsRef<StdInstant> for Instant {\n    fn as_ref(&self) -> &StdInstant {\n        &self.0\n    }\n}","impl Borrow<StdInstant> for Instant {\n    fn borrow(&self) -> &StdInstant {\n        &self.0\n    }\n}","impl From<StdInstant> for Instant {\n    fn from(instant: StdInstant) -> Self {\n        Self(instant)\n    }\n}","impl Instant {\n    // region: delegation\n    /// Returns an `Instant` corresponding to \"now\".\n    ///\n    /// ```rust\n    /// # use time::Instant;\n    /// println!(\"{:?}\", Instant::now());\n    /// ```\n    pub fn now() -> Self {\n        Self(StdInstant::now())\n    }\n\n    /// Returns the amount of time elapsed since this instant was created. The duration will always\n    /// be nonnegative if the instant is not synthetically created.\n    ///\n    /// ```rust\n    /// # use time::{Instant, ext::{NumericalStdDuration, NumericalDuration}};\n    /// # use std::thread;\n    /// let instant = Instant::now();\n    /// thread::sleep(1.std_milliseconds());\n    /// assert!(instant.elapsed() >= 1.milliseconds());\n    /// ```\n    pub fn elapsed(self) -> Duration {\n        Self::now() - self\n    }\n    // endregion delegation\n\n    // region: checked arithmetic\n    /// Returns `Some(t)` where `t` is the time `self + duration` if `t` can be represented as\n    /// `Instant` (which means it's inside the bounds of the underlying data structure), `None`\n    /// otherwise.\n    ///\n    /// ```rust\n    /// # use time::{Instant, ext::NumericalDuration};\n    /// let now = Instant::now();\n    /// assert_eq!(now.checked_add(5.seconds()), Some(now + 5.seconds()));\n    /// assert_eq!(now.checked_add((-5).seconds()), Some(now + (-5).seconds()));\n    /// ```\n    pub fn checked_add(self, duration: Duration) -> Option<Self> {\n        if duration.is_zero() {\n            Some(self)\n        } else if duration.is_positive() {\n            self.0.checked_add(duration.abs_std()).map(Self)\n        } else {\n            debug_assert!(duration.is_negative());\n            self.0.checked_sub(duration.abs_std()).map(Self)\n        }\n    }\n\n    /// Returns `Some(t)` where `t` is the time `self - duration` if `t` can be represented as\n    /// `Instant` (which means it's inside the bounds of the underlying data structure), `None`\n    /// otherwise.\n    ///\n    /// ```rust\n    /// # use time::{Instant, ext::NumericalDuration};\n    /// let now = Instant::now();\n    /// assert_eq!(now.checked_sub(5.seconds()), Some(now - 5.seconds()));\n    /// assert_eq!(now.checked_sub((-5).seconds()), Some(now - (-5).seconds()));\n    /// ```\n    pub fn checked_sub(self, duration: Duration) -> Option<Self> {\n        if duration.is_zero() {\n            Some(self)\n        } else if duration.is_positive() {\n            self.0.checked_sub(duration.abs_std()).map(Self)\n        } else {\n            debug_assert!(duration.is_negative());\n            self.0.checked_add(duration.abs_std()).map(Self)\n        }\n    }\n    // endregion checked arithmetic\n\n    /// Obtain the inner [`std::time::Instant`].\n    ///\n    /// ```rust\n    /// # use time::Instant;\n    /// let now = Instant::now();\n    /// assert_eq!(now.into_inner(), now.0);\n    /// ```\n    pub const fn into_inner(self) -> StdInstant {\n        self.0\n    }\n}","impl PartialEq<StdInstant> for Instant {\n    fn eq(&self, rhs: &StdInstant) -> bool {\n        self.0.eq(rhs)\n    }\n}","impl PartialOrd<StdInstant> for Instant {\n    fn partial_cmp(&self, rhs: &StdInstant) -> Option<Ordering> {\n        self.0.partial_cmp(rhs)\n    }\n}","impl Sub for Instant {\n    type Output = Duration;\n\n    fn sub(self, other: Self) -> Self::Output {\n        match self.0.cmp(&other.0) {\n            Ordering::Equal => Duration::ZERO,\n            Ordering::Greater => (self.0 - other.0)\n                .try_into()\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n            Ordering::Less => -Duration::try_from(other.0 - self.0)\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n        }\n    }\n}","impl Sub<Duration> for Instant {\n    type Output = Self;\n\n    fn sub(self, duration: Duration) -> Self::Output {\n        if duration.is_positive() {\n            Self(self.0 - duration.abs_std())\n        } else if duration.is_negative() {\n            Self(self.0 + duration.abs_std())\n        } else {\n            self\n        }\n    }\n}","impl Sub<StdDuration> for Instant {\n    type Output = Self;\n\n    fn sub(self, duration: StdDuration) -> Self::Output {\n        Self(self.0 - duration)\n    }\n}","impl Sub<StdInstant> for Instant {\n    type Output = Duration;\n\n    fn sub(self, other: StdInstant) -> Self::Output {\n        self - Self(other)\n    }\n}","impl core::ops::$op<$t> for $target {\n            fn $fn(&mut self, rhs: $t) {\n                *self = *self $sym rhs;\n            }\n        }"],"month::Month":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl Month {\n    /// Create a `Month` from its numerical value.\n    pub(crate) const fn from_number(n: NonZeroU8) -> Result<Self, error::ComponentRange> {\n        match n.get() {\n            1 => Ok(January),\n            2 => Ok(February),\n            3 => Ok(March),\n            4 => Ok(April),\n            5 => Ok(May),\n            6 => Ok(June),\n            7 => Ok(July),\n            8 => Ok(August),\n            9 => Ok(September),\n            10 => Ok(October),\n            11 => Ok(November),\n            12 => Ok(December),\n            n => Err(error::ComponentRange {\n                name: \"month\",\n                minimum: 1,\n                maximum: 12,\n                value: n as _,\n                conditional_range: false,\n            }),\n        }\n    }\n\n    /// Get the previous month.\n    ///\n    /// ```rust\n    /// # use time::Month;\n    /// assert_eq!(Month::January.previous(), Month::December);\n    /// ```\n    pub const fn previous(self) -> Self {\n        match self {\n            January => December,\n            February => January,\n            March => February,\n            April => March,\n            May => April,\n            June => May,\n            July => June,\n            August => July,\n            September => August,\n            October => September,\n            November => October,\n            December => November,\n        }\n    }\n\n    /// Get the next month.\n    ///\n    /// ```rust\n    /// # use time::Month;\n    /// assert_eq!(Month::January.next(), Month::February);\n    /// ```\n    pub const fn next(self) -> Self {\n        match self {\n            January => February,\n            February => March,\n            March => April,\n            April => May,\n            May => June,\n            June => July,\n            July => August,\n            August => September,\n            September => October,\n            October => November,\n            November => December,\n            December => January,\n        }\n    }\n}","impl TryFrom<u8> for Month {\n    type Error = error::ComponentRange;\n\n    fn try_from(value: u8) -> Result<Self, Self::Error> {\n        match NonZeroU8::new(value) {\n            Some(value) => Self::from_number(value),\n            None => Err(error::ComponentRange {\n                name: \"month\",\n                minimum: 1,\n                maximum: 12,\n                value: 0,\n                conditional_range: false,\n            }),\n        }\n    }\n}","impl fmt::Display for Month {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(match self {\n            January => \"January\",\n            February => \"February\",\n            March => \"March\",\n            April => \"April\",\n            May => \"May\",\n            June => \"June\",\n            July => \"July\",\n            August => \"August\",\n            September => \"September\",\n            October => \"October\",\n            November => \"November\",\n            December => \"December\",\n        })\n    }\n}"],"offset_date_time::OffsetDateTime":["Clone","Copy","Debug","Eq","impl From<SystemTime> for OffsetDateTime {\n    fn from(system_time: SystemTime) -> Self {\n        match system_time.duration_since(SystemTime::UNIX_EPOCH) {\n            Ok(duration) => Self::UNIX_EPOCH + duration,\n            Err(err) => Self::UNIX_EPOCH - err.duration(),\n        }\n    }\n}","impl Hash for OffsetDateTime {\n    fn hash<H: Hasher>(&self, hasher: &mut H) {\n        // We need to distinguish this from a `PrimitiveDateTime`, which would otherwise conflict.\n        hasher.write(b\"OffsetDateTime\");\n        self.utc_datetime.hash(hasher);\n    }\n}","impl OffsetDateTime {\n    /// Midnight, 1 January, 1970 (UTC).\n    ///\n    /// ```rust\n    /// # use time::{OffsetDateTime, macros::datetime};\n    /// assert_eq!(OffsetDateTime::UNIX_EPOCH, datetime!(1970-01-01 0:00 UTC),);\n    /// ```\n    pub const UNIX_EPOCH: Self = Date::__from_ordinal_date_unchecked(1970, 1)\n        .midnight()\n        .assume_utc();\n\n    // region: now\n    /// Create a new `OffsetDateTime` with the current date and time in UTC.\n    ///\n    /// ```rust\n    /// # use time::{OffsetDateTime, macros::offset};\n    /// assert!(OffsetDateTime::now_utc().year() >= 2019);\n    /// assert_eq!(OffsetDateTime::now_utc().offset(), offset!(UTC));\n    /// ```\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(__time_03_docs, doc(cfg(feature = \"std\")))]\n    pub fn now_utc() -> Self {\n        SystemTime::now().into()\n    }\n\n    /// Attempt to create a new `OffsetDateTime` with the current date and time in the local offset.\n    /// If the offset cannot be determined, an error is returned.\n    ///\n    /// ```rust\n    /// # use time::OffsetDateTime;\n    /// # if false {\n    /// assert!(OffsetDateTime::now_local().is_ok());\n    /// # }\n    /// ```\n    #[cfg(feature = \"local-offset\")]\n    #[cfg_attr(__time_03_docs, doc(cfg(feature = \"local-offset\")))]\n    pub fn now_local() -> Result<Self, error::IndeterminateOffset> {\n        let t = Self::now_utc();\n        Ok(t.to_offset(UtcOffset::local_offset_at(t)?))\n    }\n    // endregion now\n\n    /// Convert the `OffsetDateTime` from the current [`UtcOffset`] to the provided [`UtcOffset`].\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, offset};\n    /// assert_eq!(\n    ///     datetime!(2000-01-01 0:00 UTC)\n    ///         .to_offset(offset!(-1))\n    ///         .year(),\n    ///     1999,\n    /// );\n    ///\n    /// // Let's see what time Sydney's new year's celebration is in New York // and Los Angeles.\n    ///\n    /// // Construct midnight on new year's in Sydney.\n    /// let sydney = datetime!(2000-01-01 0:00 +11);\n    /// let new_york = sydney.to_offset(offset!(-5));\n    /// let los_angeles = sydney.to_offset(offset!(-8));\n    /// assert_eq!(sydney.hour(), 0);\n    /// assert_eq!(new_york.hour(), 8);\n    /// assert_eq!(los_angeles.hour(), 5);\n    /// ```\n    pub const fn to_offset(self, offset: UtcOffset) -> Self {\n        Self {\n            utc_datetime: self.utc_datetime,\n            offset,\n        }\n    }\n\n    // region: constructors\n    /// Create an `OffsetDateTime` from the provided Unix timestamp. Calling `.offset()` on the\n    /// resulting value is guaranteed to return UTC.\n    ///\n    /// ```rust\n    /// # use time::{OffsetDateTime, macros::datetime};\n    /// assert_eq!(\n    ///     OffsetDateTime::from_unix_timestamp(0),\n    ///     Ok(OffsetDateTime::UNIX_EPOCH),\n    /// );\n    /// assert_eq!(\n    ///     OffsetDateTime::from_unix_timestamp(1_546_300_800),\n    ///     Ok(datetime!(2019-01-01 0:00 UTC)),\n    /// );\n    /// ```\n    ///\n    /// If you have a timestamp-nanosecond pair, you can use something along the lines of the\n    /// following:\n    ///\n    /// ```rust\n    /// # use time::{Duration, OffsetDateTime, ext::NumericalDuration};\n    /// let (timestamp, nanos) = (1, 500_000_000);\n    /// assert_eq!(\n    ///     OffsetDateTime::from_unix_timestamp(timestamp)? + Duration::nanoseconds(nanos),\n    ///     OffsetDateTime::UNIX_EPOCH + 1.5.seconds()\n    /// );\n    /// # Ok::<_, time::Error>(())\n    /// ```\n    pub const fn from_unix_timestamp(timestamp: i64) -> Result<Self, error::ComponentRange> {\n        #[allow(clippy::missing_docs_in_private_items)]\n        const MIN_TIMESTAMP: i64 = Date::MIN.midnight().assume_utc().unix_timestamp();\n        #[allow(clippy::missing_docs_in_private_items)]\n        const MAX_TIMESTAMP: i64 = Date::MAX\n            .with_time(Time::__from_hms_nanos_unchecked(23, 59, 59, 999_999_999))\n            .assume_utc()\n            .unix_timestamp();\n\n        ensure_value_in_range!(timestamp in MIN_TIMESTAMP => MAX_TIMESTAMP);\n\n        // Use the unchecked method here, as the input validity has already been verified.\n        let date = Date::from_julian_day_unchecked(\n            UNIX_EPOCH_JULIAN_DAY + div_floor!(timestamp, 86_400) as i32,\n        );\n\n        let seconds_within_day = timestamp.rem_euclid(86_400);\n        let time = Time::__from_hms_nanos_unchecked(\n            (seconds_within_day / 3_600) as _,\n            ((seconds_within_day % 3_600) / 60) as _,\n            (seconds_within_day % 60) as _,\n            0,\n        );\n\n        Ok(PrimitiveDateTime::new(date, time).assume_utc())\n    }\n\n    /// Construct an `OffsetDateTime` from the provided Unix timestamp (in nanoseconds). Calling\n    /// `.offset()` on the resulting value is guaranteed to return UTC.\n    ///\n    /// ```rust\n    /// # use time::{OffsetDateTime, macros::datetime};\n    /// assert_eq!(\n    ///     OffsetDateTime::from_unix_timestamp_nanos(0),\n    ///     Ok(OffsetDateTime::UNIX_EPOCH),\n    /// );\n    /// assert_eq!(\n    ///     OffsetDateTime::from_unix_timestamp_nanos(1_546_300_800_000_000_000),\n    ///     Ok(datetime!(2019-01-01 0:00 UTC)),\n    /// );\n    /// ```\n    pub const fn from_unix_timestamp_nanos(timestamp: i128) -> Result<Self, error::ComponentRange> {\n        let datetime = const_try!(Self::from_unix_timestamp(\n            div_floor!(timestamp, 1_000_000_000) as i64\n        ));\n\n        Ok(datetime\n            .utc_datetime\n            .replace_time(Time::__from_hms_nanos_unchecked(\n                datetime.utc_datetime.hour(),\n                datetime.utc_datetime.minute(),\n                datetime.utc_datetime.second(),\n                timestamp.rem_euclid(1_000_000_000) as u32,\n            ))\n            .assume_utc())\n    }\n    // endregion constructors\n\n    // region: getters\n    /// Get the [`UtcOffset`].\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, offset};\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).offset(), offset!(UTC));\n    /// assert_eq!(datetime!(2019-01-01 0:00 +1).offset(), offset!(+1));\n    /// ```\n    pub const fn offset(self) -> UtcOffset {\n        self.offset\n    }\n\n    /// Get the [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(1970-01-01 0:00 UTC).unix_timestamp(), 0);\n    /// assert_eq!(datetime!(1970-01-01 0:00 -1).unix_timestamp(), 3_600);\n    /// ```\n    pub const fn unix_timestamp(self) -> i64 {\n        let days =\n            (self.utc_datetime.to_julian_day() as i64 - UNIX_EPOCH_JULIAN_DAY as i64) * 86_400;\n        let hours = self.utc_datetime.hour() as i64 * 3_600;\n        let minutes = self.utc_datetime.minute() as i64 * 60;\n        let seconds = self.utc_datetime.second() as i64;\n        days + hours + minutes + seconds\n    }\n\n    /// Get the Unix timestamp in nanoseconds.\n    ///\n    /// ```rust\n    /// use time::macros::datetime;\n    /// assert_eq!(datetime!(1970-01-01 0:00 UTC).unix_timestamp_nanos(), 0);\n    /// assert_eq!(\n    ///     datetime!(1970-01-01 0:00 -1).unix_timestamp_nanos(),\n    ///     3_600_000_000_000,\n    /// );\n    /// ```\n    pub const fn unix_timestamp_nanos(self) -> i128 {\n        self.unix_timestamp() as i128 * 1_000_000_000 + self.utc_datetime.nanosecond() as i128\n    }\n\n    /// Get the [`Date`] in the stored offset.\n    ///\n    /// ```rust\n    /// # use time::macros::{date, datetime, offset};\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).date(), date!(2019-01-01));\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 0:00 UTC)\n    ///         .to_offset(offset!(-1))\n    ///         .date(),\n    ///     date!(2018-12-31),\n    /// );\n    /// ```\n    pub const fn date(self) -> Date {\n        let mut second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        let mut minute = self.utc_datetime.minute() as i8 + self.offset.minutes_past_hour();\n        let mut hour = self.utc_datetime.hour() as i8 + self.offset.whole_hours();\n        let (mut year, mut ordinal) = self.utc_datetime.date.to_ordinal_date();\n\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        cascade!(hour in 0..24 => ordinal);\n        cascade!(ordinal => year);\n\n        Date::__from_ordinal_date_unchecked(year, ordinal)\n    }\n\n    /// Get the [`Time`] in the stored offset.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, offset, time};\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).time(), time!(0:00));\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 0:00 UTC)\n    ///         .to_offset(offset!(-1))\n    ///         .time(),\n    ///     time!(23:00)\n    /// );\n    /// ```\n    pub const fn time(self) -> Time {\n        let mut second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        let mut minute = self.utc_datetime.minute() as i8 + self.offset.minutes_past_hour();\n        let mut hour = self.utc_datetime.hour() as i8 + self.offset.whole_hours();\n\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n\n        Time::__from_hms_nanos_unchecked(\n            hour.rem_euclid(24) as _,\n            minute as _,\n            second as _,\n            self.utc_datetime.nanosecond(),\n        )\n    }\n\n    // region: date getters\n    /// Get the year of the date in the stored offset.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, offset};\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).year(), 2019);\n    /// assert_eq!(\n    ///     datetime!(2019-12-31 23:00 UTC)\n    ///         .to_offset(offset!(+1))\n    ///         .year(),\n    ///     2020,\n    /// );\n    /// assert_eq!(datetime!(2020-01-01 0:00 UTC).year(), 2020);\n    /// ```\n    pub const fn year(self) -> i32 {\n        let mut second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        let mut minute = self.utc_datetime.minute() as i8 + self.offset.minutes_past_hour();\n        let mut hour = self.utc_datetime.hour() as i8 + self.offset.whole_hours();\n        let (mut year, mut ordinal) = self.utc_datetime.date.to_ordinal_date();\n\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        cascade!(hour in 0..24 => ordinal);\n        cascade!(ordinal => year);\n\n        year\n    }\n\n    /// Get the month of the date in the stored offset.\n    ///\n    /// ```rust\n    /// # use time::Month;\n    /// # use time::macros::{datetime, offset};\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).month(), Month::January);\n    /// assert_eq!(\n    ///     datetime!(2019-12-31 23:00 UTC)\n    ///         .to_offset(offset!(+1))\n    ///         .month(),\n    ///     Month::January,\n    /// );\n    /// ```\n    pub const fn month(self) -> Month {\n        self.date().month()\n    }\n\n    /// Get the day of the date in the stored offset.\n    ///\n    /// The returned value will always be in the range `1..=31`.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, offset};\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).day(), 1);\n    /// assert_eq!(\n    ///     datetime!(2019-12-31 23:00 UTC)\n    ///         .to_offset(offset!(+1))\n    ///         .day(),\n    ///     1,\n    /// );\n    /// ```\n    pub const fn day(self) -> u8 {\n        self.date().day()\n    }\n\n    /// Get the day of the year of the date in the stored offset.\n    ///\n    /// The returned value will always be in the range `1..=366`.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, offset};\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).ordinal(), 1);\n    /// assert_eq!(\n    ///     datetime!(2019-12-31 23:00 UTC)\n    ///         .to_offset(offset!(+1))\n    ///         .ordinal(),\n    ///     1,\n    /// );\n    /// ```\n    pub const fn ordinal(self) -> u16 {\n        let mut second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        let mut minute = self.utc_datetime.minute() as i8 + self.offset.minutes_past_hour();\n        let mut hour = self.utc_datetime.hour() as i8 + self.offset.whole_hours();\n        let (mut year, mut ordinal) = self.utc_datetime.date.to_ordinal_date();\n\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        cascade!(hour in 0..24 => ordinal);\n        cascade!(ordinal => year);\n\n        ordinal\n    }\n\n    /// Get the ISO week number of the date in the stored offset.\n    ///\n    /// The returned value will always be in the range `1..=53`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).iso_week(), 1);\n    /// assert_eq!(datetime!(2020-01-01 0:00 UTC).iso_week(), 1);\n    /// assert_eq!(datetime!(2020-12-31 0:00 UTC).iso_week(), 53);\n    /// assert_eq!(datetime!(2021-01-01 0:00 UTC).iso_week(), 53);\n    /// ```\n    pub const fn iso_week(self) -> u8 {\n        self.date().iso_week()\n    }\n\n    /// Get the week number where week 1 begins on the first Sunday.\n    ///\n    /// The returned value will always be in the range `0..=53`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).sunday_based_week(), 0);\n    /// assert_eq!(datetime!(2020-01-01 0:00 UTC).sunday_based_week(), 0);\n    /// assert_eq!(datetime!(2020-12-31 0:00 UTC).sunday_based_week(), 52);\n    /// assert_eq!(datetime!(2021-01-01 0:00 UTC).sunday_based_week(), 0);\n    /// ```\n    pub const fn sunday_based_week(self) -> u8 {\n        self.date().sunday_based_week()\n    }\n\n    /// Get the week number where week 1 begins on the first Monday.\n    ///\n    /// The returned value will always be in the range `0..=53`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).monday_based_week(), 0);\n    /// assert_eq!(datetime!(2020-01-01 0:00 UTC).monday_based_week(), 0);\n    /// assert_eq!(datetime!(2020-12-31 0:00 UTC).monday_based_week(), 52);\n    /// assert_eq!(datetime!(2021-01-01 0:00 UTC).monday_based_week(), 0);\n    /// ```\n    pub const fn monday_based_week(self) -> u8 {\n        self.date().monday_based_week()\n    }\n\n    /// Get the year, month, and day.\n    ///\n    /// ```rust\n    /// # use time::{macros::datetime, Month};\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 0:00 UTC).to_calendar_date(),\n    ///     (2019, Month::January, 1)\n    /// );\n    /// ```\n    pub const fn to_calendar_date(self) -> (i32, Month, u8) {\n        self.date().to_calendar_date()\n    }\n\n    /// Get the year and ordinal day number.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 0:00 UTC).to_ordinal_date(),\n    ///     (2019, 1)\n    /// );\n    /// ```\n    pub const fn to_ordinal_date(self) -> (i32, u16) {\n        self.date().to_ordinal_date()\n    }\n\n    /// Get the ISO 8601 year, week number, and weekday.\n    ///\n    /// ```rust\n    /// # use time::{Weekday::*, macros::datetime};\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 0:00 UTC).to_iso_week_date(),\n    ///     (2019, 1, Tuesday)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2019-10-04 0:00 UTC).to_iso_week_date(),\n    ///     (2019, 40, Friday)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 0:00 UTC).to_iso_week_date(),\n    ///     (2020, 1, Wednesday)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2020-12-31 0:00 UTC).to_iso_week_date(),\n    ///     (2020, 53, Thursday)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2021-01-01 0:00 UTC).to_iso_week_date(),\n    ///     (2020, 53, Friday)\n    /// );\n    /// ```\n    pub const fn to_iso_week_date(self) -> (i32, u8, Weekday) {\n        self.date().to_iso_week_date()\n    }\n\n    /// Get the weekday of the date in the stored offset.\n    ///\n    /// ```rust\n    /// # use time::{Weekday::*, macros::datetime};\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).weekday(), Tuesday);\n    /// assert_eq!(datetime!(2019-02-01 0:00 UTC).weekday(), Friday);\n    /// assert_eq!(datetime!(2019-03-01 0:00 UTC).weekday(), Friday);\n    /// ```\n    pub const fn weekday(self) -> Weekday {\n        self.date().weekday()\n    }\n\n    /// Get the Julian day for the date. The time is not taken into account for this calculation.\n    ///\n    /// The algorithm to perform this conversion is derived from one provided by Peter Baum; it is\n    /// freely available [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(-4713-11-24 0:00 UTC).to_julian_day(), 0);\n    /// assert_eq!(datetime!(2000-01-01 0:00 UTC).to_julian_day(), 2_451_545);\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).to_julian_day(), 2_458_485);\n    /// assert_eq!(datetime!(2019-12-31 0:00 UTC).to_julian_day(), 2_458_849);\n    /// ```\n    pub const fn to_julian_day(self) -> i32 {\n        self.date().to_julian_day()\n    }\n    // endregion date getters\n\n    // region: time getters\n    /// Get the clock hour, minute, and second.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2020-01-01 0:00:00 UTC).to_hms(), (0, 0, 0));\n    /// assert_eq!(datetime!(2020-01-01 23:59:59 UTC).to_hms(), (23, 59, 59));\n    /// ```\n    pub const fn to_hms(self) -> (u8, u8, u8) {\n        self.time().as_hms()\n    }\n\n    /// Get the clock hour, minute, second, and millisecond.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 0:00:00 UTC).to_hms_milli(),\n    ///     (0, 0, 0, 0)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 23:59:59.999 UTC).to_hms_milli(),\n    ///     (23, 59, 59, 999)\n    /// );\n    /// ```\n    pub const fn to_hms_milli(self) -> (u8, u8, u8, u16) {\n        self.time().as_hms_milli()\n    }\n\n    /// Get the clock hour, minute, second, and microsecond.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 0:00:00 UTC).to_hms_micro(),\n    ///     (0, 0, 0, 0)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 23:59:59.999_999 UTC).to_hms_micro(),\n    ///     (23, 59, 59, 999_999)\n    /// );\n    /// ```\n    pub const fn to_hms_micro(self) -> (u8, u8, u8, u32) {\n        self.time().as_hms_micro()\n    }\n\n    /// Get the clock hour, minute, second, and nanosecond.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 0:00:00 UTC).to_hms_nano(),\n    ///     (0, 0, 0, 0)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 23:59:59.999_999_999 UTC).to_hms_nano(),\n    ///     (23, 59, 59, 999_999_999)\n    /// );\n    /// ```\n    pub const fn to_hms_nano(self) -> (u8, u8, u8, u32) {\n        self.time().as_hms_nano()\n    }\n\n    /// Get the clock hour in the stored offset.\n    ///\n    /// The returned value will always be in the range `0..24`.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, offset};\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).hour(), 0);\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 23:59:59 UTC)\n    ///         .to_offset(offset!(-2))\n    ///         .hour(),\n    ///     21,\n    /// );\n    /// ```\n    pub const fn hour(self) -> u8 {\n        let mut second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        let mut minute = self.utc_datetime.minute() as i8 + self.offset.minutes_past_hour();\n        let mut hour = self.utc_datetime.hour() as i8 + self.offset.whole_hours();\n\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        hour.rem_euclid(24) as _\n    }\n\n    /// Get the minute within the hour in the stored offset.\n    ///\n    /// The returned value will always be in the range `0..60`.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, offset};\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).minute(), 0);\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 23:59:59 UTC)\n    ///         .to_offset(offset!(+0:30))\n    ///         .minute(),\n    ///     29,\n    /// );\n    /// ```\n    pub const fn minute(self) -> u8 {\n        let mut second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        let mut minute = self.utc_datetime.minute() as i8 + self.offset.minutes_past_hour();\n\n        cascade!(second in 0..60 => minute);\n        minute.rem_euclid(60) as _\n    }\n\n    /// Get the second within the minute in the stored offset.\n    ///\n    /// The returned value will always be in the range `0..60`.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, offset};\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).second(), 0);\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 23:59:59 UTC)\n    ///         .to_offset(offset!(+0:00:30))\n    ///         .second(),\n    ///     29,\n    /// );\n    /// ```\n    pub const fn second(self) -> u8 {\n        let second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        second.rem_euclid(60) as _\n    }\n\n    // Because a `UtcOffset` is limited in resolution to one second, any subsecond value will not\n    // change when adjusting for the offset.\n\n    /// Get the milliseconds within the second in the stored offset.\n    ///\n    /// The returned value will always be in the range `0..1_000`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).millisecond(), 0);\n    /// assert_eq!(datetime!(2019-01-01 23:59:59.999 UTC).millisecond(), 999);\n    /// ```\n    pub const fn millisecond(self) -> u16 {\n        self.utc_datetime.millisecond()\n    }\n\n    /// Get the microseconds within the second in the stored offset.\n    ///\n    /// The returned value will always be in the range `0..1_000_000`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).microsecond(), 0);\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 23:59:59.999_999 UTC).microsecond(),\n    ///     999_999,\n    /// );\n    /// ```\n    pub const fn microsecond(self) -> u32 {\n        self.utc_datetime.microsecond()\n    }\n\n    /// Get the nanoseconds within the second in the stored offset.\n    ///\n    /// The returned value will always be in the range `0..1_000_000_000`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00 UTC).nanosecond(), 0);\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 23:59:59.999_999_999 UTC).nanosecond(),\n    ///     999_999_999,\n    /// );\n    /// ```\n    pub const fn nanosecond(self) -> u32 {\n        self.utc_datetime.nanosecond()\n    }\n    // endregion time getters\n    // endregion getters\n\n    // region: checked arithmetic\n    /// Computes `self + duration`, returning `None` if an overflow occurred.\n    ///\n    /// ```\n    /// # use time::{Date, ext::NumericalDuration};\n    /// # use time::macros::{datetime, offset};\n    /// let datetime = Date::MIN.midnight().assume_offset(offset!(+10));\n    /// assert_eq!(datetime.checked_add((-2).days()), None);\n    ///\n    /// let datetime = Date::MAX.midnight().assume_offset(offset!(+10));\n    /// assert_eq!(datetime.checked_add(2.days()), None);\n    ///\n    /// assert_eq!(\n    ///     datetime!(2019 - 11 - 25 15:30 +10).checked_add(27.hours()),\n    ///     Some(datetime!(2019 - 11 - 26 18:30 +10))\n    /// );\n    /// ```\n    pub const fn checked_add(self, duration: Duration) -> Option<Self> {\n        let offset_datetime = self.utc_datetime.utc_to_offset(self.offset);\n        Some(const_try_opt!(offset_datetime.checked_add(duration)).assume_offset(self.offset))\n    }\n\n    /// Computes `self - duration`, returning `None` if an overflow occurred.\n    ///\n    /// ```\n    /// # use time::{Date, ext::NumericalDuration};\n    /// # use time::macros::{datetime, offset};\n    /// let datetime = Date::MIN.midnight().assume_offset(offset!(+10));\n    /// assert_eq!(datetime.checked_sub(2.days()), None);\n    ///\n    /// let datetime = Date::MAX.midnight().assume_offset(offset!(+10));\n    /// assert_eq!(datetime.checked_sub((-2).days()), None);\n    ///\n    /// assert_eq!(\n    ///     datetime!(2019 - 11 - 25 15:30 +10).checked_sub(27.hours()),\n    ///     Some(datetime!(2019 - 11 - 24 12:30 +10))\n    /// );\n    /// ```\n    pub const fn checked_sub(self, duration: Duration) -> Option<Self> {\n        let offset_datetime = self.utc_datetime.utc_to_offset(self.offset);\n        Some(const_try_opt!(offset_datetime.checked_sub(duration)).assume_offset(self.offset))\n    }\n    // endregion: checked arithmetic\n\n    // region: saturating arithmetic\n    /// Computes `self + duration`, saturating value on overflow.\n    ///\n    /// ```\n    /// # use time::ext::NumericalDuration;\n    /// # use time::macros::datetime;\n    /// assert_eq!(\n    ///     datetime!(-999999 - 01 - 01 0:00 +10).saturating_add((-2).days()),\n    ///     datetime!(-999999 - 01 - 01 0:00 +10)\n    /// );\n    ///\n    /// assert_eq!(\n    ///     datetime!(+999999 - 12 - 31 23:59:59.999_999_999 +10).saturating_add(2.days()),\n    ///     datetime!(+999999 - 12 - 31 23:59:59.999_999_999 +10)\n    /// );\n    ///\n    /// assert_eq!(\n    ///     datetime!(2019 - 11 - 25 15:30 +10).saturating_add(27.hours()),\n    ///     datetime!(2019 - 11 - 26 18:30 +10)\n    /// );\n    /// ```\n    pub const fn saturating_add(self, duration: Duration) -> Self {\n        if let Some(datetime) = self.checked_add(duration) {\n            datetime\n        } else if duration.is_negative() {\n            PrimitiveDateTime::MIN\n                .assume_utc()\n                .replace_offset(self.offset)\n        } else {\n            PrimitiveDateTime::MAX\n                .assume_utc()\n                .replace_offset(self.offset)\n        }\n    }\n\n    /// Computes `self - duration`, saturating value on overflow.\n    ///\n    /// ```\n    /// # use time::ext::NumericalDuration;\n    /// # use time::macros::datetime;\n    /// assert_eq!(\n    ///     datetime!(-999999 - 01 - 01 0:00 +10).saturating_sub(2.days()),\n    ///     datetime!(-999999 - 01 - 01 0:00 +10)\n    /// );\n    ///\n    /// assert_eq!(\n    ///     datetime!(+999999 - 12 - 31 23:59:59.999_999_999 +10).saturating_sub((-2).days()),\n    ///     datetime!(+999999 - 12 - 31 23:59:59.999_999_999 +10)\n    /// );\n    ///\n    /// assert_eq!(\n    ///     datetime!(2019 - 11 - 25 15:30 +10).saturating_sub(27.hours()),\n    ///     datetime!(2019 - 11 - 24 12:30 +10)\n    /// );\n    /// ```\n    pub const fn saturating_sub(self, duration: Duration) -> Self {\n        if let Some(datetime) = self.checked_sub(duration) {\n            datetime\n        } else if duration.is_negative() {\n            PrimitiveDateTime::MAX\n                .assume_utc()\n                .replace_offset(self.offset)\n        } else {\n            PrimitiveDateTime::MIN\n                .assume_utc()\n                .replace_offset(self.offset)\n        }\n    }\n    // endregion: saturating arithmetic\n}","impl OffsetDateTime {\n    /// Replace the time, which is assumed to be in the stored offset. The date and offset\n    /// components are unchanged.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, time};\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 5:00 UTC).replace_time(time!(12:00)),\n    ///     datetime!(2020-01-01 12:00 UTC)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 12:00 -5).replace_time(time!(7:00)),\n    ///     datetime!(2020-01-01 7:00 -5)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 0:00 +1).replace_time(time!(12:00)),\n    ///     datetime!(2020-01-01 12:00 +1)\n    /// );\n    /// ```\n    #[must_use = \"This method does not mutate the original `OffsetDateTime`.\"]\n    pub const fn replace_time(self, time: Time) -> Self {\n        self.utc_datetime\n            .utc_to_offset(self.offset)\n            .replace_time(time)\n            .assume_offset(self.offset)\n    }\n\n    /// Replace the date, which is assumed to be in the stored offset. The time and offset\n    /// components are unchanged.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, date};\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 12:00 UTC).replace_date(date!(2020-01-30)),\n    ///     datetime!(2020-01-30 12:00 UTC)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 0:00 +1).replace_date(date!(2020-01-30)),\n    ///     datetime!(2020-01-30 0:00 +1)\n    /// );\n    /// ```\n    #[must_use = \"This method does not mutate the original `OffsetDateTime`.\"]\n    pub const fn replace_date(self, date: Date) -> Self {\n        self.utc_datetime\n            .utc_to_offset(self.offset)\n            .replace_date(date)\n            .assume_offset(self.offset)\n    }\n\n    /// Replace the date and time, which are assumed to be in the stored offset. The offset\n    /// component remains unchanged.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 12:00 UTC).replace_date_time(datetime!(2020-01-30 16:00)),\n    ///     datetime!(2020-01-30 16:00 UTC)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 12:00 +1).replace_date_time(datetime!(2020-01-30 0:00)),\n    ///     datetime!(2020-01-30 0:00 +1)\n    /// );\n    /// ```\n    #[must_use = \"This method does not mutate the original `OffsetDateTime`.\"]\n    pub const fn replace_date_time(self, date_time: PrimitiveDateTime) -> Self {\n        date_time.assume_offset(self.offset)\n    }\n\n    /// Replace the offset. The date and time components remain unchanged.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, offset};\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 0:00 UTC).replace_offset(offset!(-5)),\n    ///     datetime!(2020-01-01 0:00 -5)\n    /// );\n    /// ```\n    #[must_use = \"This method does not mutate the original `OffsetDateTime`.\"]\n    pub const fn replace_offset(self, offset: UtcOffset) -> Self {\n        self.utc_datetime.assume_offset(offset)\n    }\n}","impl Ord for OffsetDateTime {\n    fn cmp(&self, rhs: &Self) -> Ordering {\n        self.utc_datetime.cmp(&rhs.utc_datetime)\n    }\n}","impl PartialEq for OffsetDateTime {\n    fn eq(&self, rhs: &Self) -> bool {\n        self.utc_datetime.eq(&rhs.utc_datetime)\n    }\n}","impl PartialEq<SystemTime> for OffsetDateTime {\n    fn eq(&self, rhs: &SystemTime) -> bool {\n        self == &Self::from(*rhs)\n    }\n}","impl PartialOrd for OffsetDateTime {\n    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {\n        Some(self.cmp(rhs))\n    }\n}","impl PartialOrd<SystemTime> for OffsetDateTime {\n    fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering> {\n        self.partial_cmp(&Self::from(*other))\n    }\n}","impl Sub for OffsetDateTime {\n    type Output = Duration;\n\n    fn sub(self, rhs: Self) -> Self::Output {\n        self.utc_datetime - rhs.utc_datetime\n    }\n}","impl Sub<SystemTime> for OffsetDateTime {\n    type Output = Duration;\n\n    fn sub(self, rhs: SystemTime) -> Self::Output {\n        self - Self::from(rhs)\n    }\n}","impl core::ops::$op<$t> for $target {\n            fn $fn(&mut self, rhs: $t) {\n                *self = *self $sym rhs;\n            }\n        }","impl fmt::Display for OffsetDateTime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} {} {}\", self.date(), self.time(), self.offset)\n    }\n}","impl<T> Add<T> for OffsetDateTime\nwhere\n    PrimitiveDateTime: Add<T, Output = PrimitiveDateTime>,\n{\n    type Output = Self;\n\n    fn add(self, rhs: T) -> Self::Output {\n        (self.utc_datetime + rhs)\n            .assume_utc()\n            .to_offset(self.offset)\n    }\n}","impl<T> Sub<T> for OffsetDateTime\nwhere\n    PrimitiveDateTime: Sub<T, Output = PrimitiveDateTime>,\n{\n    type Output = Self;\n\n    fn sub(self, rhs: T) -> Self::Output {\n        (self.utc_datetime - rhs)\n            .assume_utc()\n            .to_offset(self.offset)\n    }\n}"],"primitive_date_time::PrimitiveDateTime":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Add<Duration> for PrimitiveDateTime {\n    type Output = Self;\n\n    fn add(self, duration: Duration) -> Self::Output {\n        self.checked_add(duration)\n            .expect(\"resulting value is out of range\")\n    }\n}","impl Add<StdDuration> for PrimitiveDateTime {\n    type Output = Self;\n\n    fn add(self, duration: StdDuration) -> Self::Output {\n        let (is_next_day, time) = self.time.adjusting_add_std(duration);\n\n        Self {\n            date: if is_next_day {\n                (self.date + duration)\n                    .next_day()\n                    .expect(\"resulting value is out of range\")\n            } else {\n                self.date + duration\n            },\n            time,\n        }\n    }\n}","impl PrimitiveDateTime {\n    /// Assuming that the current [`PrimitiveDateTime`] is a value in the provided [`UtcOffset`],\n    /// obtain the equivalent value in the UTC.\n    pub(crate) const fn offset_to_utc(self, offset: UtcOffset) -> Self {\n        let mut second = self.second() as i8 - offset.seconds_past_minute();\n        let mut minute = self.minute() as i8 - offset.minutes_past_hour();\n        let mut hour = self.hour() as i8 - offset.whole_hours();\n        let (mut year, mut ordinal) = self.date.to_ordinal_date();\n\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        cascade!(hour in 0..24 => ordinal);\n        cascade!(ordinal => year);\n\n        Self {\n            date: Date::__from_ordinal_date_unchecked(year, ordinal),\n            time: Time::__from_hms_nanos_unchecked(\n                hour as _,\n                minute as _,\n                second as _,\n                self.nanosecond(),\n            ),\n        }\n    }\n\n    /// Assuming that the current [`PrimitiveDateTime`] is a value in UTC, obtain the equivalent\n    /// value in the provided [`UtcOffset`].\n    pub(crate) const fn utc_to_offset(self, offset: UtcOffset) -> Self {\n        self.offset_to_utc(UtcOffset::__from_hms_unchecked(\n            -offset.whole_hours(),\n            -offset.minutes_past_hour(),\n            -offset.seconds_past_minute(),\n        ))\n    }\n}","impl PrimitiveDateTime {\n    /// Replace the time, preserving the date.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, time};\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 17:00).replace_time(time!(5:00)),\n    ///     datetime!(2020-01-01 5:00)\n    /// );\n    /// ```\n    #[must_use = \"This method does not mutate the original `PrimitiveDateTime`.\"]\n    pub const fn replace_time(self, time: Time) -> Self {\n        self.date.with_time(time)\n    }\n\n    /// Replace the date, preserving the time.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, date};\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 12:00).replace_date(date!(2020-01-30)),\n    ///     datetime!(2020-01-30 12:00)\n    /// );\n    /// ```\n    #[must_use = \"This method does not mutate the original `PrimitiveDateTime`.\"]\n    pub const fn replace_date(self, date: Date) -> Self {\n        date.with_time(self.time)\n    }\n}","impl PrimitiveDateTime {\n    /// The smallest value that can be represented by `PrimitiveDateTime`.\n    ///\n    /// Depending on `large-dates` feature flag, value of this constant may vary.\n    ///\n    /// 1. With `large-dates` disabled it is equal to `-9999 - 01 - 01 00:00:00.0`\n    /// 2. With `large-dates` enabled it is equal to `-999999 - 01 - 01 00:00:00.0`\n    ///\n    /// ```rust\n    /// # use time::{PrimitiveDateTime, macros::datetime};\n    /// // Assuming `large-dates` feature is enabled.\n    /// assert_eq!(PrimitiveDateTime::MIN, datetime!(-999999 - 01 - 01 0:00));\n    /// ```\n    pub const MIN: Self = Self::new(Date::MIN, Time::MIN);\n\n    /// The largest value that can be represented by `PrimitiveDateTime`.\n    ///\n    /// Depending on `large-dates` feature flag, value of this constant may vary.\n    ///\n    /// 1. With `large-dates` disabled it is equal to `9999 - 12 - 31 23:59:59.999_999_999`\n    /// 2. With `large-dates` enabled it is equal to `999999 - 12 - 31 23:59:59.999_999_999`\n    ///\n    /// ```rust\n    /// # use time::{PrimitiveDateTime, macros::datetime};\n    /// // Assuming `large-dates` feature is enabled.\n    /// assert_eq!(PrimitiveDateTime::MAX, datetime!(+999999 - 12 - 31 23:59:59.999_999_999));\n    /// ```\n    pub const MAX: Self = Self::new(Date::MAX, Time::MAX);\n\n    /// Create a new `PrimitiveDateTime` from the provided [`Date`] and [`Time`].\n    ///\n    /// ```rust\n    /// # use time::{PrimitiveDateTime, macros::{date, datetime, time}};\n    /// assert_eq!(\n    ///     PrimitiveDateTime::new(date!(2019-01-01), time!(0:00)),\n    ///     datetime!(2019-01-01 0:00),\n    /// );\n    /// ```\n    pub const fn new(date: Date, time: Time) -> Self {\n        Self { date, time }\n    }\n\n    // region: component getters\n    /// Get the [`Date`] component of the `PrimitiveDateTime`.\n    ///\n    /// ```rust\n    /// # use time::macros::{date, datetime};\n    /// assert_eq!(datetime!(2019-01-01 0:00).date(), date!(2019-01-01));\n    /// ```\n    pub const fn date(self) -> Date {\n        self.date\n    }\n\n    /// Get the [`Time`] component of the `PrimitiveDateTime`.\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, time};\n    /// assert_eq!(datetime!(2019-01-01 0:00).time(), time!(0:00));\n    pub const fn time(self) -> Time {\n        self.time\n    }\n    // endregion component getters\n\n    // region: date getters\n    /// Get the year of the date.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).year(), 2019);\n    /// assert_eq!(datetime!(2019-12-31 0:00).year(), 2019);\n    /// assert_eq!(datetime!(2020-01-01 0:00).year(), 2020);\n    /// ```\n    pub const fn year(self) -> i32 {\n        self.date.year()\n    }\n\n    /// Get the month of the date.\n    ///\n    /// ```rust\n    /// # use time::{macros::datetime, Month};\n    /// assert_eq!(datetime!(2019-01-01 0:00).month(), Month::January);\n    /// assert_eq!(datetime!(2019-12-31 0:00).month(), Month::December);\n    /// ```\n    pub const fn month(self) -> Month {\n        self.date.month()\n    }\n\n    /// Get the day of the date.\n    ///\n    /// The returned value will always be in the range `1..=31`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).day(), 1);\n    /// assert_eq!(datetime!(2019-12-31 0:00).day(), 31);\n    /// ```\n    pub const fn day(self) -> u8 {\n        self.date.day()\n    }\n\n    /// Get the day of the year.\n    ///\n    /// The returned value will always be in the range `1..=366` (`1..=365` for common years).\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).ordinal(), 1);\n    /// assert_eq!(datetime!(2019-12-31 0:00).ordinal(), 365);\n    /// ```\n    pub const fn ordinal(self) -> u16 {\n        self.date.ordinal()\n    }\n\n    /// Get the ISO week number.\n    ///\n    /// The returned value will always be in the range `1..=53`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).iso_week(), 1);\n    /// assert_eq!(datetime!(2019-10-04 0:00).iso_week(), 40);\n    /// assert_eq!(datetime!(2020-01-01 0:00).iso_week(), 1);\n    /// assert_eq!(datetime!(2020-12-31 0:00).iso_week(), 53);\n    /// assert_eq!(datetime!(2021-01-01 0:00).iso_week(), 53);\n    /// ```\n    pub const fn iso_week(self) -> u8 {\n        self.date.iso_week()\n    }\n\n    /// Get the week number where week 1 begins on the first Sunday.\n    ///\n    /// The returned value will always be in the range `0..=53`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).sunday_based_week(), 0);\n    /// assert_eq!(datetime!(2020-01-01 0:00).sunday_based_week(), 0);\n    /// assert_eq!(datetime!(2020-12-31 0:00).sunday_based_week(), 52);\n    /// assert_eq!(datetime!(2021-01-01 0:00).sunday_based_week(), 0);\n    /// ```\n    pub const fn sunday_based_week(self) -> u8 {\n        self.date.sunday_based_week()\n    }\n\n    /// Get the week number where week 1 begins on the first Monday.\n    ///\n    /// The returned value will always be in the range `0..=53`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).monday_based_week(), 0);\n    /// assert_eq!(datetime!(2020-01-01 0:00).monday_based_week(), 0);\n    /// assert_eq!(datetime!(2020-12-31 0:00).monday_based_week(), 52);\n    /// assert_eq!(datetime!(2021-01-01 0:00).monday_based_week(), 0);\n    /// ```\n    pub const fn monday_based_week(self) -> u8 {\n        self.date.monday_based_week()\n    }\n\n    /// Get the year, month, and day.\n    ///\n    /// ```rust\n    /// # use time::{macros::datetime, Month};\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 0:00).to_calendar_date(),\n    ///     (2019, Month::January, 1)\n    /// );\n    /// ```\n    pub const fn to_calendar_date(self) -> (i32, Month, u8) {\n        self.date.to_calendar_date()\n    }\n\n    /// Get the year and ordinal day number.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).to_ordinal_date(), (2019, 1));\n    /// ```\n    pub const fn to_ordinal_date(self) -> (i32, u16) {\n        self.date.to_ordinal_date()\n    }\n\n    /// Get the ISO 8601 year, week number, and weekday.\n    ///\n    /// ```rust\n    /// # use time::{Weekday::*, macros::datetime};\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 0:00).to_iso_week_date(),\n    ///     (2019, 1, Tuesday)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2019-10-04 0:00).to_iso_week_date(),\n    ///     (2019, 40, Friday)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 0:00).to_iso_week_date(),\n    ///     (2020, 1, Wednesday)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2020-12-31 0:00).to_iso_week_date(),\n    ///     (2020, 53, Thursday)\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2021-01-01 0:00).to_iso_week_date(),\n    ///     (2020, 53, Friday)\n    /// );\n    /// ```\n    pub const fn to_iso_week_date(self) -> (i32, u8, Weekday) {\n        self.date.to_iso_week_date()\n    }\n\n    /// Get the weekday.\n    ///\n    /// ```rust\n    /// # use time::{Weekday::*, macros::datetime};\n    /// assert_eq!(datetime!(2019-01-01 0:00).weekday(), Tuesday);\n    /// assert_eq!(datetime!(2019-02-01 0:00).weekday(), Friday);\n    /// assert_eq!(datetime!(2019-03-01 0:00).weekday(), Friday);\n    /// assert_eq!(datetime!(2019-04-01 0:00).weekday(), Monday);\n    /// assert_eq!(datetime!(2019-05-01 0:00).weekday(), Wednesday);\n    /// assert_eq!(datetime!(2019-06-01 0:00).weekday(), Saturday);\n    /// assert_eq!(datetime!(2019-07-01 0:00).weekday(), Monday);\n    /// assert_eq!(datetime!(2019-08-01 0:00).weekday(), Thursday);\n    /// assert_eq!(datetime!(2019-09-01 0:00).weekday(), Sunday);\n    /// assert_eq!(datetime!(2019-10-01 0:00).weekday(), Tuesday);\n    /// assert_eq!(datetime!(2019-11-01 0:00).weekday(), Friday);\n    /// assert_eq!(datetime!(2019-12-01 0:00).weekday(), Sunday);\n    /// ```\n    pub const fn weekday(self) -> Weekday {\n        self.date.weekday()\n    }\n\n    /// Get the Julian day for the date. The time is not taken into account for this calculation.\n    ///\n    /// The algorithm to perform this conversion is derived from one provided by Peter Baum; it is\n    /// freely available [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(-4713-11-24 0:00).to_julian_day(), 0);\n    /// assert_eq!(datetime!(2000-01-01 0:00).to_julian_day(), 2_451_545);\n    /// assert_eq!(datetime!(2019-01-01 0:00).to_julian_day(), 2_458_485);\n    /// assert_eq!(datetime!(2019-12-31 0:00).to_julian_day(), 2_458_849);\n    /// ```\n    pub const fn to_julian_day(self) -> i32 {\n        self.date.to_julian_day()\n    }\n    // endregion date getters\n\n    // region: time getters\n    /// Get the clock hour, minute, and second.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2020-01-01 0:00:00).as_hms(), (0, 0, 0));\n    /// assert_eq!(datetime!(2020-01-01 23:59:59).as_hms(), (23, 59, 59));\n    /// ```\n    pub const fn as_hms(self) -> (u8, u8, u8) {\n        self.time.as_hms()\n    }\n\n    /// Get the clock hour, minute, second, and millisecond.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2020-01-01 0:00:00).as_hms_milli(), (0, 0, 0, 0));\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 23:59:59.999).as_hms_milli(),\n    ///     (23, 59, 59, 999)\n    /// );\n    /// ```\n    pub const fn as_hms_milli(self) -> (u8, u8, u8, u16) {\n        self.time.as_hms_milli()\n    }\n\n    /// Get the clock hour, minute, second, and microsecond.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2020-01-01 0:00:00).as_hms_micro(), (0, 0, 0, 0));\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 23:59:59.999_999).as_hms_micro(),\n    ///     (23, 59, 59, 999_999)\n    /// );\n    /// ```\n    pub const fn as_hms_micro(self) -> (u8, u8, u8, u32) {\n        self.time.as_hms_micro()\n    }\n\n    /// Get the clock hour, minute, second, and nanosecond.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2020-01-01 0:00:00).as_hms_nano(), (0, 0, 0, 0));\n    /// assert_eq!(\n    ///     datetime!(2020-01-01 23:59:59.999_999_999).as_hms_nano(),\n    ///     (23, 59, 59, 999_999_999)\n    /// );\n    /// ```\n    pub const fn as_hms_nano(self) -> (u8, u8, u8, u32) {\n        self.time.as_hms_nano()\n    }\n\n    /// Get the clock hour.\n    ///\n    /// The returned value will always be in the range `0..24`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).hour(), 0);\n    /// assert_eq!(datetime!(2019-01-01 23:59:59).hour(), 23);\n    /// ```\n    pub const fn hour(self) -> u8 {\n        self.time.hour()\n    }\n\n    /// Get the minute within the hour.\n    ///\n    /// The returned value will always be in the range `0..60`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).minute(), 0);\n    /// assert_eq!(datetime!(2019-01-01 23:59:59).minute(), 59);\n    /// ```\n    pub const fn minute(self) -> u8 {\n        self.time.minute()\n    }\n\n    /// Get the second within the minute.\n    ///\n    /// The returned value will always be in the range `0..60`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).second(), 0);\n    /// assert_eq!(datetime!(2019-01-01 23:59:59).second(), 59);\n    /// ```\n    pub const fn second(self) -> u8 {\n        self.time.second()\n    }\n\n    /// Get the milliseconds within the second.\n    ///\n    /// The returned value will always be in the range `0..1_000`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).millisecond(), 0);\n    /// assert_eq!(datetime!(2019-01-01 23:59:59.999).millisecond(), 999);\n    /// ```\n    pub const fn millisecond(self) -> u16 {\n        self.time.millisecond()\n    }\n\n    /// Get the microseconds within the second.\n    ///\n    /// The returned value will always be in the range `0..1_000_000`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).microsecond(), 0);\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 23:59:59.999_999).microsecond(),\n    ///     999_999\n    /// );\n    /// ```\n    pub const fn microsecond(self) -> u32 {\n        self.time.microsecond()\n    }\n\n    /// Get the nanoseconds within the second.\n    ///\n    /// The returned value will always be in the range `0..1_000_000_000`.\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(datetime!(2019-01-01 0:00).nanosecond(), 0);\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 23:59:59.999_999_999).nanosecond(),\n    ///     999_999_999,\n    /// );\n    /// ```\n    pub const fn nanosecond(self) -> u32 {\n        self.time.nanosecond()\n    }\n    // endregion time getters\n\n    // region: attach offset\n    /// Assuming that the existing `PrimitiveDateTime` represents a moment in the provided\n    /// [`UtcOffset`], return an [`OffsetDateTime`].\n    ///\n    /// ```rust\n    /// # use time::macros::{datetime, offset};\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 0:00)\n    ///         .assume_offset(offset!(UTC))\n    ///         .unix_timestamp(),\n    ///     1_546_300_800,\n    /// );\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 0:00)\n    ///         .assume_offset(offset!(-1))\n    ///         .unix_timestamp(),\n    ///     1_546_304_400,\n    /// );\n    /// ```\n    pub const fn assume_offset(self, offset: UtcOffset) -> OffsetDateTime {\n        OffsetDateTime {\n            utc_datetime: self.offset_to_utc(offset),\n            offset,\n        }\n    }\n\n    /// Assuming that the existing `PrimitiveDateTime` represents a moment in UTC, return an\n    /// [`OffsetDateTime`].\n    ///\n    /// ```rust\n    /// # use time::macros::datetime;\n    /// assert_eq!(\n    ///     datetime!(2019-01-01 0:00).assume_utc().unix_timestamp(),\n    ///     1_546_300_800,\n    /// );\n    /// ```\n    pub const fn assume_utc(self) -> OffsetDateTime {\n        OffsetDateTime {\n            utc_datetime: self,\n            offset: UtcOffset::UTC,\n        }\n    }\n    // endregion attach offset\n\n    // region: checked arithmetic\n    /// Computes `self + duration`, returning `None` if an overflow occurred.\n    ///\n    /// ```\n    /// # use time::{Date, ext::NumericalDuration};\n    /// # use time::macros::datetime;\n    /// let datetime = Date::MIN.midnight();\n    /// assert_eq!(datetime.checked_add((-2).days()), None);\n    ///\n    /// let datetime = Date::MAX.midnight();\n    /// assert_eq!(datetime.checked_add(1.days()), None);\n    ///\n    /// assert_eq!(\n    ///     datetime!(2019 - 11 - 25 15:30).checked_add(27.hours()),\n    ///     Some(datetime!(2019 - 11 - 26 18:30))\n    /// );\n    /// ```\n    pub const fn checked_add(self, duration: Duration) -> Option<Self> {\n        let (date_adjustment, time) = self.time.adjusting_add(duration);\n        let date = const_try_opt!(self.date.checked_add(duration));\n\n        Some(Self {\n            date: match date_adjustment {\n                util::DateAdjustment::Previous => const_try_opt!(date.previous_day()),\n                util::DateAdjustment::Next => const_try_opt!(date.next_day()),\n                util::DateAdjustment::None => date,\n            },\n            time,\n        })\n    }\n\n    /// Computes `self - duration`, returning `None` if an overflow occurred.\n    ///\n    /// ```\n    /// # use time::{Date, ext::NumericalDuration};\n    /// # use time::macros::datetime;\n    /// let datetime = Date::MIN.midnight();\n    /// assert_eq!(datetime.checked_sub(2.days()), None);\n    ///\n    /// let datetime = Date::MAX.midnight();\n    /// assert_eq!(datetime.checked_sub((-1).days()), None);\n    ///\n    /// assert_eq!(\n    ///     datetime!(2019 - 11 - 25 15:30).checked_sub(27.hours()),\n    ///     Some(datetime!(2019 - 11 - 24 12:30))\n    /// );\n    /// ```\n    pub const fn checked_sub(self, duration: Duration) -> Option<Self> {\n        let (date_adjustment, time) = self.time.adjusting_sub(duration);\n        let date = const_try_opt!(self.date.checked_sub(duration));\n\n        Some(Self {\n            date: match date_adjustment {\n                util::DateAdjustment::Previous => const_try_opt!(date.previous_day()),\n                util::DateAdjustment::Next => const_try_opt!(date.next_day()),\n                util::DateAdjustment::None => date,\n            },\n            time,\n        })\n    }\n    // endregion: checked arithmetic\n\n    // region: saturating arithmetic\n    /// Computes `self + duration`, saturating value on overflow.\n    ///\n    /// ```\n    /// # use time::{PrimitiveDateTime, ext::NumericalDuration};\n    /// # use time::macros::datetime;\n    /// assert_eq!(\n    ///     PrimitiveDateTime::MIN.saturating_add((-2).days()),\n    ///     PrimitiveDateTime::MIN\n    /// );\n    ///\n    /// assert_eq!(\n    ///     PrimitiveDateTime::MAX.saturating_add(2.days()),\n    ///     PrimitiveDateTime::MAX\n    /// );\n    ///\n    /// assert_eq!(\n    ///     datetime!(2019 - 11 - 25 15:30).saturating_add(27.hours()),\n    ///     datetime!(2019 - 11 - 26 18:30)\n    /// );\n    /// ```\n    pub const fn saturating_add(self, duration: Duration) -> Self {\n        if let Some(datetime) = self.checked_add(duration) {\n            datetime\n        } else if duration.is_negative() {\n            Self::MIN\n        } else {\n            Self::MAX\n        }\n    }\n\n    /// Computes `self - duration`, saturating value on overflow.\n    ///\n    /// ```\n    /// # use time::{PrimitiveDateTime, ext::NumericalDuration};\n    /// # use time::macros::datetime;\n    /// assert_eq!(\n    ///     PrimitiveDateTime::MIN.saturating_sub(2.days()),\n    ///     PrimitiveDateTime::MIN\n    /// );\n    ///\n    /// assert_eq!(\n    ///     PrimitiveDateTime::MAX.saturating_sub((-2).days()),\n    ///     PrimitiveDateTime::MAX\n    /// );\n    ///\n    /// assert_eq!(\n    ///     datetime!(2019 - 11 - 25 15:30).saturating_sub(27.hours()),\n    ///     datetime!(2019 - 11 - 24 12:30)\n    /// );\n    /// ```\n    pub const fn saturating_sub(self, duration: Duration) -> Self {\n        if let Some(datetime) = self.checked_sub(duration) {\n            datetime\n        } else if duration.is_negative() {\n            Self::MAX\n        } else {\n            Self::MIN\n        }\n    }\n    // endregion: saturating arithmetic\n}","impl Sub for PrimitiveDateTime {\n    type Output = Duration;\n\n    fn sub(self, rhs: Self) -> Self::Output {\n        (self.date - rhs.date) + (self.time - rhs.time)\n    }\n}","impl Sub<Duration> for PrimitiveDateTime {\n    type Output = Self;\n\n    fn sub(self, duration: Duration) -> Self::Output {\n        self.checked_sub(duration)\n            .expect(\"resulting value is out of range\")\n    }\n}","impl Sub<StdDuration> for PrimitiveDateTime {\n    type Output = Self;\n\n    fn sub(self, duration: StdDuration) -> Self::Output {\n        let (is_previous_day, time) = self.time.adjusting_sub_std(duration);\n\n        Self {\n            date: if is_previous_day {\n                (self.date - duration)\n                    .previous_day()\n                    .expect(\"resulting value is out of range\")\n            } else {\n                self.date - duration\n            },\n            time,\n        }\n    }\n}","impl core::ops::$op<$t> for $target {\n            fn $fn(&mut self, rhs: $t) {\n                *self = *self $sym rhs;\n            }\n        }","impl fmt::Display for PrimitiveDateTime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} {}\", self.date, self.time)\n    }\n}"],"std::time::Duration":["impl Add<Duration> for StdDuration {\n    type Output = Duration;\n\n    fn add(self, rhs: Duration) -> Self::Output {\n        rhs + self\n    }\n}","impl Div<Duration> for StdDuration {\n    type Output = f64;\n\n    fn div(self, rhs: Duration) -> Self::Output {\n        self.as_secs_f64() / rhs.as_seconds_f64()\n    }\n}","impl PartialEq<Duration> for StdDuration {\n    fn eq(&self, rhs: &Duration) -> bool {\n        rhs == self\n    }\n}","impl PartialOrd<Duration> for StdDuration {\n    fn partial_cmp(&self, rhs: &Duration) -> Option<Ordering> {\n        rhs.partial_cmp(self).map(Ordering::reverse)\n    }\n}","impl Sub<Duration> for StdDuration {\n    type Output = Duration;\n\n    fn sub(self, rhs: Duration) -> Self::Output {\n        Duration::try_from(self)\n            .expect(\"overflow converting `std::time::Duration` to `time::Duration`\")\n            - rhs\n    }\n}","impl SubAssign<Duration> for StdDuration {\n    fn sub_assign(&mut self, rhs: Duration) {\n        *self = (*self - rhs).try_into().expect(\n            \"Cannot represent a resulting duration in std. Try `let x = x - rhs;`, which will \\\n             change the type.\",\n        );\n    }\n}","impl TryFrom<Duration> for StdDuration {\n    type Error = error::ConversionRange;\n\n    fn try_from(duration: Duration) -> Result<Self, error::ConversionRange> {\n        Ok(Self::new(\n            duration\n                .seconds\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n            duration\n                .nanoseconds\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n        ))\n    }\n}"],"std::time::Instant":["impl Add<Duration> for StdInstant {\n    type Output = Self;\n\n    fn add(self, duration: Duration) -> Self::Output {\n        (Instant(self) + duration).0\n    }\n}","impl From<Instant> for StdInstant {\n    fn from(instant: Instant) -> Self {\n        instant.0\n    }\n}","impl PartialEq<Instant> for StdInstant {\n    fn eq(&self, rhs: &Instant) -> bool {\n        self.eq(&rhs.0)\n    }\n}","impl PartialOrd<Instant> for StdInstant {\n    fn partial_cmp(&self, rhs: &Instant) -> Option<Ordering> {\n        self.partial_cmp(&rhs.0)\n    }\n}","impl Sub<Duration> for StdInstant {\n    type Output = Self;\n\n    fn sub(self, duration: Duration) -> Self::Output {\n        (Instant(self) - duration).0\n    }\n}","impl Sub<Instant> for StdInstant {\n    type Output = Duration;\n\n    fn sub(self, other: Instant) -> Self::Output {\n        Instant(self) - other\n    }\n}","impl core::ops::$op<$t> for $target {\n            fn $fn(&mut self, rhs: $t) {\n                *self = *self $sym rhs;\n            }\n        }"],"std::time::SystemTime":["impl Add<Duration> for SystemTime {\n    type Output = Self;\n\n    fn add(self, duration: Duration) -> Self::Output {\n        if duration.is_zero() {\n            self\n        } else if duration.is_positive() {\n            self + duration.abs_std()\n        } else {\n            debug_assert!(duration.is_negative());\n            self - duration.abs_std()\n        }\n    }\n}","impl From<OffsetDateTime> for SystemTime {\n    fn from(datetime: OffsetDateTime) -> Self {\n        let duration = datetime - OffsetDateTime::UNIX_EPOCH;\n\n        if duration.is_zero() {\n            Self::UNIX_EPOCH\n        } else if duration.is_positive() {\n            Self::UNIX_EPOCH + duration.abs_std()\n        } else {\n            debug_assert!(duration.is_negative());\n            Self::UNIX_EPOCH - duration.abs_std()\n        }\n    }\n}","impl PartialEq<OffsetDateTime> for SystemTime {\n    fn eq(&self, rhs: &OffsetDateTime) -> bool {\n        &OffsetDateTime::from(*self) == rhs\n    }\n}","impl PartialOrd<OffsetDateTime> for SystemTime {\n    fn partial_cmp(&self, other: &OffsetDateTime) -> Option<Ordering> {\n        OffsetDateTime::from(*self).partial_cmp(other)\n    }\n}","impl Sub<Duration> for SystemTime {\n    type Output = Self;\n\n    fn sub(self, duration: Duration) -> Self::Output {\n        (OffsetDateTime::from(self) - duration).into()\n    }\n}","impl Sub<OffsetDateTime> for SystemTime {\n    type Output = Duration;\n\n    fn sub(self, rhs: OffsetDateTime) -> Self::Output {\n        OffsetDateTime::from(self) - rhs\n    }\n}","impl core::ops::$op<$t> for $target {\n            fn $fn(&mut self, rhs: $t) {\n                *self = *self $sym rhs;\n            }\n        }"],"time::Padding":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd"],"time::Time":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl Add<Duration> for Time {\n    type Output = Self;\n\n    /// Add the sub-day time of the [`Duration`] to the `Time`. Wraps on overflow.\n    ///\n    /// ```rust\n    /// # use time::{ext::NumericalDuration, macros::time};\n    /// assert_eq!(time!(12:00) + 2.hours(), time!(14:00));\n    /// assert_eq!(time!(0:00:01) + (-2).seconds(), time!(23:59:59));\n    /// ```\n    fn add(self, duration: Duration) -> Self::Output {\n        self.adjusting_add(duration).1\n    }\n}","impl Add<StdDuration> for Time {\n    type Output = Self;\n\n    /// Add the sub-day time of the [`std::time::Duration`] to the `Time`. Wraps on overflow.\n    ///\n    /// ```rust\n    /// # use time::{ext::NumericalStdDuration, macros::time};\n    /// assert_eq!(time!(12:00) + 2.std_hours(), time!(14:00));\n    /// assert_eq!(time!(23:59:59) + 2.std_seconds(), time!(0:00:01));\n    /// ```\n    fn add(self, duration: StdDuration) -> Self::Output {\n        self.adjusting_add_std(duration).1\n    }\n}","impl Sub for Time {\n    type Output = Duration;\n\n    /// Subtract two `Time`s, returning the [`Duration`] between. This assumes both `Time`s are in\n    /// the same calendar day.\n    ///\n    /// ```rust\n    /// # use time::{ext::NumericalDuration, macros::time};\n    /// assert_eq!(time!(0:00) - time!(0:00), 0.seconds());\n    /// assert_eq!(time!(1:00) - time!(0:00), 1.hours());\n    /// assert_eq!(time!(0:00) - time!(1:00), (-1).hours());\n    /// assert_eq!(time!(0:00) - time!(23:00), (-23).hours());\n    /// ```\n    fn sub(self, rhs: Self) -> Self::Output {\n        let hour_diff = (self.hour as i8) - (rhs.hour as i8);\n        let minute_diff = (self.minute as i8) - (rhs.minute as i8);\n        let mut second_diff = (self.second as i8) - (rhs.second as i8);\n        let mut nanosecond_diff = (self.nanosecond as i32) - (rhs.nanosecond as i32);\n\n        cascade!(nanosecond_diff in 0..1_000_000_000 => second_diff);\n\n        Duration::new_unchecked(\n            hour_diff as i64 * 3_600 + minute_diff as i64 * 60 + second_diff as i64,\n            nanosecond_diff,\n        )\n    }\n}","impl Sub<Duration> for Time {\n    type Output = Self;\n\n    /// Subtract the sub-day time of the [`Duration`] from the `Time`. Wraps on overflow.\n    ///\n    /// ```rust\n    /// # use time::{ext::NumericalDuration, macros::time};\n    /// assert_eq!(time!(14:00) - 2.hours(), time!(12:00));\n    /// assert_eq!(time!(23:59:59) - (-2).seconds(), time!(0:00:01));\n    /// ```\n    fn sub(self, duration: Duration) -> Self::Output {\n        self.adjusting_sub(duration).1\n    }\n}","impl Sub<StdDuration> for Time {\n    type Output = Self;\n\n    /// Subtract the sub-day time of the [`std::time::Duration`] from the `Time`. Wraps on overflow.\n    ///\n    /// ```rust\n    /// # use time::{ext::NumericalStdDuration, macros::time};\n    /// assert_eq!(time!(14:00) - 2.std_hours(), time!(12:00));\n    /// assert_eq!(time!(0:00:01) - 2.std_seconds(), time!(23:59:59));\n    /// ```\n    fn sub(self, duration: StdDuration) -> Self::Output {\n        self.adjusting_sub_std(duration).1\n    }\n}","impl Time {\n    /// Create a `Time` that is exactly midnight.\n    ///\n    /// ```rust\n    /// # use time::{Time, macros::time};\n    /// assert_eq!(Time::MIDNIGHT, time!(0:00));\n    /// ```\n    pub const MIDNIGHT: Self = Self::__from_hms_nanos_unchecked(0, 0, 0, 0);\n\n    /// The smallest value that can be represented by `Time`.\n    ///\n    /// `00:00:00.0`\n    pub(crate) const MIN: Self = Self::__from_hms_nanos_unchecked(0, 0, 0, 0);\n\n    /// The largest value that can be represented by `Time`.\n    ///\n    /// `23:59:59.999_999_999`\n    pub(crate) const MAX: Self = Self::__from_hms_nanos_unchecked(23, 59, 59, 999_999_999);\n\n    // region: constructors\n    /// Create a `Time` from its components.\n    #[doc(hidden)]\n    pub const fn __from_hms_nanos_unchecked(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> Self {\n        Self {\n            hour,\n            minute,\n            second,\n            nanosecond,\n            padding: Padding::Optimize,\n        }\n    }\n\n    /// Attempt to create a `Time` from the hour, minute, and second.\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::from_hms(1, 2, 3).is_ok());\n    /// ```\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::from_hms(24, 0, 0).is_err()); // 24 isn't a valid hour.\n    /// assert!(Time::from_hms(0, 60, 0).is_err()); // 60 isn't a valid minute.\n    /// assert!(Time::from_hms(0, 0, 60).is_err()); // 60 isn't a valid second.\n    /// ```\n    pub const fn from_hms(hour: u8, minute: u8, second: u8) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        Ok(Self::__from_hms_nanos_unchecked(hour, minute, second, 0))\n    }\n\n    /// Attempt to create a `Time` from the hour, minute, second, and millisecond.\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::from_hms_milli(1, 2, 3, 4).is_ok());\n    /// ```\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::from_hms_milli(24, 0, 0, 0).is_err()); // 24 isn't a valid hour.\n    /// assert!(Time::from_hms_milli(0, 60, 0, 0).is_err()); // 60 isn't a valid minute.\n    /// assert!(Time::from_hms_milli(0, 0, 60, 0).is_err()); // 60 isn't a valid second.\n    /// assert!(Time::from_hms_milli(0, 0, 0, 1_000).is_err()); // 1_000 isn't a valid millisecond.\n    /// ```\n    pub const fn from_hms_milli(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        millisecond: u16,\n    ) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        ensure_value_in_range!(millisecond in 0 => 999);\n        Ok(Self::__from_hms_nanos_unchecked(\n            hour,\n            minute,\n            second,\n            millisecond as u32 * 1_000_000,\n        ))\n    }\n\n    /// Attempt to create a `Time` from the hour, minute, second, and microsecond.\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::from_hms_micro(1, 2, 3, 4).is_ok());\n    /// ```\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::from_hms_micro(24, 0, 0, 0).is_err()); // 24 isn't a valid hour.\n    /// assert!(Time::from_hms_micro(0, 60, 0, 0).is_err()); // 60 isn't a valid minute.\n    /// assert!(Time::from_hms_micro(0, 0, 60, 0).is_err()); // 60 isn't a valid second.\n    /// assert!(Time::from_hms_micro(0, 0, 0, 1_000_000).is_err()); // 1_000_000 isn't a valid microsecond.\n    /// ```\n    pub const fn from_hms_micro(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        microsecond: u32,\n    ) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        ensure_value_in_range!(microsecond in 0 => 999_999);\n        Ok(Self::__from_hms_nanos_unchecked(\n            hour,\n            minute,\n            second,\n            microsecond * 1_000,\n        ))\n    }\n\n    /// Attempt to create a `Time` from the hour, minute, second, and nanosecond.\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::from_hms_nano(1, 2, 3, 4).is_ok());\n    /// ```\n    ///\n    /// ```rust\n    /// # use time::Time;\n    /// assert!(Time::from_hms_nano(24, 0, 0, 0).is_err()); // 24 isn't a valid hour.\n    /// assert!(Time::from_hms_nano(0, 60, 0, 0).is_err()); // 60 isn't a valid minute.\n    /// assert!(Time::from_hms_nano(0, 0, 60, 0).is_err()); // 60 isn't a valid second.\n    /// assert!(Time::from_hms_nano(0, 0, 0, 1_000_000_000).is_err()); // 1_000_000_000 isn't a valid nanosecond.\n    /// ```\n    pub const fn from_hms_nano(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        ensure_value_in_range!(nanosecond in 0 => 999_999_999);\n        Ok(Self::__from_hms_nanos_unchecked(\n            hour, minute, second, nanosecond,\n        ))\n    }\n    // endregion constructors\n\n    // region: getters\n    /// Get the clock hour, minute, and second.\n    ///\n    /// ```rust\n    /// # use time::macros::time;\n    /// assert_eq!(time!(0:00:00).as_hms(), (0, 0, 0));\n    /// assert_eq!(time!(23:59:59).as_hms(), (23, 59, 59));\n    /// ```\n    pub const fn as_hms(self) -> (u8, u8, u8) {\n        (self.hour, self.minute, self.second)\n    }\n\n    /// Get the clock hour, minute, second, and millisecond.\n    ///\n    /// ```rust\n    /// # use time::macros::time;\n    /// assert_eq!(time!(0:00:00).as_hms_milli(), (0, 0, 0, 0));\n    /// assert_eq!(time!(23:59:59.999).as_hms_milli(), (23, 59, 59, 999));\n    /// ```\n    pub const fn as_hms_milli(self) -> (u8, u8, u8, u16) {\n        (\n            self.hour,\n            self.minute,\n            self.second,\n            (self.nanosecond / 1_000_000) as u16,\n        )\n    }\n\n    /// Get the clock hour, minute, second, and microsecond.\n    ///\n    /// ```rust\n    /// # use time::macros::time;\n    /// assert_eq!(time!(0:00:00).as_hms_micro(), (0, 0, 0, 0));\n    /// assert_eq!(\n    ///     time!(23:59:59.999_999).as_hms_micro(),\n    ///     (23, 59, 59, 999_999)\n    /// );\n    /// ```\n    pub const fn as_hms_micro(self) -> (u8, u8, u8, u32) {\n        (self.hour, self.minute, self.second, self.nanosecond / 1_000)\n    }\n\n    /// Get the clock hour, minute, second, and nanosecond.\n    ///\n    /// ```rust\n    /// # use time::macros::time;\n    /// assert_eq!(time!(0:00:00).as_hms_nano(), (0, 0, 0, 0));\n    /// assert_eq!(\n    ///     time!(23:59:59.999_999_999).as_hms_nano(),\n    ///     (23, 59, 59, 999_999_999)\n    /// );\n    /// ```\n    pub const fn as_hms_nano(self) -> (u8, u8, u8, u32) {\n        (self.hour, self.minute, self.second, self.nanosecond)\n    }\n\n    /// Get the clock hour.\n    ///\n    /// The returned value will always be in the range `0..24`.\n    ///\n    /// ```rust\n    /// # use time::macros::time;\n    /// assert_eq!(time!(0:00:00).hour(), 0);\n    /// assert_eq!(time!(23:59:59).hour(), 23);\n    /// ```\n    pub const fn hour(self) -> u8 {\n        self.hour\n    }\n\n    /// Get the minute within the hour.\n    ///\n    /// The returned value will always be in the range `0..60`.\n    ///\n    /// ```rust\n    /// # use time::macros::time;\n    /// assert_eq!(time!(0:00:00).minute(), 0);\n    /// assert_eq!(time!(23:59:59).minute(), 59);\n    /// ```\n    pub const fn minute(self) -> u8 {\n        self.minute\n    }\n\n    /// Get the second within the minute.\n    ///\n    /// The returned value will always be in the range `0..60`.\n    ///\n    /// ```rust\n    /// # use time::macros::time;\n    /// assert_eq!(time!(0:00:00).second(), 0);\n    /// assert_eq!(time!(23:59:59).second(), 59);\n    /// ```\n    pub const fn second(self) -> u8 {\n        self.second\n    }\n\n    /// Get the milliseconds within the second.\n    ///\n    /// The returned value will always be in the range `0..1_000`.\n    ///\n    /// ```rust\n    /// # use time::macros::time;\n    /// assert_eq!(time!(0:00).millisecond(), 0);\n    /// assert_eq!(time!(23:59:59.999).millisecond(), 999);\n    /// ```\n    pub const fn millisecond(self) -> u16 {\n        (self.nanosecond / 1_000_000) as _\n    }\n\n    /// Get the microseconds within the second.\n    ///\n    /// The returned value will always be in the range `0..1_000_000`.\n    ///\n    /// ```rust\n    /// # use time::macros::time;\n    /// assert_eq!(time!(0:00).microsecond(), 0);\n    /// assert_eq!(time!(23:59:59.999_999).microsecond(), 999_999);\n    /// ```\n    pub const fn microsecond(self) -> u32 {\n        self.nanosecond / 1_000\n    }\n\n    /// Get the nanoseconds within the second.\n    ///\n    /// The returned value will always be in the range `0..1_000_000_000`.\n    ///\n    /// ```rust\n    /// # use time::macros::time;\n    /// assert_eq!(time!(0:00).nanosecond(), 0);\n    /// assert_eq!(time!(23:59:59.999_999_999).nanosecond(), 999_999_999);\n    /// ```\n    pub const fn nanosecond(self) -> u32 {\n        self.nanosecond\n    }\n    // endregion getters\n\n    // region: arithmetic helpers\n    /// Add the sub-day time of the [`Duration`] to the `Time`. Wraps on overflow, returning whether\n    /// the date is different.\n    pub(crate) const fn adjusting_add(self, duration: Duration) -> (DateAdjustment, Self) {\n        let mut nanoseconds = self.nanosecond as i32 + duration.subsec_nanoseconds();\n        let mut seconds = self.second as i8 + (duration.whole_seconds() % 60) as i8;\n        let mut minutes = self.minute as i8 + (duration.whole_minutes() % 60) as i8;\n        let mut hours = self.hour as i8 + (duration.whole_hours() % 24) as i8;\n        let mut date_adjustment = DateAdjustment::None;\n\n        cascade!(nanoseconds in 0..1_000_000_000 => seconds);\n        cascade!(seconds in 0..60 => minutes);\n        cascade!(minutes in 0..60 => hours);\n        if hours >= 24 {\n            hours -= 24;\n            date_adjustment = DateAdjustment::Next;\n        } else if hours < 0 {\n            hours += 24;\n            date_adjustment = DateAdjustment::Previous;\n        }\n\n        (\n            date_adjustment,\n            Self::__from_hms_nanos_unchecked(\n                hours as _,\n                minutes as _,\n                seconds as _,\n                nanoseconds as _,\n            ),\n        )\n    }\n\n    /// Subtract the sub-day time of the [`Duration`] to the `Time`. Wraps on overflow, returning\n    /// whether the date is different.\n    pub(crate) const fn adjusting_sub(self, duration: Duration) -> (DateAdjustment, Self) {\n        let mut nanoseconds = self.nanosecond as i32 - duration.subsec_nanoseconds();\n        let mut seconds = self.second as i8 - (duration.whole_seconds() % 60) as i8;\n        let mut minutes = self.minute as i8 - (duration.whole_minutes() % 60) as i8;\n        let mut hours = self.hour as i8 - (duration.whole_hours() % 24) as i8;\n        let mut date_adjustment = DateAdjustment::None;\n\n        cascade!(nanoseconds in 0..1_000_000_000 => seconds);\n        cascade!(seconds in 0..60 => minutes);\n        cascade!(minutes in 0..60 => hours);\n        if hours >= 24 {\n            hours -= 24;\n            date_adjustment = DateAdjustment::Next;\n        } else if hours < 0 {\n            hours += 24;\n            date_adjustment = DateAdjustment::Previous;\n        }\n\n        (\n            date_adjustment,\n            Self::__from_hms_nanos_unchecked(\n                hours as _,\n                minutes as _,\n                seconds as _,\n                nanoseconds as _,\n            ),\n        )\n    }\n\n    /// Add the sub-day time of the [`std::time::Duration`] to the `Time`. Wraps on overflow,\n    /// returning whether the date is the previous date as the first element of the tuple.\n    pub(crate) const fn adjusting_add_std(self, duration: StdDuration) -> (bool, Self) {\n        let mut nanosecond = self.nanosecond + duration.subsec_nanos();\n        let mut second = self.second + (duration.as_secs() % 60) as u8;\n        let mut minute = self.minute + ((duration.as_secs() / 60) % 60) as u8;\n        let mut hour = self.hour + ((duration.as_secs() / 3_600) % 24) as u8;\n        let mut is_next_day = false;\n\n        cascade!(nanosecond in 0..1_000_000_000 => second);\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        if hour >= 24 {\n            hour -= 24;\n            is_next_day = true;\n        }\n\n        (\n            is_next_day,\n            Self::__from_hms_nanos_unchecked(hour, minute, second, nanosecond),\n        )\n    }\n\n    /// Subtract the sub-day time of the [`std::time::Duration`] to the `Time`. Wraps on overflow,\n    /// returning whether the date is the previous date as the first element of the tuple.\n    pub(crate) const fn adjusting_sub_std(self, duration: StdDuration) -> (bool, Self) {\n        let mut nanosecond = self.nanosecond as i32 - duration.subsec_nanos() as i32;\n        let mut second = self.second as i8 - (duration.as_secs() % 60) as i8;\n        let mut minute = self.minute as i8 - ((duration.as_secs() / 60) % 60) as i8;\n        let mut hour = self.hour as i8 - ((duration.as_secs() / 3_600) % 24) as i8;\n        let mut is_previous_day = false;\n\n        cascade!(nanosecond in 0..1_000_000_000 => second);\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        if hour < 0 {\n            hour += 24;\n            is_previous_day = true;\n        }\n\n        (\n            is_previous_day,\n            Self::__from_hms_nanos_unchecked(hour as _, minute as _, second as _, nanosecond as _),\n        )\n    }\n    // endregion arithmetic helpers\n}","impl core::ops::$op<$t> for $target {\n            fn $fn(&mut self, rhs: $t) {\n                *self = *self $sym rhs;\n            }\n        }","impl fmt::Debug for Time {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Time\")\n            .field(\"hour\", &self.hour)\n            .field(\"minute\", &self.minute)\n            .field(\"second\", &self.second)\n            .field(\"nanosecond\", &self.nanosecond)\n            .finish()\n    }\n}","impl fmt::Display for Time {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let (value, width) = match self.nanosecond() {\n            nanos if nanos % 10 != 0 => (nanos, 9),\n            nanos if (nanos / 10) % 10 != 0 => (nanos / 10, 8),\n            nanos if (nanos / 100) % 10 != 0 => (nanos / 100, 7),\n            nanos if (nanos / 1_000) % 10 != 0 => (nanos / 1_000, 6),\n            nanos if (nanos / 10_000) % 10 != 0 => (nanos / 10_000, 5),\n            nanos if (nanos / 100_000) % 10 != 0 => (nanos / 100_000, 4),\n            nanos if (nanos / 1_000_000) % 10 != 0 => (nanos / 1_000_000, 3),\n            nanos if (nanos / 10_000_000) % 10 != 0 => (nanos / 10_000_000, 2),\n            nanos => (nanos / 100_000_000, 1),\n        };\n        write!(\n            f,\n            \"{}:{:02}:{:02}.{:0width$}\",\n            self.hour,\n            self.minute,\n            self.second,\n            value,\n            width = width\n        )\n    }\n}"],"utc_offset::UtcOffset":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl Neg for UtcOffset {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        Self::__from_hms_unchecked(-self.hours, -self.minutes, -self.seconds)\n    }\n}","impl UtcOffset {\n    /// A `UtcOffset` that is UTC.\n    ///\n    /// ```rust\n    /// # use time::{UtcOffset, macros::offset};\n    /// assert_eq!(UtcOffset::UTC, offset!(UTC));\n    /// ```\n    pub const UTC: Self = Self::__from_hms_unchecked(0, 0, 0);\n\n    // region: constructors\n    /// Create a `UtcOffset` representing an offset of the hours, minutes, and seconds provided, the\n    /// validity of which must be guaranteed by the caller. All three parameters must have the same\n    /// sign.\n    #[doc(hidden)]\n    pub const fn __from_hms_unchecked(hours: i8, minutes: i8, seconds: i8) -> Self {\n        Self {\n            hours,\n            minutes,\n            seconds,\n        }\n    }\n\n    /// Create a `UtcOffset` representing an offset by the number of hours, minutes, and seconds\n    /// provided.\n    ///\n    /// The sign of all three components should match. If they do not, all smaller components will\n    /// have their signs flipped.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::from_hms(1, 2, 3)?.as_hms(), (1, 2, 3));\n    /// assert_eq!(UtcOffset::from_hms(1, -2, -3)?.as_hms(), (1, 2, 3));\n    /// # Ok::<_, time::Error>(())\n    /// ```\n    pub const fn from_hms(\n        hours: i8,\n        mut minutes: i8,\n        mut seconds: i8,\n    ) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(hours in -23 => 23);\n        ensure_value_in_range!(minutes in -59 => 59);\n        ensure_value_in_range!(seconds in -59 => 59);\n\n        if (hours > 0 && minutes < 0) || (hours < 0 && minutes > 0) {\n            minutes *= -1;\n        }\n        if (hours > 0 && seconds < 0)\n            || (hours < 0 && seconds > 0)\n            || (minutes > 0 && seconds < 0)\n            || (minutes < 0 && seconds > 0)\n        {\n            seconds *= -1;\n        }\n\n        Ok(Self::__from_hms_unchecked(hours, minutes, seconds))\n    }\n\n    /// Create a `UtcOffset` representing an offset by the number of seconds provided.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// assert_eq!(UtcOffset::from_whole_seconds(3_723)?.as_hms(), (1, 2, 3));\n    /// # Ok::<_, time::Error>(())\n    /// ```\n    pub const fn from_whole_seconds(seconds: i32) -> Result<Self, error::ComponentRange> {\n        ensure_value_in_range!(seconds in -86_399 => 86_399);\n\n        Ok(Self::__from_hms_unchecked(\n            (seconds / 3_600) as _,\n            ((seconds / 60) % 60) as _,\n            (seconds % 60) as _,\n        ))\n    }\n    // endregion constructors\n\n    // region: getters\n    /// Obtain the UTC offset as its hours, minutes, and seconds. The sign of all three components\n    /// will always match. A positive value indicates an offset to the east; a negative to the west.\n    ///\n    /// ```rust\n    /// # use time::macros::offset;\n    /// assert_eq!(offset!(+1:02:03).as_hms(), (1, 2, 3));\n    /// assert_eq!(offset!(-1:02:03).as_hms(), (-1, -2, -3));\n    /// ```\n    pub const fn as_hms(self) -> (i8, i8, i8) {\n        (self.hours, self.minutes, self.seconds)\n    }\n\n    /// Obtain the number of whole hours the offset is from UTC. A positive value indicates an\n    /// offset to the east; a negative to the west.\n    ///\n    /// ```rust\n    /// # use time::macros::offset;\n    /// assert_eq!(offset!(+1:02:03).whole_hours(), 1);\n    /// assert_eq!(offset!(-1:02:03).whole_hours(), -1);\n    /// ```\n    pub const fn whole_hours(self) -> i8 {\n        self.hours\n    }\n\n    /// Obtain the number of whole minutes the offset is from UTC. A positive value indicates an\n    /// offset to the east; a negative to the west.\n    ///\n    /// ```rust\n    /// # use time::macros::offset;\n    /// assert_eq!(offset!(+1:02:03).whole_minutes(), 62);\n    /// assert_eq!(offset!(-1:02:03).whole_minutes(), -62);\n    /// ```\n    pub const fn whole_minutes(self) -> i16 {\n        self.hours as i16 * 60 + self.minutes as i16\n    }\n\n    /// Obtain the number of minutes past the hour the offset is from UTC. A positive value\n    /// indicates an offset to the east; a negative to the west.\n    ///\n    /// ```rust\n    /// # use time::macros::offset;\n    /// assert_eq!(offset!(+1:02:03).minutes_past_hour(), 2);\n    /// assert_eq!(offset!(-1:02:03).minutes_past_hour(), -2);\n    /// ```\n    pub const fn minutes_past_hour(self) -> i8 {\n        self.minutes\n    }\n\n    /// Obtain the number of whole seconds the offset is from UTC. A positive value indicates an\n    /// offset to the east; a negative to the west.\n    ///\n    /// ```rust\n    /// # use time::macros::offset;\n    /// assert_eq!(offset!(+1:02:03).whole_seconds(), 3723);\n    /// assert_eq!(offset!(-1:02:03).whole_seconds(), -3723);\n    /// ```\n    // This may be useful for anyone manually implementing arithmetic, as it\n    // would let them construct a `Duration` directly.\n    pub const fn whole_seconds(self) -> i32 {\n        self.hours as i32 * 3_600 + self.minutes as i32 * 60 + self.seconds as i32\n    }\n\n    /// Obtain the number of seconds past the minute the offset is from UTC. A positive value\n    /// indicates an offset to the east; a negative to the west.\n    ///\n    /// ```rust\n    /// # use time::macros::offset;\n    /// assert_eq!(offset!(+1:02:03).seconds_past_minute(), 3);\n    /// assert_eq!(offset!(-1:02:03).seconds_past_minute(), -3);\n    /// ```\n    pub const fn seconds_past_minute(self) -> i8 {\n        self.seconds\n    }\n    // endregion getters\n\n    // region: is_{sign}\n    /// Check if the offset is exactly UTC.\n    ///\n    ///\n    /// ```rust\n    /// # use time::macros::offset;\n    /// assert!(!offset!(+1:02:03).is_utc());\n    /// assert!(!offset!(-1:02:03).is_utc());\n    /// assert!(offset!(UTC).is_utc());\n    /// ```\n    pub const fn is_utc(self) -> bool {\n        self.hours == 0 && self.minutes == 0 && self.seconds == 0\n    }\n\n    /// Check if the offset is positive, or east of UTC.\n    ///\n    /// ```rust\n    /// # use time::macros::offset;\n    /// assert!(offset!(+1:02:03).is_positive());\n    /// assert!(!offset!(-1:02:03).is_positive());\n    /// assert!(!offset!(UTC).is_positive());\n    /// ```\n    pub const fn is_positive(self) -> bool {\n        self.hours > 0 || self.minutes > 0 || self.seconds > 0\n    }\n\n    /// Check if the offset is negative, or west of UTC.\n    ///\n    /// ```rust\n    /// # use time::macros::offset;\n    /// assert!(!offset!(+1:02:03).is_negative());\n    /// assert!(offset!(-1:02:03).is_negative());\n    /// assert!(!offset!(UTC).is_negative());\n    /// ```\n    pub const fn is_negative(self) -> bool {\n        self.hours < 0 || self.minutes < 0 || self.seconds < 0\n    }\n    // endregion is_{sign}\n\n    // region: local offset\n    /// Attempt to obtain the system's UTC offset at a known moment in time. If the offset cannot be\n    /// determined, an error is returned.\n    ///\n    /// ```rust\n    /// # use time::{UtcOffset, OffsetDateTime};\n    /// let local_offset = UtcOffset::local_offset_at(OffsetDateTime::UNIX_EPOCH);\n    /// # if false {\n    /// assert!(local_offset.is_ok());\n    /// # }\n    /// ```\n    #[cfg(feature = \"local-offset\")]\n    pub fn local_offset_at(datetime: OffsetDateTime) -> Result<Self, error::IndeterminateOffset> {\n        local_offset_at(datetime).ok_or(error::IndeterminateOffset)\n    }\n\n    /// Attempt to obtain the system's current UTC offset. If the offset cannot be determined, an\n    /// error is returned.\n    ///\n    /// ```rust\n    /// # use time::UtcOffset;\n    /// let local_offset = UtcOffset::current_local_offset();\n    /// # if false {\n    /// assert!(local_offset.is_ok());\n    /// # }\n    /// ```\n    #[cfg(feature = \"local-offset\")]\n    pub fn current_local_offset() -> Result<Self, error::IndeterminateOffset> {\n        let now = OffsetDateTime::now_utc();\n        local_offset_at(now).ok_or(error::IndeterminateOffset)\n    }\n    // endregion: local offset\n}","impl fmt::Display for UtcOffset {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"{}{:02}:{:02}:{:02}\",\n            if self.is_negative() { '-' } else { '+' },\n            self.hours.abs(),\n            self.minutes.abs(),\n            self.seconds.abs()\n        )\n    }\n}"],"weekday::Weekday":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl Display for Weekday {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(match self {\n            Monday => \"Monday\",\n            Tuesday => \"Tuesday\",\n            Wednesday => \"Wednesday\",\n            Thursday => \"Thursday\",\n            Friday => \"Friday\",\n            Saturday => \"Saturday\",\n            Sunday => \"Sunday\",\n        })\n    }\n}","impl Weekday {\n    /// Get the previous weekday.\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Tuesday.previous(), Weekday::Monday);\n    /// ```\n    pub const fn previous(self) -> Self {\n        match self {\n            Monday => Sunday,\n            Tuesday => Monday,\n            Wednesday => Tuesday,\n            Thursday => Wednesday,\n            Friday => Thursday,\n            Saturday => Friday,\n            Sunday => Saturday,\n        }\n    }\n\n    /// Get the next weekday.\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Monday.next(), Weekday::Tuesday);\n    /// ```\n    pub const fn next(self) -> Self {\n        match self {\n            Monday => Tuesday,\n            Tuesday => Wednesday,\n            Wednesday => Thursday,\n            Thursday => Friday,\n            Friday => Saturday,\n            Saturday => Sunday,\n            Sunday => Monday,\n        }\n    }\n\n    /// Get the one-indexed number of days from Monday.\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Monday.number_from_monday(), 1);\n    /// ```\n    #[doc(alias = \"iso_weekday_number\")]\n    pub const fn number_from_monday(self) -> u8 {\n        self.number_days_from_monday() + 1\n    }\n\n    /// Get the one-indexed number of days from Sunday.\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Monday.number_from_sunday(), 2);\n    /// ```\n    pub const fn number_from_sunday(self) -> u8 {\n        self.number_days_from_sunday() + 1\n    }\n\n    /// Get the zero-indexed number of days from Monday.\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Monday.number_days_from_monday(), 0);\n    /// ```\n    pub const fn number_days_from_monday(self) -> u8 {\n        self as _\n    }\n\n    /// Get the zero-indexed number of days from Sunday.\n    ///\n    /// ```rust\n    /// # use time::Weekday;\n    /// assert_eq!(Weekday::Monday.number_days_from_sunday(), 1);\n    /// ```\n    pub const fn number_days_from_sunday(self) -> u8 {\n        match self {\n            Monday => 1,\n            Tuesday => 2,\n            Wednesday => 3,\n            Thursday => 4,\n            Friday => 5,\n            Saturday => 6,\n            Sunday => 0,\n        }\n    }\n}"]},"single_path_import":{"date::Date":"Date","duration::Duration":"Duration","error::Error":"Error","error::component_range::ComponentRange":"error::ComponentRange","error::conversion_range::ConversionRange":"error::ConversionRange","error::different_variant::DifferentVariant":"error::DifferentVariant","instant::Instant":"Instant","month::Month":"Month","offset_date_time::OffsetDateTime":"OffsetDateTime","primitive_date_time::PrimitiveDateTime":"PrimitiveDateTime","time::Time":"Time","utc_offset::UtcOffset":"UtcOffset","weekday::Weekday":"Weekday"},"srcs":{"<date::Date as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error>{\n        f.debug_struct(\"Date\")\n            .field(\"year\", &self.year())\n            .field(\"ordinal\", &self.ordinal())\n            .finish()\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        if cfg!(feature = \"large-dates\") && self.year().abs() >= 10_000 {\n            write!(\n                f,\n                \"{:+}-{:02}-{:02}\",\n                self.year(),\n                self.month() as u8,\n                self.day()\n            )\n        } else {\n            write!(\n                f,\n                \"{:0width$}-{:02}-{:02}\",\n                self.year(),\n                self.month() as u8,\n                self.day(),\n                width = 4 + (self.year() < 0) as usize\n            )\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::Add<duration::Duration>>::add":["fn add(self, duration: Duration) -> Self::Output{\n        self.checked_add(duration)\n            .expect(\"overflow adding duration to date\")\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::Add<std::time::Duration>>::add":["fn add(self, duration: StdDuration) -> Self::Output{\n        Self::from_julian_day(self.to_julian_day() + (duration.as_secs() / 86_400) as i32)\n            .expect(\"overflow adding duration to date\")\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::AddAssign<duration::Duration>>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<date::Date as std::ops::AddAssign<std::time::Duration>>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<date::Date as std::ops::Sub<duration::Duration>>::sub":["fn sub(self, duration: Duration) -> Self::Output{\n        self.checked_sub(duration)\n            .expect(\"overflow subtracting duration from date\")\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::Sub<std::time::Duration>>::sub":["fn sub(self, duration: StdDuration) -> Self::Output{\n        Self::from_julian_day(self.to_julian_day() - (duration.as_secs() / 86_400) as i32)\n            .expect(\"overflow subtracting duration from date\")\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::Sub>::sub":["fn sub(self, other: Self) -> Self::Output{\n        Duration::days((self.to_julian_day() - other.to_julian_day()) as _)\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date as std::ops::SubAssign<duration::Duration>>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<date::Date as std::ops::SubAssign<std::time::Duration>>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::cmp::PartialEq<std::time::Duration>>::eq":["fn eq(&self, rhs: &StdDuration) -> bool{\n        Ok(*self) == Self::try_from(*rhs)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::cmp::PartialOrd<std::time::Duration>>::partial_cmp":["fn partial_cmp(&self, rhs: &StdDuration) -> Option<Ordering>{\n        if rhs.as_secs() > i64::MAX as _ {\n            return Some(Ordering::Less);\n        }\n\n        Some(\n            self.seconds\n                .cmp(&(rhs.as_secs() as _))\n                .then_with(|| self.nanoseconds.cmp(&(rhs.subsec_nanos() as _))),\n        )\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::convert::TryFrom<std::time::Duration>>::try_from":["fn try_from(original: StdDuration) -> Result<Self, error::ConversionRange>{\n        Ok(Self::new(\n            original\n                .as_secs()\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n            original.subsec_nanos() as _,\n        ))\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"Duration\")\n            .field(\"seconds\", &self.seconds)\n            .field(\"nanoseconds\", &self.nanoseconds)\n            .finish()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::iter::Sum<&'a duration::Duration>>::sum":["fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self{\n        iter.copied().sum()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::iter::Sum>::sum":["fn sum<I: Iterator<Item = Self>>(iter: I) -> Self{\n        iter.reduce(|a, b| a + b).unwrap_or_default()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Add<std::time::Duration>>::add":["fn add(self, std_duration: StdDuration) -> Self::Output{\n        self + Self::try_from(std_duration)\n            .expect(\"overflow converting `std::time::Duration` to `time::Duration`\")\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Add>::add":["fn add(self, rhs: Self) -> Self::Output{\n        self.checked_add(rhs)\n            .expect(\"overflow when adding durations\")\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::AddAssign<std::time::Duration>>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::AddAssign>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::Div<f32>>::div":["fn div(self, rhs: f32) -> Self::Output{\n        Self::seconds_f32(self.as_seconds_f32() / rhs)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<f64>>::div":["fn div(self, rhs: f64) -> Self::Output{\n        Self::seconds_f64(self.as_seconds_f64() / rhs)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<i16>>::div":["fn div(self, rhs: $type) -> Self::Output{\n                Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n            }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<i32>>::div":["fn div(self, rhs: $type) -> Self::Output{\n                Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n            }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<i8>>::div":["fn div(self, rhs: $type) -> Self::Output{\n                Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n            }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<std::time::Duration>>::div":["fn div(self, rhs: StdDuration) -> Self::Output{\n        self.as_seconds_f64() / rhs.as_secs_f64()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<u16>>::div":["fn div(self, rhs: $type) -> Self::Output{\n                Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n            }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<u32>>::div":["fn div(self, rhs: $type) -> Self::Output{\n                Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n            }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div<u8>>::div":["fn div(self, rhs: $type) -> Self::Output{\n                Self::nanoseconds_i128(self.whole_nanoseconds() / rhs as i128)\n            }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Div>::div":["fn div(self, rhs: Self) -> Self::Output{\n        self.as_seconds_f64() / rhs.as_seconds_f64()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::DivAssign<f32>>::div_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::DivAssign<f64>>::div_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::DivAssign<i16>>::div_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::DivAssign<i32>>::div_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::DivAssign<i8>>::div_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::DivAssign<u16>>::div_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::DivAssign<u32>>::div_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::DivAssign<u8>>::div_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::Mul<f32>>::mul":["fn mul(self, rhs: f32) -> Self::Output{\n        Self::seconds_f32(self.as_seconds_f32() * rhs)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<f64>>::mul":["fn mul(self, rhs: f64) -> Self::Output{\n        Self::seconds_f64(self.as_seconds_f64() * rhs)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<i16>>::mul":["fn mul(self, rhs: $type) -> Self::Output{\n                Self::nanoseconds_i128(\n                    self.whole_nanoseconds()\n                        .checked_mul(rhs as _)\n                        .expect(\"overflow when multiplying duration\")\n                )\n            }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<i32>>::mul":["fn mul(self, rhs: $type) -> Self::Output{\n                Self::nanoseconds_i128(\n                    self.whole_nanoseconds()\n                        .checked_mul(rhs as _)\n                        .expect(\"overflow when multiplying duration\")\n                )\n            }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<i8>>::mul":["fn mul(self, rhs: $type) -> Self::Output{\n                Self::nanoseconds_i128(\n                    self.whole_nanoseconds()\n                        .checked_mul(rhs as _)\n                        .expect(\"overflow when multiplying duration\")\n                )\n            }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<u16>>::mul":["fn mul(self, rhs: $type) -> Self::Output{\n                Self::nanoseconds_i128(\n                    self.whole_nanoseconds()\n                        .checked_mul(rhs as _)\n                        .expect(\"overflow when multiplying duration\")\n                )\n            }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<u32>>::mul":["fn mul(self, rhs: $type) -> Self::Output{\n                Self::nanoseconds_i128(\n                    self.whole_nanoseconds()\n                        .checked_mul(rhs as _)\n                        .expect(\"overflow when multiplying duration\")\n                )\n            }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Mul<u8>>::mul":["fn mul(self, rhs: $type) -> Self::Output{\n                Self::nanoseconds_i128(\n                    self.whole_nanoseconds()\n                        .checked_mul(rhs as _)\n                        .expect(\"overflow when multiplying duration\")\n                )\n            }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::MulAssign<f32>>::mul_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::MulAssign<f64>>::mul_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::MulAssign<i16>>::mul_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::MulAssign<i32>>::mul_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::MulAssign<i8>>::mul_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::MulAssign<u16>>::mul_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::MulAssign<u32>>::mul_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::MulAssign<u8>>::mul_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::Neg>::neg":["fn neg(self) -> Self::Output{\n        Self::new_unchecked(-self.seconds, -self.nanoseconds)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Sub<std::time::Duration>>::sub":["fn sub(self, rhs: StdDuration) -> Self::Output{\n        self - Self::try_from(rhs)\n            .expect(\"overflow converting `std::time::Duration` to `time::Duration`\")\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::Sub>::sub":["fn sub(self, rhs: Self) -> Self::Output{\n        self.checked_sub(rhs)\n            .expect(\"overflow when subtracting durations\")\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<duration::Duration as std::ops::SubAssign<std::time::Duration>>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Duration as std::ops::SubAssign>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<duration::Padding as std::default::Default>::default":["fn default() -> Self{\n        Self::Optimize\n    }","Real(LocalPath(\"src/duration.rs\"))"],"<error::Error as std::error::Error>::source":["fn source(&self) -> Option<&(dyn std::error::Error + 'static)>{\n        match self {\n            Self::ConversionRange(err) => Some(err),\n            Self::ComponentRange(err) => Some(err),\n            #[cfg(feature = \"local-offset\")]\n            Self::IndeterminateOffset(err) => Some(err),\n            #[cfg(feature = \"formatting\")]\n            Self::Format(err) => Some(err),\n            #[cfg(feature = \"parsing\")]\n            Self::ParseFromDescription(err) => Some(err),\n            #[cfg(feature = \"parsing\")]\n            Self::UnexpectedTrailingCharacters => None,\n            #[cfg(feature = \"parsing\")]\n            Self::TryFromParsed(err) => Some(err),\n            #[cfg(all(any(feature = \"formatting\", feature = \"parsing\"), feature = \"alloc\"))]\n            Self::InvalidFormatDescription(err) => Some(err),\n            Self::DifferentVariant(err) => Some(err),\n        }\n    }","Real(LocalPath(\"src/error/mod.rs\"))"],"<error::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match self {\n            Self::ConversionRange(e) => e.fmt(f),\n            Self::ComponentRange(e) => e.fmt(f),\n            #[cfg(feature = \"local-offset\")]\n            Self::IndeterminateOffset(e) => e.fmt(f),\n            #[cfg(feature = \"formatting\")]\n            Self::Format(e) => e.fmt(f),\n            #[cfg(feature = \"parsing\")]\n            Self::ParseFromDescription(e) => e.fmt(f),\n            #[cfg(feature = \"parsing\")]\n            Self::UnexpectedTrailingCharacters => f.write_str(\"unexpected trailing characters\"),\n            #[cfg(feature = \"parsing\")]\n            Self::TryFromParsed(e) => e.fmt(f),\n            #[cfg(all(any(feature = \"formatting\", feature = \"parsing\"), feature = \"alloc\"))]\n            Self::InvalidFormatDescription(e) => e.fmt(f),\n            Self::DifferentVariant(e) => e.fmt(f),\n        }\n    }","Real(LocalPath(\"src/error/mod.rs\"))"],"<error::component_range::ComponentRange as std::convert::TryFrom<error::Error>>::try_from":["fn try_from(err: crate::Error) -> Result<Self, Self::Error>{\n        match err {\n            crate::Error::ComponentRange(err) => Ok(err),\n            _ => Err(error::DifferentVariant),\n        }\n    }","Real(LocalPath(\"src/error/component_range.rs\"))"],"<error::component_range::ComponentRange as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(\n            f,\n            \"{} must be in the range {}..={}\",\n            self.name, self.minimum, self.maximum\n        )?;\n\n        if self.conditional_range {\n            f.write_str(\", given values of other parameters\")?;\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/error/component_range.rs\"))"],"<error::conversion_range::ConversionRange as std::convert::TryFrom<error::Error>>::try_from":["fn try_from(err: crate::Error) -> Result<Self, Self::Error>{\n        match err {\n            crate::Error::ConversionRange(err) => Ok(err),\n            _ => Err(error::DifferentVariant),\n        }\n    }","Real(LocalPath(\"src/error/conversion_range.rs\"))"],"<error::conversion_range::ConversionRange as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(\"Source value is out of range for the target type\")\n    }","Real(LocalPath(\"src/error/conversion_range.rs\"))"],"<error::different_variant::DifferentVariant as std::convert::TryFrom<error::Error>>::try_from":["fn try_from(err: crate::Error) -> Result<Self, Self::Error>{\n        match err {\n            crate::Error::DifferentVariant(err) => Ok(err),\n            _ => Err(Self),\n        }\n    }","Real(LocalPath(\"src/error/different_variant.rs\"))"],"<error::different_variant::DifferentVariant as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"value was of a different variant than required\")\n    }","Real(LocalPath(\"src/error/different_variant.rs\"))"],"<f64 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n        Duration::nanoseconds((self * 86_400_000_000_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n        Duration::nanoseconds((self * 3_600_000_000_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n        Duration::nanoseconds((self * 1_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n        Duration::nanoseconds((self * 1_000_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n        Duration::nanoseconds((self * 60_000_000_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n        Duration::nanoseconds(self as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n        Duration::nanoseconds((self * 1_000_000_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n        Duration::nanoseconds((self * 604_800_000_000_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_days":["fn std_days(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 86_400_000_000_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_hours":["fn std_hours(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 3_600_000_000_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_microseconds":["fn std_microseconds(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 1_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_milliseconds":["fn std_milliseconds(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 1_000_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_minutes":["fn std_minutes(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 60_000_000_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_nanoseconds":["fn std_nanoseconds(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos(self as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_seconds":["fn std_seconds(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 1_000_000_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<f64 as ext::NumericalStdDuration>::std_weeks":["fn std_weeks(self) -> StdDuration{\n        assert!(self >= 0.);\n        StdDuration::from_nanos((self * 604_800_000_000_000.) as _)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::days":["fn days(self) -> Duration{\n        Duration::days(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::hours":["fn hours(self) -> Duration{\n        Duration::hours(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::microseconds":["fn microseconds(self) -> Duration{\n        Duration::microseconds(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::milliseconds":["fn milliseconds(self) -> Duration{\n        Duration::milliseconds(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::minutes":["fn minutes(self) -> Duration{\n        Duration::minutes(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::nanoseconds":["fn nanoseconds(self) -> Duration{\n        Duration::nanoseconds(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::seconds":["fn seconds(self) -> Duration{\n        Duration::seconds(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<i64 as ext::NumericalDuration>::weeks":["fn weeks(self) -> Duration{\n        Duration::weeks(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<instant::Instant as std::borrow::Borrow<std::time::Instant>>::borrow":["fn borrow(&self) -> &StdInstant{\n        &self.0\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::cmp::PartialEq<std::time::Instant>>::eq":["fn eq(&self, rhs: &StdInstant) -> bool{\n        self.0.eq(rhs)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::cmp::PartialOrd<std::time::Instant>>::partial_cmp":["fn partial_cmp(&self, rhs: &StdInstant) -> Option<Ordering>{\n        self.0.partial_cmp(rhs)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::convert::AsRef<std::time::Instant>>::as_ref":["fn as_ref(&self) -> &StdInstant{\n        &self.0\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::convert::From<std::time::Instant>>::from":["fn from(instant: StdInstant) -> Self{\n        Self(instant)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::Add<duration::Duration>>::add":["fn add(self, duration: Duration) -> Self::Output{\n        if duration.is_positive() {\n            Self(self.0 + duration.abs_std())\n        } else if duration.is_negative() {\n            Self(self.0 - duration.abs_std())\n        } else {\n            self\n        }\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::Add<std::time::Duration>>::add":["fn add(self, duration: StdDuration) -> Self::Output{\n        Self(self.0 + duration)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::AddAssign<duration::Duration>>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<instant::Instant as std::ops::AddAssign<std::time::Duration>>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<instant::Instant as std::ops::Sub<duration::Duration>>::sub":["fn sub(self, duration: Duration) -> Self::Output{\n        if duration.is_positive() {\n            Self(self.0 - duration.abs_std())\n        } else if duration.is_negative() {\n            Self(self.0 + duration.abs_std())\n        } else {\n            self\n        }\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::Sub<std::time::Duration>>::sub":["fn sub(self, duration: StdDuration) -> Self::Output{\n        Self(self.0 - duration)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::Sub<std::time::Instant>>::sub":["fn sub(self, other: StdInstant) -> Self::Output{\n        self - Self(other)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::Sub>::sub":["fn sub(self, other: Self) -> Self::Output{\n        match self.0.cmp(&other.0) {\n            Ordering::Equal => Duration::ZERO,\n            Ordering::Greater => (self.0 - other.0)\n                .try_into()\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n            Ordering::Less => -Duration::try_from(other.0 - self.0)\n                .expect(\"overflow converting `std::time::Duration` to `time::Duration`\"),\n        }\n    }","Real(LocalPath(\"src/instant.rs\"))"],"<instant::Instant as std::ops::SubAssign<duration::Duration>>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<instant::Instant as std::ops::SubAssign<std::time::Duration>>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<month::Month as std::convert::TryFrom<u8>>::try_from":["fn try_from(value: u8) -> Result<Self, Self::Error>{\n        match NonZeroU8::new(value) {\n            Some(value) => Self::from_number(value),\n            None => Err(error::ComponentRange {\n                name: \"month\",\n                minimum: 1,\n                maximum: 12,\n                value: 0,\n                conditional_range: false,\n            }),\n        }\n    }","Real(LocalPath(\"src/month.rs\"))"],"<month::Month as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(match self {\n            January => \"January\",\n            February => \"February\",\n            March => \"March\",\n            April => \"April\",\n            May => \"May\",\n            June => \"June\",\n            July => \"July\",\n            August => \"August\",\n            September => \"September\",\n            October => \"October\",\n            November => \"November\",\n            December => \"December\",\n        })\n    }","Real(LocalPath(\"src/month.rs\"))"],"<offset_date_time::OffsetDateTime as std::cmp::Ord>::cmp":["fn cmp(&self, rhs: &Self) -> Ordering{\n        self.utc_datetime.cmp(&rhs.utc_datetime)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq":["fn eq(&self, rhs: &SystemTime) -> bool{\n        self == &Self::from(*rhs)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::cmp::PartialEq>::eq":["fn eq(&self, rhs: &Self) -> bool{\n        self.utc_datetime.eq(&rhs.utc_datetime)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp":["fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering>{\n        self.partial_cmp(&Self::from(*other))\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, rhs: &Self) -> Option<Ordering>{\n        Some(self.cmp(rhs))\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::convert::From<std::time::SystemTime>>::from":["fn from(system_time: SystemTime) -> Self{\n        match system_time.duration_since(SystemTime::UNIX_EPOCH) {\n            Ok(duration) => Self::UNIX_EPOCH + duration,\n            Err(err) => Self::UNIX_EPOCH - err.duration(),\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"{} {} {}\", self.date(), self.time(), self.offset)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::hash::Hash>::hash":["fn hash<H: Hasher>(&self, hasher: &mut H){\n        // We need to distinguish this from a `PrimitiveDateTime`, which would otherwise conflict.\n        hasher.write(b\"OffsetDateTime\");\n        self.utc_datetime.hash(hasher);\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::Add<T>>::add":["fn add(self, rhs: T) -> Self::Output{\n        (self.utc_datetime + rhs)\n            .assume_utc()\n            .to_offset(self.offset)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::AddAssign<duration::Duration>>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::Sub<T>>::sub":["fn sub(self, rhs: T) -> Self::Output{\n        (self.utc_datetime - rhs)\n            .assume_utc()\n            .to_offset(self.offset)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::SystemTime>>::sub":["fn sub(self, rhs: SystemTime) -> Self::Output{\n        self - Self::from(rhs)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::Sub>::sub":["fn sub(self, rhs: Self) -> Self::Output{\n        self.utc_datetime - rhs.utc_datetime\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<offset_date_time::OffsetDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"{} {}\", self.date, self.time)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<duration::Duration>>::add":["fn add(self, duration: Duration) -> Self::Output{\n        self.checked_add(duration)\n            .expect(\"resulting value is out of range\")\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<std::time::Duration>>::add":["fn add(self, duration: StdDuration) -> Self::Output{\n        let (is_next_day, time) = self.time.adjusting_add_std(duration);\n\n        Self {\n            date: if is_next_day {\n                (self.date + duration)\n                    .next_day()\n                    .expect(\"resulting value is out of range\")\n            } else {\n                self.date + duration\n            },\n            time,\n        }\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<duration::Duration>>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<duration::Duration>>::sub":["fn sub(self, duration: Duration) -> Self::Output{\n        self.checked_sub(duration)\n            .expect(\"resulting value is out of range\")\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::Duration>>::sub":["fn sub(self, duration: StdDuration) -> Self::Output{\n        let (is_previous_day, time) = self.time.adjusting_sub_std(duration);\n\n        Self {\n            date: if is_previous_day {\n                (self.date - duration)\n                    .previous_day()\n                    .expect(\"resulting value is out of range\")\n            } else {\n                self.date - duration\n            },\n            time,\n        }\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub>::sub":["fn sub(self, rhs: Self) -> Self::Output{\n        (self.date - rhs.date) + (self.time - rhs.time)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<time::Time as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"Time\")\n            .field(\"hour\", &self.hour)\n            .field(\"minute\", &self.minute)\n            .field(\"second\", &self.second)\n            .field(\"nanosecond\", &self.nanosecond)\n            .finish()\n    }","Real(LocalPath(\"src/time.rs\"))"],"<time::Time as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let (value, width) = match self.nanosecond() {\n            nanos if nanos % 10 != 0 => (nanos, 9),\n            nanos if (nanos / 10) % 10 != 0 => (nanos / 10, 8),\n            nanos if (nanos / 100) % 10 != 0 => (nanos / 100, 7),\n            nanos if (nanos / 1_000) % 10 != 0 => (nanos / 1_000, 6),\n            nanos if (nanos / 10_000) % 10 != 0 => (nanos / 10_000, 5),\n            nanos if (nanos / 100_000) % 10 != 0 => (nanos / 100_000, 4),\n            nanos if (nanos / 1_000_000) % 10 != 0 => (nanos / 1_000_000, 3),\n            nanos if (nanos / 10_000_000) % 10 != 0 => (nanos / 10_000_000, 2),\n            nanos => (nanos / 100_000_000, 1),\n        };\n        write!(\n            f,\n            \"{}:{:02}:{:02}.{:0width$}\",\n            self.hour,\n            self.minute,\n            self.second,\n            value,\n            width = width\n        )\n    }","Real(LocalPath(\"src/time.rs\"))"],"<time::Time as std::ops::Add<duration::Duration>>::add":["/// Add the sub-day time of the [`Duration`] to the `Time`. Wraps on overflow.\n///\n/// ```rust\n/// # use time::{ext::NumericalDuration, macros::time};\n/// assert_eq!(time!(12:00) + 2.hours(), time!(14:00));\n/// assert_eq!(time!(0:00:01) + (-2).seconds(), time!(23:59:59));\n/// ```\nfn add(self, duration: Duration) -> Self::Output{\n        self.adjusting_add(duration).1\n    }","Real(LocalPath(\"src/time.rs\"))"],"<time::Time as std::ops::Add<std::time::Duration>>::add":["/// Add the sub-day time of the [`std::time::Duration`] to the `Time`. Wraps on overflow.\n///\n/// ```rust\n/// # use time::{ext::NumericalStdDuration, macros::time};\n/// assert_eq!(time!(12:00) + 2.std_hours(), time!(14:00));\n/// assert_eq!(time!(23:59:59) + 2.std_seconds(), time!(0:00:01));\n/// ```\nfn add(self, duration: StdDuration) -> Self::Output{\n        self.adjusting_add_std(duration).1\n    }","Real(LocalPath(\"src/time.rs\"))"],"<time::Time as std::ops::AddAssign<duration::Duration>>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<time::Time as std::ops::AddAssign<std::time::Duration>>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<time::Time as std::ops::Sub<duration::Duration>>::sub":["/// Subtract the sub-day time of the [`Duration`] from the `Time`. Wraps on overflow.\n///\n/// ```rust\n/// # use time::{ext::NumericalDuration, macros::time};\n/// assert_eq!(time!(14:00) - 2.hours(), time!(12:00));\n/// assert_eq!(time!(23:59:59) - (-2).seconds(), time!(0:00:01));\n/// ```\nfn sub(self, duration: Duration) -> Self::Output{\n        self.adjusting_sub(duration).1\n    }","Real(LocalPath(\"src/time.rs\"))"],"<time::Time as std::ops::Sub<std::time::Duration>>::sub":["/// Subtract the sub-day time of the [`std::time::Duration`] from the `Time`. Wraps on overflow.\n///\n/// ```rust\n/// # use time::{ext::NumericalStdDuration, macros::time};\n/// assert_eq!(time!(14:00) - 2.std_hours(), time!(12:00));\n/// assert_eq!(time!(0:00:01) - 2.std_seconds(), time!(23:59:59));\n/// ```\nfn sub(self, duration: StdDuration) -> Self::Output{\n        self.adjusting_sub_std(duration).1\n    }","Real(LocalPath(\"src/time.rs\"))"],"<time::Time as std::ops::Sub>::sub":["/// Subtract two `Time`s, returning the [`Duration`] between. This assumes both `Time`s are in\n/// the same calendar day.\n///\n/// ```rust\n/// # use time::{ext::NumericalDuration, macros::time};\n/// assert_eq!(time!(0:00) - time!(0:00), 0.seconds());\n/// assert_eq!(time!(1:00) - time!(0:00), 1.hours());\n/// assert_eq!(time!(0:00) - time!(1:00), (-1).hours());\n/// assert_eq!(time!(0:00) - time!(23:00), (-23).hours());\n/// ```\nfn sub(self, rhs: Self) -> Self::Output{\n        let hour_diff = (self.hour as i8) - (rhs.hour as i8);\n        let minute_diff = (self.minute as i8) - (rhs.minute as i8);\n        let mut second_diff = (self.second as i8) - (rhs.second as i8);\n        let mut nanosecond_diff = (self.nanosecond as i32) - (rhs.nanosecond as i32);\n\n        cascade!(nanosecond_diff in 0..1_000_000_000 => second_diff);\n\n        Duration::new_unchecked(\n            hour_diff as i64 * 3_600 + minute_diff as i64 * 60 + second_diff as i64,\n            nanosecond_diff,\n        )\n    }","Real(LocalPath(\"src/time.rs\"))"],"<time::Time as std::ops::SubAssign<duration::Duration>>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<time::Time as std::ops::SubAssign<std::time::Duration>>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_days":["fn std_days(self) -> StdDuration{\n        StdDuration::from_secs(self * 86_400)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_hours":["fn std_hours(self) -> StdDuration{\n        StdDuration::from_secs(self * 3_600)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_microseconds":["fn std_microseconds(self) -> StdDuration{\n        StdDuration::from_micros(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_milliseconds":["fn std_milliseconds(self) -> StdDuration{\n        StdDuration::from_millis(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_minutes":["fn std_minutes(self) -> StdDuration{\n        StdDuration::from_secs(self * 60)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_nanoseconds":["fn std_nanoseconds(self) -> StdDuration{\n        StdDuration::from_nanos(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_seconds":["fn std_seconds(self) -> StdDuration{\n        StdDuration::from_secs(self)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<u64 as ext::NumericalStdDuration>::std_weeks":["fn std_weeks(self) -> StdDuration{\n        StdDuration::from_secs(self * 604_800)\n    }","Real(LocalPath(\"src/ext.rs\"))"],"<utc_offset::UtcOffset as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(\n            f,\n            \"{}{:02}:{:02}:{:02}\",\n            if self.is_negative() { '-' } else { '+' },\n            self.hours.abs(),\n            self.minutes.abs(),\n            self.seconds.abs()\n        )\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"<utc_offset::UtcOffset as std::ops::Neg>::neg":["fn neg(self) -> Self::Output{\n        Self::__from_hms_unchecked(-self.hours, -self.minutes, -self.seconds)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"<weekday::Weekday as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.write_str(match self {\n            Monday => \"Monday\",\n            Tuesday => \"Tuesday\",\n            Wednesday => \"Wednesday\",\n            Thursday => \"Thursday\",\n            Friday => \"Friday\",\n            Saturday => \"Saturday\",\n            Sunday => \"Sunday\",\n        })\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"date::Date":["/// Date in the proleptic Gregorian calendar.\n///\n/// By default, years between ±9999 inclusive are representable. This can be expanded to ±999,999\n/// inclusive by enabling the `large-dates` crate feature. Doing so has performance implications\n/// and introduces some ambiguities when parsing.\npub struct Date {\n    /// Bitpacked field containing both the year and ordinal.\n    // |     xx     | xxxxxxxxxxxxxxxxxxxxx | xxxxxxxxx |\n    // |   2 bits   |        21 bits        |  9 bits   |\n    // | unassigned |         year          |  ordinal  |\n    // The year is 15 bits when `large-dates` is not enabled.\n    pub(crate) value: i32,\n}","Real(LocalPath(\"src/date.rs\"))"],"date::Date::__from_ordinal_date_unchecked":["/// Construct a `Date` from the year and ordinal values, the validity of which must be\n/// guaranteed by the caller.\n#[doc(hidden)]\npub const fn __from_ordinal_date_unchecked(year: i32, ordinal: u16) -> Self{\n        Self {\n            value: (year << 9) | ordinal as i32,\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::checked_add":["/// Computes `self + duration`, returning `None` if an overflow occurred.\n///\n/// ```rust\n/// # use time::{Date, ext::NumericalDuration, macros::date};\n/// assert_eq!(Date::MAX.checked_add(1.days()), None);\n/// assert_eq!(Date::MIN.checked_add((-2).days()), None);\n/// assert_eq!(\n///     date!(2020 - 12 - 31).checked_add(2.days()),\n///     Some(date!(2021 - 01 - 02))\n/// );\n/// ```\n///\n/// # Note\n///\n/// This function only takes whole days into account.\n///\n/// ```rust\n/// # use time::{Date, ext::NumericalDuration, macros::date};\n/// assert_eq!(Date::MAX.checked_add(23.hours()), Some(Date::MAX));\n/// assert_eq!(Date::MIN.checked_add((-23).hours()), Some(Date::MIN));\n/// assert_eq!(\n///     date!(2020 - 12 - 31).checked_add(23.hours()),\n///     Some(date!(2020 - 12 - 31))\n/// );\n/// assert_eq!(\n///     date!(2020 - 12 - 31).checked_add(47.hours()),\n///     Some(date!(2021 - 01 - 01))\n/// );\n/// ```\npub const fn checked_add(self, duration: Duration) -> Option<Self>{\n        let whole_days = duration.whole_days();\n        if whole_days < i32::MIN as i64 || whole_days > i32::MAX as i64 {\n            return None;\n        }\n\n        let julian_day = const_try_opt!(self.to_julian_day().checked_add(whole_days as _));\n        if let Ok(date) = Self::from_julian_day(julian_day) {\n            Some(date)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::checked_sub":["/// Computes `self - duration`, returning `None` if an overflow occurred.\n///\n/// ```\n/// # use time::{Date, ext::NumericalDuration, macros::date};\n/// assert_eq!(Date::MAX.checked_sub((-2).days()), None);\n/// assert_eq!(Date::MIN.checked_sub(1.days()), None);\n/// assert_eq!(\n///     date!(2020 - 12 - 31).checked_sub(2.days()),\n///     Some(date!(2020 - 12 - 29))\n/// );\n/// ```\n///\n/// # Note\n///\n/// This function only takes whole days into account.\n///\n/// ```\n/// # use time::{Date, ext::NumericalDuration, macros::date};\n/// assert_eq!(Date::MAX.checked_sub((-23).hours()), Some(Date::MAX));\n/// assert_eq!(Date::MIN.checked_sub(23.hours()), Some(Date::MIN));\n/// assert_eq!(\n///     date!(2020 - 12 - 31).checked_sub(23.hours()),\n///     Some(date!(2020 - 12 - 31))\n/// );\n/// assert_eq!(\n///     date!(2020 - 12 - 31).checked_sub(47.hours()),\n///     Some(date!(2020 - 12 - 30))\n/// );\n/// ```\npub const fn checked_sub(self, duration: Duration) -> Option<Self>{\n        let whole_days = duration.whole_days();\n        if whole_days < i32::MIN as i64 || whole_days > i32::MAX as i64 {\n            return None;\n        }\n\n        let julian_day = const_try_opt!(self.to_julian_day().checked_sub(whole_days as _));\n        if let Ok(date) = Self::from_julian_day(julian_day) {\n            Some(date)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::day":["/// Get the day of the month.\n///\n/// The returned value will always be in the range `1..=31`.\n///\n/// ```rust\n/// # use time::macros::date;\n/// assert_eq!(date!(2019 - 01 - 01).day(), 1);\n/// assert_eq!(date!(2019 - 12 - 31).day(), 31);\n/// ```\npub const fn day(self) -> u8{\n        self.month_day().1\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::from_calendar_date":["/// Attempt to create a `Date` from the year, month, and day.\n///\n/// ```rust\n/// # use time::{Date, Month};\n/// assert!(Date::from_calendar_date(2019, Month::January, 1).is_ok());\n/// assert!(Date::from_calendar_date(2019, Month::December, 31).is_ok());\n/// ```\n///\n/// ```rust\n/// # use time::{Date, Month};\n/// assert!(Date::from_calendar_date(2019, Month::February, 29).is_err()); // 2019 isn't a leap year.\n/// ```\npub const fn from_calendar_date(\n        year: i32,\n        month: Month,\n        day: u8,\n    ) -> Result<Self, error::ComponentRange>{\n        /// Cumulative days through the beginning of a month in both common and leap years.\n        const DAYS_CUMULATIVE_COMMON_LEAP: [[u16; 12]; 2] = [\n            [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n            [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n        ];\n\n        ensure_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        ensure_value_in_range!(day conditionally in 1 => days_in_year_month(year, month));\n\n        Ok(Self::__from_ordinal_date_unchecked(\n            year,\n            DAYS_CUMULATIVE_COMMON_LEAP[is_leap_year(year) as usize][month as usize - 1]\n                + day as u16,\n        ))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::from_iso_week_date":["/// Attempt to create a `Date` from the ISO year, week, and weekday.\n///\n/// ```rust\n/// # use time::{Date, Weekday::*};\n/// assert!(Date::from_iso_week_date(2019, 1, Monday).is_ok());\n/// assert!(Date::from_iso_week_date(2019, 1, Tuesday).is_ok());\n/// assert!(Date::from_iso_week_date(2020, 53, Friday).is_ok());\n/// ```\n///\n/// ```rust\n/// # use time::{Date, Weekday::*};\n/// assert!(Date::from_iso_week_date(2019, 53, Monday).is_err()); // 2019 doesn't have 53 weeks.\n/// ```\npub const fn from_iso_week_date(\n        year: i32,\n        week: u8,\n        weekday: Weekday,\n    ) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        ensure_value_in_range!(week conditionally in 1 => weeks_in_year(year));\n\n        let adj_year = year - 1;\n        let raw = 365 * adj_year + div_floor!(adj_year, 4) - div_floor!(adj_year, 100)\n            + div_floor!(adj_year, 400);\n        let jan_4 = match (raw % 7) as i8 {\n            -6 | 1 => 8,\n            -5 | 2 => 9,\n            -4 | 3 => 10,\n            -3 | 4 => 4,\n            -2 | 5 => 5,\n            -1 | 6 => 6,\n            _ => 7,\n        };\n        let ordinal = week as i16 * 7 + weekday.number_from_monday() as i16 - jan_4;\n\n        Ok(if ordinal <= 0 {\n            Self::__from_ordinal_date_unchecked(\n                year - 1,\n                (ordinal as u16).wrapping_add(days_in_year(year - 1)),\n            )\n        } else if ordinal > days_in_year(year) as i16 {\n            Self::__from_ordinal_date_unchecked(year + 1, ordinal as u16 - days_in_year(year))\n        } else {\n            Self::__from_ordinal_date_unchecked(year, ordinal as _)\n        })\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::from_julian_day":["/// Create a `Date` from the Julian day.\n///\n/// The algorithm to perform this conversion is derived from one provided by Peter Baum; it is\n/// freely available [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).\n///\n/// ```rust\n/// # use time::{Date, macros::date};\n/// assert_eq!(Date::from_julian_day(0), Ok(date!(-4713 - 11 - 24)));\n/// assert_eq!(Date::from_julian_day(2_451_545), Ok(date!(2000 - 01 - 01)));\n/// assert_eq!(Date::from_julian_day(2_458_485), Ok(date!(2019 - 01 - 01)));\n/// assert_eq!(Date::from_julian_day(2_458_849), Ok(date!(2019 - 12 - 31)));\n/// ```\n#[doc(alias = \"from_julian_date\")]\npub const fn from_julian_day(julian_day: i32) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(\n            julian_day in Self::MIN.to_julian_day() => Self::MAX.to_julian_day()\n        );\n        Ok(Self::from_julian_day_unchecked(julian_day))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::from_julian_day_unchecked":["/// Create a `Date` from the Julian day.\n///\n/// This does not check the validity of the provided Julian day, and as such may result in an\n/// internally invalid value.\n#[doc(alias = \"from_julian_date_unchecked\")]\n#![allow(trivial_numeric_casts)]\npub(crate) const fn from_julian_day_unchecked(julian_day: i32) -> Self{\n        #![allow(trivial_numeric_casts)] // cast depends on type alias\n\n        /// A type that is either `i32` or `i64`. This subtle difference allows for optimization\n        /// based on the valid values.\n        #[cfg(feature = \"large-dates\")]\n        type MaybeWidened = i64;\n        #[allow(clippy::missing_docs_in_private_items)]\n        #[cfg(not(feature = \"large-dates\"))]\n        type MaybeWidened = i32;\n\n        // To avoid a potential overflow, the value may need to be widened for some arithmetic.\n\n        let z = julian_day - 1_721_119;\n        let g = 100 * z as MaybeWidened - 25;\n        let a = (g / 3_652_425) as i32;\n        let b = a - a / 4;\n        let mut year = div_floor!(100 * b as MaybeWidened + g, 36525) as i32;\n        let mut ordinal = (b + z - div_floor!(36525 * year as MaybeWidened, 100) as i32) as _;\n\n        if is_leap_year(year) {\n            ordinal += 60;\n            cascade!(ordinal in 1..367 => year);\n        } else {\n            ordinal += 59;\n            cascade!(ordinal in 1..366 => year);\n        }\n\n        Self::__from_ordinal_date_unchecked(year, ordinal)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::from_ordinal_date":["/// Attempt to create a `Date` from the year and ordinal day number.\n///\n/// ```rust\n/// # use time::Date;\n/// assert!(Date::from_ordinal_date(2019, 1).is_ok());\n/// assert!(Date::from_ordinal_date(2019, 365).is_ok());\n/// ```\n///\n/// ```rust\n/// # use time::Date;\n/// assert!(Date::from_ordinal_date(2019, 366).is_err()); // 2019 isn't a leap year.\n/// ```\npub const fn from_ordinal_date(year: i32, ordinal: u16) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(year in MIN_YEAR => MAX_YEAR);\n        ensure_value_in_range!(ordinal conditionally in 1 => days_in_year(year));\n        Ok(Self::__from_ordinal_date_unchecked(year, ordinal))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::iso_week":["/// Get the ISO week number.\n///\n/// The returned value will always be in the range `1..=53`.\n///\n/// ```rust\n/// # use time::macros::date;\n/// assert_eq!(date!(2019 - 01 - 01).iso_week(), 1);\n/// assert_eq!(date!(2019 - 10 - 04).iso_week(), 40);\n/// assert_eq!(date!(2020 - 01 - 01).iso_week(), 1);\n/// assert_eq!(date!(2020 - 12 - 31).iso_week(), 53);\n/// assert_eq!(date!(2021 - 01 - 01).iso_week(), 53);\n/// ```\npub const fn iso_week(self) -> u8{\n        self.iso_year_week().1\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::iso_year_week":["/// Get the ISO 8601 year and week number.\npub(crate) const fn iso_year_week(self) -> (i32, u8){\n        let (year, ordinal) = self.to_ordinal_date();\n\n        match ((ordinal + 10 - self.weekday().number_from_monday() as u16) / 7) as _ {\n            0 => (year - 1, weeks_in_year(year - 1)),\n            53 if weeks_in_year(year) == 52 => (year + 1, 1),\n            week => (year, week),\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::midnight":["/// Create a [`PrimitiveDateTime`] using the existing date. The [`Time`] component will be set\n/// to midnight.\n///\n/// ```rust\n/// # use time::macros::{date, datetime};\n/// assert_eq!(date!(1970-01-01).midnight(), datetime!(1970-01-01 0:00));\n/// ```\npub const fn midnight(self) -> PrimitiveDateTime{\n        PrimitiveDateTime::new(self, Time::MIDNIGHT)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::monday_based_week":["/// Get the week number where week 1 begins on the first Monday.\n///\n/// The returned value will always be in the range `0..=53`.\n///\n/// ```rust\n/// # use time::macros::date;\n/// assert_eq!(date!(2019 - 01 - 01).monday_based_week(), 0);\n/// assert_eq!(date!(2020 - 01 - 01).monday_based_week(), 0);\n/// assert_eq!(date!(2020 - 12 - 31).monday_based_week(), 52);\n/// assert_eq!(date!(2021 - 01 - 01).monday_based_week(), 0);\n/// ```\npub const fn monday_based_week(self) -> u8{\n        ((self.ordinal() as i16 - self.weekday().number_days_from_monday() as i16 + 6) / 7) as _\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::month":["/// Get the month.\n///\n/// ```rust\n/// # use time::{macros::date, Month};\n/// assert_eq!(date!(2019 - 01 - 01).month(), Month::January);\n/// assert_eq!(date!(2019 - 12 - 31).month(), Month::December);\n/// ```\npub const fn month(self) -> Month{\n        self.month_day().0\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::month_day":["/// Get the month and day. This is more efficient than fetching the components individually.\npub(crate) const fn month_day(self) -> (Month, u8){\n        /// The number of days up to and including the given month. Common years\n        /// are first, followed by leap years.\n        const CUMULATIVE_DAYS_IN_MONTH_COMMON_LEAP: [[u16; 11]; 2] = [\n            [31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n            [31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n        ];\n\n        let days = CUMULATIVE_DAYS_IN_MONTH_COMMON_LEAP[is_leap_year(self.year()) as usize];\n        let ordinal = self.ordinal();\n\n        if ordinal > days[10] {\n            (Month::December, (ordinal - days[10]) as _)\n        } else if ordinal > days[9] {\n            (Month::November, (ordinal - days[9]) as _)\n        } else if ordinal > days[8] {\n            (Month::October, (ordinal - days[8]) as _)\n        } else if ordinal > days[7] {\n            (Month::September, (ordinal - days[7]) as _)\n        } else if ordinal > days[6] {\n            (Month::August, (ordinal - days[6]) as _)\n        } else if ordinal > days[5] {\n            (Month::July, (ordinal - days[5]) as _)\n        } else if ordinal > days[4] {\n            (Month::June, (ordinal - days[4]) as _)\n        } else if ordinal > days[3] {\n            (Month::May, (ordinal - days[3]) as _)\n        } else if ordinal > days[2] {\n            (Month::April, (ordinal - days[2]) as _)\n        } else if ordinal > days[1] {\n            (Month::March, (ordinal - days[1]) as _)\n        } else if ordinal > days[0] {\n            (Month::February, (ordinal - days[0]) as _)\n        } else {\n            (Month::January, ordinal as _)\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::next_day":["/// Get the next calendar date.\n///\n/// ```rust\n/// # use time::{Date, macros::date};\n/// assert_eq!(\n///     date!(2019 - 01 - 01).next_day(),\n///     Some(date!(2019 - 01 - 02))\n/// );\n/// assert_eq!(\n///     date!(2019 - 01 - 31).next_day(),\n///     Some(date!(2019 - 02 - 01))\n/// );\n/// assert_eq!(\n///     date!(2019 - 12 - 31).next_day(),\n///     Some(date!(2020 - 01 - 01))\n/// );\n/// assert_eq!(Date::MAX.next_day(), None);\n/// ```\npub const fn next_day(self) -> Option<Self>{\n        if self.ordinal() == 366 || (self.ordinal() == 365 && !is_leap_year(self.year())) {\n            if self.value == Self::MAX.value {\n                None\n            } else {\n                Some(Self::__from_ordinal_date_unchecked(self.year() + 1, 1))\n            }\n        } else {\n            Some(Self {\n                value: self.value + 1,\n            })\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::ordinal":["/// Get the day of the year.\n///\n/// The returned value will always be in the range `1..=366` (`1..=365` for common years).\n///\n/// ```rust\n/// # use time::macros::date;\n/// assert_eq!(date!(2019 - 01 - 01).ordinal(), 1);\n/// assert_eq!(date!(2019 - 12 - 31).ordinal(), 365);\n/// ```\npub const fn ordinal(self) -> u16{\n        (self.value & 0x1FF) as _\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::previous_day":["/// Get the previous calendar date.\n///\n/// ```rust\n/// # use time::{Date, macros::date};\n/// assert_eq!(\n///     date!(2019 - 01 - 02).previous_day(),\n///     Some(date!(2019 - 01 - 01))\n/// );\n/// assert_eq!(\n///     date!(2019 - 02 - 01).previous_day(),\n///     Some(date!(2019 - 01 - 31))\n/// );\n/// assert_eq!(\n///     date!(2020 - 01 - 01).previous_day(),\n///     Some(date!(2019 - 12 - 31))\n/// );\n/// assert_eq!(Date::MIN.previous_day(), None);\n/// ```\npub const fn previous_day(self) -> Option<Self>{\n        if self.ordinal() != 1 {\n            Some(Self {\n                value: self.value - 1,\n            })\n        } else if self.value == Self::MIN.value {\n            None\n        } else {\n            Some(Self::__from_ordinal_date_unchecked(\n                self.year() - 1,\n                days_in_year(self.year() - 1),\n            ))\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::saturating_add":["/// Computes `self + duration`, saturating value on overflow.\n///\n/// ```rust\n/// # use time::{Date, ext::NumericalDuration, macros::date};\n/// assert_eq!(Date::MAX.saturating_add(1.days()), Date::MAX);\n/// assert_eq!(Date::MIN.saturating_add((-2).days()), Date::MIN);\n/// assert_eq!(\n///     date!(2020 - 12 - 31).saturating_add(2.days()),\n///     date!(2021 - 01 - 02)\n/// );\n/// ```\n///\n/// # Note\n///\n/// This function only takes whole days into account.\n///\n/// ```rust\n/// # use time::{ext::NumericalDuration, macros::date};\n/// assert_eq!(\n///     date!(2020 - 12 - 31).saturating_add(23.hours()),\n///     date!(2020 - 12 - 31)\n/// );\n/// assert_eq!(\n///     date!(2020 - 12 - 31).saturating_add(47.hours()),\n///     date!(2021 - 01 - 01)\n/// );\n/// ```\npub const fn saturating_add(self, duration: Duration) -> Self{\n        if let Some(datetime) = self.checked_add(duration) {\n            datetime\n        } else if duration.is_negative() {\n            Self::MIN\n        } else {\n            Self::MAX\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::saturating_sub":["/// Computes `self - duration`, saturating value on overflow.\n///\n/// ```\n/// # use time::{Date, ext::NumericalDuration, macros::date};\n/// assert_eq!(Date::MAX.saturating_sub((-2).days()), Date::MAX);\n/// assert_eq!(Date::MIN.saturating_sub(1.days()), Date::MIN);\n/// assert_eq!(\n///     date!(2020 - 12 - 31).saturating_sub(2.days()),\n///     date!(2020 - 12 - 29)\n/// );\n/// ```\n///\n/// # Note\n///\n/// This function only takes whole days into account.\n///\n/// ```\n/// # use time::{ext::NumericalDuration, macros::date};\n/// assert_eq!(\n///     date!(2020 - 12 - 31).saturating_sub(23.hours()),\n///     date!(2020 - 12 - 31)\n/// );\n/// assert_eq!(\n///     date!(2020 - 12 - 31).saturating_sub(47.hours()),\n///     date!(2020 - 12 - 30)\n/// );\n/// ```\npub const fn saturating_sub(self, duration: Duration) -> Self{\n        if let Some(datetime) = self.checked_sub(duration) {\n            datetime\n        } else if duration.is_negative() {\n            Self::MAX\n        } else {\n            Self::MIN\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::sunday_based_week":["/// Get the week number where week 1 begins on the first Sunday.\n///\n/// The returned value will always be in the range `0..=53`.\n///\n/// ```rust\n/// # use time::macros::date;\n/// assert_eq!(date!(2019 - 01 - 01).sunday_based_week(), 0);\n/// assert_eq!(date!(2020 - 01 - 01).sunday_based_week(), 0);\n/// assert_eq!(date!(2020 - 12 - 31).sunday_based_week(), 52);\n/// assert_eq!(date!(2021 - 01 - 01).sunday_based_week(), 0);\n/// ```\npub const fn sunday_based_week(self) -> u8{\n        ((self.ordinal() as i16 - self.weekday().number_days_from_sunday() as i16 + 6) / 7) as _\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::to_calendar_date":["/// Get the year, month, and day.\n///\n/// ```rust\n/// # use time::{macros::date, Month};\n/// assert_eq!(\n///     date!(2019 - 01 - 01).to_calendar_date(),\n///     (2019, Month::January, 1)\n/// );\n/// ```\npub const fn to_calendar_date(self) -> (i32, Month, u8){\n        let (month, day) = self.month_day();\n        (self.year(), month, day)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::to_iso_week_date":["/// Get the ISO 8601 year, week number, and weekday.\n///\n/// ```rust\n/// # use time::{Weekday::*, macros::date};\n/// assert_eq!(date!(2019 - 01 - 01).to_iso_week_date(), (2019, 1, Tuesday));\n/// assert_eq!(date!(2019 - 10 - 04).to_iso_week_date(), (2019, 40, Friday));\n/// assert_eq!(\n///     date!(2020 - 01 - 01).to_iso_week_date(),\n///     (2020, 1, Wednesday)\n/// );\n/// assert_eq!(\n///     date!(2020 - 12 - 31).to_iso_week_date(),\n///     (2020, 53, Thursday)\n/// );\n/// assert_eq!(date!(2021 - 01 - 01).to_iso_week_date(), (2020, 53, Friday));\n/// ```\npub const fn to_iso_week_date(self) -> (i32, u8, Weekday){\n        let (year, ordinal) = self.to_ordinal_date();\n        let weekday = self.weekday();\n\n        match ((ordinal + 10 - self.weekday().number_from_monday() as u16) / 7) as _ {\n            0 => (year - 1, weeks_in_year(year - 1), weekday),\n            53 if weeks_in_year(year) == 52 => (year + 1, 1, weekday),\n            week => (year, week, weekday),\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::to_julian_day":["/// Get the Julian day for the date.\n///\n/// The algorithm to perform this conversion is derived from one provided by Peter Baum; it is\n/// freely available [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).\n///\n/// ```rust\n/// # use time::macros::date;\n/// assert_eq!(date!(-4713 - 11 - 24).to_julian_day(), 0);\n/// assert_eq!(date!(2000 - 01 - 01).to_julian_day(), 2_451_545);\n/// assert_eq!(date!(2019 - 01 - 01).to_julian_day(), 2_458_485);\n/// assert_eq!(date!(2019 - 12 - 31).to_julian_day(), 2_458_849);\n/// ```\npub const fn to_julian_day(self) -> i32{\n        let year = self.year() - 1;\n        let ordinal = self.ordinal() as i32;\n\n        ordinal + 365 * year + div_floor!(year, 4) - div_floor!(year, 100)\n            + div_floor!(year, 400)\n            + 1_721_425\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::to_ordinal_date":["/// Get the year and ordinal day number.\n///\n/// ```rust\n/// # use time::macros::date;\n/// assert_eq!(date!(2019 - 01 - 01).to_ordinal_date(), (2019, 1));\n/// ```\npub const fn to_ordinal_date(self) -> (i32, u16){\n        (self.year(), self.ordinal())\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::weekday":["/// Get the weekday.\n///\n/// ```rust\n/// # use time::{Weekday::*, macros::date};\n/// assert_eq!(date!(2019 - 01 - 01).weekday(), Tuesday);\n/// assert_eq!(date!(2019 - 02 - 01).weekday(), Friday);\n/// assert_eq!(date!(2019 - 03 - 01).weekday(), Friday);\n/// assert_eq!(date!(2019 - 04 - 01).weekday(), Monday);\n/// assert_eq!(date!(2019 - 05 - 01).weekday(), Wednesday);\n/// assert_eq!(date!(2019 - 06 - 01).weekday(), Saturday);\n/// assert_eq!(date!(2019 - 07 - 01).weekday(), Monday);\n/// assert_eq!(date!(2019 - 08 - 01).weekday(), Thursday);\n/// assert_eq!(date!(2019 - 09 - 01).weekday(), Sunday);\n/// assert_eq!(date!(2019 - 10 - 01).weekday(), Tuesday);\n/// assert_eq!(date!(2019 - 11 - 01).weekday(), Friday);\n/// assert_eq!(date!(2019 - 12 - 01).weekday(), Sunday);\n/// ```\npub const fn weekday(self) -> Weekday{\n        match self.to_julian_day() % 7 {\n            -6 | 1 => Weekday::Tuesday,\n            -5 | 2 => Weekday::Wednesday,\n            -4 | 3 => Weekday::Thursday,\n            -3 | 4 => Weekday::Friday,\n            -2 | 5 => Weekday::Saturday,\n            -1 | 6 => Weekday::Sunday,\n            _ => Weekday::Monday,\n        }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::with_hms":["/// Attempt to create a [`PrimitiveDateTime`] using the existing date and the provided time.\n///\n/// ```rust\n/// # use time::macros::date;\n/// assert!(date!(1970 - 01 - 01).with_hms(0, 0, 0).is_ok());\n/// assert!(date!(1970 - 01 - 01).with_hms(24, 0, 0).is_err());\n/// ```\npub const fn with_hms(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange>{\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::from_hms(hour, minute, second)),\n        ))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::with_hms_micro":["/// Attempt to create a [`PrimitiveDateTime`] using the existing date and the provided time.\n///\n/// ```rust\n/// # use time::macros::date;\n/// assert!(date!(1970 - 01 - 01).with_hms_micro(0, 0, 0, 0).is_ok());\n/// assert!(date!(1970 - 01 - 01).with_hms_micro(24, 0, 0, 0).is_err());\n/// ```\npub const fn with_hms_micro(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        microsecond: u32,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange>{\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::from_hms_micro(hour, minute, second, microsecond)),\n        ))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::with_hms_milli":["/// Attempt to create a [`PrimitiveDateTime`] using the existing date and the provided time.\n///\n/// ```rust\n/// # use time::macros::date;\n/// assert!(date!(1970 - 01 - 01).with_hms_milli(0, 0, 0, 0).is_ok());\n/// assert!(date!(1970 - 01 - 01).with_hms_milli(24, 0, 0, 0).is_err());\n/// ```\npub const fn with_hms_milli(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        millisecond: u16,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange>{\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::from_hms_milli(hour, minute, second, millisecond)),\n        ))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::with_hms_nano":["/// Attempt to create a [`PrimitiveDateTime`] using the existing date and the provided time.\n///\n/// ```rust\n/// # use time::macros::date;\n/// assert!(date!(1970 - 01 - 01).with_hms_nano(0, 0, 0, 0).is_ok());\n/// assert!(date!(1970 - 01 - 01).with_hms_nano(24, 0, 0, 0).is_err());\n/// ```\npub const fn with_hms_nano(\n        self,\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> Result<PrimitiveDateTime, error::ComponentRange>{\n        Ok(PrimitiveDateTime::new(\n            self,\n            const_try!(Time::from_hms_nano(hour, minute, second, nanosecond)),\n        ))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::with_time":["/// Create a [`PrimitiveDateTime`] using the existing date and the provided [`Time`].\n///\n/// ```rust\n/// # use time::macros::{date, datetime, time};\n/// assert_eq!(\n///     date!(1970-01-01).with_time(time!(0:00)),\n///     datetime!(1970-01-01 0:00),\n/// );\n/// ```\npub const fn with_time(self, time: Time) -> PrimitiveDateTime{\n        PrimitiveDateTime::new(self, time)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::year":["/// Get the year of the date.\n///\n/// ```rust\n/// # use time::macros::date;\n/// assert_eq!(date!(2019 - 01 - 01).year(), 2019);\n/// assert_eq!(date!(2019 - 12 - 31).year(), 2019);\n/// assert_eq!(date!(2020 - 01 - 01).year(), 2020);\n/// ```\npub const fn year(self) -> i32{\n        self.value >> 9\n    }","Real(LocalPath(\"src/date.rs\"))"],"duration::<impl std::cmp::PartialEq<duration::Duration> for std::time::Duration>::eq":["fn eq(&self, rhs: &Duration) -> bool{\n        rhs == self\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::cmp::PartialOrd<duration::Duration> for std::time::Duration>::partial_cmp":["fn partial_cmp(&self, rhs: &Duration) -> Option<Ordering>{\n        rhs.partial_cmp(self).map(Ordering::reverse)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::convert::TryFrom<duration::Duration> for std::time::Duration>::try_from":["fn try_from(duration: Duration) -> Result<Self, error::ConversionRange>{\n        Ok(Self::new(\n            duration\n                .seconds\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n            duration\n                .nanoseconds\n                .try_into()\n                .map_err(|_| error::ConversionRange)?,\n        ))\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Add<duration::Duration> for std::time::Duration>::add":["fn add(self, rhs: Duration) -> Self::Output{\n        rhs + self\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Div<duration::Duration> for std::time::Duration>::div":["fn div(self, rhs: Duration) -> Self::Output{\n        self.as_secs_f64() / rhs.as_seconds_f64()\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for f32>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n        rhs * self\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for f64>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n        rhs * self\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for i16>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n                rhs * self\n            }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for i32>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n                rhs * self\n            }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for i8>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n                rhs * self\n            }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for u16>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n                rhs * self\n            }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for u32>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n                rhs * self\n            }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Mul<duration::Duration> for u8>::mul":["fn mul(self, rhs: Duration) -> Self::Output{\n                rhs * self\n            }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::Sub<duration::Duration> for std::time::Duration>::sub":["fn sub(self, rhs: Duration) -> Self::Output{\n        Duration::try_from(self)\n            .expect(\"overflow converting `std::time::Duration` to `time::Duration`\")\n            - rhs\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::<impl std::ops::SubAssign<duration::Duration> for std::time::Duration>::sub_assign":["fn sub_assign(&mut self, rhs: Duration){\n        *self = (*self - rhs).try_into().expect(\n            \"Cannot represent a resulting duration in std. Try `let x = x - rhs;`, which will \\\n             change the type.\",\n        );\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration":["/// A span of time with nanosecond precision.\n///\n/// Each `Duration` is composed of a whole number of seconds and a fractional part represented in\n/// nanoseconds.\n///\n/// This implementation allows for negative durations, unlike [`core::time::Duration`].\npub struct Duration {\n    /// Number of whole seconds.\n    seconds: i64,\n    /// Number of nanoseconds within the second. The sign always matches the `seconds` field.\n    nanoseconds: i32, // always -10^9 < nanoseconds < 10^9\n    #[allow(clippy::missing_docs_in_private_items)]\n    padding: Padding,\n}","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::abs":["/// Get the absolute value of the duration.\n///\n/// This method saturates the returned value if it would otherwise overflow.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.seconds().abs(), 1.seconds());\n/// assert_eq!(0.seconds().abs(), 0.seconds());\n/// assert_eq!((-1).seconds().abs(), 1.seconds());\n/// ```\npub const fn abs(self) -> Self{\n        Self::new_unchecked(self.seconds.saturating_abs(), self.nanoseconds.abs())\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::abs_std":["/// Convert the existing `Duration` to a `std::time::Duration` and its sign. This doesn't\n/// actually require the standard library, but is currently only used when it's enabled.\n#[allow(clippy::missing_const_for_fn)]\n#[cfg(feature = \"std\")]\npub(crate) fn abs_std(self) -> StdDuration{\n        StdDuration::new(self.seconds.unsigned_abs(), self.nanoseconds.unsigned_abs())\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::as_seconds_f32":["/// Get the number of fractional seconds in the duration.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.5.seconds().as_seconds_f32(), 1.5);\n/// assert_eq!((-1.5).seconds().as_seconds_f32(), -1.5);\n/// ```\npub fn as_seconds_f32(self) -> f32{\n        self.seconds as f32 + self.nanoseconds as f32 / 1_000_000_000.\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::as_seconds_f64":["/// Get the number of fractional seconds in the duration.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.5.seconds().as_seconds_f64(), 1.5);\n/// assert_eq!((-1.5).seconds().as_seconds_f64(), -1.5);\n/// ```\npub fn as_seconds_f64(self) -> f64{\n        self.seconds as f64 + self.nanoseconds as f64 / 1_000_000_000.\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::checked_add":["/// Computes `self + rhs`, returning `None` if an overflow occurred.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(5.seconds().checked_add(5.seconds()), Some(10.seconds()));\n/// assert_eq!(Duration::MAX.checked_add(1.nanoseconds()), None);\n/// assert_eq!((-5).seconds().checked_add(5.seconds()), Some(0.seconds()));\n/// ```\npub const fn checked_add(self, rhs: Self) -> Option<Self>{\n        let mut seconds = const_try_opt!(self.seconds.checked_add(rhs.seconds));\n        let mut nanoseconds = self.nanoseconds + rhs.nanoseconds;\n\n        if nanoseconds >= 1_000_000_000 || seconds < 0 && nanoseconds > 0 {\n            nanoseconds -= 1_000_000_000;\n            seconds = const_try_opt!(seconds.checked_add(1));\n        } else if nanoseconds <= -1_000_000_000 || seconds > 0 && nanoseconds < 0 {\n            nanoseconds += 1_000_000_000;\n            seconds = const_try_opt!(seconds.checked_sub(1));\n        }\n\n        Some(Self::new_unchecked(seconds, nanoseconds))\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::checked_div":["/// Computes `self / rhs`, returning `None` if `rhs == 0` or if the result would overflow.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(10.seconds().checked_div(2), Some(5.seconds()));\n/// assert_eq!(10.seconds().checked_div(-2), Some((-5).seconds()));\n/// assert_eq!(1.seconds().checked_div(0), None);\n/// ```\npub const fn checked_div(self, rhs: i32) -> Option<Self>{\n        let seconds = const_try_opt!(self.seconds.checked_div(rhs as i64));\n        let carry = self.seconds - seconds * (rhs as i64);\n        let extra_nanos = const_try_opt!((carry * 1_000_000_000).checked_div(rhs as i64));\n        let nanoseconds = const_try_opt!(self.nanoseconds.checked_div(rhs)) + (extra_nanos as i32);\n\n        Some(Self::new_unchecked(seconds, nanoseconds))\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::checked_mul":["/// Computes `self * rhs`, returning `None` if an overflow occurred.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(5.seconds().checked_mul(2), Some(10.seconds()));\n/// assert_eq!(5.seconds().checked_mul(-2), Some((-10).seconds()));\n/// assert_eq!(5.seconds().checked_mul(0), Some(0.seconds()));\n/// assert_eq!(Duration::MAX.checked_mul(2), None);\n/// assert_eq!(Duration::MIN.checked_mul(2), None);\n/// ```\npub const fn checked_mul(self, rhs: i32) -> Option<Self>{\n        // Multiply nanoseconds as i64, because it cannot overflow that way.\n        let total_nanos = self.nanoseconds as i64 * rhs as i64;\n        let extra_secs = total_nanos / 1_000_000_000;\n        let nanoseconds = (total_nanos % 1_000_000_000) as _;\n        let seconds = const_try_opt!(\n            const_try_opt!(self.seconds.checked_mul(rhs as _)).checked_add(extra_secs)\n        );\n\n        Some(Self::new_unchecked(seconds, nanoseconds))\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::checked_sub":["/// Computes `self - rhs`, returning `None` if an overflow occurred.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(5.seconds().checked_sub(5.seconds()), Some(Duration::ZERO));\n/// assert_eq!(Duration::MIN.checked_sub(1.nanoseconds()), None);\n/// assert_eq!(5.seconds().checked_sub(10.seconds()), Some((-5).seconds()));\n/// ```\npub const fn checked_sub(self, rhs: Self) -> Option<Self>{\n        let mut seconds = const_try_opt!(self.seconds.checked_sub(rhs.seconds));\n        let mut nanoseconds = self.nanoseconds - rhs.nanoseconds;\n\n        if nanoseconds >= 1_000_000_000 || seconds < 0 && nanoseconds > 0 {\n            nanoseconds -= 1_000_000_000;\n            seconds = const_try_opt!(seconds.checked_add(1));\n        } else if nanoseconds <= -1_000_000_000 || seconds > 0 && nanoseconds < 0 {\n            nanoseconds += 1_000_000_000;\n            seconds = const_try_opt!(seconds.checked_sub(1));\n        }\n\n        Some(Self::new_unchecked(seconds, nanoseconds))\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::days":["/// Create a new `Duration` with the given number of days. Equivalent to\n/// `Duration::seconds(days * 86_400)`.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(Duration::days(1), 86_400.seconds());\n/// ```\npub const fn days(days: i64) -> Self{\n        Self::seconds(days * 86_400)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::hours":["/// Create a new `Duration` with the given number of hours. Equivalent to\n/// `Duration::seconds(hours * 3_600)`.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(Duration::hours(1), 3_600.seconds());\n/// ```\npub const fn hours(hours: i64) -> Self{\n        Self::seconds(hours * 3_600)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::is_negative":["/// Check if a duration is negative.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert!((-1).seconds().is_negative());\n/// assert!(!0.seconds().is_negative());\n/// assert!(!1.seconds().is_negative());\n/// ```\npub const fn is_negative(self) -> bool{\n        self.seconds < 0 || self.nanoseconds < 0\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::is_positive":["/// Check if a duration is positive.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert!(1.seconds().is_positive());\n/// assert!(!0.seconds().is_positive());\n/// assert!(!(-1).seconds().is_positive());\n/// ```\npub const fn is_positive(self) -> bool{\n        self.seconds > 0 || self.nanoseconds > 0\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::is_zero":["/// Check if a duration is exactly zero.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert!(0.seconds().is_zero());\n/// assert!(!1.nanoseconds().is_zero());\n/// ```\npub const fn is_zero(self) -> bool{\n        self.seconds == 0 && self.nanoseconds == 0\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::microseconds":["/// Create a new `Duration` with the given number of microseconds.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(Duration::microseconds(1), 1_000.nanoseconds());\n/// assert_eq!(Duration::microseconds(-1), (-1_000).nanoseconds());\n/// ```\npub const fn microseconds(microseconds: i64) -> Self{\n        Self::new_unchecked(\n            microseconds / 1_000_000,\n            ((microseconds % 1_000_000) * 1_000) as _,\n        )\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::milliseconds":["/// Create a new `Duration` with the given number of milliseconds.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(Duration::milliseconds(1), 1_000.microseconds());\n/// assert_eq!(Duration::milliseconds(-1), (-1_000).microseconds());\n/// ```\npub const fn milliseconds(milliseconds: i64) -> Self{\n        Self::new_unchecked(\n            milliseconds / 1_000,\n            ((milliseconds % 1_000) * 1_000_000) as _,\n        )\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::minutes":["/// Create a new `Duration` with the given number of minutes. Equivalent to\n/// `Duration::seconds(minutes * 60)`.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(Duration::minutes(1), 60.seconds());\n/// ```\npub const fn minutes(minutes: i64) -> Self{\n        Self::seconds(minutes * 60)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::nanoseconds":["/// Create a new `Duration` with the given number of nanoseconds.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(Duration::nanoseconds(1), 1.microseconds() / 1_000);\n/// assert_eq!(Duration::nanoseconds(-1), (-1).microseconds() / 1_000);\n/// ```\npub const fn nanoseconds(nanoseconds: i64) -> Self{\n        Self::new_unchecked(\n            nanoseconds / 1_000_000_000,\n            (nanoseconds % 1_000_000_000) as _,\n        )\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::nanoseconds_i128":["/// Create a new `Duration` with the given number of nanoseconds.\n///\n/// As the input range cannot be fully mapped to the output, this should only be used where it's\n/// known to result in a valid value.\npub(crate) const fn nanoseconds_i128(nanoseconds: i128) -> Self{\n        Self::new_unchecked(\n            (nanoseconds / 1_000_000_000) as _,\n            (nanoseconds % 1_000_000_000) as _,\n        )\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::new":["/// Create a new `Duration` with the provided seconds and nanoseconds. If nanoseconds is at\n/// least ±10<sup>9</sup>, it will wrap to the number of seconds.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(Duration::new(1, 0), 1.seconds());\n/// assert_eq!(Duration::new(-1, 0), (-1).seconds());\n/// assert_eq!(Duration::new(1, 2_000_000_000), 3.seconds());\n/// ```\npub const fn new(mut seconds: i64, mut nanoseconds: i32) -> Self{\n        seconds += nanoseconds as i64 / 1_000_000_000;\n        nanoseconds %= 1_000_000_000;\n\n        if seconds > 0 && nanoseconds < 0 {\n            seconds -= 1;\n            nanoseconds += 1_000_000_000;\n        } else if seconds < 0 && nanoseconds > 0 {\n            seconds += 1;\n            nanoseconds -= 1_000_000_000;\n        }\n\n        Self::new_unchecked(seconds, nanoseconds)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::new_unchecked":["/// Create a new `Duration` without checking the validity of the components.\npub(crate) const fn new_unchecked(seconds: i64, nanoseconds: i32) -> Self{\n        Self {\n            seconds,\n            nanoseconds,\n            padding: Padding::Optimize,\n        }\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::saturating_add":["/// Computes `self + rhs`, saturating if an overflow occurred.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(5.seconds().saturating_add(5.seconds()), 10.seconds());\n/// assert_eq!(Duration::MAX.saturating_add(1.nanoseconds()), Duration::MAX);\n/// assert_eq!(\n///     Duration::MIN.saturating_add((-1).nanoseconds()),\n///     Duration::MIN\n/// );\n/// assert_eq!((-5).seconds().saturating_add(5.seconds()), Duration::ZERO);\n/// ```\npub const fn saturating_add(self, rhs: Self) -> Self{\n        let (mut seconds, overflow) = self.seconds.overflowing_add(rhs.seconds);\n        if overflow {\n            if self.seconds > 0 {\n                return Self::MAX;\n            }\n            return Self::MIN;\n        }\n        let mut nanoseconds = self.nanoseconds + rhs.nanoseconds;\n\n        if nanoseconds >= 1_000_000_000 || seconds < 0 && nanoseconds > 0 {\n            nanoseconds -= 1_000_000_000;\n            seconds = match seconds.checked_add(1) {\n                Some(seconds) => seconds,\n                None => return Self::MAX,\n            };\n        } else if nanoseconds <= -1_000_000_000 || seconds > 0 && nanoseconds < 0 {\n            nanoseconds += 1_000_000_000;\n            seconds = match seconds.checked_sub(1) {\n                Some(seconds) => seconds,\n                None => return Self::MIN,\n            };\n        }\n\n        Self::new_unchecked(seconds, nanoseconds)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::saturating_mul":["/// Computes `self * rhs`, saturating if an overflow occurred.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(5.seconds().saturating_mul(2), 10.seconds());\n/// assert_eq!(5.seconds().saturating_mul(-2), (-10).seconds());\n/// assert_eq!(5.seconds().saturating_mul(0), Duration::ZERO);\n/// assert_eq!(Duration::MAX.saturating_mul(2), Duration::MAX);\n/// assert_eq!(Duration::MIN.saturating_mul(2), Duration::MIN);\n/// assert_eq!(Duration::MAX.saturating_mul(-2), Duration::MIN);\n/// assert_eq!(Duration::MIN.saturating_mul(-2), Duration::MAX);\n/// ```\npub const fn saturating_mul(self, rhs: i32) -> Self{\n        // Multiply nanoseconds as i64, because it cannot overflow that way.\n        let total_nanos = self.nanoseconds as i64 * rhs as i64;\n        let extra_secs = total_nanos / 1_000_000_000;\n        let nanoseconds = (total_nanos % 1_000_000_000) as _;\n        let (seconds, overflow1) = self.seconds.overflowing_mul(rhs as _);\n        if overflow1 {\n            if self.seconds > 0 && rhs > 0 || self.seconds < 0 && rhs < 0 {\n                return Self::MAX;\n            }\n            return Self::MIN;\n        }\n        let (seconds, overflow2) = seconds.overflowing_add(extra_secs);\n        if overflow2 {\n            if self.seconds > 0 && rhs > 0 {\n                return Self::MAX;\n            }\n            return Self::MIN;\n        }\n\n        Self::new_unchecked(seconds, nanoseconds)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::saturating_sub":["/// Computes `self - rhs`, saturating if an overflow occurred.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(5.seconds().saturating_sub(5.seconds()), Duration::ZERO);\n/// assert_eq!(Duration::MIN.saturating_sub(1.nanoseconds()), Duration::MIN);\n/// assert_eq!(\n///     Duration::MAX.saturating_sub((-1).nanoseconds()),\n///     Duration::MAX\n/// );\n/// assert_eq!(5.seconds().saturating_sub(10.seconds()), (-5).seconds());\n/// ```\npub const fn saturating_sub(self, rhs: Self) -> Self{\n        let (mut seconds, overflow) = self.seconds.overflowing_sub(rhs.seconds);\n        if overflow {\n            if self.seconds > 0 {\n                return Self::MAX;\n            }\n            return Self::MIN;\n        }\n        let mut nanoseconds = self.nanoseconds - rhs.nanoseconds;\n\n        if nanoseconds >= 1_000_000_000 || seconds < 0 && nanoseconds > 0 {\n            nanoseconds -= 1_000_000_000;\n            seconds = match seconds.checked_add(1) {\n                Some(seconds) => seconds,\n                None => return Self::MAX,\n            };\n        } else if nanoseconds <= -1_000_000_000 || seconds > 0 && nanoseconds < 0 {\n            nanoseconds += 1_000_000_000;\n            seconds = match seconds.checked_sub(1) {\n                Some(seconds) => seconds,\n                None => return Self::MIN,\n            };\n        }\n\n        Self::new_unchecked(seconds, nanoseconds)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::seconds":["/// Create a new `Duration` with the given number of seconds.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(Duration::seconds(1), 1_000.milliseconds());\n/// ```\npub const fn seconds(seconds: i64) -> Self{\n        Self::new_unchecked(seconds, 0)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::seconds_f32":["/// Creates a new `Duration` from the specified number of seconds represented as `f32`.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(Duration::seconds_f32(0.5), 0.5.seconds());\n/// assert_eq!(Duration::seconds_f32(-0.5), (-0.5).seconds());\n/// ```\npub fn seconds_f32(seconds: f32) -> Self{\n        Self::new_unchecked(seconds as _, ((seconds % 1.) * 1_000_000_000.) as _)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::seconds_f64":["/// Creates a new `Duration` from the specified number of seconds represented as `f64`.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(Duration::seconds_f64(0.5), 0.5.seconds());\n/// assert_eq!(Duration::seconds_f64(-0.5), -0.5.seconds());\n/// ```\npub fn seconds_f64(seconds: f64) -> Self{\n        Self::new_unchecked(seconds as _, ((seconds % 1.) * 1_000_000_000.) as _)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::subsec_microseconds":["/// Get the number of microseconds past the number of whole seconds.\n///\n/// Always in the range `-1_000_000..1_000_000`.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.0004.seconds().subsec_microseconds(), 400);\n/// assert_eq!((-1.0004).seconds().subsec_microseconds(), -400);\n/// ```\npub const fn subsec_microseconds(self) -> i32{\n        self.nanoseconds / 1_000\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::subsec_milliseconds":["/// Get the number of milliseconds past the number of whole seconds.\n///\n/// Always in the range `-1_000..1_000`.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.4.seconds().subsec_milliseconds(), 400);\n/// assert_eq!((-1.4).seconds().subsec_milliseconds(), -400);\n/// ```\npub const fn subsec_milliseconds(self) -> i16{\n        (self.nanoseconds / 1_000_000) as _\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::subsec_nanoseconds":["/// Get the number of nanoseconds past the number of whole seconds.\n///\n/// The returned value will always be in the range `-1_000_000_000..1_000_000_000`.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.000_000_400.seconds().subsec_nanoseconds(), 400);\n/// assert_eq!((-1.000_000_400).seconds().subsec_nanoseconds(), -400);\n/// ```\npub const fn subsec_nanoseconds(self) -> i32{\n        self.nanoseconds\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::time_fn":["/// Runs a closure, returning the duration of time it took to run. The return value of the\n/// closure is provided in the second part of the tuple.\n#[cfg(feature = \"std\")]\npub fn time_fn<T>(f: impl FnOnce() -> T) -> (Self, T){\n        let start = Instant::now();\n        let return_value = f();\n        let end = Instant::now();\n\n        (end - start, return_value)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::weeks":["/// Create a new `Duration` with the given number of weeks. Equivalent to\n/// `Duration::seconds(weeks * 604_800)`.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(Duration::weeks(1), 604_800.seconds());\n/// ```\npub const fn weeks(weeks: i64) -> Self{\n        Self::seconds(weeks * 604_800)\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_days":["/// Get the number of whole days in the duration.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.days().whole_days(), 1);\n/// assert_eq!((-1).days().whole_days(), -1);\n/// assert_eq!(23.hours().whole_days(), 0);\n/// assert_eq!((-23).hours().whole_days(), 0);\n/// ```\npub const fn whole_days(self) -> i64{\n        self.whole_seconds() / 86_400\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_hours":["/// Get the number of whole hours in the duration.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.hours().whole_hours(), 1);\n/// assert_eq!((-1).hours().whole_hours(), -1);\n/// assert_eq!(59.minutes().whole_hours(), 0);\n/// assert_eq!((-59).minutes().whole_hours(), 0);\n/// ```\npub const fn whole_hours(self) -> i64{\n        self.whole_seconds() / 3_600\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_microseconds":["/// Get the number of whole microseconds in the duration.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.milliseconds().whole_microseconds(), 1_000);\n/// assert_eq!((-1).milliseconds().whole_microseconds(), -1_000);\n/// assert_eq!(1.microseconds().whole_microseconds(), 1);\n/// assert_eq!((-1).microseconds().whole_microseconds(), -1);\n/// ```\npub const fn whole_microseconds(self) -> i128{\n        self.seconds as i128 * 1_000_000 + self.nanoseconds as i128 / 1_000\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_milliseconds":["/// Get the number of whole milliseconds in the duration.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.seconds().whole_milliseconds(), 1_000);\n/// assert_eq!((-1).seconds().whole_milliseconds(), -1_000);\n/// assert_eq!(1.milliseconds().whole_milliseconds(), 1);\n/// assert_eq!((-1).milliseconds().whole_milliseconds(), -1);\n/// ```\npub const fn whole_milliseconds(self) -> i128{\n        self.seconds as i128 * 1_000 + self.nanoseconds as i128 / 1_000_000\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_minutes":["/// Get the number of whole minutes in the duration.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.minutes().whole_minutes(), 1);\n/// assert_eq!((-1).minutes().whole_minutes(), -1);\n/// assert_eq!(59.seconds().whole_minutes(), 0);\n/// assert_eq!((-59).seconds().whole_minutes(), 0);\n/// ```\npub const fn whole_minutes(self) -> i64{\n        self.whole_seconds() / 60\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_nanoseconds":["/// Get the number of nanoseconds in the duration.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.microseconds().whole_nanoseconds(), 1_000);\n/// assert_eq!((-1).microseconds().whole_nanoseconds(), -1_000);\n/// assert_eq!(1.nanoseconds().whole_nanoseconds(), 1);\n/// assert_eq!((-1).nanoseconds().whole_nanoseconds(), -1);\n/// ```\npub const fn whole_nanoseconds(self) -> i128{\n        self.seconds as i128 * 1_000_000_000 + self.nanoseconds as i128\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_seconds":["/// Get the number of whole seconds in the duration.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.seconds().whole_seconds(), 1);\n/// assert_eq!((-1).seconds().whole_seconds(), -1);\n/// assert_eq!(1.minutes().whole_seconds(), 60);\n/// assert_eq!((-1).minutes().whole_seconds(), -60);\n/// ```\npub const fn whole_seconds(self) -> i64{\n        self.seconds\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Duration::whole_weeks":["/// Get the number of whole weeks in the duration.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(1.weeks().whole_weeks(), 1);\n/// assert_eq!((-1).weeks().whole_weeks(), -1);\n/// assert_eq!(6.days().whole_weeks(), 0);\n/// assert_eq!((-6).days().whole_weeks(), 0);\n/// ```\npub const fn whole_weeks(self) -> i64{\n        self.whole_seconds() / 604_800\n    }","Real(LocalPath(\"src/duration.rs\"))"],"duration::Padding":["/// By explicitly inserting this enum where padding is expected, the compiler is able to better\n/// perform niche value optimization.\n#[repr(u32)]\npub(crate) enum Padding {\n    #[allow(clippy::missing_docs_in_private_items)]\n    Optimize,\n}","Real(LocalPath(\"src/duration.rs\"))"],"error::Error":["/// A unified error type for anything returned by a method in the time crate.\n///\n/// This can be used when you either don't know or don't care about the exact error returned.\n/// `Result<_, time::Error>` (or its alias `time::Result<_>`) will work in these situations.\n#[allow(missing_copy_implementations, variant_size_differences)]\n#[allow(clippy::missing_docs_in_private_items)]\n#[non_exhaustive]\npub enum Error {\n    ConversionRange(ConversionRange),\n    ComponentRange(ComponentRange),\n    #[cfg(feature = \"local-offset\")]\n    IndeterminateOffset(IndeterminateOffset),\n    #[cfg(feature = \"formatting\")]\n    Format(Format),\n    #[cfg(feature = \"parsing\")]\n    ParseFromDescription(ParseFromDescription),\n    #[cfg(feature = \"parsing\")]\n    #[non_exhaustive]\n    UnexpectedTrailingCharacters,\n    #[cfg(feature = \"parsing\")]\n    TryFromParsed(TryFromParsed),\n    #[cfg(all(any(feature = \"formatting\", feature = \"parsing\"), feature = \"alloc\"))]\n    InvalidFormatDescription(InvalidFormatDescription),\n    DifferentVariant(DifferentVariant),\n}","Real(LocalPath(\"src/error/mod.rs\"))"],"error::component_range::<impl std::convert::From<error::component_range::ComponentRange> for error::Error>::from":["fn from(original: ComponentRange) -> Self{\n        Self::ComponentRange(original)\n    }","Real(LocalPath(\"src/error/component_range.rs\"))"],"error::component_range::ComponentRange":["/// An error type indicating that a component provided to a method was out of range, causing a\n/// failure.\npub struct ComponentRange {\n    /// Name of the component.\n    pub(crate) name: &'static str,\n    /// Minimum allowed value, inclusive.\n    pub(crate) minimum: i64,\n    /// Maximum allowed value, inclusive.\n    pub(crate) maximum: i64,\n    /// Value that was provided.\n    pub(crate) value: i64,\n    /// The minimum and/or maximum value is conditional on the value of other\n    /// parameters.\n    pub(crate) conditional_range: bool,\n}","Real(LocalPath(\"src/error/component_range.rs\"))"],"error::component_range::ComponentRange::name":["/// Obtain the name of the component whose value was out of range.\npub const fn name(self) -> &'static str{\n        self.name\n    }","Real(LocalPath(\"src/error/component_range.rs\"))"],"error::conversion_range::<impl std::convert::From<error::conversion_range::ConversionRange> for error::Error>::from":["fn from(err: ConversionRange) -> Self{\n        Self::ConversionRange(err)\n    }","Real(LocalPath(\"src/error/conversion_range.rs\"))"],"error::conversion_range::ConversionRange":["/// An error type indicating that a conversion failed because the target type could not store the\n/// initial value.\npub struct ConversionRange;","Real(LocalPath(\"src/error/conversion_range.rs\"))"],"error::different_variant::<impl std::convert::From<error::different_variant::DifferentVariant> for error::Error>::from":["fn from(err: DifferentVariant) -> Self{\n        Self::DifferentVariant(err)\n    }","Real(LocalPath(\"src/error/different_variant.rs\"))"],"error::different_variant::DifferentVariant":["/// An error type indicating that a [`TryFrom`](core::convert::TryFrom) call failed because the\n/// original value was of a different variant.\npub struct DifferentVariant;","Real(LocalPath(\"src/error/different_variant.rs\"))"],"ext::NumericalDuration":["/// Create [`Duration`]s from numeric literals.\n///\n/// # Examples\n///\n/// Basic construction of [`Duration`]s.\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!(5.nanoseconds(), Duration::nanoseconds(5));\n/// assert_eq!(5.microseconds(), Duration::microseconds(5));\n/// assert_eq!(5.milliseconds(), Duration::milliseconds(5));\n/// assert_eq!(5.seconds(), Duration::seconds(5));\n/// assert_eq!(5.minutes(), Duration::minutes(5));\n/// assert_eq!(5.hours(), Duration::hours(5));\n/// assert_eq!(5.days(), Duration::days(5));\n/// assert_eq!(5.weeks(), Duration::weeks(5));\n/// ```\n///\n/// Signed integers work as well!\n///\n/// ```rust\n/// # use time::{Duration, ext::NumericalDuration};\n/// assert_eq!((-5).nanoseconds(), Duration::nanoseconds(-5));\n/// assert_eq!((-5).microseconds(), Duration::microseconds(-5));\n/// assert_eq!((-5).milliseconds(), Duration::milliseconds(-5));\n/// assert_eq!((-5).seconds(), Duration::seconds(-5));\n/// assert_eq!((-5).minutes(), Duration::minutes(-5));\n/// assert_eq!((-5).hours(), Duration::hours(-5));\n/// assert_eq!((-5).days(), Duration::days(-5));\n/// assert_eq!((-5).weeks(), Duration::weeks(-5));\n/// ```\n///\n/// Just like any other [`Duration`], they can be added, subtracted, etc.\n///\n/// ```rust\n/// # use time::ext::NumericalDuration;\n/// assert_eq!(2.seconds() + 500.milliseconds(), 2_500.milliseconds());\n/// assert_eq!(2.seconds() - 500.milliseconds(), 1_500.milliseconds());\n/// ```\n///\n/// When called on floating point values, any remainder of the floating point value will be\n/// truncated. Keep in mind that floating point numbers are inherently imprecise and have limited\n/// capacity.\npub trait NumericalDuration: sealed::Sealed {\n    /// Create a [`Duration`] from the number of nanoseconds.\n    fn nanoseconds(self) -> Duration;\n    /// Create a [`Duration`] from the number of microseconds.\n    fn microseconds(self) -> Duration;\n    /// Create a [`Duration`] from the number of milliseconds.\n    fn milliseconds(self) -> Duration;\n    /// Create a [`Duration`] from the number of seconds.\n    fn seconds(self) -> Duration;\n    /// Create a [`Duration`] from the number of minutes.\n    fn minutes(self) -> Duration;\n    /// Create a [`Duration`] from the number of hours.\n    fn hours(self) -> Duration;\n    /// Create a [`Duration`] from the number of days.\n    fn days(self) -> Duration;\n    /// Create a [`Duration`] from the number of weeks.\n    fn weeks(self) -> Duration;\n}","Real(LocalPath(\"src/ext.rs\"))"],"ext::NumericalStdDuration":["/// Create [`std::time::Duration`]s from numeric literals.\n///\n/// # Examples\n///\n/// Basic construction of [`std::time::Duration`]s.\n///\n/// ```rust\n/// # use time::ext::NumericalStdDuration;\n/// # use core::time::Duration;\n/// assert_eq!(5.std_nanoseconds(), Duration::from_nanos(5));\n/// assert_eq!(5.std_microseconds(), Duration::from_micros(5));\n/// assert_eq!(5.std_milliseconds(), Duration::from_millis(5));\n/// assert_eq!(5.std_seconds(), Duration::from_secs(5));\n/// assert_eq!(5.std_minutes(), Duration::from_secs(5 * 60));\n/// assert_eq!(5.std_hours(), Duration::from_secs(5 * 3_600));\n/// assert_eq!(5.std_days(), Duration::from_secs(5 * 86_400));\n/// assert_eq!(5.std_weeks(), Duration::from_secs(5 * 604_800));\n/// ```\n///\n/// Just like any other [`std::time::Duration`], they can be added, subtracted, etc.\n///\n/// ```rust\n/// # use time::ext::NumericalStdDuration;\n/// assert_eq!(\n///     2.std_seconds() + 500.std_milliseconds(),\n///     2_500.std_milliseconds()\n/// );\n/// assert_eq!(\n///     2.std_seconds() - 500.std_milliseconds(),\n///     1_500.std_milliseconds()\n/// );\n/// ```\n///\n/// When called on floating point values, any remainder of the floating point value will be\n/// truncated. Keep in mind that floating point numbers are inherently imprecise and have limited\n/// capacity.\npub trait NumericalStdDuration: sealed::Sealed {\n    /// Create a [`std::time::Duration`] from the number of nanoseconds.\n    fn std_nanoseconds(self) -> StdDuration;\n    /// Create a [`std::time::Duration`] from the number of microseconds.\n    fn std_microseconds(self) -> StdDuration;\n    /// Create a [`std::time::Duration`] from the number of milliseconds.\n    fn std_milliseconds(self) -> StdDuration;\n    /// Create a [`std::time::Duration`] from the number of seconds.\n    fn std_seconds(self) -> StdDuration;\n    /// Create a [`std::time::Duration`] from the number of minutes.\n    fn std_minutes(self) -> StdDuration;\n    /// Create a [`std::time::Duration`] from the number of hours.\n    fn std_hours(self) -> StdDuration;\n    /// Create a [`std::time::Duration`] from the number of days.\n    fn std_days(self) -> StdDuration;\n    /// Create a [`std::time::Duration`] from the number of weeks.\n    fn std_weeks(self) -> StdDuration;\n}","Real(LocalPath(\"src/ext.rs\"))"],"ext::sealed::Sealed":["/// A trait that cannot be implemented by downstream users.\npub trait Sealed {}","Real(LocalPath(\"src/ext.rs\"))"],"instant::<impl std::cmp::PartialEq<instant::Instant> for std::time::Instant>::eq":["fn eq(&self, rhs: &Instant) -> bool{\n        self.eq(&rhs.0)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::cmp::PartialOrd<instant::Instant> for std::time::Instant>::partial_cmp":["fn partial_cmp(&self, rhs: &Instant) -> Option<Ordering>{\n        self.partial_cmp(&rhs.0)\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::convert::From<instant::Instant> for std::time::Instant>::from":["fn from(instant: Instant) -> Self{\n        instant.0\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::ops::Add<duration::Duration> for std::time::Instant>::add":["fn add(self, duration: Duration) -> Self::Output{\n        (Instant(self) + duration).0\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::ops::AddAssign<duration::Duration> for std::time::Instant>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"instant::<impl std::ops::Sub<duration::Duration> for std::time::Instant>::sub":["fn sub(self, duration: Duration) -> Self::Output{\n        (Instant(self) - duration).0\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::ops::Sub<instant::Instant> for std::time::Instant>::sub":["fn sub(self, other: Instant) -> Self::Output{\n        Instant(self) - other\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::<impl std::ops::SubAssign<duration::Duration> for std::time::Instant>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"instant::Instant":["/// A measurement of a monotonically non-decreasing clock. Opaque and useful only with [`Duration`].\n///\n/// Instants are always guaranteed to be no less than any previously measured instant when created,\n/// and are often useful for tasks such as measuring benchmarks or timing how long an operation\n/// takes.\n///\n/// Note, however, that instants are not guaranteed to be **steady**. In other words, each tick of\n/// the underlying clock may not be the same length (e.g. some seconds may be longer than others).\n/// An instant may jump forwards or experience time dilation (slow down or speed up), but it will\n/// never go backwards.\n///\n/// Instants are opaque types that can only be compared to one another. There is no method to get\n/// \"the number of seconds\" from an instant. Instead, it only allows measuring the duration between\n/// two instants (or comparing two instants).\n///\n/// This implementation allows for operations with signed [`Duration`]s, but is otherwise identical\n/// to [`std::time::Instant`].\n#[repr(transparent)]\npub struct Instant(pub StdInstant);","Real(LocalPath(\"src/instant.rs\"))"],"instant::Instant::checked_add":["/// Returns `Some(t)` where `t` is the time `self + duration` if `t` can be represented as\n/// `Instant` (which means it's inside the bounds of the underlying data structure), `None`\n/// otherwise.\n///\n/// ```rust\n/// # use time::{Instant, ext::NumericalDuration};\n/// let now = Instant::now();\n/// assert_eq!(now.checked_add(5.seconds()), Some(now + 5.seconds()));\n/// assert_eq!(now.checked_add((-5).seconds()), Some(now + (-5).seconds()));\n/// ```\npub fn checked_add(self, duration: Duration) -> Option<Self>{\n        if duration.is_zero() {\n            Some(self)\n        } else if duration.is_positive() {\n            self.0.checked_add(duration.abs_std()).map(Self)\n        } else {\n            debug_assert!(duration.is_negative());\n            self.0.checked_sub(duration.abs_std()).map(Self)\n        }\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::Instant::checked_sub":["/// Returns `Some(t)` where `t` is the time `self - duration` if `t` can be represented as\n/// `Instant` (which means it's inside the bounds of the underlying data structure), `None`\n/// otherwise.\n///\n/// ```rust\n/// # use time::{Instant, ext::NumericalDuration};\n/// let now = Instant::now();\n/// assert_eq!(now.checked_sub(5.seconds()), Some(now - 5.seconds()));\n/// assert_eq!(now.checked_sub((-5).seconds()), Some(now - (-5).seconds()));\n/// ```\npub fn checked_sub(self, duration: Duration) -> Option<Self>{\n        if duration.is_zero() {\n            Some(self)\n        } else if duration.is_positive() {\n            self.0.checked_sub(duration.abs_std()).map(Self)\n        } else {\n            debug_assert!(duration.is_negative());\n            self.0.checked_add(duration.abs_std()).map(Self)\n        }\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::Instant::elapsed":["/// Returns the amount of time elapsed since this instant was created. The duration will always\n/// be nonnegative if the instant is not synthetically created.\n///\n/// ```rust\n/// # use time::{Instant, ext::{NumericalStdDuration, NumericalDuration}};\n/// # use std::thread;\n/// let instant = Instant::now();\n/// thread::sleep(1.std_milliseconds());\n/// assert!(instant.elapsed() >= 1.milliseconds());\n/// ```\npub fn elapsed(self) -> Duration{\n        Self::now() - self\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::Instant::into_inner":["/// Obtain the inner [`std::time::Instant`].\n///\n/// ```rust\n/// # use time::Instant;\n/// let now = Instant::now();\n/// assert_eq!(now.into_inner(), now.0);\n/// ```\npub const fn into_inner(self) -> StdInstant{\n        self.0\n    }","Real(LocalPath(\"src/instant.rs\"))"],"instant::Instant::now":["/// Returns an `Instant` corresponding to \"now\".\n///\n/// ```rust\n/// # use time::Instant;\n/// println!(\"{:?}\", Instant::now());\n/// ```\npub fn now() -> Self{\n        Self(StdInstant::now())\n    }","Real(LocalPath(\"src/instant.rs\"))"],"month::<impl std::convert::From<month::Month> for u8>::from":["fn from(month: Month) -> Self{\n        month as _\n    }","Real(LocalPath(\"src/month.rs\"))"],"month::Month":["/// Months of the year.\n#[allow(clippy::missing_docs_in_private_items)]\n#[repr(u8)]\npub enum Month {\n    January = 1,\n    February = 2,\n    March = 3,\n    April = 4,\n    May = 5,\n    June = 6,\n    July = 7,\n    August = 8,\n    September = 9,\n    October = 10,\n    November = 11,\n    December = 12,\n}","Real(LocalPath(\"src/month.rs\"))"],"month::Month::from_number":["/// Create a `Month` from its numerical value.\npub(crate) const fn from_number(n: NonZeroU8) -> Result<Self, error::ComponentRange>{\n        match n.get() {\n            1 => Ok(January),\n            2 => Ok(February),\n            3 => Ok(March),\n            4 => Ok(April),\n            5 => Ok(May),\n            6 => Ok(June),\n            7 => Ok(July),\n            8 => Ok(August),\n            9 => Ok(September),\n            10 => Ok(October),\n            11 => Ok(November),\n            12 => Ok(December),\n            n => Err(error::ComponentRange {\n                name: \"month\",\n                minimum: 1,\n                maximum: 12,\n                value: n as _,\n                conditional_range: false,\n            }),\n        }\n    }","Real(LocalPath(\"src/month.rs\"))"],"month::Month::next":["/// Get the next month.\n///\n/// ```rust\n/// # use time::Month;\n/// assert_eq!(Month::January.next(), Month::February);\n/// ```\npub const fn next(self) -> Self{\n        match self {\n            January => February,\n            February => March,\n            March => April,\n            April => May,\n            May => June,\n            June => July,\n            July => August,\n            August => September,\n            September => October,\n            October => November,\n            November => December,\n            December => January,\n        }\n    }","Real(LocalPath(\"src/month.rs\"))"],"month::Month::previous":["/// Get the previous month.\n///\n/// ```rust\n/// # use time::Month;\n/// assert_eq!(Month::January.previous(), Month::December);\n/// ```\npub const fn previous(self) -> Self{\n        match self {\n            January => December,\n            February => January,\n            March => February,\n            April => March,\n            May => April,\n            June => May,\n            July => June,\n            August => July,\n            September => August,\n            October => September,\n            November => October,\n            December => November,\n        }\n    }","Real(LocalPath(\"src/month.rs\"))"],"offset_date_time::<impl std::cmp::PartialEq<offset_date_time::OffsetDateTime> for std::time::SystemTime>::eq":["fn eq(&self, rhs: &OffsetDateTime) -> bool{\n        &OffsetDateTime::from(*self) == rhs\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::cmp::PartialOrd<offset_date_time::OffsetDateTime> for std::time::SystemTime>::partial_cmp":["fn partial_cmp(&self, other: &OffsetDateTime) -> Option<Ordering>{\n        OffsetDateTime::from(*self).partial_cmp(other)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::convert::From<offset_date_time::OffsetDateTime> for std::time::SystemTime>::from":["fn from(datetime: OffsetDateTime) -> Self{\n        let duration = datetime - OffsetDateTime::UNIX_EPOCH;\n\n        if duration.is_zero() {\n            Self::UNIX_EPOCH\n        } else if duration.is_positive() {\n            Self::UNIX_EPOCH + duration.abs_std()\n        } else {\n            debug_assert!(duration.is_negative());\n            Self::UNIX_EPOCH - duration.abs_std()\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::ops::Add<duration::Duration> for std::time::SystemTime>::add":["fn add(self, duration: Duration) -> Self::Output{\n        if duration.is_zero() {\n            self\n        } else if duration.is_positive() {\n            self + duration.abs_std()\n        } else {\n            debug_assert!(duration.is_negative());\n            self - duration.abs_std()\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::ops::AddAssign<duration::Duration> for std::time::SystemTime>::add_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"offset_date_time::<impl std::ops::Sub<duration::Duration> for std::time::SystemTime>::sub":["fn sub(self, duration: Duration) -> Self::Output{\n        (OffsetDateTime::from(self) - duration).into()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::ops::Sub<offset_date_time::OffsetDateTime> for std::time::SystemTime>::sub":["fn sub(self, rhs: OffsetDateTime) -> Self::Output{\n        OffsetDateTime::from(self) - rhs\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::<impl std::ops::SubAssign<duration::Duration> for std::time::SystemTime>::sub_assign":["fn $fn(&mut self, rhs: $t){\n                *self = *self $sym rhs;\n            }","Real(LocalPath(\"src/lib.rs\"))"],"offset_date_time::OffsetDateTime":["/// A [`PrimitiveDateTime`] with a [`UtcOffset`].\n///\n/// All comparisons are performed using the UTC time.\npub struct OffsetDateTime {\n    /// The [`PrimitiveDateTime`], which is _always_ UTC.\n    pub(crate) utc_datetime: PrimitiveDateTime,\n    /// The [`UtcOffset`], which will be added to the [`PrimitiveDateTime`] as necessary.\n    pub(crate) offset: UtcOffset,\n}","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::checked_add":["/// Computes `self + duration`, returning `None` if an overflow occurred.\n///\n/// ```\n/// # use time::{Date, ext::NumericalDuration};\n/// # use time::macros::{datetime, offset};\n/// let datetime = Date::MIN.midnight().assume_offset(offset!(+10));\n/// assert_eq!(datetime.checked_add((-2).days()), None);\n///\n/// let datetime = Date::MAX.midnight().assume_offset(offset!(+10));\n/// assert_eq!(datetime.checked_add(2.days()), None);\n///\n/// assert_eq!(\n///     datetime!(2019 - 11 - 25 15:30 +10).checked_add(27.hours()),\n///     Some(datetime!(2019 - 11 - 26 18:30 +10))\n/// );\n/// ```\npub const fn checked_add(self, duration: Duration) -> Option<Self>{\n        let offset_datetime = self.utc_datetime.utc_to_offset(self.offset);\n        Some(const_try_opt!(offset_datetime.checked_add(duration)).assume_offset(self.offset))\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::checked_sub":["/// Computes `self - duration`, returning `None` if an overflow occurred.\n///\n/// ```\n/// # use time::{Date, ext::NumericalDuration};\n/// # use time::macros::{datetime, offset};\n/// let datetime = Date::MIN.midnight().assume_offset(offset!(+10));\n/// assert_eq!(datetime.checked_sub(2.days()), None);\n///\n/// let datetime = Date::MAX.midnight().assume_offset(offset!(+10));\n/// assert_eq!(datetime.checked_sub((-2).days()), None);\n///\n/// assert_eq!(\n///     datetime!(2019 - 11 - 25 15:30 +10).checked_sub(27.hours()),\n///     Some(datetime!(2019 - 11 - 24 12:30 +10))\n/// );\n/// ```\npub const fn checked_sub(self, duration: Duration) -> Option<Self>{\n        let offset_datetime = self.utc_datetime.utc_to_offset(self.offset);\n        Some(const_try_opt!(offset_datetime.checked_sub(duration)).assume_offset(self.offset))\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::date":["/// Get the [`Date`] in the stored offset.\n///\n/// ```rust\n/// # use time::macros::{date, datetime, offset};\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).date(), date!(2019-01-01));\n/// assert_eq!(\n///     datetime!(2019-01-01 0:00 UTC)\n///         .to_offset(offset!(-1))\n///         .date(),\n///     date!(2018-12-31),\n/// );\n/// ```\npub const fn date(self) -> Date{\n        let mut second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        let mut minute = self.utc_datetime.minute() as i8 + self.offset.minutes_past_hour();\n        let mut hour = self.utc_datetime.hour() as i8 + self.offset.whole_hours();\n        let (mut year, mut ordinal) = self.utc_datetime.date.to_ordinal_date();\n\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        cascade!(hour in 0..24 => ordinal);\n        cascade!(ordinal => year);\n\n        Date::__from_ordinal_date_unchecked(year, ordinal)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::day":["/// Get the day of the date in the stored offset.\n///\n/// The returned value will always be in the range `1..=31`.\n///\n/// ```rust\n/// # use time::macros::{datetime, offset};\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).day(), 1);\n/// assert_eq!(\n///     datetime!(2019-12-31 23:00 UTC)\n///         .to_offset(offset!(+1))\n///         .day(),\n///     1,\n/// );\n/// ```\npub const fn day(self) -> u8{\n        self.date().day()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::from_unix_timestamp":["/// Create an `OffsetDateTime` from the provided Unix timestamp. Calling `.offset()` on the\n/// resulting value is guaranteed to return UTC.\n///\n/// ```rust\n/// # use time::{OffsetDateTime, macros::datetime};\n/// assert_eq!(\n///     OffsetDateTime::from_unix_timestamp(0),\n///     Ok(OffsetDateTime::UNIX_EPOCH),\n/// );\n/// assert_eq!(\n///     OffsetDateTime::from_unix_timestamp(1_546_300_800),\n///     Ok(datetime!(2019-01-01 0:00 UTC)),\n/// );\n/// ```\n///\n/// If you have a timestamp-nanosecond pair, you can use something along the lines of the\n/// following:\n///\n/// ```rust\n/// # use time::{Duration, OffsetDateTime, ext::NumericalDuration};\n/// let (timestamp, nanos) = (1, 500_000_000);\n/// assert_eq!(\n///     OffsetDateTime::from_unix_timestamp(timestamp)? + Duration::nanoseconds(nanos),\n///     OffsetDateTime::UNIX_EPOCH + 1.5.seconds()\n/// );\n/// # Ok::<_, time::Error>(())\n/// ```\npub const fn from_unix_timestamp(timestamp: i64) -> Result<Self, error::ComponentRange>{\n        #[allow(clippy::missing_docs_in_private_items)]\n        const MIN_TIMESTAMP: i64 = Date::MIN.midnight().assume_utc().unix_timestamp();\n        #[allow(clippy::missing_docs_in_private_items)]\n        const MAX_TIMESTAMP: i64 = Date::MAX\n            .with_time(Time::__from_hms_nanos_unchecked(23, 59, 59, 999_999_999))\n            .assume_utc()\n            .unix_timestamp();\n\n        ensure_value_in_range!(timestamp in MIN_TIMESTAMP => MAX_TIMESTAMP);\n\n        // Use the unchecked method here, as the input validity has already been verified.\n        let date = Date::from_julian_day_unchecked(\n            UNIX_EPOCH_JULIAN_DAY + div_floor!(timestamp, 86_400) as i32,\n        );\n\n        let seconds_within_day = timestamp.rem_euclid(86_400);\n        let time = Time::__from_hms_nanos_unchecked(\n            (seconds_within_day / 3_600) as _,\n            ((seconds_within_day % 3_600) / 60) as _,\n            (seconds_within_day % 60) as _,\n            0,\n        );\n\n        Ok(PrimitiveDateTime::new(date, time).assume_utc())\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::from_unix_timestamp_nanos":["/// Construct an `OffsetDateTime` from the provided Unix timestamp (in nanoseconds). Calling\n/// `.offset()` on the resulting value is guaranteed to return UTC.\n///\n/// ```rust\n/// # use time::{OffsetDateTime, macros::datetime};\n/// assert_eq!(\n///     OffsetDateTime::from_unix_timestamp_nanos(0),\n///     Ok(OffsetDateTime::UNIX_EPOCH),\n/// );\n/// assert_eq!(\n///     OffsetDateTime::from_unix_timestamp_nanos(1_546_300_800_000_000_000),\n///     Ok(datetime!(2019-01-01 0:00 UTC)),\n/// );\n/// ```\npub const fn from_unix_timestamp_nanos(timestamp: i128) -> Result<Self, error::ComponentRange>{\n        let datetime = const_try!(Self::from_unix_timestamp(\n            div_floor!(timestamp, 1_000_000_000) as i64\n        ));\n\n        Ok(datetime\n            .utc_datetime\n            .replace_time(Time::__from_hms_nanos_unchecked(\n                datetime.utc_datetime.hour(),\n                datetime.utc_datetime.minute(),\n                datetime.utc_datetime.second(),\n                timestamp.rem_euclid(1_000_000_000) as u32,\n            ))\n            .assume_utc())\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::hour":["/// Get the clock hour in the stored offset.\n///\n/// The returned value will always be in the range `0..24`.\n///\n/// ```rust\n/// # use time::macros::{datetime, offset};\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).hour(), 0);\n/// assert_eq!(\n///     datetime!(2019-01-01 23:59:59 UTC)\n///         .to_offset(offset!(-2))\n///         .hour(),\n///     21,\n/// );\n/// ```\npub const fn hour(self) -> u8{\n        let mut second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        let mut minute = self.utc_datetime.minute() as i8 + self.offset.minutes_past_hour();\n        let mut hour = self.utc_datetime.hour() as i8 + self.offset.whole_hours();\n\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        hour.rem_euclid(24) as _\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::iso_week":["/// Get the ISO week number of the date in the stored offset.\n///\n/// The returned value will always be in the range `1..=53`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).iso_week(), 1);\n/// assert_eq!(datetime!(2020-01-01 0:00 UTC).iso_week(), 1);\n/// assert_eq!(datetime!(2020-12-31 0:00 UTC).iso_week(), 53);\n/// assert_eq!(datetime!(2021-01-01 0:00 UTC).iso_week(), 53);\n/// ```\npub const fn iso_week(self) -> u8{\n        self.date().iso_week()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::microsecond":["/// Get the microseconds within the second in the stored offset.\n///\n/// The returned value will always be in the range `0..1_000_000`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).microsecond(), 0);\n/// assert_eq!(\n///     datetime!(2019-01-01 23:59:59.999_999 UTC).microsecond(),\n///     999_999,\n/// );\n/// ```\npub const fn microsecond(self) -> u32{\n        self.utc_datetime.microsecond()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::millisecond":["/// Get the milliseconds within the second in the stored offset.\n///\n/// The returned value will always be in the range `0..1_000`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).millisecond(), 0);\n/// assert_eq!(datetime!(2019-01-01 23:59:59.999 UTC).millisecond(), 999);\n/// ```\npub const fn millisecond(self) -> u16{\n        self.utc_datetime.millisecond()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::minute":["/// Get the minute within the hour in the stored offset.\n///\n/// The returned value will always be in the range `0..60`.\n///\n/// ```rust\n/// # use time::macros::{datetime, offset};\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).minute(), 0);\n/// assert_eq!(\n///     datetime!(2019-01-01 23:59:59 UTC)\n///         .to_offset(offset!(+0:30))\n///         .minute(),\n///     29,\n/// );\n/// ```\npub const fn minute(self) -> u8{\n        let mut second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        let mut minute = self.utc_datetime.minute() as i8 + self.offset.minutes_past_hour();\n\n        cascade!(second in 0..60 => minute);\n        minute.rem_euclid(60) as _\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::monday_based_week":["/// Get the week number where week 1 begins on the first Monday.\n///\n/// The returned value will always be in the range `0..=53`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).monday_based_week(), 0);\n/// assert_eq!(datetime!(2020-01-01 0:00 UTC).monday_based_week(), 0);\n/// assert_eq!(datetime!(2020-12-31 0:00 UTC).monday_based_week(), 52);\n/// assert_eq!(datetime!(2021-01-01 0:00 UTC).monday_based_week(), 0);\n/// ```\npub const fn monday_based_week(self) -> u8{\n        self.date().monday_based_week()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::month":["/// Get the month of the date in the stored offset.\n///\n/// ```rust\n/// # use time::Month;\n/// # use time::macros::{datetime, offset};\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).month(), Month::January);\n/// assert_eq!(\n///     datetime!(2019-12-31 23:00 UTC)\n///         .to_offset(offset!(+1))\n///         .month(),\n///     Month::January,\n/// );\n/// ```\npub const fn month(self) -> Month{\n        self.date().month()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::nanosecond":["/// Get the nanoseconds within the second in the stored offset.\n///\n/// The returned value will always be in the range `0..1_000_000_000`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).nanosecond(), 0);\n/// assert_eq!(\n///     datetime!(2019-01-01 23:59:59.999_999_999 UTC).nanosecond(),\n///     999_999_999,\n/// );\n/// ```\npub const fn nanosecond(self) -> u32{\n        self.utc_datetime.nanosecond()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::now_utc":["/// Create a new `OffsetDateTime` with the current date and time in UTC.\n///\n/// ```rust\n/// # use time::{OffsetDateTime, macros::offset};\n/// assert!(OffsetDateTime::now_utc().year() >= 2019);\n/// assert_eq!(OffsetDateTime::now_utc().offset(), offset!(UTC));\n/// ```\n#[cfg(feature = \"std\")]\npub fn now_utc() -> Self{\n        SystemTime::now().into()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::offset":["/// Get the [`UtcOffset`].\n///\n/// ```rust\n/// # use time::macros::{datetime, offset};\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).offset(), offset!(UTC));\n/// assert_eq!(datetime!(2019-01-01 0:00 +1).offset(), offset!(+1));\n/// ```\npub const fn offset(self) -> UtcOffset{\n        self.offset\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::ordinal":["/// Get the day of the year of the date in the stored offset.\n///\n/// The returned value will always be in the range `1..=366`.\n///\n/// ```rust\n/// # use time::macros::{datetime, offset};\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).ordinal(), 1);\n/// assert_eq!(\n///     datetime!(2019-12-31 23:00 UTC)\n///         .to_offset(offset!(+1))\n///         .ordinal(),\n///     1,\n/// );\n/// ```\npub const fn ordinal(self) -> u16{\n        let mut second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        let mut minute = self.utc_datetime.minute() as i8 + self.offset.minutes_past_hour();\n        let mut hour = self.utc_datetime.hour() as i8 + self.offset.whole_hours();\n        let (mut year, mut ordinal) = self.utc_datetime.date.to_ordinal_date();\n\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        cascade!(hour in 0..24 => ordinal);\n        cascade!(ordinal => year);\n\n        ordinal\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::replace_date":["/// Replace the date, which is assumed to be in the stored offset. The time and offset\n/// components are unchanged.\n///\n/// ```rust\n/// # use time::macros::{datetime, date};\n/// assert_eq!(\n///     datetime!(2020-01-01 12:00 UTC).replace_date(date!(2020-01-30)),\n///     datetime!(2020-01-30 12:00 UTC)\n/// );\n/// assert_eq!(\n///     datetime!(2020-01-01 0:00 +1).replace_date(date!(2020-01-30)),\n///     datetime!(2020-01-30 0:00 +1)\n/// );\n/// ```\n#[must_use = \"This method does not mutate the original `OffsetDateTime`.\"]\npub const fn replace_date(self, date: Date) -> Self{\n        self.utc_datetime\n            .utc_to_offset(self.offset)\n            .replace_date(date)\n            .assume_offset(self.offset)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::replace_date_time":["/// Replace the date and time, which are assumed to be in the stored offset. The offset\n/// component remains unchanged.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(\n///     datetime!(2020-01-01 12:00 UTC).replace_date_time(datetime!(2020-01-30 16:00)),\n///     datetime!(2020-01-30 16:00 UTC)\n/// );\n/// assert_eq!(\n///     datetime!(2020-01-01 12:00 +1).replace_date_time(datetime!(2020-01-30 0:00)),\n///     datetime!(2020-01-30 0:00 +1)\n/// );\n/// ```\n#[must_use = \"This method does not mutate the original `OffsetDateTime`.\"]\npub const fn replace_date_time(self, date_time: PrimitiveDateTime) -> Self{\n        date_time.assume_offset(self.offset)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::replace_offset":["/// Replace the offset. The date and time components remain unchanged.\n///\n/// ```rust\n/// # use time::macros::{datetime, offset};\n/// assert_eq!(\n///     datetime!(2020-01-01 0:00 UTC).replace_offset(offset!(-5)),\n///     datetime!(2020-01-01 0:00 -5)\n/// );\n/// ```\n#[must_use = \"This method does not mutate the original `OffsetDateTime`.\"]\npub const fn replace_offset(self, offset: UtcOffset) -> Self{\n        self.utc_datetime.assume_offset(offset)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::replace_time":["/// Replace the time, which is assumed to be in the stored offset. The date and offset\n/// components are unchanged.\n///\n/// ```rust\n/// # use time::macros::{datetime, time};\n/// assert_eq!(\n///     datetime!(2020-01-01 5:00 UTC).replace_time(time!(12:00)),\n///     datetime!(2020-01-01 12:00 UTC)\n/// );\n/// assert_eq!(\n///     datetime!(2020-01-01 12:00 -5).replace_time(time!(7:00)),\n///     datetime!(2020-01-01 7:00 -5)\n/// );\n/// assert_eq!(\n///     datetime!(2020-01-01 0:00 +1).replace_time(time!(12:00)),\n///     datetime!(2020-01-01 12:00 +1)\n/// );\n/// ```\n#[must_use = \"This method does not mutate the original `OffsetDateTime`.\"]\npub const fn replace_time(self, time: Time) -> Self{\n        self.utc_datetime\n            .utc_to_offset(self.offset)\n            .replace_time(time)\n            .assume_offset(self.offset)\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::saturating_add":["/// Computes `self + duration`, saturating value on overflow.\n///\n/// ```\n/// # use time::ext::NumericalDuration;\n/// # use time::macros::datetime;\n/// assert_eq!(\n///     datetime!(-999999 - 01 - 01 0:00 +10).saturating_add((-2).days()),\n///     datetime!(-999999 - 01 - 01 0:00 +10)\n/// );\n///\n/// assert_eq!(\n///     datetime!(+999999 - 12 - 31 23:59:59.999_999_999 +10).saturating_add(2.days()),\n///     datetime!(+999999 - 12 - 31 23:59:59.999_999_999 +10)\n/// );\n///\n/// assert_eq!(\n///     datetime!(2019 - 11 - 25 15:30 +10).saturating_add(27.hours()),\n///     datetime!(2019 - 11 - 26 18:30 +10)\n/// );\n/// ```\npub const fn saturating_add(self, duration: Duration) -> Self{\n        if let Some(datetime) = self.checked_add(duration) {\n            datetime\n        } else if duration.is_negative() {\n            PrimitiveDateTime::MIN\n                .assume_utc()\n                .replace_offset(self.offset)\n        } else {\n            PrimitiveDateTime::MAX\n                .assume_utc()\n                .replace_offset(self.offset)\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::saturating_sub":["/// Computes `self - duration`, saturating value on overflow.\n///\n/// ```\n/// # use time::ext::NumericalDuration;\n/// # use time::macros::datetime;\n/// assert_eq!(\n///     datetime!(-999999 - 01 - 01 0:00 +10).saturating_sub(2.days()),\n///     datetime!(-999999 - 01 - 01 0:00 +10)\n/// );\n///\n/// assert_eq!(\n///     datetime!(+999999 - 12 - 31 23:59:59.999_999_999 +10).saturating_sub((-2).days()),\n///     datetime!(+999999 - 12 - 31 23:59:59.999_999_999 +10)\n/// );\n///\n/// assert_eq!(\n///     datetime!(2019 - 11 - 25 15:30 +10).saturating_sub(27.hours()),\n///     datetime!(2019 - 11 - 24 12:30 +10)\n/// );\n/// ```\npub const fn saturating_sub(self, duration: Duration) -> Self{\n        if let Some(datetime) = self.checked_sub(duration) {\n            datetime\n        } else if duration.is_negative() {\n            PrimitiveDateTime::MAX\n                .assume_utc()\n                .replace_offset(self.offset)\n        } else {\n            PrimitiveDateTime::MIN\n                .assume_utc()\n                .replace_offset(self.offset)\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::second":["/// Get the second within the minute in the stored offset.\n///\n/// The returned value will always be in the range `0..60`.\n///\n/// ```rust\n/// # use time::macros::{datetime, offset};\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).second(), 0);\n/// assert_eq!(\n///     datetime!(2019-01-01 23:59:59 UTC)\n///         .to_offset(offset!(+0:00:30))\n///         .second(),\n///     29,\n/// );\n/// ```\npub const fn second(self) -> u8{\n        let second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        second.rem_euclid(60) as _\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::sunday_based_week":["/// Get the week number where week 1 begins on the first Sunday.\n///\n/// The returned value will always be in the range `0..=53`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).sunday_based_week(), 0);\n/// assert_eq!(datetime!(2020-01-01 0:00 UTC).sunday_based_week(), 0);\n/// assert_eq!(datetime!(2020-12-31 0:00 UTC).sunday_based_week(), 52);\n/// assert_eq!(datetime!(2021-01-01 0:00 UTC).sunday_based_week(), 0);\n/// ```\npub const fn sunday_based_week(self) -> u8{\n        self.date().sunday_based_week()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::time":["/// Get the [`Time`] in the stored offset.\n///\n/// ```rust\n/// # use time::macros::{datetime, offset, time};\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).time(), time!(0:00));\n/// assert_eq!(\n///     datetime!(2019-01-01 0:00 UTC)\n///         .to_offset(offset!(-1))\n///         .time(),\n///     time!(23:00)\n/// );\n/// ```\npub const fn time(self) -> Time{\n        let mut second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        let mut minute = self.utc_datetime.minute() as i8 + self.offset.minutes_past_hour();\n        let mut hour = self.utc_datetime.hour() as i8 + self.offset.whole_hours();\n\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n\n        Time::__from_hms_nanos_unchecked(\n            hour.rem_euclid(24) as _,\n            minute as _,\n            second as _,\n            self.utc_datetime.nanosecond(),\n        )\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::to_calendar_date":["/// Get the year, month, and day.\n///\n/// ```rust\n/// # use time::{macros::datetime, Month};\n/// assert_eq!(\n///     datetime!(2019-01-01 0:00 UTC).to_calendar_date(),\n///     (2019, Month::January, 1)\n/// );\n/// ```\npub const fn to_calendar_date(self) -> (i32, Month, u8){\n        self.date().to_calendar_date()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::to_hms":["/// Get the clock hour, minute, and second.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2020-01-01 0:00:00 UTC).to_hms(), (0, 0, 0));\n/// assert_eq!(datetime!(2020-01-01 23:59:59 UTC).to_hms(), (23, 59, 59));\n/// ```\npub const fn to_hms(self) -> (u8, u8, u8){\n        self.time().as_hms()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::to_hms_micro":["/// Get the clock hour, minute, second, and microsecond.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(\n///     datetime!(2020-01-01 0:00:00 UTC).to_hms_micro(),\n///     (0, 0, 0, 0)\n/// );\n/// assert_eq!(\n///     datetime!(2020-01-01 23:59:59.999_999 UTC).to_hms_micro(),\n///     (23, 59, 59, 999_999)\n/// );\n/// ```\npub const fn to_hms_micro(self) -> (u8, u8, u8, u32){\n        self.time().as_hms_micro()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::to_hms_milli":["/// Get the clock hour, minute, second, and millisecond.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(\n///     datetime!(2020-01-01 0:00:00 UTC).to_hms_milli(),\n///     (0, 0, 0, 0)\n/// );\n/// assert_eq!(\n///     datetime!(2020-01-01 23:59:59.999 UTC).to_hms_milli(),\n///     (23, 59, 59, 999)\n/// );\n/// ```\npub const fn to_hms_milli(self) -> (u8, u8, u8, u16){\n        self.time().as_hms_milli()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::to_hms_nano":["/// Get the clock hour, minute, second, and nanosecond.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(\n///     datetime!(2020-01-01 0:00:00 UTC).to_hms_nano(),\n///     (0, 0, 0, 0)\n/// );\n/// assert_eq!(\n///     datetime!(2020-01-01 23:59:59.999_999_999 UTC).to_hms_nano(),\n///     (23, 59, 59, 999_999_999)\n/// );\n/// ```\npub const fn to_hms_nano(self) -> (u8, u8, u8, u32){\n        self.time().as_hms_nano()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::to_iso_week_date":["/// Get the ISO 8601 year, week number, and weekday.\n///\n/// ```rust\n/// # use time::{Weekday::*, macros::datetime};\n/// assert_eq!(\n///     datetime!(2019-01-01 0:00 UTC).to_iso_week_date(),\n///     (2019, 1, Tuesday)\n/// );\n/// assert_eq!(\n///     datetime!(2019-10-04 0:00 UTC).to_iso_week_date(),\n///     (2019, 40, Friday)\n/// );\n/// assert_eq!(\n///     datetime!(2020-01-01 0:00 UTC).to_iso_week_date(),\n///     (2020, 1, Wednesday)\n/// );\n/// assert_eq!(\n///     datetime!(2020-12-31 0:00 UTC).to_iso_week_date(),\n///     (2020, 53, Thursday)\n/// );\n/// assert_eq!(\n///     datetime!(2021-01-01 0:00 UTC).to_iso_week_date(),\n///     (2020, 53, Friday)\n/// );\n/// ```\npub const fn to_iso_week_date(self) -> (i32, u8, Weekday){\n        self.date().to_iso_week_date()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::to_julian_day":["/// Get the Julian day for the date. The time is not taken into account for this calculation.\n///\n/// The algorithm to perform this conversion is derived from one provided by Peter Baum; it is\n/// freely available [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(-4713-11-24 0:00 UTC).to_julian_day(), 0);\n/// assert_eq!(datetime!(2000-01-01 0:00 UTC).to_julian_day(), 2_451_545);\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).to_julian_day(), 2_458_485);\n/// assert_eq!(datetime!(2019-12-31 0:00 UTC).to_julian_day(), 2_458_849);\n/// ```\npub const fn to_julian_day(self) -> i32{\n        self.date().to_julian_day()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::to_offset":["/// Convert the `OffsetDateTime` from the current [`UtcOffset`] to the provided [`UtcOffset`].\n///\n/// ```rust\n/// # use time::macros::{datetime, offset};\n/// assert_eq!(\n///     datetime!(2000-01-01 0:00 UTC)\n///         .to_offset(offset!(-1))\n///         .year(),\n///     1999,\n/// );\n///\n/// // Let's see what time Sydney's new year's celebration is in New York // and Los Angeles.\n///\n/// // Construct midnight on new year's in Sydney.\n/// let sydney = datetime!(2000-01-01 0:00 +11);\n/// let new_york = sydney.to_offset(offset!(-5));\n/// let los_angeles = sydney.to_offset(offset!(-8));\n/// assert_eq!(sydney.hour(), 0);\n/// assert_eq!(new_york.hour(), 8);\n/// assert_eq!(los_angeles.hour(), 5);\n/// ```\npub const fn to_offset(self, offset: UtcOffset) -> Self{\n        Self {\n            utc_datetime: self.utc_datetime,\n            offset,\n        }\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::to_ordinal_date":["/// Get the year and ordinal day number.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(\n///     datetime!(2019-01-01 0:00 UTC).to_ordinal_date(),\n///     (2019, 1)\n/// );\n/// ```\npub const fn to_ordinal_date(self) -> (i32, u16){\n        self.date().to_ordinal_date()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::unix_timestamp":["/// Get the [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(1970-01-01 0:00 UTC).unix_timestamp(), 0);\n/// assert_eq!(datetime!(1970-01-01 0:00 -1).unix_timestamp(), 3_600);\n/// ```\npub const fn unix_timestamp(self) -> i64{\n        let days =\n            (self.utc_datetime.to_julian_day() as i64 - UNIX_EPOCH_JULIAN_DAY as i64) * 86_400;\n        let hours = self.utc_datetime.hour() as i64 * 3_600;\n        let minutes = self.utc_datetime.minute() as i64 * 60;\n        let seconds = self.utc_datetime.second() as i64;\n        days + hours + minutes + seconds\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::unix_timestamp_nanos":["/// Get the Unix timestamp in nanoseconds.\n///\n/// ```rust\n/// use time::macros::datetime;\n/// assert_eq!(datetime!(1970-01-01 0:00 UTC).unix_timestamp_nanos(), 0);\n/// assert_eq!(\n///     datetime!(1970-01-01 0:00 -1).unix_timestamp_nanos(),\n///     3_600_000_000_000,\n/// );\n/// ```\npub const fn unix_timestamp_nanos(self) -> i128{\n        self.unix_timestamp() as i128 * 1_000_000_000 + self.utc_datetime.nanosecond() as i128\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::weekday":["/// Get the weekday of the date in the stored offset.\n///\n/// ```rust\n/// # use time::{Weekday::*, macros::datetime};\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).weekday(), Tuesday);\n/// assert_eq!(datetime!(2019-02-01 0:00 UTC).weekday(), Friday);\n/// assert_eq!(datetime!(2019-03-01 0:00 UTC).weekday(), Friday);\n/// ```\npub const fn weekday(self) -> Weekday{\n        self.date().weekday()\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"offset_date_time::OffsetDateTime::year":["/// Get the year of the date in the stored offset.\n///\n/// ```rust\n/// # use time::macros::{datetime, offset};\n/// assert_eq!(datetime!(2019-01-01 0:00 UTC).year(), 2019);\n/// assert_eq!(\n///     datetime!(2019-12-31 23:00 UTC)\n///         .to_offset(offset!(+1))\n///         .year(),\n///     2020,\n/// );\n/// assert_eq!(datetime!(2020-01-01 0:00 UTC).year(), 2020);\n/// ```\npub const fn year(self) -> i32{\n        let mut second = self.utc_datetime.second() as i8 + self.offset.seconds_past_minute();\n        let mut minute = self.utc_datetime.minute() as i8 + self.offset.minutes_past_hour();\n        let mut hour = self.utc_datetime.hour() as i8 + self.offset.whole_hours();\n        let (mut year, mut ordinal) = self.utc_datetime.date.to_ordinal_date();\n\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        cascade!(hour in 0..24 => ordinal);\n        cascade!(ordinal => year);\n\n        year\n    }","Real(LocalPath(\"src/offset_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime":["/// Combined date and time.\npub struct PrimitiveDateTime {\n    #[allow(clippy::missing_docs_in_private_items)]\n    pub(crate) date: Date,\n    #[allow(clippy::missing_docs_in_private_items)]\n    pub(crate) time: Time,\n}","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::as_hms":["/// Get the clock hour, minute, and second.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2020-01-01 0:00:00).as_hms(), (0, 0, 0));\n/// assert_eq!(datetime!(2020-01-01 23:59:59).as_hms(), (23, 59, 59));\n/// ```\npub const fn as_hms(self) -> (u8, u8, u8){\n        self.time.as_hms()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::as_hms_micro":["/// Get the clock hour, minute, second, and microsecond.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2020-01-01 0:00:00).as_hms_micro(), (0, 0, 0, 0));\n/// assert_eq!(\n///     datetime!(2020-01-01 23:59:59.999_999).as_hms_micro(),\n///     (23, 59, 59, 999_999)\n/// );\n/// ```\npub const fn as_hms_micro(self) -> (u8, u8, u8, u32){\n        self.time.as_hms_micro()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::as_hms_milli":["/// Get the clock hour, minute, second, and millisecond.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2020-01-01 0:00:00).as_hms_milli(), (0, 0, 0, 0));\n/// assert_eq!(\n///     datetime!(2020-01-01 23:59:59.999).as_hms_milli(),\n///     (23, 59, 59, 999)\n/// );\n/// ```\npub const fn as_hms_milli(self) -> (u8, u8, u8, u16){\n        self.time.as_hms_milli()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::as_hms_nano":["/// Get the clock hour, minute, second, and nanosecond.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2020-01-01 0:00:00).as_hms_nano(), (0, 0, 0, 0));\n/// assert_eq!(\n///     datetime!(2020-01-01 23:59:59.999_999_999).as_hms_nano(),\n///     (23, 59, 59, 999_999_999)\n/// );\n/// ```\npub const fn as_hms_nano(self) -> (u8, u8, u8, u32){\n        self.time.as_hms_nano()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::assume_offset":["/// Assuming that the existing `PrimitiveDateTime` represents a moment in the provided\n/// [`UtcOffset`], return an [`OffsetDateTime`].\n///\n/// ```rust\n/// # use time::macros::{datetime, offset};\n/// assert_eq!(\n///     datetime!(2019-01-01 0:00)\n///         .assume_offset(offset!(UTC))\n///         .unix_timestamp(),\n///     1_546_300_800,\n/// );\n/// assert_eq!(\n///     datetime!(2019-01-01 0:00)\n///         .assume_offset(offset!(-1))\n///         .unix_timestamp(),\n///     1_546_304_400,\n/// );\n/// ```\npub const fn assume_offset(self, offset: UtcOffset) -> OffsetDateTime{\n        OffsetDateTime {\n            utc_datetime: self.offset_to_utc(offset),\n            offset,\n        }\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::assume_utc":["/// Assuming that the existing `PrimitiveDateTime` represents a moment in UTC, return an\n/// [`OffsetDateTime`].\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(\n///     datetime!(2019-01-01 0:00).assume_utc().unix_timestamp(),\n///     1_546_300_800,\n/// );\n/// ```\npub const fn assume_utc(self) -> OffsetDateTime{\n        OffsetDateTime {\n            utc_datetime: self,\n            offset: UtcOffset::UTC,\n        }\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::checked_add":["/// Computes `self + duration`, returning `None` if an overflow occurred.\n///\n/// ```\n/// # use time::{Date, ext::NumericalDuration};\n/// # use time::macros::datetime;\n/// let datetime = Date::MIN.midnight();\n/// assert_eq!(datetime.checked_add((-2).days()), None);\n///\n/// let datetime = Date::MAX.midnight();\n/// assert_eq!(datetime.checked_add(1.days()), None);\n///\n/// assert_eq!(\n///     datetime!(2019 - 11 - 25 15:30).checked_add(27.hours()),\n///     Some(datetime!(2019 - 11 - 26 18:30))\n/// );\n/// ```\npub const fn checked_add(self, duration: Duration) -> Option<Self>{\n        let (date_adjustment, time) = self.time.adjusting_add(duration);\n        let date = const_try_opt!(self.date.checked_add(duration));\n\n        Some(Self {\n            date: match date_adjustment {\n                util::DateAdjustment::Previous => const_try_opt!(date.previous_day()),\n                util::DateAdjustment::Next => const_try_opt!(date.next_day()),\n                util::DateAdjustment::None => date,\n            },\n            time,\n        })\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::checked_sub":["/// Computes `self - duration`, returning `None` if an overflow occurred.\n///\n/// ```\n/// # use time::{Date, ext::NumericalDuration};\n/// # use time::macros::datetime;\n/// let datetime = Date::MIN.midnight();\n/// assert_eq!(datetime.checked_sub(2.days()), None);\n///\n/// let datetime = Date::MAX.midnight();\n/// assert_eq!(datetime.checked_sub((-1).days()), None);\n///\n/// assert_eq!(\n///     datetime!(2019 - 11 - 25 15:30).checked_sub(27.hours()),\n///     Some(datetime!(2019 - 11 - 24 12:30))\n/// );\n/// ```\npub const fn checked_sub(self, duration: Duration) -> Option<Self>{\n        let (date_adjustment, time) = self.time.adjusting_sub(duration);\n        let date = const_try_opt!(self.date.checked_sub(duration));\n\n        Some(Self {\n            date: match date_adjustment {\n                util::DateAdjustment::Previous => const_try_opt!(date.previous_day()),\n                util::DateAdjustment::Next => const_try_opt!(date.next_day()),\n                util::DateAdjustment::None => date,\n            },\n            time,\n        })\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::date":["/// Get the [`Date`] component of the `PrimitiveDateTime`.\n///\n/// ```rust\n/// # use time::macros::{date, datetime};\n/// assert_eq!(datetime!(2019-01-01 0:00).date(), date!(2019-01-01));\n/// ```\npub const fn date(self) -> Date{\n        self.date\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::day":["/// Get the day of the date.\n///\n/// The returned value will always be in the range `1..=31`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).day(), 1);\n/// assert_eq!(datetime!(2019-12-31 0:00).day(), 31);\n/// ```\npub const fn day(self) -> u8{\n        self.date.day()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::hour":["/// Get the clock hour.\n///\n/// The returned value will always be in the range `0..24`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).hour(), 0);\n/// assert_eq!(datetime!(2019-01-01 23:59:59).hour(), 23);\n/// ```\npub const fn hour(self) -> u8{\n        self.time.hour()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::iso_week":["/// Get the ISO week number.\n///\n/// The returned value will always be in the range `1..=53`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).iso_week(), 1);\n/// assert_eq!(datetime!(2019-10-04 0:00).iso_week(), 40);\n/// assert_eq!(datetime!(2020-01-01 0:00).iso_week(), 1);\n/// assert_eq!(datetime!(2020-12-31 0:00).iso_week(), 53);\n/// assert_eq!(datetime!(2021-01-01 0:00).iso_week(), 53);\n/// ```\npub const fn iso_week(self) -> u8{\n        self.date.iso_week()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::microsecond":["/// Get the microseconds within the second.\n///\n/// The returned value will always be in the range `0..1_000_000`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).microsecond(), 0);\n/// assert_eq!(\n///     datetime!(2019-01-01 23:59:59.999_999).microsecond(),\n///     999_999\n/// );\n/// ```\npub const fn microsecond(self) -> u32{\n        self.time.microsecond()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::millisecond":["/// Get the milliseconds within the second.\n///\n/// The returned value will always be in the range `0..1_000`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).millisecond(), 0);\n/// assert_eq!(datetime!(2019-01-01 23:59:59.999).millisecond(), 999);\n/// ```\npub const fn millisecond(self) -> u16{\n        self.time.millisecond()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::minute":["/// Get the minute within the hour.\n///\n/// The returned value will always be in the range `0..60`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).minute(), 0);\n/// assert_eq!(datetime!(2019-01-01 23:59:59).minute(), 59);\n/// ```\npub const fn minute(self) -> u8{\n        self.time.minute()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::monday_based_week":["/// Get the week number where week 1 begins on the first Monday.\n///\n/// The returned value will always be in the range `0..=53`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).monday_based_week(), 0);\n/// assert_eq!(datetime!(2020-01-01 0:00).monday_based_week(), 0);\n/// assert_eq!(datetime!(2020-12-31 0:00).monday_based_week(), 52);\n/// assert_eq!(datetime!(2021-01-01 0:00).monday_based_week(), 0);\n/// ```\npub const fn monday_based_week(self) -> u8{\n        self.date.monday_based_week()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::month":["/// Get the month of the date.\n///\n/// ```rust\n/// # use time::{macros::datetime, Month};\n/// assert_eq!(datetime!(2019-01-01 0:00).month(), Month::January);\n/// assert_eq!(datetime!(2019-12-31 0:00).month(), Month::December);\n/// ```\npub const fn month(self) -> Month{\n        self.date.month()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::nanosecond":["/// Get the nanoseconds within the second.\n///\n/// The returned value will always be in the range `0..1_000_000_000`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).nanosecond(), 0);\n/// assert_eq!(\n///     datetime!(2019-01-01 23:59:59.999_999_999).nanosecond(),\n///     999_999_999,\n/// );\n/// ```\npub const fn nanosecond(self) -> u32{\n        self.time.nanosecond()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::new":["/// Create a new `PrimitiveDateTime` from the provided [`Date`] and [`Time`].\n///\n/// ```rust\n/// # use time::{PrimitiveDateTime, macros::{date, datetime, time}};\n/// assert_eq!(\n///     PrimitiveDateTime::new(date!(2019-01-01), time!(0:00)),\n///     datetime!(2019-01-01 0:00),\n/// );\n/// ```\npub const fn new(date: Date, time: Time) -> Self{\n        Self { date, time }\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::offset_to_utc":["/// Assuming that the current [`PrimitiveDateTime`] is a value in the provided [`UtcOffset`],\n/// obtain the equivalent value in the UTC.\npub(crate) const fn offset_to_utc(self, offset: UtcOffset) -> Self{\n        let mut second = self.second() as i8 - offset.seconds_past_minute();\n        let mut minute = self.minute() as i8 - offset.minutes_past_hour();\n        let mut hour = self.hour() as i8 - offset.whole_hours();\n        let (mut year, mut ordinal) = self.date.to_ordinal_date();\n\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        cascade!(hour in 0..24 => ordinal);\n        cascade!(ordinal => year);\n\n        Self {\n            date: Date::__from_ordinal_date_unchecked(year, ordinal),\n            time: Time::__from_hms_nanos_unchecked(\n                hour as _,\n                minute as _,\n                second as _,\n                self.nanosecond(),\n            ),\n        }\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::ordinal":["/// Get the day of the year.\n///\n/// The returned value will always be in the range `1..=366` (`1..=365` for common years).\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).ordinal(), 1);\n/// assert_eq!(datetime!(2019-12-31 0:00).ordinal(), 365);\n/// ```\npub const fn ordinal(self) -> u16{\n        self.date.ordinal()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::replace_date":["/// Replace the date, preserving the time.\n///\n/// ```rust\n/// # use time::macros::{datetime, date};\n/// assert_eq!(\n///     datetime!(2020-01-01 12:00).replace_date(date!(2020-01-30)),\n///     datetime!(2020-01-30 12:00)\n/// );\n/// ```\n#[must_use = \"This method does not mutate the original `PrimitiveDateTime`.\"]\npub const fn replace_date(self, date: Date) -> Self{\n        date.with_time(self.time)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::replace_time":["/// Replace the time, preserving the date.\n///\n/// ```rust\n/// # use time::macros::{datetime, time};\n/// assert_eq!(\n///     datetime!(2020-01-01 17:00).replace_time(time!(5:00)),\n///     datetime!(2020-01-01 5:00)\n/// );\n/// ```\n#[must_use = \"This method does not mutate the original `PrimitiveDateTime`.\"]\npub const fn replace_time(self, time: Time) -> Self{\n        self.date.with_time(time)\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::saturating_add":["/// Computes `self + duration`, saturating value on overflow.\n///\n/// ```\n/// # use time::{PrimitiveDateTime, ext::NumericalDuration};\n/// # use time::macros::datetime;\n/// assert_eq!(\n///     PrimitiveDateTime::MIN.saturating_add((-2).days()),\n///     PrimitiveDateTime::MIN\n/// );\n///\n/// assert_eq!(\n///     PrimitiveDateTime::MAX.saturating_add(2.days()),\n///     PrimitiveDateTime::MAX\n/// );\n///\n/// assert_eq!(\n///     datetime!(2019 - 11 - 25 15:30).saturating_add(27.hours()),\n///     datetime!(2019 - 11 - 26 18:30)\n/// );\n/// ```\npub const fn saturating_add(self, duration: Duration) -> Self{\n        if let Some(datetime) = self.checked_add(duration) {\n            datetime\n        } else if duration.is_negative() {\n            Self::MIN\n        } else {\n            Self::MAX\n        }\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::saturating_sub":["/// Computes `self - duration`, saturating value on overflow.\n///\n/// ```\n/// # use time::{PrimitiveDateTime, ext::NumericalDuration};\n/// # use time::macros::datetime;\n/// assert_eq!(\n///     PrimitiveDateTime::MIN.saturating_sub(2.days()),\n///     PrimitiveDateTime::MIN\n/// );\n///\n/// assert_eq!(\n///     PrimitiveDateTime::MAX.saturating_sub((-2).days()),\n///     PrimitiveDateTime::MAX\n/// );\n///\n/// assert_eq!(\n///     datetime!(2019 - 11 - 25 15:30).saturating_sub(27.hours()),\n///     datetime!(2019 - 11 - 24 12:30)\n/// );\n/// ```\npub const fn saturating_sub(self, duration: Duration) -> Self{\n        if let Some(datetime) = self.checked_sub(duration) {\n            datetime\n        } else if duration.is_negative() {\n            Self::MAX\n        } else {\n            Self::MIN\n        }\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::second":["/// Get the second within the minute.\n///\n/// The returned value will always be in the range `0..60`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).second(), 0);\n/// assert_eq!(datetime!(2019-01-01 23:59:59).second(), 59);\n/// ```\npub const fn second(self) -> u8{\n        self.time.second()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::sunday_based_week":["/// Get the week number where week 1 begins on the first Sunday.\n///\n/// The returned value will always be in the range `0..=53`.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).sunday_based_week(), 0);\n/// assert_eq!(datetime!(2020-01-01 0:00).sunday_based_week(), 0);\n/// assert_eq!(datetime!(2020-12-31 0:00).sunday_based_week(), 52);\n/// assert_eq!(datetime!(2021-01-01 0:00).sunday_based_week(), 0);\n/// ```\npub const fn sunday_based_week(self) -> u8{\n        self.date.sunday_based_week()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::time":["/// Get the [`Time`] component of the `PrimitiveDateTime`.\n///\n/// ```rust\n/// # use time::macros::{datetime, time};\n/// assert_eq!(datetime!(2019-01-01 0:00).time(), time!(0:00));\npub const fn time(self) -> Time{\n        self.time\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::to_calendar_date":["/// Get the year, month, and day.\n///\n/// ```rust\n/// # use time::{macros::datetime, Month};\n/// assert_eq!(\n///     datetime!(2019-01-01 0:00).to_calendar_date(),\n///     (2019, Month::January, 1)\n/// );\n/// ```\npub const fn to_calendar_date(self) -> (i32, Month, u8){\n        self.date.to_calendar_date()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::to_iso_week_date":["/// Get the ISO 8601 year, week number, and weekday.\n///\n/// ```rust\n/// # use time::{Weekday::*, macros::datetime};\n/// assert_eq!(\n///     datetime!(2019-01-01 0:00).to_iso_week_date(),\n///     (2019, 1, Tuesday)\n/// );\n/// assert_eq!(\n///     datetime!(2019-10-04 0:00).to_iso_week_date(),\n///     (2019, 40, Friday)\n/// );\n/// assert_eq!(\n///     datetime!(2020-01-01 0:00).to_iso_week_date(),\n///     (2020, 1, Wednesday)\n/// );\n/// assert_eq!(\n///     datetime!(2020-12-31 0:00).to_iso_week_date(),\n///     (2020, 53, Thursday)\n/// );\n/// assert_eq!(\n///     datetime!(2021-01-01 0:00).to_iso_week_date(),\n///     (2020, 53, Friday)\n/// );\n/// ```\npub const fn to_iso_week_date(self) -> (i32, u8, Weekday){\n        self.date.to_iso_week_date()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::to_julian_day":["/// Get the Julian day for the date. The time is not taken into account for this calculation.\n///\n/// The algorithm to perform this conversion is derived from one provided by Peter Baum; it is\n/// freely available [here](https://www.researchgate.net/publication/316558298_Date_Algorithms).\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(-4713-11-24 0:00).to_julian_day(), 0);\n/// assert_eq!(datetime!(2000-01-01 0:00).to_julian_day(), 2_451_545);\n/// assert_eq!(datetime!(2019-01-01 0:00).to_julian_day(), 2_458_485);\n/// assert_eq!(datetime!(2019-12-31 0:00).to_julian_day(), 2_458_849);\n/// ```\npub const fn to_julian_day(self) -> i32{\n        self.date.to_julian_day()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::to_ordinal_date":["/// Get the year and ordinal day number.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).to_ordinal_date(), (2019, 1));\n/// ```\npub const fn to_ordinal_date(self) -> (i32, u16){\n        self.date.to_ordinal_date()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::utc_to_offset":["/// Assuming that the current [`PrimitiveDateTime`] is a value in UTC, obtain the equivalent\n/// value in the provided [`UtcOffset`].\npub(crate) const fn utc_to_offset(self, offset: UtcOffset) -> Self{\n        self.offset_to_utc(UtcOffset::__from_hms_unchecked(\n            -offset.whole_hours(),\n            -offset.minutes_past_hour(),\n            -offset.seconds_past_minute(),\n        ))\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::weekday":["/// Get the weekday.\n///\n/// ```rust\n/// # use time::{Weekday::*, macros::datetime};\n/// assert_eq!(datetime!(2019-01-01 0:00).weekday(), Tuesday);\n/// assert_eq!(datetime!(2019-02-01 0:00).weekday(), Friday);\n/// assert_eq!(datetime!(2019-03-01 0:00).weekday(), Friday);\n/// assert_eq!(datetime!(2019-04-01 0:00).weekday(), Monday);\n/// assert_eq!(datetime!(2019-05-01 0:00).weekday(), Wednesday);\n/// assert_eq!(datetime!(2019-06-01 0:00).weekday(), Saturday);\n/// assert_eq!(datetime!(2019-07-01 0:00).weekday(), Monday);\n/// assert_eq!(datetime!(2019-08-01 0:00).weekday(), Thursday);\n/// assert_eq!(datetime!(2019-09-01 0:00).weekday(), Sunday);\n/// assert_eq!(datetime!(2019-10-01 0:00).weekday(), Tuesday);\n/// assert_eq!(datetime!(2019-11-01 0:00).weekday(), Friday);\n/// assert_eq!(datetime!(2019-12-01 0:00).weekday(), Sunday);\n/// ```\npub const fn weekday(self) -> Weekday{\n        self.date.weekday()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"primitive_date_time::PrimitiveDateTime::year":["/// Get the year of the date.\n///\n/// ```rust\n/// # use time::macros::datetime;\n/// assert_eq!(datetime!(2019-01-01 0:00).year(), 2019);\n/// assert_eq!(datetime!(2019-12-31 0:00).year(), 2019);\n/// assert_eq!(datetime!(2020-01-01 0:00).year(), 2020);\n/// ```\npub const fn year(self) -> i32{\n        self.date.year()\n    }","Real(LocalPath(\"src/primitive_date_time.rs\"))"],"time::Padding":["/// By explicitly inserting this enum where padding is expected, the compiler is able to better\n/// perform niche value optimization.\n#[repr(u8)]\npub(crate) enum Padding {\n    #[allow(clippy::missing_docs_in_private_items)]\n    Optimize,\n}","Real(LocalPath(\"src/time.rs\"))"],"time::Time":["/// The clock time within a given date. Nanosecond precision.\n///\n/// All minutes are assumed to have exactly 60 seconds; no attempt is made to handle leap seconds\n/// (either positive or negative).\n///\n/// When comparing two `Time`s, they are assumed to be in the same calendar date.\npub struct Time {\n    #[allow(clippy::missing_docs_in_private_items)]\n    hour: u8,\n    #[allow(clippy::missing_docs_in_private_items)]\n    minute: u8,\n    #[allow(clippy::missing_docs_in_private_items)]\n    second: u8,\n    #[allow(clippy::missing_docs_in_private_items)]\n    nanosecond: u32,\n    #[allow(clippy::missing_docs_in_private_items)]\n    padding: Padding,\n}","Real(LocalPath(\"src/time.rs\"))"],"time::Time::__from_hms_nanos_unchecked":["/// Create a `Time` from its components.\n#[doc(hidden)]\npub const fn __from_hms_nanos_unchecked(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> Self{\n        Self {\n            hour,\n            minute,\n            second,\n            nanosecond,\n            padding: Padding::Optimize,\n        }\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::adjusting_add":["/// Add the sub-day time of the [`Duration`] to the `Time`. Wraps on overflow, returning whether\n/// the date is different.\npub(crate) const fn adjusting_add(self, duration: Duration) -> (DateAdjustment, Self){\n        let mut nanoseconds = self.nanosecond as i32 + duration.subsec_nanoseconds();\n        let mut seconds = self.second as i8 + (duration.whole_seconds() % 60) as i8;\n        let mut minutes = self.minute as i8 + (duration.whole_minutes() % 60) as i8;\n        let mut hours = self.hour as i8 + (duration.whole_hours() % 24) as i8;\n        let mut date_adjustment = DateAdjustment::None;\n\n        cascade!(nanoseconds in 0..1_000_000_000 => seconds);\n        cascade!(seconds in 0..60 => minutes);\n        cascade!(minutes in 0..60 => hours);\n        if hours >= 24 {\n            hours -= 24;\n            date_adjustment = DateAdjustment::Next;\n        } else if hours < 0 {\n            hours += 24;\n            date_adjustment = DateAdjustment::Previous;\n        }\n\n        (\n            date_adjustment,\n            Self::__from_hms_nanos_unchecked(\n                hours as _,\n                minutes as _,\n                seconds as _,\n                nanoseconds as _,\n            ),\n        )\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::adjusting_add_std":["/// Add the sub-day time of the [`std::time::Duration`] to the `Time`. Wraps on overflow,\n/// returning whether the date is the previous date as the first element of the tuple.\npub(crate) const fn adjusting_add_std(self, duration: StdDuration) -> (bool, Self){\n        let mut nanosecond = self.nanosecond + duration.subsec_nanos();\n        let mut second = self.second + (duration.as_secs() % 60) as u8;\n        let mut minute = self.minute + ((duration.as_secs() / 60) % 60) as u8;\n        let mut hour = self.hour + ((duration.as_secs() / 3_600) % 24) as u8;\n        let mut is_next_day = false;\n\n        cascade!(nanosecond in 0..1_000_000_000 => second);\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        if hour >= 24 {\n            hour -= 24;\n            is_next_day = true;\n        }\n\n        (\n            is_next_day,\n            Self::__from_hms_nanos_unchecked(hour, minute, second, nanosecond),\n        )\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::adjusting_sub":["/// Subtract the sub-day time of the [`Duration`] to the `Time`. Wraps on overflow, returning\n/// whether the date is different.\npub(crate) const fn adjusting_sub(self, duration: Duration) -> (DateAdjustment, Self){\n        let mut nanoseconds = self.nanosecond as i32 - duration.subsec_nanoseconds();\n        let mut seconds = self.second as i8 - (duration.whole_seconds() % 60) as i8;\n        let mut minutes = self.minute as i8 - (duration.whole_minutes() % 60) as i8;\n        let mut hours = self.hour as i8 - (duration.whole_hours() % 24) as i8;\n        let mut date_adjustment = DateAdjustment::None;\n\n        cascade!(nanoseconds in 0..1_000_000_000 => seconds);\n        cascade!(seconds in 0..60 => minutes);\n        cascade!(minutes in 0..60 => hours);\n        if hours >= 24 {\n            hours -= 24;\n            date_adjustment = DateAdjustment::Next;\n        } else if hours < 0 {\n            hours += 24;\n            date_adjustment = DateAdjustment::Previous;\n        }\n\n        (\n            date_adjustment,\n            Self::__from_hms_nanos_unchecked(\n                hours as _,\n                minutes as _,\n                seconds as _,\n                nanoseconds as _,\n            ),\n        )\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::adjusting_sub_std":["/// Subtract the sub-day time of the [`std::time::Duration`] to the `Time`. Wraps on overflow,\n/// returning whether the date is the previous date as the first element of the tuple.\npub(crate) const fn adjusting_sub_std(self, duration: StdDuration) -> (bool, Self){\n        let mut nanosecond = self.nanosecond as i32 - duration.subsec_nanos() as i32;\n        let mut second = self.second as i8 - (duration.as_secs() % 60) as i8;\n        let mut minute = self.minute as i8 - ((duration.as_secs() / 60) % 60) as i8;\n        let mut hour = self.hour as i8 - ((duration.as_secs() / 3_600) % 24) as i8;\n        let mut is_previous_day = false;\n\n        cascade!(nanosecond in 0..1_000_000_000 => second);\n        cascade!(second in 0..60 => minute);\n        cascade!(minute in 0..60 => hour);\n        if hour < 0 {\n            hour += 24;\n            is_previous_day = true;\n        }\n\n        (\n            is_previous_day,\n            Self::__from_hms_nanos_unchecked(hour as _, minute as _, second as _, nanosecond as _),\n        )\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::as_hms":["/// Get the clock hour, minute, and second.\n///\n/// ```rust\n/// # use time::macros::time;\n/// assert_eq!(time!(0:00:00).as_hms(), (0, 0, 0));\n/// assert_eq!(time!(23:59:59).as_hms(), (23, 59, 59));\n/// ```\npub const fn as_hms(self) -> (u8, u8, u8){\n        (self.hour, self.minute, self.second)\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::as_hms_micro":["/// Get the clock hour, minute, second, and microsecond.\n///\n/// ```rust\n/// # use time::macros::time;\n/// assert_eq!(time!(0:00:00).as_hms_micro(), (0, 0, 0, 0));\n/// assert_eq!(\n///     time!(23:59:59.999_999).as_hms_micro(),\n///     (23, 59, 59, 999_999)\n/// );\n/// ```\npub const fn as_hms_micro(self) -> (u8, u8, u8, u32){\n        (self.hour, self.minute, self.second, self.nanosecond / 1_000)\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::as_hms_milli":["/// Get the clock hour, minute, second, and millisecond.\n///\n/// ```rust\n/// # use time::macros::time;\n/// assert_eq!(time!(0:00:00).as_hms_milli(), (0, 0, 0, 0));\n/// assert_eq!(time!(23:59:59.999).as_hms_milli(), (23, 59, 59, 999));\n/// ```\npub const fn as_hms_milli(self) -> (u8, u8, u8, u16){\n        (\n            self.hour,\n            self.minute,\n            self.second,\n            (self.nanosecond / 1_000_000) as u16,\n        )\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::as_hms_nano":["/// Get the clock hour, minute, second, and nanosecond.\n///\n/// ```rust\n/// # use time::macros::time;\n/// assert_eq!(time!(0:00:00).as_hms_nano(), (0, 0, 0, 0));\n/// assert_eq!(\n///     time!(23:59:59.999_999_999).as_hms_nano(),\n///     (23, 59, 59, 999_999_999)\n/// );\n/// ```\npub const fn as_hms_nano(self) -> (u8, u8, u8, u32){\n        (self.hour, self.minute, self.second, self.nanosecond)\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::from_hms":["/// Attempt to create a `Time` from the hour, minute, and second.\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::from_hms(1, 2, 3).is_ok());\n/// ```\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::from_hms(24, 0, 0).is_err()); // 24 isn't a valid hour.\n/// assert!(Time::from_hms(0, 60, 0).is_err()); // 60 isn't a valid minute.\n/// assert!(Time::from_hms(0, 0, 60).is_err()); // 60 isn't a valid second.\n/// ```\npub const fn from_hms(hour: u8, minute: u8, second: u8) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        Ok(Self::__from_hms_nanos_unchecked(hour, minute, second, 0))\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::from_hms_micro":["/// Attempt to create a `Time` from the hour, minute, second, and microsecond.\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::from_hms_micro(1, 2, 3, 4).is_ok());\n/// ```\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::from_hms_micro(24, 0, 0, 0).is_err()); // 24 isn't a valid hour.\n/// assert!(Time::from_hms_micro(0, 60, 0, 0).is_err()); // 60 isn't a valid minute.\n/// assert!(Time::from_hms_micro(0, 0, 60, 0).is_err()); // 60 isn't a valid second.\n/// assert!(Time::from_hms_micro(0, 0, 0, 1_000_000).is_err()); // 1_000_000 isn't a valid microsecond.\n/// ```\npub const fn from_hms_micro(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        microsecond: u32,\n    ) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        ensure_value_in_range!(microsecond in 0 => 999_999);\n        Ok(Self::__from_hms_nanos_unchecked(\n            hour,\n            minute,\n            second,\n            microsecond * 1_000,\n        ))\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::from_hms_milli":["/// Attempt to create a `Time` from the hour, minute, second, and millisecond.\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::from_hms_milli(1, 2, 3, 4).is_ok());\n/// ```\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::from_hms_milli(24, 0, 0, 0).is_err()); // 24 isn't a valid hour.\n/// assert!(Time::from_hms_milli(0, 60, 0, 0).is_err()); // 60 isn't a valid minute.\n/// assert!(Time::from_hms_milli(0, 0, 60, 0).is_err()); // 60 isn't a valid second.\n/// assert!(Time::from_hms_milli(0, 0, 0, 1_000).is_err()); // 1_000 isn't a valid millisecond.\n/// ```\npub const fn from_hms_milli(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        millisecond: u16,\n    ) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        ensure_value_in_range!(millisecond in 0 => 999);\n        Ok(Self::__from_hms_nanos_unchecked(\n            hour,\n            minute,\n            second,\n            millisecond as u32 * 1_000_000,\n        ))\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::from_hms_nano":["/// Attempt to create a `Time` from the hour, minute, second, and nanosecond.\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::from_hms_nano(1, 2, 3, 4).is_ok());\n/// ```\n///\n/// ```rust\n/// # use time::Time;\n/// assert!(Time::from_hms_nano(24, 0, 0, 0).is_err()); // 24 isn't a valid hour.\n/// assert!(Time::from_hms_nano(0, 60, 0, 0).is_err()); // 60 isn't a valid minute.\n/// assert!(Time::from_hms_nano(0, 0, 60, 0).is_err()); // 60 isn't a valid second.\n/// assert!(Time::from_hms_nano(0, 0, 0, 1_000_000_000).is_err()); // 1_000_000_000 isn't a valid nanosecond.\n/// ```\npub const fn from_hms_nano(\n        hour: u8,\n        minute: u8,\n        second: u8,\n        nanosecond: u32,\n    ) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(hour in 0 => 23);\n        ensure_value_in_range!(minute in 0 => 59);\n        ensure_value_in_range!(second in 0 => 59);\n        ensure_value_in_range!(nanosecond in 0 => 999_999_999);\n        Ok(Self::__from_hms_nanos_unchecked(\n            hour, minute, second, nanosecond,\n        ))\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::hour":["/// Get the clock hour.\n///\n/// The returned value will always be in the range `0..24`.\n///\n/// ```rust\n/// # use time::macros::time;\n/// assert_eq!(time!(0:00:00).hour(), 0);\n/// assert_eq!(time!(23:59:59).hour(), 23);\n/// ```\npub const fn hour(self) -> u8{\n        self.hour\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::microsecond":["/// Get the microseconds within the second.\n///\n/// The returned value will always be in the range `0..1_000_000`.\n///\n/// ```rust\n/// # use time::macros::time;\n/// assert_eq!(time!(0:00).microsecond(), 0);\n/// assert_eq!(time!(23:59:59.999_999).microsecond(), 999_999);\n/// ```\npub const fn microsecond(self) -> u32{\n        self.nanosecond / 1_000\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::millisecond":["/// Get the milliseconds within the second.\n///\n/// The returned value will always be in the range `0..1_000`.\n///\n/// ```rust\n/// # use time::macros::time;\n/// assert_eq!(time!(0:00).millisecond(), 0);\n/// assert_eq!(time!(23:59:59.999).millisecond(), 999);\n/// ```\npub const fn millisecond(self) -> u16{\n        (self.nanosecond / 1_000_000) as _\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::minute":["/// Get the minute within the hour.\n///\n/// The returned value will always be in the range `0..60`.\n///\n/// ```rust\n/// # use time::macros::time;\n/// assert_eq!(time!(0:00:00).minute(), 0);\n/// assert_eq!(time!(23:59:59).minute(), 59);\n/// ```\npub const fn minute(self) -> u8{\n        self.minute\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::nanosecond":["/// Get the nanoseconds within the second.\n///\n/// The returned value will always be in the range `0..1_000_000_000`.\n///\n/// ```rust\n/// # use time::macros::time;\n/// assert_eq!(time!(0:00).nanosecond(), 0);\n/// assert_eq!(time!(23:59:59.999_999_999).nanosecond(), 999_999_999);\n/// ```\npub const fn nanosecond(self) -> u32{\n        self.nanosecond\n    }","Real(LocalPath(\"src/time.rs\"))"],"time::Time::second":["/// Get the second within the minute.\n///\n/// The returned value will always be in the range `0..60`.\n///\n/// ```rust\n/// # use time::macros::time;\n/// assert_eq!(time!(0:00:00).second(), 0);\n/// assert_eq!(time!(23:59:59).second(), 59);\n/// ```\npub const fn second(self) -> u8{\n        self.second\n    }","Real(LocalPath(\"src/time.rs\"))"],"utc_offset::UtcOffset":["/// An offset from UTC.\n///\n/// This struct can store values up to ±23:59:59. If you need support outside this range, please\n/// file an issue with your use case.\npub struct UtcOffset {\n    #[allow(clippy::missing_docs_in_private_items)]\n    hours: i8,\n    #[allow(clippy::missing_docs_in_private_items)]\n    minutes: i8,\n    #[allow(clippy::missing_docs_in_private_items)]\n    seconds: i8,\n}","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::__from_hms_unchecked":["/// Create a `UtcOffset` representing an offset of the hours, minutes, and seconds provided, the\n/// validity of which must be guaranteed by the caller. All three parameters must have the same\n/// sign.\n#[doc(hidden)]\npub const fn __from_hms_unchecked(hours: i8, minutes: i8, seconds: i8) -> Self{\n        Self {\n            hours,\n            minutes,\n            seconds,\n        }\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::as_hms":["/// Obtain the UTC offset as its hours, minutes, and seconds. The sign of all three components\n/// will always match. A positive value indicates an offset to the east; a negative to the west.\n///\n/// ```rust\n/// # use time::macros::offset;\n/// assert_eq!(offset!(+1:02:03).as_hms(), (1, 2, 3));\n/// assert_eq!(offset!(-1:02:03).as_hms(), (-1, -2, -3));\n/// ```\npub const fn as_hms(self) -> (i8, i8, i8){\n        (self.hours, self.minutes, self.seconds)\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::from_hms":["/// Create a `UtcOffset` representing an offset by the number of hours, minutes, and seconds\n/// provided.\n///\n/// The sign of all three components should match. If they do not, all smaller components will\n/// have their signs flipped.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::from_hms(1, 2, 3)?.as_hms(), (1, 2, 3));\n/// assert_eq!(UtcOffset::from_hms(1, -2, -3)?.as_hms(), (1, 2, 3));\n/// # Ok::<_, time::Error>(())\n/// ```\npub const fn from_hms(\n        hours: i8,\n        mut minutes: i8,\n        mut seconds: i8,\n    ) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(hours in -23 => 23);\n        ensure_value_in_range!(minutes in -59 => 59);\n        ensure_value_in_range!(seconds in -59 => 59);\n\n        if (hours > 0 && minutes < 0) || (hours < 0 && minutes > 0) {\n            minutes *= -1;\n        }\n        if (hours > 0 && seconds < 0)\n            || (hours < 0 && seconds > 0)\n            || (minutes > 0 && seconds < 0)\n            || (minutes < 0 && seconds > 0)\n        {\n            seconds *= -1;\n        }\n\n        Ok(Self::__from_hms_unchecked(hours, minutes, seconds))\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::from_whole_seconds":["/// Create a `UtcOffset` representing an offset by the number of seconds provided.\n///\n/// ```rust\n/// # use time::UtcOffset;\n/// assert_eq!(UtcOffset::from_whole_seconds(3_723)?.as_hms(), (1, 2, 3));\n/// # Ok::<_, time::Error>(())\n/// ```\npub const fn from_whole_seconds(seconds: i32) -> Result<Self, error::ComponentRange>{\n        ensure_value_in_range!(seconds in -86_399 => 86_399);\n\n        Ok(Self::__from_hms_unchecked(\n            (seconds / 3_600) as _,\n            ((seconds / 60) % 60) as _,\n            (seconds % 60) as _,\n        ))\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::is_negative":["/// Check if the offset is negative, or west of UTC.\n///\n/// ```rust\n/// # use time::macros::offset;\n/// assert!(!offset!(+1:02:03).is_negative());\n/// assert!(offset!(-1:02:03).is_negative());\n/// assert!(!offset!(UTC).is_negative());\n/// ```\npub const fn is_negative(self) -> bool{\n        self.hours < 0 || self.minutes < 0 || self.seconds < 0\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::is_positive":["/// Check if the offset is positive, or east of UTC.\n///\n/// ```rust\n/// # use time::macros::offset;\n/// assert!(offset!(+1:02:03).is_positive());\n/// assert!(!offset!(-1:02:03).is_positive());\n/// assert!(!offset!(UTC).is_positive());\n/// ```\npub const fn is_positive(self) -> bool{\n        self.hours > 0 || self.minutes > 0 || self.seconds > 0\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::is_utc":["/// Check if the offset is exactly UTC.\n///\n///\n/// ```rust\n/// # use time::macros::offset;\n/// assert!(!offset!(+1:02:03).is_utc());\n/// assert!(!offset!(-1:02:03).is_utc());\n/// assert!(offset!(UTC).is_utc());\n/// ```\npub const fn is_utc(self) -> bool{\n        self.hours == 0 && self.minutes == 0 && self.seconds == 0\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::minutes_past_hour":["/// Obtain the number of minutes past the hour the offset is from UTC. A positive value\n/// indicates an offset to the east; a negative to the west.\n///\n/// ```rust\n/// # use time::macros::offset;\n/// assert_eq!(offset!(+1:02:03).minutes_past_hour(), 2);\n/// assert_eq!(offset!(-1:02:03).minutes_past_hour(), -2);\n/// ```\npub const fn minutes_past_hour(self) -> i8{\n        self.minutes\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::seconds_past_minute":["/// Obtain the number of seconds past the minute the offset is from UTC. A positive value\n/// indicates an offset to the east; a negative to the west.\n///\n/// ```rust\n/// # use time::macros::offset;\n/// assert_eq!(offset!(+1:02:03).seconds_past_minute(), 3);\n/// assert_eq!(offset!(-1:02:03).seconds_past_minute(), -3);\n/// ```\npub const fn seconds_past_minute(self) -> i8{\n        self.seconds\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::whole_hours":["/// Obtain the number of whole hours the offset is from UTC. A positive value indicates an\n/// offset to the east; a negative to the west.\n///\n/// ```rust\n/// # use time::macros::offset;\n/// assert_eq!(offset!(+1:02:03).whole_hours(), 1);\n/// assert_eq!(offset!(-1:02:03).whole_hours(), -1);\n/// ```\npub const fn whole_hours(self) -> i8{\n        self.hours\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::whole_minutes":["/// Obtain the number of whole minutes the offset is from UTC. A positive value indicates an\n/// offset to the east; a negative to the west.\n///\n/// ```rust\n/// # use time::macros::offset;\n/// assert_eq!(offset!(+1:02:03).whole_minutes(), 62);\n/// assert_eq!(offset!(-1:02:03).whole_minutes(), -62);\n/// ```\npub const fn whole_minutes(self) -> i16{\n        self.hours as i16 * 60 + self.minutes as i16\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"utc_offset::UtcOffset::whole_seconds":["/// Obtain the number of whole seconds the offset is from UTC. A positive value indicates an\n/// offset to the east; a negative to the west.\n///\n/// ```rust\n/// # use time::macros::offset;\n/// assert_eq!(offset!(+1:02:03).whole_seconds(), 3723);\n/// assert_eq!(offset!(-1:02:03).whole_seconds(), -3723);\n/// ```\npub const fn whole_seconds(self) -> i32{\n        self.hours as i32 * 3_600 + self.minutes as i32 * 60 + self.seconds as i32\n    }","Real(LocalPath(\"src/utc_offset.rs\"))"],"util::DateAdjustment":["/// Whether to adjust the date, and in which direction. Useful when implementing arithmetic.\npub(crate) enum DateAdjustment {\n    /// The previous day should be used.\n    Previous,\n    /// The next day should be used.\n    Next,\n    /// The date should be used as-is.\n    None,\n}","Real(LocalPath(\"src/util.rs\"))"],"util::days_in_year":["/// Get the number of calendar days in a given year.\n///\n/// The returned value will always be either 365 or 366.\n///\n/// ```rust\n/// # use time::util::days_in_year;\n/// assert_eq!(days_in_year(1900), 365);\n/// assert_eq!(days_in_year(2000), 366);\n/// assert_eq!(days_in_year(2004), 366);\n/// assert_eq!(days_in_year(2005), 365);\n/// assert_eq!(days_in_year(2100), 365);\n/// ```\npub const fn days_in_year(year: i32) -> u16{\n    if is_leap_year(year) { 366 } else { 365 }\n}","Real(LocalPath(\"src/util.rs\"))"],"util::days_in_year_month":["/// Get the number of days in the month of a given year.\n///\n/// ```rust\n/// # use time::{Month, util};\n/// assert_eq!(util::days_in_year_month(2020, Month::February), 29);\n/// ```\npub const fn days_in_year_month(year: i32, month: Month) -> u8{\n    use Month::*;\n    match month {\n        January | March | May | July | August | October | December => 31,\n        April | June | September | November => 30,\n        February if is_leap_year(year) => 29,\n        February => 28,\n    }\n}","Real(LocalPath(\"src/util.rs\"))"],"util::is_leap_year":["/// Returns if the provided year is a leap year in the proleptic Gregorian calendar. Uses\n/// [astronomical year numbering](https://en.wikipedia.org/wiki/Astronomical_year_numbering).\n///\n/// ```rust\n/// # use time::util::is_leap_year;\n/// assert!(!is_leap_year(1900));\n/// assert!(is_leap_year(2000));\n/// assert!(is_leap_year(2004));\n/// assert!(!is_leap_year(2005));\n/// assert!(!is_leap_year(2100));\n/// ```\npub const fn is_leap_year(year: i32) -> bool{\n    year % 4 == 0 && (year % 25 != 0 || year % 16 == 0)\n}","Real(LocalPath(\"src/util.rs\"))"],"util::weeks_in_year":["/// Get the number of weeks in the ISO year.\n///\n/// The returned value will always be either 52 or 53.\n///\n/// ```rust\n/// # use time::util::weeks_in_year;\n/// assert_eq!(weeks_in_year(2019), 52);\n/// assert_eq!(weeks_in_year(2020), 53);\n/// ```\npub const fn weeks_in_year(year: i32) -> u8{\n    match year.rem_euclid(400) {\n        4 | 9 | 15 | 20 | 26 | 32 | 37 | 43 | 48 | 54 | 60 | 65 | 71 | 76 | 82 | 88 | 93 | 99\n        | 105 | 111 | 116 | 122 | 128 | 133 | 139 | 144 | 150 | 156 | 161 | 167 | 172 | 178\n        | 184 | 189 | 195 | 201 | 207 | 212 | 218 | 224 | 229 | 235 | 240 | 246 | 252 | 257\n        | 263 | 268 | 274 | 280 | 285 | 291 | 296 | 303 | 308 | 314 | 320 | 325 | 331 | 336\n        | 342 | 348 | 353 | 359 | 364 | 370 | 376 | 381 | 387 | 392 | 398 => 53,\n        _ => 52,\n    }\n}","Real(LocalPath(\"src/util.rs\"))"],"weekday::Weekday":["/// Days of the week.\n///\n/// As order is dependent on context (Sunday could be either two days after or five days before\n/// Friday), this type does not implement `PartialOrd` or `Ord`.\npub enum Weekday {\n    #[allow(clippy::missing_docs_in_private_items)]\n    Monday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Tuesday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Wednesday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Thursday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Friday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Saturday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Sunday,\n}","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::next":["/// Get the next weekday.\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Monday.next(), Weekday::Tuesday);\n/// ```\npub const fn next(self) -> Self{\n        match self {\n            Monday => Tuesday,\n            Tuesday => Wednesday,\n            Wednesday => Thursday,\n            Thursday => Friday,\n            Friday => Saturday,\n            Saturday => Sunday,\n            Sunday => Monday,\n        }\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::number_days_from_monday":["/// Get the zero-indexed number of days from Monday.\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Monday.number_days_from_monday(), 0);\n/// ```\npub const fn number_days_from_monday(self) -> u8{\n        self as _\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::number_days_from_sunday":["/// Get the zero-indexed number of days from Sunday.\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Monday.number_days_from_sunday(), 1);\n/// ```\npub const fn number_days_from_sunday(self) -> u8{\n        match self {\n            Monday => 1,\n            Tuesday => 2,\n            Wednesday => 3,\n            Thursday => 4,\n            Friday => 5,\n            Saturday => 6,\n            Sunday => 0,\n        }\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::number_from_monday":["/// Get the one-indexed number of days from Monday.\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Monday.number_from_monday(), 1);\n/// ```\n#[doc(alias = \"iso_weekday_number\")]\npub const fn number_from_monday(self) -> u8{\n        self.number_days_from_monday() + 1\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::number_from_sunday":["/// Get the one-indexed number of days from Sunday.\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Monday.number_from_sunday(), 2);\n/// ```\npub const fn number_from_sunday(self) -> u8{\n        self.number_days_from_sunday() + 1\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::previous":["/// Get the previous weekday.\n///\n/// ```rust\n/// # use time::Weekday;\n/// assert_eq!(Weekday::Tuesday.previous(), Weekday::Monday);\n/// ```\npub const fn previous(self) -> Self{\n        match self {\n            Monday => Sunday,\n            Tuesday => Monday,\n            Wednesday => Tuesday,\n            Thursday => Wednesday,\n            Friday => Thursday,\n            Saturday => Friday,\n            Sunday => Saturday,\n        }\n    }","Real(LocalPath(\"src/weekday.rs\"))"]},"struct_constructor":{"&'static str":["name"],"&(dyn std::error::Error + 'static)":["source"],"&std::time::Instant":["as_ref","borrow"],"(bool, time::Time)":["adjusting_add_std","adjusting_sub_std"],"(duration::Duration, T)":["time_fn"],"(i32, month::Month, u8)":["to_calendar_date"],"(i32, u16)":["to_ordinal_date"],"(i32, u8)":["iso_year_week"],"(i32, u8, weekday::Weekday)":["to_iso_week_date"],"(i8, i8, i8)":["as_hms"],"(month::Month, u8)":["month_day"],"(u8, u8, u8)":["as_hms","to_hms"],"(u8, u8, u8, u16)":["as_hms_milli","to_hms_milli"],"(u8, u8, u8, u32)":["as_hms_micro","as_hms_nano","to_hms_micro","to_hms_nano"],"(util::DateAdjustment, time::Time)":["adjusting_add","adjusting_sub"],"<date::Date as std::ops::Add<duration::Duration>>::Output":["add"],"<date::Date as std::ops::Add<std::time::Duration>>::Output":["add"],"<date::Date as std::ops::Sub<duration::Duration>>::Output":["sub"],"<date::Date as std::ops::Sub<std::time::Duration>>::Output":["sub"],"<date::Date as std::ops::Sub>::Output":["sub"],"<duration::Duration as std::ops::Add<std::time::Duration>>::Output":["add"],"<duration::Duration as std::ops::Add>::Output":["add"],"<duration::Duration as std::ops::Div<f32>>::Output":["div"],"<duration::Duration as std::ops::Div<f64>>::Output":["div"],"<duration::Duration as std::ops::Div<i16>>::Output":["div"],"<duration::Duration as std::ops::Div<i32>>::Output":["div"],"<duration::Duration as std::ops::Div<i8>>::Output":["div"],"<duration::Duration as std::ops::Div<std::time::Duration>>::Output":["div"],"<duration::Duration as std::ops::Div<u16>>::Output":["div"],"<duration::Duration as std::ops::Div<u32>>::Output":["div"],"<duration::Duration as std::ops::Div<u8>>::Output":["div"],"<duration::Duration as std::ops::Div>::Output":["div"],"<duration::Duration as std::ops::Mul<f32>>::Output":["mul"],"<duration::Duration as std::ops::Mul<f64>>::Output":["mul"],"<duration::Duration as std::ops::Mul<i16>>::Output":["mul"],"<duration::Duration as std::ops::Mul<i32>>::Output":["mul"],"<duration::Duration as std::ops::Mul<i8>>::Output":["mul"],"<duration::Duration as std::ops::Mul<u16>>::Output":["mul"],"<duration::Duration as std::ops::Mul<u32>>::Output":["mul"],"<duration::Duration as std::ops::Mul<u8>>::Output":["mul"],"<duration::Duration as std::ops::Neg>::Output":["neg"],"<duration::Duration as std::ops::Sub<std::time::Duration>>::Output":["sub"],"<duration::Duration as std::ops::Sub>::Output":["sub"],"<f32 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<f64 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<i16 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<i32 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<i8 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<instant::Instant as std::ops::Add<duration::Duration>>::Output":["add"],"<instant::Instant as std::ops::Add<std::time::Duration>>::Output":["add"],"<instant::Instant as std::ops::Sub<duration::Duration>>::Output":["sub"],"<instant::Instant as std::ops::Sub<std::time::Duration>>::Output":["sub"],"<instant::Instant as std::ops::Sub<std::time::Instant>>::Output":["sub"],"<instant::Instant as std::ops::Sub>::Output":["sub"],"<offset_date_time::OffsetDateTime as std::ops::Add<T>>::Output":["add"],"<offset_date_time::OffsetDateTime as std::ops::Sub<T>>::Output":["sub"],"<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::SystemTime>>::Output":["sub"],"<offset_date_time::OffsetDateTime as std::ops::Sub>::Output":["sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<duration::Duration>>::Output":["add"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<std::time::Duration>>::Output":["add"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<duration::Duration>>::Output":["sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::Duration>>::Output":["sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub>::Output":["sub"],"<std::time::Duration as std::ops::Add<duration::Duration>>::Output":["add"],"<std::time::Duration as std::ops::Div<duration::Duration>>::Output":["div"],"<std::time::Duration as std::ops::Sub<duration::Duration>>::Output":["sub"],"<std::time::Instant as std::ops::Add<duration::Duration>>::Output":["add"],"<std::time::Instant as std::ops::Sub<duration::Duration>>::Output":["sub"],"<std::time::Instant as std::ops::Sub<instant::Instant>>::Output":["sub"],"<std::time::SystemTime as std::ops::Add<duration::Duration>>::Output":["add"],"<std::time::SystemTime as std::ops::Sub<duration::Duration>>::Output":["sub"],"<std::time::SystemTime as std::ops::Sub<offset_date_time::OffsetDateTime>>::Output":["sub"],"<time::Time as std::ops::Add<duration::Duration>>::Output":["add"],"<time::Time as std::ops::Add<std::time::Duration>>::Output":["add"],"<time::Time as std::ops::Sub<duration::Duration>>::Output":["sub"],"<time::Time as std::ops::Sub<std::time::Duration>>::Output":["sub"],"<time::Time as std::ops::Sub>::Output":["sub"],"<u16 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<u32 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<u8 as std::ops::Mul<duration::Duration>>::Output":["mul"],"<utc_offset::UtcOffset as std::ops::Neg>::Output":["neg"],"bool":["eq","is_leap_year","is_negative","is_positive","is_utc","is_zero"],"date::Date":["__from_ordinal_date_unchecked","clone","date","from_calendar_date","from_iso_week_date","from_julian_day","from_julian_day_unchecked","from_ordinal_date"],"duration::Duration":["clone","days","default","elapsed","hours","microseconds","milliseconds","minutes","nanoseconds","nanoseconds_i128","new","new_unchecked","seconds","seconds_f32","seconds_f64","sum","try_from","weeks"],"duration::Padding":["clone","default"],"error::Error":["from"],"error::component_range::ComponentRange":["clone","try_from"],"error::conversion_range::ConversionRange":["clone","try_from"],"error::different_variant::DifferentVariant":["clone","try_from"],"f32":["as_seconds_f32"],"f64":["as_seconds_f64"],"i128":["unix_timestamp_nanos","whole_microseconds","whole_milliseconds","whole_nanoseconds"],"i16":["subsec_milliseconds","whole_minutes"],"i32":["subsec_microseconds","subsec_nanoseconds","to_julian_day","whole_seconds","year"],"i64":["unix_timestamp","whole_days","whole_hours","whole_minutes","whole_seconds","whole_weeks"],"i8":["minutes_past_hour","seconds_past_minute","whole_hours"],"instant::Instant":["clone","from","now"],"month::Month":["clone","from_number","month","try_from"],"offset_date_time::OffsetDateTime":["assume_offset","assume_utc","clone","from","from_unix_timestamp","from_unix_timestamp_nanos","now_utc"],"primitive_date_time::PrimitiveDateTime":["clone","midnight","new","with_hms","with_hms_micro","with_hms_milli","with_hms_nano","with_time"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::time::Duration":["abs_std","std_days","std_hours","std_microseconds","std_milliseconds","std_minutes","std_nanoseconds","std_seconds","std_weeks","try_from"],"std::time::Instant":["from","into_inner"],"std::time::SystemTime":["from"],"time::Padding":["clone"],"time::Time":["__from_hms_nanos_unchecked","clone","from_hms","from_hms_micro","from_hms_milli","from_hms_nano","time"],"u16":["days_in_year","millisecond","ordinal"],"u32":["microsecond","nanosecond"],"u8":["day","days_in_year_month","from","hour","iso_week","minute","monday_based_week","number_days_from_monday","number_days_from_sunday","number_from_monday","number_from_sunday","second","sunday_based_week","weeks_in_year"],"utc_offset::UtcOffset":["__from_hms_unchecked","clone","from_hms","from_whole_seconds","offset"],"weekday::Weekday":["clone","weekday"]},"struct_to_trait":{"date::Date":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"duration::Duration":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::TryFrom","std::default::Default","std::fmt::Debug","std::hash::Hash","std::iter::Sum","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Div","std::ops::DivAssign","std::ops::Mul","std::ops::MulAssign","std::ops::Neg","std::ops::Sub","std::ops::SubAssign"],"duration::Padding":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::Error":["std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display"],"error::component_range::ComponentRange":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::TryFrom","std::error::Error","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::conversion_range::ConversionRange":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::TryFrom","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"error::different_variant::DifferentVariant":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::TryFrom","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"instant::Instant":["std::borrow::Borrow","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::AsRef","std::convert::From","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"month::Month":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::TryFrom","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset_date_time::OffsetDateTime":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"primitive_date_time::PrimitiveDateTime":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"std::time::Duration":["std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::TryFrom","std::ops::Add","std::ops::Div","std::ops::Sub","std::ops::SubAssign"],"std::time::Instant":["std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"std::time::SystemTime":["std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"time::Padding":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"time::Time":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign"],"utc_offset::UtcOffset":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Neg"],"weekday::Weekday":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"]},"targets":{"<date::Date as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/date.rs\"))","std::fmt::Debug"],"<date::Date as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/date.rs\"))","std::fmt::Display"],"<date::Date as std::ops::Add<duration::Duration>>::add":["add","Real(LocalPath(\"src/date.rs\"))","std::ops::Add"],"<date::Date as std::ops::Add<std::time::Duration>>::add":["add","Real(LocalPath(\"src/date.rs\"))","std::ops::Add"],"<date::Date as std::ops::AddAssign<duration::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"<date::Date as std::ops::AddAssign<std::time::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"<date::Date as std::ops::Sub<duration::Duration>>::sub":["sub","Real(LocalPath(\"src/date.rs\"))","std::ops::Sub"],"<date::Date as std::ops::Sub<std::time::Duration>>::sub":["sub","Real(LocalPath(\"src/date.rs\"))","std::ops::Sub"],"<date::Date as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/date.rs\"))","std::ops::Sub"],"<date::Date as std::ops::SubAssign<duration::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"<date::Date as std::ops::SubAssign<std::time::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"<duration::Duration as std::cmp::PartialEq<std::time::Duration>>::eq":["eq","Real(LocalPath(\"src/duration.rs\"))","std::cmp::PartialEq"],"<duration::Duration as std::cmp::PartialOrd<std::time::Duration>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/duration.rs\"))","std::cmp::PartialOrd"],"<duration::Duration as std::convert::TryFrom<std::time::Duration>>::try_from":["try_from","Real(LocalPath(\"src/duration.rs\"))","std::convert::TryFrom"],"<duration::Duration as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/duration.rs\"))","std::fmt::Debug"],"<duration::Duration as std::iter::Sum<&'a duration::Duration>>::sum":["sum","Real(LocalPath(\"src/duration.rs\"))","std::iter::Sum"],"<duration::Duration as std::iter::Sum>::sum":["sum","Real(LocalPath(\"src/duration.rs\"))","std::iter::Sum"],"<duration::Duration as std::ops::Add<std::time::Duration>>::add":["add","Real(LocalPath(\"src/duration.rs\"))","std::ops::Add"],"<duration::Duration as std::ops::Add>::add":["add","Real(LocalPath(\"src/duration.rs\"))","std::ops::Add"],"<duration::Duration as std::ops::AddAssign<std::time::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"<duration::Duration as std::ops::AddAssign>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"<duration::Duration as std::ops::Div<f32>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<f64>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<i16>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<i32>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<i8>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<std::time::Duration>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<u16>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<u32>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div<u8>>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::Div>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"<duration::Duration as std::ops::DivAssign<f32>>::div_assign":["div_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<f64>>::div_assign":["div_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<i16>>::div_assign":["div_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<i32>>::div_assign":["div_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<i8>>::div_assign":["div_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<u16>>::div_assign":["div_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<u32>>::div_assign":["div_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::DivAssign<u8>>::div_assign":["div_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::DivAssign"],"<duration::Duration as std::ops::Mul<f32>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<f64>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<i16>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<i32>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<i8>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<u16>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<u32>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::Mul<u8>>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"<duration::Duration as std::ops::MulAssign<f32>>::mul_assign":["mul_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<f64>>::mul_assign":["mul_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<i16>>::mul_assign":["mul_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<i32>>::mul_assign":["mul_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<i8>>::mul_assign":["mul_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<u16>>::mul_assign":["mul_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<u32>>::mul_assign":["mul_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::MulAssign<u8>>::mul_assign":["mul_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::MulAssign"],"<duration::Duration as std::ops::Neg>::neg":["neg","Real(LocalPath(\"src/duration.rs\"))","std::ops::Neg"],"<duration::Duration as std::ops::Sub<std::time::Duration>>::sub":["sub","Real(LocalPath(\"src/duration.rs\"))","std::ops::Sub"],"<duration::Duration as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/duration.rs\"))","std::ops::Sub"],"<duration::Duration as std::ops::SubAssign<std::time::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"<duration::Duration as std::ops::SubAssign>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"<duration::Padding as std::default::Default>::default":["default","Real(LocalPath(\"src/duration.rs\"))","std::default::Default"],"<error::Error as std::error::Error>::source":["source","Real(LocalPath(\"src/error/mod.rs\"))","std::error::Error"],"<error::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error/mod.rs\"))","std::fmt::Display"],"<error::component_range::ComponentRange as std::convert::TryFrom<error::Error>>::try_from":["try_from","Real(LocalPath(\"src/error/component_range.rs\"))","std::convert::TryFrom"],"<error::component_range::ComponentRange as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error/component_range.rs\"))","std::fmt::Display"],"<error::conversion_range::ConversionRange as std::convert::TryFrom<error::Error>>::try_from":["try_from","Real(LocalPath(\"src/error/conversion_range.rs\"))","std::convert::TryFrom"],"<error::conversion_range::ConversionRange as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error/conversion_range.rs\"))","std::fmt::Display"],"<error::different_variant::DifferentVariant as std::convert::TryFrom<error::Error>>::try_from":["try_from","Real(LocalPath(\"src/error/different_variant.rs\"))","std::convert::TryFrom"],"<error::different_variant::DifferentVariant as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error/different_variant.rs\"))","std::fmt::Display"],"<f64 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<f64 as ext::NumericalStdDuration>::std_days":["std_days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_hours":["std_hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_microseconds":["std_microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_milliseconds":["std_milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_minutes":["std_minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_nanoseconds":["std_nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_seconds":["std_seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<f64 as ext::NumericalStdDuration>::std_weeks":["std_weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<i64 as ext::NumericalDuration>::days":["days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::hours":["hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::microseconds":["microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::milliseconds":["milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::minutes":["minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::nanoseconds":["nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::seconds":["seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<i64 as ext::NumericalDuration>::weeks":["weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalDuration"],"<instant::Instant as std::borrow::Borrow<std::time::Instant>>::borrow":["borrow","Real(LocalPath(\"src/instant.rs\"))","std::borrow::Borrow"],"<instant::Instant as std::cmp::PartialEq<std::time::Instant>>::eq":["eq","Real(LocalPath(\"src/instant.rs\"))","std::cmp::PartialEq"],"<instant::Instant as std::cmp::PartialOrd<std::time::Instant>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/instant.rs\"))","std::cmp::PartialOrd"],"<instant::Instant as std::convert::AsRef<std::time::Instant>>::as_ref":["as_ref","Real(LocalPath(\"src/instant.rs\"))","std::convert::AsRef"],"<instant::Instant as std::convert::From<std::time::Instant>>::from":["from","Real(LocalPath(\"src/instant.rs\"))","std::convert::From"],"<instant::Instant as std::ops::Add<duration::Duration>>::add":["add","Real(LocalPath(\"src/instant.rs\"))","std::ops::Add"],"<instant::Instant as std::ops::Add<std::time::Duration>>::add":["add","Real(LocalPath(\"src/instant.rs\"))","std::ops::Add"],"<instant::Instant as std::ops::AddAssign<duration::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"<instant::Instant as std::ops::AddAssign<std::time::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"<instant::Instant as std::ops::Sub<duration::Duration>>::sub":["sub","Real(LocalPath(\"src/instant.rs\"))","std::ops::Sub"],"<instant::Instant as std::ops::Sub<std::time::Duration>>::sub":["sub","Real(LocalPath(\"src/instant.rs\"))","std::ops::Sub"],"<instant::Instant as std::ops::Sub<std::time::Instant>>::sub":["sub","Real(LocalPath(\"src/instant.rs\"))","std::ops::Sub"],"<instant::Instant as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/instant.rs\"))","std::ops::Sub"],"<instant::Instant as std::ops::SubAssign<duration::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"<instant::Instant as std::ops::SubAssign<std::time::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"<month::Month as std::convert::TryFrom<u8>>::try_from":["try_from","Real(LocalPath(\"src/month.rs\"))","std::convert::TryFrom"],"<month::Month as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/month.rs\"))","std::fmt::Display"],"<offset_date_time::OffsetDateTime as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::Ord"],"<offset_date_time::OffsetDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq":["eq","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::PartialEq"],"<offset_date_time::OffsetDateTime as std::cmp::PartialEq>::eq":["eq","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::PartialEq"],"<offset_date_time::OffsetDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::PartialOrd"],"<offset_date_time::OffsetDateTime as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::PartialOrd"],"<offset_date_time::OffsetDateTime as std::convert::From<std::time::SystemTime>>::from":["from","Real(LocalPath(\"src/offset_date_time.rs\"))","std::convert::From"],"<offset_date_time::OffsetDateTime as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/offset_date_time.rs\"))","std::fmt::Display"],"<offset_date_time::OffsetDateTime as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/offset_date_time.rs\"))","std::hash::Hash"],"<offset_date_time::OffsetDateTime as std::ops::Add<T>>::add":["add","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Add"],"<offset_date_time::OffsetDateTime as std::ops::AddAssign<duration::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"<offset_date_time::OffsetDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"<offset_date_time::OffsetDateTime as std::ops::Sub<T>>::sub":["sub","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Sub"],"<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::SystemTime>>::sub":["sub","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Sub"],"<offset_date_time::OffsetDateTime as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Sub"],"<offset_date_time::OffsetDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"<offset_date_time::OffsetDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"<primitive_date_time::PrimitiveDateTime as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::fmt::Display"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<duration::Duration>>::add":["add","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::Add"],"<primitive_date_time::PrimitiveDateTime as std::ops::Add<std::time::Duration>>::add":["add","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::Add"],"<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<duration::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<duration::Duration>>::sub":["sub","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::Sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::Duration>>::sub":["sub","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::Sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/primitive_date_time.rs\"))","std::ops::Sub"],"<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"<time::Time as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/time.rs\"))","std::fmt::Debug"],"<time::Time as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/time.rs\"))","std::fmt::Display"],"<time::Time as std::ops::Add<duration::Duration>>::add":["add","Real(LocalPath(\"src/time.rs\"))","std::ops::Add"],"<time::Time as std::ops::Add<std::time::Duration>>::add":["add","Real(LocalPath(\"src/time.rs\"))","std::ops::Add"],"<time::Time as std::ops::AddAssign<duration::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"<time::Time as std::ops::AddAssign<std::time::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"<time::Time as std::ops::Sub<duration::Duration>>::sub":["sub","Real(LocalPath(\"src/time.rs\"))","std::ops::Sub"],"<time::Time as std::ops::Sub<std::time::Duration>>::sub":["sub","Real(LocalPath(\"src/time.rs\"))","std::ops::Sub"],"<time::Time as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/time.rs\"))","std::ops::Sub"],"<time::Time as std::ops::SubAssign<duration::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"<time::Time as std::ops::SubAssign<std::time::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"<u64 as ext::NumericalStdDuration>::std_days":["std_days","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_hours":["std_hours","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_microseconds":["std_microseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_milliseconds":["std_milliseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_minutes":["std_minutes","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_nanoseconds":["std_nanoseconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_seconds":["std_seconds","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<u64 as ext::NumericalStdDuration>::std_weeks":["std_weeks","Real(LocalPath(\"src/ext.rs\"))","ext::NumericalStdDuration"],"<utc_offset::UtcOffset as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/utc_offset.rs\"))","std::fmt::Display"],"<utc_offset::UtcOffset as std::ops::Neg>::neg":["neg","Real(LocalPath(\"src/utc_offset.rs\"))","std::ops::Neg"],"<weekday::Weekday as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/weekday.rs\"))","std::fmt::Display"],"date::Date::__from_ordinal_date_unchecked":["__from_ordinal_date_unchecked","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::checked_add":["checked_add","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::checked_sub":["checked_sub","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::day":["day","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::from_calendar_date":["from_calendar_date","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::from_iso_week_date":["from_iso_week_date","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::from_julian_day":["from_julian_day","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::from_julian_day_unchecked":["from_julian_day_unchecked","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::from_ordinal_date":["from_ordinal_date","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::iso_week":["iso_week","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::iso_year_week":["iso_year_week","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::midnight":["midnight","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::monday_based_week":["monday_based_week","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::month":["month","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::month_day":["month_day","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::next_day":["next_day","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::ordinal":["ordinal","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::previous_day":["previous_day","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::saturating_add":["saturating_add","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::saturating_sub":["saturating_sub","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::sunday_based_week":["sunday_based_week","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::to_calendar_date":["to_calendar_date","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::to_iso_week_date":["to_iso_week_date","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::to_julian_day":["to_julian_day","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::to_ordinal_date":["to_ordinal_date","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::weekday":["weekday","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::with_hms":["with_hms","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::with_hms_micro":["with_hms_micro","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::with_hms_milli":["with_hms_milli","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::with_hms_nano":["with_hms_nano","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::with_time":["with_time","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::year":["year","Real(LocalPath(\"src/date.rs\"))",""],"duration::<impl std::cmp::PartialEq<duration::Duration> for std::time::Duration>::eq":["eq","Real(LocalPath(\"src/duration.rs\"))","std::cmp::PartialEq"],"duration::<impl std::cmp::PartialOrd<duration::Duration> for std::time::Duration>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/duration.rs\"))","std::cmp::PartialOrd"],"duration::<impl std::convert::TryFrom<duration::Duration> for std::time::Duration>::try_from":["try_from","Real(LocalPath(\"src/duration.rs\"))","std::convert::TryFrom"],"duration::<impl std::ops::Add<duration::Duration> for std::time::Duration>::add":["add","Real(LocalPath(\"src/duration.rs\"))","std::ops::Add"],"duration::<impl std::ops::Div<duration::Duration> for std::time::Duration>::div":["div","Real(LocalPath(\"src/duration.rs\"))","std::ops::Div"],"duration::<impl std::ops::Mul<duration::Duration> for f32>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for f64>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for i16>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for i32>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for i8>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for u16>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for u32>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Mul<duration::Duration> for u8>::mul":["mul","Real(LocalPath(\"src/duration.rs\"))","std::ops::Mul"],"duration::<impl std::ops::Sub<duration::Duration> for std::time::Duration>::sub":["sub","Real(LocalPath(\"src/duration.rs\"))","std::ops::Sub"],"duration::<impl std::ops::SubAssign<duration::Duration> for std::time::Duration>::sub_assign":["sub_assign","Real(LocalPath(\"src/duration.rs\"))","std::ops::SubAssign"],"duration::Duration::abs":["abs","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::abs_std":["abs_std","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::as_seconds_f32":["as_seconds_f32","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::as_seconds_f64":["as_seconds_f64","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::checked_add":["checked_add","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::checked_div":["checked_div","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::checked_mul":["checked_mul","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::checked_sub":["checked_sub","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::days":["days","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::hours":["hours","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::is_negative":["is_negative","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::is_positive":["is_positive","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::is_zero":["is_zero","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::microseconds":["microseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::milliseconds":["milliseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::minutes":["minutes","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::nanoseconds":["nanoseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::nanoseconds_i128":["nanoseconds_i128","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::new":["new","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::new_unchecked":["new_unchecked","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::saturating_add":["saturating_add","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::saturating_mul":["saturating_mul","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::saturating_sub":["saturating_sub","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::seconds":["seconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::seconds_f32":["seconds_f32","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::seconds_f64":["seconds_f64","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::subsec_microseconds":["subsec_microseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::subsec_milliseconds":["subsec_milliseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::subsec_nanoseconds":["subsec_nanoseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::time_fn":["time_fn","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::weeks":["weeks","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_days":["whole_days","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_hours":["whole_hours","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_microseconds":["whole_microseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_milliseconds":["whole_milliseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_minutes":["whole_minutes","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_nanoseconds":["whole_nanoseconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_seconds":["whole_seconds","Real(LocalPath(\"src/duration.rs\"))",""],"duration::Duration::whole_weeks":["whole_weeks","Real(LocalPath(\"src/duration.rs\"))",""],"error::component_range::<impl std::convert::From<error::component_range::ComponentRange> for error::Error>::from":["from","Real(LocalPath(\"src/error/component_range.rs\"))","std::convert::From"],"error::component_range::ComponentRange::name":["name","Real(LocalPath(\"src/error/component_range.rs\"))",""],"error::conversion_range::<impl std::convert::From<error::conversion_range::ConversionRange> for error::Error>::from":["from","Real(LocalPath(\"src/error/conversion_range.rs\"))","std::convert::From"],"error::different_variant::<impl std::convert::From<error::different_variant::DifferentVariant> for error::Error>::from":["from","Real(LocalPath(\"src/error/different_variant.rs\"))","std::convert::From"],"instant::<impl std::cmp::PartialEq<instant::Instant> for std::time::Instant>::eq":["eq","Real(LocalPath(\"src/instant.rs\"))","std::cmp::PartialEq"],"instant::<impl std::cmp::PartialOrd<instant::Instant> for std::time::Instant>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/instant.rs\"))","std::cmp::PartialOrd"],"instant::<impl std::convert::From<instant::Instant> for std::time::Instant>::from":["from","Real(LocalPath(\"src/instant.rs\"))","std::convert::From"],"instant::<impl std::ops::Add<duration::Duration> for std::time::Instant>::add":["add","Real(LocalPath(\"src/instant.rs\"))","std::ops::Add"],"instant::<impl std::ops::AddAssign<duration::Duration> for std::time::Instant>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"instant::<impl std::ops::Sub<duration::Duration> for std::time::Instant>::sub":["sub","Real(LocalPath(\"src/instant.rs\"))","std::ops::Sub"],"instant::<impl std::ops::Sub<instant::Instant> for std::time::Instant>::sub":["sub","Real(LocalPath(\"src/instant.rs\"))","std::ops::Sub"],"instant::<impl std::ops::SubAssign<duration::Duration> for std::time::Instant>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"instant::Instant::checked_add":["checked_add","Real(LocalPath(\"src/instant.rs\"))",""],"instant::Instant::checked_sub":["checked_sub","Real(LocalPath(\"src/instant.rs\"))",""],"instant::Instant::elapsed":["elapsed","Real(LocalPath(\"src/instant.rs\"))",""],"instant::Instant::into_inner":["into_inner","Real(LocalPath(\"src/instant.rs\"))",""],"instant::Instant::now":["now","Real(LocalPath(\"src/instant.rs\"))",""],"month::<impl std::convert::From<month::Month> for u8>::from":["from","Real(LocalPath(\"src/month.rs\"))","std::convert::From"],"month::Month::from_number":["from_number","Real(LocalPath(\"src/month.rs\"))",""],"month::Month::next":["next","Real(LocalPath(\"src/month.rs\"))",""],"month::Month::previous":["previous","Real(LocalPath(\"src/month.rs\"))",""],"offset_date_time::<impl std::cmp::PartialEq<offset_date_time::OffsetDateTime> for std::time::SystemTime>::eq":["eq","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::PartialEq"],"offset_date_time::<impl std::cmp::PartialOrd<offset_date_time::OffsetDateTime> for std::time::SystemTime>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/offset_date_time.rs\"))","std::cmp::PartialOrd"],"offset_date_time::<impl std::convert::From<offset_date_time::OffsetDateTime> for std::time::SystemTime>::from":["from","Real(LocalPath(\"src/offset_date_time.rs\"))","std::convert::From"],"offset_date_time::<impl std::ops::Add<duration::Duration> for std::time::SystemTime>::add":["add","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Add"],"offset_date_time::<impl std::ops::AddAssign<duration::Duration> for std::time::SystemTime>::add_assign":["add_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::AddAssign"],"offset_date_time::<impl std::ops::Sub<duration::Duration> for std::time::SystemTime>::sub":["sub","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Sub"],"offset_date_time::<impl std::ops::Sub<offset_date_time::OffsetDateTime> for std::time::SystemTime>::sub":["sub","Real(LocalPath(\"src/offset_date_time.rs\"))","std::ops::Sub"],"offset_date_time::<impl std::ops::SubAssign<duration::Duration> for std::time::SystemTime>::sub_assign":["sub_assign","Real(LocalPath(\"src/lib.rs\"))","std::ops::SubAssign"],"offset_date_time::OffsetDateTime::checked_add":["checked_add","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::checked_sub":["checked_sub","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::date":["date","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::day":["day","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::from_unix_timestamp":["from_unix_timestamp","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::from_unix_timestamp_nanos":["from_unix_timestamp_nanos","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::hour":["hour","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::iso_week":["iso_week","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::microsecond":["microsecond","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::millisecond":["millisecond","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::minute":["minute","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::monday_based_week":["monday_based_week","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::month":["month","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::nanosecond":["nanosecond","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::now_utc":["now_utc","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::offset":["offset","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::ordinal":["ordinal","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::replace_date":["replace_date","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::replace_date_time":["replace_date_time","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::replace_offset":["replace_offset","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::replace_time":["replace_time","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::saturating_add":["saturating_add","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::saturating_sub":["saturating_sub","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::second":["second","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::sunday_based_week":["sunday_based_week","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::time":["time","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::to_calendar_date":["to_calendar_date","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::to_hms":["to_hms","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::to_hms_micro":["to_hms_micro","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::to_hms_milli":["to_hms_milli","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::to_hms_nano":["to_hms_nano","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::to_iso_week_date":["to_iso_week_date","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::to_julian_day":["to_julian_day","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::to_offset":["to_offset","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::to_ordinal_date":["to_ordinal_date","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::unix_timestamp":["unix_timestamp","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::unix_timestamp_nanos":["unix_timestamp_nanos","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::weekday":["weekday","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"offset_date_time::OffsetDateTime::year":["year","Real(LocalPath(\"src/offset_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::as_hms":["as_hms","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::as_hms_micro":["as_hms_micro","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::as_hms_milli":["as_hms_milli","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::as_hms_nano":["as_hms_nano","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::assume_offset":["assume_offset","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::assume_utc":["assume_utc","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::checked_add":["checked_add","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::checked_sub":["checked_sub","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::date":["date","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::day":["day","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::hour":["hour","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::iso_week":["iso_week","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::microsecond":["microsecond","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::millisecond":["millisecond","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::minute":["minute","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::monday_based_week":["monday_based_week","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::month":["month","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::nanosecond":["nanosecond","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::new":["new","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::offset_to_utc":["offset_to_utc","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::ordinal":["ordinal","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::replace_date":["replace_date","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::replace_time":["replace_time","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::saturating_add":["saturating_add","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::saturating_sub":["saturating_sub","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::second":["second","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::sunday_based_week":["sunday_based_week","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::time":["time","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::to_calendar_date":["to_calendar_date","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::to_iso_week_date":["to_iso_week_date","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::to_julian_day":["to_julian_day","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::to_ordinal_date":["to_ordinal_date","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::utc_to_offset":["utc_to_offset","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::weekday":["weekday","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"primitive_date_time::PrimitiveDateTime::year":["year","Real(LocalPath(\"src/primitive_date_time.rs\"))",""],"time::Time::__from_hms_nanos_unchecked":["__from_hms_nanos_unchecked","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::adjusting_add":["adjusting_add","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::adjusting_add_std":["adjusting_add_std","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::adjusting_sub":["adjusting_sub","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::adjusting_sub_std":["adjusting_sub_std","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::as_hms":["as_hms","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::as_hms_micro":["as_hms_micro","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::as_hms_milli":["as_hms_milli","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::as_hms_nano":["as_hms_nano","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::from_hms":["from_hms","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::from_hms_micro":["from_hms_micro","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::from_hms_milli":["from_hms_milli","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::from_hms_nano":["from_hms_nano","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::hour":["hour","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::microsecond":["microsecond","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::millisecond":["millisecond","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::minute":["minute","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::nanosecond":["nanosecond","Real(LocalPath(\"src/time.rs\"))",""],"time::Time::second":["second","Real(LocalPath(\"src/time.rs\"))",""],"utc_offset::UtcOffset::__from_hms_unchecked":["__from_hms_unchecked","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::as_hms":["as_hms","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::from_hms":["from_hms","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::from_whole_seconds":["from_whole_seconds","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::is_negative":["is_negative","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::is_positive":["is_positive","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::is_utc":["is_utc","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::minutes_past_hour":["minutes_past_hour","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::seconds_past_minute":["seconds_past_minute","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::whole_hours":["whole_hours","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::whole_minutes":["whole_minutes","Real(LocalPath(\"src/utc_offset.rs\"))",""],"utc_offset::UtcOffset::whole_seconds":["whole_seconds","Real(LocalPath(\"src/utc_offset.rs\"))",""],"util::days_in_year":["days_in_year","Real(LocalPath(\"src/util.rs\"))",""],"util::days_in_year_month":["days_in_year_month","Real(LocalPath(\"src/util.rs\"))",""],"util::is_leap_year":["is_leap_year","Real(LocalPath(\"src/util.rs\"))",""],"util::weeks_in_year":["weeks_in_year","Real(LocalPath(\"src/util.rs\"))",""],"weekday::Weekday::next":["next","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::number_days_from_monday":["number_days_from_monday","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::number_days_from_sunday":["number_days_from_sunday","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::number_from_monday":["number_from_monday","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::number_from_sunday":["number_from_sunday","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::previous":["previous","Real(LocalPath(\"src/weekday.rs\"))",""]},"trait_to_struct":{"std::borrow::Borrow":["instant::Instant"],"std::clone::Clone":["date::Date","duration::Duration","duration::Padding","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","instant::Instant","month::Month","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::cmp::Eq":["date::Date","duration::Duration","duration::Padding","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","instant::Instant","month::Month","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::cmp::Ord":["date::Date","duration::Duration","duration::Padding","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset"],"std::cmp::PartialEq":["date::Date","duration::Duration","duration::Padding","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","instant::Instant","month::Month","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","std::time::Instant","std::time::SystemTime","time::Padding","time::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::cmp::PartialOrd":["date::Date","duration::Duration","duration::Padding","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","std::time::Instant","std::time::SystemTime","time::Padding","time::Time","utc_offset::UtcOffset"],"std::convert::AsRef":["instant::Instant"],"std::convert::From":["error::Error","instant::Instant","offset_date_time::OffsetDateTime","std::time::Instant","std::time::SystemTime"],"std::convert::TryFrom":["duration::Duration","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","month::Month","std::time::Duration"],"std::default::Default":["duration::Duration","duration::Padding"],"std::error::Error":["error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant"],"std::fmt::Debug":["date::Date","duration::Duration","duration::Padding","error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","instant::Instant","month::Month","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::fmt::Display":["date::Date","error::Error","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","month::Month","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::hash::Hash":["date::Date","duration::Duration","duration::Padding","error::component_range::ComponentRange","instant::Instant","month::Month","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::iter::Sum":["duration::Duration"],"std::marker::Copy":["date::Date","duration::Duration","duration::Padding","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","instant::Instant","month::Month","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::marker::StructuralEq":["date::Date","duration::Duration","duration::Padding","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","instant::Instant","month::Month","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::marker::StructuralPartialEq":["date::Date","duration::Duration","duration::Padding","error::component_range::ComponentRange","error::conversion_range::ConversionRange","error::different_variant::DifferentVariant","instant::Instant","month::Month","primitive_date_time::PrimitiveDateTime","time::Padding","time::Time","utc_offset::UtcOffset","weekday::Weekday"],"std::ops::Add":["date::Date","duration::Duration","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","std::time::Instant","std::time::SystemTime","time::Time"],"std::ops::AddAssign":["date::Date","duration::Duration","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Instant","std::time::SystemTime","time::Time"],"std::ops::Div":["duration::Duration","std::time::Duration"],"std::ops::DivAssign":["duration::Duration"],"std::ops::Mul":["duration::Duration"],"std::ops::MulAssign":["duration::Duration"],"std::ops::Neg":["duration::Duration","utc_offset::UtcOffset"],"std::ops::Sub":["date::Date","duration::Duration","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","std::time::Instant","std::time::SystemTime","time::Time"],"std::ops::SubAssign":["date::Date","duration::Duration","instant::Instant","offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime","std::time::Duration","std::time::Instant","std::time::SystemTime","time::Time"]},"type_to_def_path":{"date::Date":"date::Date","duration::Duration":"duration::Duration","duration::Padding":"duration::Padding","error::Error":"error::Error","error::component_range::ComponentRange":"error::component_range::ComponentRange","error::conversion_range::ConversionRange":"error::conversion_range::ConversionRange","error::different_variant::DifferentVariant":"error::different_variant::DifferentVariant","instant::Instant":"instant::Instant","month::Month":"month::Month","offset_date_time::OffsetDateTime":"offset_date_time::OffsetDateTime","primitive_date_time::PrimitiveDateTime":"primitive_date_time::PrimitiveDateTime","time::Padding":"time::Padding","time::Time":"time::Time","utc_offset::UtcOffset":"utc_offset::UtcOffset","util::DateAdjustment":"util::DateAdjustment","weekday::Weekday":"weekday::Weekday"}}