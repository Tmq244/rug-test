-----------------
src/util.rs util::days_in_year_month
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Month
+util::days_in_year_month(p0, p1);
+crate::util::days_in_year_month(p0, p1);
+crate::util::days_in_year_month(p0, p1);
-----------------
src/util.rs util::is_leap_year
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+util::is_leap_year(p0);
+crate::util::is_leap_year(p0);
+crate::util::is_leap_year(p0);
-----------------
src/util.rs util::days_in_year
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+util::days_in_year(p0);
+crate::util::days_in_year(p0);
+crate::util::days_in_year(p0);
-----------------
src/util.rs util::weeks_in_year
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+util::weeks_in_year(p0);
+crate::util::weeks_in_year(p0);
+crate::util::weeks_in_year(p0);
-----------------
src/ext.rs ext::NumericalDuration::nanoseconds
deps:{"ext::NumericalDuration::nanoseconds":{"Self":["ext::sealed::Sealed","ext::NumericalDuration"]}}
candidates:{"ext::NumericalDuration::nanoseconds":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.nanoseconds();
+ext::NumericalDuration::nanoseconds(p0);
+crate::ext::NumericalDuration::nanoseconds(p0);
+crate::ext::NumericalDuration::nanoseconds(p0);
-----------------
src/ext.rs ext::NumericalDuration::microseconds
deps:{"ext::NumericalDuration::microseconds":{"Self":["ext::NumericalDuration","ext::sealed::Sealed"]}}
candidates:{"ext::NumericalDuration::microseconds":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.microseconds();
+ext::NumericalDuration::microseconds(p0);
+crate::ext::NumericalDuration::microseconds(p0);
+crate::ext::NumericalDuration::microseconds(p0);
-----------------
src/ext.rs ext::NumericalDuration::milliseconds
deps:{"ext::NumericalDuration::milliseconds":{"Self":["ext::NumericalDuration","ext::sealed::Sealed"]}}
candidates:{"ext::NumericalDuration::milliseconds":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.milliseconds();
+ext::NumericalDuration::milliseconds(p0);
+crate::ext::NumericalDuration::milliseconds(p0);
+crate::ext::NumericalDuration::milliseconds(p0);
-----------------
src/ext.rs ext::NumericalDuration::seconds
deps:{"ext::NumericalDuration::seconds":{"Self":["ext::sealed::Sealed","ext::NumericalDuration"]}}
candidates:{"ext::NumericalDuration::seconds":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.seconds();
+ext::NumericalDuration::seconds(p0);
+crate::ext::NumericalDuration::seconds(p0);
+crate::ext::NumericalDuration::seconds(p0);
-----------------
src/ext.rs ext::NumericalDuration::minutes
deps:{"ext::NumericalDuration::minutes":{"Self":["ext::NumericalDuration","ext::sealed::Sealed"]}}
candidates:{"ext::NumericalDuration::minutes":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.minutes();
+ext::NumericalDuration::minutes(p0);
+crate::ext::NumericalDuration::minutes(p0);
+crate::ext::NumericalDuration::minutes(p0);
-----------------
src/ext.rs ext::NumericalDuration::hours
deps:{"ext::NumericalDuration::hours":{"Self":["ext::sealed::Sealed","ext::NumericalDuration"]}}
candidates:{"ext::NumericalDuration::hours":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.hours();
+ext::NumericalDuration::hours(p0);
+crate::ext::NumericalDuration::hours(p0);
+crate::ext::NumericalDuration::hours(p0);
-----------------
src/ext.rs ext::NumericalDuration::days
deps:{"ext::NumericalDuration::days":{"Self":["ext::NumericalDuration","ext::sealed::Sealed"]}}
candidates:{"ext::NumericalDuration::days":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.days();
+ext::NumericalDuration::days(p0);
+crate::ext::NumericalDuration::days(p0);
+crate::ext::NumericalDuration::days(p0);
-----------------
src/ext.rs ext::NumericalDuration::weeks
deps:{"ext::NumericalDuration::weeks":{"Self":["ext::NumericalDuration","ext::sealed::Sealed"]}}
candidates:{"ext::NumericalDuration::weeks":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.weeks();
+ext::NumericalDuration::weeks(p0);
+crate::ext::NumericalDuration::weeks(p0);
+crate::ext::NumericalDuration::weeks(p0);
-----------------
src/ext.rs ext::NumericalStdDuration::std_nanoseconds
deps:{"ext::NumericalStdDuration::std_nanoseconds":{"Self":["ext::NumericalStdDuration","ext::sealed::Sealed"]}}
candidates:{"ext::NumericalStdDuration::std_nanoseconds":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.std_nanoseconds();
+ext::NumericalStdDuration::std_nanoseconds(p0);
+crate::ext::NumericalStdDuration::std_nanoseconds(p0);
+crate::ext::NumericalStdDuration::std_nanoseconds(p0);
-----------------
src/ext.rs ext::NumericalStdDuration::std_microseconds
deps:{"ext::NumericalStdDuration::std_microseconds":{"Self":["ext::sealed::Sealed","ext::NumericalStdDuration"]}}
candidates:{"ext::NumericalStdDuration::std_microseconds":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.std_microseconds();
+ext::NumericalStdDuration::std_microseconds(p0);
+crate::ext::NumericalStdDuration::std_microseconds(p0);
+crate::ext::NumericalStdDuration::std_microseconds(p0);
-----------------
src/ext.rs ext::NumericalStdDuration::std_milliseconds
deps:{"ext::NumericalStdDuration::std_milliseconds":{"Self":["ext::sealed::Sealed","ext::NumericalStdDuration"]}}
candidates:{"ext::NumericalStdDuration::std_milliseconds":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.std_milliseconds();
+ext::NumericalStdDuration::std_milliseconds(p0);
+crate::ext::NumericalStdDuration::std_milliseconds(p0);
+crate::ext::NumericalStdDuration::std_milliseconds(p0);
-----------------
src/ext.rs ext::NumericalStdDuration::std_seconds
deps:{"ext::NumericalStdDuration::std_seconds":{"Self":["ext::sealed::Sealed","ext::NumericalStdDuration"]}}
candidates:{"ext::NumericalStdDuration::std_seconds":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.std_seconds();
+ext::NumericalStdDuration::std_seconds(p0);
+crate::ext::NumericalStdDuration::std_seconds(p0);
+crate::ext::NumericalStdDuration::std_seconds(p0);
-----------------
src/ext.rs ext::NumericalStdDuration::std_minutes
deps:{"ext::NumericalStdDuration::std_minutes":{"Self":["ext::sealed::Sealed","ext::NumericalStdDuration"]}}
candidates:{"ext::NumericalStdDuration::std_minutes":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.std_minutes();
+ext::NumericalStdDuration::std_minutes(p0);
+crate::ext::NumericalStdDuration::std_minutes(p0);
+crate::ext::NumericalStdDuration::std_minutes(p0);
-----------------
src/ext.rs ext::NumericalStdDuration::std_hours
deps:{"ext::NumericalStdDuration::std_hours":{"Self":["ext::sealed::Sealed","ext::NumericalStdDuration"]}}
candidates:{"ext::NumericalStdDuration::std_hours":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.std_hours();
+ext::NumericalStdDuration::std_hours(p0);
+crate::ext::NumericalStdDuration::std_hours(p0);
+crate::ext::NumericalStdDuration::std_hours(p0);
-----------------
src/ext.rs ext::NumericalStdDuration::std_days
deps:{"ext::NumericalStdDuration::std_days":{"Self":["ext::sealed::Sealed","ext::NumericalStdDuration"]}}
candidates:{"ext::NumericalStdDuration::std_days":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.std_days();
+ext::NumericalStdDuration::std_days(p0);
+crate::ext::NumericalStdDuration::std_days(p0);
+crate::ext::NumericalStdDuration::std_days(p0);
-----------------
src/ext.rs ext::NumericalStdDuration::std_weeks
deps:{"ext::NumericalStdDuration::std_weeks":{"Self":["ext::sealed::Sealed","ext::NumericalStdDuration"]}}
candidates:{"ext::NumericalStdDuration::std_weeks":{"Self":[]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // Self
+p0.std_weeks();
+ext::NumericalStdDuration::std_weeks(p0);
+crate::ext::NumericalStdDuration::std_weeks(p0);
+crate::ext::NumericalStdDuration::std_weeks(p0);
-----------------
src/date.rs <date::Date as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date
+p0.clone();
+<date::Date as std::clone::Clone>::clone(p0);
+crate::<date::Date as std::clone::Clone>::clone(p0);
+<date::Date>::clone(p0);
-----------------
src/date.rs <date::Date as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = & MaybeUninit::uninit().assume_init(); // date::Date
+p0.eq(p1);
+<date::Date as std::cmp::PartialEq>::eq(p0, p1);
+crate::<date::Date as std::cmp::PartialEq>::eq(p0, p1);
+<date::Date>::eq(p0, p1);
-----------------
src/date.rs <date::Date as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date
+p0.assert_receiver_is_total_eq();
+<date::Date as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<date::Date as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<date::Date>::assert_receiver_is_total_eq(p0);
-----------------
src/date.rs <date::Date as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<date::Date as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<date::Date as std::hash::Hash>::hash":{"__H":["std::boxed::Box<T, A>","std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<date::Date as std::hash::Hash>::hash(p0, p1);
+crate::<date::Date as std::hash::Hash>::hash(p0, p1);
+<date::Date>::hash(p0, p1);
-----------------
src/date.rs <date::Date as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = & MaybeUninit::uninit().assume_init(); // date::Date
+p0.partial_cmp(p1);
+<date::Date as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<date::Date as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<date::Date>::partial_cmp(p0, p1);
-----------------
src/date.rs <date::Date as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = & MaybeUninit::uninit().assume_init(); // date::Date
+p0.cmp(p1);
+<date::Date as std::cmp::Ord>::cmp(p0, p1);
+crate::<date::Date as std::cmp::Ord>::cmp(p0, p1);
+<date::Date>::cmp(p0, p1);
-----------------
src/date.rs <date::Date as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<date::Date as std::fmt::Debug>::fmt(p0, p1);
+crate::<date::Date as std::fmt::Debug>::fmt(p0, p1);
+<date::Date>::fmt(p0, p1);
-----------------
src/date.rs date::Date::__from_ordinal_date_unchecked
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u16; // None+u16
+date::Date::__from_ordinal_date_unchecked(p0, p1);
+crate::date::Date::__from_ordinal_date_unchecked(p0, p1);
+<date::Date>::__from_ordinal_date_unchecked(p0, p1);
-----------------
src/date.rs date::Date::from_calendar_date
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = MaybeUninit::uninit().assume_init(); // month::Month
let mut p2 = 0u8; // None+u8
+date::Date::from_calendar_date(p0, p1, p2);
+crate::date::Date::from_calendar_date(p0, p1, p2);
+<date::Date>::from_calendar_date(p0, p1, p2);
-----------------
src/date.rs date::Date::from_ordinal_date
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u16; // None+u16
+date::Date::from_ordinal_date(p0, p1);
+crate::date::Date::from_ordinal_date(p0, p1);
+<date::Date>::from_ordinal_date(p0, p1);
-----------------
src/date.rs date::Date::from_iso_week_date
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = 0u8; // None+u8
let mut p2 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+date::Date::from_iso_week_date(p0, p1, p2);
+crate::date::Date::from_iso_week_date(p0, p1, p2);
+<date::Date>::from_iso_week_date(p0, p1, p2);
-----------------
src/date.rs date::Date::from_julian_day
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+date::Date::from_julian_day(p0);
+crate::date::Date::from_julian_day(p0);
+<date::Date>::from_julian_day(p0);
-----------------
src/date.rs date::Date::from_julian_day_unchecked
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+date::Date::from_julian_day_unchecked(p0);
+crate::date::Date::from_julian_day_unchecked(p0);
+<date::Date>::from_julian_day_unchecked(p0);
-----------------
src/date.rs date::Date::year
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.year();
+date::Date::year(p0);
+crate::date::Date::year(p0);
+<date::Date>::year(p0);
-----------------
src/date.rs date::Date::month
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.month();
+date::Date::month(p0);
+crate::date::Date::month(p0);
+<date::Date>::month(p0);
-----------------
src/date.rs date::Date::day
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.day();
+date::Date::day(p0);
+crate::date::Date::day(p0);
+<date::Date>::day(p0);
-----------------
src/date.rs date::Date::month_day
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.month_day();
+date::Date::month_day(p0);
+crate::date::Date::month_day(p0);
+<date::Date>::month_day(p0);
-----------------
src/date.rs date::Date::ordinal
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.ordinal();
+date::Date::ordinal(p0);
+crate::date::Date::ordinal(p0);
+<date::Date>::ordinal(p0);
-----------------
src/date.rs date::Date::iso_year_week
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.iso_year_week();
+date::Date::iso_year_week(p0);
+crate::date::Date::iso_year_week(p0);
+<date::Date>::iso_year_week(p0);
-----------------
src/date.rs date::Date::iso_week
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.iso_week();
+date::Date::iso_week(p0);
+crate::date::Date::iso_week(p0);
+<date::Date>::iso_week(p0);
-----------------
src/date.rs date::Date::sunday_based_week
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.sunday_based_week();
+date::Date::sunday_based_week(p0);
+crate::date::Date::sunday_based_week(p0);
+<date::Date>::sunday_based_week(p0);
-----------------
src/date.rs date::Date::monday_based_week
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.monday_based_week();
+date::Date::monday_based_week(p0);
+crate::date::Date::monday_based_week(p0);
+<date::Date>::monday_based_week(p0);
-----------------
src/date.rs date::Date::to_calendar_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.to_calendar_date();
+date::Date::to_calendar_date(p0);
+crate::date::Date::to_calendar_date(p0);
+<date::Date>::to_calendar_date(p0);
-----------------
src/date.rs date::Date::to_ordinal_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.to_ordinal_date();
+date::Date::to_ordinal_date(p0);
+crate::date::Date::to_ordinal_date(p0);
+<date::Date>::to_ordinal_date(p0);
-----------------
src/date.rs date::Date::to_iso_week_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.to_iso_week_date();
+date::Date::to_iso_week_date(p0);
+crate::date::Date::to_iso_week_date(p0);
+<date::Date>::to_iso_week_date(p0);
-----------------
src/date.rs date::Date::weekday
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.weekday();
+date::Date::weekday(p0);
+crate::date::Date::weekday(p0);
+<date::Date>::weekday(p0);
-----------------
src/date.rs date::Date::next_day
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.next_day();
+date::Date::next_day(p0);
+crate::date::Date::next_day(p0);
+<date::Date>::next_day(p0);
-----------------
src/date.rs date::Date::previous_day
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.previous_day();
+date::Date::previous_day(p0);
+crate::date::Date::previous_day(p0);
+<date::Date>::previous_day(p0);
-----------------
src/date.rs date::Date::to_julian_day
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.to_julian_day();
+date::Date::to_julian_day(p0);
+crate::date::Date::to_julian_day(p0);
+<date::Date>::to_julian_day(p0);
-----------------
src/date.rs date::Date::checked_add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.checked_add(p1);
+date::Date::checked_add(p0, p1);
+crate::date::Date::checked_add(p0, p1);
+<date::Date>::checked_add(p0, p1);
-----------------
src/date.rs date::Date::checked_sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.checked_sub(p1);
+date::Date::checked_sub(p0, p1);
+crate::date::Date::checked_sub(p0, p1);
+<date::Date>::checked_sub(p0, p1);
-----------------
src/date.rs date::Date::saturating_add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.saturating_add(p1);
+date::Date::saturating_add(p0, p1);
+crate::date::Date::saturating_add(p0, p1);
+<date::Date>::saturating_add(p0, p1);
-----------------
src/date.rs date::Date::saturating_sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.saturating_sub(p1);
+date::Date::saturating_sub(p0, p1);
+crate::date::Date::saturating_sub(p0, p1);
+<date::Date>::saturating_sub(p0, p1);
-----------------
src/date.rs date::Date::midnight
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.midnight();
+date::Date::midnight(p0);
+crate::date::Date::midnight(p0);
+<date::Date>::midnight(p0);
-----------------
src/date.rs date::Date::with_time
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.with_time(p1);
+date::Date::with_time(p0, p1);
+crate::date::Date::with_time(p0, p1);
+<date::Date>::with_time(p0, p1);
-----------------
src/date.rs date::Date::with_hms
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
let mut p3 = 0u8; // None+u8
+p0.with_hms(p1, p2, p3);
+date::Date::with_hms(p0, p1, p2, p3);
+crate::date::Date::with_hms(p0, p1, p2, p3);
+<date::Date>::with_hms(p0, p1, p2, p3);
-----------------
src/date.rs date::Date::with_hms_milli
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
let mut p3 = 0u8; // None+u8
let mut p4 = 0u16; // None+u16
+p0.with_hms_milli(p1, p2, p3, p4);
+date::Date::with_hms_milli(p0, p1, p2, p3, p4);
+crate::date::Date::with_hms_milli(p0, p1, p2, p3, p4);
+<date::Date>::with_hms_milli(p0, p1, p2, p3, p4);
-----------------
src/date.rs date::Date::with_hms_micro
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
let mut p3 = 0u8; // None+u8
let mut p4 = 0u32; // None+u32
+p0.with_hms_micro(p1, p2, p3, p4);
+date::Date::with_hms_micro(p0, p1, p2, p3, p4);
+crate::date::Date::with_hms_micro(p0, p1, p2, p3, p4);
+<date::Date>::with_hms_micro(p0, p1, p2, p3, p4);
-----------------
src/date.rs date::Date::with_hms_nano
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
let mut p3 = 0u8; // None+u8
let mut p4 = 0u32; // None+u32
+p0.with_hms_nano(p1, p2, p3, p4);
+date::Date::with_hms_nano(p0, p1, p2, p3, p4);
+crate::date::Date::with_hms_nano(p0, p1, p2, p3, p4);
+<date::Date>::with_hms_nano(p0, p1, p2, p3, p4);
-----------------
src/date.rs <date::Date as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<date::Date as std::fmt::Display>::fmt(p0, p1);
+crate::<date::Date as std::fmt::Display>::fmt(p0, p1);
+<date::Date>::fmt(p0, p1);
-----------------
src/date.rs <date::Date as std::ops::Add<duration::Duration>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add(p1);
+<date::Date as std::ops::Add<duration::Duration>>::add(p0, p1);
+crate::<date::Date as std::ops::Add<duration::Duration>>::add(p0, p1);
+<date::Date>::add(p0, p1);
-----------------
src/date.rs <date::Date as std::ops::Add<std::time::Duration>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.add(p1);
+<date::Date as std::ops::Add<std::time::Duration>>::add(p0, p1);
+crate::<date::Date as std::ops::Add<std::time::Duration>>::add(p0, p1);
+<date::Date>::add(p0, p1);
-----------------
src/lib.rs <date::Date as std::ops::AddAssign<duration::Duration>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add_assign(p1);
+<date::Date as std::ops::AddAssign<duration::Duration>>::add_assign(p0, p1);
+crate::<date::Date as std::ops::AddAssign<duration::Duration>>::add_assign(p0, p1);
+<date::Date>::add_assign(p0, p1);
-----------------
src/lib.rs <date::Date as std::ops::AddAssign<std::time::Duration>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.add_assign(p1);
+<date::Date as std::ops::AddAssign<std::time::Duration>>::add_assign(p0, p1);
+crate::<date::Date as std::ops::AddAssign<std::time::Duration>>::add_assign(p0, p1);
+<date::Date>::add_assign(p0, p1);
-----------------
src/date.rs <date::Date as std::ops::Sub<duration::Duration>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub(p1);
+<date::Date as std::ops::Sub<duration::Duration>>::sub(p0, p1);
+crate::<date::Date as std::ops::Sub<duration::Duration>>::sub(p0, p1);
+<date::Date>::sub(p0, p1);
-----------------
src/date.rs <date::Date as std::ops::Sub<std::time::Duration>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.sub(p1);
+<date::Date as std::ops::Sub<std::time::Duration>>::sub(p0, p1);
+crate::<date::Date as std::ops::Sub<std::time::Duration>>::sub(p0, p1);
+<date::Date>::sub(p0, p1);
-----------------
src/lib.rs <date::Date as std::ops::SubAssign<duration::Duration>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub_assign(p1);
+<date::Date as std::ops::SubAssign<duration::Duration>>::sub_assign(p0, p1);
+crate::<date::Date as std::ops::SubAssign<duration::Duration>>::sub_assign(p0, p1);
+<date::Date>::sub_assign(p0, p1);
-----------------
src/lib.rs <date::Date as std::ops::SubAssign<std::time::Duration>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.sub_assign(p1);
+<date::Date as std::ops::SubAssign<std::time::Duration>>::sub_assign(p0, p1);
+crate::<date::Date as std::ops::SubAssign<std::time::Duration>>::sub_assign(p0, p1);
+<date::Date>::sub_assign(p0, p1);
-----------------
src/date.rs <date::Date as std::ops::Sub>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.sub(p1);
+<date::Date as std::ops::Sub>::sub(p0, p1);
+crate::<date::Date as std::ops::Sub>::sub(p0, p1);
+<date::Date>::sub(p0, p1);
-----------------
src/duration.rs <duration::Padding as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Padding
+p0.clone();
+<duration::Padding as std::clone::Clone>::clone(p0);
+crate::<duration::Padding as std::clone::Clone>::clone(p0);
+<duration::Padding>::clone(p0);
-----------------
src/duration.rs <duration::Padding as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Padding
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<duration::Padding as std::fmt::Debug>::fmt(p0, p1);
+crate::<duration::Padding as std::fmt::Debug>::fmt(p0, p1);
+<duration::Padding>::fmt(p0, p1);
-----------------
src/duration.rs <duration::Padding as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Padding
let mut p1 = & MaybeUninit::uninit().assume_init(); // duration::Padding
+p0.eq(p1);
+<duration::Padding as std::cmp::PartialEq>::eq(p0, p1);
+crate::<duration::Padding as std::cmp::PartialEq>::eq(p0, p1);
+<duration::Padding>::eq(p0, p1);
-----------------
src/duration.rs <duration::Padding as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Padding
+p0.assert_receiver_is_total_eq();
+<duration::Padding as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<duration::Padding as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<duration::Padding>::assert_receiver_is_total_eq(p0);
-----------------
src/duration.rs <duration::Padding as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<duration::Padding as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<duration::Padding as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::hash::sip::Hasher<S>","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Padding
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<duration::Padding as std::hash::Hash>::hash(p0, p1);
+crate::<duration::Padding as std::hash::Hash>::hash(p0, p1);
+<duration::Padding>::hash(p0, p1);
-----------------
src/duration.rs <duration::Padding as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Padding
let mut p1 = & MaybeUninit::uninit().assume_init(); // duration::Padding
+p0.partial_cmp(p1);
+<duration::Padding as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<duration::Padding as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<duration::Padding>::partial_cmp(p0, p1);
-----------------
src/duration.rs <duration::Padding as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Padding
let mut p1 = & MaybeUninit::uninit().assume_init(); // duration::Padding
+p0.cmp(p1);
+<duration::Padding as std::cmp::Ord>::cmp(p0, p1);
+crate::<duration::Padding as std::cmp::Ord>::cmp(p0, p1);
+<duration::Padding>::cmp(p0, p1);
-----------------
src/duration.rs <duration::Padding as std::default::Default>::default
deps:{}
candidates:{}
+<duration::Padding as std::default::Default>::default();
+crate::<duration::Padding as std::default::Default>::default();
+<duration::Padding>::default();
-----------------
src/duration.rs <duration::Duration as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.clone();
+<duration::Duration as std::clone::Clone>::clone(p0);
+crate::<duration::Duration as std::clone::Clone>::clone(p0);
+<duration::Duration>::clone(p0);
-----------------
src/duration.rs <duration::Duration as std::default::Default>::default
deps:{}
candidates:{}
+<duration::Duration as std::default::Default>::default();
+crate::<duration::Duration as std::default::Default>::default();
+<duration::Duration>::default();
-----------------
src/duration.rs <duration::Duration as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = & MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.eq(p1);
+<duration::Duration as std::cmp::PartialEq>::eq(p0, p1);
+crate::<duration::Duration as std::cmp::PartialEq>::eq(p0, p1);
+<duration::Duration>::eq(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.assert_receiver_is_total_eq();
+<duration::Duration as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<duration::Duration as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<duration::Duration>::assert_receiver_is_total_eq(p0);
-----------------
src/duration.rs <duration::Duration as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<duration::Duration as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<duration::Duration as std::hash::Hash>::hash":{"__H":["std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::hash::SipHasher13","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<duration::Duration as std::hash::Hash>::hash(p0, p1);
+crate::<duration::Duration as std::hash::Hash>::hash(p0, p1);
+<duration::Duration>::hash(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = & MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.partial_cmp(p1);
+<duration::Duration as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<duration::Duration as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<duration::Duration>::partial_cmp(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = & MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.cmp(p1);
+<duration::Duration as std::cmp::Ord>::cmp(p0, p1);
+crate::<duration::Duration as std::cmp::Ord>::cmp(p0, p1);
+<duration::Duration>::cmp(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<duration::Duration as std::fmt::Debug>::fmt(p0, p1);
+crate::<duration::Duration as std::fmt::Debug>::fmt(p0, p1);
+<duration::Duration>::fmt(p0, p1);
-----------------
src/duration.rs duration::Duration::is_zero
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.is_zero();
+duration::Duration::is_zero(p0);
+crate::duration::Duration::is_zero(p0);
+<duration::Duration>::is_zero(p0);
-----------------
src/duration.rs duration::Duration::is_negative
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.is_negative();
+duration::Duration::is_negative(p0);
+crate::duration::Duration::is_negative(p0);
+<duration::Duration>::is_negative(p0);
-----------------
src/duration.rs duration::Duration::is_positive
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.is_positive();
+duration::Duration::is_positive(p0);
+crate::duration::Duration::is_positive(p0);
+<duration::Duration>::is_positive(p0);
-----------------
src/duration.rs duration::Duration::abs
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.abs();
+duration::Duration::abs(p0);
+crate::duration::Duration::abs(p0);
+<duration::Duration>::abs(p0);
-----------------
src/duration.rs duration::Duration::abs_std
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.abs_std();
+duration::Duration::abs_std(p0);
+crate::duration::Duration::abs_std(p0);
+<duration::Duration>::abs_std(p0);
-----------------
src/duration.rs duration::Duration::new_unchecked
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0i32; // None+i32
+duration::Duration::new_unchecked(p0, p1);
+crate::duration::Duration::new_unchecked(p0, p1);
+<duration::Duration>::new_unchecked(p0, p1);
-----------------
src/duration.rs duration::Duration::new
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
let mut p1 = 0i32; // None+i32
+duration::Duration::new(p0, p1);
+crate::duration::Duration::new(p0, p1);
+<duration::Duration>::new(p0, p1);
-----------------
src/duration.rs duration::Duration::weeks
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+duration::Duration::weeks(p0);
+crate::duration::Duration::weeks(p0);
+<duration::Duration>::weeks(p0);
-----------------
src/duration.rs duration::Duration::days
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+duration::Duration::days(p0);
+crate::duration::Duration::days(p0);
+<duration::Duration>::days(p0);
-----------------
src/duration.rs duration::Duration::hours
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+duration::Duration::hours(p0);
+crate::duration::Duration::hours(p0);
+<duration::Duration>::hours(p0);
-----------------
src/duration.rs duration::Duration::minutes
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+duration::Duration::minutes(p0);
+crate::duration::Duration::minutes(p0);
+<duration::Duration>::minutes(p0);
-----------------
src/duration.rs duration::Duration::seconds
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+duration::Duration::seconds(p0);
+crate::duration::Duration::seconds(p0);
+<duration::Duration>::seconds(p0);
-----------------
src/duration.rs duration::Duration::seconds_f64
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+duration::Duration::seconds_f64(p0);
+crate::duration::Duration::seconds_f64(p0);
+<duration::Duration>::seconds_f64(p0);
-----------------
src/duration.rs duration::Duration::seconds_f32
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
+duration::Duration::seconds_f32(p0);
+crate::duration::Duration::seconds_f32(p0);
+<duration::Duration>::seconds_f32(p0);
-----------------
src/duration.rs duration::Duration::milliseconds
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+duration::Duration::milliseconds(p0);
+crate::duration::Duration::milliseconds(p0);
+<duration::Duration>::milliseconds(p0);
-----------------
src/duration.rs duration::Duration::microseconds
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+duration::Duration::microseconds(p0);
+crate::duration::Duration::microseconds(p0);
+<duration::Duration>::microseconds(p0);
-----------------
src/duration.rs duration::Duration::nanoseconds
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+duration::Duration::nanoseconds(p0);
+crate::duration::Duration::nanoseconds(p0);
+<duration::Duration>::nanoseconds(p0);
-----------------
src/duration.rs duration::Duration::nanoseconds_i128
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+duration::Duration::nanoseconds_i128(p0);
+crate::duration::Duration::nanoseconds_i128(p0);
+<duration::Duration>::nanoseconds_i128(p0);
-----------------
src/duration.rs duration::Duration::whole_weeks
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.whole_weeks();
+duration::Duration::whole_weeks(p0);
+crate::duration::Duration::whole_weeks(p0);
+<duration::Duration>::whole_weeks(p0);
-----------------
src/duration.rs duration::Duration::whole_days
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.whole_days();
+duration::Duration::whole_days(p0);
+crate::duration::Duration::whole_days(p0);
+<duration::Duration>::whole_days(p0);
-----------------
src/duration.rs duration::Duration::whole_hours
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.whole_hours();
+duration::Duration::whole_hours(p0);
+crate::duration::Duration::whole_hours(p0);
+<duration::Duration>::whole_hours(p0);
-----------------
src/duration.rs duration::Duration::whole_minutes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.whole_minutes();
+duration::Duration::whole_minutes(p0);
+crate::duration::Duration::whole_minutes(p0);
+<duration::Duration>::whole_minutes(p0);
-----------------
src/duration.rs duration::Duration::whole_seconds
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.whole_seconds();
+duration::Duration::whole_seconds(p0);
+crate::duration::Duration::whole_seconds(p0);
+<duration::Duration>::whole_seconds(p0);
-----------------
src/duration.rs duration::Duration::as_seconds_f64
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.as_seconds_f64();
+duration::Duration::as_seconds_f64(p0);
+crate::duration::Duration::as_seconds_f64(p0);
+<duration::Duration>::as_seconds_f64(p0);
-----------------
src/duration.rs duration::Duration::as_seconds_f32
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.as_seconds_f32();
+duration::Duration::as_seconds_f32(p0);
+crate::duration::Duration::as_seconds_f32(p0);
+<duration::Duration>::as_seconds_f32(p0);
-----------------
src/duration.rs duration::Duration::whole_milliseconds
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.whole_milliseconds();
+duration::Duration::whole_milliseconds(p0);
+crate::duration::Duration::whole_milliseconds(p0);
+<duration::Duration>::whole_milliseconds(p0);
-----------------
src/duration.rs duration::Duration::subsec_milliseconds
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.subsec_milliseconds();
+duration::Duration::subsec_milliseconds(p0);
+crate::duration::Duration::subsec_milliseconds(p0);
+<duration::Duration>::subsec_milliseconds(p0);
-----------------
src/duration.rs duration::Duration::whole_microseconds
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.whole_microseconds();
+duration::Duration::whole_microseconds(p0);
+crate::duration::Duration::whole_microseconds(p0);
+<duration::Duration>::whole_microseconds(p0);
-----------------
src/duration.rs duration::Duration::subsec_microseconds
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.subsec_microseconds();
+duration::Duration::subsec_microseconds(p0);
+crate::duration::Duration::subsec_microseconds(p0);
+<duration::Duration>::subsec_microseconds(p0);
-----------------
src/duration.rs duration::Duration::whole_nanoseconds
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.whole_nanoseconds();
+duration::Duration::whole_nanoseconds(p0);
+crate::duration::Duration::whole_nanoseconds(p0);
+<duration::Duration>::whole_nanoseconds(p0);
-----------------
src/duration.rs duration::Duration::subsec_nanoseconds
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.subsec_nanoseconds();
+duration::Duration::subsec_nanoseconds(p0);
+crate::duration::Duration::subsec_nanoseconds(p0);
+<duration::Duration>::subsec_nanoseconds(p0);
-----------------
src/duration.rs duration::Duration::checked_add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.checked_add(p1);
+duration::Duration::checked_add(p0, p1);
+crate::duration::Duration::checked_add(p0, p1);
+<duration::Duration>::checked_add(p0, p1);
-----------------
src/duration.rs duration::Duration::checked_sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.checked_sub(p1);
+duration::Duration::checked_sub(p0, p1);
+crate::duration::Duration::checked_sub(p0, p1);
+<duration::Duration>::checked_sub(p0, p1);
-----------------
src/duration.rs duration::Duration::checked_mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i32; // None+i32
+p0.checked_mul(p1);
+duration::Duration::checked_mul(p0, p1);
+crate::duration::Duration::checked_mul(p0, p1);
+<duration::Duration>::checked_mul(p0, p1);
-----------------
src/duration.rs duration::Duration::checked_div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i32; // None+i32
+p0.checked_div(p1);
+duration::Duration::checked_div(p0, p1);
+crate::duration::Duration::checked_div(p0, p1);
+<duration::Duration>::checked_div(p0, p1);
-----------------
src/duration.rs duration::Duration::saturating_add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.saturating_add(p1);
+duration::Duration::saturating_add(p0, p1);
+crate::duration::Duration::saturating_add(p0, p1);
+<duration::Duration>::saturating_add(p0, p1);
-----------------
src/duration.rs duration::Duration::saturating_sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.saturating_sub(p1);
+duration::Duration::saturating_sub(p0, p1);
+crate::duration::Duration::saturating_sub(p0, p1);
+<duration::Duration>::saturating_sub(p0, p1);
-----------------
src/duration.rs duration::Duration::saturating_mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i32; // None+i32
+p0.saturating_mul(p1);
+duration::Duration::saturating_mul(p0, p1);
+crate::duration::Duration::saturating_mul(p0, p1);
+<duration::Duration>::saturating_mul(p0, p1);
-----------------
src/duration.rs duration::Duration::time_fn
deps:{"duration::Duration::time_fn":{"T":["std::marker::Sized"],"impl FnOnce() -> T":["std::ops::FnOnce","std::marker::Sized"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
candidates:{"duration::Duration::time_fn":{"T":["RUG_ANY"],"impl FnOnce() -> T":["core::const_closure::ConstFnMutClosure<&'a mut A, Function>","core::str::IsWhitespace","std::panic::AssertUnwindSafe<F>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B), Function>","core::str::CharEscapeUnicode","core::str::CharEscapeDebugContinue","core::str::LinesAnyMap","std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>","core::str::BytesIsNotEmpty","core::str::IsAsciiWhitespace","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D), Function>","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C, &'a mut D, &'a mut E), Function>","core::str::CharEscapeDefault","std::boxed::Box<F, A>","core::slice::ascii::EscapeByte","core::str::IsNotEmpty","core::str::UnsafeBytesToStr","core::const_closure::ConstFnMutClosure<(&'a mut A, &'a mut B, &'a mut C), Function>"]},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &F>":{},"std::ops::function::impls::<impl std::ops::FnOnce<A> for &mut F>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // impl FnOnce() -> T
+duration::Duration::time_fn(p0);
+crate::duration::Duration::time_fn(p0);
+<duration::Duration>::time_fn(p0);
-----------------
src/duration.rs <duration::Duration as std::convert::TryFrom<std::time::Duration>>::try_from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+<duration::Duration as std::convert::TryFrom<std::time::Duration>>::try_from(p0);
+crate::<duration::Duration as std::convert::TryFrom<std::time::Duration>>::try_from(p0);
+<duration::Duration>::try_from(p0);
-----------------
src/duration.rs duration::<impl std::convert::TryFrom<duration::Duration> for std::time::Duration>::try_from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+duration::<impl std::convert::TryFrom<duration::Duration> for std::time::Duration>::try_from(p0);
+crate::duration::<impl std::convert::TryFrom<duration::Duration> for std::time::Duration>::try_from(p0);
+<std::time::Duration>::try_from(p0);
-----------------
src/duration.rs <duration::Duration as std::ops::Add>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add(p1);
+<duration::Duration as std::ops::Add>::add(p0, p1);
+crate::<duration::Duration as std::ops::Add>::add(p0, p1);
+<duration::Duration>::add(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Add<std::time::Duration>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.add(p1);
+<duration::Duration as std::ops::Add<std::time::Duration>>::add(p0, p1);
+crate::<duration::Duration as std::ops::Add<std::time::Duration>>::add(p0, p1);
+<duration::Duration>::add(p0, p1);
-----------------
src/duration.rs duration::<impl std::ops::Add<duration::Duration> for std::time::Duration>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add(p1);
+duration::<impl std::ops::Add<duration::Duration> for std::time::Duration>::add(p0, p1);
+crate::duration::<impl std::ops::Add<duration::Duration> for std::time::Duration>::add(p0, p1);
+<std::time::Duration>::add(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::AddAssign>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add_assign(p1);
+<duration::Duration as std::ops::AddAssign>::add_assign(p0, p1);
+crate::<duration::Duration as std::ops::AddAssign>::add_assign(p0, p1);
+<duration::Duration>::add_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::AddAssign<std::time::Duration>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.add_assign(p1);
+<duration::Duration as std::ops::AddAssign<std::time::Duration>>::add_assign(p0, p1);
+crate::<duration::Duration as std::ops::AddAssign<std::time::Duration>>::add_assign(p0, p1);
+<duration::Duration>::add_assign(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Neg>::neg
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.neg();
+<duration::Duration as std::ops::Neg>::neg(p0);
+crate::<duration::Duration as std::ops::Neg>::neg(p0);
+<duration::Duration>::neg(p0);
-----------------
src/duration.rs <duration::Duration as std::ops::Sub>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub(p1);
+<duration::Duration as std::ops::Sub>::sub(p0, p1);
+crate::<duration::Duration as std::ops::Sub>::sub(p0, p1);
+<duration::Duration>::sub(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Sub<std::time::Duration>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.sub(p1);
+<duration::Duration as std::ops::Sub<std::time::Duration>>::sub(p0, p1);
+crate::<duration::Duration as std::ops::Sub<std::time::Duration>>::sub(p0, p1);
+<duration::Duration>::sub(p0, p1);
-----------------
src/duration.rs duration::<impl std::ops::Sub<duration::Duration> for std::time::Duration>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub(p1);
+duration::<impl std::ops::Sub<duration::Duration> for std::time::Duration>::sub(p0, p1);
+crate::duration::<impl std::ops::Sub<duration::Duration> for std::time::Duration>::sub(p0, p1);
+<std::time::Duration>::sub(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::SubAssign>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub_assign(p1);
+<duration::Duration as std::ops::SubAssign>::sub_assign(p0, p1);
+crate::<duration::Duration as std::ops::SubAssign>::sub_assign(p0, p1);
+<duration::Duration>::sub_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::SubAssign<std::time::Duration>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.sub_assign(p1);
+<duration::Duration as std::ops::SubAssign<std::time::Duration>>::sub_assign(p0, p1);
+crate::<duration::Duration as std::ops::SubAssign<std::time::Duration>>::sub_assign(p0, p1);
+<duration::Duration>::sub_assign(p0, p1);
-----------------
src/duration.rs duration::<impl std::ops::SubAssign<duration::Duration> for std::time::Duration>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::time::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub_assign(p1);
+duration::<impl std::ops::SubAssign<duration::Duration> for std::time::Duration>::sub_assign(p0, p1);
+crate::duration::<impl std::ops::SubAssign<duration::Duration> for std::time::Duration>::sub_assign(p0, p1);
+<std::time::Duration>::sub_assign(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Mul<i8>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i8; // None+i8
+p0.mul(p1);
+<duration::Duration as std::ops::Mul<i8>>::mul(p0, p1);
+crate::<duration::Duration as std::ops::Mul<i8>>::mul(p0, p1);
+<duration::Duration>::mul(p0, p1);
-----------------
src/duration.rs duration::<impl std::ops::Mul<duration::Duration> for i8>::mul
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.mul(p1);
+duration::<impl std::ops::Mul<duration::Duration> for i8>::mul(p0, p1);
+crate::duration::<impl std::ops::Mul<duration::Duration> for i8>::mul(p0, p1);
+<i8>::mul(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Div<i8>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i8; // None+i8
+p0.div(p1);
+<duration::Duration as std::ops::Div<i8>>::div(p0, p1);
+crate::<duration::Duration as std::ops::Div<i8>>::div(p0, p1);
+<duration::Duration>::div(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Mul<i16>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i16; // None+i16
+p0.mul(p1);
+<duration::Duration as std::ops::Mul<i16>>::mul(p0, p1);
+crate::<duration::Duration as std::ops::Mul<i16>>::mul(p0, p1);
+<duration::Duration>::mul(p0, p1);
-----------------
src/duration.rs duration::<impl std::ops::Mul<duration::Duration> for i16>::mul
deps:{}
candidates:{}
let mut p0 = 0i16; // None+i16
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.mul(p1);
+duration::<impl std::ops::Mul<duration::Duration> for i16>::mul(p0, p1);
+crate::duration::<impl std::ops::Mul<duration::Duration> for i16>::mul(p0, p1);
+<i16>::mul(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Div<i16>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i16; // None+i16
+p0.div(p1);
+<duration::Duration as std::ops::Div<i16>>::div(p0, p1);
+crate::<duration::Duration as std::ops::Div<i16>>::div(p0, p1);
+<duration::Duration>::div(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Mul<i32>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i32; // None+i32
+p0.mul(p1);
+<duration::Duration as std::ops::Mul<i32>>::mul(p0, p1);
+crate::<duration::Duration as std::ops::Mul<i32>>::mul(p0, p1);
+<duration::Duration>::mul(p0, p1);
-----------------
src/duration.rs duration::<impl std::ops::Mul<duration::Duration> for i32>::mul
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.mul(p1);
+duration::<impl std::ops::Mul<duration::Duration> for i32>::mul(p0, p1);
+crate::duration::<impl std::ops::Mul<duration::Duration> for i32>::mul(p0, p1);
+<i32>::mul(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Div<i32>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i32; // None+i32
+p0.div(p1);
+<duration::Duration as std::ops::Div<i32>>::div(p0, p1);
+crate::<duration::Duration as std::ops::Div<i32>>::div(p0, p1);
+<duration::Duration>::div(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Mul<u8>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0u8; // None+u8
+p0.mul(p1);
+<duration::Duration as std::ops::Mul<u8>>::mul(p0, p1);
+crate::<duration::Duration as std::ops::Mul<u8>>::mul(p0, p1);
+<duration::Duration>::mul(p0, p1);
-----------------
src/duration.rs duration::<impl std::ops::Mul<duration::Duration> for u8>::mul
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.mul(p1);
+duration::<impl std::ops::Mul<duration::Duration> for u8>::mul(p0, p1);
+crate::duration::<impl std::ops::Mul<duration::Duration> for u8>::mul(p0, p1);
+<u8>::mul(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Div<u8>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0u8; // None+u8
+p0.div(p1);
+<duration::Duration as std::ops::Div<u8>>::div(p0, p1);
+crate::<duration::Duration as std::ops::Div<u8>>::div(p0, p1);
+<duration::Duration>::div(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Mul<u16>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0u16; // None+u16
+p0.mul(p1);
+<duration::Duration as std::ops::Mul<u16>>::mul(p0, p1);
+crate::<duration::Duration as std::ops::Mul<u16>>::mul(p0, p1);
+<duration::Duration>::mul(p0, p1);
-----------------
src/duration.rs duration::<impl std::ops::Mul<duration::Duration> for u16>::mul
deps:{}
candidates:{}
let mut p0 = 0u16; // None+u16
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.mul(p1);
+duration::<impl std::ops::Mul<duration::Duration> for u16>::mul(p0, p1);
+crate::duration::<impl std::ops::Mul<duration::Duration> for u16>::mul(p0, p1);
+<u16>::mul(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Div<u16>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0u16; // None+u16
+p0.div(p1);
+<duration::Duration as std::ops::Div<u16>>::div(p0, p1);
+crate::<duration::Duration as std::ops::Div<u16>>::div(p0, p1);
+<duration::Duration>::div(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Mul<u32>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0u32; // None+u32
+p0.mul(p1);
+<duration::Duration as std::ops::Mul<u32>>::mul(p0, p1);
+crate::<duration::Duration as std::ops::Mul<u32>>::mul(p0, p1);
+<duration::Duration>::mul(p0, p1);
-----------------
src/duration.rs duration::<impl std::ops::Mul<duration::Duration> for u32>::mul
deps:{}
candidates:{}
let mut p0 = 0u32; // None+u32
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.mul(p1);
+duration::<impl std::ops::Mul<duration::Duration> for u32>::mul(p0, p1);
+crate::duration::<impl std::ops::Mul<duration::Duration> for u32>::mul(p0, p1);
+<u32>::mul(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Div<u32>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0u32; // None+u32
+p0.div(p1);
+<duration::Duration as std::ops::Div<u32>>::div(p0, p1);
+crate::<duration::Duration as std::ops::Div<u32>>::div(p0, p1);
+<duration::Duration>::div(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Mul<f32>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0f32; // None+f32
+p0.mul(p1);
+<duration::Duration as std::ops::Mul<f32>>::mul(p0, p1);
+crate::<duration::Duration as std::ops::Mul<f32>>::mul(p0, p1);
+<duration::Duration>::mul(p0, p1);
-----------------
src/duration.rs duration::<impl std::ops::Mul<duration::Duration> for f32>::mul
deps:{}
candidates:{}
let mut p0 = 0f32; // None+f32
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.mul(p1);
+duration::<impl std::ops::Mul<duration::Duration> for f32>::mul(p0, p1);
+crate::duration::<impl std::ops::Mul<duration::Duration> for f32>::mul(p0, p1);
+<f32>::mul(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Mul<f64>>::mul
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0f64; // None+f64
+p0.mul(p1);
+<duration::Duration as std::ops::Mul<f64>>::mul(p0, p1);
+crate::<duration::Duration as std::ops::Mul<f64>>::mul(p0, p1);
+<duration::Duration>::mul(p0, p1);
-----------------
src/duration.rs duration::<impl std::ops::Mul<duration::Duration> for f64>::mul
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.mul(p1);
+duration::<impl std::ops::Mul<duration::Duration> for f64>::mul(p0, p1);
+crate::duration::<impl std::ops::Mul<duration::Duration> for f64>::mul(p0, p1);
+<f64>::mul(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::MulAssign<i8>>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i8; // None+i8
+p0.mul_assign(p1);
+<duration::Duration as std::ops::MulAssign<i8>>::mul_assign(p0, p1);
+crate::<duration::Duration as std::ops::MulAssign<i8>>::mul_assign(p0, p1);
+<duration::Duration>::mul_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::MulAssign<i16>>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i16; // None+i16
+p0.mul_assign(p1);
+<duration::Duration as std::ops::MulAssign<i16>>::mul_assign(p0, p1);
+crate::<duration::Duration as std::ops::MulAssign<i16>>::mul_assign(p0, p1);
+<duration::Duration>::mul_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::MulAssign<i32>>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i32; // None+i32
+p0.mul_assign(p1);
+<duration::Duration as std::ops::MulAssign<i32>>::mul_assign(p0, p1);
+crate::<duration::Duration as std::ops::MulAssign<i32>>::mul_assign(p0, p1);
+<duration::Duration>::mul_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::MulAssign<u8>>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0u8; // None+u8
+p0.mul_assign(p1);
+<duration::Duration as std::ops::MulAssign<u8>>::mul_assign(p0, p1);
+crate::<duration::Duration as std::ops::MulAssign<u8>>::mul_assign(p0, p1);
+<duration::Duration>::mul_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::MulAssign<u16>>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0u16; // None+u16
+p0.mul_assign(p1);
+<duration::Duration as std::ops::MulAssign<u16>>::mul_assign(p0, p1);
+crate::<duration::Duration as std::ops::MulAssign<u16>>::mul_assign(p0, p1);
+<duration::Duration>::mul_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::MulAssign<u32>>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0u32; // None+u32
+p0.mul_assign(p1);
+<duration::Duration as std::ops::MulAssign<u32>>::mul_assign(p0, p1);
+crate::<duration::Duration as std::ops::MulAssign<u32>>::mul_assign(p0, p1);
+<duration::Duration>::mul_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::MulAssign<f32>>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0f32; // None+f32
+p0.mul_assign(p1);
+<duration::Duration as std::ops::MulAssign<f32>>::mul_assign(p0, p1);
+crate::<duration::Duration as std::ops::MulAssign<f32>>::mul_assign(p0, p1);
+<duration::Duration>::mul_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::MulAssign<f64>>::mul_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0f64; // None+f64
+p0.mul_assign(p1);
+<duration::Duration as std::ops::MulAssign<f64>>::mul_assign(p0, p1);
+crate::<duration::Duration as std::ops::MulAssign<f64>>::mul_assign(p0, p1);
+<duration::Duration>::mul_assign(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Div<f32>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0f32; // None+f32
+p0.div(p1);
+<duration::Duration as std::ops::Div<f32>>::div(p0, p1);
+crate::<duration::Duration as std::ops::Div<f32>>::div(p0, p1);
+<duration::Duration>::div(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Div<f64>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0f64; // None+f64
+p0.div(p1);
+<duration::Duration as std::ops::Div<f64>>::div(p0, p1);
+crate::<duration::Duration as std::ops::Div<f64>>::div(p0, p1);
+<duration::Duration>::div(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::DivAssign<i8>>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i8; // None+i8
+p0.div_assign(p1);
+<duration::Duration as std::ops::DivAssign<i8>>::div_assign(p0, p1);
+crate::<duration::Duration as std::ops::DivAssign<i8>>::div_assign(p0, p1);
+<duration::Duration>::div_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::DivAssign<i16>>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i16; // None+i16
+p0.div_assign(p1);
+<duration::Duration as std::ops::DivAssign<i16>>::div_assign(p0, p1);
+crate::<duration::Duration as std::ops::DivAssign<i16>>::div_assign(p0, p1);
+<duration::Duration>::div_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::DivAssign<i32>>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0i32; // None+i32
+p0.div_assign(p1);
+<duration::Duration as std::ops::DivAssign<i32>>::div_assign(p0, p1);
+crate::<duration::Duration as std::ops::DivAssign<i32>>::div_assign(p0, p1);
+<duration::Duration>::div_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::DivAssign<u8>>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0u8; // None+u8
+p0.div_assign(p1);
+<duration::Duration as std::ops::DivAssign<u8>>::div_assign(p0, p1);
+crate::<duration::Duration as std::ops::DivAssign<u8>>::div_assign(p0, p1);
+<duration::Duration>::div_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::DivAssign<u16>>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0u16; // None+u16
+p0.div_assign(p1);
+<duration::Duration as std::ops::DivAssign<u16>>::div_assign(p0, p1);
+crate::<duration::Duration as std::ops::DivAssign<u16>>::div_assign(p0, p1);
+<duration::Duration>::div_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::DivAssign<u32>>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0u32; // None+u32
+p0.div_assign(p1);
+<duration::Duration as std::ops::DivAssign<u32>>::div_assign(p0, p1);
+crate::<duration::Duration as std::ops::DivAssign<u32>>::div_assign(p0, p1);
+<duration::Duration>::div_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::DivAssign<f32>>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0f32; // None+f32
+p0.div_assign(p1);
+<duration::Duration as std::ops::DivAssign<f32>>::div_assign(p0, p1);
+crate::<duration::Duration as std::ops::DivAssign<f32>>::div_assign(p0, p1);
+<duration::Duration>::div_assign(p0, p1);
-----------------
src/lib.rs <duration::Duration as std::ops::DivAssign<f64>>::div_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = 0f64; // None+f64
+p0.div_assign(p1);
+<duration::Duration as std::ops::DivAssign<f64>>::div_assign(p0, p1);
+crate::<duration::Duration as std::ops::DivAssign<f64>>::div_assign(p0, p1);
+<duration::Duration>::div_assign(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Div>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.div(p1);
+<duration::Duration as std::ops::Div>::div(p0, p1);
+crate::<duration::Duration as std::ops::Div>::div(p0, p1);
+<duration::Duration>::div(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::ops::Div<std::time::Duration>>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.div(p1);
+<duration::Duration as std::ops::Div<std::time::Duration>>::div(p0, p1);
+crate::<duration::Duration as std::ops::Div<std::time::Duration>>::div(p0, p1);
+<duration::Duration>::div(p0, p1);
-----------------
src/duration.rs duration::<impl std::ops::Div<duration::Duration> for std::time::Duration>::div
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::Duration
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.div(p1);
+duration::<impl std::ops::Div<duration::Duration> for std::time::Duration>::div(p0, p1);
+crate::duration::<impl std::ops::Div<duration::Duration> for std::time::Duration>::div(p0, p1);
+<std::time::Duration>::div(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::cmp::PartialEq<std::time::Duration>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.eq(p1);
+<duration::Duration as std::cmp::PartialEq<std::time::Duration>>::eq(p0, p1);
+crate::<duration::Duration as std::cmp::PartialEq<std::time::Duration>>::eq(p0, p1);
+<duration::Duration>::eq(p0, p1);
-----------------
src/duration.rs duration::<impl std::cmp::PartialEq<duration::Duration> for std::time::Duration>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::time::Duration
let mut p1 = & MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.eq(p1);
+duration::<impl std::cmp::PartialEq<duration::Duration> for std::time::Duration>::eq(p0, p1);
+crate::duration::<impl std::cmp::PartialEq<duration::Duration> for std::time::Duration>::eq(p0, p1);
+<std::time::Duration>::eq(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::cmp::PartialOrd<std::time::Duration>>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // duration::Duration
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.partial_cmp(p1);
+<duration::Duration as std::cmp::PartialOrd<std::time::Duration>>::partial_cmp(p0, p1);
+crate::<duration::Duration as std::cmp::PartialOrd<std::time::Duration>>::partial_cmp(p0, p1);
+<duration::Duration>::partial_cmp(p0, p1);
-----------------
src/duration.rs duration::<impl std::cmp::PartialOrd<duration::Duration> for std::time::Duration>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::time::Duration
let mut p1 = & MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.partial_cmp(p1);
+duration::<impl std::cmp::PartialOrd<duration::Duration> for std::time::Duration>::partial_cmp(p0, p1);
+crate::duration::<impl std::cmp::PartialOrd<duration::Duration> for std::time::Duration>::partial_cmp(p0, p1);
+<std::time::Duration>::partial_cmp(p0, p1);
-----------------
src/duration.rs <duration::Duration as std::iter::Sum>::sum
deps:{"<&mut I as std::iter::Iterator>":{},"<duration::Duration as std::iter::Sum>::sum":{"I":["std::marker::Sized","std::iter::Iterator"]}}
candidates:{"<&mut I as std::iter::Iterator>":{},"<duration::Duration as std::iter::Sum>::sum":{"I":["core::slice::iter::GenericSplitN<I>","std::collections::btree_map::IterMut<'a, K, V>","std::os::unix::net::ScmCredentials<'a>","std::slice::RSplitNMut<'a, T, P>","std::os::unix::net::Messages<'a>","std::slice::GroupByMut<'a, T, P>","std::collections::btree_map::IntoIter<K, V, A>","std::collections::binary_heap::IntoIter<T>","std::os::unix::net::Incoming<'a>","std::ops::RangeInclusive<A>","std::collections::btree_set::IntoIter<T, A>","std::sys::unix::fs::ReadDir","std::sys::unix::args::Args","std::process::CommandEnvs<'a>","std::ascii::EscapeDefault","std::iter::RepeatN<A>","std::slice::SplitMut<'a, T, P>","std::collections::vec_deque::Drain<'_, T, A>","std::str::LinesAny<'a>","std::vec::DrainFilter<'_, T, F, A>","std::slice::RChunksExact<'a, T>","std::collections::vec_deque::IterMut<'a, T>","std::collections::btree_set::Iter<'a, T>","std::iter::Chain<A, B>","std::slice::ArrayChunks<'a, T, N>","std::slice::IterMut<'a, T>","std::iter::Flatten<I>","std::option::Item<A>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::slice::Windows<'a, T>","std::str::EscapeDefault<'a>","std::slice::RSplitMut<'a, T, P>","std::io::Bytes<R>","std::iter::adapters::GenericShunt<'_, I, R>","std::iter::Enumerate<I>","std::collections::btree_map::Keys<'a, K, V>","std::option::Iter<'a, A>","std::str::CharIndices<'a>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::collections::hash_map::Drain<'a, K, V>","std::collections::hash_map::IntoKeys<K, V>","std::sys_common::net::LookupHost","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::collections::binary_heap::DrainSorted<'_, T>","std::option::IterMut<'a, A>","std::char::DecodeUtf16<I>","std::iter::ArrayChunks<I, N>","std::os::unix::net::ScmRights<'a>","std::str::MatchIndices<'a, P>","std::str::SplitTerminator<'a, P>","std::str::Lines<'a>","std::char::EscapeUnicode","std::collections::hash_set::Intersection<'a, T, S>","std::slice::RChunks<'a, T>","core::error::Source<'a>","std::path::Components<'a>","std::slice::ChunksExact<'a, T>","std::ops::RangeFrom<A>","std::string::Drain<'_>","std::str::SplitAsciiWhitespace<'a>","std::iter::Filter<I, P>","std::slice::SplitNMut<'a, T, P>","std::iter::Repeat<A>","std::sync::mpsc::IntoIter<T>","std::slice::Split<'a, T, P>","std::slice::Chunks<'a, T>","std::collections::linked_list::Iter<'a, T>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","std::collections::hash_set::Drain<'a, K>","std::str::Chars<'a>","std::collections::hash_set::Iter<'a, K>","std::iter::Scan<I, St, F>","std::sync::mpsc::Iter<'a, T>","std::sys::unix::process::process_common::CommandArgs<'a>","std::slice::EscapeAscii<'a>","std::result::IntoIter<T>","std::collections::btree_set::Difference<'a, T, A>","std::net::Incoming<'a>","std::iter::Skip<I>","std::iter::Cloned<I>","std::str::EncodeUtf16<'a>","std::slice::RChunksExactMut<'a, T>","std::iter::TakeWhile<I, P>","std::collections::binary_heap::IntoIterSorted<T>","std::str::RSplit<'a, P>","std::vec::Drain<'_, T, A>","std::iter::StepBy<I>","std::slice::RChunksMut<'a, T>","std::str::RMatchIndices<'a, P>","std::slice::RSplitN<'a, T, P>","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::hash_set::Difference<'a, T, S>","std::slice::GroupBy<'a, T, P>","std::iter::sources::from_generator::FromGenerator<G>","std::array::IntoIter<T, N>","std::collections::linked_list::IntoIter<T>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::net::IntoIncoming","std::slice::SplitN<'a, T, P>","std::str::SplitN<'a, P>","std::slice::ChunksExactMut<'a, T>","std::boxed::Box<I, A>","std::collections::linked_list::IterMut<'a, T>","std::collections::linked_list::DrainFilter<'_, T, F>","std::iter::Take<I>","std::str::Split<'a, P>","std::slice::SplitInclusiveMut<'a, T, P>","std::slice::SplitInclusive<'a, T, P>","std::collections::hash_map::Keys<'a, K, V>","std::iter::Cycle<I>","std::collections::btree_map::Iter<'a, K, V>","std::slice::ArrayChunksMut<'a, T, N>","std::char::ToUppercase","std::collections::hash_map::IntoValues<K, V>","std::env::SplitPaths<'a>","std::iter::Copied<I>","<&mut I as std::iter::Iterator>","std::collections::btree_map::IntoValues<K, V, A>","std::process::CommandArgs<'a>","std::collections::btree_set::SymmetricDifference<'a, T>","std::collections::hash_map::IterMut<'a, K, V>","std::iter::Rev<I>","std::slice::ChunksMut<'a, T>","std::collections::hash_map::Iter<'a, K, V>","std::io::Lines<B>","std::iter::Once<T>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::path::Iter<'a>","std::collections::btree_set::Intersection<'a, T, A>","std::sync::mpsc::TryIter<'a, T>","std::collections::vec_deque::IntoIter<T, A>","std::path::Ancestors<'a>","std::slice::Iter<'a, T>","std::str::Utf8Chunks<'a>","std::option::IntoIter<A>","std::env::Vars","std::iter::FlatMap<I, U, F>","std::iter::IntersperseWith<I, G>","std::iter::OnceWith<F>","std::iter::Fuse<I>","std::collections::btree_map::IntoKeys<K, V, A>","std::iter::Map<I, F>","std::slice::ArrayWindows<'a, T, N>","std::result::Iter<'a, T>","std::collections::hash_set::IntoIter<K>","std::collections::btree_map::Range<'a, K, V>","std::ops::Range<A>","std::iter::FromFn<F>","std::char::CaseMappingIter","std::char::EscapeDefault","std::vec::Splice<'_, I, A>","std::iter::Intersperse<I>","std::collections::hash_set::DrainFilter<'_, K, F>","std::iter::Empty<T>","std::str::RSplitTerminator<'a, P>","std::str::SplitWhitespace<'a>","std::result::IterMut<'a, T>","std::collections::binary_heap::Drain<'_, T>","std::char::ToLowercase","std::collections::hash_map::IntoIter<K, V>","std::fs::ReadDir","std::collections::btree_map::Values<'a, K, V>","std::collections::btree_set::Range<'a, T>","std::sys_common::wtf8::EncodeWide<'a>","std::env::VarsOs","std::collections::btree_map::RangeMut<'a, K, V>","std::env::ArgsOs","std::vec::IntoIter<T, A>","std::sys::unix::os::Env","std::char::EscapeDebug","std::env::Args","std::iter::Successors<T, F>","std::iter::RepeatWith<F>","std::sys::unix::os::SplitPaths<'a>","std::collections::binary_heap::Iter<'a, T>","std::str::Matches<'a, P>","std::iter::FilterMap<I, F>","std::str::EscapeDebug<'a>","std::collections::hash_map::ValuesMut<'a, K, V>","std::sys_common::wstr::WStrUnits<'_>","std::collections::hash_set::Union<'a, T, S>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::iter::SkipWhile<I, P>","std::io::Split<B>","std::collections::hash_map::Values<'a, K, V>","std::str::RMatches<'a, P>","std::str::RSplitN<'a, P>","std::str::SplitInclusive<'a, P>","std::ops::index_range::IndexRange","std::iter::Peekable<I>","std::iter::Zip<A, B>","std::str::Bytes<'_>","std::iter::Inspect<I, F>","std::slice::RSplit<'a, T, P>","std::str::EscapeUnicode<'a>","std::collections::btree_set::Union<'a, T>","std::iter::ByRefSized<'_, I>","std::iter::MapWhile<I, P>","std::collections::vec_deque::Iter<'a, T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<duration::Duration as std::iter::Sum>::sum(p0);
+crate::<duration::Duration as std::iter::Sum>::sum(p0);
+<duration::Duration>::sum(p0);
-----------------
src/duration.rs <duration::Duration as std::iter::Sum<&'a duration::Duration>>::sum
'a
deps:{"<&mut I as std::iter::Iterator>":{},"<duration::Duration as std::iter::Sum<&'a duration::Duration>>::sum":{"I":["std::marker::Sized","std::iter::Iterator"]}}
candidates:{"<&mut I as std::iter::Iterator>":{},"<duration::Duration as std::iter::Sum<&'a duration::Duration>>::sum":{"I":["std::ops::RangeFrom<A>","std::slice::ArrayWindows<'a, T, N>","std::collections::btree_map::RangeMut<'a, K, V>","std::char::DecodeUtf16<I>","std::slice::RChunks<'a, T>","std::slice::SplitInclusive<'a, T, P>","std::collections::binary_heap::DrainSorted<'_, T>","std::slice::RSplit<'a, T, P>","std::slice::SplitMut<'a, T, P>","std::str::Matches<'a, P>","std::iter::Skip<I>","std::slice::RSplitN<'a, T, P>","std::slice::GroupByMut<'a, T, P>","std::env::Vars","std::str::RMatches<'a, P>","std::iter::Zip<A, B>","std::process::CommandEnvs<'a>","std::collections::linked_list::Iter<'a, T>","std::sync::mpsc::Iter<'a, T>","std::collections::binary_heap::Iter<'a, T>","std::collections::btree_map::IterMut<'a, K, V>","std::str::RMatchIndices<'a, P>","std::slice::RChunksMut<'a, T>","std::sys_common::wtf8::EncodeWide<'a>","std::str::SplitAsciiWhitespace<'a>","std::slice::ArrayChunksMut<'a, T, N>","std::collections::btree_map::IntoValues<K, V, A>","std::collections::btree_map::ValuesMut<'a, K, V>","std::collections::vec_deque::Iter<'a, T>","std::option::Iter<'a, A>","std::collections::btree_map::Values<'a, K, V>","std::iter::Rev<I>","std::array::IntoIter<T, N>","std::slice::ChunksExactMut<'a, T>","std::str::EncodeUtf16<'a>","std::option::IterMut<'a, A>","std::collections::btree_map::IntoIter<K, V, A>","std::iter::Successors<T, F>","std::sys::unix::os::Env","std::vec::IntoIter<T, A>","std::iter::Chain<A, B>","std::collections::btree_map::IntoKeys<K, V, A>","std::slice::RSplitNMut<'a, T, P>","std::iter::MapWhile<I, P>","std::collections::hash_set::Difference<'a, T, S>","std::net::IntoIncoming","std::char::CaseMappingIter","std::str::EscapeDebug<'a>","std::collections::hash_map::IntoKeys<K, V>","std::slice::SplitNMut<'a, T, P>","std::collections::hash_map::Drain<'a, K, V>","std::collections::hash_set::SymmetricDifference<'a, T, S>","std::string::Drain<'_>","std::sys_common::net::LookupHost","std::os::unix::net::ScmRights<'a>","std::iter::Filter<I, P>","std::str::Bytes<'_>","std::str::LinesAny<'a>","std::str::Lines<'a>","std::str::SplitInclusive<'a, P>","std::fs::ReadDir","std::io::Split<B>","std::iter::Empty<T>","std::collections::btree_map::Keys<'a, K, V>","std::option::Item<A>","std::iter::SkipWhile<I, P>","std::collections::hash_set::Drain<'a, K>","std::sys::unix::args::Args","std::str::EscapeDefault<'a>","std::collections::binary_heap::Drain<'_, T>","std::iter::FlatMap<I, U, F>","std::slice::IterMut<'a, T>","std::ascii::EscapeDefault","std::iter::Map<I, F>","std::iter::adapters::GenericShunt<'_, I, R>","std::sync::mpsc::TryIter<'a, T>","std::path::Components<'a>","std::slice::ArrayChunks<'a, T, N>","std::collections::vec_deque::Drain<'_, T, A>","std::iter::RepeatWith<F>","std::path::Iter<'a>","std::iter::ArrayChunks<I, N>","std::collections::hash_map::Iter<'a, K, V>","std::collections::binary_heap::IntoIterSorted<T>","std::result::IterMut<'a, T>","std::slice::RChunksExact<'a, T>","std::ops::RangeInclusive<A>","std::slice::EscapeAscii<'a>","std::collections::btree_set::SymmetricDifference<'a, T>","std::slice::Iter<'a, T>","std::iter::ByRefSized<'_, I>","std::result::IntoIter<T>","std::env::SplitPaths<'a>","std::collections::hash_set::Intersection<'a, T, S>","std::collections::btree_set::Intersection<'a, T, A>","std::slice::ChunksMut<'a, T>","std::slice::Chunks<'a, T>","std::collections::hash_map::Keys<'a, K, V>","std::str::CharIndices<'a>","std::collections::btree_map::Iter<'a, K, V>","std::ops::Range<A>","std::collections::btree_set::Iter<'a, T>","std::collections::hash_set::Union<'a, T, S>","std::iter::FilterMap<I, F>","std::iter::Repeat<A>","std::boxed::Box<I, A>","std::slice::Split<'a, T, P>","std::char::EscapeDebug","std::str::MatchIndices<'a, P>","std::collections::vec_deque::IntoIter<T, A>","std::iter::Take<I>","std::str::Chars<'a>","std::collections::hash_map::Values<'a, K, V>","std::os::unix::net::Messages<'a>","std::collections::btree_set::Union<'a, T>","std::process::CommandArgs<'a>","std::collections::hash_set::Iter<'a, K>","std::iter::Once<T>","std::str::RSplitTerminator<'a, P>","std::iter::Cycle<I>","std::result::Iter<'a, T>","std::option::IntoIter<A>","std::sys_common::wstr::WStrUnits<'_>","std::sys_common::wtf8::Wtf8CodePoints<'a>","std::slice::Windows<'a, T>","<&mut I as std::iter::Iterator>","std::iter::Cloned<I>","std::iter::sources::from_generator::FromGenerator<G>","std::iter::adapters::flatten::FlattenCompat<I, U>","std::io::Bytes<R>","std::collections::btree_map::Range<'a, K, V>","std::str::Utf8Chunks<'a>","std::env::Args","std::iter::TakeWhile<I, P>","std::iter::Intersperse<I>","std::iter::Copied<I>","std::collections::btree_set::Difference<'a, T, A>","std::slice::ChunksExact<'a, T>","std::char::ToUppercase","std::iter::Enumerate<I>","std::collections::linked_list::DrainFilter<'_, T, F>","std::str::SplitN<'a, P>","std::vec::DrainFilter<'_, T, F, A>","std::char::EscapeUnicode","std::collections::linked_list::IntoIter<T>","std::collections::btree_map::DrainFilter<'_, K, V, F, A>","std::io::Lines<B>","std::str::RSplit<'a, P>","std::collections::btree_set::IntoIter<T, A>","std::vec::Drain<'_, T, A>","std::str::SplitTerminator<'a, P>","std::net::Incoming<'a>","std::slice::SplitInclusiveMut<'a, T, P>","std::slice::RChunksExactMut<'a, T>","std::ops::index_range::IndexRange","std::iter::OnceWith<F>","std::iter::Flatten<I>","std::collections::linked_list::IterMut<'a, T>","std::collections::hash_map::IterMut<'a, K, V>","std::iter::StepBy<I>","std::char::ToLowercase","std::env::ArgsOs","std::vec::Splice<'_, I, A>","std::os::unix::net::ScmCredentials<'a>","std::iter::Inspect<I, F>","std::env::VarsOs","core::error::Source<'a>","std::collections::vec_deque::IterMut<'a, T>","std::path::Ancestors<'a>","std::os::unix::net::ancillary::AncillaryDataIter<'a, T>","core::slice::iter::GenericSplitN<I>","std::slice::GroupBy<'a, T, P>","std::collections::hash_map::ValuesMut<'a, K, V>","std::iter::Peekable<I>","std::sys::unix::process::process_common::CommandArgs<'a>","std::collections::hash_set::IntoIter<K>","std::os::unix::net::Incoming<'a>","std::str::RSplitN<'a, P>","std::iter::Scan<I, St, F>","std::iter::IntersperseWith<I, G>","std::slice::RSplitMut<'a, T, P>","std::collections::hash_map::DrainFilter<'_, K, V, F>","std::collections::btree_set::DrainFilter<'_, T, F, A>","std::slice::SplitN<'a, T, P>","std::collections::binary_heap::IntoIter<T>","std::char::EscapeDefault","std::iter::Fuse<I>","std::collections::btree_set::Range<'a, T>","std::sys::unix::fs::ReadDir","std::str::SplitWhitespace<'a>","std::sys::unix::os::SplitPaths<'a>","std::str::Split<'a, P>","std::iter::FromFn<F>","std::str::EscapeUnicode<'a>","std::iter::RepeatN<A>","std::collections::hash_map::IntoValues<K, V>","std::collections::hash_set::DrainFilter<'_, K, F>","std::collections::hash_map::IntoIter<K, V>","std::sync::mpsc::IntoIter<T>"]}}
let mut p0 = MaybeUninit::uninit().assume_init(); // I
+<duration::Duration as std::iter::Sum<&'a duration::Duration>>::sum(p0);
+crate::<duration::Duration as std::iter::Sum<&'a duration::Duration>>::sum(p0);
+<duration::Duration>::sum(p0);
-----------------
src/error/component_range.rs <error::component_range::ComponentRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::component_range::ComponentRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::component_range::ComponentRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::component_range::ComponentRange as std::fmt::Debug>::fmt(p0, p1);
+<error::component_range::ComponentRange>::fmt(p0, p1);
-----------------
src/error/component_range.rs <error::component_range::ComponentRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::component_range::ComponentRange
+p0.clone();
+<error::component_range::ComponentRange as std::clone::Clone>::clone(p0);
+crate::<error::component_range::ComponentRange as std::clone::Clone>::clone(p0);
+<error::component_range::ComponentRange>::clone(p0);
-----------------
src/error/component_range.rs <error::component_range::ComponentRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::component_range::ComponentRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::component_range::ComponentRange
+p0.eq(p1);
+<error::component_range::ComponentRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::component_range::ComponentRange as std::cmp::PartialEq>::eq(p0, p1);
+<error::component_range::ComponentRange>::eq(p0, p1);
-----------------
src/error/component_range.rs <error::component_range::ComponentRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::component_range::ComponentRange
+p0.assert_receiver_is_total_eq();
+<error::component_range::ComponentRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::component_range::ComponentRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::component_range::ComponentRange>::assert_receiver_is_total_eq(p0);
-----------------
src/error/component_range.rs <error::component_range::ComponentRange as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<error::component_range::ComponentRange as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<error::component_range::ComponentRange as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::component_range::ComponentRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<error::component_range::ComponentRange as std::hash::Hash>::hash(p0, p1);
+crate::<error::component_range::ComponentRange as std::hash::Hash>::hash(p0, p1);
+<error::component_range::ComponentRange>::hash(p0, p1);
-----------------
src/error/component_range.rs error::component_range::ComponentRange::name
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::component_range::ComponentRange
+p0.name();
+error::component_range::ComponentRange::name(p0);
+crate::error::component_range::ComponentRange::name(p0);
+<error::component_range::ComponentRange>::name(p0);
-----------------
src/error/component_range.rs <error::component_range::ComponentRange as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::component_range::ComponentRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::component_range::ComponentRange as std::fmt::Display>::fmt(p0, p1);
+crate::<error::component_range::ComponentRange as std::fmt::Display>::fmt(p0, p1);
+<error::component_range::ComponentRange>::fmt(p0, p1);
-----------------
src/error/component_range.rs error::component_range::<impl std::convert::From<error::component_range::ComponentRange> for error::Error>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::component_range::ComponentRange
+error::component_range::<impl std::convert::From<error::component_range::ComponentRange> for error::Error>::from(p0);
+crate::error::component_range::<impl std::convert::From<error::component_range::ComponentRange> for error::Error>::from(p0);
+<error::Error>::from(p0);
-----------------
src/error/component_range.rs <error::component_range::ComponentRange as std::convert::TryFrom<error::Error>>::try_from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::Error
+<error::component_range::ComponentRange as std::convert::TryFrom<error::Error>>::try_from(p0);
+crate::<error::component_range::ComponentRange as std::convert::TryFrom<error::Error>>::try_from(p0);
+<error::component_range::ComponentRange>::try_from(p0);
-----------------
src/error/conversion_range.rs <error::conversion_range::ConversionRange as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::conversion_range::ConversionRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::conversion_range::ConversionRange as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::conversion_range::ConversionRange as std::fmt::Debug>::fmt(p0, p1);
+<error::conversion_range::ConversionRange>::fmt(p0, p1);
-----------------
src/error/conversion_range.rs <error::conversion_range::ConversionRange as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::conversion_range::ConversionRange
+p0.clone();
+<error::conversion_range::ConversionRange as std::clone::Clone>::clone(p0);
+crate::<error::conversion_range::ConversionRange as std::clone::Clone>::clone(p0);
+<error::conversion_range::ConversionRange>::clone(p0);
-----------------
src/error/conversion_range.rs <error::conversion_range::ConversionRange as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::conversion_range::ConversionRange
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::conversion_range::ConversionRange
+p0.eq(p1);
+<error::conversion_range::ConversionRange as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::conversion_range::ConversionRange as std::cmp::PartialEq>::eq(p0, p1);
+<error::conversion_range::ConversionRange>::eq(p0, p1);
-----------------
src/error/conversion_range.rs <error::conversion_range::ConversionRange as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::conversion_range::ConversionRange
+p0.assert_receiver_is_total_eq();
+<error::conversion_range::ConversionRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::conversion_range::ConversionRange as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::conversion_range::ConversionRange>::assert_receiver_is_total_eq(p0);
-----------------
src/error/conversion_range.rs <error::conversion_range::ConversionRange as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::conversion_range::ConversionRange
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::conversion_range::ConversionRange as std::fmt::Display>::fmt(p0, p1);
+crate::<error::conversion_range::ConversionRange as std::fmt::Display>::fmt(p0, p1);
+<error::conversion_range::ConversionRange>::fmt(p0, p1);
-----------------
src/error/conversion_range.rs error::conversion_range::<impl std::convert::From<error::conversion_range::ConversionRange> for error::Error>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::conversion_range::ConversionRange
+error::conversion_range::<impl std::convert::From<error::conversion_range::ConversionRange> for error::Error>::from(p0);
+crate::error::conversion_range::<impl std::convert::From<error::conversion_range::ConversionRange> for error::Error>::from(p0);
+<error::Error>::from(p0);
-----------------
src/error/conversion_range.rs <error::conversion_range::ConversionRange as std::convert::TryFrom<error::Error>>::try_from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::Error
+<error::conversion_range::ConversionRange as std::convert::TryFrom<error::Error>>::try_from(p0);
+crate::<error::conversion_range::ConversionRange as std::convert::TryFrom<error::Error>>::try_from(p0);
+<error::conversion_range::ConversionRange>::try_from(p0);
-----------------
src/error/different_variant.rs <error::different_variant::DifferentVariant as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::different_variant::DifferentVariant
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::different_variant::DifferentVariant as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::different_variant::DifferentVariant as std::fmt::Debug>::fmt(p0, p1);
+<error::different_variant::DifferentVariant>::fmt(p0, p1);
-----------------
src/error/different_variant.rs <error::different_variant::DifferentVariant as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::different_variant::DifferentVariant
+p0.clone();
+<error::different_variant::DifferentVariant as std::clone::Clone>::clone(p0);
+crate::<error::different_variant::DifferentVariant as std::clone::Clone>::clone(p0);
+<error::different_variant::DifferentVariant>::clone(p0);
-----------------
src/error/different_variant.rs <error::different_variant::DifferentVariant as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::different_variant::DifferentVariant
let mut p1 = & MaybeUninit::uninit().assume_init(); // error::different_variant::DifferentVariant
+p0.eq(p1);
+<error::different_variant::DifferentVariant as std::cmp::PartialEq>::eq(p0, p1);
+crate::<error::different_variant::DifferentVariant as std::cmp::PartialEq>::eq(p0, p1);
+<error::different_variant::DifferentVariant>::eq(p0, p1);
-----------------
src/error/different_variant.rs <error::different_variant::DifferentVariant as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::different_variant::DifferentVariant
+p0.assert_receiver_is_total_eq();
+<error::different_variant::DifferentVariant as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<error::different_variant::DifferentVariant as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<error::different_variant::DifferentVariant>::assert_receiver_is_total_eq(p0);
-----------------
src/error/different_variant.rs <error::different_variant::DifferentVariant as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::different_variant::DifferentVariant
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::different_variant::DifferentVariant as std::fmt::Display>::fmt(p0, p1);
+crate::<error::different_variant::DifferentVariant as std::fmt::Display>::fmt(p0, p1);
+<error::different_variant::DifferentVariant>::fmt(p0, p1);
-----------------
src/error/different_variant.rs error::different_variant::<impl std::convert::From<error::different_variant::DifferentVariant> for error::Error>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::different_variant::DifferentVariant
+error::different_variant::<impl std::convert::From<error::different_variant::DifferentVariant> for error::Error>::from(p0);
+crate::error::different_variant::<impl std::convert::From<error::different_variant::DifferentVariant> for error::Error>::from(p0);
+<error::Error>::from(p0);
-----------------
src/error/different_variant.rs <error::different_variant::DifferentVariant as std::convert::TryFrom<error::Error>>::try_from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // error::Error
+<error::different_variant::DifferentVariant as std::convert::TryFrom<error::Error>>::try_from(p0);
+crate::<error::different_variant::DifferentVariant as std::convert::TryFrom<error::Error>>::try_from(p0);
+<error::different_variant::DifferentVariant>::try_from(p0);
-----------------
src/error/mod.rs <error::Error as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Debug>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Debug>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
src/error/mod.rs <error::Error as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<error::Error as std::fmt::Display>::fmt(p0, p1);
+crate::<error::Error as std::fmt::Display>::fmt(p0, p1);
+<error::Error>::fmt(p0, p1);
-----------------
src/error/mod.rs <error::Error as std::error::Error>::source
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // error::Error
+p0.source();
+<error::Error as std::error::Error>::source(p0);
+crate::<error::Error as std::error::Error>::source(p0);
+<error::Error>::source(p0);
-----------------
src/ext.rs <i64 as ext::NumericalDuration>::nanoseconds
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.nanoseconds();
+<i64 as ext::NumericalDuration>::nanoseconds(p0);
+crate::<i64 as ext::NumericalDuration>::nanoseconds(p0);
+<i64>::nanoseconds(p0);
-----------------
src/ext.rs <i64 as ext::NumericalDuration>::microseconds
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.microseconds();
+<i64 as ext::NumericalDuration>::microseconds(p0);
+crate::<i64 as ext::NumericalDuration>::microseconds(p0);
+<i64>::microseconds(p0);
-----------------
src/ext.rs <i64 as ext::NumericalDuration>::milliseconds
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.milliseconds();
+<i64 as ext::NumericalDuration>::milliseconds(p0);
+crate::<i64 as ext::NumericalDuration>::milliseconds(p0);
+<i64>::milliseconds(p0);
-----------------
src/ext.rs <i64 as ext::NumericalDuration>::seconds
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.seconds();
+<i64 as ext::NumericalDuration>::seconds(p0);
+crate::<i64 as ext::NumericalDuration>::seconds(p0);
+<i64>::seconds(p0);
-----------------
src/ext.rs <i64 as ext::NumericalDuration>::minutes
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.minutes();
+<i64 as ext::NumericalDuration>::minutes(p0);
+crate::<i64 as ext::NumericalDuration>::minutes(p0);
+<i64>::minutes(p0);
-----------------
src/ext.rs <i64 as ext::NumericalDuration>::hours
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.hours();
+<i64 as ext::NumericalDuration>::hours(p0);
+crate::<i64 as ext::NumericalDuration>::hours(p0);
+<i64>::hours(p0);
-----------------
src/ext.rs <i64 as ext::NumericalDuration>::days
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.days();
+<i64 as ext::NumericalDuration>::days(p0);
+crate::<i64 as ext::NumericalDuration>::days(p0);
+<i64>::days(p0);
-----------------
src/ext.rs <i64 as ext::NumericalDuration>::weeks
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+p0.weeks();
+<i64 as ext::NumericalDuration>::weeks(p0);
+crate::<i64 as ext::NumericalDuration>::weeks(p0);
+<i64>::weeks(p0);
-----------------
src/ext.rs <f64 as ext::NumericalDuration>::nanoseconds
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.nanoseconds();
+<f64 as ext::NumericalDuration>::nanoseconds(p0);
+crate::<f64 as ext::NumericalDuration>::nanoseconds(p0);
+<f64>::nanoseconds(p0);
-----------------
src/ext.rs <f64 as ext::NumericalDuration>::microseconds
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.microseconds();
+<f64 as ext::NumericalDuration>::microseconds(p0);
+crate::<f64 as ext::NumericalDuration>::microseconds(p0);
+<f64>::microseconds(p0);
-----------------
src/ext.rs <f64 as ext::NumericalDuration>::milliseconds
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.milliseconds();
+<f64 as ext::NumericalDuration>::milliseconds(p0);
+crate::<f64 as ext::NumericalDuration>::milliseconds(p0);
+<f64>::milliseconds(p0);
-----------------
src/ext.rs <f64 as ext::NumericalDuration>::seconds
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.seconds();
+<f64 as ext::NumericalDuration>::seconds(p0);
+crate::<f64 as ext::NumericalDuration>::seconds(p0);
+<f64>::seconds(p0);
-----------------
src/ext.rs <f64 as ext::NumericalDuration>::minutes
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.minutes();
+<f64 as ext::NumericalDuration>::minutes(p0);
+crate::<f64 as ext::NumericalDuration>::minutes(p0);
+<f64>::minutes(p0);
-----------------
src/ext.rs <f64 as ext::NumericalDuration>::hours
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.hours();
+<f64 as ext::NumericalDuration>::hours(p0);
+crate::<f64 as ext::NumericalDuration>::hours(p0);
+<f64>::hours(p0);
-----------------
src/ext.rs <f64 as ext::NumericalDuration>::days
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.days();
+<f64 as ext::NumericalDuration>::days(p0);
+crate::<f64 as ext::NumericalDuration>::days(p0);
+<f64>::days(p0);
-----------------
src/ext.rs <f64 as ext::NumericalDuration>::weeks
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.weeks();
+<f64 as ext::NumericalDuration>::weeks(p0);
+crate::<f64 as ext::NumericalDuration>::weeks(p0);
+<f64>::weeks(p0);
-----------------
src/ext.rs <u64 as ext::NumericalStdDuration>::std_nanoseconds
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.std_nanoseconds();
+<u64 as ext::NumericalStdDuration>::std_nanoseconds(p0);
+crate::<u64 as ext::NumericalStdDuration>::std_nanoseconds(p0);
+<u64>::std_nanoseconds(p0);
-----------------
src/ext.rs <u64 as ext::NumericalStdDuration>::std_microseconds
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.std_microseconds();
+<u64 as ext::NumericalStdDuration>::std_microseconds(p0);
+crate::<u64 as ext::NumericalStdDuration>::std_microseconds(p0);
+<u64>::std_microseconds(p0);
-----------------
src/ext.rs <u64 as ext::NumericalStdDuration>::std_milliseconds
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.std_milliseconds();
+<u64 as ext::NumericalStdDuration>::std_milliseconds(p0);
+crate::<u64 as ext::NumericalStdDuration>::std_milliseconds(p0);
+<u64>::std_milliseconds(p0);
-----------------
src/ext.rs <u64 as ext::NumericalStdDuration>::std_seconds
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.std_seconds();
+<u64 as ext::NumericalStdDuration>::std_seconds(p0);
+crate::<u64 as ext::NumericalStdDuration>::std_seconds(p0);
+<u64>::std_seconds(p0);
-----------------
src/ext.rs <u64 as ext::NumericalStdDuration>::std_minutes
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.std_minutes();
+<u64 as ext::NumericalStdDuration>::std_minutes(p0);
+crate::<u64 as ext::NumericalStdDuration>::std_minutes(p0);
+<u64>::std_minutes(p0);
-----------------
src/ext.rs <u64 as ext::NumericalStdDuration>::std_hours
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.std_hours();
+<u64 as ext::NumericalStdDuration>::std_hours(p0);
+crate::<u64 as ext::NumericalStdDuration>::std_hours(p0);
+<u64>::std_hours(p0);
-----------------
src/ext.rs <u64 as ext::NumericalStdDuration>::std_days
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.std_days();
+<u64 as ext::NumericalStdDuration>::std_days(p0);
+crate::<u64 as ext::NumericalStdDuration>::std_days(p0);
+<u64>::std_days(p0);
-----------------
src/ext.rs <u64 as ext::NumericalStdDuration>::std_weeks
deps:{}
candidates:{}
let mut p0 = 0u64; // None+u64
+p0.std_weeks();
+<u64 as ext::NumericalStdDuration>::std_weeks(p0);
+crate::<u64 as ext::NumericalStdDuration>::std_weeks(p0);
+<u64>::std_weeks(p0);
-----------------
src/ext.rs <f64 as ext::NumericalStdDuration>::std_nanoseconds
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.std_nanoseconds();
+<f64 as ext::NumericalStdDuration>::std_nanoseconds(p0);
+crate::<f64 as ext::NumericalStdDuration>::std_nanoseconds(p0);
+<f64>::std_nanoseconds(p0);
-----------------
src/ext.rs <f64 as ext::NumericalStdDuration>::std_microseconds
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.std_microseconds();
+<f64 as ext::NumericalStdDuration>::std_microseconds(p0);
+crate::<f64 as ext::NumericalStdDuration>::std_microseconds(p0);
+<f64>::std_microseconds(p0);
-----------------
src/ext.rs <f64 as ext::NumericalStdDuration>::std_milliseconds
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.std_milliseconds();
+<f64 as ext::NumericalStdDuration>::std_milliseconds(p0);
+crate::<f64 as ext::NumericalStdDuration>::std_milliseconds(p0);
+<f64>::std_milliseconds(p0);
-----------------
src/ext.rs <f64 as ext::NumericalStdDuration>::std_seconds
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.std_seconds();
+<f64 as ext::NumericalStdDuration>::std_seconds(p0);
+crate::<f64 as ext::NumericalStdDuration>::std_seconds(p0);
+<f64>::std_seconds(p0);
-----------------
src/ext.rs <f64 as ext::NumericalStdDuration>::std_minutes
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.std_minutes();
+<f64 as ext::NumericalStdDuration>::std_minutes(p0);
+crate::<f64 as ext::NumericalStdDuration>::std_minutes(p0);
+<f64>::std_minutes(p0);
-----------------
src/ext.rs <f64 as ext::NumericalStdDuration>::std_hours
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.std_hours();
+<f64 as ext::NumericalStdDuration>::std_hours(p0);
+crate::<f64 as ext::NumericalStdDuration>::std_hours(p0);
+<f64>::std_hours(p0);
-----------------
src/ext.rs <f64 as ext::NumericalStdDuration>::std_days
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.std_days();
+<f64 as ext::NumericalStdDuration>::std_days(p0);
+crate::<f64 as ext::NumericalStdDuration>::std_days(p0);
+<f64>::std_days(p0);
-----------------
src/ext.rs <f64 as ext::NumericalStdDuration>::std_weeks
deps:{}
candidates:{}
let mut p0 = 0f64; // None+f64
+p0.std_weeks();
+<f64 as ext::NumericalStdDuration>::std_weeks(p0);
+crate::<f64 as ext::NumericalStdDuration>::std_weeks(p0);
+<f64>::std_weeks(p0);
-----------------
src/instant.rs <instant::Instant as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<instant::Instant as std::fmt::Debug>::fmt(p0, p1);
+crate::<instant::Instant as std::fmt::Debug>::fmt(p0, p1);
+<instant::Instant>::fmt(p0, p1);
-----------------
src/instant.rs <instant::Instant as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.clone();
+<instant::Instant as std::clone::Clone>::clone(p0);
+crate::<instant::Instant as std::clone::Clone>::clone(p0);
+<instant::Instant>::clone(p0);
-----------------
src/instant.rs <instant::Instant as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = & MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.eq(p1);
+<instant::Instant as std::cmp::PartialEq>::eq(p0, p1);
+crate::<instant::Instant as std::cmp::PartialEq>::eq(p0, p1);
+<instant::Instant>::eq(p0, p1);
-----------------
src/instant.rs <instant::Instant as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.assert_receiver_is_total_eq();
+<instant::Instant as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<instant::Instant as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<instant::Instant>::assert_receiver_is_total_eq(p0);
-----------------
src/instant.rs <instant::Instant as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = & MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.partial_cmp(p1);
+<instant::Instant as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<instant::Instant as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<instant::Instant>::partial_cmp(p0, p1);
-----------------
src/instant.rs <instant::Instant as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = & MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.cmp(p1);
+<instant::Instant as std::cmp::Ord>::cmp(p0, p1);
+crate::<instant::Instant as std::cmp::Ord>::cmp(p0, p1);
+<instant::Instant>::cmp(p0, p1);
-----------------
src/instant.rs <instant::Instant as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<instant::Instant as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<instant::Instant as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher","std::collections::hash_map::DefaultHasher","std::boxed::Box<T, A>","std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<instant::Instant as std::hash::Hash>::hash(p0, p1);
+crate::<instant::Instant as std::hash::Hash>::hash(p0, p1);
+<instant::Instant>::hash(p0, p1);
-----------------
src/instant.rs instant::Instant::now
deps:{}
candidates:{}
+instant::Instant::now();
+crate::instant::Instant::now();
+<instant::Instant>::now();
-----------------
src/instant.rs instant::Instant::elapsed
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.elapsed();
+instant::Instant::elapsed(p0);
+crate::instant::Instant::elapsed(p0);
+<instant::Instant>::elapsed(p0);
-----------------
src/instant.rs instant::Instant::checked_add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.checked_add(p1);
+instant::Instant::checked_add(p0, p1);
+crate::instant::Instant::checked_add(p0, p1);
+<instant::Instant>::checked_add(p0, p1);
-----------------
src/instant.rs instant::Instant::checked_sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.checked_sub(p1);
+instant::Instant::checked_sub(p0, p1);
+crate::instant::Instant::checked_sub(p0, p1);
+<instant::Instant>::checked_sub(p0, p1);
-----------------
src/instant.rs instant::Instant::into_inner
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.into_inner();
+instant::Instant::into_inner(p0);
+crate::instant::Instant::into_inner(p0);
+<instant::Instant>::into_inner(p0);
-----------------
src/instant.rs <instant::Instant as std::convert::From<std::time::Instant>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::Instant
+<instant::Instant as std::convert::From<std::time::Instant>>::from(p0);
+crate::<instant::Instant as std::convert::From<std::time::Instant>>::from(p0);
+<instant::Instant>::from(p0);
-----------------
src/instant.rs instant::<impl std::convert::From<instant::Instant> for std::time::Instant>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // instant::Instant
+instant::<impl std::convert::From<instant::Instant> for std::time::Instant>::from(p0);
+crate::instant::<impl std::convert::From<instant::Instant> for std::time::Instant>::from(p0);
+<std::time::Instant>::from(p0);
-----------------
src/instant.rs <instant::Instant as std::ops::Sub>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.sub(p1);
+<instant::Instant as std::ops::Sub>::sub(p0, p1);
+crate::<instant::Instant as std::ops::Sub>::sub(p0, p1);
+<instant::Instant>::sub(p0, p1);
-----------------
src/instant.rs <instant::Instant as std::ops::Sub<std::time::Instant>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Instant
+p0.sub(p1);
+<instant::Instant as std::ops::Sub<std::time::Instant>>::sub(p0, p1);
+crate::<instant::Instant as std::ops::Sub<std::time::Instant>>::sub(p0, p1);
+<instant::Instant>::sub(p0, p1);
-----------------
src/instant.rs instant::<impl std::ops::Sub<instant::Instant> for std::time::Instant>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.sub(p1);
+instant::<impl std::ops::Sub<instant::Instant> for std::time::Instant>::sub(p0, p1);
+crate::instant::<impl std::ops::Sub<instant::Instant> for std::time::Instant>::sub(p0, p1);
+<std::time::Instant>::sub(p0, p1);
-----------------
src/instant.rs <instant::Instant as std::ops::Add<duration::Duration>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add(p1);
+<instant::Instant as std::ops::Add<duration::Duration>>::add(p0, p1);
+crate::<instant::Instant as std::ops::Add<duration::Duration>>::add(p0, p1);
+<instant::Instant>::add(p0, p1);
-----------------
src/instant.rs instant::<impl std::ops::Add<duration::Duration> for std::time::Instant>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add(p1);
+instant::<impl std::ops::Add<duration::Duration> for std::time::Instant>::add(p0, p1);
+crate::instant::<impl std::ops::Add<duration::Duration> for std::time::Instant>::add(p0, p1);
+<std::time::Instant>::add(p0, p1);
-----------------
src/instant.rs <instant::Instant as std::ops::Add<std::time::Duration>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.add(p1);
+<instant::Instant as std::ops::Add<std::time::Duration>>::add(p0, p1);
+crate::<instant::Instant as std::ops::Add<std::time::Duration>>::add(p0, p1);
+<instant::Instant>::add(p0, p1);
-----------------
src/lib.rs <instant::Instant as std::ops::AddAssign<duration::Duration>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add_assign(p1);
+<instant::Instant as std::ops::AddAssign<duration::Duration>>::add_assign(p0, p1);
+crate::<instant::Instant as std::ops::AddAssign<duration::Duration>>::add_assign(p0, p1);
+<instant::Instant>::add_assign(p0, p1);
-----------------
src/lib.rs <instant::Instant as std::ops::AddAssign<std::time::Duration>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.add_assign(p1);
+<instant::Instant as std::ops::AddAssign<std::time::Duration>>::add_assign(p0, p1);
+crate::<instant::Instant as std::ops::AddAssign<std::time::Duration>>::add_assign(p0, p1);
+<instant::Instant>::add_assign(p0, p1);
-----------------
src/lib.rs instant::<impl std::ops::AddAssign<duration::Duration> for std::time::Instant>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::time::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add_assign(p1);
+instant::<impl std::ops::AddAssign<duration::Duration> for std::time::Instant>::add_assign(p0, p1);
+crate::instant::<impl std::ops::AddAssign<duration::Duration> for std::time::Instant>::add_assign(p0, p1);
+<std::time::Instant>::add_assign(p0, p1);
-----------------
src/instant.rs <instant::Instant as std::ops::Sub<duration::Duration>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub(p1);
+<instant::Instant as std::ops::Sub<duration::Duration>>::sub(p0, p1);
+crate::<instant::Instant as std::ops::Sub<duration::Duration>>::sub(p0, p1);
+<instant::Instant>::sub(p0, p1);
-----------------
src/instant.rs instant::<impl std::ops::Sub<duration::Duration> for std::time::Instant>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub(p1);
+instant::<impl std::ops::Sub<duration::Duration> for std::time::Instant>::sub(p0, p1);
+crate::instant::<impl std::ops::Sub<duration::Duration> for std::time::Instant>::sub(p0, p1);
+<std::time::Instant>::sub(p0, p1);
-----------------
src/instant.rs <instant::Instant as std::ops::Sub<std::time::Duration>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.sub(p1);
+<instant::Instant as std::ops::Sub<std::time::Duration>>::sub(p0, p1);
+crate::<instant::Instant as std::ops::Sub<std::time::Duration>>::sub(p0, p1);
+<instant::Instant>::sub(p0, p1);
-----------------
src/lib.rs <instant::Instant as std::ops::SubAssign<duration::Duration>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub_assign(p1);
+<instant::Instant as std::ops::SubAssign<duration::Duration>>::sub_assign(p0, p1);
+crate::<instant::Instant as std::ops::SubAssign<duration::Duration>>::sub_assign(p0, p1);
+<instant::Instant>::sub_assign(p0, p1);
-----------------
src/lib.rs <instant::Instant as std::ops::SubAssign<std::time::Duration>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.sub_assign(p1);
+<instant::Instant as std::ops::SubAssign<std::time::Duration>>::sub_assign(p0, p1);
+crate::<instant::Instant as std::ops::SubAssign<std::time::Duration>>::sub_assign(p0, p1);
+<instant::Instant>::sub_assign(p0, p1);
-----------------
src/lib.rs instant::<impl std::ops::SubAssign<duration::Duration> for std::time::Instant>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::time::Instant
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub_assign(p1);
+instant::<impl std::ops::SubAssign<duration::Duration> for std::time::Instant>::sub_assign(p0, p1);
+crate::instant::<impl std::ops::SubAssign<duration::Duration> for std::time::Instant>::sub_assign(p0, p1);
+<std::time::Instant>::sub_assign(p0, p1);
-----------------
src/instant.rs <instant::Instant as std::cmp::PartialEq<std::time::Instant>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::time::Instant
+p0.eq(p1);
+<instant::Instant as std::cmp::PartialEq<std::time::Instant>>::eq(p0, p1);
+crate::<instant::Instant as std::cmp::PartialEq<std::time::Instant>>::eq(p0, p1);
+<instant::Instant>::eq(p0, p1);
-----------------
src/instant.rs instant::<impl std::cmp::PartialEq<instant::Instant> for std::time::Instant>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::time::Instant
let mut p1 = & MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.eq(p1);
+instant::<impl std::cmp::PartialEq<instant::Instant> for std::time::Instant>::eq(p0, p1);
+crate::instant::<impl std::cmp::PartialEq<instant::Instant> for std::time::Instant>::eq(p0, p1);
+<std::time::Instant>::eq(p0, p1);
-----------------
src/instant.rs <instant::Instant as std::cmp::PartialOrd<std::time::Instant>>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // instant::Instant
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::time::Instant
+p0.partial_cmp(p1);
+<instant::Instant as std::cmp::PartialOrd<std::time::Instant>>::partial_cmp(p0, p1);
+crate::<instant::Instant as std::cmp::PartialOrd<std::time::Instant>>::partial_cmp(p0, p1);
+<instant::Instant>::partial_cmp(p0, p1);
-----------------
src/instant.rs instant::<impl std::cmp::PartialOrd<instant::Instant> for std::time::Instant>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::time::Instant
let mut p1 = & MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.partial_cmp(p1);
+instant::<impl std::cmp::PartialOrd<instant::Instant> for std::time::Instant>::partial_cmp(p0, p1);
+crate::instant::<impl std::cmp::PartialOrd<instant::Instant> for std::time::Instant>::partial_cmp(p0, p1);
+<std::time::Instant>::partial_cmp(p0, p1);
-----------------
src/instant.rs <instant::Instant as std::convert::AsRef<std::time::Instant>>::as_ref
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.as_ref();
+<instant::Instant as std::convert::AsRef<std::time::Instant>>::as_ref(p0);
+crate::<instant::Instant as std::convert::AsRef<std::time::Instant>>::as_ref(p0);
+<instant::Instant>::as_ref(p0);
-----------------
src/instant.rs <instant::Instant as std::borrow::Borrow<std::time::Instant>>::borrow
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // instant::Instant
+p0.borrow();
+<instant::Instant as std::borrow::Borrow<std::time::Instant>>::borrow(p0);
+crate::<instant::Instant as std::borrow::Borrow<std::time::Instant>>::borrow(p0);
+<instant::Instant>::borrow(p0);
-----------------
src/month.rs <month::Month as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<month::Month as std::fmt::Debug>::fmt(p0, p1);
+crate::<month::Month as std::fmt::Debug>::fmt(p0, p1);
+<month::Month>::fmt(p0, p1);
-----------------
src/month.rs <month::Month as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
+p0.clone();
+<month::Month as std::clone::Clone>::clone(p0);
+crate::<month::Month as std::clone::Clone>::clone(p0);
+<month::Month>::clone(p0);
-----------------
src/month.rs <month::Month as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
let mut p1 = & MaybeUninit::uninit().assume_init(); // month::Month
+p0.eq(p1);
+<month::Month as std::cmp::PartialEq>::eq(p0, p1);
+crate::<month::Month as std::cmp::PartialEq>::eq(p0, p1);
+<month::Month>::eq(p0, p1);
-----------------
src/month.rs <month::Month as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
+p0.assert_receiver_is_total_eq();
+<month::Month as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<month::Month as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<month::Month>::assert_receiver_is_total_eq(p0);
-----------------
src/month.rs <month::Month as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<month::Month as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<month::Month as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","<&mut H as std::hash::Hasher>","std::hash::sip::Hasher<S>","std::hash::SipHasher13"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<month::Month as std::hash::Hash>::hash(p0, p1);
+crate::<month::Month as std::hash::Hash>::hash(p0, p1);
+<month::Month>::hash(p0, p1);
-----------------
src/month.rs month::Month::from_number
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::num::NonZeroU8
+month::Month::from_number(p0);
+crate::month::Month::from_number(p0);
+<month::Month>::from_number(p0);
-----------------
src/month.rs month::Month::previous
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // month::Month
+p0.previous();
+month::Month::previous(p0);
+crate::month::Month::previous(p0);
+<month::Month>::previous(p0);
-----------------
src/month.rs month::Month::next
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // month::Month
+p0.next();
+month::Month::next(p0);
+crate::month::Month::next(p0);
+<month::Month>::next(p0);
-----------------
src/month.rs <month::Month as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // month::Month
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<month::Month as std::fmt::Display>::fmt(p0, p1);
+crate::<month::Month as std::fmt::Display>::fmt(p0, p1);
+<month::Month>::fmt(p0, p1);
-----------------
src/month.rs month::<impl std::convert::From<month::Month> for u8>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // month::Month
+month::<impl std::convert::From<month::Month> for u8>::from(p0);
+crate::month::<impl std::convert::From<month::Month> for u8>::from(p0);
+<u8>::from(p0);
-----------------
src/month.rs <month::Month as std::convert::TryFrom<u8>>::try_from
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
+<month::Month as std::convert::TryFrom<u8>>::try_from(p0);
+crate::<month::Month as std::convert::TryFrom<u8>>::try_from(p0);
+<month::Month>::try_from(p0);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<offset_date_time::OffsetDateTime as std::fmt::Debug>::fmt(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::fmt::Debug>::fmt(p0, p1);
+<offset_date_time::OffsetDateTime>::fmt(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.clone();
+<offset_date_time::OffsetDateTime as std::clone::Clone>::clone(p0);
+crate::<offset_date_time::OffsetDateTime as std::clone::Clone>::clone(p0);
+<offset_date_time::OffsetDateTime>::clone(p0);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.assert_receiver_is_total_eq();
+<offset_date_time::OffsetDateTime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<offset_date_time::OffsetDateTime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<offset_date_time::OffsetDateTime>::assert_receiver_is_total_eq(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::now_utc
deps:{}
candidates:{}
+offset_date_time::OffsetDateTime::now_utc();
+crate::offset_date_time::OffsetDateTime::now_utc();
+<offset_date_time::OffsetDateTime>::now_utc();
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::to_offset
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.to_offset(p1);
+offset_date_time::OffsetDateTime::to_offset(p0, p1);
+crate::offset_date_time::OffsetDateTime::to_offset(p0, p1);
+<offset_date_time::OffsetDateTime>::to_offset(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::from_unix_timestamp
deps:{}
candidates:{}
let mut p0 = 0i64; // None+i64
+offset_date_time::OffsetDateTime::from_unix_timestamp(p0);
+crate::offset_date_time::OffsetDateTime::from_unix_timestamp(p0);
+<offset_date_time::OffsetDateTime>::from_unix_timestamp(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::from_unix_timestamp_nanos
deps:{}
candidates:{}
let mut p0 = 0i128; // None+i128
+offset_date_time::OffsetDateTime::from_unix_timestamp_nanos(p0);
+crate::offset_date_time::OffsetDateTime::from_unix_timestamp_nanos(p0);
+<offset_date_time::OffsetDateTime>::from_unix_timestamp_nanos(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::offset
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.offset();
+offset_date_time::OffsetDateTime::offset(p0);
+crate::offset_date_time::OffsetDateTime::offset(p0);
+<offset_date_time::OffsetDateTime>::offset(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::unix_timestamp
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.unix_timestamp();
+offset_date_time::OffsetDateTime::unix_timestamp(p0);
+crate::offset_date_time::OffsetDateTime::unix_timestamp(p0);
+<offset_date_time::OffsetDateTime>::unix_timestamp(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::unix_timestamp_nanos
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.unix_timestamp_nanos();
+offset_date_time::OffsetDateTime::unix_timestamp_nanos(p0);
+crate::offset_date_time::OffsetDateTime::unix_timestamp_nanos(p0);
+<offset_date_time::OffsetDateTime>::unix_timestamp_nanos(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.date();
+offset_date_time::OffsetDateTime::date(p0);
+crate::offset_date_time::OffsetDateTime::date(p0);
+<offset_date_time::OffsetDateTime>::date(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::time
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.time();
+offset_date_time::OffsetDateTime::time(p0);
+crate::offset_date_time::OffsetDateTime::time(p0);
+<offset_date_time::OffsetDateTime>::time(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::year
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.year();
+offset_date_time::OffsetDateTime::year(p0);
+crate::offset_date_time::OffsetDateTime::year(p0);
+<offset_date_time::OffsetDateTime>::year(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::month
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.month();
+offset_date_time::OffsetDateTime::month(p0);
+crate::offset_date_time::OffsetDateTime::month(p0);
+<offset_date_time::OffsetDateTime>::month(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::day
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.day();
+offset_date_time::OffsetDateTime::day(p0);
+crate::offset_date_time::OffsetDateTime::day(p0);
+<offset_date_time::OffsetDateTime>::day(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::ordinal
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.ordinal();
+offset_date_time::OffsetDateTime::ordinal(p0);
+crate::offset_date_time::OffsetDateTime::ordinal(p0);
+<offset_date_time::OffsetDateTime>::ordinal(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::iso_week
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.iso_week();
+offset_date_time::OffsetDateTime::iso_week(p0);
+crate::offset_date_time::OffsetDateTime::iso_week(p0);
+<offset_date_time::OffsetDateTime>::iso_week(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::sunday_based_week
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.sunday_based_week();
+offset_date_time::OffsetDateTime::sunday_based_week(p0);
+crate::offset_date_time::OffsetDateTime::sunday_based_week(p0);
+<offset_date_time::OffsetDateTime>::sunday_based_week(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::monday_based_week
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.monday_based_week();
+offset_date_time::OffsetDateTime::monday_based_week(p0);
+crate::offset_date_time::OffsetDateTime::monday_based_week(p0);
+<offset_date_time::OffsetDateTime>::monday_based_week(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::to_calendar_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.to_calendar_date();
+offset_date_time::OffsetDateTime::to_calendar_date(p0);
+crate::offset_date_time::OffsetDateTime::to_calendar_date(p0);
+<offset_date_time::OffsetDateTime>::to_calendar_date(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::to_ordinal_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.to_ordinal_date();
+offset_date_time::OffsetDateTime::to_ordinal_date(p0);
+crate::offset_date_time::OffsetDateTime::to_ordinal_date(p0);
+<offset_date_time::OffsetDateTime>::to_ordinal_date(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::to_iso_week_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.to_iso_week_date();
+offset_date_time::OffsetDateTime::to_iso_week_date(p0);
+crate::offset_date_time::OffsetDateTime::to_iso_week_date(p0);
+<offset_date_time::OffsetDateTime>::to_iso_week_date(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::weekday
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.weekday();
+offset_date_time::OffsetDateTime::weekday(p0);
+crate::offset_date_time::OffsetDateTime::weekday(p0);
+<offset_date_time::OffsetDateTime>::weekday(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::to_julian_day
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.to_julian_day();
+offset_date_time::OffsetDateTime::to_julian_day(p0);
+crate::offset_date_time::OffsetDateTime::to_julian_day(p0);
+<offset_date_time::OffsetDateTime>::to_julian_day(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::to_hms
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.to_hms();
+offset_date_time::OffsetDateTime::to_hms(p0);
+crate::offset_date_time::OffsetDateTime::to_hms(p0);
+<offset_date_time::OffsetDateTime>::to_hms(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::to_hms_milli
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.to_hms_milli();
+offset_date_time::OffsetDateTime::to_hms_milli(p0);
+crate::offset_date_time::OffsetDateTime::to_hms_milli(p0);
+<offset_date_time::OffsetDateTime>::to_hms_milli(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::to_hms_micro
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.to_hms_micro();
+offset_date_time::OffsetDateTime::to_hms_micro(p0);
+crate::offset_date_time::OffsetDateTime::to_hms_micro(p0);
+<offset_date_time::OffsetDateTime>::to_hms_micro(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::to_hms_nano
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.to_hms_nano();
+offset_date_time::OffsetDateTime::to_hms_nano(p0);
+crate::offset_date_time::OffsetDateTime::to_hms_nano(p0);
+<offset_date_time::OffsetDateTime>::to_hms_nano(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::hour
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.hour();
+offset_date_time::OffsetDateTime::hour(p0);
+crate::offset_date_time::OffsetDateTime::hour(p0);
+<offset_date_time::OffsetDateTime>::hour(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::minute
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.minute();
+offset_date_time::OffsetDateTime::minute(p0);
+crate::offset_date_time::OffsetDateTime::minute(p0);
+<offset_date_time::OffsetDateTime>::minute(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::second
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.second();
+offset_date_time::OffsetDateTime::second(p0);
+crate::offset_date_time::OffsetDateTime::second(p0);
+<offset_date_time::OffsetDateTime>::second(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::millisecond
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.millisecond();
+offset_date_time::OffsetDateTime::millisecond(p0);
+crate::offset_date_time::OffsetDateTime::millisecond(p0);
+<offset_date_time::OffsetDateTime>::millisecond(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::microsecond
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.microsecond();
+offset_date_time::OffsetDateTime::microsecond(p0);
+crate::offset_date_time::OffsetDateTime::microsecond(p0);
+<offset_date_time::OffsetDateTime>::microsecond(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::nanosecond
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.nanosecond();
+offset_date_time::OffsetDateTime::nanosecond(p0);
+crate::offset_date_time::OffsetDateTime::nanosecond(p0);
+<offset_date_time::OffsetDateTime>::nanosecond(p0);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::checked_add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.checked_add(p1);
+offset_date_time::OffsetDateTime::checked_add(p0, p1);
+crate::offset_date_time::OffsetDateTime::checked_add(p0, p1);
+<offset_date_time::OffsetDateTime>::checked_add(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::checked_sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.checked_sub(p1);
+offset_date_time::OffsetDateTime::checked_sub(p0, p1);
+crate::offset_date_time::OffsetDateTime::checked_sub(p0, p1);
+<offset_date_time::OffsetDateTime>::checked_sub(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::saturating_add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.saturating_add(p1);
+offset_date_time::OffsetDateTime::saturating_add(p0, p1);
+crate::offset_date_time::OffsetDateTime::saturating_add(p0, p1);
+<offset_date_time::OffsetDateTime>::saturating_add(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::saturating_sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.saturating_sub(p1);
+offset_date_time::OffsetDateTime::saturating_sub(p0, p1);
+crate::offset_date_time::OffsetDateTime::saturating_sub(p0, p1);
+<offset_date_time::OffsetDateTime>::saturating_sub(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::replace_time
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.replace_time(p1);
+offset_date_time::OffsetDateTime::replace_time(p0, p1);
+crate::offset_date_time::OffsetDateTime::replace_time(p0, p1);
+<offset_date_time::OffsetDateTime>::replace_time(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::replace_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.replace_date(p1);
+offset_date_time::OffsetDateTime::replace_date(p0, p1);
+crate::offset_date_time::OffsetDateTime::replace_date(p0, p1);
+<offset_date_time::OffsetDateTime>::replace_date(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::replace_date_time
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.replace_date_time(p1);
+offset_date_time::OffsetDateTime::replace_date_time(p0, p1);
+crate::offset_date_time::OffsetDateTime::replace_date_time(p0, p1);
+<offset_date_time::OffsetDateTime>::replace_date_time(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::OffsetDateTime::replace_offset
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.replace_offset(p1);
+offset_date_time::OffsetDateTime::replace_offset(p0, p1);
+crate::offset_date_time::OffsetDateTime::replace_offset(p0, p1);
+<offset_date_time::OffsetDateTime>::replace_offset(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<offset_date_time::OffsetDateTime as std::fmt::Display>::fmt(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::fmt::Display>::fmt(p0, p1);
+<offset_date_time::OffsetDateTime>::fmt(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.eq(p1);
+<offset_date_time::OffsetDateTime as std::cmp::PartialEq>::eq(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::cmp::PartialEq>::eq(p0, p1);
+<offset_date_time::OffsetDateTime>::eq(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.partial_cmp(p1);
+<offset_date_time::OffsetDateTime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<offset_date_time::OffsetDateTime>::partial_cmp(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.cmp(p1);
+<offset_date_time::OffsetDateTime as std::cmp::Ord>::cmp(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::cmp::Ord>::cmp(p0, p1);
+<offset_date_time::OffsetDateTime>::cmp(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<offset_date_time::OffsetDateTime as std::hash::Hash>::hash":{"H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<offset_date_time::OffsetDateTime as std::hash::Hash>::hash":{"H":["<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher13","std::hash::SipHasher","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // H
+p0.hash(p1);
+<offset_date_time::OffsetDateTime as std::hash::Hash>::hash(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::hash::Hash>::hash(p0, p1);
+<offset_date_time::OffsetDateTime>::hash(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::ops::Add<T>>::add
deps:{"<&'a std::num::Saturating<i128> as std::ops::Add<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Add<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Add<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Add<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Add<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Add<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Add<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Add<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Add<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Add<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Add<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Add<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Add<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Add<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Add<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Add<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Add<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Add<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Add<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Add<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Add<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Add<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Add<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Add<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Add<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Add<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Add<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Add<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Add<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Add<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Add<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Add<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Add<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Add<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Add<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Add<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Add<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Add<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Add<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Add<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Add<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Add<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Add<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Add<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Add<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Add<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Add<&std::num::Wrapping<usize>>>":{},"<offset_date_time::OffsetDateTime as std::ops::Add<T>>::add":{"T":["std::marker::Sized"],"primitive_date_time::PrimitiveDateTime":["std::ops::Add"]},"core::core_simd::ops::deref::<impl std::ops::Add<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Add<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Add<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Add<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Add<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Add<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Add<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Add<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Add<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Add<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Add<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Add<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Add<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Add<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Add<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Add<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Add<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Add<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Add<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Add<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Add<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Add<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Add<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Add<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Add<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Add<std::num::Wrapping<usize>>>":{},"<&std::num::Saturating<i128> as std::ops::Add<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Add<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Add<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Add<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Add<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Add<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Add<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Add<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Add<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Add<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Add<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Add<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Add<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Add<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Add<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Add<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Add<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Add<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Add<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Add<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Add<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Add<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Add<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Add<&std::num::Wrapping<usize>>>":{},"<offset_date_time::OffsetDateTime as std::ops::Add<T>>::add":{"T":["RUG_ANY"],"primitive_date_time::PrimitiveDateTime":["<&std::num::Saturating<u16> as std::ops::Add<&std::num::Saturating<u16>>>","offset_date_time::OffsetDateTime"]},"core::core_simd::ops::deref::<impl std::ops::Add<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Add<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.add(p1);
+<offset_date_time::OffsetDateTime as std::ops::Add<T>>::add(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::ops::Add<T>>::add(p0, p1);
+<offset_date_time::OffsetDateTime>::add(p0, p1);
-----------------
src/lib.rs <offset_date_time::OffsetDateTime as std::ops::AddAssign<duration::Duration>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add_assign(p1);
+<offset_date_time::OffsetDateTime as std::ops::AddAssign<duration::Duration>>::add_assign(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::ops::AddAssign<duration::Duration>>::add_assign(p0, p1);
+<offset_date_time::OffsetDateTime>::add_assign(p0, p1);
-----------------
src/lib.rs <offset_date_time::OffsetDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.add_assign(p1);
+<offset_date_time::OffsetDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign(p0, p1);
+<offset_date_time::OffsetDateTime>::add_assign(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::ops::Sub<T>>::sub
deps:{"<&'a std::num::Saturating<i128> as std::ops::Sub<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Sub<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Sub<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Sub<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Sub<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Sub<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Sub<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Sub<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Sub<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Sub<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Sub<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Sub<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Sub<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Sub<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Sub<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Sub<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Sub<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Sub<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Sub<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Sub<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Sub<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Sub<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Sub<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Sub<std::num::Wrapping<usize>>>":{},"<&hashbrown::set::HashSet<T, S> as std::ops::Sub<&hashbrown::set::HashSet<T, S>>>":{},"<&std::collections::BTreeSet<T, A> as std::ops::Sub<&std::collections::BTreeSet<T, A>>>":{},"<&std::collections::HashSet<T, S> as std::ops::Sub<&std::collections::HashSet<T, S>>>":{},"<&std::num::Saturating<i128> as std::ops::Sub<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Sub<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Sub<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Sub<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Sub<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Sub<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Sub<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Sub<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Sub<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Sub<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Sub<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Sub<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Sub<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Sub<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Sub<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Sub<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Sub<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Sub<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Sub<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Sub<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Sub<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Sub<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Sub<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Sub<&std::num::Wrapping<usize>>>":{},"<offset_date_time::OffsetDateTime as std::ops::Sub<T>>::sub":{"T":["std::marker::Sized"],"primitive_date_time::PrimitiveDateTime":["std::ops::Sub"]},"core::core_simd::ops::deref::<impl std::ops::Sub<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Sub<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{}}
candidates:{"<&'a std::num::Saturating<i128> as std::ops::Sub<std::num::Saturating<i128>>>":{},"<&'a std::num::Saturating<i16> as std::ops::Sub<std::num::Saturating<i16>>>":{},"<&'a std::num::Saturating<i32> as std::ops::Sub<std::num::Saturating<i32>>>":{},"<&'a std::num::Saturating<i64> as std::ops::Sub<std::num::Saturating<i64>>>":{},"<&'a std::num::Saturating<i8> as std::ops::Sub<std::num::Saturating<i8>>>":{},"<&'a std::num::Saturating<isize> as std::ops::Sub<std::num::Saturating<isize>>>":{},"<&'a std::num::Saturating<u128> as std::ops::Sub<std::num::Saturating<u128>>>":{},"<&'a std::num::Saturating<u16> as std::ops::Sub<std::num::Saturating<u16>>>":{},"<&'a std::num::Saturating<u32> as std::ops::Sub<std::num::Saturating<u32>>>":{},"<&'a std::num::Saturating<u64> as std::ops::Sub<std::num::Saturating<u64>>>":{},"<&'a std::num::Saturating<u8> as std::ops::Sub<std::num::Saturating<u8>>>":{},"<&'a std::num::Saturating<usize> as std::ops::Sub<std::num::Saturating<usize>>>":{},"<&'a std::num::Wrapping<i128> as std::ops::Sub<std::num::Wrapping<i128>>>":{},"<&'a std::num::Wrapping<i16> as std::ops::Sub<std::num::Wrapping<i16>>>":{},"<&'a std::num::Wrapping<i32> as std::ops::Sub<std::num::Wrapping<i32>>>":{},"<&'a std::num::Wrapping<i64> as std::ops::Sub<std::num::Wrapping<i64>>>":{},"<&'a std::num::Wrapping<i8> as std::ops::Sub<std::num::Wrapping<i8>>>":{},"<&'a std::num::Wrapping<isize> as std::ops::Sub<std::num::Wrapping<isize>>>":{},"<&'a std::num::Wrapping<u128> as std::ops::Sub<std::num::Wrapping<u128>>>":{},"<&'a std::num::Wrapping<u16> as std::ops::Sub<std::num::Wrapping<u16>>>":{},"<&'a std::num::Wrapping<u32> as std::ops::Sub<std::num::Wrapping<u32>>>":{},"<&'a std::num::Wrapping<u64> as std::ops::Sub<std::num::Wrapping<u64>>>":{},"<&'a std::num::Wrapping<u8> as std::ops::Sub<std::num::Wrapping<u8>>>":{},"<&'a std::num::Wrapping<usize> as std::ops::Sub<std::num::Wrapping<usize>>>":{},"<&hashbrown::set::HashSet<T, S> as std::ops::Sub<&hashbrown::set::HashSet<T, S>>>":{},"<&std::collections::BTreeSet<T, A> as std::ops::Sub<&std::collections::BTreeSet<T, A>>>":{},"<&std::collections::HashSet<T, S> as std::ops::Sub<&std::collections::HashSet<T, S>>>":{},"<&std::num::Saturating<i128> as std::ops::Sub<&std::num::Saturating<i128>>>":{},"<&std::num::Saturating<i16> as std::ops::Sub<&std::num::Saturating<i16>>>":{},"<&std::num::Saturating<i32> as std::ops::Sub<&std::num::Saturating<i32>>>":{},"<&std::num::Saturating<i64> as std::ops::Sub<&std::num::Saturating<i64>>>":{},"<&std::num::Saturating<i8> as std::ops::Sub<&std::num::Saturating<i8>>>":{},"<&std::num::Saturating<isize> as std::ops::Sub<&std::num::Saturating<isize>>>":{},"<&std::num::Saturating<u128> as std::ops::Sub<&std::num::Saturating<u128>>>":{},"<&std::num::Saturating<u16> as std::ops::Sub<&std::num::Saturating<u16>>>":{},"<&std::num::Saturating<u32> as std::ops::Sub<&std::num::Saturating<u32>>>":{},"<&std::num::Saturating<u64> as std::ops::Sub<&std::num::Saturating<u64>>>":{},"<&std::num::Saturating<u8> as std::ops::Sub<&std::num::Saturating<u8>>>":{},"<&std::num::Saturating<usize> as std::ops::Sub<&std::num::Saturating<usize>>>":{},"<&std::num::Wrapping<i128> as std::ops::Sub<&std::num::Wrapping<i128>>>":{},"<&std::num::Wrapping<i16> as std::ops::Sub<&std::num::Wrapping<i16>>>":{},"<&std::num::Wrapping<i32> as std::ops::Sub<&std::num::Wrapping<i32>>>":{},"<&std::num::Wrapping<i64> as std::ops::Sub<&std::num::Wrapping<i64>>>":{},"<&std::num::Wrapping<i8> as std::ops::Sub<&std::num::Wrapping<i8>>>":{},"<&std::num::Wrapping<isize> as std::ops::Sub<&std::num::Wrapping<isize>>>":{},"<&std::num::Wrapping<u128> as std::ops::Sub<&std::num::Wrapping<u128>>>":{},"<&std::num::Wrapping<u16> as std::ops::Sub<&std::num::Wrapping<u16>>>":{},"<&std::num::Wrapping<u32> as std::ops::Sub<&std::num::Wrapping<u32>>>":{},"<&std::num::Wrapping<u64> as std::ops::Sub<&std::num::Wrapping<u64>>>":{},"<&std::num::Wrapping<u8> as std::ops::Sub<&std::num::Wrapping<u8>>>":{},"<&std::num::Wrapping<usize> as std::ops::Sub<&std::num::Wrapping<usize>>>":{},"<offset_date_time::OffsetDateTime as std::ops::Sub<T>>::sub":{"T":["RUG_ANY"],"primitive_date_time::PrimitiveDateTime":["std::simd::Simd<u16, N>","std::simd::Simd<i16, N>","std::simd::Simd<usize, N>","std::simd::Simd<T, LANES>","std::simd::Simd<u32, N>","std::simd::Simd<u8, N>","std::simd::Simd<u64, N>","std::mem::Assume","<&std::num::Saturating<u128> as std::ops::Sub<&std::num::Saturating<u128>>>","std::simd::Simd<i8, N>","std::simd::Simd<f32, N>","std::simd::Simd<isize, N>","std::simd::Simd<i64, N>","std::simd::Simd<f64, N>","std::simd::Simd<i32, N>"]},"core::core_simd::ops::deref::<impl std::ops::Sub<&'rhs std::simd::Simd<T, LANES>> for &'lhs std::simd::Simd<T, LANES>>":{},"core::core_simd::ops::deref::<impl std::ops::Sub<std::simd::Simd<T, LANES>> for &std::simd::Simd<T, LANES>>":{}}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // T
+p0.sub(p1);
+<offset_date_time::OffsetDateTime as std::ops::Sub<T>>::sub(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::ops::Sub<T>>::sub(p0, p1);
+<offset_date_time::OffsetDateTime>::sub(p0, p1);
-----------------
src/lib.rs <offset_date_time::OffsetDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub_assign(p1);
+<offset_date_time::OffsetDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign(p0, p1);
+<offset_date_time::OffsetDateTime>::sub_assign(p0, p1);
-----------------
src/lib.rs <offset_date_time::OffsetDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.sub_assign(p1);
+<offset_date_time::OffsetDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign(p0, p1);
+<offset_date_time::OffsetDateTime>::sub_assign(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::ops::Sub>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.sub(p1);
+<offset_date_time::OffsetDateTime as std::ops::Sub>::sub(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::ops::Sub>::sub(p0, p1);
+<offset_date_time::OffsetDateTime>::sub(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::<impl std::ops::Add<duration::Duration> for std::time::SystemTime>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::SystemTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add(p1);
+offset_date_time::<impl std::ops::Add<duration::Duration> for std::time::SystemTime>::add(p0, p1);
+crate::offset_date_time::<impl std::ops::Add<duration::Duration> for std::time::SystemTime>::add(p0, p1);
+<std::time::SystemTime>::add(p0, p1);
-----------------
src/lib.rs offset_date_time::<impl std::ops::AddAssign<duration::Duration> for std::time::SystemTime>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::time::SystemTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add_assign(p1);
+offset_date_time::<impl std::ops::AddAssign<duration::Duration> for std::time::SystemTime>::add_assign(p0, p1);
+crate::offset_date_time::<impl std::ops::AddAssign<duration::Duration> for std::time::SystemTime>::add_assign(p0, p1);
+<std::time::SystemTime>::add_assign(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::<impl std::ops::Sub<duration::Duration> for std::time::SystemTime>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::SystemTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub(p1);
+offset_date_time::<impl std::ops::Sub<duration::Duration> for std::time::SystemTime>::sub(p0, p1);
+crate::offset_date_time::<impl std::ops::Sub<duration::Duration> for std::time::SystemTime>::sub(p0, p1);
+<std::time::SystemTime>::sub(p0, p1);
-----------------
src/lib.rs offset_date_time::<impl std::ops::SubAssign<duration::Duration> for std::time::SystemTime>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // std::time::SystemTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub_assign(p1);
+offset_date_time::<impl std::ops::SubAssign<duration::Duration> for std::time::SystemTime>::sub_assign(p0, p1);
+crate::offset_date_time::<impl std::ops::SubAssign<duration::Duration> for std::time::SystemTime>::sub_assign(p0, p1);
+<std::time::SystemTime>::sub_assign(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::ops::Sub<std::time::SystemTime>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::SystemTime
+p0.sub(p1);
+<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::SystemTime>>::sub(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::ops::Sub<std::time::SystemTime>>::sub(p0, p1);
+<offset_date_time::OffsetDateTime>::sub(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::<impl std::ops::Sub<offset_date_time::OffsetDateTime> for std::time::SystemTime>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::SystemTime
let mut p1 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.sub(p1);
+offset_date_time::<impl std::ops::Sub<offset_date_time::OffsetDateTime> for std::time::SystemTime>::sub(p0, p1);
+crate::offset_date_time::<impl std::ops::Sub<offset_date_time::OffsetDateTime> for std::time::SystemTime>::sub(p0, p1);
+<std::time::SystemTime>::sub(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::time::SystemTime
+p0.eq(p1);
+<offset_date_time::OffsetDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::cmp::PartialEq<std::time::SystemTime>>::eq(p0, p1);
+<offset_date_time::OffsetDateTime>::eq(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::<impl std::cmp::PartialEq<offset_date_time::OffsetDateTime> for std::time::SystemTime>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::time::SystemTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.eq(p1);
+offset_date_time::<impl std::cmp::PartialEq<offset_date_time::OffsetDateTime> for std::time::SystemTime>::eq(p0, p1);
+crate::offset_date_time::<impl std::cmp::PartialEq<offset_date_time::OffsetDateTime> for std::time::SystemTime>::eq(p0, p1);
+<std::time::SystemTime>::eq(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // std::time::SystemTime
+p0.partial_cmp(p1);
+<offset_date_time::OffsetDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp(p0, p1);
+crate::<offset_date_time::OffsetDateTime as std::cmp::PartialOrd<std::time::SystemTime>>::partial_cmp(p0, p1);
+<offset_date_time::OffsetDateTime>::partial_cmp(p0, p1);
-----------------
src/offset_date_time.rs offset_date_time::<impl std::cmp::PartialOrd<offset_date_time::OffsetDateTime> for std::time::SystemTime>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // std::time::SystemTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+p0.partial_cmp(p1);
+offset_date_time::<impl std::cmp::PartialOrd<offset_date_time::OffsetDateTime> for std::time::SystemTime>::partial_cmp(p0, p1);
+crate::offset_date_time::<impl std::cmp::PartialOrd<offset_date_time::OffsetDateTime> for std::time::SystemTime>::partial_cmp(p0, p1);
+<std::time::SystemTime>::partial_cmp(p0, p1);
-----------------
src/offset_date_time.rs <offset_date_time::OffsetDateTime as std::convert::From<std::time::SystemTime>>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // std::time::SystemTime
+<offset_date_time::OffsetDateTime as std::convert::From<std::time::SystemTime>>::from(p0);
+crate::<offset_date_time::OffsetDateTime as std::convert::From<std::time::SystemTime>>::from(p0);
+<offset_date_time::OffsetDateTime>::from(p0);
-----------------
src/offset_date_time.rs offset_date_time::<impl std::convert::From<offset_date_time::OffsetDateTime> for std::time::SystemTime>::from
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // offset_date_time::OffsetDateTime
+offset_date_time::<impl std::convert::From<offset_date_time::OffsetDateTime> for std::time::SystemTime>::from(p0);
+crate::offset_date_time::<impl std::convert::From<offset_date_time::OffsetDateTime> for std::time::SystemTime>::from(p0);
+<std::time::SystemTime>::from(p0);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<primitive_date_time::PrimitiveDateTime as std::fmt::Debug>::fmt(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::fmt::Debug>::fmt(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::fmt(p0, p1);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.clone();
+<primitive_date_time::PrimitiveDateTime as std::clone::Clone>::clone(p0);
+crate::<primitive_date_time::PrimitiveDateTime as std::clone::Clone>::clone(p0);
+<primitive_date_time::PrimitiveDateTime>::clone(p0);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.eq(p1);
+<primitive_date_time::PrimitiveDateTime as std::cmp::PartialEq>::eq(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::cmp::PartialEq>::eq(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::eq(p0, p1);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.assert_receiver_is_total_eq();
+<primitive_date_time::PrimitiveDateTime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<primitive_date_time::PrimitiveDateTime as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<primitive_date_time::PrimitiveDateTime>::assert_receiver_is_total_eq(p0);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<primitive_date_time::PrimitiveDateTime as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<primitive_date_time::PrimitiveDateTime as std::hash::Hash>::hash":{"__H":["std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<primitive_date_time::PrimitiveDateTime as std::hash::Hash>::hash(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::hash::Hash>::hash(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::hash(p0, p1);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.partial_cmp(p1);
+<primitive_date_time::PrimitiveDateTime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::partial_cmp(p0, p1);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = & MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.cmp(p1);
+<primitive_date_time::PrimitiveDateTime as std::cmp::Ord>::cmp(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::cmp::Ord>::cmp(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::cmp(p0, p1);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::new
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // date::Date
let mut p1 = MaybeUninit::uninit().assume_init(); // time::Time
+primitive_date_time::PrimitiveDateTime::new(p0, p1);
+crate::primitive_date_time::PrimitiveDateTime::new(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::new(p0, p1);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.date();
+primitive_date_time::PrimitiveDateTime::date(p0);
+crate::primitive_date_time::PrimitiveDateTime::date(p0);
+<primitive_date_time::PrimitiveDateTime>::date(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::time
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.time();
+primitive_date_time::PrimitiveDateTime::time(p0);
+crate::primitive_date_time::PrimitiveDateTime::time(p0);
+<primitive_date_time::PrimitiveDateTime>::time(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::year
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.year();
+primitive_date_time::PrimitiveDateTime::year(p0);
+crate::primitive_date_time::PrimitiveDateTime::year(p0);
+<primitive_date_time::PrimitiveDateTime>::year(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::month
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.month();
+primitive_date_time::PrimitiveDateTime::month(p0);
+crate::primitive_date_time::PrimitiveDateTime::month(p0);
+<primitive_date_time::PrimitiveDateTime>::month(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::day
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.day();
+primitive_date_time::PrimitiveDateTime::day(p0);
+crate::primitive_date_time::PrimitiveDateTime::day(p0);
+<primitive_date_time::PrimitiveDateTime>::day(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::ordinal
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.ordinal();
+primitive_date_time::PrimitiveDateTime::ordinal(p0);
+crate::primitive_date_time::PrimitiveDateTime::ordinal(p0);
+<primitive_date_time::PrimitiveDateTime>::ordinal(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::iso_week
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.iso_week();
+primitive_date_time::PrimitiveDateTime::iso_week(p0);
+crate::primitive_date_time::PrimitiveDateTime::iso_week(p0);
+<primitive_date_time::PrimitiveDateTime>::iso_week(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::sunday_based_week
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.sunday_based_week();
+primitive_date_time::PrimitiveDateTime::sunday_based_week(p0);
+crate::primitive_date_time::PrimitiveDateTime::sunday_based_week(p0);
+<primitive_date_time::PrimitiveDateTime>::sunday_based_week(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::monday_based_week
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.monday_based_week();
+primitive_date_time::PrimitiveDateTime::monday_based_week(p0);
+crate::primitive_date_time::PrimitiveDateTime::monday_based_week(p0);
+<primitive_date_time::PrimitiveDateTime>::monday_based_week(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::to_calendar_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.to_calendar_date();
+primitive_date_time::PrimitiveDateTime::to_calendar_date(p0);
+crate::primitive_date_time::PrimitiveDateTime::to_calendar_date(p0);
+<primitive_date_time::PrimitiveDateTime>::to_calendar_date(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::to_ordinal_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.to_ordinal_date();
+primitive_date_time::PrimitiveDateTime::to_ordinal_date(p0);
+crate::primitive_date_time::PrimitiveDateTime::to_ordinal_date(p0);
+<primitive_date_time::PrimitiveDateTime>::to_ordinal_date(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::to_iso_week_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.to_iso_week_date();
+primitive_date_time::PrimitiveDateTime::to_iso_week_date(p0);
+crate::primitive_date_time::PrimitiveDateTime::to_iso_week_date(p0);
+<primitive_date_time::PrimitiveDateTime>::to_iso_week_date(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::weekday
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.weekday();
+primitive_date_time::PrimitiveDateTime::weekday(p0);
+crate::primitive_date_time::PrimitiveDateTime::weekday(p0);
+<primitive_date_time::PrimitiveDateTime>::weekday(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::to_julian_day
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.to_julian_day();
+primitive_date_time::PrimitiveDateTime::to_julian_day(p0);
+crate::primitive_date_time::PrimitiveDateTime::to_julian_day(p0);
+<primitive_date_time::PrimitiveDateTime>::to_julian_day(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::as_hms
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.as_hms();
+primitive_date_time::PrimitiveDateTime::as_hms(p0);
+crate::primitive_date_time::PrimitiveDateTime::as_hms(p0);
+<primitive_date_time::PrimitiveDateTime>::as_hms(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::as_hms_milli
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.as_hms_milli();
+primitive_date_time::PrimitiveDateTime::as_hms_milli(p0);
+crate::primitive_date_time::PrimitiveDateTime::as_hms_milli(p0);
+<primitive_date_time::PrimitiveDateTime>::as_hms_milli(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::as_hms_micro
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.as_hms_micro();
+primitive_date_time::PrimitiveDateTime::as_hms_micro(p0);
+crate::primitive_date_time::PrimitiveDateTime::as_hms_micro(p0);
+<primitive_date_time::PrimitiveDateTime>::as_hms_micro(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::as_hms_nano
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.as_hms_nano();
+primitive_date_time::PrimitiveDateTime::as_hms_nano(p0);
+crate::primitive_date_time::PrimitiveDateTime::as_hms_nano(p0);
+<primitive_date_time::PrimitiveDateTime>::as_hms_nano(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::hour
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.hour();
+primitive_date_time::PrimitiveDateTime::hour(p0);
+crate::primitive_date_time::PrimitiveDateTime::hour(p0);
+<primitive_date_time::PrimitiveDateTime>::hour(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::minute
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.minute();
+primitive_date_time::PrimitiveDateTime::minute(p0);
+crate::primitive_date_time::PrimitiveDateTime::minute(p0);
+<primitive_date_time::PrimitiveDateTime>::minute(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::second
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.second();
+primitive_date_time::PrimitiveDateTime::second(p0);
+crate::primitive_date_time::PrimitiveDateTime::second(p0);
+<primitive_date_time::PrimitiveDateTime>::second(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::millisecond
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.millisecond();
+primitive_date_time::PrimitiveDateTime::millisecond(p0);
+crate::primitive_date_time::PrimitiveDateTime::millisecond(p0);
+<primitive_date_time::PrimitiveDateTime>::millisecond(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::microsecond
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.microsecond();
+primitive_date_time::PrimitiveDateTime::microsecond(p0);
+crate::primitive_date_time::PrimitiveDateTime::microsecond(p0);
+<primitive_date_time::PrimitiveDateTime>::microsecond(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::nanosecond
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.nanosecond();
+primitive_date_time::PrimitiveDateTime::nanosecond(p0);
+crate::primitive_date_time::PrimitiveDateTime::nanosecond(p0);
+<primitive_date_time::PrimitiveDateTime>::nanosecond(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::assume_offset
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.assume_offset(p1);
+primitive_date_time::PrimitiveDateTime::assume_offset(p0, p1);
+crate::primitive_date_time::PrimitiveDateTime::assume_offset(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::assume_offset(p0, p1);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::assume_utc
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.assume_utc();
+primitive_date_time::PrimitiveDateTime::assume_utc(p0);
+crate::primitive_date_time::PrimitiveDateTime::assume_utc(p0);
+<primitive_date_time::PrimitiveDateTime>::assume_utc(p0);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::checked_add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.checked_add(p1);
+primitive_date_time::PrimitiveDateTime::checked_add(p0, p1);
+crate::primitive_date_time::PrimitiveDateTime::checked_add(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::checked_add(p0, p1);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::checked_sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.checked_sub(p1);
+primitive_date_time::PrimitiveDateTime::checked_sub(p0, p1);
+crate::primitive_date_time::PrimitiveDateTime::checked_sub(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::checked_sub(p0, p1);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::saturating_add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.saturating_add(p1);
+primitive_date_time::PrimitiveDateTime::saturating_add(p0, p1);
+crate::primitive_date_time::PrimitiveDateTime::saturating_add(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::saturating_add(p0, p1);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::saturating_sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.saturating_sub(p1);
+primitive_date_time::PrimitiveDateTime::saturating_sub(p0, p1);
+crate::primitive_date_time::PrimitiveDateTime::saturating_sub(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::saturating_sub(p0, p1);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::replace_time
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.replace_time(p1);
+primitive_date_time::PrimitiveDateTime::replace_time(p0, p1);
+crate::primitive_date_time::PrimitiveDateTime::replace_time(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::replace_time(p0, p1);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::replace_date
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // date::Date
+p0.replace_date(p1);
+primitive_date_time::PrimitiveDateTime::replace_date(p0, p1);
+crate::primitive_date_time::PrimitiveDateTime::replace_date(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::replace_date(p0, p1);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::offset_to_utc
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.offset_to_utc(p1);
+primitive_date_time::PrimitiveDateTime::offset_to_utc(p0, p1);
+crate::primitive_date_time::PrimitiveDateTime::offset_to_utc(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::offset_to_utc(p0, p1);
-----------------
src/primitive_date_time.rs primitive_date_time::PrimitiveDateTime::utc_to_offset
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.utc_to_offset(p1);
+primitive_date_time::PrimitiveDateTime::utc_to_offset(p0, p1);
+crate::primitive_date_time::PrimitiveDateTime::utc_to_offset(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::utc_to_offset(p0, p1);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<primitive_date_time::PrimitiveDateTime as std::fmt::Display>::fmt(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::fmt::Display>::fmt(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::fmt(p0, p1);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::ops::Add<duration::Duration>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add(p1);
+<primitive_date_time::PrimitiveDateTime as std::ops::Add<duration::Duration>>::add(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::ops::Add<duration::Duration>>::add(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::add(p0, p1);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::ops::Add<std::time::Duration>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.add(p1);
+<primitive_date_time::PrimitiveDateTime as std::ops::Add<std::time::Duration>>::add(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::ops::Add<std::time::Duration>>::add(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::add(p0, p1);
-----------------
src/lib.rs <primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<duration::Duration>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add_assign(p1);
+<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<duration::Duration>>::add_assign(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<duration::Duration>>::add_assign(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::add_assign(p0, p1);
-----------------
src/lib.rs <primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.add_assign(p1);
+<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::ops::AddAssign<std::time::Duration>>::add_assign(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::add_assign(p0, p1);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::ops::Sub<duration::Duration>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub(p1);
+<primitive_date_time::PrimitiveDateTime as std::ops::Sub<duration::Duration>>::sub(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::ops::Sub<duration::Duration>>::sub(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::sub(p0, p1);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::Duration>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.sub(p1);
+<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::Duration>>::sub(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::ops::Sub<std::time::Duration>>::sub(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::sub(p0, p1);
-----------------
src/lib.rs <primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub_assign(p1);
+<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<duration::Duration>>::sub_assign(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::sub_assign(p0, p1);
-----------------
src/lib.rs <primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.sub_assign(p1);
+<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::ops::SubAssign<std::time::Duration>>::sub_assign(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::sub_assign(p0, p1);
-----------------
src/primitive_date_time.rs <primitive_date_time::PrimitiveDateTime as std::ops::Sub>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
let mut p1 = MaybeUninit::uninit().assume_init(); // primitive_date_time::PrimitiveDateTime
+p0.sub(p1);
+<primitive_date_time::PrimitiveDateTime as std::ops::Sub>::sub(p0, p1);
+crate::<primitive_date_time::PrimitiveDateTime as std::ops::Sub>::sub(p0, p1);
+<primitive_date_time::PrimitiveDateTime>::sub(p0, p1);
-----------------
src/time.rs <time::Padding as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Padding
+p0.clone();
+<time::Padding as std::clone::Clone>::clone(p0);
+crate::<time::Padding as std::clone::Clone>::clone(p0);
+<time::Padding>::clone(p0);
-----------------
src/time.rs <time::Padding as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Padding
let mut p1 = & MaybeUninit::uninit().assume_init(); // time::Padding
+p0.eq(p1);
+<time::Padding as std::cmp::PartialEq>::eq(p0, p1);
+crate::<time::Padding as std::cmp::PartialEq>::eq(p0, p1);
+<time::Padding>::eq(p0, p1);
-----------------
src/time.rs <time::Padding as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Padding
+p0.assert_receiver_is_total_eq();
+<time::Padding as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<time::Padding as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<time::Padding>::assert_receiver_is_total_eq(p0);
-----------------
src/time.rs <time::Padding as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Padding
let mut p1 = & MaybeUninit::uninit().assume_init(); // time::Padding
+p0.partial_cmp(p1);
+<time::Padding as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<time::Padding as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<time::Padding>::partial_cmp(p0, p1);
-----------------
src/time.rs <time::Padding as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Padding
let mut p1 = & MaybeUninit::uninit().assume_init(); // time::Padding
+p0.cmp(p1);
+<time::Padding as std::cmp::Ord>::cmp(p0, p1);
+crate::<time::Padding as std::cmp::Ord>::cmp(p0, p1);
+<time::Padding>::cmp(p0, p1);
-----------------
src/time.rs <time::Padding as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<time::Padding as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<time::Padding as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::hash::SipHasher","<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Padding
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<time::Padding as std::hash::Hash>::hash(p0, p1);
+crate::<time::Padding as std::hash::Hash>::hash(p0, p1);
+<time::Padding>::hash(p0, p1);
-----------------
src/time.rs <time::Time as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Time
+p0.clone();
+<time::Time as std::clone::Clone>::clone(p0);
+crate::<time::Time as std::clone::Clone>::clone(p0);
+<time::Time>::clone(p0);
-----------------
src/time.rs <time::Time as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = & MaybeUninit::uninit().assume_init(); // time::Time
+p0.eq(p1);
+<time::Time as std::cmp::PartialEq>::eq(p0, p1);
+crate::<time::Time as std::cmp::PartialEq>::eq(p0, p1);
+<time::Time>::eq(p0, p1);
-----------------
src/time.rs <time::Time as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Time
+p0.assert_receiver_is_total_eq();
+<time::Time as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<time::Time as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<time::Time>::assert_receiver_is_total_eq(p0);
-----------------
src/time.rs <time::Time as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<time::Time as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<time::Time as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","<&mut H as std::hash::Hasher>","std::hash::SipHasher13","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::boxed::Box<T, A>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<time::Time as std::hash::Hash>::hash(p0, p1);
+crate::<time::Time as std::hash::Hash>::hash(p0, p1);
+<time::Time>::hash(p0, p1);
-----------------
src/time.rs <time::Time as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = & MaybeUninit::uninit().assume_init(); // time::Time
+p0.partial_cmp(p1);
+<time::Time as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<time::Time as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<time::Time>::partial_cmp(p0, p1);
-----------------
src/time.rs <time::Time as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = & MaybeUninit::uninit().assume_init(); // time::Time
+p0.cmp(p1);
+<time::Time as std::cmp::Ord>::cmp(p0, p1);
+crate::<time::Time as std::cmp::Ord>::cmp(p0, p1);
+<time::Time>::cmp(p0, p1);
-----------------
src/time.rs <time::Time as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<time::Time as std::fmt::Debug>::fmt(p0, p1);
+crate::<time::Time as std::fmt::Debug>::fmt(p0, p1);
+<time::Time>::fmt(p0, p1);
-----------------
src/time.rs time::Time::__from_hms_nanos_unchecked
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
let mut p3 = 0u32; // None+u32
+time::Time::__from_hms_nanos_unchecked(p0, p1, p2, p3);
+crate::time::Time::__from_hms_nanos_unchecked(p0, p1, p2, p3);
+<time::Time>::__from_hms_nanos_unchecked(p0, p1, p2, p3);
-----------------
src/time.rs time::Time::from_hms
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
+time::Time::from_hms(p0, p1, p2);
+crate::time::Time::from_hms(p0, p1, p2);
+<time::Time>::from_hms(p0, p1, p2);
-----------------
src/time.rs time::Time::from_hms_milli
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
let mut p3 = 0u16; // None+u16
+time::Time::from_hms_milli(p0, p1, p2, p3);
+crate::time::Time::from_hms_milli(p0, p1, p2, p3);
+<time::Time>::from_hms_milli(p0, p1, p2, p3);
-----------------
src/time.rs time::Time::from_hms_micro
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
let mut p3 = 0u32; // None+u32
+time::Time::from_hms_micro(p0, p1, p2, p3);
+crate::time::Time::from_hms_micro(p0, p1, p2, p3);
+<time::Time>::from_hms_micro(p0, p1, p2, p3);
-----------------
src/time.rs time::Time::from_hms_nano
deps:{}
candidates:{}
let mut p0 = 0u8; // None+u8
let mut p1 = 0u8; // None+u8
let mut p2 = 0u8; // None+u8
let mut p3 = 0u32; // None+u32
+time::Time::from_hms_nano(p0, p1, p2, p3);
+crate::time::Time::from_hms_nano(p0, p1, p2, p3);
+<time::Time>::from_hms_nano(p0, p1, p2, p3);
-----------------
src/time.rs time::Time::as_hms
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.as_hms();
+time::Time::as_hms(p0);
+crate::time::Time::as_hms(p0);
+<time::Time>::as_hms(p0);
-----------------
src/time.rs time::Time::as_hms_milli
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.as_hms_milli();
+time::Time::as_hms_milli(p0);
+crate::time::Time::as_hms_milli(p0);
+<time::Time>::as_hms_milli(p0);
-----------------
src/time.rs time::Time::as_hms_micro
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.as_hms_micro();
+time::Time::as_hms_micro(p0);
+crate::time::Time::as_hms_micro(p0);
+<time::Time>::as_hms_micro(p0);
-----------------
src/time.rs time::Time::as_hms_nano
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.as_hms_nano();
+time::Time::as_hms_nano(p0);
+crate::time::Time::as_hms_nano(p0);
+<time::Time>::as_hms_nano(p0);
-----------------
src/time.rs time::Time::hour
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.hour();
+time::Time::hour(p0);
+crate::time::Time::hour(p0);
+<time::Time>::hour(p0);
-----------------
src/time.rs time::Time::minute
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.minute();
+time::Time::minute(p0);
+crate::time::Time::minute(p0);
+<time::Time>::minute(p0);
-----------------
src/time.rs time::Time::second
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.second();
+time::Time::second(p0);
+crate::time::Time::second(p0);
+<time::Time>::second(p0);
-----------------
src/time.rs time::Time::millisecond
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.millisecond();
+time::Time::millisecond(p0);
+crate::time::Time::millisecond(p0);
+<time::Time>::millisecond(p0);
-----------------
src/time.rs time::Time::microsecond
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.microsecond();
+time::Time::microsecond(p0);
+crate::time::Time::microsecond(p0);
+<time::Time>::microsecond(p0);
-----------------
src/time.rs time::Time::nanosecond
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.nanosecond();
+time::Time::nanosecond(p0);
+crate::time::Time::nanosecond(p0);
+<time::Time>::nanosecond(p0);
-----------------
src/time.rs time::Time::adjusting_add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.adjusting_add(p1);
+time::Time::adjusting_add(p0, p1);
+crate::time::Time::adjusting_add(p0, p1);
+<time::Time>::adjusting_add(p0, p1);
-----------------
src/time.rs time::Time::adjusting_sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.adjusting_sub(p1);
+time::Time::adjusting_sub(p0, p1);
+crate::time::Time::adjusting_sub(p0, p1);
+<time::Time>::adjusting_sub(p0, p1);
-----------------
src/time.rs time::Time::adjusting_add_std
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.adjusting_add_std(p1);
+time::Time::adjusting_add_std(p0, p1);
+crate::time::Time::adjusting_add_std(p0, p1);
+<time::Time>::adjusting_add_std(p0, p1);
-----------------
src/time.rs time::Time::adjusting_sub_std
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.adjusting_sub_std(p1);
+time::Time::adjusting_sub_std(p0, p1);
+crate::time::Time::adjusting_sub_std(p0, p1);
+<time::Time>::adjusting_sub_std(p0, p1);
-----------------
src/time.rs <time::Time as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<time::Time as std::fmt::Display>::fmt(p0, p1);
+crate::<time::Time as std::fmt::Display>::fmt(p0, p1);
+<time::Time>::fmt(p0, p1);
-----------------
src/time.rs <time::Time as std::ops::Add<duration::Duration>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add(p1);
+<time::Time as std::ops::Add<duration::Duration>>::add(p0, p1);
+crate::<time::Time as std::ops::Add<duration::Duration>>::add(p0, p1);
+<time::Time>::add(p0, p1);
-----------------
src/time.rs <time::Time as std::ops::Add<std::time::Duration>>::add
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.add(p1);
+<time::Time as std::ops::Add<std::time::Duration>>::add(p0, p1);
+crate::<time::Time as std::ops::Add<std::time::Duration>>::add(p0, p1);
+<time::Time>::add(p0, p1);
-----------------
src/lib.rs <time::Time as std::ops::AddAssign<duration::Duration>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.add_assign(p1);
+<time::Time as std::ops::AddAssign<duration::Duration>>::add_assign(p0, p1);
+crate::<time::Time as std::ops::AddAssign<duration::Duration>>::add_assign(p0, p1);
+<time::Time>::add_assign(p0, p1);
-----------------
src/lib.rs <time::Time as std::ops::AddAssign<std::time::Duration>>::add_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.add_assign(p1);
+<time::Time as std::ops::AddAssign<std::time::Duration>>::add_assign(p0, p1);
+crate::<time::Time as std::ops::AddAssign<std::time::Duration>>::add_assign(p0, p1);
+<time::Time>::add_assign(p0, p1);
-----------------
src/time.rs <time::Time as std::ops::Sub<duration::Duration>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub(p1);
+<time::Time as std::ops::Sub<duration::Duration>>::sub(p0, p1);
+crate::<time::Time as std::ops::Sub<duration::Duration>>::sub(p0, p1);
+<time::Time>::sub(p0, p1);
-----------------
src/time.rs <time::Time as std::ops::Sub<std::time::Duration>>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.sub(p1);
+<time::Time as std::ops::Sub<std::time::Duration>>::sub(p0, p1);
+crate::<time::Time as std::ops::Sub<std::time::Duration>>::sub(p0, p1);
+<time::Time>::sub(p0, p1);
-----------------
src/lib.rs <time::Time as std::ops::SubAssign<duration::Duration>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // duration::Duration
+p0.sub_assign(p1);
+<time::Time as std::ops::SubAssign<duration::Duration>>::sub_assign(p0, p1);
+crate::<time::Time as std::ops::SubAssign<duration::Duration>>::sub_assign(p0, p1);
+<time::Time>::sub_assign(p0, p1);
-----------------
src/lib.rs <time::Time as std::ops::SubAssign<std::time::Duration>>::sub_assign
deps:{}
candidates:{}
let mut p0 = &mut  MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // std::time::Duration
+p0.sub_assign(p1);
+<time::Time as std::ops::SubAssign<std::time::Duration>>::sub_assign(p0, p1);
+crate::<time::Time as std::ops::SubAssign<std::time::Duration>>::sub_assign(p0, p1);
+<time::Time>::sub_assign(p0, p1);
-----------------
src/time.rs <time::Time as std::ops::Sub>::sub
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // time::Time
let mut p1 = MaybeUninit::uninit().assume_init(); // time::Time
+p0.sub(p1);
+<time::Time as std::ops::Sub>::sub(p0, p1);
+crate::<time::Time as std::ops::Sub>::sub(p0, p1);
+<time::Time>::sub(p0, p1);
-----------------
src/utc_offset.rs <utc_offset::UtcOffset as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<utc_offset::UtcOffset as std::fmt::Debug>::fmt(p0, p1);
+crate::<utc_offset::UtcOffset as std::fmt::Debug>::fmt(p0, p1);
+<utc_offset::UtcOffset>::fmt(p0, p1);
-----------------
src/utc_offset.rs <utc_offset::UtcOffset as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.clone();
+<utc_offset::UtcOffset as std::clone::Clone>::clone(p0);
+crate::<utc_offset::UtcOffset as std::clone::Clone>::clone(p0);
+<utc_offset::UtcOffset>::clone(p0);
-----------------
src/utc_offset.rs <utc_offset::UtcOffset as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
let mut p1 = & MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.eq(p1);
+<utc_offset::UtcOffset as std::cmp::PartialEq>::eq(p0, p1);
+crate::<utc_offset::UtcOffset as std::cmp::PartialEq>::eq(p0, p1);
+<utc_offset::UtcOffset>::eq(p0, p1);
-----------------
src/utc_offset.rs <utc_offset::UtcOffset as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.assert_receiver_is_total_eq();
+<utc_offset::UtcOffset as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<utc_offset::UtcOffset as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<utc_offset::UtcOffset>::assert_receiver_is_total_eq(p0);
-----------------
src/utc_offset.rs <utc_offset::UtcOffset as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<utc_offset::UtcOffset as std::hash::Hash>::hash":{"__H":["std::hash::Hasher","std::marker::Sized"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<utc_offset::UtcOffset as std::hash::Hash>::hash":{"__H":["std::hash::SipHasher13","<&mut H as std::hash::Hasher>","std::boxed::Box<T, A>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher","std::hash::sip::Hasher<S>"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<utc_offset::UtcOffset as std::hash::Hash>::hash(p0, p1);
+crate::<utc_offset::UtcOffset as std::hash::Hash>::hash(p0, p1);
+<utc_offset::UtcOffset>::hash(p0, p1);
-----------------
src/utc_offset.rs <utc_offset::UtcOffset as std::cmp::PartialOrd>::partial_cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
let mut p1 = & MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.partial_cmp(p1);
+<utc_offset::UtcOffset as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+crate::<utc_offset::UtcOffset as std::cmp::PartialOrd>::partial_cmp(p0, p1);
+<utc_offset::UtcOffset>::partial_cmp(p0, p1);
-----------------
src/utc_offset.rs <utc_offset::UtcOffset as std::cmp::Ord>::cmp
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
let mut p1 = & MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.cmp(p1);
+<utc_offset::UtcOffset as std::cmp::Ord>::cmp(p0, p1);
+crate::<utc_offset::UtcOffset as std::cmp::Ord>::cmp(p0, p1);
+<utc_offset::UtcOffset>::cmp(p0, p1);
-----------------
src/utc_offset.rs utc_offset::UtcOffset::__from_hms_unchecked
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0i8; // None+i8
let mut p2 = 0i8; // None+i8
+utc_offset::UtcOffset::__from_hms_unchecked(p0, p1, p2);
+crate::utc_offset::UtcOffset::__from_hms_unchecked(p0, p1, p2);
+<utc_offset::UtcOffset>::__from_hms_unchecked(p0, p1, p2);
-----------------
src/utc_offset.rs utc_offset::UtcOffset::from_hms
deps:{}
candidates:{}
let mut p0 = 0i8; // None+i8
let mut p1 = 0i8; // None+i8
let mut p2 = 0i8; // None+i8
+utc_offset::UtcOffset::from_hms(p0, p1, p2);
+crate::utc_offset::UtcOffset::from_hms(p0, p1, p2);
+<utc_offset::UtcOffset>::from_hms(p0, p1, p2);
-----------------
src/utc_offset.rs utc_offset::UtcOffset::from_whole_seconds
deps:{}
candidates:{}
let mut p0 = 0i32; // None+i32
+utc_offset::UtcOffset::from_whole_seconds(p0);
+crate::utc_offset::UtcOffset::from_whole_seconds(p0);
+<utc_offset::UtcOffset>::from_whole_seconds(p0);
-----------------
src/utc_offset.rs utc_offset::UtcOffset::as_hms
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.as_hms();
+utc_offset::UtcOffset::as_hms(p0);
+crate::utc_offset::UtcOffset::as_hms(p0);
+<utc_offset::UtcOffset>::as_hms(p0);
-----------------
src/utc_offset.rs utc_offset::UtcOffset::whole_hours
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.whole_hours();
+utc_offset::UtcOffset::whole_hours(p0);
+crate::utc_offset::UtcOffset::whole_hours(p0);
+<utc_offset::UtcOffset>::whole_hours(p0);
-----------------
src/utc_offset.rs utc_offset::UtcOffset::whole_minutes
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.whole_minutes();
+utc_offset::UtcOffset::whole_minutes(p0);
+crate::utc_offset::UtcOffset::whole_minutes(p0);
+<utc_offset::UtcOffset>::whole_minutes(p0);
-----------------
src/utc_offset.rs utc_offset::UtcOffset::minutes_past_hour
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.minutes_past_hour();
+utc_offset::UtcOffset::minutes_past_hour(p0);
+crate::utc_offset::UtcOffset::minutes_past_hour(p0);
+<utc_offset::UtcOffset>::minutes_past_hour(p0);
-----------------
src/utc_offset.rs utc_offset::UtcOffset::whole_seconds
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.whole_seconds();
+utc_offset::UtcOffset::whole_seconds(p0);
+crate::utc_offset::UtcOffset::whole_seconds(p0);
+<utc_offset::UtcOffset>::whole_seconds(p0);
-----------------
src/utc_offset.rs utc_offset::UtcOffset::seconds_past_minute
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.seconds_past_minute();
+utc_offset::UtcOffset::seconds_past_minute(p0);
+crate::utc_offset::UtcOffset::seconds_past_minute(p0);
+<utc_offset::UtcOffset>::seconds_past_minute(p0);
-----------------
src/utc_offset.rs utc_offset::UtcOffset::is_utc
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.is_utc();
+utc_offset::UtcOffset::is_utc(p0);
+crate::utc_offset::UtcOffset::is_utc(p0);
+<utc_offset::UtcOffset>::is_utc(p0);
-----------------
src/utc_offset.rs utc_offset::UtcOffset::is_positive
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.is_positive();
+utc_offset::UtcOffset::is_positive(p0);
+crate::utc_offset::UtcOffset::is_positive(p0);
+<utc_offset::UtcOffset>::is_positive(p0);
-----------------
src/utc_offset.rs utc_offset::UtcOffset::is_negative
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.is_negative();
+utc_offset::UtcOffset::is_negative(p0);
+crate::utc_offset::UtcOffset::is_negative(p0);
+<utc_offset::UtcOffset>::is_negative(p0);
-----------------
src/utc_offset.rs <utc_offset::UtcOffset as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<utc_offset::UtcOffset as std::fmt::Display>::fmt(p0, p1);
+crate::<utc_offset::UtcOffset as std::fmt::Display>::fmt(p0, p1);
+<utc_offset::UtcOffset>::fmt(p0, p1);
-----------------
src/utc_offset.rs <utc_offset::UtcOffset as std::ops::Neg>::neg
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // utc_offset::UtcOffset
+p0.neg();
+<utc_offset::UtcOffset as std::ops::Neg>::neg(p0);
+crate::<utc_offset::UtcOffset as std::ops::Neg>::neg(p0);
+<utc_offset::UtcOffset>::neg(p0);
-----------------
src/weekday.rs <weekday::Weekday as std::fmt::Debug>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{:?}", p0);
+p0.fmt(p1);
+<weekday::Weekday as std::fmt::Debug>::fmt(p0, p1);
+crate::<weekday::Weekday as std::fmt::Debug>::fmt(p0, p1);
+<weekday::Weekday>::fmt(p0, p1);
-----------------
src/weekday.rs <weekday::Weekday as std::clone::Clone>::clone
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.clone();
+<weekday::Weekday as std::clone::Clone>::clone(p0);
+crate::<weekday::Weekday as std::clone::Clone>::clone(p0);
+<weekday::Weekday>::clone(p0);
-----------------
src/weekday.rs <weekday::Weekday as std::cmp::PartialEq>::eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
let mut p1 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.eq(p1);
+<weekday::Weekday as std::cmp::PartialEq>::eq(p0, p1);
+crate::<weekday::Weekday as std::cmp::PartialEq>::eq(p0, p1);
+<weekday::Weekday>::eq(p0, p1);
-----------------
src/weekday.rs <weekday::Weekday as std::cmp::Eq>::assert_receiver_is_total_eq
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.assert_receiver_is_total_eq();
+<weekday::Weekday as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+crate::<weekday::Weekday as std::cmp::Eq>::assert_receiver_is_total_eq(p0);
+<weekday::Weekday>::assert_receiver_is_total_eq(p0);
-----------------
src/weekday.rs <weekday::Weekday as std::hash::Hash>::hash
deps:{"<&mut H as std::hash::Hasher>":{},"<weekday::Weekday as std::hash::Hash>::hash":{"__H":["std::marker::Sized","std::hash::Hasher"]}}
candidates:{"<&mut H as std::hash::Hasher>":{},"<weekday::Weekday as std::hash::Hash>::hash":{"__H":["std::hash::sip::Hasher<S>","std::hash::SipHasher13","std::boxed::Box<T, A>","<&mut H as std::hash::Hasher>","std::collections::hash_map::DefaultHasher","std::hash::SipHasher"]}}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // __H
+p0.hash(p1);
+<weekday::Weekday as std::hash::Hash>::hash(p0, p1);
+crate::<weekday::Weekday as std::hash::Hash>::hash(p0, p1);
+<weekday::Weekday>::hash(p0, p1);
-----------------
src/weekday.rs weekday::Weekday::previous
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.previous();
+weekday::Weekday::previous(p0);
+crate::weekday::Weekday::previous(p0);
+<weekday::Weekday>::previous(p0);
-----------------
src/weekday.rs weekday::Weekday::next
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.next();
+weekday::Weekday::next(p0);
+crate::weekday::Weekday::next(p0);
+<weekday::Weekday>::next(p0);
-----------------
src/weekday.rs weekday::Weekday::number_from_monday
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.number_from_monday();
+weekday::Weekday::number_from_monday(p0);
+crate::weekday::Weekday::number_from_monday(p0);
+<weekday::Weekday>::number_from_monday(p0);
-----------------
src/weekday.rs weekday::Weekday::number_from_sunday
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.number_from_sunday();
+weekday::Weekday::number_from_sunday(p0);
+crate::weekday::Weekday::number_from_sunday(p0);
+<weekday::Weekday>::number_from_sunday(p0);
-----------------
src/weekday.rs weekday::Weekday::number_days_from_monday
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.number_days_from_monday();
+weekday::Weekday::number_days_from_monday(p0);
+crate::weekday::Weekday::number_days_from_monday(p0);
+<weekday::Weekday>::number_days_from_monday(p0);
-----------------
src/weekday.rs weekday::Weekday::number_days_from_sunday
deps:{}
candidates:{}
let mut p0 = MaybeUninit::uninit().assume_init(); // weekday::Weekday
+p0.number_days_from_sunday();
+weekday::Weekday::number_days_from_sunday(p0);
+crate::weekday::Weekday::number_days_from_sunday(p0);
+<weekday::Weekday>::number_days_from_sunday(p0);
-----------------
src/weekday.rs <weekday::Weekday as std::fmt::Display>::fmt
deps:{}
candidates:{}
let mut p0 = & MaybeUninit::uninit().assume_init(); // weekday::Weekday
let mut p1 = &mut  MaybeUninit::uninit().assume_init(); // std::fmt::Formatter<'_>
+format!("{}", p0);
+p0.fmt(p1);
+<weekday::Weekday as std::fmt::Display>::fmt(p0, p1);
+crate::<weekday::Weekday as std::fmt::Display>::fmt(p0, p1);
+<weekday::Weekday>::fmt(p0, p1);