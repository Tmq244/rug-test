{"dependencies":{"<connect_four::Column as std::clone::Clone>::clone":["connect_four::Column","std::marker::Sized","std::option::Option"],"<connect_four::Column as std::cmp::Eq>::assert_receiver_is_total_eq":["connect_four::Column","std::marker::Sized","std::option::Option"],"<connect_four::Column as std::cmp::PartialEq>::eq":["connect_four::Column","std::marker::Sized","std::option::Option"],"<connect_four::Column as std::default::Default>::default":["connect_four::Column","std::marker::Sized","std::option::Option"],"<connect_four::Column as std::fmt::Debug>::fmt":["connect_four::Column","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<connect_four::Column as std::ops::Index<usize>>::index":["connect_four::Column","std::marker::Sized","std::option::Option"],"<connect_four::Column as std::ops::IndexMut<usize>>::index_mut":["connect_four::Column","std::marker::Sized","std::option::Option"],"<connect_four::ColumnFilledSnafu as snafu::IntoError<connect_four::ConnectFourError>>::into_error":["connect_four::ColumnFilledSnafu","connect_four::ConnectFourError"],"<connect_four::ColumnFilledSnafu as std::clone::Clone>::clone":["connect_four::ColumnFilledSnafu"],"<connect_four::ColumnFilledSnafu as std::fmt::Debug>::fmt":["connect_four::ColumnFilledSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<connect_four::ConnectFour as std::clone::Clone>::clone":["connect_four::Column","connect_four::ConnectFour","connect_four::GameState","connect_four::Player","std::marker::Sized","std::option::Option"],"<connect_four::ConnectFour as std::fmt::Debug>::fmt":["connect_four::Column","connect_four::ConnectFour","connect_four::GameState","connect_four::Player","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<connect_four::ConnectFourError as snafu::Error>::cause":["connect_four::ConnectFourError","std::marker::Sized","std::option::Option"],"<connect_four::ConnectFourError as snafu::Error>::description":["connect_four::ConnectFourError"],"<connect_four::ConnectFourError as snafu::Error>::source":["connect_four::ConnectFourError","std::marker::Sized","std::option::Option"],"<connect_four::ConnectFourError as snafu::ErrorCompat>::backtrace":["connect_four::ConnectFourError","std::marker::Sized","std::option::Option"],"<connect_four::ConnectFourError as std::cmp::Eq>::assert_receiver_is_total_eq":["connect_four::ConnectFourError"],"<connect_four::ConnectFourError as std::cmp::PartialEq>::eq":["connect_four::ConnectFourError"],"<connect_four::ConnectFourError as std::fmt::Debug>::fmt":["connect_four::ConnectFourError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<connect_four::ConnectFourError as std::fmt::Display>::fmt":["connect_four::ConnectFourError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<connect_four::GameEndedSnafu as snafu::IntoError<connect_four::ConnectFourError>>::into_error":["connect_four::ConnectFourError","connect_four::GameEndedSnafu"],"<connect_four::GameEndedSnafu as std::clone::Clone>::clone":["connect_four::GameEndedSnafu"],"<connect_four::GameEndedSnafu as std::fmt::Debug>::fmt":["connect_four::GameEndedSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<connect_four::GameState as std::clone::Clone>::clone":["connect_four::GameState","connect_four::Player"],"<connect_four::GameState as std::cmp::Eq>::assert_receiver_is_total_eq":["connect_four::GameState","connect_four::Player"],"<connect_four::GameState as std::cmp::PartialEq>::eq":["connect_four::GameState","connect_four::Player"],"<connect_four::GameState as std::fmt::Debug>::fmt":["connect_four::GameState","connect_four::Player","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<connect_four::Player as std::clone::Clone>::clone":["connect_four::Player"],"<connect_four::Player as std::cmp::Eq>::assert_receiver_is_total_eq":["connect_four::Player"],"<connect_four::Player as std::cmp::PartialEq>::eq":["connect_four::Player"],"<connect_four::Player as std::fmt::Debug>::fmt":["connect_four::Player","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<connect_four::WrongPlayerSnafu as snafu::IntoError<connect_four::ConnectFourError>>::into_error":["connect_four::ConnectFourError","connect_four::WrongPlayerSnafu"],"<connect_four::WrongPlayerSnafu as std::clone::Clone>::clone":["connect_four::WrongPlayerSnafu"],"<connect_four::WrongPlayerSnafu as std::fmt::Debug>::fmt":["connect_four::WrongPlayerSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<gomoku::GameEndedSnafu as snafu::IntoError<gomoku::GomokuError>>::into_error":["gomoku::GameEndedSnafu","gomoku::GomokuError"],"<gomoku::GameEndedSnafu as std::clone::Clone>::clone":["gomoku::GameEndedSnafu"],"<gomoku::GameEndedSnafu as std::fmt::Debug>::fmt":["gomoku::GameEndedSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<gomoku::GameState as std::clone::Clone>::clone":["gomoku::GameState","gomoku::Player"],"<gomoku::GameState as std::cmp::Eq>::assert_receiver_is_total_eq":["gomoku::GameState","gomoku::Player"],"<gomoku::GameState as std::cmp::PartialEq>::eq":["gomoku::GameState","gomoku::Player"],"<gomoku::GameState as std::fmt::Debug>::fmt":["gomoku::GameState","gomoku::Player","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<gomoku::Gomoku as std::clone::Clone>::clone":["gomoku::GameState","gomoku::Gomoku","gomoku::Player","std::marker::Sized","std::option::Option"],"<gomoku::Gomoku as std::fmt::Debug>::fmt":["gomoku::GameState","gomoku::Gomoku","gomoku::Player","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<gomoku::GomokuError as snafu::Error>::cause":["gomoku::GomokuError","std::marker::Sized","std::option::Option"],"<gomoku::GomokuError as snafu::Error>::description":["gomoku::GomokuError"],"<gomoku::GomokuError as snafu::Error>::source":["gomoku::GomokuError","std::marker::Sized","std::option::Option"],"<gomoku::GomokuError as snafu::ErrorCompat>::backtrace":["gomoku::GomokuError","std::marker::Sized","std::option::Option"],"<gomoku::GomokuError as std::cmp::Eq>::assert_receiver_is_total_eq":["gomoku::GomokuError"],"<gomoku::GomokuError as std::cmp::PartialEq>::eq":["gomoku::GomokuError"],"<gomoku::GomokuError as std::fmt::Debug>::fmt":["gomoku::GomokuError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<gomoku::GomokuError as std::fmt::Display>::fmt":["gomoku::GomokuError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<gomoku::OccupiedPositionSnafu as snafu::IntoError<gomoku::GomokuError>>::into_error":["gomoku::GomokuError","gomoku::OccupiedPositionSnafu"],"<gomoku::OccupiedPositionSnafu as std::clone::Clone>::clone":["gomoku::OccupiedPositionSnafu"],"<gomoku::OccupiedPositionSnafu as std::fmt::Debug>::fmt":["gomoku::OccupiedPositionSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<gomoku::Player as std::clone::Clone>::clone":["gomoku::Player"],"<gomoku::Player as std::cmp::Eq>::assert_receiver_is_total_eq":["gomoku::Player"],"<gomoku::Player as std::cmp::PartialEq>::eq":["gomoku::Player"],"<gomoku::Player as std::fmt::Debug>::fmt":["gomoku::Player","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<gomoku::WrongPlayerSnafu as snafu::IntoError<gomoku::GomokuError>>::into_error":["gomoku::GomokuError","gomoku::WrongPlayerSnafu"],"<gomoku::WrongPlayerSnafu as std::clone::Clone>::clone":["gomoku::WrongPlayerSnafu"],"<gomoku::WrongPlayerSnafu as std::fmt::Debug>::fmt":["gomoku::WrongPlayerSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<minesweeper::AdjacentCells as std::clone::Clone>::clone":["minesweeper::AdjacentCells"],"<minesweeper::AdjacentCells as std::iter::Iterator>::next":["minesweeper::AdjacentCells","std::marker::Sized","std::option::Option"],"<minesweeper::AlreadyFlaggedSnafu as snafu::IntoError<minesweeper::MinesweeperError>>::into_error":["minesweeper::AlreadyFlaggedSnafu","minesweeper::MinesweeperError"],"<minesweeper::AlreadyFlaggedSnafu as std::clone::Clone>::clone":["minesweeper::AlreadyFlaggedSnafu"],"<minesweeper::AlreadyFlaggedSnafu as std::fmt::Debug>::fmt":["minesweeper::AlreadyFlaggedSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<minesweeper::AlreadyRevealedSnafu as snafu::IntoError<minesweeper::MinesweeperError>>::into_error":["minesweeper::AlreadyRevealedSnafu","minesweeper::MinesweeperError"],"<minesweeper::AlreadyRevealedSnafu as std::clone::Clone>::clone":["minesweeper::AlreadyRevealedSnafu"],"<minesweeper::AlreadyRevealedSnafu as std::fmt::Debug>::fmt":["minesweeper::AlreadyRevealedSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<minesweeper::Cell as std::clone::Clone>::clone":["minesweeper::Cell"],"<minesweeper::Cell as std::cmp::Eq>::assert_receiver_is_total_eq":["minesweeper::Cell"],"<minesweeper::Cell as std::cmp::PartialEq>::eq":["minesweeper::Cell"],"<minesweeper::Cell as std::fmt::Debug>::fmt":["minesweeper::Cell","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<minesweeper::GameEndedSnafu as snafu::IntoError<minesweeper::MinesweeperError>>::into_error":["minesweeper::GameEndedSnafu","minesweeper::MinesweeperError"],"<minesweeper::GameEndedSnafu as std::clone::Clone>::clone":["minesweeper::GameEndedSnafu"],"<minesweeper::GameEndedSnafu as std::fmt::Debug>::fmt":["minesweeper::GameEndedSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<minesweeper::GameState as std::clone::Clone>::clone":["minesweeper::GameState","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<minesweeper::GameState as std::cmp::Eq>::assert_receiver_is_total_eq":["minesweeper::GameState","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<minesweeper::GameState as std::cmp::PartialEq>::eq":["minesweeper::GameState","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<minesweeper::GameState as std::fmt::Debug>::fmt":["minesweeper::GameState","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<minesweeper::Minesweeper as std::clone::Clone>::clone":["minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<minesweeper::Minesweeper as std::fmt::Debug>::fmt":["minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<minesweeper::MinesweeperError as snafu::Error>::cause":["minesweeper::MinesweeperError","std::marker::Sized","std::option::Option"],"<minesweeper::MinesweeperError as snafu::Error>::description":["minesweeper::MinesweeperError"],"<minesweeper::MinesweeperError as snafu::Error>::source":["minesweeper::MinesweeperError","std::marker::Sized","std::option::Option"],"<minesweeper::MinesweeperError as snafu::ErrorCompat>::backtrace":["minesweeper::MinesweeperError","std::marker::Sized","std::option::Option"],"<minesweeper::MinesweeperError as std::cmp::Eq>::assert_receiver_is_total_eq":["minesweeper::MinesweeperError"],"<minesweeper::MinesweeperError as std::cmp::PartialEq>::eq":["minesweeper::MinesweeperError"],"<minesweeper::MinesweeperError as std::fmt::Debug>::fmt":["minesweeper::MinesweeperError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<minesweeper::MinesweeperError as std::fmt::Display>::fmt":["minesweeper::MinesweeperError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<minesweeper::TooManyMinesSnafu as snafu::IntoError<minesweeper::MinesweeperError>>::into_error":["minesweeper::MinesweeperError","minesweeper::TooManyMinesSnafu"],"<minesweeper::TooManyMinesSnafu as std::clone::Clone>::clone":["minesweeper::TooManyMinesSnafu"],"<minesweeper::TooManyMinesSnafu as std::fmt::Debug>::fmt":["minesweeper::TooManyMinesSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<reversi::Direction as std::clone::Clone>::clone":["reversi::Direction"],"<reversi::Direction as std::cmp::PartialEq>::eq":["reversi::Direction"],"<reversi::Direction as std::fmt::Debug>::fmt":["reversi::Direction","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<reversi::GameEndedSnafu as snafu::IntoError<reversi::ReversiError>>::into_error":["reversi::GameEndedSnafu","reversi::ReversiError"],"<reversi::GameEndedSnafu as std::clone::Clone>::clone":["reversi::GameEndedSnafu"],"<reversi::GameEndedSnafu as std::fmt::Debug>::fmt":["reversi::GameEndedSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<reversi::GameState as std::clone::Clone>::clone":["reversi::GameState","reversi::Player"],"<reversi::GameState as std::cmp::Eq>::assert_receiver_is_total_eq":["reversi::GameState","reversi::Player"],"<reversi::GameState as std::cmp::PartialEq>::eq":["reversi::GameState","reversi::Player"],"<reversi::GameState as std::fmt::Debug>::fmt":["reversi::GameState","reversi::Player","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<reversi::InvalidPositionSnafu as snafu::IntoError<reversi::ReversiError>>::into_error":["reversi::InvalidPositionSnafu","reversi::ReversiError"],"<reversi::InvalidPositionSnafu as std::clone::Clone>::clone":["reversi::InvalidPositionSnafu"],"<reversi::InvalidPositionSnafu as std::fmt::Debug>::fmt":["reversi::InvalidPositionSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<reversi::OccupiedPositionSnafu as snafu::IntoError<reversi::ReversiError>>::into_error":["reversi::OccupiedPositionSnafu","reversi::ReversiError"],"<reversi::OccupiedPositionSnafu as std::clone::Clone>::clone":["reversi::OccupiedPositionSnafu"],"<reversi::OccupiedPositionSnafu as std::fmt::Debug>::fmt":["reversi::OccupiedPositionSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<reversi::Player as std::clone::Clone>::clone":["reversi::Player"],"<reversi::Player as std::cmp::Eq>::assert_receiver_is_total_eq":["reversi::Player"],"<reversi::Player as std::cmp::PartialEq>::eq":["reversi::Player"],"<reversi::Player as std::fmt::Debug>::fmt":["reversi::Player","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<reversi::Reversi as std::clone::Clone>::clone":["reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option"],"<reversi::Reversi as std::fmt::Debug>::fmt":["reversi::GameState","reversi::Player","reversi::Reversi","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<reversi::ReversiError as snafu::Error>::cause":["reversi::ReversiError","std::marker::Sized","std::option::Option"],"<reversi::ReversiError as snafu::Error>::description":["reversi::ReversiError"],"<reversi::ReversiError as snafu::Error>::source":["reversi::ReversiError","std::marker::Sized","std::option::Option"],"<reversi::ReversiError as snafu::ErrorCompat>::backtrace":["reversi::ReversiError","std::marker::Sized","std::option::Option"],"<reversi::ReversiError as std::cmp::Eq>::assert_receiver_is_total_eq":["reversi::ReversiError"],"<reversi::ReversiError as std::cmp::PartialEq>::eq":["reversi::ReversiError"],"<reversi::ReversiError as std::fmt::Debug>::fmt":["reversi::ReversiError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<reversi::ReversiError as std::fmt::Display>::fmt":["reversi::ReversiError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<reversi::WrongPlayerSnafu as snafu::IntoError<reversi::ReversiError>>::into_error":["reversi::ReversiError","reversi::WrongPlayerSnafu"],"<reversi::WrongPlayerSnafu as std::clone::Clone>::clone":["reversi::WrongPlayerSnafu"],"<reversi::WrongPlayerSnafu as std::fmt::Debug>::fmt":["reversi::WrongPlayerSnafu","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<tictactoe::GameEndedSnafu as snafu::IntoError<tictactoe::TicTacToeError>>::into_error":["tictactoe::GameEndedSnafu","tictactoe::TicTacToeError"],"<tictactoe::GameEndedSnafu as std::clone::Clone>::clone":["tictactoe::GameEndedSnafu"],"<tictactoe::GameEndedSnafu as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","tictactoe::GameEndedSnafu"],"<tictactoe::GameState as std::clone::Clone>::clone":["tictactoe::GameState","tictactoe::Player"],"<tictactoe::GameState as std::cmp::Eq>::assert_receiver_is_total_eq":["tictactoe::GameState","tictactoe::Player"],"<tictactoe::GameState as std::cmp::PartialEq>::eq":["tictactoe::GameState","tictactoe::Player"],"<tictactoe::GameState as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","tictactoe::GameState","tictactoe::Player"],"<tictactoe::OccupiedPositionSnafu as snafu::IntoError<tictactoe::TicTacToeError>>::into_error":["tictactoe::OccupiedPositionSnafu","tictactoe::TicTacToeError"],"<tictactoe::OccupiedPositionSnafu as std::clone::Clone>::clone":["tictactoe::OccupiedPositionSnafu"],"<tictactoe::OccupiedPositionSnafu as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","tictactoe::OccupiedPositionSnafu"],"<tictactoe::Player as std::clone::Clone>::clone":["tictactoe::Player"],"<tictactoe::Player as std::cmp::Eq>::assert_receiver_is_total_eq":["tictactoe::Player"],"<tictactoe::Player as std::cmp::PartialEq>::eq":["tictactoe::Player"],"<tictactoe::Player as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","tictactoe::Player"],"<tictactoe::TicTacToe as std::clone::Clone>::clone":["std::marker::Sized","std::option::Option","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToe"],"<tictactoe::TicTacToe as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToe"],"<tictactoe::TicTacToeError as snafu::Error>::cause":["std::marker::Sized","std::option::Option","tictactoe::TicTacToeError"],"<tictactoe::TicTacToeError as snafu::Error>::description":["tictactoe::TicTacToeError"],"<tictactoe::TicTacToeError as snafu::Error>::source":["std::marker::Sized","std::option::Option","tictactoe::TicTacToeError"],"<tictactoe::TicTacToeError as snafu::ErrorCompat>::backtrace":["std::marker::Sized","std::option::Option","tictactoe::TicTacToeError"],"<tictactoe::TicTacToeError as std::cmp::Eq>::assert_receiver_is_total_eq":["tictactoe::TicTacToeError"],"<tictactoe::TicTacToeError as std::cmp::PartialEq>::eq":["tictactoe::TicTacToeError"],"<tictactoe::TicTacToeError as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","tictactoe::TicTacToeError"],"<tictactoe::TicTacToeError as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","tictactoe::TicTacToeError"],"<tictactoe::WrongPlayerSnafu as snafu::IntoError<tictactoe::TicTacToeError>>::into_error":["tictactoe::TicTacToeError","tictactoe::WrongPlayerSnafu"],"<tictactoe::WrongPlayerSnafu as std::clone::Clone>::clone":["tictactoe::WrongPlayerSnafu"],"<tictactoe::WrongPlayerSnafu as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","tictactoe::WrongPlayerSnafu"],"connect_four::Column":["connect_four::Column","std::marker::Sized","std::option::Option"],"connect_four::Column::is_full":["connect_four::Column","std::marker::Sized","std::option::Option"],"connect_four::Column::push":["connect_four::Column","connect_four::Player","std::marker::Sized","std::option::Option"],"connect_four::ColumnFilledSnafu":["connect_four::ColumnFilledSnafu"],"connect_four::ColumnFilledSnafu::build":["connect_four::ColumnFilledSnafu","connect_four::ConnectFourError"],"connect_four::ColumnFilledSnafu::fail":["connect_four::ColumnFilledSnafu","std::marker::Sized","std::result::Result"],"connect_four::ConnectFour":["connect_four::Column","connect_four::ConnectFour","connect_four::GameState","connect_four::Player","std::marker::Sized","std::option::Option"],"connect_four::ConnectFour::check_state":["connect_four::Column","connect_four::ConnectFour","connect_four::GameState","connect_four::Player","std::marker::Sized","std::option::Option"],"connect_four::ConnectFour::get":["connect_four::Column","connect_four::ConnectFour","connect_four::GameState","connect_four::Player","std::marker::Sized","std::option::Option"],"connect_four::ConnectFour::get_connectable":[],"connect_four::ConnectFour::get_next_player":["connect_four::Column","connect_four::ConnectFour","connect_four::GameState","connect_four::Player","std::marker::Sized","std::option::Option"],"connect_four::ConnectFour::is_ended":["connect_four::Column","connect_four::ConnectFour","connect_four::GameState","connect_four::Player","std::marker::Sized","std::option::Option"],"connect_four::ConnectFour::new":["std::marker::Sized","std::result::Result"],"connect_four::ConnectFour::put":["connect_four::Column","connect_four::ConnectFour","connect_four::GameState","connect_four::Player","std::marker::Sized","std::option::Option","std::result::Result"],"connect_four::ConnectFour::status":["connect_four::Column","connect_four::ConnectFour","connect_four::GameState","connect_four::Player","std::marker::Sized","std::option::Option"],"connect_four::ConnectFour::winner":["connect_four::Column","connect_four::ConnectFour","connect_four::GameState","connect_four::Player","std::marker::Sized","std::option::Option"],"connect_four::ConnectFourError":["connect_four::ConnectFourError"],"connect_four::GameEndedSnafu":["connect_four::GameEndedSnafu"],"connect_four::GameEndedSnafu::build":["connect_four::ConnectFourError","connect_four::GameEndedSnafu"],"connect_four::GameEndedSnafu::fail":["connect_four::GameEndedSnafu","std::marker::Sized","std::result::Result"],"connect_four::GameState":["connect_four::GameState","connect_four::Player"],"connect_four::Player":["connect_four::Player"],"connect_four::Player::other":["connect_four::Player"],"connect_four::WrongPlayerSnafu":["connect_four::WrongPlayerSnafu"],"connect_four::WrongPlayerSnafu::build":["connect_four::ConnectFourError","connect_four::WrongPlayerSnafu"],"connect_four::WrongPlayerSnafu::fail":["connect_four::WrongPlayerSnafu","std::marker::Sized","std::result::Result"],"gomoku::GameEndedSnafu":["gomoku::GameEndedSnafu"],"gomoku::GameEndedSnafu::build":["gomoku::GameEndedSnafu","gomoku::GomokuError"],"gomoku::GameEndedSnafu::fail":["gomoku::GameEndedSnafu","std::marker::Sized","std::result::Result"],"gomoku::GameState":["gomoku::GameState","gomoku::Player"],"gomoku::Gomoku":["gomoku::GameState","gomoku::Gomoku","gomoku::Player","std::marker::Sized","std::option::Option"],"gomoku::Gomoku::check_state":["gomoku::GameState","gomoku::Gomoku","gomoku::Player","std::marker::Sized","std::option::Option"],"gomoku::Gomoku::get":["gomoku::GameState","gomoku::Gomoku","gomoku::Player","std::marker::Sized","std::option::Option"],"gomoku::Gomoku::get_connectable":[],"gomoku::Gomoku::get_next_player":["gomoku::GameState","gomoku::Gomoku","gomoku::Player","std::marker::Sized","std::option::Option"],"gomoku::Gomoku::is_ended":["gomoku::GameState","gomoku::Gomoku","gomoku::Player","std::marker::Sized","std::option::Option"],"gomoku::Gomoku::new":["std::marker::Sized","std::result::Result"],"gomoku::Gomoku::place":["gomoku::GameState","gomoku::Gomoku","gomoku::Player","std::marker::Sized","std::option::Option","std::result::Result"],"gomoku::Gomoku::status":["gomoku::GameState","gomoku::Gomoku","gomoku::Player","std::marker::Sized","std::option::Option"],"gomoku::Gomoku::winner":["gomoku::GameState","gomoku::Gomoku","gomoku::Player","std::marker::Sized","std::option::Option"],"gomoku::GomokuError":["gomoku::GomokuError"],"gomoku::OccupiedPositionSnafu":["gomoku::OccupiedPositionSnafu"],"gomoku::OccupiedPositionSnafu::build":["gomoku::GomokuError","gomoku::OccupiedPositionSnafu"],"gomoku::OccupiedPositionSnafu::fail":["gomoku::OccupiedPositionSnafu","std::marker::Sized","std::result::Result"],"gomoku::Player":["gomoku::Player"],"gomoku::Player::other":["gomoku::Player"],"gomoku::WrongPlayerSnafu":["gomoku::WrongPlayerSnafu"],"gomoku::WrongPlayerSnafu::build":["gomoku::GomokuError","gomoku::WrongPlayerSnafu"],"gomoku::WrongPlayerSnafu::fail":["gomoku::WrongPlayerSnafu","std::marker::Sized","std::result::Result"],"minesweeper::AdjacentCells":["minesweeper::AdjacentCells"],"minesweeper::AdjacentCells::new":["minesweeper::AdjacentCells"],"minesweeper::AlreadyFlaggedSnafu":["minesweeper::AlreadyFlaggedSnafu"],"minesweeper::AlreadyFlaggedSnafu::build":["minesweeper::AlreadyFlaggedSnafu","minesweeper::MinesweeperError"],"minesweeper::AlreadyFlaggedSnafu::fail":["minesweeper::AlreadyFlaggedSnafu","std::marker::Sized","std::result::Result"],"minesweeper::AlreadyRevealedSnafu":["minesweeper::AlreadyRevealedSnafu"],"minesweeper::AlreadyRevealedSnafu::build":["minesweeper::AlreadyRevealedSnafu","minesweeper::MinesweeperError"],"minesweeper::AlreadyRevealedSnafu::fail":["minesweeper::AlreadyRevealedSnafu","std::marker::Sized","std::result::Result"],"minesweeper::Cell":["minesweeper::Cell"],"minesweeper::Cell::new":["minesweeper::Cell"],"minesweeper::GameEndedSnafu":["minesweeper::GameEndedSnafu"],"minesweeper::GameEndedSnafu::build":["minesweeper::GameEndedSnafu","minesweeper::MinesweeperError"],"minesweeper::GameEndedSnafu::fail":["minesweeper::GameEndedSnafu","std::marker::Sized","std::result::Result"],"minesweeper::GameState":["minesweeper::GameState","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"minesweeper::Minesweeper":["minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"minesweeper::Minesweeper::check_state":["minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"minesweeper::Minesweeper::click":["minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"minesweeper::Minesweeper::click_revealed":["minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"minesweeper::Minesweeper::click_unrevealed":["minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"minesweeper::Minesweeper::get":["minesweeper::Cell","minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"minesweeper::Minesweeper::get_adjacent_cells":["minesweeper::AdjacentCells","minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"minesweeper::Minesweeper::is_ended":["minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"minesweeper::Minesweeper::new":["rand::Rng","std::marker::Sized","std::result::Result"],"minesweeper::Minesweeper::randomize":["minesweeper::GameState","minesweeper::Minesweeper","rand::Rng","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"minesweeper::Minesweeper::reveal_from":["minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"minesweeper::Minesweeper::status":["minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"minesweeper::Minesweeper::toggle_flag":["minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"minesweeper::Minesweeper::update_around_mine_count":["minesweeper::GameState","minesweeper::Minesweeper","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"minesweeper::MinesweeperError":["minesweeper::MinesweeperError"],"minesweeper::TooManyMinesSnafu":["minesweeper::TooManyMinesSnafu"],"minesweeper::TooManyMinesSnafu::build":["minesweeper::MinesweeperError","minesweeper::TooManyMinesSnafu"],"minesweeper::TooManyMinesSnafu::fail":["minesweeper::TooManyMinesSnafu","std::marker::Sized","std::result::Result"],"reversi::Direction":["reversi::Direction"],"reversi::Direction::as_offset":["reversi::Direction"],"reversi::Direction::iter":[],"reversi::GameEndedSnafu":["reversi::GameEndedSnafu"],"reversi::GameEndedSnafu::build":["reversi::GameEndedSnafu","reversi::ReversiError"],"reversi::GameEndedSnafu::fail":["reversi::GameEndedSnafu","std::marker::Sized","std::result::Result"],"reversi::GameState":["reversi::GameState","reversi::Player"],"reversi::InvalidPositionSnafu":["reversi::InvalidPositionSnafu"],"reversi::InvalidPositionSnafu::build":["reversi::InvalidPositionSnafu","reversi::ReversiError"],"reversi::InvalidPositionSnafu::fail":["reversi::InvalidPositionSnafu","std::marker::Sized","std::result::Result"],"reversi::OccupiedPositionSnafu":["reversi::OccupiedPositionSnafu"],"reversi::OccupiedPositionSnafu::build":["reversi::OccupiedPositionSnafu","reversi::ReversiError"],"reversi::OccupiedPositionSnafu::fail":["reversi::OccupiedPositionSnafu","std::marker::Sized","std::result::Result"],"reversi::Player":["reversi::Player"],"reversi::Player::other":["reversi::Player"],"reversi::Reversi":["reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option"],"reversi::Reversi::can_player_move":["reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option"],"reversi::Reversi::check_occupied_line_in_direction":["reversi::Direction","reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option"],"reversi::Reversi::check_position_validity":["reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option","std::result::Result"],"reversi::Reversi::check_state":["reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option"],"reversi::Reversi::flip":["reversi::Direction","reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option"],"reversi::Reversi::get":["reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option"],"reversi::Reversi::get_next_player":["reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option"],"reversi::Reversi::is_ended":["reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option"],"reversi::Reversi::iter_positions_in_direction_from":["reversi::Direction","reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option"],"reversi::Reversi::new":["std::marker::Sized","std::result::Result"],"reversi::Reversi::place":["reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option","std::result::Result"],"reversi::Reversi::simple_check_position_validity":["reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option","std::result::Result"],"reversi::Reversi::status":["reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option"],"reversi::Reversi::winner":["reversi::GameState","reversi::Player","reversi::Reversi","std::marker::Sized","std::option::Option"],"reversi::ReversiError":["reversi::ReversiError"],"reversi::WrongPlayerSnafu":["reversi::WrongPlayerSnafu"],"reversi::WrongPlayerSnafu::build":["reversi::ReversiError","reversi::WrongPlayerSnafu"],"reversi::WrongPlayerSnafu::fail":["reversi::WrongPlayerSnafu","std::marker::Sized","std::result::Result"],"tictactoe::GameEndedSnafu":["tictactoe::GameEndedSnafu"],"tictactoe::GameEndedSnafu::build":["tictactoe::GameEndedSnafu","tictactoe::TicTacToeError"],"tictactoe::GameEndedSnafu::fail":["std::marker::Sized","std::result::Result","tictactoe::GameEndedSnafu"],"tictactoe::GameState":["tictactoe::GameState","tictactoe::Player"],"tictactoe::OccupiedPositionSnafu":["tictactoe::OccupiedPositionSnafu"],"tictactoe::OccupiedPositionSnafu::build":["tictactoe::OccupiedPositionSnafu","tictactoe::TicTacToeError"],"tictactoe::OccupiedPositionSnafu::fail":["std::marker::Sized","std::result::Result","tictactoe::OccupiedPositionSnafu"],"tictactoe::Player":["tictactoe::Player"],"tictactoe::Player::other":["tictactoe::Player"],"tictactoe::TicTacToe":["std::marker::Sized","std::option::Option","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToe"],"tictactoe::TicTacToe::check_state":["std::marker::Sized","std::option::Option","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToe"],"tictactoe::TicTacToe::get":["std::marker::Sized","std::option::Option","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToe"],"tictactoe::TicTacToe::get_next_player":["std::marker::Sized","std::option::Option","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToe"],"tictactoe::TicTacToe::is_ended":["std::marker::Sized","std::option::Option","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToe"],"tictactoe::TicTacToe::new":["std::marker::Sized","std::result::Result"],"tictactoe::TicTacToe::place":["std::marker::Sized","std::option::Option","std::result::Result","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToe"],"tictactoe::TicTacToe::status":["std::marker::Sized","std::option::Option","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToe"],"tictactoe::TicTacToe::winner":["std::marker::Sized","std::option::Option","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToe"],"tictactoe::TicTacToeError":["tictactoe::TicTacToeError"],"tictactoe::WrongPlayerSnafu":["tictactoe::WrongPlayerSnafu"],"tictactoe::WrongPlayerSnafu::build":["tictactoe::TicTacToeError","tictactoe::WrongPlayerSnafu"],"tictactoe::WrongPlayerSnafu::fail":["std::marker::Sized","std::result::Result","tictactoe::WrongPlayerSnafu"]},"glob_path_import":{},"self_to_fn":{"connect_four::Column":["Clone","Debug","Eq","PartialEq","impl Column {\n    fn is_full(&self) -> bool {\n        self.occupied == 6\n    }\n\n    fn push(&mut self, player: Player) {\n        self.column[self.occupied] = Some(player);\n        self.occupied += 1;\n    }\n}","impl Default for Column {\n    fn default() -> Self {\n        Self {\n            column: [None; 6],\n            occupied: 0,\n        }\n    }\n}","impl Index<usize> for Column {\n    type Output = Option<Player>;\n\n    fn index(&self, index: usize) -> &Self::Output {\n        &self.column[index]\n    }\n}","impl IndexMut<usize> for Column {\n    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n        &mut self.column[index]\n    }\n}"],"connect_four::ColumnFilledSnafu":["Snafu"],"connect_four::ConnectFour":["Clone","Debug","impl ConnectFour {\n    /// Create a new Connect Four game\n    pub fn new() -> Result<Self, Infallible> {\n        Ok(Self {\n            board: Default::default(),\n            next: Player::Player0,\n            status: GameState::InProgress,\n        })\n    }\n\n    /// Get a cell reference from the game board\n    /// Panic when target position out of bounds\n    pub fn get(&self, row: usize, col: usize) -> &Option<Player> {\n        &self.board[5 - row][col]\n    }\n\n    /// Check if the game was end\n    pub fn is_ended(&self) -> bool {\n        self.status != GameState::InProgress\n    }\n\n    /// Get the winner of the game. Return `None` when the game is tied or not end yet\n    pub fn winner(&self) -> Option<Player> {\n        if let GameState::Win(player) = self.status {\n            Some(player)\n        } else {\n            None\n        }\n    }\n\n    /// Get the game status\n    pub fn status(&self) -> &GameState {\n        &self.status\n    }\n\n    /// Get the next player\n    pub fn get_next_player(&self) -> Player {\n        self.next\n    }\n\n    /// Put a piece into the game board\n    /// Panic when target position out of bounds\n    pub fn put(&mut self, player: Player, col: usize) -> Result<(), ConnectFourError> {\n        if self.is_ended() {\n            return Err(ConnectFourError::GameEnded);\n        }\n\n        if player != self.next {\n            return Err(ConnectFourError::WrongPlayer);\n        }\n\n        if self.board[col].is_full() {\n            return Err(ConnectFourError::ColumnFilled);\n        }\n\n        self.board[col].push(player);\n        self.next = self.next.other();\n\n        self.check_state();\n\n        Ok(())\n    }\n\n    fn check_state(&mut self) {\n        for connectable in Self::get_connectable() {\n            let mut last = None;\n            let mut count = 0u8;\n\n            for cell in connectable.map(|(row, col)| self.board[col][row]) {\n                if cell != last {\n                    last = cell;\n                    count = 1;\n                } else {\n                    count += 1;\n                    if count == 4 && cell.is_some() {\n                        self.status = GameState::Win(cell.unwrap());\n                        return;\n                    }\n                }\n            }\n        }\n\n        if (0..7).all(|col| self.board[col][5].is_some()) {\n            self.status = GameState::Tie;\n        }\n    }\n\n    fn get_connectable() -> impl Iterator<Item = Box<dyn Iterator<Item = (usize, usize)>>> {\n        let horizontal = (0usize..6).map(move |row| {\n            Box::new((0usize..7).map(move |col| (row, col)))\n                as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let vertical = (0usize..7).map(move |col| {\n            Box::new((0usize..6).map(move |row| (row, col)))\n                as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let horizontal_upper_left_to_lower_right = (0usize..7).map(move |col| {\n            Box::new(\n                iter::successors(Some((0usize, col)), |(row, col)| Some((row + 1, col + 1)))\n                    .take((7 - col).min(6)),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let vertical_upper_left_to_lower_right = (0usize..6).map(move |row| {\n            Box::new(\n                iter::successors(Some((row, 0usize)), |(row, col)| Some((row + 1, col + 1)))\n                    .take(6 - row),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let horizontal_upper_right_to_lower_left = (0usize..7).map(move |col| {\n            Box::new(\n                iter::successors(Some((0usize, col)), |(row, col)| {\n                    col.checked_sub(1).map(|new_col| (row + 1, new_col))\n                })\n                .take((1 + col).min(6)),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let vertical_upper_right_to_lower_left = (0usize..6).map(move |row| {\n            Box::new(\n                iter::successors(Some((row, 6usize)), |(row, col)| Some((row + 1, col - 1)))\n                    .take(6 - row),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        horizontal\n            .chain(vertical)\n            .chain(horizontal_upper_left_to_lower_right)\n            .chain(vertical_upper_left_to_lower_right)\n            .chain(horizontal_upper_right_to_lower_left)\n            .chain(vertical_upper_right_to_lower_left)\n    }\n}"],"connect_four::ConnectFourError":["Debug","Eq","PartialEq","Snafu"],"connect_four::GameEndedSnafu":["Snafu"],"connect_four::GameState":["Clone","Debug","Eq","PartialEq"],"connect_four::Player":["Clone","Copy","Debug","Eq","PartialEq","impl Player {\n    /// Get the opposite player\n    pub fn other(self) -> Self {\n        match self {\n            Player::Player0 => Player::Player1,\n            Player::Player1 => Player::Player0,\n        }\n    }\n}"],"connect_four::WrongPlayerSnafu":["Snafu"],"gomoku::GameEndedSnafu":["Snafu"],"gomoku::GameState":["Clone","Debug","Eq","PartialEq"],"gomoku::Gomoku":["Clone","Debug","impl Gomoku {\n    /// Create a new Gomoku game.\n    pub fn new() -> Result<Self, Infallible> {\n        Ok(Self {\n            board: [[None; 15]; 15],\n            next: Player::Player0,\n            status: GameState::InProgress,\n        })\n    }\n\n    /// Get a cell reference from the game board\n    /// Panic when target position out of bounds\n    pub fn get(&self, row: usize, col: usize) -> &Option<Player> {\n        &self.board[row][col]\n    }\n\n    /// Check if the game was end\n    pub fn is_ended(&self) -> bool {\n        self.status != GameState::InProgress\n    }\n\n    /// Get the winner of the game. Return `None` when the game is tied or not end yet\n    pub fn winner(&self) -> Option<Player> {\n        if let GameState::Win(player) = self.status {\n            Some(player)\n        } else {\n            None\n        }\n    }\n\n    /// Get the game status\n    pub fn status(&self) -> &GameState {\n        &self.status\n    }\n\n    /// Get the next player\n    pub fn get_next_player(&self) -> Player {\n        self.next\n    }\n\n    /// Place a piece on the board\n    /// Panic when target position out of bounds\n    pub fn place(&mut self, player: Player, row: usize, col: usize) -> Result<(), GomokuError> {\n        if self.is_ended() {\n            return Err(GomokuError::GameEnded);\n        }\n\n        if player != self.next {\n            return Err(GomokuError::WrongPlayer);\n        }\n\n        if self.board[row][col].is_some() {\n            return Err(GomokuError::OccupiedPosition);\n        }\n\n        self.board[row][col] = Some(player);\n        self.next = self.next.other();\n\n        self.check_state();\n\n        Ok(())\n    }\n\n    fn check_state(&mut self) {\n        for connectable in Self::get_connectable() {\n            let mut last = None;\n            let mut count = 0u8;\n\n            for cell in connectable.map(|(row, col)| self.board[col][row]) {\n                if cell != last {\n                    last = cell;\n                    count = 1;\n                } else {\n                    count += 1;\n                    if count == 5 && cell.is_some() {\n                        self.status = GameState::Win(cell.unwrap());\n                        return;\n                    }\n                }\n            }\n        }\n\n        if self.board.iter().flatten().all(|cell| cell.is_some()) {\n            self.status = GameState::Tie;\n        }\n    }\n\n    fn get_connectable() -> impl Iterator<Item = Box<dyn Iterator<Item = (usize, usize)>>> {\n        let horizontal = (0usize..15).map(move |row| {\n            Box::new((0usize..15).map(move |col| (row, col)))\n                as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let vertical = (0usize..15).map(move |col| {\n            Box::new((0usize..15).map(move |row| (row, col)))\n                as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let horizontal_upper_left_to_lower_right = (0usize..15).map(move |col| {\n            Box::new(\n                iter::successors(Some((0usize, col)), |(row, col)| Some((row + 1, col + 1)))\n                    .take(15 - col),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let vertical_upper_left_to_lower_right = (0usize..15).map(move |row| {\n            Box::new(\n                iter::successors(Some((row, 0usize)), |(row, col)| Some((row + 1, col + 1)))\n                    .take(15 - row),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let horizontal_upper_right_to_lower_left = (0usize..15).map(move |col| {\n            Box::new(\n                iter::successors(Some((0usize, col)), |(row, col)| {\n                    col.checked_sub(1).map(|new_col| (row + 1, new_col))\n                })\n                .take(1 + col),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let vertical_upper_right_to_lower_left = (0usize..15).map(move |row| {\n            Box::new(\n                iter::successors(Some((row, 14usize)), |(row, col)| Some((row + 1, col - 1)))\n                    .take(15 - row),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        horizontal\n            .chain(vertical)\n            .chain(horizontal_upper_left_to_lower_right)\n            .chain(vertical_upper_left_to_lower_right)\n            .chain(horizontal_upper_right_to_lower_left)\n            .chain(vertical_upper_right_to_lower_left)\n    }\n}"],"gomoku::GomokuError":["Debug","Eq","PartialEq","Snafu"],"gomoku::OccupiedPositionSnafu":["Snafu"],"gomoku::Player":["Clone","Copy","Debug","Eq","PartialEq","impl Player {\n    /// Get the opposite player\n    pub fn other(self) -> Self {\n        match self {\n            Player::Player0 => Player::Player1,\n            Player::Player1 => Player::Player0,\n        }\n    }\n}"],"gomoku::WrongPlayerSnafu":["Snafu"],"minesweeper::AdjacentCells":["Clone","impl AdjacentCells {\n    fn new(row: usize, col: usize, board_height: usize, board_width: usize) -> Self {\n        let (row, col, board_height, board_width) = (\n            row as isize,\n            col as isize,\n            board_height as isize,\n            board_width as isize,\n        );\n\n        AdjacentCells {\n            around: [\n                (row - 1, col - 1),\n                (row - 1, col),\n                (row - 1, col + 1),\n                (row, col - 1),\n                (row, col + 1),\n                (row + 1, col - 1),\n                (row + 1, col),\n                (row + 1, col + 1),\n            ],\n            board_height,\n            board_width,\n            offset: 0,\n        }\n    }\n}","impl Iterator for AdjacentCells {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.around[self.offset..]\n            .iter()\n            .enumerate()\n            .filter(|(_, (row, col))| {\n                *row >= 0 && *col >= 0 && *row < self.board_height && *col < self.board_width\n            })\n            .next()\n            .map(|(idx, (row, col))| {\n                self.offset += idx + 1;\n                (row * self.board_width + col) as usize\n            })\n    }\n}"],"minesweeper::AlreadyFlaggedSnafu":["Snafu"],"minesweeper::AlreadyRevealedSnafu":["Snafu"],"minesweeper::Cell":["Clone","Copy","Debug","Eq","PartialEq","impl Cell {\n    fn new(is_mine: bool) -> Self {\n        Self {\n            is_mine,\n            mine_adjacent: 0,\n            is_revealed: false,\n            is_flagged: false,\n        }\n    }\n}"],"minesweeper::GameEndedSnafu":["Snafu"],"minesweeper::GameState":["Clone","Debug","Eq","PartialEq"],"minesweeper::Minesweeper":["Clone","Debug","impl Minesweeper {\n    /// Create a new Minesweeper game\n    ///\n    /// A mutable reference of a random number generator is required for randomizing mine positions\n    ///\n    /// Return `Err(MinesweeperError::TooManyMines)` if `height * width < mines`\n    ///\n    /// # Examples\n    /// ```rust\n    /// # fn minesweeper() {\n    /// use gamie::minesweeper::Minesweeper;\n    /// use rand::rngs::ThreadRng;\n    ///\n    /// let mut game = Minesweeper::new(8, 8, 9, &mut ThreadRng::default()).unwrap();\n    /// # }\n    /// ```\n    pub fn new<R: Rng + ?Sized>(\n        height: usize,\n        width: usize,\n        mines: usize,\n        rng: &mut R,\n    ) -> Result<Self, MinesweeperError> {\n        if height * width < mines {\n            return Err(MinesweeperError::TooManyMines);\n        }\n\n        let board = iter::repeat(Cell::new(true))\n            .take(mines)\n            .chain(iter::repeat(Cell::new(false)).take(height * width - mines))\n            .collect();\n\n        let mut minesweeper = Self {\n            board,\n            height,\n            width,\n            status: GameState::InProgress,\n        };\n        minesweeper.randomize(rng).unwrap();\n\n        Ok(minesweeper)\n    }\n\n    /// Randomize the board\n    ///\n    /// A mutable reference of a random number generator is required for randomizing mine positions\n    pub fn randomize<R: Rng + ?Sized>(&mut self, rng: &mut R) -> Result<(), MinesweeperError> {\n        if self.is_ended() {\n            return Err(MinesweeperError::GameEnded);\n        }\n\n        let range = Uniform::from(0..self.height * self.width);\n\n        for idx in 0..self.height * self.width {\n            self.board.swap(idx, range.sample(rng));\n        }\n\n        self.update_around_mine_count();\n\n        Ok(())\n    }\n\n    /// Get a cell reference from the game board\n    /// Panic when target position out of bounds\n    pub fn get(&self, row: usize, col: usize) -> &Cell {\n        if row >= self.height || col >= self.width {\n            panic!(\"Invalid position: ({}, {})\", row, col);\n        }\n\n        &self.board[row * self.width + col]\n    }\n\n    /// Check if the game was end\n    pub fn is_ended(&self) -> bool {\n        self.status != GameState::InProgress\n    }\n\n    /// Get the game status\n    pub fn status(&self) -> &GameState {\n        &self.status\n    }\n\n    /// Click a cell on the game board\n    ///\n    /// Clicking an already revealed cell will unreveal its adjacent cells if the flagged cell count around it equals to its adjacent mine count\n    /// When `auto_flag` is `true`, clicking an already revealed cell will flag its adjacent unflagged-unrevealed cells if the unflagged-revealed cell count around it equals to its adjacent mine count\n    ///\n    /// The return value indicates if the game board is changed from the click\n    ///\n    /// Panic when target position out of bounds\n    pub fn click(\n        &mut self,\n        row: usize,\n        col: usize,\n        auto_flag: bool,\n    ) -> Result<bool, MinesweeperError> {\n        if row >= self.height || col >= self.width {\n            panic!(\"Invalid position: ({}, {})\", row, col);\n        }\n\n        if self.is_ended() {\n            return Err(MinesweeperError::GameEnded);\n        }\n\n        if !self.board[row * self.width + col].is_revealed {\n            self.click_unrevealed(row, col)?;\n            Ok(true)\n        } else {\n            Ok(self.click_revealed(row, col, auto_flag)?)\n        }\n    }\n\n    /// Flag or unflag a cell on the board\n    /// Return Err(MinesweeperError::AlreadyRevealed) if the target cell is already revealed\n    ///\n    /// Panic when target position out of bounds\n    pub fn toggle_flag(&mut self, row: usize, col: usize) -> Result<(), MinesweeperError> {\n        if row >= self.height || col >= self.width {\n            panic!(\"Invalid position: ({}, {})\", row, col);\n        }\n\n        if self.is_ended() {\n            return Err(MinesweeperError::GameEnded);\n        }\n\n        if self.board[row * self.width + col].is_revealed {\n            return Err(MinesweeperError::AlreadyRevealed);\n        }\n\n        self.board[row * self.width + col].is_flagged =\n            !self.board[row * self.width + col].is_flagged;\n\n        self.check_state();\n\n        Ok(())\n    }\n\n    fn click_unrevealed(&mut self, row: usize, col: usize) -> Result<(), MinesweeperError> {\n        if self.board[row * self.width + col].is_flagged {\n            return Err(MinesweeperError::AlreadyFlagged);\n        }\n\n        if self.board[row * self.width + col].is_mine {\n            self.status = GameState::Exploded(vec![(row, col)]);\n            return Ok(());\n        }\n\n        self.reveal_from(row * self.width + col);\n        self.check_state();\n\n        Ok(())\n    }\n\n    fn click_revealed(\n        &mut self,\n        row: usize,\n        col: usize,\n        auto_flag: bool,\n    ) -> Result<bool, MinesweeperError> {\n        let mut is_changed = false;\n\n        if self.board[row * self.width + col].mine_adjacent > 0 {\n            let mut adjacent_all = 0;\n            let mut adjacent_revealed = 0;\n            let mut adjacent_flagged = 0;\n\n            self.get_adjacent_cells(row, col)\n                .map(|idx| self.board[idx])\n                .for_each(|cell| {\n                    adjacent_all += 1;\n\n                    if cell.is_revealed {\n                        adjacent_revealed += 1;\n                    } else if cell.is_flagged {\n                        adjacent_flagged += 1;\n                    }\n                });\n\n            let adjacent_unrevealed = adjacent_all - adjacent_revealed - adjacent_flagged;\n\n            if adjacent_unrevealed > 0 {\n                if adjacent_flagged == self.board[row * self.width + col].mine_adjacent {\n                    let mut exploded = None;\n\n                    self.get_adjacent_cells(row, col).for_each(|idx| {\n                        if !self.board[idx].is_flagged && !self.board[idx].is_revealed {\n                            if self.board[idx].is_mine {\n                                self.board[idx].is_revealed = true;\n\n                                match exploded {\n                                    None => exploded = Some(vec![(row, col)]),\n                                    Some(ref mut exploded) => {\n                                        exploded.push((row, col));\n                                    }\n                                }\n                            } else {\n                                self.reveal_from(idx);\n                                is_changed = true;\n                            }\n                        }\n                    });\n\n                    if let Some(exploded) = exploded {\n                        self.status = GameState::Exploded(exploded);\n                        return Ok(true);\n                    }\n                }\n\n                if auto_flag\n                    && adjacent_unrevealed + adjacent_flagged\n                        == self.board[row * self.width + col].mine_adjacent\n                {\n                    self.get_adjacent_cells(row, col).for_each(|idx| {\n                        if !self.board[idx].is_flagged && !self.board[idx].is_revealed {\n                            self.board[idx].is_flagged = true;\n                            is_changed = true;\n                        }\n                    });\n                }\n            }\n\n            self.check_state();\n        }\n\n        Ok(is_changed)\n    }\n\n    fn reveal_from(&mut self, idx: usize) {\n        if self.board[idx].mine_adjacent != 0 {\n            self.board[idx].is_revealed = true;\n        } else {\n            let mut cell_idxs_to_reveal = VecDeque::new();\n            cell_idxs_to_reveal.push_back(idx);\n\n            while let Some(cell_idx) = cell_idxs_to_reveal.pop_front() {\n                self.board[cell_idx].is_revealed = true;\n\n                for neighbor_idx in\n                    self.get_adjacent_cells(cell_idx / self.width, cell_idx % self.width)\n                {\n                    if !self.board[neighbor_idx].is_flagged && !self.board[neighbor_idx].is_revealed\n                    {\n                        if self.board[neighbor_idx].mine_adjacent == 0 {\n                            cell_idxs_to_reveal.push_back(neighbor_idx);\n                        } else {\n                            self.board[neighbor_idx].is_revealed = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    fn check_state(&mut self) {\n        self.status = if self\n            .board\n            .iter()\n            .filter(|cell| !cell.is_mine)\n            .all(|cell| cell.is_revealed)\n        {\n            GameState::Win\n        } else {\n            GameState::InProgress\n        };\n    }\n\n    fn update_around_mine_count(&mut self) {\n        for idx in 0..self.height * self.width {\n            let count = self\n                .get_adjacent_cells(idx / self.width, idx % self.width)\n                .filter(|idx| self.board[*idx].is_mine)\n                .count();\n\n            self.board[idx].mine_adjacent = count;\n        }\n    }\n\n    fn get_adjacent_cells(&self, row: usize, col: usize) -> AdjacentCells {\n        AdjacentCells::new(row, col, self.height, self.width)\n    }\n}"],"minesweeper::MinesweeperError":["Debug","Eq","PartialEq","Snafu"],"minesweeper::TooManyMinesSnafu":["Snafu"],"reversi::Direction":["Clone","Copy","Debug","PartialEq","impl Direction {\n    fn as_offset(&self) -> (i8, i8) {\n        match self {\n            Direction::Upper => (-1, 0),\n            Direction::UpperRight => (-1, 1),\n            Direction::Right => (0, 1),\n            Direction::LowerRight => (1, 1),\n            Direction::Lower => (1, 0),\n            Direction::LowerLeft => (1, -1),\n            Direction::Left => (0, -1),\n            Direction::UpperLeft => (-1, -1),\n        }\n    }\n\n    fn iter() -> impl Iterator<Item = Self> {\n        [\n            Direction::Upper,\n            Direction::UpperRight,\n            Direction::Right,\n            Direction::LowerRight,\n            Direction::Lower,\n            Direction::LowerLeft,\n            Direction::Left,\n            Direction::UpperLeft,\n        ]\n        .into_iter()\n    }\n}"],"reversi::GameEndedSnafu":["Snafu"],"reversi::GameState":["Clone","Debug","Eq","PartialEq"],"reversi::InvalidPositionSnafu":["Snafu"],"reversi::OccupiedPositionSnafu":["Snafu"],"reversi::Player":["Clone","Copy","Debug","Eq","PartialEq","impl Player {\n    /// Get the opposite player\n    pub fn other(self) -> Self {\n        match self {\n            Player::Player0 => Player::Player1,\n            Player::Player1 => Player::Player0,\n        }\n    }\n}"],"reversi::Reversi":["Clone","Debug","impl Reversi {\n    /// Create a new Reversi game\n    pub fn new() -> Result<Self, Infallible> {\n        let mut board = [[None; 8]; 8];\n        board[3][3] = Some(Player::Player0);\n        board[4][4] = Some(Player::Player0);\n        board[3][4] = Some(Player::Player1);\n        board[4][3] = Some(Player::Player1);\n\n        Ok(Self {\n            board,\n            next: Player::Player0,\n            status: GameState::InProgress,\n        })\n    }\n\n    /// Get a cell reference from the game board\n    /// Panic when target position out of bounds\n    pub fn get(&self, row: usize, col: usize) -> &Option<Player> {\n        &self.board[row][col]\n    }\n\n    /// Check if the game was end\n    pub fn is_ended(&self) -> bool {\n        self.status != GameState::InProgress\n    }\n\n    /// Get the winner of the game. Return `None` when the game is tied or not end yet\n    pub fn winner(&self) -> Option<Player> {\n        if let GameState::Win(player) = self.status {\n            Some(player)\n        } else {\n            None\n        }\n    }\n\n    /// Get the game status\n    pub fn status(&self) -> &GameState {\n        &self.status\n    }\n\n    /// Get the next player\n    pub fn get_next_player(&self) -> Player {\n        self.next\n    }\n\n    /// Place a piece on the board\n    /// Panic when target position out of bounds\n    pub fn place(&mut self, player: Player, row: usize, col: usize) -> Result<(), ReversiError> {\n        self.simple_check_position_validity(row, col, player)?;\n\n        let mut flipped = false;\n\n        for dir in Direction::iter() {\n            if let Some((to_row, to_col)) =\n                self.check_occupied_line_in_direction(row, col, dir, player)\n            {\n                self.flip(row, col, to_row, to_col, dir, player);\n                flipped = true;\n            }\n        }\n\n        if flipped {\n            self.next = player.other();\n\n            if !self.can_player_move(player.other()) {\n                self.next = player;\n\n                if !self.can_player_move(player) {\n                    self.check_state();\n                }\n            }\n\n            Ok(())\n        } else {\n            Err(ReversiError::InvalidPosition)\n        }\n    }\n\n    /// Check if a position is valid for placing piece\n    /// Panic when target position out of bounds\n    pub fn check_position_validity(\n        &self,\n        row: usize,\n        col: usize,\n        player: Player,\n    ) -> Result<(), ReversiError> {\n        self.simple_check_position_validity(row, col, player)?;\n\n        if Direction::iter()\n            .map(|dir| self.check_occupied_line_in_direction(row, col, dir, player))\n            .any(|o| o.is_some())\n        {\n            Ok(())\n        } else {\n            Err(ReversiError::InvalidPosition)\n        }\n    }\n\n    fn simple_check_position_validity(\n        &self,\n        row: usize,\n        col: usize,\n        player: Player,\n    ) -> Result<(), ReversiError> {\n        if self.is_ended() {\n            return Err(ReversiError::GameEnded);\n        }\n\n        if player != self.next {\n            return Err(ReversiError::WrongPlayer);\n        }\n\n        if self.board[row][col].is_some() {\n            return Err(ReversiError::OccupiedPosition);\n        }\n\n        Ok(())\n    }\n\n    fn can_player_move(&self, player: Player) -> bool {\n        for row in 0..8 {\n            for col in 0..8 {\n                if self.board[row][col].is_none()\n                    && self.check_position_validity(row, col, player).is_ok()\n                {\n                    return true;\n                }\n            }\n        }\n\n        false\n    }\n\n    fn check_state(&mut self) {\n        let mut black_count = 0;\n        let mut white_count = 0;\n\n        for cell in self.board.iter().flatten().flatten() {\n            match cell {\n                Player::Player0 => black_count += 1,\n                Player::Player1 => white_count += 1,\n            }\n        }\n\n        self.status = match black_count.cmp(&white_count) {\n            Ordering::Less => GameState::Win(Player::Player1),\n            Ordering::Equal => GameState::Tie,\n            Ordering::Greater => GameState::Win(Player::Player0),\n        };\n    }\n\n    fn flip(\n        &mut self,\n        from_row: usize,\n        from_col: usize,\n        to_row: usize,\n        to_col: usize,\n        dir: Direction,\n        player: Player,\n    ) {\n        self.iter_positions_in_direction_from(from_row, from_col, dir)\n            .take_while(|(row, col)| *row != to_row || *col != to_col)\n            .for_each(|(row, col)| {\n                self.board[row][col] = Some(player);\n            });\n    }\n\n    fn check_occupied_line_in_direction(\n        &self,\n        row: usize,\n        col: usize,\n        dir: Direction,\n        player: Player,\n    ) -> Option<(usize, usize)> {\n        let mut pos = self.iter_positions_in_direction_from(row, col, dir);\n\n        pos.next();\n\n        let first = if let Some(pos) = pos.next() {\n            pos\n        } else {\n            return None;\n        };\n\n        if self.board[first.0][first.1] != Some(player.other()) {\n            return None;\n        }\n\n        for (row, col) in pos {\n            match self.board[row][col] {\n                Some(piece) if piece == player.other() => continue,\n                Some(_) => return Some((row, col)),\n                None => return None,\n            }\n        }\n\n        None\n    }\n\n    fn iter_positions_in_direction_from(\n        &self,\n        row: usize,\n        col: usize,\n        dir: Direction,\n    ) -> impl Iterator<Item = (usize, usize)> {\n        iter::successors(Some((row, col)), move |(row, col)| {\n            let (offset_row, offset_col) = dir.as_offset();\n            Some((\n                (*row as i8 + offset_row) as usize,\n                (*col as i8 + offset_col) as usize,\n            ))\n        })\n        .take_while(|(row, col)| *row < 8 && *col < 8)\n    }\n}"],"reversi::ReversiError":["Debug","Eq","PartialEq","Snafu"],"reversi::WrongPlayerSnafu":["Snafu"],"tictactoe::GameEndedSnafu":["Snafu"],"tictactoe::GameState":["Clone","Debug","Eq","PartialEq"],"tictactoe::OccupiedPositionSnafu":["Snafu"],"tictactoe::Player":["Clone","Copy","Debug","Eq","PartialEq","impl Player {\n    /// Get the opposite player\n    pub fn other(self) -> Self {\n        match self {\n            Player::Player0 => Player::Player1,\n            Player::Player1 => Player::Player0,\n        }\n    }\n}"],"tictactoe::TicTacToe":["Clone","Debug","impl TicTacToe {\n    /// Create a new Tic-Tac-Toe game\n    pub fn new() -> Result<Self, Infallible> {\n        Ok(Self {\n            board: [[None; 3]; 3],\n            next: Player::Player0,\n            status: GameState::InProgress,\n        })\n    }\n\n    /// Get a cell reference from the game board\n    /// Panic when target position out of bounds\n    pub fn get(&self, row: usize, col: usize) -> &Option<Player> {\n        &self.board[row][col]\n    }\n\n    /// Check if the game was end\n    pub fn is_ended(&self) -> bool {\n        self.status != GameState::InProgress\n    }\n\n    /// Get the winner of the game. Return `None` when the game is tied or not end yet\n    pub fn winner(&self) -> Option<Player> {\n        if let GameState::Win(player) = self.status {\n            Some(player)\n        } else {\n            None\n        }\n    }\n\n    /// Get the game status\n    pub fn status(&self) -> &GameState {\n        &self.status\n    }\n\n    /// Get the next player\n    pub fn get_next_player(&self) -> Player {\n        self.next\n    }\n\n    /// Place a piece on the board\n    /// Panic when target position out of bounds\n    pub fn place(&mut self, player: Player, row: usize, col: usize) -> Result<(), TicTacToeError> {\n        if self.is_ended() {\n            return Err(TicTacToeError::GameEnded);\n        }\n\n        if player != self.next {\n            return Err(TicTacToeError::WrongPlayer);\n        }\n\n        if self.board[row][col].is_some() {\n            return Err(TicTacToeError::OccupiedPosition);\n        }\n\n        self.board[row][col] = Some(player);\n        self.next = self.next.other();\n\n        self.check_state();\n\n        Ok(())\n    }\n\n    fn check_state(&mut self) {\n        for row in 0..3 {\n            if self.board[row][0].is_some()\n                && self.board[row][0] == self.board[row][1]\n                && self.board[row][1] == self.board[row][2]\n            {\n                self.status = GameState::Win(self.board[row][0].unwrap());\n                return;\n            }\n        }\n\n        for col in 0..3 {\n            if self.board[0][col].is_some()\n                && self.board[0][col] == self.board[1][col]\n                && self.board[1][col] == self.board[2][col]\n            {\n                self.status = GameState::Win(self.board[0][col].unwrap());\n                return;\n            }\n        }\n\n        if self.board[0][0].is_some()\n            && self.board[0][0] == self.board[1][1]\n            && self.board[1][1] == self.board[2][2]\n        {\n            self.status = GameState::Win(self.board[0][0].unwrap());\n            return;\n        }\n\n        if self.board[0][0].is_some()\n            && self.board[0][2] == self.board[1][1]\n            && self.board[1][1] == self.board[2][0]\n        {\n            self.status = GameState::Win(self.board[0][2].unwrap());\n            return;\n        }\n\n        self.status = if self.board.iter().flatten().all(|p| p.is_some()) {\n            GameState::Tie\n        } else {\n            GameState::InProgress\n        };\n    }\n}"],"tictactoe::TicTacToeError":["Debug","Eq","PartialEq","Snafu"],"tictactoe::WrongPlayerSnafu":["Snafu"]},"single_path_import":{"ntest::timeout":"timeout"},"srcs":{"<connect_four::Column as std::default::Default>::default":["fn default() -> Self{\n        Self {\n            column: [None; 6],\n            occupied: 0,\n        }\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"<connect_four::Column as std::ops::Index<usize>>::index":["fn index(&self, index: usize) -> &Self::Output{\n        &self.column[index]\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"<connect_four::Column as std::ops::IndexMut<usize>>::index_mut":["fn index_mut(&mut self, index: usize) -> &mut Self::Output{\n        &mut self.column[index]\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"<minesweeper::AdjacentCells as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        self.around[self.offset..]\n            .iter()\n            .enumerate()\n            .filter(|(_, (row, col))| {\n                *row >= 0 && *col >= 0 && *row < self.board_height && *col < self.board_width\n            })\n            .next()\n            .map(|(idx, (row, col))| {\n                self.offset += idx + 1;\n                (row * self.board_width + col) as usize\n            })\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"connect_four::Column":["/// The column of the game board.\n///\n/// This is a vector-like struct. Inner elements can be accessed by using index\nstruct Column {\n    column: [Option<Player>; 6],\n    occupied: usize,\n}","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::Column::is_full":["fn is_full(&self) -> bool{\n        self.occupied == 6\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::Column::push":["fn push(&mut self, player: Player){\n        self.column[self.occupied] = Some(player);\n        self.occupied += 1;\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::ColumnFilledSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::ConnectFour":["/// Connect Four\n///\n/// Passing an invalid position to a method will cause panic. Check the target position validity first when dealing with user input\npub struct ConnectFour {\n    board: [Column; 7],\n    next: Player,\n    status: GameState,\n}","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::ConnectFour::check_state":["fn check_state(&mut self){\n        for connectable in Self::get_connectable() {\n            let mut last = None;\n            let mut count = 0u8;\n\n            for cell in connectable.map(|(row, col)| self.board[col][row]) {\n                if cell != last {\n                    last = cell;\n                    count = 1;\n                } else {\n                    count += 1;\n                    if count == 4 && cell.is_some() {\n                        self.status = GameState::Win(cell.unwrap());\n                        return;\n                    }\n                }\n            }\n        }\n\n        if (0..7).all(|col| self.board[col][5].is_some()) {\n            self.status = GameState::Tie;\n        }\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::ConnectFour::get":["/// Get a cell reference from the game board\n/// Panic when target position out of bounds\npub fn get(&self, row: usize, col: usize) -> &Option<Player>{\n        &self.board[5 - row][col]\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::ConnectFour::get_connectable":["fn get_connectable() -> impl Iterator<Item = Box<dyn Iterator<Item = (usize, usize)>>>{\n        let horizontal = (0usize..6).map(move |row| {\n            Box::new((0usize..7).map(move |col| (row, col)))\n                as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let vertical = (0usize..7).map(move |col| {\n            Box::new((0usize..6).map(move |row| (row, col)))\n                as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let horizontal_upper_left_to_lower_right = (0usize..7).map(move |col| {\n            Box::new(\n                iter::successors(Some((0usize, col)), |(row, col)| Some((row + 1, col + 1)))\n                    .take((7 - col).min(6)),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let vertical_upper_left_to_lower_right = (0usize..6).map(move |row| {\n            Box::new(\n                iter::successors(Some((row, 0usize)), |(row, col)| Some((row + 1, col + 1)))\n                    .take(6 - row),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let horizontal_upper_right_to_lower_left = (0usize..7).map(move |col| {\n            Box::new(\n                iter::successors(Some((0usize, col)), |(row, col)| {\n                    col.checked_sub(1).map(|new_col| (row + 1, new_col))\n                })\n                .take((1 + col).min(6)),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let vertical_upper_right_to_lower_left = (0usize..6).map(move |row| {\n            Box::new(\n                iter::successors(Some((row, 6usize)), |(row, col)| Some((row + 1, col - 1)))\n                    .take(6 - row),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        horizontal\n            .chain(vertical)\n            .chain(horizontal_upper_left_to_lower_right)\n            .chain(vertical_upper_left_to_lower_right)\n            .chain(horizontal_upper_right_to_lower_left)\n            .chain(vertical_upper_right_to_lower_left)\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::ConnectFour::get_next_player":["/// Get the next player\npub fn get_next_player(&self) -> Player{\n        self.next\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::ConnectFour::is_ended":["/// Check if the game was end\npub fn is_ended(&self) -> bool{\n        self.status != GameState::InProgress\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::ConnectFour::new":["/// Create a new Connect Four game\npub fn new() -> Result<Self, Infallible>{\n        Ok(Self {\n            board: Default::default(),\n            next: Player::Player0,\n            status: GameState::InProgress,\n        })\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::ConnectFour::put":["/// Put a piece into the game board\n/// Panic when target position out of bounds\npub fn put(&mut self, player: Player, col: usize) -> Result<(), ConnectFourError>{\n        if self.is_ended() {\n            return Err(ConnectFourError::GameEnded);\n        }\n\n        if player != self.next {\n            return Err(ConnectFourError::WrongPlayer);\n        }\n\n        if self.board[col].is_full() {\n            return Err(ConnectFourError::ColumnFilled);\n        }\n\n        self.board[col].push(player);\n        self.next = self.next.other();\n\n        self.check_state();\n\n        Ok(())\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::ConnectFour::status":["/// Get the game status\npub fn status(&self) -> &GameState{\n        &self.status\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::ConnectFour::winner":["/// Get the winner of the game. Return `None` when the game is tied or not end yet\npub fn winner(&self) -> Option<Player>{\n        if let GameState::Win(player) = self.status {\n            Some(player)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::ConnectFourError":["/// Errors that can occur when putting a piece into the board\npub enum ConnectFourError {\n    #[snafu(display(\"Wrong player\"))]\n    WrongPlayer,\n    #[snafu(display(\"Filled Column\"))]\n    ColumnFilled,\n    #[snafu(display(\"The game was already end\"))]\n    GameEnded,\n}","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::GameEndedSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::GameState":["/// Game status\npub enum GameState {\n    Win(Player),\n    Tie,\n    InProgress,\n}","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::Player":["/// Players\npub enum Player {\n    Player0,\n    Player1,\n}","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::Player::other":["/// Get the opposite player\npub fn other(self) -> Self{\n        match self {\n            Player::Player0 => Player::Player1,\n            Player::Player1 => Player::Player0,\n        }\n    }","Real(LocalPath(\"src/connect_four.rs\"))"],"connect_four::WrongPlayerSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/connect_four.rs\"))"],"gomoku::GameEndedSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::GameState":["/// Game status\npub enum GameState {\n    Win(Player),\n    Tie,\n    InProgress,\n}","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::Gomoku":["/// Gomoku\n///\n/// Passing an invalid position to a method will cause panic. Check the target position validity first when dealing with user input\npub struct Gomoku {\n    board: [[Option<Player>; 15]; 15],\n    next: Player,\n    status: GameState,\n}","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::Gomoku::check_state":["fn check_state(&mut self){\n        for connectable in Self::get_connectable() {\n            let mut last = None;\n            let mut count = 0u8;\n\n            for cell in connectable.map(|(row, col)| self.board[col][row]) {\n                if cell != last {\n                    last = cell;\n                    count = 1;\n                } else {\n                    count += 1;\n                    if count == 5 && cell.is_some() {\n                        self.status = GameState::Win(cell.unwrap());\n                        return;\n                    }\n                }\n            }\n        }\n\n        if self.board.iter().flatten().all(|cell| cell.is_some()) {\n            self.status = GameState::Tie;\n        }\n    }","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::Gomoku::get":["/// Get a cell reference from the game board\n/// Panic when target position out of bounds\npub fn get(&self, row: usize, col: usize) -> &Option<Player>{\n        &self.board[row][col]\n    }","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::Gomoku::get_connectable":["fn get_connectable() -> impl Iterator<Item = Box<dyn Iterator<Item = (usize, usize)>>>{\n        let horizontal = (0usize..15).map(move |row| {\n            Box::new((0usize..15).map(move |col| (row, col)))\n                as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let vertical = (0usize..15).map(move |col| {\n            Box::new((0usize..15).map(move |row| (row, col)))\n                as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let horizontal_upper_left_to_lower_right = (0usize..15).map(move |col| {\n            Box::new(\n                iter::successors(Some((0usize, col)), |(row, col)| Some((row + 1, col + 1)))\n                    .take(15 - col),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let vertical_upper_left_to_lower_right = (0usize..15).map(move |row| {\n            Box::new(\n                iter::successors(Some((row, 0usize)), |(row, col)| Some((row + 1, col + 1)))\n                    .take(15 - row),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let horizontal_upper_right_to_lower_left = (0usize..15).map(move |col| {\n            Box::new(\n                iter::successors(Some((0usize, col)), |(row, col)| {\n                    col.checked_sub(1).map(|new_col| (row + 1, new_col))\n                })\n                .take(1 + col),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        let vertical_upper_right_to_lower_left = (0usize..15).map(move |row| {\n            Box::new(\n                iter::successors(Some((row, 14usize)), |(row, col)| Some((row + 1, col - 1)))\n                    .take(15 - row),\n            ) as Box<dyn Iterator<Item = (usize, usize)>>\n        });\n\n        horizontal\n            .chain(vertical)\n            .chain(horizontal_upper_left_to_lower_right)\n            .chain(vertical_upper_left_to_lower_right)\n            .chain(horizontal_upper_right_to_lower_left)\n            .chain(vertical_upper_right_to_lower_left)\n    }","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::Gomoku::get_next_player":["/// Get the next player\npub fn get_next_player(&self) -> Player{\n        self.next\n    }","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::Gomoku::is_ended":["/// Check if the game was end\npub fn is_ended(&self) -> bool{\n        self.status != GameState::InProgress\n    }","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::Gomoku::new":["/// Create a new Gomoku game.\npub fn new() -> Result<Self, Infallible>{\n        Ok(Self {\n            board: [[None; 15]; 15],\n            next: Player::Player0,\n            status: GameState::InProgress,\n        })\n    }","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::Gomoku::place":["/// Place a piece on the board\n/// Panic when target position out of bounds\npub fn place(&mut self, player: Player, row: usize, col: usize) -> Result<(), GomokuError>{\n        if self.is_ended() {\n            return Err(GomokuError::GameEnded);\n        }\n\n        if player != self.next {\n            return Err(GomokuError::WrongPlayer);\n        }\n\n        if self.board[row][col].is_some() {\n            return Err(GomokuError::OccupiedPosition);\n        }\n\n        self.board[row][col] = Some(player);\n        self.next = self.next.other();\n\n        self.check_state();\n\n        Ok(())\n    }","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::Gomoku::status":["/// Get the game status\npub fn status(&self) -> &GameState{\n        &self.status\n    }","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::Gomoku::winner":["/// Get the winner of the game. Return `None` when the game is tied or not end yet\npub fn winner(&self) -> Option<Player>{\n        if let GameState::Win(player) = self.status {\n            Some(player)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::GomokuError":["/// Errors that can occur when placing a piece on the board\npub enum GomokuError {\n    #[snafu(display(\"Wrong player\"))]\n    WrongPlayer,\n    #[snafu(display(\"Occupied position\"))]\n    OccupiedPosition,\n    #[snafu(display(\"The game was already end\"))]\n    GameEnded,\n}","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::OccupiedPositionSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::Player":["/// Players\npub enum Player {\n    Player0,\n    Player1,\n}","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::Player::other":["/// Get the opposite player\npub fn other(self) -> Self{\n        match self {\n            Player::Player0 => Player::Player1,\n            Player::Player1 => Player::Player0,\n        }\n    }","Real(LocalPath(\"src/gomoku.rs\"))"],"gomoku::WrongPlayerSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/gomoku.rs\"))"],"minesweeper::AdjacentCells":["struct AdjacentCells {\n    around: [(isize, isize); 8],\n    board_height: isize,\n    board_width: isize,\n    offset: usize,\n}","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::AdjacentCells::new":["fn new(row: usize, col: usize, board_height: usize, board_width: usize) -> Self{\n        let (row, col, board_height, board_width) = (\n            row as isize,\n            col as isize,\n            board_height as isize,\n            board_width as isize,\n        );\n\n        AdjacentCells {\n            around: [\n                (row - 1, col - 1),\n                (row - 1, col),\n                (row - 1, col + 1),\n                (row, col - 1),\n                (row, col + 1),\n                (row + 1, col - 1),\n                (row + 1, col),\n                (row + 1, col + 1),\n            ],\n            board_height,\n            board_width,\n            offset: 0,\n        }\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::AlreadyFlaggedSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::AlreadyRevealedSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Cell":["/// The cell in the board.\npub struct Cell {\n    pub is_mine: bool,\n    pub mine_adjacent: usize,\n    pub is_revealed: bool,\n    pub is_flagged: bool,\n}","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Cell::new":["fn new(is_mine: bool) -> Self{\n        Self {\n            is_mine,\n            mine_adjacent: 0,\n            is_revealed: false,\n            is_flagged: false,\n        }\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::GameEndedSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::GameState":["/// Game status\npub enum GameState {\n    Win,\n    Exploded(Vec<(usize, usize)>),\n    InProgress,\n}","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper":["/// Minesweeper\n///\n/// To avoid unessecary memory allocation, the game board is stored in a single `Vec` rather than a nested one.\n///\n/// Passing an invalid position to a method will cause panic. Check the target position validity first when dealing with user input\npub struct Minesweeper {\n    board: Vec<Cell>,\n    height: usize,\n    width: usize,\n    status: GameState,\n}","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::check_state":["fn check_state(&mut self){\n        self.status = if self\n            .board\n            .iter()\n            .filter(|cell| !cell.is_mine)\n            .all(|cell| cell.is_revealed)\n        {\n            GameState::Win\n        } else {\n            GameState::InProgress\n        };\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::click":["/// Click a cell on the game board\n///\n/// Clicking an already revealed cell will unreveal its adjacent cells if the flagged cell count around it equals to its adjacent mine count\n/// When `auto_flag` is `true`, clicking an already revealed cell will flag its adjacent unflagged-unrevealed cells if the unflagged-revealed cell count around it equals to its adjacent mine count\n///\n/// The return value indicates if the game board is changed from the click\n///\n/// Panic when target position out of bounds\npub fn click(\n        &mut self,\n        row: usize,\n        col: usize,\n        auto_flag: bool,\n    ) -> Result<bool, MinesweeperError>{\n        if row >= self.height || col >= self.width {\n            panic!(\"Invalid position: ({}, {})\", row, col);\n        }\n\n        if self.is_ended() {\n            return Err(MinesweeperError::GameEnded);\n        }\n\n        if !self.board[row * self.width + col].is_revealed {\n            self.click_unrevealed(row, col)?;\n            Ok(true)\n        } else {\n            Ok(self.click_revealed(row, col, auto_flag)?)\n        }\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::click_revealed":["fn click_revealed(\n        &mut self,\n        row: usize,\n        col: usize,\n        auto_flag: bool,\n    ) -> Result<bool, MinesweeperError>{\n        let mut is_changed = false;\n\n        if self.board[row * self.width + col].mine_adjacent > 0 {\n            let mut adjacent_all = 0;\n            let mut adjacent_revealed = 0;\n            let mut adjacent_flagged = 0;\n\n            self.get_adjacent_cells(row, col)\n                .map(|idx| self.board[idx])\n                .for_each(|cell| {\n                    adjacent_all += 1;\n\n                    if cell.is_revealed {\n                        adjacent_revealed += 1;\n                    } else if cell.is_flagged {\n                        adjacent_flagged += 1;\n                    }\n                });\n\n            let adjacent_unrevealed = adjacent_all - adjacent_revealed - adjacent_flagged;\n\n            if adjacent_unrevealed > 0 {\n                if adjacent_flagged == self.board[row * self.width + col].mine_adjacent {\n                    let mut exploded = None;\n\n                    self.get_adjacent_cells(row, col).for_each(|idx| {\n                        if !self.board[idx].is_flagged && !self.board[idx].is_revealed {\n                            if self.board[idx].is_mine {\n                                self.board[idx].is_revealed = true;\n\n                                match exploded {\n                                    None => exploded = Some(vec![(row, col)]),\n                                    Some(ref mut exploded) => {\n                                        exploded.push((row, col));\n                                    }\n                                }\n                            } else {\n                                self.reveal_from(idx);\n                                is_changed = true;\n                            }\n                        }\n                    });\n\n                    if let Some(exploded) = exploded {\n                        self.status = GameState::Exploded(exploded);\n                        return Ok(true);\n                    }\n                }\n\n                if auto_flag\n                    && adjacent_unrevealed + adjacent_flagged\n                        == self.board[row * self.width + col].mine_adjacent\n                {\n                    self.get_adjacent_cells(row, col).for_each(|idx| {\n                        if !self.board[idx].is_flagged && !self.board[idx].is_revealed {\n                            self.board[idx].is_flagged = true;\n                            is_changed = true;\n                        }\n                    });\n                }\n            }\n\n            self.check_state();\n        }\n\n        Ok(is_changed)\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::click_unrevealed":["fn click_unrevealed(&mut self, row: usize, col: usize) -> Result<(), MinesweeperError>{\n        if self.board[row * self.width + col].is_flagged {\n            return Err(MinesweeperError::AlreadyFlagged);\n        }\n\n        if self.board[row * self.width + col].is_mine {\n            self.status = GameState::Exploded(vec![(row, col)]);\n            return Ok(());\n        }\n\n        self.reveal_from(row * self.width + col);\n        self.check_state();\n\n        Ok(())\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::get":["/// Get a cell reference from the game board\n/// Panic when target position out of bounds\npub fn get(&self, row: usize, col: usize) -> &Cell{\n        if row >= self.height || col >= self.width {\n            panic!(\"Invalid position: ({}, {})\", row, col);\n        }\n\n        &self.board[row * self.width + col]\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::get_adjacent_cells":["fn get_adjacent_cells(&self, row: usize, col: usize) -> AdjacentCells{\n        AdjacentCells::new(row, col, self.height, self.width)\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::is_ended":["/// Check if the game was end\npub fn is_ended(&self) -> bool{\n        self.status != GameState::InProgress\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::new":["/// Create a new Minesweeper game\n///\n/// A mutable reference of a random number generator is required for randomizing mine positions\n///\n/// Return `Err(MinesweeperError::TooManyMines)` if `height * width < mines`\n///\n/// # Examples\n/// ```rust\n/// # fn minesweeper() {\n/// use gamie::minesweeper::Minesweeper;\n/// use rand::rngs::ThreadRng;\n///\n/// let mut game = Minesweeper::new(8, 8, 9, &mut ThreadRng::default()).unwrap();\n/// # }\n/// ```\npub fn new<R: Rng + ?Sized>(\n        height: usize,\n        width: usize,\n        mines: usize,\n        rng: &mut R,\n    ) -> Result<Self, MinesweeperError>{\n        if height * width < mines {\n            return Err(MinesweeperError::TooManyMines);\n        }\n\n        let board = iter::repeat(Cell::new(true))\n            .take(mines)\n            .chain(iter::repeat(Cell::new(false)).take(height * width - mines))\n            .collect();\n\n        let mut minesweeper = Self {\n            board,\n            height,\n            width,\n            status: GameState::InProgress,\n        };\n        minesweeper.randomize(rng).unwrap();\n\n        Ok(minesweeper)\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::randomize":["/// Randomize the board\n///\n/// A mutable reference of a random number generator is required for randomizing mine positions\npub fn randomize<R: Rng + ?Sized>(&mut self, rng: &mut R) -> Result<(), MinesweeperError>{\n        if self.is_ended() {\n            return Err(MinesweeperError::GameEnded);\n        }\n\n        let range = Uniform::from(0..self.height * self.width);\n\n        for idx in 0..self.height * self.width {\n            self.board.swap(idx, range.sample(rng));\n        }\n\n        self.update_around_mine_count();\n\n        Ok(())\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::reveal_from":["fn reveal_from(&mut self, idx: usize){\n        if self.board[idx].mine_adjacent != 0 {\n            self.board[idx].is_revealed = true;\n        } else {\n            let mut cell_idxs_to_reveal = VecDeque::new();\n            cell_idxs_to_reveal.push_back(idx);\n\n            while let Some(cell_idx) = cell_idxs_to_reveal.pop_front() {\n                self.board[cell_idx].is_revealed = true;\n\n                for neighbor_idx in\n                    self.get_adjacent_cells(cell_idx / self.width, cell_idx % self.width)\n                {\n                    if !self.board[neighbor_idx].is_flagged && !self.board[neighbor_idx].is_revealed\n                    {\n                        if self.board[neighbor_idx].mine_adjacent == 0 {\n                            cell_idxs_to_reveal.push_back(neighbor_idx);\n                        } else {\n                            self.board[neighbor_idx].is_revealed = true;\n                        }\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::status":["/// Get the game status\npub fn status(&self) -> &GameState{\n        &self.status\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::toggle_flag":["/// Flag or unflag a cell on the board\n/// Return Err(MinesweeperError::AlreadyRevealed) if the target cell is already revealed\n///\n/// Panic when target position out of bounds\npub fn toggle_flag(&mut self, row: usize, col: usize) -> Result<(), MinesweeperError>{\n        if row >= self.height || col >= self.width {\n            panic!(\"Invalid position: ({}, {})\", row, col);\n        }\n\n        if self.is_ended() {\n            return Err(MinesweeperError::GameEnded);\n        }\n\n        if self.board[row * self.width + col].is_revealed {\n            return Err(MinesweeperError::AlreadyRevealed);\n        }\n\n        self.board[row * self.width + col].is_flagged =\n            !self.board[row * self.width + col].is_flagged;\n\n        self.check_state();\n\n        Ok(())\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::Minesweeper::update_around_mine_count":["fn update_around_mine_count(&mut self){\n        for idx in 0..self.height * self.width {\n            let count = self\n                .get_adjacent_cells(idx / self.width, idx % self.width)\n                .filter(|idx| self.board[*idx].is_mine)\n                .count();\n\n            self.board[idx].mine_adjacent = count;\n        }\n    }","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::MinesweeperError":["/// Errors that can occur.\npub enum MinesweeperError {\n    #[snafu(display(\"Too many mines\"))]\n    TooManyMines,\n    #[snafu(display(\"Clicked an already flagged cell\"))]\n    AlreadyFlagged,\n    #[snafu(display(\"Clicked an already revealed cell\"))]\n    AlreadyRevealed,\n    #[snafu(display(\"The game was already end\"))]\n    GameEnded,\n}","Real(LocalPath(\"src/minesweeper.rs\"))"],"minesweeper::TooManyMinesSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/minesweeper.rs\"))"],"reversi::Direction":["enum Direction {\n    Upper,\n    UpperRight,\n    Right,\n    LowerRight,\n    Lower,\n    LowerLeft,\n    Left,\n    UpperLeft,\n}","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Direction::as_offset":["fn as_offset(&self) -> (i8, i8){\n        match self {\n            Direction::Upper => (-1, 0),\n            Direction::UpperRight => (-1, 1),\n            Direction::Right => (0, 1),\n            Direction::LowerRight => (1, 1),\n            Direction::Lower => (1, 0),\n            Direction::LowerLeft => (1, -1),\n            Direction::Left => (0, -1),\n            Direction::UpperLeft => (-1, -1),\n        }\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Direction::iter":["fn iter() -> impl Iterator<Item = Self>{\n        [\n            Direction::Upper,\n            Direction::UpperRight,\n            Direction::Right,\n            Direction::LowerRight,\n            Direction::Lower,\n            Direction::LowerLeft,\n            Direction::Left,\n            Direction::UpperLeft,\n        ]\n        .into_iter()\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::GameEndedSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::GameState":["/// Game status\npub enum GameState {\n    Win(Player),\n    Tie,\n    InProgress,\n}","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::InvalidPositionSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::OccupiedPositionSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Player":["/// Players\npub enum Player {\n    Player0,\n    Player1,\n}","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Player::other":["/// Get the opposite player\npub fn other(self) -> Self{\n        match self {\n            Player::Player0 => Player::Player1,\n            Player::Player1 => Player::Player0,\n        }\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi":["/// Reversi\n///\n/// Passing an invalid position to a method will cause panic. Check the target position validity first when dealing with user input\npub struct Reversi {\n    board: [[Option<Player>; 8]; 8],\n    next: Player,\n    status: GameState,\n}","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::can_player_move":["fn can_player_move(&self, player: Player) -> bool{\n        for row in 0..8 {\n            for col in 0..8 {\n                if self.board[row][col].is_none()\n                    && self.check_position_validity(row, col, player).is_ok()\n                {\n                    return true;\n                }\n            }\n        }\n\n        false\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::check_occupied_line_in_direction":["fn check_occupied_line_in_direction(\n        &self,\n        row: usize,\n        col: usize,\n        dir: Direction,\n        player: Player,\n    ) -> Option<(usize, usize)>{\n        let mut pos = self.iter_positions_in_direction_from(row, col, dir);\n\n        pos.next();\n\n        let first = if let Some(pos) = pos.next() {\n            pos\n        } else {\n            return None;\n        };\n\n        if self.board[first.0][first.1] != Some(player.other()) {\n            return None;\n        }\n\n        for (row, col) in pos {\n            match self.board[row][col] {\n                Some(piece) if piece == player.other() => continue,\n                Some(_) => return Some((row, col)),\n                None => return None,\n            }\n        }\n\n        None\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::check_position_validity":["/// Check if a position is valid for placing piece\n/// Panic when target position out of bounds\npub fn check_position_validity(\n        &self,\n        row: usize,\n        col: usize,\n        player: Player,\n    ) -> Result<(), ReversiError>{\n        self.simple_check_position_validity(row, col, player)?;\n\n        if Direction::iter()\n            .map(|dir| self.check_occupied_line_in_direction(row, col, dir, player))\n            .any(|o| o.is_some())\n        {\n            Ok(())\n        } else {\n            Err(ReversiError::InvalidPosition)\n        }\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::check_state":["fn check_state(&mut self){\n        let mut black_count = 0;\n        let mut white_count = 0;\n\n        for cell in self.board.iter().flatten().flatten() {\n            match cell {\n                Player::Player0 => black_count += 1,\n                Player::Player1 => white_count += 1,\n            }\n        }\n\n        self.status = match black_count.cmp(&white_count) {\n            Ordering::Less => GameState::Win(Player::Player1),\n            Ordering::Equal => GameState::Tie,\n            Ordering::Greater => GameState::Win(Player::Player0),\n        };\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::flip":["fn flip(\n        &mut self,\n        from_row: usize,\n        from_col: usize,\n        to_row: usize,\n        to_col: usize,\n        dir: Direction,\n        player: Player,\n    ){\n        self.iter_positions_in_direction_from(from_row, from_col, dir)\n            .take_while(|(row, col)| *row != to_row || *col != to_col)\n            .for_each(|(row, col)| {\n                self.board[row][col] = Some(player);\n            });\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::get":["/// Get a cell reference from the game board\n/// Panic when target position out of bounds\npub fn get(&self, row: usize, col: usize) -> &Option<Player>{\n        &self.board[row][col]\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::get_next_player":["/// Get the next player\npub fn get_next_player(&self) -> Player{\n        self.next\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::is_ended":["/// Check if the game was end\npub fn is_ended(&self) -> bool{\n        self.status != GameState::InProgress\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::iter_positions_in_direction_from":["fn iter_positions_in_direction_from(\n        &self,\n        row: usize,\n        col: usize,\n        dir: Direction,\n    ) -> impl Iterator<Item = (usize, usize)>{\n        iter::successors(Some((row, col)), move |(row, col)| {\n            let (offset_row, offset_col) = dir.as_offset();\n            Some((\n                (*row as i8 + offset_row) as usize,\n                (*col as i8 + offset_col) as usize,\n            ))\n        })\n        .take_while(|(row, col)| *row < 8 && *col < 8)\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::new":["/// Create a new Reversi game\npub fn new() -> Result<Self, Infallible>{\n        let mut board = [[None; 8]; 8];\n        board[3][3] = Some(Player::Player0);\n        board[4][4] = Some(Player::Player0);\n        board[3][4] = Some(Player::Player1);\n        board[4][3] = Some(Player::Player1);\n\n        Ok(Self {\n            board,\n            next: Player::Player0,\n            status: GameState::InProgress,\n        })\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::place":["/// Place a piece on the board\n/// Panic when target position out of bounds\npub fn place(&mut self, player: Player, row: usize, col: usize) -> Result<(), ReversiError>{\n        self.simple_check_position_validity(row, col, player)?;\n\n        let mut flipped = false;\n\n        for dir in Direction::iter() {\n            if let Some((to_row, to_col)) =\n                self.check_occupied_line_in_direction(row, col, dir, player)\n            {\n                self.flip(row, col, to_row, to_col, dir, player);\n                flipped = true;\n            }\n        }\n\n        if flipped {\n            self.next = player.other();\n\n            if !self.can_player_move(player.other()) {\n                self.next = player;\n\n                if !self.can_player_move(player) {\n                    self.check_state();\n                }\n            }\n\n            Ok(())\n        } else {\n            Err(ReversiError::InvalidPosition)\n        }\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::simple_check_position_validity":["fn simple_check_position_validity(\n        &self,\n        row: usize,\n        col: usize,\n        player: Player,\n    ) -> Result<(), ReversiError>{\n        if self.is_ended() {\n            return Err(ReversiError::GameEnded);\n        }\n\n        if player != self.next {\n            return Err(ReversiError::WrongPlayer);\n        }\n\n        if self.board[row][col].is_some() {\n            return Err(ReversiError::OccupiedPosition);\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::status":["/// Get the game status\npub fn status(&self) -> &GameState{\n        &self.status\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::Reversi::winner":["/// Get the winner of the game. Return `None` when the game is tied or not end yet\npub fn winner(&self) -> Option<Player>{\n        if let GameState::Win(player) = self.status {\n            Some(player)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::ReversiError":["/// Errors that can occur when placing a piece on the board\npub enum ReversiError {\n    #[snafu(display(\"Wrong player\"))]\n    WrongPlayer,\n    #[snafu(display(\"Position already occupied\"))]\n    OccupiedPosition,\n    #[snafu(display(\"Invalid position\"))]\n    InvalidPosition,\n    #[snafu(display(\"The game was already end\"))]\n    GameEnded,\n}","Real(LocalPath(\"src/reversi.rs\"))"],"reversi::WrongPlayerSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/reversi.rs\"))"],"tictactoe::GameEndedSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::GameState":["/// Game status\npub enum GameState {\n    Win(Player),\n    Tie,\n    InProgress,\n}","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::OccupiedPositionSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::Player":["/// Players\npub enum Player {\n    Player0,\n    Player1,\n}","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::Player::other":["/// Get the opposite player\npub fn other(self) -> Self{\n        match self {\n            Player::Player0 => Player::Player1,\n            Player::Player1 => Player::Player0,\n        }\n    }","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::TicTacToe":["/// Tic-Tac-Toe\n///\n/// Passing an invalid position to a method will cause panic. Check the target position validity first when dealing with user input\npub struct TicTacToe {\n    board: [[Option<Player>; 3]; 3],\n    next: Player,\n    status: GameState,\n}","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::TicTacToe::check_state":["fn check_state(&mut self){\n        for row in 0..3 {\n            if self.board[row][0].is_some()\n                && self.board[row][0] == self.board[row][1]\n                && self.board[row][1] == self.board[row][2]\n            {\n                self.status = GameState::Win(self.board[row][0].unwrap());\n                return;\n            }\n        }\n\n        for col in 0..3 {\n            if self.board[0][col].is_some()\n                && self.board[0][col] == self.board[1][col]\n                && self.board[1][col] == self.board[2][col]\n            {\n                self.status = GameState::Win(self.board[0][col].unwrap());\n                return;\n            }\n        }\n\n        if self.board[0][0].is_some()\n            && self.board[0][0] == self.board[1][1]\n            && self.board[1][1] == self.board[2][2]\n        {\n            self.status = GameState::Win(self.board[0][0].unwrap());\n            return;\n        }\n\n        if self.board[0][0].is_some()\n            && self.board[0][2] == self.board[1][1]\n            && self.board[1][1] == self.board[2][0]\n        {\n            self.status = GameState::Win(self.board[0][2].unwrap());\n            return;\n        }\n\n        self.status = if self.board.iter().flatten().all(|p| p.is_some()) {\n            GameState::Tie\n        } else {\n            GameState::InProgress\n        };\n    }","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::TicTacToe::get":["/// Get a cell reference from the game board\n/// Panic when target position out of bounds\npub fn get(&self, row: usize, col: usize) -> &Option<Player>{\n        &self.board[row][col]\n    }","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::TicTacToe::get_next_player":["/// Get the next player\npub fn get_next_player(&self) -> Player{\n        self.next\n    }","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::TicTacToe::is_ended":["/// Check if the game was end\npub fn is_ended(&self) -> bool{\n        self.status != GameState::InProgress\n    }","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::TicTacToe::new":["/// Create a new Tic-Tac-Toe game\npub fn new() -> Result<Self, Infallible>{\n        Ok(Self {\n            board: [[None; 3]; 3],\n            next: Player::Player0,\n            status: GameState::InProgress,\n        })\n    }","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::TicTacToe::place":["/// Place a piece on the board\n/// Panic when target position out of bounds\npub fn place(&mut self, player: Player, row: usize, col: usize) -> Result<(), TicTacToeError>{\n        if self.is_ended() {\n            return Err(TicTacToeError::GameEnded);\n        }\n\n        if player != self.next {\n            return Err(TicTacToeError::WrongPlayer);\n        }\n\n        if self.board[row][col].is_some() {\n            return Err(TicTacToeError::OccupiedPosition);\n        }\n\n        self.board[row][col] = Some(player);\n        self.next = self.next.other();\n\n        self.check_state();\n\n        Ok(())\n    }","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::TicTacToe::status":["/// Get the game status\npub fn status(&self) -> &GameState{\n        &self.status\n    }","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::TicTacToe::winner":["/// Get the winner of the game. Return `None` when the game is tied or not end yet\npub fn winner(&self) -> Option<Player>{\n        if let GameState::Win(player) = self.status {\n            Some(player)\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::TicTacToeError":["/// Errors that can occur when placing a piece on the board\npub enum TicTacToeError {\n    #[snafu(display(\"Wrong player\"))]\n    WrongPlayer,\n    #[snafu(display(\"Occupied position\"))]\n    OccupiedPosition,\n    #[snafu(display(\"The game was already end\"))]\n    GameEnded,\n}","Real(LocalPath(\"src/tictactoe.rs\"))"],"tictactoe::WrongPlayerSnafu":["Snafu\nSnafu","Real(LocalPath(\"src/tictactoe.rs\"))"]},"struct_constructor":{"&(dyn snafu::Error + 'static)":["source"],"&<connect_four::Column as std::ops::Index<usize>>::Output":["index"],"&connect_four::GameState":["status"],"&dyn snafu::Error":["cause"],"&gomoku::GameState":["status"],"&minesweeper::Cell":["get"],"&minesweeper::GameState":["status"],"&mut <connect_four::Column as std::ops::Index<usize>>::Output":["index_mut"],"&reversi::GameState":["status"],"&snafu::Backtrace":["backtrace"],"&str":["description"],"&tictactoe::GameState":["status"],"(i8, i8)":["as_offset"],"(usize, usize)":["check_occupied_line_in_direction"],"<minesweeper::AdjacentCells as std::iter::Iterator>::Item":["next"],"bool":["can_player_move","eq","is_ended","is_full"],"connect_four::Column":["clone","default"],"connect_four::ColumnFilledSnafu":["clone"],"connect_four::ConnectFour":["clone","new"],"connect_four::ConnectFourError":["build","into_error"],"connect_four::GameEndedSnafu":["clone"],"connect_four::GameState":["clone"],"connect_four::Player":["clone","get_next_player","winner"],"connect_four::WrongPlayerSnafu":["clone"],"gomoku::GameEndedSnafu":["clone"],"gomoku::GameState":["clone"],"gomoku::Gomoku":["clone","new"],"gomoku::GomokuError":["build","into_error"],"gomoku::OccupiedPositionSnafu":["clone"],"gomoku::Player":["clone","get_next_player","winner"],"gomoku::WrongPlayerSnafu":["clone"],"impl std::iter::Iterator<Item = (usize, usize)>":["iter_positions_in_direction_from"],"impl std::iter::Iterator<Item = reversi::Direction>":["iter"],"impl std::iter::Iterator<Item = std::boxed::Box<(dyn std::iter::Iterator<Item = (usize, usize)> + 'static)>>":["get_connectable"],"minesweeper::AdjacentCells":["clone","get_adjacent_cells","new"],"minesweeper::AlreadyFlaggedSnafu":["clone"],"minesweeper::AlreadyRevealedSnafu":["clone"],"minesweeper::Cell":["clone","new"],"minesweeper::GameEndedSnafu":["clone"],"minesweeper::GameState":["clone"],"minesweeper::Minesweeper":["clone","new"],"minesweeper::MinesweeperError":["build","into_error"],"minesweeper::TooManyMinesSnafu":["clone"],"reversi::Direction":["clone"],"reversi::GameEndedSnafu":["clone"],"reversi::GameState":["clone"],"reversi::InvalidPositionSnafu":["clone"],"reversi::OccupiedPositionSnafu":["clone"],"reversi::Player":["clone","get_next_player","winner"],"reversi::Reversi":["clone","new"],"reversi::ReversiError":["build","into_error"],"reversi::WrongPlayerSnafu":["clone"],"tictactoe::GameEndedSnafu":["clone"],"tictactoe::GameState":["clone"],"tictactoe::OccupiedPositionSnafu":["clone"],"tictactoe::Player":["clone","get_next_player","winner"],"tictactoe::TicTacToe":["clone","new"],"tictactoe::TicTacToeError":["build","into_error"],"tictactoe::WrongPlayerSnafu":["clone"]},"struct_to_trait":{"connect_four::Column":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Index","std::ops::IndexMut"],"connect_four::ColumnFilledSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"connect_four::ConnectFour":["std::clone::Clone","std::fmt::Debug"],"connect_four::ConnectFourError":["snafu::Error","snafu::ErrorCompat","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"connect_four::GameEndedSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"connect_four::GameState":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"connect_four::Player":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"connect_four::WrongPlayerSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"gomoku::GameEndedSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"gomoku::GameState":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"gomoku::Gomoku":["std::clone::Clone","std::fmt::Debug"],"gomoku::GomokuError":["snafu::Error","snafu::ErrorCompat","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"gomoku::OccupiedPositionSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"gomoku::Player":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"gomoku::WrongPlayerSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"minesweeper::AdjacentCells":["std::clone::Clone","std::iter::Iterator"],"minesweeper::AlreadyFlaggedSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"minesweeper::AlreadyRevealedSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"minesweeper::Cell":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"minesweeper::GameEndedSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"minesweeper::GameState":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"minesweeper::Minesweeper":["std::clone::Clone","std::fmt::Debug"],"minesweeper::MinesweeperError":["snafu::Error","snafu::ErrorCompat","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"minesweeper::TooManyMinesSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"reversi::Direction":["std::clone::Clone","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"reversi::GameEndedSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"reversi::GameState":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"reversi::InvalidPositionSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"reversi::OccupiedPositionSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"reversi::Player":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"reversi::Reversi":["std::clone::Clone","std::fmt::Debug"],"reversi::ReversiError":["snafu::Error","snafu::ErrorCompat","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"reversi::WrongPlayerSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"tictactoe::GameEndedSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"tictactoe::GameState":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"tictactoe::OccupiedPositionSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"tictactoe::Player":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"tictactoe::TicTacToe":["std::clone::Clone","std::fmt::Debug"],"tictactoe::TicTacToeError":["snafu::Error","snafu::ErrorCompat","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"tictactoe::WrongPlayerSnafu":["snafu::IntoError","std::clone::Clone","std::fmt::Debug","std::marker::Copy"]},"targets":{"<connect_four::Column as std::default::Default>::default":["default","Real(LocalPath(\"src/connect_four.rs\"))","std::default::Default"],"<connect_four::Column as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/connect_four.rs\"))","std::ops::Index"],"<connect_four::Column as std::ops::IndexMut<usize>>::index_mut":["index_mut","Real(LocalPath(\"src/connect_four.rs\"))","std::ops::IndexMut"],"<minesweeper::AdjacentCells as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/minesweeper.rs\"))","std::iter::Iterator"],"connect_four::Column::is_full":["is_full","Real(LocalPath(\"src/connect_four.rs\"))",""],"connect_four::Column::push":["push","Real(LocalPath(\"src/connect_four.rs\"))",""],"connect_four::ConnectFour::check_state":["check_state","Real(LocalPath(\"src/connect_four.rs\"))",""],"connect_four::ConnectFour::get":["get","Real(LocalPath(\"src/connect_four.rs\"))",""],"connect_four::ConnectFour::get_connectable":["get_connectable","Real(LocalPath(\"src/connect_four.rs\"))",""],"connect_four::ConnectFour::get_next_player":["get_next_player","Real(LocalPath(\"src/connect_four.rs\"))",""],"connect_four::ConnectFour::is_ended":["is_ended","Real(LocalPath(\"src/connect_four.rs\"))",""],"connect_four::ConnectFour::new":["new","Real(LocalPath(\"src/connect_four.rs\"))",""],"connect_four::ConnectFour::put":["put","Real(LocalPath(\"src/connect_four.rs\"))",""],"connect_four::ConnectFour::status":["status","Real(LocalPath(\"src/connect_four.rs\"))",""],"connect_four::ConnectFour::winner":["winner","Real(LocalPath(\"src/connect_four.rs\"))",""],"connect_four::Player::other":["other","Real(LocalPath(\"src/connect_four.rs\"))",""],"gomoku::Gomoku::check_state":["check_state","Real(LocalPath(\"src/gomoku.rs\"))",""],"gomoku::Gomoku::get":["get","Real(LocalPath(\"src/gomoku.rs\"))",""],"gomoku::Gomoku::get_connectable":["get_connectable","Real(LocalPath(\"src/gomoku.rs\"))",""],"gomoku::Gomoku::get_next_player":["get_next_player","Real(LocalPath(\"src/gomoku.rs\"))",""],"gomoku::Gomoku::is_ended":["is_ended","Real(LocalPath(\"src/gomoku.rs\"))",""],"gomoku::Gomoku::new":["new","Real(LocalPath(\"src/gomoku.rs\"))",""],"gomoku::Gomoku::place":["place","Real(LocalPath(\"src/gomoku.rs\"))",""],"gomoku::Gomoku::status":["status","Real(LocalPath(\"src/gomoku.rs\"))",""],"gomoku::Gomoku::winner":["winner","Real(LocalPath(\"src/gomoku.rs\"))",""],"gomoku::Player::other":["other","Real(LocalPath(\"src/gomoku.rs\"))",""],"minesweeper::AdjacentCells::new":["new","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Cell::new":["new","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::check_state":["check_state","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::click":["click","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::click_revealed":["click_revealed","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::click_unrevealed":["click_unrevealed","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::get":["get","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::get_adjacent_cells":["get_adjacent_cells","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::is_ended":["is_ended","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::new":["new","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::randomize":["randomize","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::reveal_from":["reveal_from","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::status":["status","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::toggle_flag":["toggle_flag","Real(LocalPath(\"src/minesweeper.rs\"))",""],"minesweeper::Minesweeper::update_around_mine_count":["update_around_mine_count","Real(LocalPath(\"src/minesweeper.rs\"))",""],"reversi::Direction::as_offset":["as_offset","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Direction::iter":["iter","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Player::other":["other","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::can_player_move":["can_player_move","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::check_occupied_line_in_direction":["check_occupied_line_in_direction","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::check_position_validity":["check_position_validity","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::check_state":["check_state","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::flip":["flip","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::get":["get","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::get_next_player":["get_next_player","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::is_ended":["is_ended","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::iter_positions_in_direction_from":["iter_positions_in_direction_from","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::new":["new","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::place":["place","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::simple_check_position_validity":["simple_check_position_validity","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::status":["status","Real(LocalPath(\"src/reversi.rs\"))",""],"reversi::Reversi::winner":["winner","Real(LocalPath(\"src/reversi.rs\"))",""],"tictactoe::Player::other":["other","Real(LocalPath(\"src/tictactoe.rs\"))",""],"tictactoe::TicTacToe::check_state":["check_state","Real(LocalPath(\"src/tictactoe.rs\"))",""],"tictactoe::TicTacToe::get":["get","Real(LocalPath(\"src/tictactoe.rs\"))",""],"tictactoe::TicTacToe::get_next_player":["get_next_player","Real(LocalPath(\"src/tictactoe.rs\"))",""],"tictactoe::TicTacToe::is_ended":["is_ended","Real(LocalPath(\"src/tictactoe.rs\"))",""],"tictactoe::TicTacToe::new":["new","Real(LocalPath(\"src/tictactoe.rs\"))",""],"tictactoe::TicTacToe::place":["place","Real(LocalPath(\"src/tictactoe.rs\"))",""],"tictactoe::TicTacToe::status":["status","Real(LocalPath(\"src/tictactoe.rs\"))",""],"tictactoe::TicTacToe::winner":["winner","Real(LocalPath(\"src/tictactoe.rs\"))",""]},"trait_to_struct":{"snafu::Error":["connect_four::ConnectFourError","gomoku::GomokuError","minesweeper::MinesweeperError","reversi::ReversiError","tictactoe::TicTacToeError"],"snafu::ErrorCompat":["connect_four::ConnectFourError","gomoku::GomokuError","minesweeper::MinesweeperError","reversi::ReversiError","tictactoe::TicTacToeError"],"snafu::IntoError":["connect_four::ColumnFilledSnafu","connect_four::GameEndedSnafu","connect_four::WrongPlayerSnafu","gomoku::GameEndedSnafu","gomoku::OccupiedPositionSnafu","gomoku::WrongPlayerSnafu","minesweeper::AlreadyFlaggedSnafu","minesweeper::AlreadyRevealedSnafu","minesweeper::GameEndedSnafu","minesweeper::TooManyMinesSnafu","reversi::GameEndedSnafu","reversi::InvalidPositionSnafu","reversi::OccupiedPositionSnafu","reversi::WrongPlayerSnafu","tictactoe::GameEndedSnafu","tictactoe::OccupiedPositionSnafu","tictactoe::WrongPlayerSnafu"],"std::clone::Clone":["connect_four::Column","connect_four::ColumnFilledSnafu","connect_four::ConnectFour","connect_four::GameEndedSnafu","connect_four::GameState","connect_four::Player","connect_four::WrongPlayerSnafu","gomoku::GameEndedSnafu","gomoku::GameState","gomoku::Gomoku","gomoku::OccupiedPositionSnafu","gomoku::Player","gomoku::WrongPlayerSnafu","minesweeper::AdjacentCells","minesweeper::AlreadyFlaggedSnafu","minesweeper::AlreadyRevealedSnafu","minesweeper::Cell","minesweeper::GameEndedSnafu","minesweeper::GameState","minesweeper::Minesweeper","minesweeper::TooManyMinesSnafu","reversi::Direction","reversi::GameEndedSnafu","reversi::GameState","reversi::InvalidPositionSnafu","reversi::OccupiedPositionSnafu","reversi::Player","reversi::Reversi","reversi::WrongPlayerSnafu","tictactoe::GameEndedSnafu","tictactoe::GameState","tictactoe::OccupiedPositionSnafu","tictactoe::Player","tictactoe::TicTacToe","tictactoe::WrongPlayerSnafu"],"std::cmp::Eq":["connect_four::Column","connect_four::ConnectFourError","connect_four::GameState","connect_four::Player","gomoku::GameState","gomoku::GomokuError","gomoku::Player","minesweeper::Cell","minesweeper::GameState","minesweeper::MinesweeperError","reversi::GameState","reversi::Player","reversi::ReversiError","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToeError"],"std::cmp::PartialEq":["connect_four::Column","connect_four::ConnectFourError","connect_four::GameState","connect_four::Player","gomoku::GameState","gomoku::GomokuError","gomoku::Player","minesweeper::Cell","minesweeper::GameState","minesweeper::MinesweeperError","reversi::Direction","reversi::GameState","reversi::Player","reversi::ReversiError","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToeError"],"std::default::Default":["connect_four::Column"],"std::fmt::Debug":["connect_four::Column","connect_four::ColumnFilledSnafu","connect_four::ConnectFour","connect_four::ConnectFourError","connect_four::GameEndedSnafu","connect_four::GameState","connect_four::Player","connect_four::WrongPlayerSnafu","gomoku::GameEndedSnafu","gomoku::GameState","gomoku::Gomoku","gomoku::GomokuError","gomoku::OccupiedPositionSnafu","gomoku::Player","gomoku::WrongPlayerSnafu","minesweeper::AlreadyFlaggedSnafu","minesweeper::AlreadyRevealedSnafu","minesweeper::Cell","minesweeper::GameEndedSnafu","minesweeper::GameState","minesweeper::Minesweeper","minesweeper::MinesweeperError","minesweeper::TooManyMinesSnafu","reversi::Direction","reversi::GameEndedSnafu","reversi::GameState","reversi::InvalidPositionSnafu","reversi::OccupiedPositionSnafu","reversi::Player","reversi::Reversi","reversi::ReversiError","reversi::WrongPlayerSnafu","tictactoe::GameEndedSnafu","tictactoe::GameState","tictactoe::OccupiedPositionSnafu","tictactoe::Player","tictactoe::TicTacToe","tictactoe::TicTacToeError","tictactoe::WrongPlayerSnafu"],"std::fmt::Display":["connect_four::ConnectFourError","gomoku::GomokuError","minesweeper::MinesweeperError","reversi::ReversiError","tictactoe::TicTacToeError"],"std::iter::Iterator":["minesweeper::AdjacentCells"],"std::marker::Copy":["connect_four::ColumnFilledSnafu","connect_four::GameEndedSnafu","connect_four::Player","connect_four::WrongPlayerSnafu","gomoku::GameEndedSnafu","gomoku::OccupiedPositionSnafu","gomoku::Player","gomoku::WrongPlayerSnafu","minesweeper::AlreadyFlaggedSnafu","minesweeper::AlreadyRevealedSnafu","minesweeper::Cell","minesweeper::GameEndedSnafu","minesweeper::TooManyMinesSnafu","reversi::Direction","reversi::GameEndedSnafu","reversi::InvalidPositionSnafu","reversi::OccupiedPositionSnafu","reversi::Player","reversi::WrongPlayerSnafu","tictactoe::GameEndedSnafu","tictactoe::OccupiedPositionSnafu","tictactoe::Player","tictactoe::WrongPlayerSnafu"],"std::marker::StructuralEq":["connect_four::Column","connect_four::ConnectFourError","connect_four::GameState","connect_four::Player","gomoku::GameState","gomoku::GomokuError","gomoku::Player","minesweeper::Cell","minesweeper::GameState","minesweeper::MinesweeperError","reversi::GameState","reversi::Player","reversi::ReversiError","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToeError"],"std::marker::StructuralPartialEq":["connect_four::Column","connect_four::ConnectFourError","connect_four::GameState","connect_four::Player","gomoku::GameState","gomoku::GomokuError","gomoku::Player","minesweeper::Cell","minesweeper::GameState","minesweeper::MinesweeperError","reversi::Direction","reversi::GameState","reversi::Player","reversi::ReversiError","tictactoe::GameState","tictactoe::Player","tictactoe::TicTacToeError"],"std::ops::Index":["connect_four::Column"],"std::ops::IndexMut":["connect_four::Column"]},"type_to_def_path":{"connect_four::Column":"connect_four::Column","connect_four::ColumnFilledSnafu":"connect_four::ColumnFilledSnafu","connect_four::ConnectFour":"connect_four::ConnectFour","connect_four::ConnectFourError":"connect_four::ConnectFourError","connect_four::GameEndedSnafu":"connect_four::GameEndedSnafu","connect_four::GameState":"connect_four::GameState","connect_four::Player":"connect_four::Player","connect_four::WrongPlayerSnafu":"connect_four::WrongPlayerSnafu","gomoku::GameEndedSnafu":"gomoku::GameEndedSnafu","gomoku::GameState":"gomoku::GameState","gomoku::Gomoku":"gomoku::Gomoku","gomoku::GomokuError":"gomoku::GomokuError","gomoku::OccupiedPositionSnafu":"gomoku::OccupiedPositionSnafu","gomoku::Player":"gomoku::Player","gomoku::WrongPlayerSnafu":"gomoku::WrongPlayerSnafu","minesweeper::AdjacentCells":"minesweeper::AdjacentCells","minesweeper::AlreadyFlaggedSnafu":"minesweeper::AlreadyFlaggedSnafu","minesweeper::AlreadyRevealedSnafu":"minesweeper::AlreadyRevealedSnafu","minesweeper::Cell":"minesweeper::Cell","minesweeper::GameEndedSnafu":"minesweeper::GameEndedSnafu","minesweeper::GameState":"minesweeper::GameState","minesweeper::Minesweeper":"minesweeper::Minesweeper","minesweeper::MinesweeperError":"minesweeper::MinesweeperError","minesweeper::TooManyMinesSnafu":"minesweeper::TooManyMinesSnafu","reversi::Direction":"reversi::Direction","reversi::GameEndedSnafu":"reversi::GameEndedSnafu","reversi::GameState":"reversi::GameState","reversi::InvalidPositionSnafu":"reversi::InvalidPositionSnafu","reversi::OccupiedPositionSnafu":"reversi::OccupiedPositionSnafu","reversi::Player":"reversi::Player","reversi::Reversi":"reversi::Reversi","reversi::ReversiError":"reversi::ReversiError","reversi::WrongPlayerSnafu":"reversi::WrongPlayerSnafu","tictactoe::GameEndedSnafu":"tictactoe::GameEndedSnafu","tictactoe::GameState":"tictactoe::GameState","tictactoe::OccupiedPositionSnafu":"tictactoe::OccupiedPositionSnafu","tictactoe::Player":"tictactoe::Player","tictactoe::TicTacToe":"tictactoe::TicTacToe","tictactoe::TicTacToeError":"tictactoe::TicTacToeError","tictactoe::WrongPlayerSnafu":"tictactoe::WrongPlayerSnafu"}}