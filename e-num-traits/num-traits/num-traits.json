{"dependencies":{"<&'a core::num::Wrapping<i128> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<i128> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<i16> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<i16> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<i32> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<i32> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<i64> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<i64> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<i8> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<i8> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<isize> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<isize> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<u128> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<u128> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<u16> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<u16> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<u32> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<u32> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<u64> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<u64> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<u8> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<u8> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<usize> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a core::num::Wrapping<usize> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'a f32 as ops::inv::Inv>::inv":[],"<&'a f64 as ops::inv::Inv>::inv":[],"<&'a i128 as pow::Pow<u16>>::pow":[],"<&'a i128 as pow::Pow<u32>>::pow":[],"<&'a i128 as pow::Pow<u8>>::pow":[],"<&'a i128 as pow::Pow<usize>>::pow":[],"<&'a i16 as pow::Pow<u16>>::pow":[],"<&'a i16 as pow::Pow<u32>>::pow":[],"<&'a i16 as pow::Pow<u8>>::pow":[],"<&'a i16 as pow::Pow<usize>>::pow":[],"<&'a i32 as pow::Pow<u16>>::pow":[],"<&'a i32 as pow::Pow<u32>>::pow":[],"<&'a i32 as pow::Pow<u8>>::pow":[],"<&'a i32 as pow::Pow<usize>>::pow":[],"<&'a i64 as pow::Pow<u16>>::pow":[],"<&'a i64 as pow::Pow<u32>>::pow":[],"<&'a i64 as pow::Pow<u8>>::pow":[],"<&'a i64 as pow::Pow<usize>>::pow":[],"<&'a i8 as pow::Pow<u16>>::pow":[],"<&'a i8 as pow::Pow<u32>>::pow":[],"<&'a i8 as pow::Pow<u8>>::pow":[],"<&'a i8 as pow::Pow<usize>>::pow":[],"<&'a isize as pow::Pow<u16>>::pow":[],"<&'a isize as pow::Pow<u32>>::pow":[],"<&'a isize as pow::Pow<u8>>::pow":[],"<&'a isize as pow::Pow<usize>>::pow":[],"<&'a u128 as pow::Pow<u16>>::pow":[],"<&'a u128 as pow::Pow<u32>>::pow":[],"<&'a u128 as pow::Pow<u8>>::pow":[],"<&'a u128 as pow::Pow<usize>>::pow":[],"<&'a u16 as pow::Pow<u16>>::pow":[],"<&'a u16 as pow::Pow<u32>>::pow":[],"<&'a u16 as pow::Pow<u8>>::pow":[],"<&'a u16 as pow::Pow<usize>>::pow":[],"<&'a u32 as pow::Pow<u16>>::pow":[],"<&'a u32 as pow::Pow<u32>>::pow":[],"<&'a u32 as pow::Pow<u8>>::pow":[],"<&'a u32 as pow::Pow<usize>>::pow":[],"<&'a u64 as pow::Pow<u16>>::pow":[],"<&'a u64 as pow::Pow<u32>>::pow":[],"<&'a u64 as pow::Pow<u8>>::pow":[],"<&'a u64 as pow::Pow<usize>>::pow":[],"<&'a u8 as pow::Pow<u16>>::pow":[],"<&'a u8 as pow::Pow<u32>>::pow":[],"<&'a u8 as pow::Pow<u8>>::pow":[],"<&'a u8 as pow::Pow<usize>>::pow":[],"<&'a usize as pow::Pow<u16>>::pow":[],"<&'a usize as pow::Pow<u32>>::pow":[],"<&'a usize as pow::Pow<u8>>::pow":[],"<&'a usize as pow::Pow<usize>>::pow":[],"<&'b core::num::Wrapping<i128> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<i128> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<i16> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<i16> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<i32> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<i32> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<i64> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<i64> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<i8> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<i8> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<isize> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<isize> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<u128> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<u128> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<u16> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<u16> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<u32> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<u32> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<u64> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<u64> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<u8> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<u8> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<usize> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b core::num::Wrapping<usize> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<&'b i128 as pow::Pow<&'a u16>>::pow":[],"<&'b i128 as pow::Pow<&'a u32>>::pow":[],"<&'b i128 as pow::Pow<&'a u8>>::pow":[],"<&'b i128 as pow::Pow<&'a usize>>::pow":[],"<&'b i16 as pow::Pow<&'a u16>>::pow":[],"<&'b i16 as pow::Pow<&'a u32>>::pow":[],"<&'b i16 as pow::Pow<&'a u8>>::pow":[],"<&'b i16 as pow::Pow<&'a usize>>::pow":[],"<&'b i32 as pow::Pow<&'a u16>>::pow":[],"<&'b i32 as pow::Pow<&'a u32>>::pow":[],"<&'b i32 as pow::Pow<&'a u8>>::pow":[],"<&'b i32 as pow::Pow<&'a usize>>::pow":[],"<&'b i64 as pow::Pow<&'a u16>>::pow":[],"<&'b i64 as pow::Pow<&'a u32>>::pow":[],"<&'b i64 as pow::Pow<&'a u8>>::pow":[],"<&'b i64 as pow::Pow<&'a usize>>::pow":[],"<&'b i8 as pow::Pow<&'a u16>>::pow":[],"<&'b i8 as pow::Pow<&'a u32>>::pow":[],"<&'b i8 as pow::Pow<&'a u8>>::pow":[],"<&'b i8 as pow::Pow<&'a usize>>::pow":[],"<&'b isize as pow::Pow<&'a u16>>::pow":[],"<&'b isize as pow::Pow<&'a u32>>::pow":[],"<&'b isize as pow::Pow<&'a u8>>::pow":[],"<&'b isize as pow::Pow<&'a usize>>::pow":[],"<&'b u128 as pow::Pow<&'a u16>>::pow":[],"<&'b u128 as pow::Pow<&'a u32>>::pow":[],"<&'b u128 as pow::Pow<&'a u8>>::pow":[],"<&'b u128 as pow::Pow<&'a usize>>::pow":[],"<&'b u16 as pow::Pow<&'a u16>>::pow":[],"<&'b u16 as pow::Pow<&'a u32>>::pow":[],"<&'b u16 as pow::Pow<&'a u8>>::pow":[],"<&'b u16 as pow::Pow<&'a usize>>::pow":[],"<&'b u32 as pow::Pow<&'a u16>>::pow":[],"<&'b u32 as pow::Pow<&'a u32>>::pow":[],"<&'b u32 as pow::Pow<&'a u8>>::pow":[],"<&'b u32 as pow::Pow<&'a usize>>::pow":[],"<&'b u64 as pow::Pow<&'a u16>>::pow":[],"<&'b u64 as pow::Pow<&'a u32>>::pow":[],"<&'b u64 as pow::Pow<&'a u8>>::pow":[],"<&'b u64 as pow::Pow<&'a usize>>::pow":[],"<&'b u8 as pow::Pow<&'a u16>>::pow":[],"<&'b u8 as pow::Pow<&'a u32>>::pow":[],"<&'b u8 as pow::Pow<&'a u8>>::pow":[],"<&'b u8 as pow::Pow<&'a usize>>::pow":[],"<&'b usize as pow::Pow<&'a u16>>::pow":[],"<&'b usize as pow::Pow<&'a u32>>::pow":[],"<&'b usize as pow::Pow<&'a u8>>::pow":[],"<&'b usize as pow::Pow<&'a usize>>::pow":[],"<() as bounds::Bounded>::max_value":[],"<() as bounds::Bounded>::min_value":[],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(O, P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(O, P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(P, Q, R, S, T) as bounds::Bounded>::max_value":[],"<(P, Q, R, S, T) as bounds::Bounded>::min_value":[],"<(Q, R, S, T) as bounds::Bounded>::max_value":[],"<(Q, R, S, T) as bounds::Bounded>::min_value":[],"<(R, S, T) as bounds::Bounded>::max_value":[],"<(R, S, T) as bounds::Bounded>::min_value":[],"<(S, T) as bounds::Bounded>::max_value":[],"<(S, T) as bounds::Bounded>::min_value":[],"<(T,) as bounds::Bounded>::max_value":[],"<(T,) as bounds::Bounded>::min_value":[],"<FloatErrorKind as core::fmt::Debug>::fmt":["FloatErrorKind","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<ParseFloatError as core::fmt::Debug>::fmt":["FloatErrorKind","ParseFloatError","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<ParseFloatError as core::fmt::Display>::fmt":["FloatErrorKind","ParseFloatError","core::fmt::Formatter","core::marker::Sized","core::result::Result"],"<T as bounds::LowerBounded>::min_value":[],"<T as bounds::UpperBounded>::max_value":[],"<T as real::Real>::abs":[],"<T as real::Real>::abs_sub":[],"<T as real::Real>::acos":[],"<T as real::Real>::acosh":[],"<T as real::Real>::asin":[],"<T as real::Real>::asinh":[],"<T as real::Real>::atan":[],"<T as real::Real>::atan2":[],"<T as real::Real>::atanh":[],"<T as real::Real>::cbrt":[],"<T as real::Real>::ceil":[],"<T as real::Real>::cos":[],"<T as real::Real>::cosh":[],"<T as real::Real>::epsilon":[],"<T as real::Real>::exp":[],"<T as real::Real>::exp2":[],"<T as real::Real>::exp_m1":[],"<T as real::Real>::floor":[],"<T as real::Real>::fract":[],"<T as real::Real>::hypot":[],"<T as real::Real>::is_sign_negative":[],"<T as real::Real>::is_sign_positive":[],"<T as real::Real>::ln":[],"<T as real::Real>::ln_1p":[],"<T as real::Real>::log":[],"<T as real::Real>::log10":[],"<T as real::Real>::log2":[],"<T as real::Real>::max":[],"<T as real::Real>::max_value":[],"<T as real::Real>::min":[],"<T as real::Real>::min_positive_value":[],"<T as real::Real>::min_value":[],"<T as real::Real>::mul_add":[],"<T as real::Real>::powf":[],"<T as real::Real>::powi":[],"<T as real::Real>::recip":[],"<T as real::Real>::round":[],"<T as real::Real>::signum":[],"<T as real::Real>::sin":[],"<T as real::Real>::sin_cos":[],"<T as real::Real>::sinh":[],"<T as real::Real>::sqrt":[],"<T as real::Real>::tan":[],"<T as real::Real>::tanh":[],"<T as real::Real>::to_degrees":[],"<T as real::Real>::to_radians":[],"<T as real::Real>::trunc":[],"<bool as cast::AsPrimitive<i128>>::as_":[],"<bool as cast::AsPrimitive<i16>>::as_":[],"<bool as cast::AsPrimitive<i32>>::as_":[],"<bool as cast::AsPrimitive<i64>>::as_":[],"<bool as cast::AsPrimitive<i8>>::as_":[],"<bool as cast::AsPrimitive<isize>>::as_":[],"<bool as cast::AsPrimitive<u128>>::as_":[],"<bool as cast::AsPrimitive<u16>>::as_":[],"<bool as cast::AsPrimitive<u32>>::as_":[],"<bool as cast::AsPrimitive<u64>>::as_":[],"<bool as cast::AsPrimitive<u8>>::as_":[],"<bool as cast::AsPrimitive<usize>>::as_":[],"<char as cast::AsPrimitive<char>>::as_":[],"<char as cast::AsPrimitive<i128>>::as_":[],"<char as cast::AsPrimitive<i16>>::as_":[],"<char as cast::AsPrimitive<i32>>::as_":[],"<char as cast::AsPrimitive<i64>>::as_":[],"<char as cast::AsPrimitive<i8>>::as_":[],"<char as cast::AsPrimitive<isize>>::as_":[],"<char as cast::AsPrimitive<u128>>::as_":[],"<char as cast::AsPrimitive<u16>>::as_":[],"<char as cast::AsPrimitive<u32>>::as_":[],"<char as cast::AsPrimitive<u64>>::as_":[],"<char as cast::AsPrimitive<u8>>::as_":[],"<char as cast::AsPrimitive<usize>>::as_":[],"<core::num::Wrapping<T> as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<core::num::Wrapping<T> as bounds::Bounded>::max_value":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as bounds::Bounded>::min_value":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<core::num::Wrapping<T> as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::num::Wrapping","core::option::Option"],"<core::num::Wrapping<T> as identities::One>::one":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as identities::One>::set_one":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as identities::Zero>::is_zero":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as identities::Zero>::set_zero":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as identities::Zero>::zero":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as ops::wrapping::WrappingAdd>::wrapping_add":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as ops::wrapping::WrappingMul>::wrapping_mul":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as ops::wrapping::WrappingNeg>::wrapping_neg":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as ops::wrapping::WrappingShl>::wrapping_shl":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as ops::wrapping::WrappingShr>::wrapping_shr":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as ops::wrapping::WrappingSub>::wrapping_sub":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as sign::Signed>::abs":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as sign::Signed>::abs_sub":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as sign::Signed>::is_negative":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as sign::Signed>::is_positive":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<T> as sign::Signed>::signum":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i128> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i128> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i128> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i128> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i16> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i16> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i16> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i16> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i32> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i32> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i32> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i32> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i64> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i64> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i64> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i64> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i8> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i8> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i8> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<i8> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<isize> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<isize> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<isize> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<isize> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u128> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u128> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u128> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u128> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u16> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u16> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u16> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u16> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u32> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u32> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u32> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u32> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u64> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u64> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u64> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u64> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u8> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u8> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u8> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<u8> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<usize> as pow::Pow<&'a u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<usize> as pow::Pow<&'a usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<usize> as pow::Pow<u8>>::pow":["core::marker::Sized","core::num::Wrapping"],"<core::num::Wrapping<usize> as pow::Pow<usize>>::pow":["core::marker::Sized","core::num::Wrapping"],"<f32 as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<f32 as Num>::from_str_radix::pow":[],"<f32 as Num>::from_str_radix::slice_shift_char":["core::marker::Sized","core::option::Option"],"<f32 as bounds::Bounded>::max_value":[],"<f32 as bounds::Bounded>::min_value":[],"<f32 as cast::AsPrimitive<f32>>::as_":[],"<f32 as cast::AsPrimitive<f64>>::as_":[],"<f32 as cast::AsPrimitive<i128>>::as_":[],"<f32 as cast::AsPrimitive<i16>>::as_":[],"<f32 as cast::AsPrimitive<i32>>::as_":[],"<f32 as cast::AsPrimitive<i64>>::as_":[],"<f32 as cast::AsPrimitive<i8>>::as_":[],"<f32 as cast::AsPrimitive<isize>>::as_":[],"<f32 as cast::AsPrimitive<u128>>::as_":[],"<f32 as cast::AsPrimitive<u16>>::as_":[],"<f32 as cast::AsPrimitive<u32>>::as_":[],"<f32 as cast::AsPrimitive<u64>>::as_":[],"<f32 as cast::AsPrimitive<u8>>::as_":[],"<f32 as cast::AsPrimitive<usize>>::as_":[],"<f32 as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<f32 as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<f32 as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<f32 as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<f32 as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<f32 as float::Float>::abs":[],"<f32 as float::Float>::abs_sub":[],"<f32 as float::Float>::acos":[],"<f32 as float::Float>::acosh":[],"<f32 as float::Float>::asin":[],"<f32 as float::Float>::asinh":[],"<f32 as float::Float>::atan":[],"<f32 as float::Float>::atan2":[],"<f32 as float::Float>::atanh":[],"<f32 as float::Float>::cbrt":[],"<f32 as float::Float>::ceil":[],"<f32 as float::Float>::classify":["core::num::FpCategory"],"<f32 as float::Float>::copysign":[],"<f32 as float::Float>::cos":[],"<f32 as float::Float>::cosh":[],"<f32 as float::Float>::epsilon":[],"<f32 as float::Float>::exp":[],"<f32 as float::Float>::exp2":[],"<f32 as float::Float>::exp_m1":[],"<f32 as float::Float>::floor":[],"<f32 as float::Float>::fract":[],"<f32 as float::Float>::hypot":[],"<f32 as float::Float>::infinity":[],"<f32 as float::Float>::integer_decode":[],"<f32 as float::Float>::is_finite":[],"<f32 as float::Float>::is_infinite":[],"<f32 as float::Float>::is_nan":[],"<f32 as float::Float>::is_normal":[],"<f32 as float::Float>::is_sign_negative":[],"<f32 as float::Float>::is_sign_positive":[],"<f32 as float::Float>::ln":[],"<f32 as float::Float>::ln_1p":[],"<f32 as float::Float>::log":[],"<f32 as float::Float>::log10":[],"<f32 as float::Float>::log2":[],"<f32 as float::Float>::max":[],"<f32 as float::Float>::max_value":[],"<f32 as float::Float>::min":[],"<f32 as float::Float>::min_positive_value":[],"<f32 as float::Float>::min_value":[],"<f32 as float::Float>::mul_add":[],"<f32 as float::Float>::nan":[],"<f32 as float::Float>::neg_infinity":[],"<f32 as float::Float>::neg_zero":[],"<f32 as float::Float>::powf":[],"<f32 as float::Float>::powi":[],"<f32 as float::Float>::recip":[],"<f32 as float::Float>::round":[],"<f32 as float::Float>::signum":[],"<f32 as float::Float>::sin":[],"<f32 as float::Float>::sin_cos":[],"<f32 as float::Float>::sinh":[],"<f32 as float::Float>::sqrt":[],"<f32 as float::Float>::tan":[],"<f32 as float::Float>::tanh":[],"<f32 as float::Float>::to_degrees":[],"<f32 as float::Float>::to_radians":[],"<f32 as float::Float>::trunc":[],"<f32 as float::FloatConst>::E":[],"<f32 as float::FloatConst>::FRAC_1_PI":[],"<f32 as float::FloatConst>::FRAC_1_SQRT_2":[],"<f32 as float::FloatConst>::FRAC_2_PI":[],"<f32 as float::FloatConst>::FRAC_2_SQRT_PI":[],"<f32 as float::FloatConst>::FRAC_PI_2":[],"<f32 as float::FloatConst>::FRAC_PI_3":[],"<f32 as float::FloatConst>::FRAC_PI_4":[],"<f32 as float::FloatConst>::FRAC_PI_6":[],"<f32 as float::FloatConst>::FRAC_PI_8":[],"<f32 as float::FloatConst>::LN_10":[],"<f32 as float::FloatConst>::LN_2":[],"<f32 as float::FloatConst>::LOG10_2":[],"<f32 as float::FloatConst>::LOG10_E":[],"<f32 as float::FloatConst>::LOG2_10":[],"<f32 as float::FloatConst>::LOG2_E":[],"<f32 as float::FloatConst>::PI":[],"<f32 as float::FloatConst>::SQRT_2":[],"<f32 as float::FloatConst>::TAU":[],"<f32 as float::FloatCore>::abs":[],"<f32 as float::FloatCore>::ceil":[],"<f32 as float::FloatCore>::classify":["core::num::FpCategory"],"<f32 as float::FloatCore>::epsilon":[],"<f32 as float::FloatCore>::floor":[],"<f32 as float::FloatCore>::fract":[],"<f32 as float::FloatCore>::infinity":[],"<f32 as float::FloatCore>::integer_decode":[],"<f32 as float::FloatCore>::is_finite":[],"<f32 as float::FloatCore>::is_infinite":[],"<f32 as float::FloatCore>::is_nan":[],"<f32 as float::FloatCore>::is_normal":[],"<f32 as float::FloatCore>::is_sign_negative":[],"<f32 as float::FloatCore>::is_sign_positive":[],"<f32 as float::FloatCore>::max":[],"<f32 as float::FloatCore>::max_value":[],"<f32 as float::FloatCore>::min":[],"<f32 as float::FloatCore>::min_positive_value":[],"<f32 as float::FloatCore>::min_value":[],"<f32 as float::FloatCore>::nan":[],"<f32 as float::FloatCore>::neg_infinity":[],"<f32 as float::FloatCore>::neg_zero":[],"<f32 as float::FloatCore>::powi":[],"<f32 as float::FloatCore>::recip":[],"<f32 as float::FloatCore>::round":[],"<f32 as float::FloatCore>::signum":[],"<f32 as float::FloatCore>::to_degrees":[],"<f32 as float::FloatCore>::to_radians":[],"<f32 as float::FloatCore>::trunc":[],"<f32 as identities::One>::is_one":[],"<f32 as identities::One>::one":[],"<f32 as identities::Zero>::is_zero":[],"<f32 as identities::Zero>::zero":[],"<f32 as ops::euclid::Euclid>::div_euclid":[],"<f32 as ops::euclid::Euclid>::rem_euclid":[],"<f32 as ops::inv::Inv>::inv":[],"<f32 as ops::mul_add::MulAdd>::mul_add":[],"<f32 as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<f32 as sign::Signed>::abs":[],"<f32 as sign::Signed>::abs_sub":[],"<f32 as sign::Signed>::is_negative":[],"<f32 as sign::Signed>::is_positive":[],"<f32 as sign::Signed>::signum":[],"<f64 as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<f64 as Num>::from_str_radix::pow":[],"<f64 as Num>::from_str_radix::slice_shift_char":["core::marker::Sized","core::option::Option"],"<f64 as bounds::Bounded>::max_value":[],"<f64 as bounds::Bounded>::min_value":[],"<f64 as cast::AsPrimitive<f32>>::as_":[],"<f64 as cast::AsPrimitive<f64>>::as_":[],"<f64 as cast::AsPrimitive<i128>>::as_":[],"<f64 as cast::AsPrimitive<i16>>::as_":[],"<f64 as cast::AsPrimitive<i32>>::as_":[],"<f64 as cast::AsPrimitive<i64>>::as_":[],"<f64 as cast::AsPrimitive<i8>>::as_":[],"<f64 as cast::AsPrimitive<isize>>::as_":[],"<f64 as cast::AsPrimitive<u128>>::as_":[],"<f64 as cast::AsPrimitive<u16>>::as_":[],"<f64 as cast::AsPrimitive<u32>>::as_":[],"<f64 as cast::AsPrimitive<u64>>::as_":[],"<f64 as cast::AsPrimitive<u8>>::as_":[],"<f64 as cast::AsPrimitive<usize>>::as_":[],"<f64 as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<f64 as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<f64 as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<f64 as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<f64 as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<f64 as float::Float>::abs":[],"<f64 as float::Float>::abs_sub":[],"<f64 as float::Float>::acos":[],"<f64 as float::Float>::acosh":[],"<f64 as float::Float>::asin":[],"<f64 as float::Float>::asinh":[],"<f64 as float::Float>::atan":[],"<f64 as float::Float>::atan2":[],"<f64 as float::Float>::atanh":[],"<f64 as float::Float>::cbrt":[],"<f64 as float::Float>::ceil":[],"<f64 as float::Float>::classify":["core::num::FpCategory"],"<f64 as float::Float>::copysign":[],"<f64 as float::Float>::cos":[],"<f64 as float::Float>::cosh":[],"<f64 as float::Float>::epsilon":[],"<f64 as float::Float>::exp":[],"<f64 as float::Float>::exp2":[],"<f64 as float::Float>::exp_m1":[],"<f64 as float::Float>::floor":[],"<f64 as float::Float>::fract":[],"<f64 as float::Float>::hypot":[],"<f64 as float::Float>::infinity":[],"<f64 as float::Float>::integer_decode":[],"<f64 as float::Float>::is_finite":[],"<f64 as float::Float>::is_infinite":[],"<f64 as float::Float>::is_nan":[],"<f64 as float::Float>::is_normal":[],"<f64 as float::Float>::is_sign_negative":[],"<f64 as float::Float>::is_sign_positive":[],"<f64 as float::Float>::ln":[],"<f64 as float::Float>::ln_1p":[],"<f64 as float::Float>::log":[],"<f64 as float::Float>::log10":[],"<f64 as float::Float>::log2":[],"<f64 as float::Float>::max":[],"<f64 as float::Float>::max_value":[],"<f64 as float::Float>::min":[],"<f64 as float::Float>::min_positive_value":[],"<f64 as float::Float>::min_value":[],"<f64 as float::Float>::mul_add":[],"<f64 as float::Float>::nan":[],"<f64 as float::Float>::neg_infinity":[],"<f64 as float::Float>::neg_zero":[],"<f64 as float::Float>::powf":[],"<f64 as float::Float>::powi":[],"<f64 as float::Float>::recip":[],"<f64 as float::Float>::round":[],"<f64 as float::Float>::signum":[],"<f64 as float::Float>::sin":[],"<f64 as float::Float>::sin_cos":[],"<f64 as float::Float>::sinh":[],"<f64 as float::Float>::sqrt":[],"<f64 as float::Float>::tan":[],"<f64 as float::Float>::tanh":[],"<f64 as float::Float>::to_degrees":[],"<f64 as float::Float>::to_radians":[],"<f64 as float::Float>::trunc":[],"<f64 as float::FloatConst>::E":[],"<f64 as float::FloatConst>::FRAC_1_PI":[],"<f64 as float::FloatConst>::FRAC_1_SQRT_2":[],"<f64 as float::FloatConst>::FRAC_2_PI":[],"<f64 as float::FloatConst>::FRAC_2_SQRT_PI":[],"<f64 as float::FloatConst>::FRAC_PI_2":[],"<f64 as float::FloatConst>::FRAC_PI_3":[],"<f64 as float::FloatConst>::FRAC_PI_4":[],"<f64 as float::FloatConst>::FRAC_PI_6":[],"<f64 as float::FloatConst>::FRAC_PI_8":[],"<f64 as float::FloatConst>::LN_10":[],"<f64 as float::FloatConst>::LN_2":[],"<f64 as float::FloatConst>::LOG10_2":[],"<f64 as float::FloatConst>::LOG10_E":[],"<f64 as float::FloatConst>::LOG2_10":[],"<f64 as float::FloatConst>::LOG2_E":[],"<f64 as float::FloatConst>::PI":[],"<f64 as float::FloatConst>::SQRT_2":[],"<f64 as float::FloatConst>::TAU":[],"<f64 as float::FloatCore>::abs":[],"<f64 as float::FloatCore>::ceil":[],"<f64 as float::FloatCore>::classify":["core::num::FpCategory"],"<f64 as float::FloatCore>::epsilon":[],"<f64 as float::FloatCore>::floor":[],"<f64 as float::FloatCore>::fract":[],"<f64 as float::FloatCore>::infinity":[],"<f64 as float::FloatCore>::integer_decode":[],"<f64 as float::FloatCore>::is_finite":[],"<f64 as float::FloatCore>::is_infinite":[],"<f64 as float::FloatCore>::is_nan":[],"<f64 as float::FloatCore>::is_normal":[],"<f64 as float::FloatCore>::is_sign_negative":[],"<f64 as float::FloatCore>::is_sign_positive":[],"<f64 as float::FloatCore>::max":[],"<f64 as float::FloatCore>::max_value":[],"<f64 as float::FloatCore>::min":[],"<f64 as float::FloatCore>::min_positive_value":[],"<f64 as float::FloatCore>::min_value":[],"<f64 as float::FloatCore>::nan":[],"<f64 as float::FloatCore>::neg_infinity":[],"<f64 as float::FloatCore>::neg_zero":[],"<f64 as float::FloatCore>::powi":[],"<f64 as float::FloatCore>::recip":[],"<f64 as float::FloatCore>::round":[],"<f64 as float::FloatCore>::signum":[],"<f64 as float::FloatCore>::to_degrees":[],"<f64 as float::FloatCore>::to_radians":[],"<f64 as float::FloatCore>::trunc":[],"<f64 as identities::One>::is_one":[],"<f64 as identities::One>::one":[],"<f64 as identities::Zero>::is_zero":[],"<f64 as identities::Zero>::zero":[],"<f64 as ops::euclid::Euclid>::div_euclid":[],"<f64 as ops::euclid::Euclid>::rem_euclid":[],"<f64 as ops::inv::Inv>::inv":[],"<f64 as ops::mul_add::MulAdd>::mul_add":[],"<f64 as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<f64 as sign::Signed>::abs":[],"<f64 as sign::Signed>::abs_sub":[],"<f64 as sign::Signed>::is_negative":[],"<f64 as sign::Signed>::is_positive":[],"<f64 as sign::Signed>::signum":[],"<i128 as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<i128 as bounds::Bounded>::max_value":[],"<i128 as bounds::Bounded>::min_value":[],"<i128 as cast::AsPrimitive<f32>>::as_":[],"<i128 as cast::AsPrimitive<f64>>::as_":[],"<i128 as cast::AsPrimitive<i128>>::as_":[],"<i128 as cast::AsPrimitive<i16>>::as_":[],"<i128 as cast::AsPrimitive<i32>>::as_":[],"<i128 as cast::AsPrimitive<i64>>::as_":[],"<i128 as cast::AsPrimitive<i8>>::as_":[],"<i128 as cast::AsPrimitive<isize>>::as_":[],"<i128 as cast::AsPrimitive<u128>>::as_":[],"<i128 as cast::AsPrimitive<u16>>::as_":[],"<i128 as cast::AsPrimitive<u32>>::as_":[],"<i128 as cast::AsPrimitive<u64>>::as_":[],"<i128 as cast::AsPrimitive<u8>>::as_":[],"<i128 as cast::AsPrimitive<usize>>::as_":[],"<i128 as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<i128 as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<i128 as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<i128 as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<i128 as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<i128 as identities::One>::is_one":[],"<i128 as identities::One>::one":[],"<i128 as identities::Zero>::is_zero":[],"<i128 as identities::Zero>::zero":[],"<i128 as int::PrimInt>::count_ones":[],"<i128 as int::PrimInt>::count_zeros":[],"<i128 as int::PrimInt>::from_be":[],"<i128 as int::PrimInt>::from_le":[],"<i128 as int::PrimInt>::leading_ones":[],"<i128 as int::PrimInt>::leading_zeros":[],"<i128 as int::PrimInt>::pow":[],"<i128 as int::PrimInt>::reverse_bits":[],"<i128 as int::PrimInt>::rotate_left":[],"<i128 as int::PrimInt>::rotate_right":[],"<i128 as int::PrimInt>::signed_shl":[],"<i128 as int::PrimInt>::signed_shr":[],"<i128 as int::PrimInt>::swap_bytes":[],"<i128 as int::PrimInt>::to_be":[],"<i128 as int::PrimInt>::to_le":[],"<i128 as int::PrimInt>::trailing_ones":[],"<i128 as int::PrimInt>::trailing_zeros":[],"<i128 as int::PrimInt>::unsigned_shl":[],"<i128 as int::PrimInt>::unsigned_shr":[],"<i128 as ops::checked::CheckedAdd>::checked_add":["core::marker::Sized","core::option::Option"],"<i128 as ops::checked::CheckedDiv>::checked_div":["core::marker::Sized","core::option::Option"],"<i128 as ops::checked::CheckedMul>::checked_mul":["core::marker::Sized","core::option::Option"],"<i128 as ops::checked::CheckedNeg>::checked_neg":["core::marker::Sized","core::option::Option"],"<i128 as ops::checked::CheckedRem>::checked_rem":["core::marker::Sized","core::option::Option"],"<i128 as ops::checked::CheckedShl>::checked_shl":["core::marker::Sized","core::option::Option"],"<i128 as ops::checked::CheckedShr>::checked_shr":["core::marker::Sized","core::option::Option"],"<i128 as ops::checked::CheckedSub>::checked_sub":["core::marker::Sized","core::option::Option"],"<i128 as ops::euclid::CheckedEuclid>::checked_div_euclid":["core::marker::Sized","core::option::Option"],"<i128 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"<i128 as ops::euclid::Euclid>::div_euclid":[],"<i128 as ops::euclid::Euclid>::rem_euclid":[],"<i128 as ops::mul_add::MulAdd>::mul_add":[],"<i128 as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<i128 as ops::overflowing::OverflowingAdd>::overflowing_add":[],"<i128 as ops::overflowing::OverflowingMul>::overflowing_mul":[],"<i128 as ops::overflowing::OverflowingSub>::overflowing_sub":[],"<i128 as ops::saturating::Saturating>::saturating_add":[],"<i128 as ops::saturating::Saturating>::saturating_sub":[],"<i128 as ops::saturating::SaturatingAdd>::saturating_add":[],"<i128 as ops::saturating::SaturatingMul>::saturating_mul":[],"<i128 as ops::saturating::SaturatingSub>::saturating_sub":[],"<i128 as ops::wrapping::WrappingAdd>::wrapping_add":[],"<i128 as ops::wrapping::WrappingMul>::wrapping_mul":[],"<i128 as ops::wrapping::WrappingNeg>::wrapping_neg":[],"<i128 as ops::wrapping::WrappingShl>::wrapping_shl":[],"<i128 as ops::wrapping::WrappingShr>::wrapping_shr":[],"<i128 as ops::wrapping::WrappingSub>::wrapping_sub":[],"<i128 as pow::Pow<&'a u16>>::pow":[],"<i128 as pow::Pow<&'a u32>>::pow":[],"<i128 as pow::Pow<&'a u8>>::pow":[],"<i128 as pow::Pow<&'a usize>>::pow":[],"<i128 as pow::Pow<u16>>::pow":[],"<i128 as pow::Pow<u32>>::pow":[],"<i128 as pow::Pow<u8>>::pow":[],"<i128 as pow::Pow<usize>>::pow":[],"<i128 as sign::Signed>::abs":[],"<i128 as sign::Signed>::abs_sub":[],"<i128 as sign::Signed>::is_negative":[],"<i128 as sign::Signed>::is_positive":[],"<i128 as sign::Signed>::signum":[],"<i16 as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<i16 as bounds::Bounded>::max_value":[],"<i16 as bounds::Bounded>::min_value":[],"<i16 as cast::AsPrimitive<f32>>::as_":[],"<i16 as cast::AsPrimitive<f64>>::as_":[],"<i16 as cast::AsPrimitive<i128>>::as_":[],"<i16 as cast::AsPrimitive<i16>>::as_":[],"<i16 as cast::AsPrimitive<i32>>::as_":[],"<i16 as cast::AsPrimitive<i64>>::as_":[],"<i16 as cast::AsPrimitive<i8>>::as_":[],"<i16 as cast::AsPrimitive<isize>>::as_":[],"<i16 as cast::AsPrimitive<u128>>::as_":[],"<i16 as cast::AsPrimitive<u16>>::as_":[],"<i16 as cast::AsPrimitive<u32>>::as_":[],"<i16 as cast::AsPrimitive<u64>>::as_":[],"<i16 as cast::AsPrimitive<u8>>::as_":[],"<i16 as cast::AsPrimitive<usize>>::as_":[],"<i16 as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<i16 as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<i16 as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<i16 as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<i16 as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<i16 as identities::One>::is_one":[],"<i16 as identities::One>::one":[],"<i16 as identities::Zero>::is_zero":[],"<i16 as identities::Zero>::zero":[],"<i16 as int::PrimInt>::count_ones":[],"<i16 as int::PrimInt>::count_zeros":[],"<i16 as int::PrimInt>::from_be":[],"<i16 as int::PrimInt>::from_le":[],"<i16 as int::PrimInt>::leading_ones":[],"<i16 as int::PrimInt>::leading_zeros":[],"<i16 as int::PrimInt>::pow":[],"<i16 as int::PrimInt>::reverse_bits":[],"<i16 as int::PrimInt>::rotate_left":[],"<i16 as int::PrimInt>::rotate_right":[],"<i16 as int::PrimInt>::signed_shl":[],"<i16 as int::PrimInt>::signed_shr":[],"<i16 as int::PrimInt>::swap_bytes":[],"<i16 as int::PrimInt>::to_be":[],"<i16 as int::PrimInt>::to_le":[],"<i16 as int::PrimInt>::trailing_ones":[],"<i16 as int::PrimInt>::trailing_zeros":[],"<i16 as int::PrimInt>::unsigned_shl":[],"<i16 as int::PrimInt>::unsigned_shr":[],"<i16 as ops::checked::CheckedAdd>::checked_add":["core::marker::Sized","core::option::Option"],"<i16 as ops::checked::CheckedDiv>::checked_div":["core::marker::Sized","core::option::Option"],"<i16 as ops::checked::CheckedMul>::checked_mul":["core::marker::Sized","core::option::Option"],"<i16 as ops::checked::CheckedNeg>::checked_neg":["core::marker::Sized","core::option::Option"],"<i16 as ops::checked::CheckedRem>::checked_rem":["core::marker::Sized","core::option::Option"],"<i16 as ops::checked::CheckedShl>::checked_shl":["core::marker::Sized","core::option::Option"],"<i16 as ops::checked::CheckedShr>::checked_shr":["core::marker::Sized","core::option::Option"],"<i16 as ops::checked::CheckedSub>::checked_sub":["core::marker::Sized","core::option::Option"],"<i16 as ops::euclid::CheckedEuclid>::checked_div_euclid":["core::marker::Sized","core::option::Option"],"<i16 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"<i16 as ops::euclid::Euclid>::div_euclid":[],"<i16 as ops::euclid::Euclid>::rem_euclid":[],"<i16 as ops::mul_add::MulAdd>::mul_add":[],"<i16 as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<i16 as ops::overflowing::OverflowingAdd>::overflowing_add":[],"<i16 as ops::overflowing::OverflowingMul>::overflowing_mul":[],"<i16 as ops::overflowing::OverflowingSub>::overflowing_sub":[],"<i16 as ops::saturating::Saturating>::saturating_add":[],"<i16 as ops::saturating::Saturating>::saturating_sub":[],"<i16 as ops::saturating::SaturatingAdd>::saturating_add":[],"<i16 as ops::saturating::SaturatingMul>::saturating_mul":[],"<i16 as ops::saturating::SaturatingSub>::saturating_sub":[],"<i16 as ops::wrapping::WrappingAdd>::wrapping_add":[],"<i16 as ops::wrapping::WrappingMul>::wrapping_mul":[],"<i16 as ops::wrapping::WrappingNeg>::wrapping_neg":[],"<i16 as ops::wrapping::WrappingShl>::wrapping_shl":[],"<i16 as ops::wrapping::WrappingShr>::wrapping_shr":[],"<i16 as ops::wrapping::WrappingSub>::wrapping_sub":[],"<i16 as pow::Pow<&'a u16>>::pow":[],"<i16 as pow::Pow<&'a u32>>::pow":[],"<i16 as pow::Pow<&'a u8>>::pow":[],"<i16 as pow::Pow<&'a usize>>::pow":[],"<i16 as pow::Pow<u16>>::pow":[],"<i16 as pow::Pow<u32>>::pow":[],"<i16 as pow::Pow<u8>>::pow":[],"<i16 as pow::Pow<usize>>::pow":[],"<i16 as sign::Signed>::abs":[],"<i16 as sign::Signed>::abs_sub":[],"<i16 as sign::Signed>::is_negative":[],"<i16 as sign::Signed>::is_positive":[],"<i16 as sign::Signed>::signum":[],"<i32 as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<i32 as bounds::Bounded>::max_value":[],"<i32 as bounds::Bounded>::min_value":[],"<i32 as cast::AsPrimitive<f32>>::as_":[],"<i32 as cast::AsPrimitive<f64>>::as_":[],"<i32 as cast::AsPrimitive<i128>>::as_":[],"<i32 as cast::AsPrimitive<i16>>::as_":[],"<i32 as cast::AsPrimitive<i32>>::as_":[],"<i32 as cast::AsPrimitive<i64>>::as_":[],"<i32 as cast::AsPrimitive<i8>>::as_":[],"<i32 as cast::AsPrimitive<isize>>::as_":[],"<i32 as cast::AsPrimitive<u128>>::as_":[],"<i32 as cast::AsPrimitive<u16>>::as_":[],"<i32 as cast::AsPrimitive<u32>>::as_":[],"<i32 as cast::AsPrimitive<u64>>::as_":[],"<i32 as cast::AsPrimitive<u8>>::as_":[],"<i32 as cast::AsPrimitive<usize>>::as_":[],"<i32 as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<i32 as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<i32 as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<i32 as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<i32 as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<i32 as identities::One>::is_one":[],"<i32 as identities::One>::one":[],"<i32 as identities::Zero>::is_zero":[],"<i32 as identities::Zero>::zero":[],"<i32 as int::PrimInt>::count_ones":[],"<i32 as int::PrimInt>::count_zeros":[],"<i32 as int::PrimInt>::from_be":[],"<i32 as int::PrimInt>::from_le":[],"<i32 as int::PrimInt>::leading_ones":[],"<i32 as int::PrimInt>::leading_zeros":[],"<i32 as int::PrimInt>::pow":[],"<i32 as int::PrimInt>::reverse_bits":[],"<i32 as int::PrimInt>::rotate_left":[],"<i32 as int::PrimInt>::rotate_right":[],"<i32 as int::PrimInt>::signed_shl":[],"<i32 as int::PrimInt>::signed_shr":[],"<i32 as int::PrimInt>::swap_bytes":[],"<i32 as int::PrimInt>::to_be":[],"<i32 as int::PrimInt>::to_le":[],"<i32 as int::PrimInt>::trailing_ones":[],"<i32 as int::PrimInt>::trailing_zeros":[],"<i32 as int::PrimInt>::unsigned_shl":[],"<i32 as int::PrimInt>::unsigned_shr":[],"<i32 as ops::checked::CheckedAdd>::checked_add":["core::marker::Sized","core::option::Option"],"<i32 as ops::checked::CheckedDiv>::checked_div":["core::marker::Sized","core::option::Option"],"<i32 as ops::checked::CheckedMul>::checked_mul":["core::marker::Sized","core::option::Option"],"<i32 as ops::checked::CheckedNeg>::checked_neg":["core::marker::Sized","core::option::Option"],"<i32 as ops::checked::CheckedRem>::checked_rem":["core::marker::Sized","core::option::Option"],"<i32 as ops::checked::CheckedShl>::checked_shl":["core::marker::Sized","core::option::Option"],"<i32 as ops::checked::CheckedShr>::checked_shr":["core::marker::Sized","core::option::Option"],"<i32 as ops::checked::CheckedSub>::checked_sub":["core::marker::Sized","core::option::Option"],"<i32 as ops::euclid::CheckedEuclid>::checked_div_euclid":["core::marker::Sized","core::option::Option"],"<i32 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"<i32 as ops::euclid::Euclid>::div_euclid":[],"<i32 as ops::euclid::Euclid>::rem_euclid":[],"<i32 as ops::mul_add::MulAdd>::mul_add":[],"<i32 as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<i32 as ops::overflowing::OverflowingAdd>::overflowing_add":[],"<i32 as ops::overflowing::OverflowingMul>::overflowing_mul":[],"<i32 as ops::overflowing::OverflowingSub>::overflowing_sub":[],"<i32 as ops::saturating::Saturating>::saturating_add":[],"<i32 as ops::saturating::Saturating>::saturating_sub":[],"<i32 as ops::saturating::SaturatingAdd>::saturating_add":[],"<i32 as ops::saturating::SaturatingMul>::saturating_mul":[],"<i32 as ops::saturating::SaturatingSub>::saturating_sub":[],"<i32 as ops::wrapping::WrappingAdd>::wrapping_add":[],"<i32 as ops::wrapping::WrappingMul>::wrapping_mul":[],"<i32 as ops::wrapping::WrappingNeg>::wrapping_neg":[],"<i32 as ops::wrapping::WrappingShl>::wrapping_shl":[],"<i32 as ops::wrapping::WrappingShr>::wrapping_shr":[],"<i32 as ops::wrapping::WrappingSub>::wrapping_sub":[],"<i32 as pow::Pow<&'a u16>>::pow":[],"<i32 as pow::Pow<&'a u32>>::pow":[],"<i32 as pow::Pow<&'a u8>>::pow":[],"<i32 as pow::Pow<&'a usize>>::pow":[],"<i32 as pow::Pow<u16>>::pow":[],"<i32 as pow::Pow<u32>>::pow":[],"<i32 as pow::Pow<u8>>::pow":[],"<i32 as pow::Pow<usize>>::pow":[],"<i32 as sign::Signed>::abs":[],"<i32 as sign::Signed>::abs_sub":[],"<i32 as sign::Signed>::is_negative":[],"<i32 as sign::Signed>::is_positive":[],"<i32 as sign::Signed>::signum":[],"<i64 as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<i64 as bounds::Bounded>::max_value":[],"<i64 as bounds::Bounded>::min_value":[],"<i64 as cast::AsPrimitive<f32>>::as_":[],"<i64 as cast::AsPrimitive<f64>>::as_":[],"<i64 as cast::AsPrimitive<i128>>::as_":[],"<i64 as cast::AsPrimitive<i16>>::as_":[],"<i64 as cast::AsPrimitive<i32>>::as_":[],"<i64 as cast::AsPrimitive<i64>>::as_":[],"<i64 as cast::AsPrimitive<i8>>::as_":[],"<i64 as cast::AsPrimitive<isize>>::as_":[],"<i64 as cast::AsPrimitive<u128>>::as_":[],"<i64 as cast::AsPrimitive<u16>>::as_":[],"<i64 as cast::AsPrimitive<u32>>::as_":[],"<i64 as cast::AsPrimitive<u64>>::as_":[],"<i64 as cast::AsPrimitive<u8>>::as_":[],"<i64 as cast::AsPrimitive<usize>>::as_":[],"<i64 as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<i64 as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<i64 as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<i64 as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<i64 as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<i64 as identities::One>::is_one":[],"<i64 as identities::One>::one":[],"<i64 as identities::Zero>::is_zero":[],"<i64 as identities::Zero>::zero":[],"<i64 as int::PrimInt>::count_ones":[],"<i64 as int::PrimInt>::count_zeros":[],"<i64 as int::PrimInt>::from_be":[],"<i64 as int::PrimInt>::from_le":[],"<i64 as int::PrimInt>::leading_ones":[],"<i64 as int::PrimInt>::leading_zeros":[],"<i64 as int::PrimInt>::pow":[],"<i64 as int::PrimInt>::reverse_bits":[],"<i64 as int::PrimInt>::rotate_left":[],"<i64 as int::PrimInt>::rotate_right":[],"<i64 as int::PrimInt>::signed_shl":[],"<i64 as int::PrimInt>::signed_shr":[],"<i64 as int::PrimInt>::swap_bytes":[],"<i64 as int::PrimInt>::to_be":[],"<i64 as int::PrimInt>::to_le":[],"<i64 as int::PrimInt>::trailing_ones":[],"<i64 as int::PrimInt>::trailing_zeros":[],"<i64 as int::PrimInt>::unsigned_shl":[],"<i64 as int::PrimInt>::unsigned_shr":[],"<i64 as ops::checked::CheckedAdd>::checked_add":["core::marker::Sized","core::option::Option"],"<i64 as ops::checked::CheckedDiv>::checked_div":["core::marker::Sized","core::option::Option"],"<i64 as ops::checked::CheckedMul>::checked_mul":["core::marker::Sized","core::option::Option"],"<i64 as ops::checked::CheckedNeg>::checked_neg":["core::marker::Sized","core::option::Option"],"<i64 as ops::checked::CheckedRem>::checked_rem":["core::marker::Sized","core::option::Option"],"<i64 as ops::checked::CheckedShl>::checked_shl":["core::marker::Sized","core::option::Option"],"<i64 as ops::checked::CheckedShr>::checked_shr":["core::marker::Sized","core::option::Option"],"<i64 as ops::checked::CheckedSub>::checked_sub":["core::marker::Sized","core::option::Option"],"<i64 as ops::euclid::CheckedEuclid>::checked_div_euclid":["core::marker::Sized","core::option::Option"],"<i64 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"<i64 as ops::euclid::Euclid>::div_euclid":[],"<i64 as ops::euclid::Euclid>::rem_euclid":[],"<i64 as ops::mul_add::MulAdd>::mul_add":[],"<i64 as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<i64 as ops::overflowing::OverflowingAdd>::overflowing_add":[],"<i64 as ops::overflowing::OverflowingMul>::overflowing_mul":[],"<i64 as ops::overflowing::OverflowingSub>::overflowing_sub":[],"<i64 as ops::saturating::Saturating>::saturating_add":[],"<i64 as ops::saturating::Saturating>::saturating_sub":[],"<i64 as ops::saturating::SaturatingAdd>::saturating_add":[],"<i64 as ops::saturating::SaturatingMul>::saturating_mul":[],"<i64 as ops::saturating::SaturatingSub>::saturating_sub":[],"<i64 as ops::wrapping::WrappingAdd>::wrapping_add":[],"<i64 as ops::wrapping::WrappingMul>::wrapping_mul":[],"<i64 as ops::wrapping::WrappingNeg>::wrapping_neg":[],"<i64 as ops::wrapping::WrappingShl>::wrapping_shl":[],"<i64 as ops::wrapping::WrappingShr>::wrapping_shr":[],"<i64 as ops::wrapping::WrappingSub>::wrapping_sub":[],"<i64 as pow::Pow<&'a u16>>::pow":[],"<i64 as pow::Pow<&'a u32>>::pow":[],"<i64 as pow::Pow<&'a u8>>::pow":[],"<i64 as pow::Pow<&'a usize>>::pow":[],"<i64 as pow::Pow<u16>>::pow":[],"<i64 as pow::Pow<u32>>::pow":[],"<i64 as pow::Pow<u8>>::pow":[],"<i64 as pow::Pow<usize>>::pow":[],"<i64 as sign::Signed>::abs":[],"<i64 as sign::Signed>::abs_sub":[],"<i64 as sign::Signed>::is_negative":[],"<i64 as sign::Signed>::is_positive":[],"<i64 as sign::Signed>::signum":[],"<i8 as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<i8 as bounds::Bounded>::max_value":[],"<i8 as bounds::Bounded>::min_value":[],"<i8 as cast::AsPrimitive<f32>>::as_":[],"<i8 as cast::AsPrimitive<f64>>::as_":[],"<i8 as cast::AsPrimitive<i128>>::as_":[],"<i8 as cast::AsPrimitive<i16>>::as_":[],"<i8 as cast::AsPrimitive<i32>>::as_":[],"<i8 as cast::AsPrimitive<i64>>::as_":[],"<i8 as cast::AsPrimitive<i8>>::as_":[],"<i8 as cast::AsPrimitive<isize>>::as_":[],"<i8 as cast::AsPrimitive<u128>>::as_":[],"<i8 as cast::AsPrimitive<u16>>::as_":[],"<i8 as cast::AsPrimitive<u32>>::as_":[],"<i8 as cast::AsPrimitive<u64>>::as_":[],"<i8 as cast::AsPrimitive<u8>>::as_":[],"<i8 as cast::AsPrimitive<usize>>::as_":[],"<i8 as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<i8 as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<i8 as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<i8 as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<i8 as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<i8 as identities::One>::is_one":[],"<i8 as identities::One>::one":[],"<i8 as identities::Zero>::is_zero":[],"<i8 as identities::Zero>::zero":[],"<i8 as int::PrimInt>::count_ones":[],"<i8 as int::PrimInt>::count_zeros":[],"<i8 as int::PrimInt>::from_be":[],"<i8 as int::PrimInt>::from_le":[],"<i8 as int::PrimInt>::leading_ones":[],"<i8 as int::PrimInt>::leading_zeros":[],"<i8 as int::PrimInt>::pow":[],"<i8 as int::PrimInt>::reverse_bits":[],"<i8 as int::PrimInt>::rotate_left":[],"<i8 as int::PrimInt>::rotate_right":[],"<i8 as int::PrimInt>::signed_shl":[],"<i8 as int::PrimInt>::signed_shr":[],"<i8 as int::PrimInt>::swap_bytes":[],"<i8 as int::PrimInt>::to_be":[],"<i8 as int::PrimInt>::to_le":[],"<i8 as int::PrimInt>::trailing_ones":[],"<i8 as int::PrimInt>::trailing_zeros":[],"<i8 as int::PrimInt>::unsigned_shl":[],"<i8 as int::PrimInt>::unsigned_shr":[],"<i8 as ops::checked::CheckedAdd>::checked_add":["core::marker::Sized","core::option::Option"],"<i8 as ops::checked::CheckedDiv>::checked_div":["core::marker::Sized","core::option::Option"],"<i8 as ops::checked::CheckedMul>::checked_mul":["core::marker::Sized","core::option::Option"],"<i8 as ops::checked::CheckedNeg>::checked_neg":["core::marker::Sized","core::option::Option"],"<i8 as ops::checked::CheckedRem>::checked_rem":["core::marker::Sized","core::option::Option"],"<i8 as ops::checked::CheckedShl>::checked_shl":["core::marker::Sized","core::option::Option"],"<i8 as ops::checked::CheckedShr>::checked_shr":["core::marker::Sized","core::option::Option"],"<i8 as ops::checked::CheckedSub>::checked_sub":["core::marker::Sized","core::option::Option"],"<i8 as ops::euclid::CheckedEuclid>::checked_div_euclid":["core::marker::Sized","core::option::Option"],"<i8 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"<i8 as ops::euclid::Euclid>::div_euclid":[],"<i8 as ops::euclid::Euclid>::rem_euclid":[],"<i8 as ops::mul_add::MulAdd>::mul_add":[],"<i8 as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<i8 as ops::overflowing::OverflowingAdd>::overflowing_add":[],"<i8 as ops::overflowing::OverflowingMul>::overflowing_mul":[],"<i8 as ops::overflowing::OverflowingSub>::overflowing_sub":[],"<i8 as ops::saturating::Saturating>::saturating_add":[],"<i8 as ops::saturating::Saturating>::saturating_sub":[],"<i8 as ops::saturating::SaturatingAdd>::saturating_add":[],"<i8 as ops::saturating::SaturatingMul>::saturating_mul":[],"<i8 as ops::saturating::SaturatingSub>::saturating_sub":[],"<i8 as ops::wrapping::WrappingAdd>::wrapping_add":[],"<i8 as ops::wrapping::WrappingMul>::wrapping_mul":[],"<i8 as ops::wrapping::WrappingNeg>::wrapping_neg":[],"<i8 as ops::wrapping::WrappingShl>::wrapping_shl":[],"<i8 as ops::wrapping::WrappingShr>::wrapping_shr":[],"<i8 as ops::wrapping::WrappingSub>::wrapping_sub":[],"<i8 as pow::Pow<&'a u16>>::pow":[],"<i8 as pow::Pow<&'a u32>>::pow":[],"<i8 as pow::Pow<&'a u8>>::pow":[],"<i8 as pow::Pow<&'a usize>>::pow":[],"<i8 as pow::Pow<u16>>::pow":[],"<i8 as pow::Pow<u32>>::pow":[],"<i8 as pow::Pow<u8>>::pow":[],"<i8 as pow::Pow<usize>>::pow":[],"<i8 as sign::Signed>::abs":[],"<i8 as sign::Signed>::abs_sub":[],"<i8 as sign::Signed>::is_negative":[],"<i8 as sign::Signed>::is_positive":[],"<i8 as sign::Signed>::signum":[],"<isize as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<isize as bounds::Bounded>::max_value":[],"<isize as bounds::Bounded>::min_value":[],"<isize as cast::AsPrimitive<f32>>::as_":[],"<isize as cast::AsPrimitive<f64>>::as_":[],"<isize as cast::AsPrimitive<i128>>::as_":[],"<isize as cast::AsPrimitive<i16>>::as_":[],"<isize as cast::AsPrimitive<i32>>::as_":[],"<isize as cast::AsPrimitive<i64>>::as_":[],"<isize as cast::AsPrimitive<i8>>::as_":[],"<isize as cast::AsPrimitive<isize>>::as_":[],"<isize as cast::AsPrimitive<u128>>::as_":[],"<isize as cast::AsPrimitive<u16>>::as_":[],"<isize as cast::AsPrimitive<u32>>::as_":[],"<isize as cast::AsPrimitive<u64>>::as_":[],"<isize as cast::AsPrimitive<u8>>::as_":[],"<isize as cast::AsPrimitive<usize>>::as_":[],"<isize as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<isize as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<isize as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<isize as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<isize as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<isize as identities::One>::is_one":[],"<isize as identities::One>::one":[],"<isize as identities::Zero>::is_zero":[],"<isize as identities::Zero>::zero":[],"<isize as int::PrimInt>::count_ones":[],"<isize as int::PrimInt>::count_zeros":[],"<isize as int::PrimInt>::from_be":[],"<isize as int::PrimInt>::from_le":[],"<isize as int::PrimInt>::leading_ones":[],"<isize as int::PrimInt>::leading_zeros":[],"<isize as int::PrimInt>::pow":[],"<isize as int::PrimInt>::reverse_bits":[],"<isize as int::PrimInt>::rotate_left":[],"<isize as int::PrimInt>::rotate_right":[],"<isize as int::PrimInt>::signed_shl":[],"<isize as int::PrimInt>::signed_shr":[],"<isize as int::PrimInt>::swap_bytes":[],"<isize as int::PrimInt>::to_be":[],"<isize as int::PrimInt>::to_le":[],"<isize as int::PrimInt>::trailing_ones":[],"<isize as int::PrimInt>::trailing_zeros":[],"<isize as int::PrimInt>::unsigned_shl":[],"<isize as int::PrimInt>::unsigned_shr":[],"<isize as ops::checked::CheckedAdd>::checked_add":["core::marker::Sized","core::option::Option"],"<isize as ops::checked::CheckedDiv>::checked_div":["core::marker::Sized","core::option::Option"],"<isize as ops::checked::CheckedMul>::checked_mul":["core::marker::Sized","core::option::Option"],"<isize as ops::checked::CheckedNeg>::checked_neg":["core::marker::Sized","core::option::Option"],"<isize as ops::checked::CheckedRem>::checked_rem":["core::marker::Sized","core::option::Option"],"<isize as ops::checked::CheckedShl>::checked_shl":["core::marker::Sized","core::option::Option"],"<isize as ops::checked::CheckedShr>::checked_shr":["core::marker::Sized","core::option::Option"],"<isize as ops::checked::CheckedSub>::checked_sub":["core::marker::Sized","core::option::Option"],"<isize as ops::euclid::CheckedEuclid>::checked_div_euclid":["core::marker::Sized","core::option::Option"],"<isize as ops::euclid::CheckedEuclid>::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"<isize as ops::euclid::Euclid>::div_euclid":[],"<isize as ops::euclid::Euclid>::rem_euclid":[],"<isize as ops::mul_add::MulAdd>::mul_add":[],"<isize as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<isize as ops::overflowing::OverflowingAdd>::overflowing_add":[],"<isize as ops::overflowing::OverflowingMul>::overflowing_mul":[],"<isize as ops::overflowing::OverflowingSub>::overflowing_sub":[],"<isize as ops::saturating::Saturating>::saturating_add":[],"<isize as ops::saturating::Saturating>::saturating_sub":[],"<isize as ops::saturating::SaturatingAdd>::saturating_add":[],"<isize as ops::saturating::SaturatingMul>::saturating_mul":[],"<isize as ops::saturating::SaturatingSub>::saturating_sub":[],"<isize as ops::wrapping::WrappingAdd>::wrapping_add":[],"<isize as ops::wrapping::WrappingMul>::wrapping_mul":[],"<isize as ops::wrapping::WrappingNeg>::wrapping_neg":[],"<isize as ops::wrapping::WrappingShl>::wrapping_shl":[],"<isize as ops::wrapping::WrappingShr>::wrapping_shr":[],"<isize as ops::wrapping::WrappingSub>::wrapping_sub":[],"<isize as pow::Pow<&'a u16>>::pow":[],"<isize as pow::Pow<&'a u32>>::pow":[],"<isize as pow::Pow<&'a u8>>::pow":[],"<isize as pow::Pow<&'a usize>>::pow":[],"<isize as pow::Pow<u16>>::pow":[],"<isize as pow::Pow<u32>>::pow":[],"<isize as pow::Pow<u8>>::pow":[],"<isize as pow::Pow<usize>>::pow":[],"<isize as sign::Signed>::abs":[],"<isize as sign::Signed>::abs_sub":[],"<isize as sign::Signed>::is_negative":[],"<isize as sign::Signed>::is_positive":[],"<isize as sign::Signed>::signum":[],"<u128 as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<u128 as bounds::Bounded>::max_value":[],"<u128 as bounds::Bounded>::min_value":[],"<u128 as cast::AsPrimitive<f32>>::as_":[],"<u128 as cast::AsPrimitive<f64>>::as_":[],"<u128 as cast::AsPrimitive<i128>>::as_":[],"<u128 as cast::AsPrimitive<i16>>::as_":[],"<u128 as cast::AsPrimitive<i32>>::as_":[],"<u128 as cast::AsPrimitive<i64>>::as_":[],"<u128 as cast::AsPrimitive<i8>>::as_":[],"<u128 as cast::AsPrimitive<isize>>::as_":[],"<u128 as cast::AsPrimitive<u128>>::as_":[],"<u128 as cast::AsPrimitive<u16>>::as_":[],"<u128 as cast::AsPrimitive<u32>>::as_":[],"<u128 as cast::AsPrimitive<u64>>::as_":[],"<u128 as cast::AsPrimitive<u8>>::as_":[],"<u128 as cast::AsPrimitive<usize>>::as_":[],"<u128 as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<u128 as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<u128 as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<u128 as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<u128 as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<u128 as identities::One>::is_one":[],"<u128 as identities::One>::one":[],"<u128 as identities::Zero>::is_zero":[],"<u128 as identities::Zero>::zero":[],"<u128 as int::PrimInt>::count_ones":[],"<u128 as int::PrimInt>::count_zeros":[],"<u128 as int::PrimInt>::from_be":[],"<u128 as int::PrimInt>::from_le":[],"<u128 as int::PrimInt>::leading_ones":[],"<u128 as int::PrimInt>::leading_zeros":[],"<u128 as int::PrimInt>::pow":[],"<u128 as int::PrimInt>::reverse_bits":[],"<u128 as int::PrimInt>::rotate_left":[],"<u128 as int::PrimInt>::rotate_right":[],"<u128 as int::PrimInt>::signed_shl":[],"<u128 as int::PrimInt>::signed_shr":[],"<u128 as int::PrimInt>::swap_bytes":[],"<u128 as int::PrimInt>::to_be":[],"<u128 as int::PrimInt>::to_le":[],"<u128 as int::PrimInt>::trailing_ones":[],"<u128 as int::PrimInt>::trailing_zeros":[],"<u128 as int::PrimInt>::unsigned_shl":[],"<u128 as int::PrimInt>::unsigned_shr":[],"<u128 as ops::checked::CheckedAdd>::checked_add":["core::marker::Sized","core::option::Option"],"<u128 as ops::checked::CheckedDiv>::checked_div":["core::marker::Sized","core::option::Option"],"<u128 as ops::checked::CheckedMul>::checked_mul":["core::marker::Sized","core::option::Option"],"<u128 as ops::checked::CheckedNeg>::checked_neg":["core::marker::Sized","core::option::Option"],"<u128 as ops::checked::CheckedRem>::checked_rem":["core::marker::Sized","core::option::Option"],"<u128 as ops::checked::CheckedShl>::checked_shl":["core::marker::Sized","core::option::Option"],"<u128 as ops::checked::CheckedShr>::checked_shr":["core::marker::Sized","core::option::Option"],"<u128 as ops::checked::CheckedSub>::checked_sub":["core::marker::Sized","core::option::Option"],"<u128 as ops::euclid::CheckedEuclid>::checked_div_euclid":["core::marker::Sized","core::option::Option"],"<u128 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"<u128 as ops::euclid::Euclid>::div_euclid":[],"<u128 as ops::euclid::Euclid>::rem_euclid":[],"<u128 as ops::mul_add::MulAdd>::mul_add":[],"<u128 as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<u128 as ops::overflowing::OverflowingAdd>::overflowing_add":[],"<u128 as ops::overflowing::OverflowingMul>::overflowing_mul":[],"<u128 as ops::overflowing::OverflowingSub>::overflowing_sub":[],"<u128 as ops::saturating::Saturating>::saturating_add":[],"<u128 as ops::saturating::Saturating>::saturating_sub":[],"<u128 as ops::saturating::SaturatingAdd>::saturating_add":[],"<u128 as ops::saturating::SaturatingMul>::saturating_mul":[],"<u128 as ops::saturating::SaturatingSub>::saturating_sub":[],"<u128 as ops::wrapping::WrappingAdd>::wrapping_add":[],"<u128 as ops::wrapping::WrappingMul>::wrapping_mul":[],"<u128 as ops::wrapping::WrappingNeg>::wrapping_neg":[],"<u128 as ops::wrapping::WrappingShl>::wrapping_shl":[],"<u128 as ops::wrapping::WrappingShr>::wrapping_shr":[],"<u128 as ops::wrapping::WrappingSub>::wrapping_sub":[],"<u128 as pow::Pow<&'a u16>>::pow":[],"<u128 as pow::Pow<&'a u32>>::pow":[],"<u128 as pow::Pow<&'a u8>>::pow":[],"<u128 as pow::Pow<&'a usize>>::pow":[],"<u128 as pow::Pow<u16>>::pow":[],"<u128 as pow::Pow<u32>>::pow":[],"<u128 as pow::Pow<u8>>::pow":[],"<u128 as pow::Pow<usize>>::pow":[],"<u16 as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<u16 as bounds::Bounded>::max_value":[],"<u16 as bounds::Bounded>::min_value":[],"<u16 as cast::AsPrimitive<f32>>::as_":[],"<u16 as cast::AsPrimitive<f64>>::as_":[],"<u16 as cast::AsPrimitive<i128>>::as_":[],"<u16 as cast::AsPrimitive<i16>>::as_":[],"<u16 as cast::AsPrimitive<i32>>::as_":[],"<u16 as cast::AsPrimitive<i64>>::as_":[],"<u16 as cast::AsPrimitive<i8>>::as_":[],"<u16 as cast::AsPrimitive<isize>>::as_":[],"<u16 as cast::AsPrimitive<u128>>::as_":[],"<u16 as cast::AsPrimitive<u16>>::as_":[],"<u16 as cast::AsPrimitive<u32>>::as_":[],"<u16 as cast::AsPrimitive<u64>>::as_":[],"<u16 as cast::AsPrimitive<u8>>::as_":[],"<u16 as cast::AsPrimitive<usize>>::as_":[],"<u16 as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<u16 as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<u16 as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<u16 as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<u16 as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<u16 as identities::One>::is_one":[],"<u16 as identities::One>::one":[],"<u16 as identities::Zero>::is_zero":[],"<u16 as identities::Zero>::zero":[],"<u16 as int::PrimInt>::count_ones":[],"<u16 as int::PrimInt>::count_zeros":[],"<u16 as int::PrimInt>::from_be":[],"<u16 as int::PrimInt>::from_le":[],"<u16 as int::PrimInt>::leading_ones":[],"<u16 as int::PrimInt>::leading_zeros":[],"<u16 as int::PrimInt>::pow":[],"<u16 as int::PrimInt>::reverse_bits":[],"<u16 as int::PrimInt>::rotate_left":[],"<u16 as int::PrimInt>::rotate_right":[],"<u16 as int::PrimInt>::signed_shl":[],"<u16 as int::PrimInt>::signed_shr":[],"<u16 as int::PrimInt>::swap_bytes":[],"<u16 as int::PrimInt>::to_be":[],"<u16 as int::PrimInt>::to_le":[],"<u16 as int::PrimInt>::trailing_ones":[],"<u16 as int::PrimInt>::trailing_zeros":[],"<u16 as int::PrimInt>::unsigned_shl":[],"<u16 as int::PrimInt>::unsigned_shr":[],"<u16 as ops::checked::CheckedAdd>::checked_add":["core::marker::Sized","core::option::Option"],"<u16 as ops::checked::CheckedDiv>::checked_div":["core::marker::Sized","core::option::Option"],"<u16 as ops::checked::CheckedMul>::checked_mul":["core::marker::Sized","core::option::Option"],"<u16 as ops::checked::CheckedNeg>::checked_neg":["core::marker::Sized","core::option::Option"],"<u16 as ops::checked::CheckedRem>::checked_rem":["core::marker::Sized","core::option::Option"],"<u16 as ops::checked::CheckedShl>::checked_shl":["core::marker::Sized","core::option::Option"],"<u16 as ops::checked::CheckedShr>::checked_shr":["core::marker::Sized","core::option::Option"],"<u16 as ops::checked::CheckedSub>::checked_sub":["core::marker::Sized","core::option::Option"],"<u16 as ops::euclid::CheckedEuclid>::checked_div_euclid":["core::marker::Sized","core::option::Option"],"<u16 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"<u16 as ops::euclid::Euclid>::div_euclid":[],"<u16 as ops::euclid::Euclid>::rem_euclid":[],"<u16 as ops::mul_add::MulAdd>::mul_add":[],"<u16 as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<u16 as ops::overflowing::OverflowingAdd>::overflowing_add":[],"<u16 as ops::overflowing::OverflowingMul>::overflowing_mul":[],"<u16 as ops::overflowing::OverflowingSub>::overflowing_sub":[],"<u16 as ops::saturating::Saturating>::saturating_add":[],"<u16 as ops::saturating::Saturating>::saturating_sub":[],"<u16 as ops::saturating::SaturatingAdd>::saturating_add":[],"<u16 as ops::saturating::SaturatingMul>::saturating_mul":[],"<u16 as ops::saturating::SaturatingSub>::saturating_sub":[],"<u16 as ops::wrapping::WrappingAdd>::wrapping_add":[],"<u16 as ops::wrapping::WrappingMul>::wrapping_mul":[],"<u16 as ops::wrapping::WrappingNeg>::wrapping_neg":[],"<u16 as ops::wrapping::WrappingShl>::wrapping_shl":[],"<u16 as ops::wrapping::WrappingShr>::wrapping_shr":[],"<u16 as ops::wrapping::WrappingSub>::wrapping_sub":[],"<u16 as pow::Pow<&'a u16>>::pow":[],"<u16 as pow::Pow<&'a u32>>::pow":[],"<u16 as pow::Pow<&'a u8>>::pow":[],"<u16 as pow::Pow<&'a usize>>::pow":[],"<u16 as pow::Pow<u16>>::pow":[],"<u16 as pow::Pow<u32>>::pow":[],"<u16 as pow::Pow<u8>>::pow":[],"<u16 as pow::Pow<usize>>::pow":[],"<u32 as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<u32 as bounds::Bounded>::max_value":[],"<u32 as bounds::Bounded>::min_value":[],"<u32 as cast::AsPrimitive<f32>>::as_":[],"<u32 as cast::AsPrimitive<f64>>::as_":[],"<u32 as cast::AsPrimitive<i128>>::as_":[],"<u32 as cast::AsPrimitive<i16>>::as_":[],"<u32 as cast::AsPrimitive<i32>>::as_":[],"<u32 as cast::AsPrimitive<i64>>::as_":[],"<u32 as cast::AsPrimitive<i8>>::as_":[],"<u32 as cast::AsPrimitive<isize>>::as_":[],"<u32 as cast::AsPrimitive<u128>>::as_":[],"<u32 as cast::AsPrimitive<u16>>::as_":[],"<u32 as cast::AsPrimitive<u32>>::as_":[],"<u32 as cast::AsPrimitive<u64>>::as_":[],"<u32 as cast::AsPrimitive<u8>>::as_":[],"<u32 as cast::AsPrimitive<usize>>::as_":[],"<u32 as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<u32 as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<u32 as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<u32 as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<u32 as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<u32 as identities::One>::is_one":[],"<u32 as identities::One>::one":[],"<u32 as identities::Zero>::is_zero":[],"<u32 as identities::Zero>::zero":[],"<u32 as int::PrimInt>::count_ones":[],"<u32 as int::PrimInt>::count_zeros":[],"<u32 as int::PrimInt>::from_be":[],"<u32 as int::PrimInt>::from_le":[],"<u32 as int::PrimInt>::leading_ones":[],"<u32 as int::PrimInt>::leading_zeros":[],"<u32 as int::PrimInt>::pow":[],"<u32 as int::PrimInt>::reverse_bits":[],"<u32 as int::PrimInt>::rotate_left":[],"<u32 as int::PrimInt>::rotate_right":[],"<u32 as int::PrimInt>::signed_shl":[],"<u32 as int::PrimInt>::signed_shr":[],"<u32 as int::PrimInt>::swap_bytes":[],"<u32 as int::PrimInt>::to_be":[],"<u32 as int::PrimInt>::to_le":[],"<u32 as int::PrimInt>::trailing_ones":[],"<u32 as int::PrimInt>::trailing_zeros":[],"<u32 as int::PrimInt>::unsigned_shl":[],"<u32 as int::PrimInt>::unsigned_shr":[],"<u32 as ops::checked::CheckedAdd>::checked_add":["core::marker::Sized","core::option::Option"],"<u32 as ops::checked::CheckedDiv>::checked_div":["core::marker::Sized","core::option::Option"],"<u32 as ops::checked::CheckedMul>::checked_mul":["core::marker::Sized","core::option::Option"],"<u32 as ops::checked::CheckedNeg>::checked_neg":["core::marker::Sized","core::option::Option"],"<u32 as ops::checked::CheckedRem>::checked_rem":["core::marker::Sized","core::option::Option"],"<u32 as ops::checked::CheckedShl>::checked_shl":["core::marker::Sized","core::option::Option"],"<u32 as ops::checked::CheckedShr>::checked_shr":["core::marker::Sized","core::option::Option"],"<u32 as ops::checked::CheckedSub>::checked_sub":["core::marker::Sized","core::option::Option"],"<u32 as ops::euclid::CheckedEuclid>::checked_div_euclid":["core::marker::Sized","core::option::Option"],"<u32 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"<u32 as ops::euclid::Euclid>::div_euclid":[],"<u32 as ops::euclid::Euclid>::rem_euclid":[],"<u32 as ops::mul_add::MulAdd>::mul_add":[],"<u32 as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<u32 as ops::overflowing::OverflowingAdd>::overflowing_add":[],"<u32 as ops::overflowing::OverflowingMul>::overflowing_mul":[],"<u32 as ops::overflowing::OverflowingSub>::overflowing_sub":[],"<u32 as ops::saturating::Saturating>::saturating_add":[],"<u32 as ops::saturating::Saturating>::saturating_sub":[],"<u32 as ops::saturating::SaturatingAdd>::saturating_add":[],"<u32 as ops::saturating::SaturatingMul>::saturating_mul":[],"<u32 as ops::saturating::SaturatingSub>::saturating_sub":[],"<u32 as ops::wrapping::WrappingAdd>::wrapping_add":[],"<u32 as ops::wrapping::WrappingMul>::wrapping_mul":[],"<u32 as ops::wrapping::WrappingNeg>::wrapping_neg":[],"<u32 as ops::wrapping::WrappingShl>::wrapping_shl":[],"<u32 as ops::wrapping::WrappingShr>::wrapping_shr":[],"<u32 as ops::wrapping::WrappingSub>::wrapping_sub":[],"<u32 as pow::Pow<&'a u16>>::pow":[],"<u32 as pow::Pow<&'a u32>>::pow":[],"<u32 as pow::Pow<&'a u8>>::pow":[],"<u32 as pow::Pow<&'a usize>>::pow":[],"<u32 as pow::Pow<u16>>::pow":[],"<u32 as pow::Pow<u32>>::pow":[],"<u32 as pow::Pow<u8>>::pow":[],"<u32 as pow::Pow<usize>>::pow":[],"<u64 as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<u64 as bounds::Bounded>::max_value":[],"<u64 as bounds::Bounded>::min_value":[],"<u64 as cast::AsPrimitive<f32>>::as_":[],"<u64 as cast::AsPrimitive<f64>>::as_":[],"<u64 as cast::AsPrimitive<i128>>::as_":[],"<u64 as cast::AsPrimitive<i16>>::as_":[],"<u64 as cast::AsPrimitive<i32>>::as_":[],"<u64 as cast::AsPrimitive<i64>>::as_":[],"<u64 as cast::AsPrimitive<i8>>::as_":[],"<u64 as cast::AsPrimitive<isize>>::as_":[],"<u64 as cast::AsPrimitive<u128>>::as_":[],"<u64 as cast::AsPrimitive<u16>>::as_":[],"<u64 as cast::AsPrimitive<u32>>::as_":[],"<u64 as cast::AsPrimitive<u64>>::as_":[],"<u64 as cast::AsPrimitive<u8>>::as_":[],"<u64 as cast::AsPrimitive<usize>>::as_":[],"<u64 as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<u64 as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<u64 as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<u64 as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<u64 as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<u64 as identities::One>::is_one":[],"<u64 as identities::One>::one":[],"<u64 as identities::Zero>::is_zero":[],"<u64 as identities::Zero>::zero":[],"<u64 as int::PrimInt>::count_ones":[],"<u64 as int::PrimInt>::count_zeros":[],"<u64 as int::PrimInt>::from_be":[],"<u64 as int::PrimInt>::from_le":[],"<u64 as int::PrimInt>::leading_ones":[],"<u64 as int::PrimInt>::leading_zeros":[],"<u64 as int::PrimInt>::pow":[],"<u64 as int::PrimInt>::reverse_bits":[],"<u64 as int::PrimInt>::rotate_left":[],"<u64 as int::PrimInt>::rotate_right":[],"<u64 as int::PrimInt>::signed_shl":[],"<u64 as int::PrimInt>::signed_shr":[],"<u64 as int::PrimInt>::swap_bytes":[],"<u64 as int::PrimInt>::to_be":[],"<u64 as int::PrimInt>::to_le":[],"<u64 as int::PrimInt>::trailing_ones":[],"<u64 as int::PrimInt>::trailing_zeros":[],"<u64 as int::PrimInt>::unsigned_shl":[],"<u64 as int::PrimInt>::unsigned_shr":[],"<u64 as ops::checked::CheckedAdd>::checked_add":["core::marker::Sized","core::option::Option"],"<u64 as ops::checked::CheckedDiv>::checked_div":["core::marker::Sized","core::option::Option"],"<u64 as ops::checked::CheckedMul>::checked_mul":["core::marker::Sized","core::option::Option"],"<u64 as ops::checked::CheckedNeg>::checked_neg":["core::marker::Sized","core::option::Option"],"<u64 as ops::checked::CheckedRem>::checked_rem":["core::marker::Sized","core::option::Option"],"<u64 as ops::checked::CheckedShl>::checked_shl":["core::marker::Sized","core::option::Option"],"<u64 as ops::checked::CheckedShr>::checked_shr":["core::marker::Sized","core::option::Option"],"<u64 as ops::checked::CheckedSub>::checked_sub":["core::marker::Sized","core::option::Option"],"<u64 as ops::euclid::CheckedEuclid>::checked_div_euclid":["core::marker::Sized","core::option::Option"],"<u64 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"<u64 as ops::euclid::Euclid>::div_euclid":[],"<u64 as ops::euclid::Euclid>::rem_euclid":[],"<u64 as ops::mul_add::MulAdd>::mul_add":[],"<u64 as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<u64 as ops::overflowing::OverflowingAdd>::overflowing_add":[],"<u64 as ops::overflowing::OverflowingMul>::overflowing_mul":[],"<u64 as ops::overflowing::OverflowingSub>::overflowing_sub":[],"<u64 as ops::saturating::Saturating>::saturating_add":[],"<u64 as ops::saturating::Saturating>::saturating_sub":[],"<u64 as ops::saturating::SaturatingAdd>::saturating_add":[],"<u64 as ops::saturating::SaturatingMul>::saturating_mul":[],"<u64 as ops::saturating::SaturatingSub>::saturating_sub":[],"<u64 as ops::wrapping::WrappingAdd>::wrapping_add":[],"<u64 as ops::wrapping::WrappingMul>::wrapping_mul":[],"<u64 as ops::wrapping::WrappingNeg>::wrapping_neg":[],"<u64 as ops::wrapping::WrappingShl>::wrapping_shl":[],"<u64 as ops::wrapping::WrappingShr>::wrapping_shr":[],"<u64 as ops::wrapping::WrappingSub>::wrapping_sub":[],"<u64 as pow::Pow<&'a u16>>::pow":[],"<u64 as pow::Pow<&'a u32>>::pow":[],"<u64 as pow::Pow<&'a u8>>::pow":[],"<u64 as pow::Pow<&'a usize>>::pow":[],"<u64 as pow::Pow<u16>>::pow":[],"<u64 as pow::Pow<u32>>::pow":[],"<u64 as pow::Pow<u8>>::pow":[],"<u64 as pow::Pow<usize>>::pow":[],"<u8 as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<u8 as bounds::Bounded>::max_value":[],"<u8 as bounds::Bounded>::min_value":[],"<u8 as cast::AsPrimitive<char>>::as_":[],"<u8 as cast::AsPrimitive<f32>>::as_":[],"<u8 as cast::AsPrimitive<f64>>::as_":[],"<u8 as cast::AsPrimitive<i128>>::as_":[],"<u8 as cast::AsPrimitive<i16>>::as_":[],"<u8 as cast::AsPrimitive<i32>>::as_":[],"<u8 as cast::AsPrimitive<i64>>::as_":[],"<u8 as cast::AsPrimitive<i8>>::as_":[],"<u8 as cast::AsPrimitive<isize>>::as_":[],"<u8 as cast::AsPrimitive<u128>>::as_":[],"<u8 as cast::AsPrimitive<u16>>::as_":[],"<u8 as cast::AsPrimitive<u32>>::as_":[],"<u8 as cast::AsPrimitive<u64>>::as_":[],"<u8 as cast::AsPrimitive<u8>>::as_":[],"<u8 as cast::AsPrimitive<usize>>::as_":[],"<u8 as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<u8 as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<u8 as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<u8 as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<u8 as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<u8 as identities::One>::is_one":[],"<u8 as identities::One>::one":[],"<u8 as identities::Zero>::is_zero":[],"<u8 as identities::Zero>::zero":[],"<u8 as int::PrimInt>::count_ones":[],"<u8 as int::PrimInt>::count_zeros":[],"<u8 as int::PrimInt>::from_be":[],"<u8 as int::PrimInt>::from_le":[],"<u8 as int::PrimInt>::leading_ones":[],"<u8 as int::PrimInt>::leading_zeros":[],"<u8 as int::PrimInt>::pow":[],"<u8 as int::PrimInt>::reverse_bits":[],"<u8 as int::PrimInt>::rotate_left":[],"<u8 as int::PrimInt>::rotate_right":[],"<u8 as int::PrimInt>::signed_shl":[],"<u8 as int::PrimInt>::signed_shr":[],"<u8 as int::PrimInt>::swap_bytes":[],"<u8 as int::PrimInt>::to_be":[],"<u8 as int::PrimInt>::to_le":[],"<u8 as int::PrimInt>::trailing_ones":[],"<u8 as int::PrimInt>::trailing_zeros":[],"<u8 as int::PrimInt>::unsigned_shl":[],"<u8 as int::PrimInt>::unsigned_shr":[],"<u8 as ops::checked::CheckedAdd>::checked_add":["core::marker::Sized","core::option::Option"],"<u8 as ops::checked::CheckedDiv>::checked_div":["core::marker::Sized","core::option::Option"],"<u8 as ops::checked::CheckedMul>::checked_mul":["core::marker::Sized","core::option::Option"],"<u8 as ops::checked::CheckedNeg>::checked_neg":["core::marker::Sized","core::option::Option"],"<u8 as ops::checked::CheckedRem>::checked_rem":["core::marker::Sized","core::option::Option"],"<u8 as ops::checked::CheckedShl>::checked_shl":["core::marker::Sized","core::option::Option"],"<u8 as ops::checked::CheckedShr>::checked_shr":["core::marker::Sized","core::option::Option"],"<u8 as ops::checked::CheckedSub>::checked_sub":["core::marker::Sized","core::option::Option"],"<u8 as ops::euclid::CheckedEuclid>::checked_div_euclid":["core::marker::Sized","core::option::Option"],"<u8 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"<u8 as ops::euclid::Euclid>::div_euclid":[],"<u8 as ops::euclid::Euclid>::rem_euclid":[],"<u8 as ops::mul_add::MulAdd>::mul_add":[],"<u8 as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<u8 as ops::overflowing::OverflowingAdd>::overflowing_add":[],"<u8 as ops::overflowing::OverflowingMul>::overflowing_mul":[],"<u8 as ops::overflowing::OverflowingSub>::overflowing_sub":[],"<u8 as ops::saturating::Saturating>::saturating_add":[],"<u8 as ops::saturating::Saturating>::saturating_sub":[],"<u8 as ops::saturating::SaturatingAdd>::saturating_add":[],"<u8 as ops::saturating::SaturatingMul>::saturating_mul":[],"<u8 as ops::saturating::SaturatingSub>::saturating_sub":[],"<u8 as ops::wrapping::WrappingAdd>::wrapping_add":[],"<u8 as ops::wrapping::WrappingMul>::wrapping_mul":[],"<u8 as ops::wrapping::WrappingNeg>::wrapping_neg":[],"<u8 as ops::wrapping::WrappingShl>::wrapping_shl":[],"<u8 as ops::wrapping::WrappingShr>::wrapping_shr":[],"<u8 as ops::wrapping::WrappingSub>::wrapping_sub":[],"<u8 as pow::Pow<&'a u16>>::pow":[],"<u8 as pow::Pow<&'a u32>>::pow":[],"<u8 as pow::Pow<&'a u8>>::pow":[],"<u8 as pow::Pow<&'a usize>>::pow":[],"<u8 as pow::Pow<u16>>::pow":[],"<u8 as pow::Pow<u32>>::pow":[],"<u8 as pow::Pow<u8>>::pow":[],"<u8 as pow::Pow<usize>>::pow":[],"<usize as Num>::from_str_radix":["core::marker::Sized","core::result::Result"],"<usize as bounds::Bounded>::max_value":[],"<usize as bounds::Bounded>::min_value":[],"<usize as cast::AsPrimitive<f32>>::as_":[],"<usize as cast::AsPrimitive<f64>>::as_":[],"<usize as cast::AsPrimitive<i128>>::as_":[],"<usize as cast::AsPrimitive<i16>>::as_":[],"<usize as cast::AsPrimitive<i32>>::as_":[],"<usize as cast::AsPrimitive<i64>>::as_":[],"<usize as cast::AsPrimitive<i8>>::as_":[],"<usize as cast::AsPrimitive<isize>>::as_":[],"<usize as cast::AsPrimitive<u128>>::as_":[],"<usize as cast::AsPrimitive<u16>>::as_":[],"<usize as cast::AsPrimitive<u32>>::as_":[],"<usize as cast::AsPrimitive<u64>>::as_":[],"<usize as cast::AsPrimitive<u8>>::as_":[],"<usize as cast::AsPrimitive<usize>>::as_":[],"<usize as cast::FromPrimitive>::from_f32":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_f64":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_i128":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_i16":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_i32":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_i64":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_i8":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_isize":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_u128":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_u16":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_u32":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_u64":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_u8":["core::marker::Sized","core::option::Option"],"<usize as cast::FromPrimitive>::from_usize":["core::marker::Sized","core::option::Option"],"<usize as cast::NumCast>::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"<usize as cast::ToPrimitive>::to_f32":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_f64":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_i128":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_i16":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_i32":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_i64":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_i8":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_isize":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_u128":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_u16":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_u32":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_u64":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_u8":["core::marker::Sized","core::option::Option"],"<usize as cast::ToPrimitive>::to_usize":["core::marker::Sized","core::option::Option"],"<usize as identities::One>::is_one":[],"<usize as identities::One>::one":[],"<usize as identities::Zero>::is_zero":[],"<usize as identities::Zero>::zero":[],"<usize as int::PrimInt>::count_ones":[],"<usize as int::PrimInt>::count_zeros":[],"<usize as int::PrimInt>::from_be":[],"<usize as int::PrimInt>::from_le":[],"<usize as int::PrimInt>::leading_ones":[],"<usize as int::PrimInt>::leading_zeros":[],"<usize as int::PrimInt>::pow":[],"<usize as int::PrimInt>::reverse_bits":[],"<usize as int::PrimInt>::rotate_left":[],"<usize as int::PrimInt>::rotate_right":[],"<usize as int::PrimInt>::signed_shl":[],"<usize as int::PrimInt>::signed_shr":[],"<usize as int::PrimInt>::swap_bytes":[],"<usize as int::PrimInt>::to_be":[],"<usize as int::PrimInt>::to_le":[],"<usize as int::PrimInt>::trailing_ones":[],"<usize as int::PrimInt>::trailing_zeros":[],"<usize as int::PrimInt>::unsigned_shl":[],"<usize as int::PrimInt>::unsigned_shr":[],"<usize as ops::checked::CheckedAdd>::checked_add":["core::marker::Sized","core::option::Option"],"<usize as ops::checked::CheckedDiv>::checked_div":["core::marker::Sized","core::option::Option"],"<usize as ops::checked::CheckedMul>::checked_mul":["core::marker::Sized","core::option::Option"],"<usize as ops::checked::CheckedNeg>::checked_neg":["core::marker::Sized","core::option::Option"],"<usize as ops::checked::CheckedRem>::checked_rem":["core::marker::Sized","core::option::Option"],"<usize as ops::checked::CheckedShl>::checked_shl":["core::marker::Sized","core::option::Option"],"<usize as ops::checked::CheckedShr>::checked_shr":["core::marker::Sized","core::option::Option"],"<usize as ops::checked::CheckedSub>::checked_sub":["core::marker::Sized","core::option::Option"],"<usize as ops::euclid::CheckedEuclid>::checked_div_euclid":["core::marker::Sized","core::option::Option"],"<usize as ops::euclid::CheckedEuclid>::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"<usize as ops::euclid::Euclid>::div_euclid":[],"<usize as ops::euclid::Euclid>::rem_euclid":[],"<usize as ops::mul_add::MulAdd>::mul_add":[],"<usize as ops::mul_add::MulAddAssign>::mul_add_assign":[],"<usize as ops::overflowing::OverflowingAdd>::overflowing_add":[],"<usize as ops::overflowing::OverflowingMul>::overflowing_mul":[],"<usize as ops::overflowing::OverflowingSub>::overflowing_sub":[],"<usize as ops::saturating::Saturating>::saturating_add":[],"<usize as ops::saturating::Saturating>::saturating_sub":[],"<usize as ops::saturating::SaturatingAdd>::saturating_add":[],"<usize as ops::saturating::SaturatingMul>::saturating_mul":[],"<usize as ops::saturating::SaturatingSub>::saturating_sub":[],"<usize as ops::wrapping::WrappingAdd>::wrapping_add":[],"<usize as ops::wrapping::WrappingMul>::wrapping_mul":[],"<usize as ops::wrapping::WrappingNeg>::wrapping_neg":[],"<usize as ops::wrapping::WrappingShl>::wrapping_shl":[],"<usize as ops::wrapping::WrappingShr>::wrapping_shr":[],"<usize as ops::wrapping::WrappingSub>::wrapping_sub":[],"<usize as pow::Pow<&'a u16>>::pow":[],"<usize as pow::Pow<&'a u32>>::pow":[],"<usize as pow::Pow<&'a u8>>::pow":[],"<usize as pow::Pow<&'a usize>>::pow":[],"<usize as pow::Pow<u16>>::pow":[],"<usize as pow::Pow<u32>>::pow":[],"<usize as pow::Pow<u8>>::pow":[],"<usize as pow::Pow<usize>>::pow":[],"FloatErrorKind":["FloatErrorKind"],"Num::from_str_radix":["core::marker::Sized","core::result::Result"],"ParseFloatError":["FloatErrorKind","ParseFloatError"],"bounds::Bounded::max_value":[],"bounds::Bounded::min_value":[],"bounds::LowerBounded::min_value":[],"bounds::UpperBounded::max_value":[],"cast::AsPrimitive::as_":[],"cast::FromPrimitive::from_f32":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_f64":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_i128":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_i16":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_i32":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_i64":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_i8":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_isize":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_u128":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_u16":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_u32":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_u64":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_u8":["core::marker::Sized","core::option::Option"],"cast::FromPrimitive::from_usize":["core::marker::Sized","core::option::Option"],"cast::NumCast::from":["cast::ToPrimitive","core::marker::Sized","core::num::Wrapping","core::option::Option"],"cast::ToPrimitive::to_f32":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_f64":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_i128":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_i16":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_i32":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_i64":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_i8":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_isize":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_u128":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_u16":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_u32":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_u64":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_u8":["core::marker::Sized","core::option::Option"],"cast::ToPrimitive::to_usize":["core::marker::Sized","core::option::Option"],"cast::cast":["cast::NumCast","core::marker::Sized","core::num::Wrapping","core::option::Option"],"clamp":["core::cmp::PartialOrd","core::marker::Sized"],"clamp_max":["core::cmp::PartialOrd","core::marker::Sized"],"clamp_min":["core::cmp::PartialOrd","core::marker::Sized"],"float::Float::abs":[],"float::Float::abs_sub":[],"float::Float::acos":[],"float::Float::acosh":[],"float::Float::asin":[],"float::Float::asinh":[],"float::Float::atan":[],"float::Float::atan2":[],"float::Float::atanh":[],"float::Float::cbrt":[],"float::Float::ceil":[],"float::Float::classify":["core::num::FpCategory"],"float::Float::copysign":[],"float::Float::cos":[],"float::Float::cosh":[],"float::Float::epsilon":[],"float::Float::exp":[],"float::Float::exp2":[],"float::Float::exp_m1":[],"float::Float::floor":[],"float::Float::fract":[],"float::Float::hypot":[],"float::Float::infinity":[],"float::Float::integer_decode":[],"float::Float::is_finite":[],"float::Float::is_infinite":[],"float::Float::is_nan":[],"float::Float::is_normal":[],"float::Float::is_sign_negative":[],"float::Float::is_sign_positive":[],"float::Float::ln":[],"float::Float::ln_1p":[],"float::Float::log":[],"float::Float::log10":[],"float::Float::log2":[],"float::Float::max":[],"float::Float::max_value":[],"float::Float::min":[],"float::Float::min_positive_value":[],"float::Float::min_value":[],"float::Float::mul_add":[],"float::Float::nan":[],"float::Float::neg_infinity":[],"float::Float::neg_zero":[],"float::Float::powf":[],"float::Float::powi":[],"float::Float::recip":[],"float::Float::round":[],"float::Float::signum":[],"float::Float::sin":[],"float::Float::sin_cos":[],"float::Float::sinh":[],"float::Float::sqrt":[],"float::Float::tan":[],"float::Float::tanh":[],"float::Float::to_degrees":[],"float::Float::to_radians":[],"float::Float::trunc":[],"float::FloatConst::E":[],"float::FloatConst::FRAC_1_PI":[],"float::FloatConst::FRAC_1_SQRT_2":[],"float::FloatConst::FRAC_2_PI":[],"float::FloatConst::FRAC_2_SQRT_PI":[],"float::FloatConst::FRAC_PI_2":[],"float::FloatConst::FRAC_PI_3":[],"float::FloatConst::FRAC_PI_4":[],"float::FloatConst::FRAC_PI_6":[],"float::FloatConst::FRAC_PI_8":[],"float::FloatConst::LN_10":[],"float::FloatConst::LN_2":[],"float::FloatConst::LOG10_2":["core::marker::Sized","core::ops::Div"],"float::FloatConst::LOG10_E":[],"float::FloatConst::LOG2_10":["core::marker::Sized","core::ops::Div"],"float::FloatConst::LOG2_E":[],"float::FloatConst::PI":[],"float::FloatConst::SQRT_2":[],"float::FloatConst::TAU":["core::marker::Sized","core::ops::Add"],"float::FloatCore::abs":[],"float::FloatCore::ceil":[],"float::FloatCore::classify":["core::num::FpCategory"],"float::FloatCore::epsilon":[],"float::FloatCore::floor":[],"float::FloatCore::fract":[],"float::FloatCore::infinity":[],"float::FloatCore::integer_decode":[],"float::FloatCore::is_finite":[],"float::FloatCore::is_infinite":[],"float::FloatCore::is_nan":[],"float::FloatCore::is_normal":[],"float::FloatCore::is_sign_negative":[],"float::FloatCore::is_sign_positive":[],"float::FloatCore::max":[],"float::FloatCore::max_value":[],"float::FloatCore::min":[],"float::FloatCore::min_positive_value":[],"float::FloatCore::min_value":[],"float::FloatCore::nan":[],"float::FloatCore::neg_infinity":[],"float::FloatCore::neg_zero":[],"float::FloatCore::powi":[],"float::FloatCore::recip":[],"float::FloatCore::round":[],"float::FloatCore::signum":[],"float::FloatCore::to_degrees":[],"float::FloatCore::to_radians":[],"float::FloatCore::trunc":[],"float::integer_decode_f32":[],"float::integer_decode_f64":[],"identities::One::is_one":["core::cmp::PartialEq"],"identities::One::one":[],"identities::One::set_one":[],"identities::Zero::is_zero":[],"identities::Zero::set_zero":[],"identities::Zero::zero":[],"identities::one":["core::marker::Sized","core::num::Wrapping","identities::One"],"identities::zero":["core::marker::Sized","core::num::Wrapping","identities::Zero"],"int::PrimInt::count_ones":[],"int::PrimInt::count_zeros":[],"int::PrimInt::from_be":[],"int::PrimInt::from_le":[],"int::PrimInt::leading_ones":[],"int::PrimInt::leading_zeros":[],"int::PrimInt::pow":[],"int::PrimInt::reverse_bits":[],"int::PrimInt::rotate_left":[],"int::PrimInt::rotate_right":[],"int::PrimInt::signed_shl":[],"int::PrimInt::signed_shr":[],"int::PrimInt::swap_bytes":[],"int::PrimInt::to_be":[],"int::PrimInt::to_le":[],"int::PrimInt::trailing_ones":[],"int::PrimInt::trailing_zeros":[],"int::PrimInt::unsigned_shl":[],"int::PrimInt::unsigned_shr":[],"int::one_per_byte":["core::marker::Sized","int::PrimInt"],"int::reverse_bits_fallback":["core::marker::Sized","int::PrimInt"],"ops::checked::CheckedAdd::checked_add":["core::marker::Sized","core::option::Option"],"ops::checked::CheckedDiv::checked_div":["core::marker::Sized","core::option::Option"],"ops::checked::CheckedMul::checked_mul":["core::marker::Sized","core::option::Option"],"ops::checked::CheckedNeg::checked_neg":["core::marker::Sized","core::option::Option"],"ops::checked::CheckedRem::checked_rem":["core::marker::Sized","core::option::Option"],"ops::checked::CheckedShl::checked_shl":["core::marker::Sized","core::option::Option"],"ops::checked::CheckedShr::checked_shr":["core::marker::Sized","core::option::Option"],"ops::checked::CheckedSub::checked_sub":["core::marker::Sized","core::option::Option"],"ops::euclid::CheckedEuclid::checked_div_euclid":["core::marker::Sized","core::option::Option"],"ops::euclid::CheckedEuclid::checked_rem_euclid":["core::marker::Sized","core::option::Option"],"ops::euclid::Euclid::div_euclid":[],"ops::euclid::Euclid::rem_euclid":[],"ops::inv::Inv::inv":[],"ops::mul_add::MulAdd::mul_add":[],"ops::mul_add::MulAddAssign::mul_add_assign":[],"ops::overflowing::OverflowingAdd::overflowing_add":[],"ops::overflowing::OverflowingMul::overflowing_mul":[],"ops::overflowing::OverflowingSub::overflowing_sub":[],"ops::saturating::Saturating::saturating_add":[],"ops::saturating::Saturating::saturating_sub":[],"ops::saturating::SaturatingAdd::saturating_add":[],"ops::saturating::SaturatingMul::saturating_mul":[],"ops::saturating::SaturatingSub::saturating_sub":[],"ops::wrapping::WrappingAdd::wrapping_add":[],"ops::wrapping::WrappingMul::wrapping_mul":[],"ops::wrapping::WrappingNeg::wrapping_neg":[],"ops::wrapping::WrappingShl::wrapping_shl":[],"ops::wrapping::WrappingShr::wrapping_shr":[],"ops::wrapping::WrappingSub::wrapping_sub":[],"pow::Pow::pow":[],"pow::checked_pow":["core::clone::Clone","core::marker::Sized","core::num::Wrapping","core::option::Option","identities::One","ops::checked::CheckedMul"],"pow::float_impls::<impl pow::Pow<&'a f32> for &'b f32>::pow":[],"pow::float_impls::<impl pow::Pow<&'a f32> for &'b f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a f32> for f32>::pow":[],"pow::float_impls::<impl pow::Pow<&'a f32> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a f64> for &'b f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a f64> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a i16> for &'b f32>::pow":[],"pow::float_impls::<impl pow::Pow<&'a i16> for &'b f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a i16> for f32>::pow":[],"pow::float_impls::<impl pow::Pow<&'a i16> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a i32> for &'b f32>::pow":[],"pow::float_impls::<impl pow::Pow<&'a i32> for &'b f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a i32> for f32>::pow":[],"pow::float_impls::<impl pow::Pow<&'a i32> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a i8> for &'b f32>::pow":[],"pow::float_impls::<impl pow::Pow<&'a i8> for &'b f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a i8> for f32>::pow":[],"pow::float_impls::<impl pow::Pow<&'a i8> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a u16> for &'b f32>::pow":[],"pow::float_impls::<impl pow::Pow<&'a u16> for &'b f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a u16> for f32>::pow":[],"pow::float_impls::<impl pow::Pow<&'a u16> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a u8> for &'b f32>::pow":[],"pow::float_impls::<impl pow::Pow<&'a u8> for &'b f64>::pow":[],"pow::float_impls::<impl pow::Pow<&'a u8> for f32>::pow":[],"pow::float_impls::<impl pow::Pow<&'a u8> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<f32> for &'a f32>::pow":[],"pow::float_impls::<impl pow::Pow<f32> for &'a f64>::pow":[],"pow::float_impls::<impl pow::Pow<f32> for f32>::pow":[],"pow::float_impls::<impl pow::Pow<f32> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<f64> for &'a f64>::pow":[],"pow::float_impls::<impl pow::Pow<f64> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<i16> for &'a f32>::pow":[],"pow::float_impls::<impl pow::Pow<i16> for &'a f64>::pow":[],"pow::float_impls::<impl pow::Pow<i16> for f32>::pow":[],"pow::float_impls::<impl pow::Pow<i16> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<i32> for &'a f32>::pow":[],"pow::float_impls::<impl pow::Pow<i32> for &'a f64>::pow":[],"pow::float_impls::<impl pow::Pow<i32> for f32>::pow":[],"pow::float_impls::<impl pow::Pow<i32> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<i8> for &'a f32>::pow":[],"pow::float_impls::<impl pow::Pow<i8> for &'a f64>::pow":[],"pow::float_impls::<impl pow::Pow<i8> for f32>::pow":[],"pow::float_impls::<impl pow::Pow<i8> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<u16> for &'a f32>::pow":[],"pow::float_impls::<impl pow::Pow<u16> for &'a f64>::pow":[],"pow::float_impls::<impl pow::Pow<u16> for f32>::pow":[],"pow::float_impls::<impl pow::Pow<u16> for f64>::pow":[],"pow::float_impls::<impl pow::Pow<u8> for &'a f32>::pow":[],"pow::float_impls::<impl pow::Pow<u8> for &'a f64>::pow":[],"pow::float_impls::<impl pow::Pow<u8> for f32>::pow":[],"pow::float_impls::<impl pow::Pow<u8> for f64>::pow":[],"pow::pow":["core::clone::Clone","core::marker::Sized","core::num::Wrapping","core::ops::Mul","identities::One"],"real::Real::abs":[],"real::Real::abs_sub":[],"real::Real::acos":[],"real::Real::acosh":[],"real::Real::asin":[],"real::Real::asinh":[],"real::Real::atan":[],"real::Real::atan2":[],"real::Real::atanh":[],"real::Real::cbrt":[],"real::Real::ceil":[],"real::Real::cos":[],"real::Real::cosh":[],"real::Real::epsilon":[],"real::Real::exp":[],"real::Real::exp2":[],"real::Real::exp_m1":[],"real::Real::floor":[],"real::Real::fract":[],"real::Real::hypot":[],"real::Real::is_sign_negative":[],"real::Real::is_sign_positive":[],"real::Real::ln":[],"real::Real::ln_1p":[],"real::Real::log":[],"real::Real::log10":[],"real::Real::log2":[],"real::Real::max":[],"real::Real::max_value":[],"real::Real::min":[],"real::Real::min_positive_value":[],"real::Real::min_value":[],"real::Real::mul_add":[],"real::Real::powf":[],"real::Real::powi":[],"real::Real::recip":[],"real::Real::round":[],"real::Real::signum":[],"real::Real::sin":[],"real::Real::sin_cos":[],"real::Real::sinh":[],"real::Real::sqrt":[],"real::Real::tan":[],"real::Real::tanh":[],"real::Real::to_degrees":[],"real::Real::to_radians":[],"real::Real::trunc":[],"sign::Signed::abs":[],"sign::Signed::abs_sub":[],"sign::Signed::is_negative":[],"sign::Signed::is_positive":[],"sign::Signed::signum":[],"sign::abs":["core::marker::Sized","core::num::Wrapping","sign::Signed"],"sign::abs_sub":["core::marker::Sized","core::num::Wrapping","sign::Signed"],"sign::signum":["core::marker::Sized","core::num::Wrapping","sign::Signed"],"str_to_ascii_lower_eq_str":[]},"glob_path_import":{},"self_to_fn":{"<T as NumAssign>::T":["impl<T> NumAssign for T where T: Num + NumAssignOps {}"],"<T as NumAssignOps<Rhs>>::T":["impl<T, Rhs> NumAssignOps<Rhs> for T where\n    T: AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>\n{\n}"],"<T as NumAssignRef>::T":["impl<T> NumAssignRef for T where T: NumAssign + for<'r> NumAssignOps<&'r T> {}"],"<T as NumOps<Rhs, Output>>::T":["impl<T, Rhs, Output> NumOps<Rhs, Output> for T where\n    T: Add<Rhs, Output = Output>\n        + Sub<Rhs, Output = Output>\n        + Mul<Rhs, Output = Output>\n        + Div<Rhs, Output = Output>\n        + Rem<Rhs, Output = Output>\n{\n}"],"<T as NumRef>::T":["impl<T> NumRef for T where T: Num + for<'r> NumOps<&'r T> {}"],"<T as RefNum<Base>>::T":["impl<T, Base> RefNum<Base> for T where T: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}"],"<T as bounds::LowerBounded>::T":["impl<T: Bounded> LowerBounded for T {\n    fn min_value() -> T {\n        Bounded::min_value()\n    }\n}"],"<T as bounds::UpperBounded>::T":["impl<T: Bounded> UpperBounded for T {\n    fn max_value() -> T {\n        Bounded::max_value()\n    }\n}"],"<T as real::Real>::T":["impl<T: Float> Real for T {\n    forward! {\n        Float::min_value() -> Self;\n        Float::min_positive_value() -> Self;\n        Float::epsilon() -> Self;\n        Float::max_value() -> Self;\n    }\n    forward! {\n        Float::floor(self) -> Self;\n        Float::ceil(self) -> Self;\n        Float::round(self) -> Self;\n        Float::trunc(self) -> Self;\n        Float::fract(self) -> Self;\n        Float::abs(self) -> Self;\n        Float::signum(self) -> Self;\n        Float::is_sign_positive(self) -> bool;\n        Float::is_sign_negative(self) -> bool;\n        Float::mul_add(self, a: Self, b: Self) -> Self;\n        Float::recip(self) -> Self;\n        Float::powi(self, n: i32) -> Self;\n        Float::powf(self, n: Self) -> Self;\n        Float::sqrt(self) -> Self;\n        Float::exp(self) -> Self;\n        Float::exp2(self) -> Self;\n        Float::ln(self) -> Self;\n        Float::log(self, base: Self) -> Self;\n        Float::log2(self) -> Self;\n        Float::log10(self) -> Self;\n        Float::to_degrees(self) -> Self;\n        Float::to_radians(self) -> Self;\n        Float::max(self, other: Self) -> Self;\n        Float::min(self, other: Self) -> Self;\n        Float::abs_sub(self, other: Self) -> Self;\n        Float::cbrt(self) -> Self;\n        Float::hypot(self, other: Self) -> Self;\n        Float::sin(self) -> Self;\n        Float::cos(self) -> Self;\n        Float::tan(self) -> Self;\n        Float::asin(self) -> Self;\n        Float::acos(self) -> Self;\n        Float::atan(self) -> Self;\n        Float::atan2(self, other: Self) -> Self;\n        Float::sin_cos(self) -> (Self, Self);\n        Float::exp_m1(self) -> Self;\n        Float::ln_1p(self) -> Self;\n        Float::sinh(self) -> Self;\n        Float::cosh(self) -> Self;\n        Float::tanh(self) -> Self;\n        Float::asinh(self) -> Self;\n        Float::acosh(self) -> Self;\n        Float::atanh(self) -> Self;\n    }\n}"],"FloatErrorKind":["Debug"],"ParseFloatError":["Debug","impl fmt::Display for ParseFloatError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let description = match self.kind {\n            FloatErrorKind::Empty => \"cannot parse float from empty string\",\n            FloatErrorKind::Invalid => \"invalid float literal\",\n        };\n\n        description.fmt(f)\n    }\n}"],"core::num::Wrapping":["impl Pow<$rhs> for $t {\n            type Output = $t;\n            #[inline]\n            fn pow(self, rhs: $rhs) -> $t {\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }\n        }","impl<'a> Pow<&'a $rhs> for $t {\n            type Output = $t;\n            #[inline]\n            fn pow(self, rhs: &'a $rhs) -> $t {\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }\n        }","impl<T: Bounded> Bounded for Wrapping<T> {\n    fn min_value() -> Self {\n        Wrapping(T::min_value())\n    }\n    fn max_value() -> Self {\n        Wrapping(T::max_value())\n    }\n}","impl<T: FromPrimitive> FromPrimitive for Wrapping<T> {\n    impl_from_primitive_wrapping! {\n        fn from_isize(isize);\n        fn from_i8(i8);\n        fn from_i16(i16);\n        fn from_i32(i32);\n        fn from_i64(i64);\n        #[cfg(has_i128)]\n        fn from_i128(i128);\n\n        fn from_usize(usize);\n        fn from_u8(u8);\n        fn from_u16(u16);\n        fn from_u32(u32);\n        fn from_u64(u64);\n        #[cfg(has_i128)]\n        fn from_u128(u128);\n\n        fn from_f32(f32);\n        fn from_f64(f64);\n    }\n}","impl<T: Num> Num for Wrapping<T>\nwhere\n    Wrapping<T>: NumOps,\n{\n    type FromStrRadixErr = T::FromStrRadixErr;\n    fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr> {\n        T::from_str_radix(str, radix).map(Wrapping)\n    }\n}","impl<T: NumCast> NumCast for Wrapping<T> {\n    fn from<U: ToPrimitive>(n: U) -> Option<Self> {\n        T::from(n).map(Wrapping)\n    }\n}","impl<T: One> One for Wrapping<T>\nwhere\n    Wrapping<T>: Mul<Output = Wrapping<T>>,\n{\n    fn set_one(&mut self) {\n        self.0.set_one();\n    }\n\n    fn one() -> Self {\n        Wrapping(T::one())\n    }\n}","impl<T: Signed> Signed for Wrapping<T>\nwhere\n    Wrapping<T>: Num + Neg<Output = Wrapping<T>>,\n{\n    #[inline]\n    fn abs(&self) -> Self {\n        Wrapping(self.0.abs())\n    }\n\n    #[inline]\n    fn abs_sub(&self, other: &Self) -> Self {\n        Wrapping(self.0.abs_sub(&other.0))\n    }\n\n    #[inline]\n    fn signum(&self) -> Self {\n        Wrapping(self.0.signum())\n    }\n\n    #[inline]\n    fn is_positive(&self) -> bool {\n        self.0.is_positive()\n    }\n\n    #[inline]\n    fn is_negative(&self) -> bool {\n        self.0.is_negative()\n    }\n}","impl<T: ToPrimitive> ToPrimitive for Wrapping<T> {\n    impl_to_primitive_wrapping! {\n        fn to_isize -> isize;\n        fn to_i8 -> i8;\n        fn to_i16 -> i16;\n        fn to_i32 -> i32;\n        fn to_i64 -> i64;\n        #[cfg(has_i128)]\n        fn to_i128 -> i128;\n\n        fn to_usize -> usize;\n        fn to_u8 -> u8;\n        fn to_u16 -> u16;\n        fn to_u32 -> u32;\n        fn to_u64 -> u64;\n        #[cfg(has_i128)]\n        fn to_u128 -> u128;\n\n        fn to_f32 -> f32;\n        fn to_f64 -> f64;\n    }\n}","impl<T: Unsigned> Unsigned for Wrapping<T> where Wrapping<T>: Num {}","impl<T: WrappingAdd> WrappingAdd for Wrapping<T>\nwhere\n    Wrapping<T>: Add<Output = Wrapping<T>>,\n{\n    fn wrapping_add(&self, v: &Self) -> Self {\n        Wrapping(self.0.wrapping_add(&v.0))\n    }\n}","impl<T: WrappingMul> WrappingMul for Wrapping<T>\nwhere\n    Wrapping<T>: Mul<Output = Wrapping<T>>,\n{\n    fn wrapping_mul(&self, v: &Self) -> Self {\n        Wrapping(self.0.wrapping_mul(&v.0))\n    }\n}","impl<T: WrappingNeg> WrappingNeg for Wrapping<T>\nwhere\n    Wrapping<T>: Neg<Output = Wrapping<T>>,\n{\n    fn wrapping_neg(&self) -> Self {\n        Wrapping(self.0.wrapping_neg())\n    }\n}","impl<T: WrappingShl> WrappingShl for Wrapping<T>\nwhere\n    Wrapping<T>: Shl<usize, Output = Wrapping<T>>,\n{\n    fn wrapping_shl(&self, rhs: u32) -> Self {\n        Wrapping(self.0.wrapping_shl(rhs))\n    }\n}","impl<T: WrappingShr> WrappingShr for Wrapping<T>\nwhere\n    Wrapping<T>: Shr<usize, Output = Wrapping<T>>,\n{\n    fn wrapping_shr(&self, rhs: u32) -> Self {\n        Wrapping(self.0.wrapping_shr(rhs))\n    }\n}","impl<T: WrappingSub> WrappingSub for Wrapping<T>\nwhere\n    Wrapping<T>: Sub<Output = Wrapping<T>>,\n{\n    fn wrapping_sub(&self, v: &Self) -> Self {\n        Wrapping(self.0.wrapping_sub(&v.0))\n    }\n}","impl<T: Zero> Zero for Wrapping<T>\nwhere\n    Wrapping<T>: Add<Output = Wrapping<T>>,\n{\n    fn is_zero(&self) -> bool {\n        self.0.is_zero()\n    }\n\n    fn set_zero(&mut self) {\n        self.0.set_zero();\n    }\n\n    fn zero() -> Self {\n        Wrapping(T::zero())\n    }\n}"]},"single_path_import":{"bounds::Bounded":"Bounded","cast::AsPrimitive":"AsPrimitive","cast::FromPrimitive":"FromPrimitive","cast::NumCast":"NumCast","cast::ToPrimitive":"ToPrimitive","cast::cast":"cast","float::Float":"Float","float::FloatConst":"FloatConst","identities::One":"One","identities::Zero":"Zero","identities::one":"one","identities::zero":"zero","int::PrimInt":"PrimInt","ops::checked::CheckedAdd":"CheckedAdd","ops::checked::CheckedDiv":"CheckedDiv","ops::checked::CheckedMul":"CheckedMul","ops::checked::CheckedNeg":"CheckedNeg","ops::checked::CheckedRem":"CheckedRem","ops::checked::CheckedShl":"CheckedShl","ops::checked::CheckedShr":"CheckedShr","ops::checked::CheckedSub":"CheckedSub","ops::euclid::CheckedEuclid":"CheckedEuclid","ops::euclid::Euclid":"Euclid","ops::inv::Inv":"Inv","ops::mul_add::MulAdd":"MulAdd","ops::mul_add::MulAddAssign":"MulAddAssign","ops::saturating::Saturating":"Saturating","ops::saturating::SaturatingAdd":"SaturatingAdd","ops::saturating::SaturatingMul":"SaturatingMul","ops::saturating::SaturatingSub":"SaturatingSub","ops::wrapping::WrappingAdd":"WrappingAdd","ops::wrapping::WrappingMul":"WrappingMul","ops::wrapping::WrappingNeg":"WrappingNeg","ops::wrapping::WrappingShl":"WrappingShl","ops::wrapping::WrappingShr":"WrappingShr","ops::wrapping::WrappingSub":"WrappingSub","pow::Pow":"Pow","pow::checked_pow":"checked_pow","pow::pow":"pow","sign::Signed":"Signed","sign::Unsigned":"Unsigned","sign::abs":"abs","sign::abs_sub":"abs_sub","sign::signum":"signum"},"srcs":{"<&'a core::num::Wrapping<i128> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<i128> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<i16> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<i16> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<i32> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<i32> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<i64> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<i64> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<i8> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<i8> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<isize> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<isize> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<u128> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<u128> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<u16> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<u16> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<u32> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<u32> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<u64> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<u64> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<u8> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<u8> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<usize> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a core::num::Wrapping<usize> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a f32 as ops::inv::Inv>::inv":["#[inline]\nfn inv(self) -> f32{\n        1.0 / *self\n    }","Real(LocalPath(\"src/ops/inv.rs\"))"],"<&'a f64 as ops::inv::Inv>::inv":["#[inline]\nfn inv(self) -> f64{\n        1.0 / *self\n    }","Real(LocalPath(\"src/ops/inv.rs\"))"],"<&'a i128 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i128 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i128 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i128 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i16 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i16 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i16 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i16 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i32 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i32 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i32 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i32 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i64 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i64 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i64 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i64 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i8 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i8 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i8 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a i8 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a isize as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a isize as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a isize as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a isize as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u128 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u128 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u128 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u128 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u16 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u16 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u16 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u16 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u32 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u32 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u32 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u32 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u64 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u64 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u64 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u64 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u8 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u8 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u8 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a u8 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a usize as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a usize as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a usize as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'a usize as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<i128> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<i128> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<i16> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<i16> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<i32> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<i32> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<i64> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<i64> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<i8> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<i8> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<isize> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<isize> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<u128> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<u128> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<u16> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<u16> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<u32> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<u32> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<u64> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<u64> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<u8> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<u8> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<usize> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b core::num::Wrapping<usize> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i128 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i128 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i128 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i128 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i16 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i16 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i16 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i16 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i32 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i32 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i32 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i32 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i64 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i64 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i64 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i64 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i8 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i8 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i8 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b i8 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b isize as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b isize as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b isize as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b isize as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u128 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u128 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u128 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u128 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u16 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u16 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u16 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u16 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u32 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u32 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u32 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u32 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u64 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u64 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u64 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u64 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u8 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u8 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u8 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b u8 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b usize as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b usize as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b usize as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<&'b usize as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<() as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<() as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(O, P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(O, P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(P, Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(P, Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(Q, R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(Q, R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(R, S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(R, S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(S, T) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(S, T) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(T,) as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> Self{\n                ($($name::max_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<(T,) as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> Self{\n                ($($name::min_value(),)*)\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<ParseFloatError as core::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let description = match self.kind {\n            FloatErrorKind::Empty => \"cannot parse float from empty string\",\n            FloatErrorKind::Invalid => \"invalid float literal\",\n        };\n\n        description.fmt(f)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<T as bounds::LowerBounded>::min_value":["fn min_value() -> T{\n        Bounded::min_value()\n    }","Real(LocalPath(\"src/bounds.rs\"))"],"<T as bounds::UpperBounded>::max_value":["fn max_value() -> T{\n        Bounded::max_value()\n    }","Real(LocalPath(\"src/bounds.rs\"))"],"<T as real::Real>::abs":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::abs_sub":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::acos":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::acosh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::asin":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::asinh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::atan":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::atan2":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::atanh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::cbrt":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::ceil":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::cos":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::cosh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::epsilon":["#[inline]\nfn $method( $( $arg : $ty ),* ) -> $ret{\n                <Self as $base>::$method( $( $arg ),* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::exp":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::exp2":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::exp_m1":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::floor":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::fract":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::hypot":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::is_sign_negative":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::is_sign_positive":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::ln":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::ln_1p":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::log":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::log10":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::log2":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::max":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::max_value":["#[inline]\nfn $method( $( $arg : $ty ),* ) -> $ret{\n                <Self as $base>::$method( $( $arg ),* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::min":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::min_positive_value":["#[inline]\nfn $method( $( $arg : $ty ),* ) -> $ret{\n                <Self as $base>::$method( $( $arg ),* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::min_value":["#[inline]\nfn $method( $( $arg : $ty ),* ) -> $ret{\n                <Self as $base>::$method( $( $arg ),* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::mul_add":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::powf":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::powi":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::recip":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::round":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::signum":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::sin":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::sin_cos":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::sinh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::sqrt":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::tan":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::tanh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::to_degrees":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::to_radians":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<T as real::Real>::trunc":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                <Self as $base>::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<bool as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<bool as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<bool as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<bool as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<bool as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<bool as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<bool as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<bool as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<bool as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<bool as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<bool as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<bool as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<char>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<char as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as Num>::from_str_radix":["fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr>{\n        T::from_str_radix(str, radix).map(Wrapping)\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<core::num::Wrapping<T> as bounds::Bounded>::max_value":["fn max_value() -> Self{\n        Wrapping(T::max_value())\n    }","Real(LocalPath(\"src/bounds.rs\"))"],"<core::num::Wrapping<T> as bounds::Bounded>::min_value":["fn min_value() -> Self{\n        Wrapping(T::min_value())\n    }","Real(LocalPath(\"src/bounds.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_f32":["#[inline]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_f64":["#[inline]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i128":["#[inline]\n#[$cfg]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i16":["#[inline]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i32":["#[inline]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i64":["#[inline]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i8":["#[inline]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_isize":["#[inline]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u128":["#[inline]\n#[$cfg]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u16":["#[inline]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u32":["#[inline]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u64":["#[inline]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u8":["#[inline]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_usize":["#[inline]\nfn $method(n: $i) -> Option<Self>{\n            T::$method(n).map(Wrapping)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::NumCast>::from":["fn from<U: ToPrimitive>(n: U) -> Option<Self>{\n        T::from(n).map(Wrapping)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_f32":["#[inline]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_f64":["#[inline]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$i>{\n            (self.0).$method()\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<core::num::Wrapping<T> as identities::One>::one":["fn one() -> Self{\n        Wrapping(T::one())\n    }","Real(LocalPath(\"src/identities.rs\"))"],"<core::num::Wrapping<T> as identities::One>::set_one":["fn set_one(&mut self){\n        self.0.set_one();\n    }","Real(LocalPath(\"src/identities.rs\"))"],"<core::num::Wrapping<T> as identities::Zero>::is_zero":["fn is_zero(&self) -> bool{\n        self.0.is_zero()\n    }","Real(LocalPath(\"src/identities.rs\"))"],"<core::num::Wrapping<T> as identities::Zero>::set_zero":["fn set_zero(&mut self){\n        self.0.set_zero();\n    }","Real(LocalPath(\"src/identities.rs\"))"],"<core::num::Wrapping<T> as identities::Zero>::zero":["fn zero() -> Self{\n        Wrapping(T::zero())\n    }","Real(LocalPath(\"src/identities.rs\"))"],"<core::num::Wrapping<T> as ops::wrapping::WrappingAdd>::wrapping_add":["fn wrapping_add(&self, v: &Self) -> Self{\n        Wrapping(self.0.wrapping_add(&v.0))\n    }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<core::num::Wrapping<T> as ops::wrapping::WrappingMul>::wrapping_mul":["fn wrapping_mul(&self, v: &Self) -> Self{\n        Wrapping(self.0.wrapping_mul(&v.0))\n    }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<core::num::Wrapping<T> as ops::wrapping::WrappingNeg>::wrapping_neg":["fn wrapping_neg(&self) -> Self{\n        Wrapping(self.0.wrapping_neg())\n    }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<core::num::Wrapping<T> as ops::wrapping::WrappingShl>::wrapping_shl":["fn wrapping_shl(&self, rhs: u32) -> Self{\n        Wrapping(self.0.wrapping_shl(rhs))\n    }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<core::num::Wrapping<T> as ops::wrapping::WrappingShr>::wrapping_shr":["fn wrapping_shr(&self, rhs: u32) -> Self{\n        Wrapping(self.0.wrapping_shr(rhs))\n    }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<core::num::Wrapping<T> as ops::wrapping::WrappingSub>::wrapping_sub":["fn wrapping_sub(&self, v: &Self) -> Self{\n        Wrapping(self.0.wrapping_sub(&v.0))\n    }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<core::num::Wrapping<T> as sign::Signed>::abs":["#[inline]\nfn abs(&self) -> Self{\n        Wrapping(self.0.abs())\n    }","Real(LocalPath(\"src/sign.rs\"))"],"<core::num::Wrapping<T> as sign::Signed>::abs_sub":["#[inline]\nfn abs_sub(&self, other: &Self) -> Self{\n        Wrapping(self.0.abs_sub(&other.0))\n    }","Real(LocalPath(\"src/sign.rs\"))"],"<core::num::Wrapping<T> as sign::Signed>::is_negative":["#[inline]\nfn is_negative(&self) -> bool{\n        self.0.is_negative()\n    }","Real(LocalPath(\"src/sign.rs\"))"],"<core::num::Wrapping<T> as sign::Signed>::is_positive":["#[inline]\nfn is_positive(&self) -> bool{\n        self.0.is_positive()\n    }","Real(LocalPath(\"src/sign.rs\"))"],"<core::num::Wrapping<T> as sign::Signed>::signum":["#[inline]\nfn signum(&self) -> Self{\n        Wrapping(self.0.signum())\n    }","Real(LocalPath(\"src/sign.rs\"))"],"<core::num::Wrapping<i128> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i128> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i128> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i128> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i16> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i16> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i16> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i16> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i32> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i32> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i32> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i32> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i64> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i64> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i64> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i64> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i8> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i8> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i8> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<i8> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<isize> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<isize> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<isize> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<isize> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u128> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u128> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u128> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u128> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u16> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u16> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u16> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u16> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u32> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u32> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u32> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u32> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u64> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u64> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u64> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u64> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u8> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u8> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u8> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<u8> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<usize> as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<usize> as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<usize> as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<core::num::Wrapping<usize> as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<f32 as Num>::from_str_radix":["fn from_str_radix(src: &str, radix: u32)\n                              -> Result<Self, Self::FromStrRadixErr>{\n                use self::FloatErrorKind::*;\n                use self::ParseFloatError as PFE;\n\n                // Special case radix 10 to use more accurate standard library implementation\n                if radix == 10 {\n                    return src.parse().map_err(|_| PFE {\n                        kind: if src.is_empty() { Empty } else { Invalid },\n                    });\n                }\n\n                // Special values\n                if str_to_ascii_lower_eq_str(src, \"inf\")\n                    || str_to_ascii_lower_eq_str(src, \"infinity\")\n                {\n                    return Ok(core::$t::INFINITY);\n                } else if str_to_ascii_lower_eq_str(src, \"-inf\")\n                    || str_to_ascii_lower_eq_str(src, \"-infinity\")\n                {\n                    return Ok(core::$t::NEG_INFINITY);\n                } else if str_to_ascii_lower_eq_str(src, \"nan\") {\n                    return Ok(core::$t::NAN);\n                } else if str_to_ascii_lower_eq_str(src, \"-nan\") {\n                    return Ok(-core::$t::NAN);\n                }\n\n                fn slice_shift_char(src: &str) -> Option<(char, &str)> {\n                    let mut chars = src.chars();\n                    if let Some(ch) = chars.next() {\n                        Some((ch, chars.as_str()))\n                    } else {\n                        None\n                    }\n                }\n\n                let (is_positive, src) =  match slice_shift_char(src) {\n                    None             => return Err(PFE { kind: Empty }),\n                    Some(('-', \"\"))  => return Err(PFE { kind: Empty }),\n                    Some(('-', src)) => (false, src),\n                    Some((_, _))     => (true,  src),\n                };\n\n                // The significand to accumulate\n                let mut sig = if is_positive { 0.0 } else { -0.0 };\n                // Necessary to detect overflow\n                let mut prev_sig = sig;\n                let mut cs = src.chars().enumerate();\n                // Exponent prefix and exponent index offset\n                let mut exp_info = None::<(char, usize)>;\n\n                // Parse the integer part of the significand\n                for (i, c) in cs.by_ref() {\n                    match c.to_digit(radix) {\n                        Some(digit) => {\n                            // shift significand one digit left\n                            sig = sig * (radix as $t);\n\n                            // add/subtract current digit depending on sign\n                            if is_positive {\n                                sig = sig + ((digit as isize) as $t);\n                            } else {\n                                sig = sig - ((digit as isize) as $t);\n                            }\n\n                            // Detect overflow by comparing to last value, except\n                            // if we've not seen any non-zero digits.\n                            if prev_sig != 0.0 {\n                                if is_positive && sig <= prev_sig\n                                    { return Ok(core::$t::INFINITY); }\n                                if !is_positive && sig >= prev_sig\n                                    { return Ok(core::$t::NEG_INFINITY); }\n\n                                // Detect overflow by reversing the shift-and-add process\n                                if is_positive && (prev_sig != (sig - digit as $t) / radix as $t)\n                                    { return Ok(core::$t::INFINITY); }\n                                if !is_positive && (prev_sig != (sig + digit as $t) / radix as $t)\n                                    { return Ok(core::$t::NEG_INFINITY); }\n                            }\n                            prev_sig = sig;\n                        },\n                        None => match c {\n                            'e' | 'E' | 'p' | 'P' => {\n                                exp_info = Some((c, i + 1));\n                                break;  // start of exponent\n                            },\n                            '.' => {\n                                break;  // start of fractional part\n                            },\n                            _ => {\n                                return Err(PFE { kind: Invalid });\n                            },\n                        },\n                    }\n                }\n\n                // If we are not yet at the exponent parse the fractional\n                // part of the significand\n                if exp_info.is_none() {\n                    let mut power = 1.0;\n                    for (i, c) in cs.by_ref() {\n                        match c.to_digit(radix) {\n                            Some(digit) => {\n                                // Decrease power one order of magnitude\n                                power = power / (radix as $t);\n                                // add/subtract current digit depending on sign\n                                sig = if is_positive {\n                                    sig + (digit as $t) * power\n                                } else {\n                                    sig - (digit as $t) * power\n                                };\n                                // Detect overflow by comparing to last value\n                                if is_positive && sig < prev_sig\n                                    { return Ok(core::$t::INFINITY); }\n                                if !is_positive && sig > prev_sig\n                                    { return Ok(core::$t::NEG_INFINITY); }\n                                prev_sig = sig;\n                            },\n                            None => match c {\n                                'e' | 'E' | 'p' | 'P' => {\n                                    exp_info = Some((c, i + 1));\n                                    break; // start of exponent\n                                },\n                                _ => {\n                                    return Err(PFE { kind: Invalid });\n                                },\n                            },\n                        }\n                    }\n                }\n\n                // Parse and calculate the exponent\n                let exp = match exp_info {\n                    Some((c, offset)) => {\n                        let base = match c {\n                            'E' | 'e' if radix == 10 => 10.0,\n                            'P' | 'p' if radix == 16 => 2.0,\n                            _ => return Err(PFE { kind: Invalid }),\n                        };\n\n                        // Parse the exponent as decimal integer\n                        let src = &src[offset..];\n                        let (is_positive, exp) = match slice_shift_char(src) {\n                            Some(('-', src)) => (false, src.parse::<usize>()),\n                            Some(('+', src)) => (true,  src.parse::<usize>()),\n                            Some((_, _))     => (true,  src.parse::<usize>()),\n                            None             => return Err(PFE { kind: Invalid }),\n                        };\n\n                        #[cfg(feature = \"std\")]\n                        fn pow(base: $t, exp: usize) -> $t {\n                            Float::powi(base, exp as i32)\n                        }\n                        // otherwise uses the generic `pow` from the root\n\n                        match (is_positive, exp) {\n                            (true,  Ok(exp)) => pow(base, exp),\n                            (false, Ok(exp)) => 1.0 / pow(base, exp),\n                            (_, Err(_))      => return Err(PFE { kind: Invalid }),\n                        }\n                    },\n                    None => 1.0, // no exponent\n                };\n\n                Ok(sig * exp)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<f32 as Num>::from_str_radix::pow":["#[cfg(feature = \"std\")]\nfn pow(base: $t, exp: usize) -> $t{\n                            Float::powi(base, exp as i32)\n                        }","Real(LocalPath(\"src/lib.rs\"))"],"<f32 as Num>::from_str_radix::slice_shift_char":["fn slice_shift_char(src: &str) -> Option<(char, &str)>{\n                    let mut chars = src.chars();\n                    if let Some(ch) = chars.next() {\n                        Some((ch, chars.as_str()))\n                    } else {\n                        None\n                    }\n                }","Real(LocalPath(\"src/lib.rs\"))"],"<f32 as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<f32 as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<f32 as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_f32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            // We can safely cast all values, whether NaN, +-inf, or finite.\n            // Finite values that are reducing size may saturate to +-inf.\n            Some(*self as $DstT)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_f64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            // We can safely cast all values, whether NaN, +-inf, or finite.\n            // Finite values that are reducing size may saturate to +-inf.\n            Some(*self as $DstT)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$i>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(MIN-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$i>() {\n                // With a larger size, we can represent the range exactly.\n                const MIN_M1: $f = $i::MIN as $f - 1.0;\n                const MAX_P1: $f = $i::MAX as $f + 1.0;\n                if *self > MIN_M1 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            } else {\n                // We can't represent `MIN-1` exactly, but there's no fractional part\n                // at this magnitude, so we can just use a `MIN` inclusive boundary.\n                const MIN: $f = $i::MIN as $f;\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                const MAX_P1: $f = $i::MAX as $f;\n                if *self >= MIN && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$i>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(MIN-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$i>() {\n                // With a larger size, we can represent the range exactly.\n                const MIN_M1: $f = $i::MIN as $f - 1.0;\n                const MAX_P1: $f = $i::MAX as $f + 1.0;\n                if *self > MIN_M1 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            } else {\n                // We can't represent `MIN-1` exactly, but there's no fractional part\n                // at this magnitude, so we can just use a `MIN` inclusive boundary.\n                const MIN: $f = $i::MIN as $f;\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                const MAX_P1: $f = $i::MAX as $f;\n                if *self >= MIN && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$i>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(MIN-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$i>() {\n                // With a larger size, we can represent the range exactly.\n                const MIN_M1: $f = $i::MIN as $f - 1.0;\n                const MAX_P1: $f = $i::MAX as $f + 1.0;\n                if *self > MIN_M1 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            } else {\n                // We can't represent `MIN-1` exactly, but there's no fractional part\n                // at this magnitude, so we can just use a `MIN` inclusive boundary.\n                const MIN: $f = $i::MIN as $f;\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                const MAX_P1: $f = $i::MAX as $f;\n                if *self >= MIN && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$i>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(MIN-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$i>() {\n                // With a larger size, we can represent the range exactly.\n                const MIN_M1: $f = $i::MIN as $f - 1.0;\n                const MAX_P1: $f = $i::MAX as $f + 1.0;\n                if *self > MIN_M1 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            } else {\n                // We can't represent `MIN-1` exactly, but there's no fractional part\n                // at this magnitude, so we can just use a `MIN` inclusive boundary.\n                const MIN: $f = $i::MIN as $f;\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                const MAX_P1: $f = $i::MAX as $f;\n                if *self >= MIN && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$i>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(MIN-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$i>() {\n                // With a larger size, we can represent the range exactly.\n                const MIN_M1: $f = $i::MIN as $f - 1.0;\n                const MAX_P1: $f = $i::MAX as $f + 1.0;\n                if *self > MIN_M1 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            } else {\n                // We can't represent `MIN-1` exactly, but there's no fractional part\n                // at this magnitude, so we can just use a `MIN` inclusive boundary.\n                const MIN: $f = $i::MIN as $f;\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                const MAX_P1: $f = $i::MAX as $f;\n                if *self >= MIN && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$i>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(MIN-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$i>() {\n                // With a larger size, we can represent the range exactly.\n                const MIN_M1: $f = $i::MIN as $f - 1.0;\n                const MAX_P1: $f = $i::MAX as $f + 1.0;\n                if *self > MIN_M1 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            } else {\n                // We can't represent `MIN-1` exactly, but there's no fractional part\n                // at this magnitude, so we can just use a `MIN` inclusive boundary.\n                const MIN: $f = $i::MIN as $f;\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                const MAX_P1: $f = $i::MAX as $f;\n                if *self >= MIN && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$u>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$u>() {\n                // With a larger size, we can represent the range exactly.\n                const MAX_P1: $f = $u::MAX as $f + 1.0;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            } else {\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                // (`u128::MAX as f32` is infinity, but this is still ok.)\n                const MAX_P1: $f = $u::MAX as $f;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$u>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$u>() {\n                // With a larger size, we can represent the range exactly.\n                const MAX_P1: $f = $u::MAX as $f + 1.0;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            } else {\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                // (`u128::MAX as f32` is infinity, but this is still ok.)\n                const MAX_P1: $f = $u::MAX as $f;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$u>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$u>() {\n                // With a larger size, we can represent the range exactly.\n                const MAX_P1: $f = $u::MAX as $f + 1.0;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            } else {\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                // (`u128::MAX as f32` is infinity, but this is still ok.)\n                const MAX_P1: $f = $u::MAX as $f;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$u>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$u>() {\n                // With a larger size, we can represent the range exactly.\n                const MAX_P1: $f = $u::MAX as $f + 1.0;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            } else {\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                // (`u128::MAX as f32` is infinity, but this is still ok.)\n                const MAX_P1: $f = $u::MAX as $f;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$u>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$u>() {\n                // With a larger size, we can represent the range exactly.\n                const MAX_P1: $f = $u::MAX as $f + 1.0;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            } else {\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                // (`u128::MAX as f32` is infinity, but this is still ok.)\n                const MAX_P1: $f = $u::MAX as $f;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$u>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$u>() {\n                // With a larger size, we can represent the range exactly.\n                const MAX_P1: $f = $u::MAX as $f + 1.0;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            } else {\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                // (`u128::MAX as f32` is infinity, but this is still ok.)\n                const MAX_P1: $f = $u::MAX as $f;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f32 as float::Float>::abs":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::abs_sub":["#[inline]\n#[allow(deprecated)]\nfn abs_sub(self, other: Self) -> Self{\n                <$T>::abs_sub(self, other)\n            }","Real(LocalPath(\"src/float.rs\"))"],"<f32 as float::Float>::acos":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::acosh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::asin":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::asinh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::atan":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::atan2":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::atanh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::cbrt":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::ceil":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::classify":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::copysign":["#[cfg(has_copysign)]\n#[inline]\nfn copysign(self, sign: Self) -> Self{\n                Self::copysign(self, sign)\n            }","Real(LocalPath(\"src/float.rs\"))"],"<f32 as float::Float>::cos":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::cosh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::epsilon":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::exp":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::exp2":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::exp_m1":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::floor":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::fract":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::hypot":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::infinity":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::integer_decode":["#[inline]\nfn integer_decode(self) -> (u64, i16, i8){\n                $decode(self)\n            }","Real(LocalPath(\"src/float.rs\"))"],"<f32 as float::Float>::is_finite":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::is_infinite":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::is_nan":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::is_normal":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::is_sign_negative":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::is_sign_positive":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::ln":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::ln_1p":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::log":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::log10":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::log2":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::max":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::max_value":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::min":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::min_positive_value":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::min_value":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::mul_add":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::nan":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::neg_infinity":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::neg_zero":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::powf":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::powi":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::recip":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::round":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::signum":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::sin":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::sin_cos":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::sinh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::sqrt":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::tan":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::tanh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::to_degrees":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::to_radians":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::Float>::trunc":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::E":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::FRAC_1_PI":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::FRAC_1_SQRT_2":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::FRAC_2_PI":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::FRAC_2_SQRT_PI":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::FRAC_PI_2":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::FRAC_PI_3":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::FRAC_PI_4":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::FRAC_PI_6":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::FRAC_PI_8":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::LN_10":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::LN_2":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::LOG10_2":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::LOG10_E":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::LOG2_10":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::LOG2_E":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::PI":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::SQRT_2":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatConst>::TAU":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::abs":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::ceil":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::classify":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::epsilon":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::floor":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::fract":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::infinity":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::integer_decode":["#[inline]\nfn integer_decode(self) -> (u64, i16, i8){\n        integer_decode_f32(self)\n    }","Real(LocalPath(\"src/float.rs\"))"],"<f32 as float::FloatCore>::is_finite":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::is_infinite":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::is_nan":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::is_normal":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::is_sign_negative":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::is_sign_positive":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::max":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::max_value":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::min":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::min_positive_value":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::min_value":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::nan":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::neg_infinity":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::neg_zero":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::powi":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::recip":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::round":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::signum":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::to_degrees":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::to_radians":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as float::FloatCore>::trunc":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f32 as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<f32 as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<f32 as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<f32 as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<f32 as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<f32 as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<f32 as ops::inv::Inv>::inv":["#[inline]\nfn inv(self) -> f32{\n        1.0 / self\n    }","Real(LocalPath(\"src/ops/inv.rs\"))"],"<f32 as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n        <Self as ::Float>::mul_add(self, a, b)\n    }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<f32 as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n        *self = <Self as ::Float>::mul_add(*self, a, b)\n    }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<f32 as sign::Signed>::abs":["/// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n#[inline]\nfn abs(&self) -> $t{\n                FloatCore::abs(*self)\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<f32 as sign::Signed>::abs_sub":["/// The positive difference of two numbers. Returns `0.0` if the number is\n/// less than or equal to `other`, otherwise the difference between`self`\n/// and `other` is returned.\n#[inline]\nfn abs_sub(&self, other: &$t) -> $t{\n                if *self <= *other {\n                    0.\n                } else {\n                    *self - *other\n                }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<f32 as sign::Signed>::is_negative":["/// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n#[inline]\nfn is_negative(&self) -> bool{\n                FloatCore::is_sign_negative(*self)\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<f32 as sign::Signed>::is_positive":["/// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n#[inline]\nfn is_positive(&self) -> bool{\n                FloatCore::is_sign_positive(*self)\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<f32 as sign::Signed>::signum":["/// # Returns\n///\n/// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n/// - `NAN` if the number is NaN\n#[inline]\nfn signum(&self) -> $t{\n                FloatCore::signum(*self)\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<f64 as Num>::from_str_radix":["fn from_str_radix(src: &str, radix: u32)\n                              -> Result<Self, Self::FromStrRadixErr>{\n                use self::FloatErrorKind::*;\n                use self::ParseFloatError as PFE;\n\n                // Special case radix 10 to use more accurate standard library implementation\n                if radix == 10 {\n                    return src.parse().map_err(|_| PFE {\n                        kind: if src.is_empty() { Empty } else { Invalid },\n                    });\n                }\n\n                // Special values\n                if str_to_ascii_lower_eq_str(src, \"inf\")\n                    || str_to_ascii_lower_eq_str(src, \"infinity\")\n                {\n                    return Ok(core::$t::INFINITY);\n                } else if str_to_ascii_lower_eq_str(src, \"-inf\")\n                    || str_to_ascii_lower_eq_str(src, \"-infinity\")\n                {\n                    return Ok(core::$t::NEG_INFINITY);\n                } else if str_to_ascii_lower_eq_str(src, \"nan\") {\n                    return Ok(core::$t::NAN);\n                } else if str_to_ascii_lower_eq_str(src, \"-nan\") {\n                    return Ok(-core::$t::NAN);\n                }\n\n                fn slice_shift_char(src: &str) -> Option<(char, &str)> {\n                    let mut chars = src.chars();\n                    if let Some(ch) = chars.next() {\n                        Some((ch, chars.as_str()))\n                    } else {\n                        None\n                    }\n                }\n\n                let (is_positive, src) =  match slice_shift_char(src) {\n                    None             => return Err(PFE { kind: Empty }),\n                    Some(('-', \"\"))  => return Err(PFE { kind: Empty }),\n                    Some(('-', src)) => (false, src),\n                    Some((_, _))     => (true,  src),\n                };\n\n                // The significand to accumulate\n                let mut sig = if is_positive { 0.0 } else { -0.0 };\n                // Necessary to detect overflow\n                let mut prev_sig = sig;\n                let mut cs = src.chars().enumerate();\n                // Exponent prefix and exponent index offset\n                let mut exp_info = None::<(char, usize)>;\n\n                // Parse the integer part of the significand\n                for (i, c) in cs.by_ref() {\n                    match c.to_digit(radix) {\n                        Some(digit) => {\n                            // shift significand one digit left\n                            sig = sig * (radix as $t);\n\n                            // add/subtract current digit depending on sign\n                            if is_positive {\n                                sig = sig + ((digit as isize) as $t);\n                            } else {\n                                sig = sig - ((digit as isize) as $t);\n                            }\n\n                            // Detect overflow by comparing to last value, except\n                            // if we've not seen any non-zero digits.\n                            if prev_sig != 0.0 {\n                                if is_positive && sig <= prev_sig\n                                    { return Ok(core::$t::INFINITY); }\n                                if !is_positive && sig >= prev_sig\n                                    { return Ok(core::$t::NEG_INFINITY); }\n\n                                // Detect overflow by reversing the shift-and-add process\n                                if is_positive && (prev_sig != (sig - digit as $t) / radix as $t)\n                                    { return Ok(core::$t::INFINITY); }\n                                if !is_positive && (prev_sig != (sig + digit as $t) / radix as $t)\n                                    { return Ok(core::$t::NEG_INFINITY); }\n                            }\n                            prev_sig = sig;\n                        },\n                        None => match c {\n                            'e' | 'E' | 'p' | 'P' => {\n                                exp_info = Some((c, i + 1));\n                                break;  // start of exponent\n                            },\n                            '.' => {\n                                break;  // start of fractional part\n                            },\n                            _ => {\n                                return Err(PFE { kind: Invalid });\n                            },\n                        },\n                    }\n                }\n\n                // If we are not yet at the exponent parse the fractional\n                // part of the significand\n                if exp_info.is_none() {\n                    let mut power = 1.0;\n                    for (i, c) in cs.by_ref() {\n                        match c.to_digit(radix) {\n                            Some(digit) => {\n                                // Decrease power one order of magnitude\n                                power = power / (radix as $t);\n                                // add/subtract current digit depending on sign\n                                sig = if is_positive {\n                                    sig + (digit as $t) * power\n                                } else {\n                                    sig - (digit as $t) * power\n                                };\n                                // Detect overflow by comparing to last value\n                                if is_positive && sig < prev_sig\n                                    { return Ok(core::$t::INFINITY); }\n                                if !is_positive && sig > prev_sig\n                                    { return Ok(core::$t::NEG_INFINITY); }\n                                prev_sig = sig;\n                            },\n                            None => match c {\n                                'e' | 'E' | 'p' | 'P' => {\n                                    exp_info = Some((c, i + 1));\n                                    break; // start of exponent\n                                },\n                                _ => {\n                                    return Err(PFE { kind: Invalid });\n                                },\n                            },\n                        }\n                    }\n                }\n\n                // Parse and calculate the exponent\n                let exp = match exp_info {\n                    Some((c, offset)) => {\n                        let base = match c {\n                            'E' | 'e' if radix == 10 => 10.0,\n                            'P' | 'p' if radix == 16 => 2.0,\n                            _ => return Err(PFE { kind: Invalid }),\n                        };\n\n                        // Parse the exponent as decimal integer\n                        let src = &src[offset..];\n                        let (is_positive, exp) = match slice_shift_char(src) {\n                            Some(('-', src)) => (false, src.parse::<usize>()),\n                            Some(('+', src)) => (true,  src.parse::<usize>()),\n                            Some((_, _))     => (true,  src.parse::<usize>()),\n                            None             => return Err(PFE { kind: Invalid }),\n                        };\n\n                        #[cfg(feature = \"std\")]\n                        fn pow(base: $t, exp: usize) -> $t {\n                            Float::powi(base, exp as i32)\n                        }\n                        // otherwise uses the generic `pow` from the root\n\n                        match (is_positive, exp) {\n                            (true,  Ok(exp)) => pow(base, exp),\n                            (false, Ok(exp)) => 1.0 / pow(base, exp),\n                            (_, Err(_))      => return Err(PFE { kind: Invalid }),\n                        }\n                    },\n                    None => 1.0, // no exponent\n                };\n\n                Ok(sig * exp)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<f64 as Num>::from_str_radix::pow":["#[cfg(feature = \"std\")]\nfn pow(base: $t, exp: usize) -> $t{\n                            Float::powi(base, exp as i32)\n                        }","Real(LocalPath(\"src/lib.rs\"))"],"<f64 as Num>::from_str_radix::slice_shift_char":["fn slice_shift_char(src: &str) -> Option<(char, &str)>{\n                    let mut chars = src.chars();\n                    if let Some(ch) = chars.next() {\n                        Some((ch, chars.as_str()))\n                    } else {\n                        None\n                    }\n                }","Real(LocalPath(\"src/lib.rs\"))"],"<f64 as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<f64 as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<f64 as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_f32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            // We can safely cast all values, whether NaN, +-inf, or finite.\n            // Finite values that are reducing size may saturate to +-inf.\n            Some(*self as $DstT)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_f64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            // We can safely cast all values, whether NaN, +-inf, or finite.\n            // Finite values that are reducing size may saturate to +-inf.\n            Some(*self as $DstT)\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$i>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(MIN-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$i>() {\n                // With a larger size, we can represent the range exactly.\n                const MIN_M1: $f = $i::MIN as $f - 1.0;\n                const MAX_P1: $f = $i::MAX as $f + 1.0;\n                if *self > MIN_M1 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            } else {\n                // We can't represent `MIN-1` exactly, but there's no fractional part\n                // at this magnitude, so we can just use a `MIN` inclusive boundary.\n                const MIN: $f = $i::MIN as $f;\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                const MAX_P1: $f = $i::MAX as $f;\n                if *self >= MIN && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$i>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(MIN-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$i>() {\n                // With a larger size, we can represent the range exactly.\n                const MIN_M1: $f = $i::MIN as $f - 1.0;\n                const MAX_P1: $f = $i::MAX as $f + 1.0;\n                if *self > MIN_M1 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            } else {\n                // We can't represent `MIN-1` exactly, but there's no fractional part\n                // at this magnitude, so we can just use a `MIN` inclusive boundary.\n                const MIN: $f = $i::MIN as $f;\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                const MAX_P1: $f = $i::MAX as $f;\n                if *self >= MIN && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$i>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(MIN-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$i>() {\n                // With a larger size, we can represent the range exactly.\n                const MIN_M1: $f = $i::MIN as $f - 1.0;\n                const MAX_P1: $f = $i::MAX as $f + 1.0;\n                if *self > MIN_M1 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            } else {\n                // We can't represent `MIN-1` exactly, but there's no fractional part\n                // at this magnitude, so we can just use a `MIN` inclusive boundary.\n                const MIN: $f = $i::MIN as $f;\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                const MAX_P1: $f = $i::MAX as $f;\n                if *self >= MIN && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$i>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(MIN-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$i>() {\n                // With a larger size, we can represent the range exactly.\n                const MIN_M1: $f = $i::MIN as $f - 1.0;\n                const MAX_P1: $f = $i::MAX as $f + 1.0;\n                if *self > MIN_M1 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            } else {\n                // We can't represent `MIN-1` exactly, but there's no fractional part\n                // at this magnitude, so we can just use a `MIN` inclusive boundary.\n                const MIN: $f = $i::MIN as $f;\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                const MAX_P1: $f = $i::MAX as $f;\n                if *self >= MIN && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$i>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(MIN-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$i>() {\n                // With a larger size, we can represent the range exactly.\n                const MIN_M1: $f = $i::MIN as $f - 1.0;\n                const MAX_P1: $f = $i::MAX as $f + 1.0;\n                if *self > MIN_M1 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            } else {\n                // We can't represent `MIN-1` exactly, but there's no fractional part\n                // at this magnitude, so we can just use a `MIN` inclusive boundary.\n                const MIN: $f = $i::MIN as $f;\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                const MAX_P1: $f = $i::MAX as $f;\n                if *self >= MIN && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$i>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(MIN-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$i>() {\n                // With a larger size, we can represent the range exactly.\n                const MIN_M1: $f = $i::MIN as $f - 1.0;\n                const MAX_P1: $f = $i::MAX as $f + 1.0;\n                if *self > MIN_M1 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            } else {\n                // We can't represent `MIN-1` exactly, but there's no fractional part\n                // at this magnitude, so we can just use a `MIN` inclusive boundary.\n                const MIN: $f = $i::MIN as $f;\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                const MAX_P1: $f = $i::MAX as $f;\n                if *self >= MIN && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $i));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$u>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$u>() {\n                // With a larger size, we can represent the range exactly.\n                const MAX_P1: $f = $u::MAX as $f + 1.0;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            } else {\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                // (`u128::MAX as f32` is infinity, but this is still ok.)\n                const MAX_P1: $f = $u::MAX as $f;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$u>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$u>() {\n                // With a larger size, we can represent the range exactly.\n                const MAX_P1: $f = $u::MAX as $f + 1.0;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            } else {\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                // (`u128::MAX as f32` is infinity, but this is still ok.)\n                const MAX_P1: $f = $u::MAX as $f;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$u>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$u>() {\n                // With a larger size, we can represent the range exactly.\n                const MAX_P1: $f = $u::MAX as $f + 1.0;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            } else {\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                // (`u128::MAX as f32` is infinity, but this is still ok.)\n                const MAX_P1: $f = $u::MAX as $f;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$u>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$u>() {\n                // With a larger size, we can represent the range exactly.\n                const MAX_P1: $f = $u::MAX as $f + 1.0;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            } else {\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                // (`u128::MAX as f32` is infinity, but this is still ok.)\n                const MAX_P1: $f = $u::MAX as $f;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$u>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$u>() {\n                // With a larger size, we can represent the range exactly.\n                const MAX_P1: $f = $u::MAX as $f + 1.0;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            } else {\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                // (`u128::MAX as f32` is infinity, but this is still ok.)\n                const MAX_P1: $f = $u::MAX as $f;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$u>{\n            // Float as int truncates toward zero, so we want to allow values\n            // in the exclusive range `(-1, MAX+1)`.\n            if size_of::<$f>() > size_of::<$u>() {\n                // With a larger size, we can represent the range exactly.\n                const MAX_P1: $f = $u::MAX as $f + 1.0;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            } else {\n                // We can't represent `MAX` exactly, but it will round up to exactly\n                // `MAX+1` (a power of two) when we cast it.\n                // (`u128::MAX as f32` is infinity, but this is still ok.)\n                const MAX_P1: $f = $u::MAX as $f;\n                if *self > -1.0 && *self < MAX_P1 {\n                    return Some(float_to_int_unchecked!(*self => $u));\n                }\n            }\n            None\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<f64 as float::Float>::abs":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::abs_sub":["#[inline]\n#[allow(deprecated)]\nfn abs_sub(self, other: Self) -> Self{\n                <$T>::abs_sub(self, other)\n            }","Real(LocalPath(\"src/float.rs\"))"],"<f64 as float::Float>::acos":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::acosh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::asin":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::asinh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::atan":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::atan2":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::atanh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::cbrt":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::ceil":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::classify":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::copysign":["#[cfg(has_copysign)]\n#[inline]\nfn copysign(self, sign: Self) -> Self{\n                Self::copysign(self, sign)\n            }","Real(LocalPath(\"src/float.rs\"))"],"<f64 as float::Float>::cos":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::cosh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::epsilon":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::exp":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::exp2":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::exp_m1":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::floor":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::fract":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::hypot":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::infinity":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::integer_decode":["#[inline]\nfn integer_decode(self) -> (u64, i16, i8){\n                $decode(self)\n            }","Real(LocalPath(\"src/float.rs\"))"],"<f64 as float::Float>::is_finite":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::is_infinite":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::is_nan":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::is_normal":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::is_sign_negative":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::is_sign_positive":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::ln":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::ln_1p":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::log":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::log10":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::log2":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::max":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::max_value":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::min":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::min_positive_value":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::min_value":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::mul_add":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::nan":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::neg_infinity":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::neg_zero":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::powf":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::powi":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::recip":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::round":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::signum":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::sin":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::sin_cos":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::sinh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::sqrt":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::tan":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::tanh":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::to_degrees":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::to_radians":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::Float>::trunc":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::E":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::FRAC_1_PI":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::FRAC_1_SQRT_2":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::FRAC_2_PI":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::FRAC_2_SQRT_PI":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::FRAC_PI_2":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::FRAC_PI_3":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::FRAC_PI_4":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::FRAC_PI_6":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::FRAC_PI_8":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::LN_10":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::LN_2":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::LOG10_2":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::LOG10_E":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::LOG2_10":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::LOG2_E":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::PI":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::SQRT_2":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatConst>::TAU":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::abs":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::ceil":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::classify":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::epsilon":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::floor":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::fract":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::infinity":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::integer_decode":["#[inline]\nfn integer_decode(self) -> (u64, i16, i8){\n        integer_decode_f64(self)\n    }","Real(LocalPath(\"src/float.rs\"))"],"<f64 as float::FloatCore>::is_finite":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::is_infinite":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::is_nan":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::is_normal":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::is_sign_negative":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::is_sign_positive":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::max":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::max_value":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::min":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::min_positive_value":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::min_value":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::nan":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::neg_infinity":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::neg_zero":["#[inline]\nfn $method() -> Self{\n                $ret\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::powi":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::recip":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::round":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::signum":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::to_degrees":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::to_radians":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as float::FloatCore>::trunc":["#[inline]\nfn $method(self $( , $arg : $ty )* ) -> $ret{\n                Self::$method(self $( , $arg )* )\n            }","Real(LocalPath(\"src/macros.rs\"))"],"<f64 as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<f64 as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<f64 as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<f64 as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<f64 as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<f64 as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<f64 as ops::inv::Inv>::inv":["#[inline]\nfn inv(self) -> f64{\n        1.0 / self\n    }","Real(LocalPath(\"src/ops/inv.rs\"))"],"<f64 as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n        <Self as ::Float>::mul_add(self, a, b)\n    }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<f64 as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n        *self = <Self as ::Float>::mul_add(*self, a, b)\n    }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<f64 as sign::Signed>::abs":["/// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n#[inline]\nfn abs(&self) -> $t{\n                FloatCore::abs(*self)\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<f64 as sign::Signed>::abs_sub":["/// The positive difference of two numbers. Returns `0.0` if the number is\n/// less than or equal to `other`, otherwise the difference between`self`\n/// and `other` is returned.\n#[inline]\nfn abs_sub(&self, other: &$t) -> $t{\n                if *self <= *other {\n                    0.\n                } else {\n                    *self - *other\n                }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<f64 as sign::Signed>::is_negative":["/// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n#[inline]\nfn is_negative(&self) -> bool{\n                FloatCore::is_sign_negative(*self)\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<f64 as sign::Signed>::is_positive":["/// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n#[inline]\nfn is_positive(&self) -> bool{\n                FloatCore::is_sign_positive(*self)\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<f64 as sign::Signed>::signum":["/// # Returns\n///\n/// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n/// - `NAN` if the number is NaN\n#[inline]\nfn signum(&self) -> $t{\n                FloatCore::signum(*self)\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i128 as Num>::from_str_radix":["#[inline]\nfn from_str_radix(s: &str, radix: u32)\n                              -> Result<Self, ::core::num::ParseIntError>{\n                <$t>::from_str_radix(s, radix)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<i128 as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<i128 as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<i128 as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_f32":["#[inline]\nfn to_f32(&self) -> Option<f32>{\n                Some(*self as f32)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_f64":["#[inline]\nfn to_f64(&self) -> Option<f64>{\n                Some(*self as f64)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i128 as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i128 as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i128 as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i128 as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i128 as int::PrimInt>::count_ones":["#[inline]\nfn count_ones(self) -> u32{\n                <$T>::count_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::count_zeros":["#[inline]\nfn count_zeros(self) -> u32{\n                <$T>::count_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::from_be":["#[inline]\nfn from_be(x: Self) -> Self{\n                <$T>::from_be(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::from_le":["#[inline]\nfn from_le(x: Self) -> Self{\n                <$T>::from_le(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::leading_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn leading_ones(self) -> u32{\n                <$T>::leading_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::leading_zeros":["#[inline]\nfn leading_zeros(self) -> u32{\n                <$T>::leading_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::pow":["#[inline]\nfn pow(self, exp: u32) -> Self{\n                <$T>::pow(self, exp)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::reverse_bits":["#[cfg(has_reverse_bits)]\n#[inline]\nfn reverse_bits(self) -> Self{\n                <$T>::reverse_bits(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::rotate_left":["#[inline]\nfn rotate_left(self, n: u32) -> Self{\n                <$T>::rotate_left(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::rotate_right":["#[inline]\nfn rotate_right(self, n: u32) -> Self{\n                <$T>::rotate_right(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::signed_shl":["#[inline]\nfn signed_shl(self, n: u32) -> Self{\n                ((self as $S) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::signed_shr":["#[inline]\nfn signed_shr(self, n: u32) -> Self{\n                ((self as $S) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::swap_bytes":["#[inline]\nfn swap_bytes(self) -> Self{\n                <$T>::swap_bytes(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::to_be":["#[inline]\nfn to_be(self) -> Self{\n                <$T>::to_be(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::to_le":["#[inline]\nfn to_le(self) -> Self{\n                <$T>::to_le(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::trailing_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn trailing_ones(self) -> u32{\n                <$T>::trailing_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::trailing_zeros":["#[inline]\nfn trailing_zeros(self) -> u32{\n                <$T>::trailing_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::unsigned_shl":["#[inline]\nfn unsigned_shl(self, n: u32) -> Self{\n                ((self as $U) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as int::PrimInt>::unsigned_shr":["#[inline]\nfn unsigned_shr(self, n: u32) -> Self{\n                ((self as $U) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i128 as ops::checked::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i128 as ops::checked::CheckedDiv>::checked_div":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i128 as ops::checked::CheckedMul>::checked_mul":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i128 as ops::checked::CheckedNeg>::checked_neg":["#[inline]\nfn $method(&self) -> Option<$t>{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i128 as ops::checked::CheckedRem>::checked_rem":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i128 as ops::checked::CheckedShl>::checked_shl":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i128 as ops::checked::CheckedShr>::checked_shr":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i128 as ops::checked::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i128 as ops::euclid::CheckedEuclid>::checked_div_euclid":["#[inline]\nfn checked_div_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i128 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["#[inline]\nfn checked_rem_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i128 as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i128 as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i128 as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n                (self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<i128 as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n                *self = (*self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<i128 as ops::overflowing::OverflowingAdd>::overflowing_add":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i128 as ops::overflowing::OverflowingMul>::overflowing_mul":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i128 as ops::overflowing::OverflowingSub>::overflowing_sub":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i128 as ops::saturating::Saturating>::saturating_add":["#[inline]\nfn saturating_add(self, v: Self) -> Self{\n                Self::saturating_add(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i128 as ops::saturating::Saturating>::saturating_sub":["#[inline]\nfn saturating_sub(self, v: Self) -> Self{\n                Self::saturating_sub(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i128 as ops::saturating::SaturatingAdd>::saturating_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i128 as ops::saturating::SaturatingMul>::saturating_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i128 as ops::saturating::SaturatingSub>::saturating_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i128 as ops::wrapping::WrappingAdd>::wrapping_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i128 as ops::wrapping::WrappingMul>::wrapping_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i128 as ops::wrapping::WrappingNeg>::wrapping_neg":["#[inline]\nfn $method(&self) -> $t{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i128 as ops::wrapping::WrappingShl>::wrapping_shl":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i128 as ops::wrapping::WrappingShr>::wrapping_shr":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i128 as ops::wrapping::WrappingSub>::wrapping_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i128 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i128 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i128 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i128 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i128 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i128 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i128 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i128 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i128 as sign::Signed>::abs":["#[inline]\nfn abs(&self) -> $t{\n                if self.is_negative() { -*self } else { *self }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i128 as sign::Signed>::abs_sub":["#[inline]\nfn abs_sub(&self, other: &$t) -> $t{\n                if *self <= *other { 0 } else { *self - *other }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i128 as sign::Signed>::is_negative":["#[inline]\nfn is_negative(&self) -> bool{ *self < 0 }","Real(LocalPath(\"src/sign.rs\"))"],"<i128 as sign::Signed>::is_positive":["#[inline]\nfn is_positive(&self) -> bool{ *self > 0 }","Real(LocalPath(\"src/sign.rs\"))"],"<i128 as sign::Signed>::signum":["#[inline]\nfn signum(&self) -> $t{\n                match *self {\n                    n if n > 0 => 1,\n                    0 => 0,\n                    _ => -1,\n                }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i16 as Num>::from_str_radix":["#[inline]\nfn from_str_radix(s: &str, radix: u32)\n                              -> Result<Self, ::core::num::ParseIntError>{\n                <$t>::from_str_radix(s, radix)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<i16 as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<i16 as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<i16 as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_f32":["#[inline]\nfn to_f32(&self) -> Option<f32>{\n                Some(*self as f32)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_f64":["#[inline]\nfn to_f64(&self) -> Option<f64>{\n                Some(*self as f64)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i16 as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i16 as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i16 as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i16 as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i16 as int::PrimInt>::count_ones":["#[inline]\nfn count_ones(self) -> u32{\n                <$T>::count_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::count_zeros":["#[inline]\nfn count_zeros(self) -> u32{\n                <$T>::count_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::from_be":["#[inline]\nfn from_be(x: Self) -> Self{\n                <$T>::from_be(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::from_le":["#[inline]\nfn from_le(x: Self) -> Self{\n                <$T>::from_le(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::leading_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn leading_ones(self) -> u32{\n                <$T>::leading_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::leading_zeros":["#[inline]\nfn leading_zeros(self) -> u32{\n                <$T>::leading_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::pow":["#[inline]\nfn pow(self, exp: u32) -> Self{\n                <$T>::pow(self, exp)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::reverse_bits":["#[cfg(has_reverse_bits)]\n#[inline]\nfn reverse_bits(self) -> Self{\n                <$T>::reverse_bits(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::rotate_left":["#[inline]\nfn rotate_left(self, n: u32) -> Self{\n                <$T>::rotate_left(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::rotate_right":["#[inline]\nfn rotate_right(self, n: u32) -> Self{\n                <$T>::rotate_right(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::signed_shl":["#[inline]\nfn signed_shl(self, n: u32) -> Self{\n                ((self as $S) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::signed_shr":["#[inline]\nfn signed_shr(self, n: u32) -> Self{\n                ((self as $S) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::swap_bytes":["#[inline]\nfn swap_bytes(self) -> Self{\n                <$T>::swap_bytes(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::to_be":["#[inline]\nfn to_be(self) -> Self{\n                <$T>::to_be(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::to_le":["#[inline]\nfn to_le(self) -> Self{\n                <$T>::to_le(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::trailing_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn trailing_ones(self) -> u32{\n                <$T>::trailing_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::trailing_zeros":["#[inline]\nfn trailing_zeros(self) -> u32{\n                <$T>::trailing_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::unsigned_shl":["#[inline]\nfn unsigned_shl(self, n: u32) -> Self{\n                ((self as $U) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as int::PrimInt>::unsigned_shr":["#[inline]\nfn unsigned_shr(self, n: u32) -> Self{\n                ((self as $U) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i16 as ops::checked::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i16 as ops::checked::CheckedDiv>::checked_div":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i16 as ops::checked::CheckedMul>::checked_mul":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i16 as ops::checked::CheckedNeg>::checked_neg":["#[inline]\nfn $method(&self) -> Option<$t>{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i16 as ops::checked::CheckedRem>::checked_rem":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i16 as ops::checked::CheckedShl>::checked_shl":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i16 as ops::checked::CheckedShr>::checked_shr":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i16 as ops::checked::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i16 as ops::euclid::CheckedEuclid>::checked_div_euclid":["#[inline]\nfn checked_div_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i16 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["#[inline]\nfn checked_rem_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i16 as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i16 as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i16 as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n                (self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<i16 as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n                *self = (*self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<i16 as ops::overflowing::OverflowingAdd>::overflowing_add":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i16 as ops::overflowing::OverflowingMul>::overflowing_mul":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i16 as ops::overflowing::OverflowingSub>::overflowing_sub":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i16 as ops::saturating::Saturating>::saturating_add":["#[inline]\nfn saturating_add(self, v: Self) -> Self{\n                Self::saturating_add(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i16 as ops::saturating::Saturating>::saturating_sub":["#[inline]\nfn saturating_sub(self, v: Self) -> Self{\n                Self::saturating_sub(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i16 as ops::saturating::SaturatingAdd>::saturating_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i16 as ops::saturating::SaturatingMul>::saturating_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i16 as ops::saturating::SaturatingSub>::saturating_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i16 as ops::wrapping::WrappingAdd>::wrapping_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i16 as ops::wrapping::WrappingMul>::wrapping_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i16 as ops::wrapping::WrappingNeg>::wrapping_neg":["#[inline]\nfn $method(&self) -> $t{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i16 as ops::wrapping::WrappingShl>::wrapping_shl":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i16 as ops::wrapping::WrappingShr>::wrapping_shr":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i16 as ops::wrapping::WrappingSub>::wrapping_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i16 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i16 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i16 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i16 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i16 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i16 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i16 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i16 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i16 as sign::Signed>::abs":["#[inline]\nfn abs(&self) -> $t{\n                if self.is_negative() { -*self } else { *self }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i16 as sign::Signed>::abs_sub":["#[inline]\nfn abs_sub(&self, other: &$t) -> $t{\n                if *self <= *other { 0 } else { *self - *other }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i16 as sign::Signed>::is_negative":["#[inline]\nfn is_negative(&self) -> bool{ *self < 0 }","Real(LocalPath(\"src/sign.rs\"))"],"<i16 as sign::Signed>::is_positive":["#[inline]\nfn is_positive(&self) -> bool{ *self > 0 }","Real(LocalPath(\"src/sign.rs\"))"],"<i16 as sign::Signed>::signum":["#[inline]\nfn signum(&self) -> $t{\n                match *self {\n                    n if n > 0 => 1,\n                    0 => 0,\n                    _ => -1,\n                }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i32 as Num>::from_str_radix":["#[inline]\nfn from_str_radix(s: &str, radix: u32)\n                              -> Result<Self, ::core::num::ParseIntError>{\n                <$t>::from_str_radix(s, radix)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<i32 as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<i32 as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<i32 as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_f32":["#[inline]\nfn to_f32(&self) -> Option<f32>{\n                Some(*self as f32)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_f64":["#[inline]\nfn to_f64(&self) -> Option<f64>{\n                Some(*self as f64)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i32 as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i32 as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i32 as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i32 as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i32 as int::PrimInt>::count_ones":["#[inline]\nfn count_ones(self) -> u32{\n                <$T>::count_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::count_zeros":["#[inline]\nfn count_zeros(self) -> u32{\n                <$T>::count_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::from_be":["#[inline]\nfn from_be(x: Self) -> Self{\n                <$T>::from_be(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::from_le":["#[inline]\nfn from_le(x: Self) -> Self{\n                <$T>::from_le(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::leading_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn leading_ones(self) -> u32{\n                <$T>::leading_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::leading_zeros":["#[inline]\nfn leading_zeros(self) -> u32{\n                <$T>::leading_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::pow":["#[inline]\nfn pow(self, exp: u32) -> Self{\n                <$T>::pow(self, exp)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::reverse_bits":["#[cfg(has_reverse_bits)]\n#[inline]\nfn reverse_bits(self) -> Self{\n                <$T>::reverse_bits(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::rotate_left":["#[inline]\nfn rotate_left(self, n: u32) -> Self{\n                <$T>::rotate_left(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::rotate_right":["#[inline]\nfn rotate_right(self, n: u32) -> Self{\n                <$T>::rotate_right(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::signed_shl":["#[inline]\nfn signed_shl(self, n: u32) -> Self{\n                ((self as $S) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::signed_shr":["#[inline]\nfn signed_shr(self, n: u32) -> Self{\n                ((self as $S) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::swap_bytes":["#[inline]\nfn swap_bytes(self) -> Self{\n                <$T>::swap_bytes(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::to_be":["#[inline]\nfn to_be(self) -> Self{\n                <$T>::to_be(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::to_le":["#[inline]\nfn to_le(self) -> Self{\n                <$T>::to_le(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::trailing_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn trailing_ones(self) -> u32{\n                <$T>::trailing_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::trailing_zeros":["#[inline]\nfn trailing_zeros(self) -> u32{\n                <$T>::trailing_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::unsigned_shl":["#[inline]\nfn unsigned_shl(self, n: u32) -> Self{\n                ((self as $U) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as int::PrimInt>::unsigned_shr":["#[inline]\nfn unsigned_shr(self, n: u32) -> Self{\n                ((self as $U) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i32 as ops::checked::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i32 as ops::checked::CheckedDiv>::checked_div":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i32 as ops::checked::CheckedMul>::checked_mul":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i32 as ops::checked::CheckedNeg>::checked_neg":["#[inline]\nfn $method(&self) -> Option<$t>{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i32 as ops::checked::CheckedRem>::checked_rem":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i32 as ops::checked::CheckedShl>::checked_shl":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i32 as ops::checked::CheckedShr>::checked_shr":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i32 as ops::checked::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i32 as ops::euclid::CheckedEuclid>::checked_div_euclid":["#[inline]\nfn checked_div_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i32 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["#[inline]\nfn checked_rem_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i32 as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i32 as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i32 as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n                (self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<i32 as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n                *self = (*self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<i32 as ops::overflowing::OverflowingAdd>::overflowing_add":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i32 as ops::overflowing::OverflowingMul>::overflowing_mul":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i32 as ops::overflowing::OverflowingSub>::overflowing_sub":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i32 as ops::saturating::Saturating>::saturating_add":["#[inline]\nfn saturating_add(self, v: Self) -> Self{\n                Self::saturating_add(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i32 as ops::saturating::Saturating>::saturating_sub":["#[inline]\nfn saturating_sub(self, v: Self) -> Self{\n                Self::saturating_sub(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i32 as ops::saturating::SaturatingAdd>::saturating_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i32 as ops::saturating::SaturatingMul>::saturating_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i32 as ops::saturating::SaturatingSub>::saturating_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i32 as ops::wrapping::WrappingAdd>::wrapping_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i32 as ops::wrapping::WrappingMul>::wrapping_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i32 as ops::wrapping::WrappingNeg>::wrapping_neg":["#[inline]\nfn $method(&self) -> $t{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i32 as ops::wrapping::WrappingShl>::wrapping_shl":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i32 as ops::wrapping::WrappingShr>::wrapping_shr":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i32 as ops::wrapping::WrappingSub>::wrapping_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i32 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i32 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i32 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i32 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i32 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i32 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i32 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i32 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i32 as sign::Signed>::abs":["#[inline]\nfn abs(&self) -> $t{\n                if self.is_negative() { -*self } else { *self }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i32 as sign::Signed>::abs_sub":["#[inline]\nfn abs_sub(&self, other: &$t) -> $t{\n                if *self <= *other { 0 } else { *self - *other }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i32 as sign::Signed>::is_negative":["#[inline]\nfn is_negative(&self) -> bool{ *self < 0 }","Real(LocalPath(\"src/sign.rs\"))"],"<i32 as sign::Signed>::is_positive":["#[inline]\nfn is_positive(&self) -> bool{ *self > 0 }","Real(LocalPath(\"src/sign.rs\"))"],"<i32 as sign::Signed>::signum":["#[inline]\nfn signum(&self) -> $t{\n                match *self {\n                    n if n > 0 => 1,\n                    0 => 0,\n                    _ => -1,\n                }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i64 as Num>::from_str_radix":["#[inline]\nfn from_str_radix(s: &str, radix: u32)\n                              -> Result<Self, ::core::num::ParseIntError>{\n                <$t>::from_str_radix(s, radix)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<i64 as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<i64 as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<i64 as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_f32":["#[inline]\nfn to_f32(&self) -> Option<f32>{\n                Some(*self as f32)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_f64":["#[inline]\nfn to_f64(&self) -> Option<f64>{\n                Some(*self as f64)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i64 as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i64 as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i64 as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i64 as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i64 as int::PrimInt>::count_ones":["#[inline]\nfn count_ones(self) -> u32{\n                <$T>::count_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::count_zeros":["#[inline]\nfn count_zeros(self) -> u32{\n                <$T>::count_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::from_be":["#[inline]\nfn from_be(x: Self) -> Self{\n                <$T>::from_be(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::from_le":["#[inline]\nfn from_le(x: Self) -> Self{\n                <$T>::from_le(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::leading_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn leading_ones(self) -> u32{\n                <$T>::leading_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::leading_zeros":["#[inline]\nfn leading_zeros(self) -> u32{\n                <$T>::leading_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::pow":["#[inline]\nfn pow(self, exp: u32) -> Self{\n                <$T>::pow(self, exp)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::reverse_bits":["#[cfg(has_reverse_bits)]\n#[inline]\nfn reverse_bits(self) -> Self{\n                <$T>::reverse_bits(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::rotate_left":["#[inline]\nfn rotate_left(self, n: u32) -> Self{\n                <$T>::rotate_left(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::rotate_right":["#[inline]\nfn rotate_right(self, n: u32) -> Self{\n                <$T>::rotate_right(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::signed_shl":["#[inline]\nfn signed_shl(self, n: u32) -> Self{\n                ((self as $S) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::signed_shr":["#[inline]\nfn signed_shr(self, n: u32) -> Self{\n                ((self as $S) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::swap_bytes":["#[inline]\nfn swap_bytes(self) -> Self{\n                <$T>::swap_bytes(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::to_be":["#[inline]\nfn to_be(self) -> Self{\n                <$T>::to_be(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::to_le":["#[inline]\nfn to_le(self) -> Self{\n                <$T>::to_le(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::trailing_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn trailing_ones(self) -> u32{\n                <$T>::trailing_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::trailing_zeros":["#[inline]\nfn trailing_zeros(self) -> u32{\n                <$T>::trailing_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::unsigned_shl":["#[inline]\nfn unsigned_shl(self, n: u32) -> Self{\n                ((self as $U) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as int::PrimInt>::unsigned_shr":["#[inline]\nfn unsigned_shr(self, n: u32) -> Self{\n                ((self as $U) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i64 as ops::checked::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i64 as ops::checked::CheckedDiv>::checked_div":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i64 as ops::checked::CheckedMul>::checked_mul":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i64 as ops::checked::CheckedNeg>::checked_neg":["#[inline]\nfn $method(&self) -> Option<$t>{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i64 as ops::checked::CheckedRem>::checked_rem":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i64 as ops::checked::CheckedShl>::checked_shl":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i64 as ops::checked::CheckedShr>::checked_shr":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i64 as ops::checked::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i64 as ops::euclid::CheckedEuclid>::checked_div_euclid":["#[inline]\nfn checked_div_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i64 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["#[inline]\nfn checked_rem_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i64 as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i64 as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i64 as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n                (self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<i64 as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n                *self = (*self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<i64 as ops::overflowing::OverflowingAdd>::overflowing_add":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i64 as ops::overflowing::OverflowingMul>::overflowing_mul":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i64 as ops::overflowing::OverflowingSub>::overflowing_sub":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i64 as ops::saturating::Saturating>::saturating_add":["#[inline]\nfn saturating_add(self, v: Self) -> Self{\n                Self::saturating_add(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i64 as ops::saturating::Saturating>::saturating_sub":["#[inline]\nfn saturating_sub(self, v: Self) -> Self{\n                Self::saturating_sub(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i64 as ops::saturating::SaturatingAdd>::saturating_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i64 as ops::saturating::SaturatingMul>::saturating_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i64 as ops::saturating::SaturatingSub>::saturating_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i64 as ops::wrapping::WrappingAdd>::wrapping_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i64 as ops::wrapping::WrappingMul>::wrapping_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i64 as ops::wrapping::WrappingNeg>::wrapping_neg":["#[inline]\nfn $method(&self) -> $t{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i64 as ops::wrapping::WrappingShl>::wrapping_shl":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i64 as ops::wrapping::WrappingShr>::wrapping_shr":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i64 as ops::wrapping::WrappingSub>::wrapping_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i64 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i64 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i64 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i64 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i64 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i64 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i64 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i64 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i64 as sign::Signed>::abs":["#[inline]\nfn abs(&self) -> $t{\n                if self.is_negative() { -*self } else { *self }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i64 as sign::Signed>::abs_sub":["#[inline]\nfn abs_sub(&self, other: &$t) -> $t{\n                if *self <= *other { 0 } else { *self - *other }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i64 as sign::Signed>::is_negative":["#[inline]\nfn is_negative(&self) -> bool{ *self < 0 }","Real(LocalPath(\"src/sign.rs\"))"],"<i64 as sign::Signed>::is_positive":["#[inline]\nfn is_positive(&self) -> bool{ *self > 0 }","Real(LocalPath(\"src/sign.rs\"))"],"<i64 as sign::Signed>::signum":["#[inline]\nfn signum(&self) -> $t{\n                match *self {\n                    n if n > 0 => 1,\n                    0 => 0,\n                    _ => -1,\n                }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i8 as Num>::from_str_radix":["#[inline]\nfn from_str_radix(s: &str, radix: u32)\n                              -> Result<Self, ::core::num::ParseIntError>{\n                <$t>::from_str_radix(s, radix)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<i8 as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<i8 as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<i8 as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_f32":["#[inline]\nfn to_f32(&self) -> Option<f32>{\n                Some(*self as f32)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_f64":["#[inline]\nfn to_f64(&self) -> Option<f64>{\n                Some(*self as f64)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<i8 as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i8 as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i8 as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i8 as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<i8 as int::PrimInt>::count_ones":["#[inline]\nfn count_ones(self) -> u32{\n                <$T>::count_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::count_zeros":["#[inline]\nfn count_zeros(self) -> u32{\n                <$T>::count_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::from_be":["#[inline]\nfn from_be(x: Self) -> Self{\n                <$T>::from_be(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::from_le":["#[inline]\nfn from_le(x: Self) -> Self{\n                <$T>::from_le(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::leading_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn leading_ones(self) -> u32{\n                <$T>::leading_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::leading_zeros":["#[inline]\nfn leading_zeros(self) -> u32{\n                <$T>::leading_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::pow":["#[inline]\nfn pow(self, exp: u32) -> Self{\n                <$T>::pow(self, exp)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::reverse_bits":["#[cfg(has_reverse_bits)]\n#[inline]\nfn reverse_bits(self) -> Self{\n                <$T>::reverse_bits(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::rotate_left":["#[inline]\nfn rotate_left(self, n: u32) -> Self{\n                <$T>::rotate_left(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::rotate_right":["#[inline]\nfn rotate_right(self, n: u32) -> Self{\n                <$T>::rotate_right(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::signed_shl":["#[inline]\nfn signed_shl(self, n: u32) -> Self{\n                ((self as $S) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::signed_shr":["#[inline]\nfn signed_shr(self, n: u32) -> Self{\n                ((self as $S) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::swap_bytes":["#[inline]\nfn swap_bytes(self) -> Self{\n                <$T>::swap_bytes(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::to_be":["#[inline]\nfn to_be(self) -> Self{\n                <$T>::to_be(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::to_le":["#[inline]\nfn to_le(self) -> Self{\n                <$T>::to_le(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::trailing_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn trailing_ones(self) -> u32{\n                <$T>::trailing_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::trailing_zeros":["#[inline]\nfn trailing_zeros(self) -> u32{\n                <$T>::trailing_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::unsigned_shl":["#[inline]\nfn unsigned_shl(self, n: u32) -> Self{\n                ((self as $U) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as int::PrimInt>::unsigned_shr":["#[inline]\nfn unsigned_shr(self, n: u32) -> Self{\n                ((self as $U) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<i8 as ops::checked::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i8 as ops::checked::CheckedDiv>::checked_div":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i8 as ops::checked::CheckedMul>::checked_mul":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i8 as ops::checked::CheckedNeg>::checked_neg":["#[inline]\nfn $method(&self) -> Option<$t>{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i8 as ops::checked::CheckedRem>::checked_rem":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i8 as ops::checked::CheckedShl>::checked_shl":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i8 as ops::checked::CheckedShr>::checked_shr":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i8 as ops::checked::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<i8 as ops::euclid::CheckedEuclid>::checked_div_euclid":["#[inline]\nfn checked_div_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i8 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["#[inline]\nfn checked_rem_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i8 as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i8 as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<i8 as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n                (self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<i8 as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n                *self = (*self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<i8 as ops::overflowing::OverflowingAdd>::overflowing_add":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i8 as ops::overflowing::OverflowingMul>::overflowing_mul":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i8 as ops::overflowing::OverflowingSub>::overflowing_sub":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<i8 as ops::saturating::Saturating>::saturating_add":["#[inline]\nfn saturating_add(self, v: Self) -> Self{\n                Self::saturating_add(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i8 as ops::saturating::Saturating>::saturating_sub":["#[inline]\nfn saturating_sub(self, v: Self) -> Self{\n                Self::saturating_sub(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i8 as ops::saturating::SaturatingAdd>::saturating_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i8 as ops::saturating::SaturatingMul>::saturating_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i8 as ops::saturating::SaturatingSub>::saturating_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<i8 as ops::wrapping::WrappingAdd>::wrapping_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i8 as ops::wrapping::WrappingMul>::wrapping_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i8 as ops::wrapping::WrappingNeg>::wrapping_neg":["#[inline]\nfn $method(&self) -> $t{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i8 as ops::wrapping::WrappingShl>::wrapping_shl":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i8 as ops::wrapping::WrappingShr>::wrapping_shr":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i8 as ops::wrapping::WrappingSub>::wrapping_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<i8 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i8 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i8 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i8 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i8 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i8 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i8 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i8 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<i8 as sign::Signed>::abs":["#[inline]\nfn abs(&self) -> $t{\n                if self.is_negative() { -*self } else { *self }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i8 as sign::Signed>::abs_sub":["#[inline]\nfn abs_sub(&self, other: &$t) -> $t{\n                if *self <= *other { 0 } else { *self - *other }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<i8 as sign::Signed>::is_negative":["#[inline]\nfn is_negative(&self) -> bool{ *self < 0 }","Real(LocalPath(\"src/sign.rs\"))"],"<i8 as sign::Signed>::is_positive":["#[inline]\nfn is_positive(&self) -> bool{ *self > 0 }","Real(LocalPath(\"src/sign.rs\"))"],"<i8 as sign::Signed>::signum":["#[inline]\nfn signum(&self) -> $t{\n                match *self {\n                    n if n > 0 => 1,\n                    0 => 0,\n                    _ => -1,\n                }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<isize as Num>::from_str_radix":["#[inline]\nfn from_str_radix(s: &str, radix: u32)\n                              -> Result<Self, ::core::num::ParseIntError>{\n                <$t>::from_str_radix(s, radix)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<isize as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<isize as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<isize as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_f32":["#[inline]\nfn to_f32(&self) -> Option<f32>{\n                Some(*self as f32)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_f64":["#[inline]\nfn to_f64(&self) -> Option<f64>{\n                Some(*self as f64)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let min = $DstT::MIN as $SrcT;\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<isize as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<isize as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<isize as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<isize as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<isize as int::PrimInt>::count_ones":["#[inline]\nfn count_ones(self) -> u32{\n                <$T>::count_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::count_zeros":["#[inline]\nfn count_zeros(self) -> u32{\n                <$T>::count_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::from_be":["#[inline]\nfn from_be(x: Self) -> Self{\n                <$T>::from_be(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::from_le":["#[inline]\nfn from_le(x: Self) -> Self{\n                <$T>::from_le(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::leading_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn leading_ones(self) -> u32{\n                <$T>::leading_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::leading_zeros":["#[inline]\nfn leading_zeros(self) -> u32{\n                <$T>::leading_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::pow":["#[inline]\nfn pow(self, exp: u32) -> Self{\n                <$T>::pow(self, exp)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::reverse_bits":["#[cfg(has_reverse_bits)]\n#[inline]\nfn reverse_bits(self) -> Self{\n                <$T>::reverse_bits(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::rotate_left":["#[inline]\nfn rotate_left(self, n: u32) -> Self{\n                <$T>::rotate_left(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::rotate_right":["#[inline]\nfn rotate_right(self, n: u32) -> Self{\n                <$T>::rotate_right(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::signed_shl":["#[inline]\nfn signed_shl(self, n: u32) -> Self{\n                ((self as $S) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::signed_shr":["#[inline]\nfn signed_shr(self, n: u32) -> Self{\n                ((self as $S) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::swap_bytes":["#[inline]\nfn swap_bytes(self) -> Self{\n                <$T>::swap_bytes(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::to_be":["#[inline]\nfn to_be(self) -> Self{\n                <$T>::to_be(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::to_le":["#[inline]\nfn to_le(self) -> Self{\n                <$T>::to_le(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::trailing_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn trailing_ones(self) -> u32{\n                <$T>::trailing_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::trailing_zeros":["#[inline]\nfn trailing_zeros(self) -> u32{\n                <$T>::trailing_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::unsigned_shl":["#[inline]\nfn unsigned_shl(self, n: u32) -> Self{\n                ((self as $U) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as int::PrimInt>::unsigned_shr":["#[inline]\nfn unsigned_shr(self, n: u32) -> Self{\n                ((self as $U) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<isize as ops::checked::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<isize as ops::checked::CheckedDiv>::checked_div":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<isize as ops::checked::CheckedMul>::checked_mul":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<isize as ops::checked::CheckedNeg>::checked_neg":["#[inline]\nfn $method(&self) -> Option<$t>{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<isize as ops::checked::CheckedRem>::checked_rem":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<isize as ops::checked::CheckedShl>::checked_shl":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<isize as ops::checked::CheckedShr>::checked_shr":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<isize as ops::checked::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<isize as ops::euclid::CheckedEuclid>::checked_div_euclid":["#[inline]\nfn checked_div_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<isize as ops::euclid::CheckedEuclid>::checked_rem_euclid":["#[inline]\nfn checked_rem_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<isize as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<isize as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<isize as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n                (self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<isize as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n                *self = (*self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<isize as ops::overflowing::OverflowingAdd>::overflowing_add":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<isize as ops::overflowing::OverflowingMul>::overflowing_mul":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<isize as ops::overflowing::OverflowingSub>::overflowing_sub":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<isize as ops::saturating::Saturating>::saturating_add":["#[inline]\nfn saturating_add(self, v: Self) -> Self{\n                Self::saturating_add(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<isize as ops::saturating::Saturating>::saturating_sub":["#[inline]\nfn saturating_sub(self, v: Self) -> Self{\n                Self::saturating_sub(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<isize as ops::saturating::SaturatingAdd>::saturating_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<isize as ops::saturating::SaturatingMul>::saturating_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<isize as ops::saturating::SaturatingSub>::saturating_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<isize as ops::wrapping::WrappingAdd>::wrapping_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<isize as ops::wrapping::WrappingMul>::wrapping_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<isize as ops::wrapping::WrappingNeg>::wrapping_neg":["#[inline]\nfn $method(&self) -> $t{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<isize as ops::wrapping::WrappingShl>::wrapping_shl":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<isize as ops::wrapping::WrappingShr>::wrapping_shr":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<isize as ops::wrapping::WrappingSub>::wrapping_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<isize as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<isize as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<isize as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<isize as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<isize as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<isize as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<isize as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<isize as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<isize as sign::Signed>::abs":["#[inline]\nfn abs(&self) -> $t{\n                if self.is_negative() { -*self } else { *self }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<isize as sign::Signed>::abs_sub":["#[inline]\nfn abs_sub(&self, other: &$t) -> $t{\n                if *self <= *other { 0 } else { *self - *other }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<isize as sign::Signed>::is_negative":["#[inline]\nfn is_negative(&self) -> bool{ *self < 0 }","Real(LocalPath(\"src/sign.rs\"))"],"<isize as sign::Signed>::is_positive":["#[inline]\nfn is_positive(&self) -> bool{ *self > 0 }","Real(LocalPath(\"src/sign.rs\"))"],"<isize as sign::Signed>::signum":["#[inline]\nfn signum(&self) -> $t{\n                match *self {\n                    n if n > 0 => 1,\n                    0 => 0,\n                    _ => -1,\n                }\n            }","Real(LocalPath(\"src/sign.rs\"))"],"<u128 as Num>::from_str_radix":["#[inline]\nfn from_str_radix(s: &str, radix: u32)\n                              -> Result<Self, ::core::num::ParseIntError>{\n                <$t>::from_str_radix(s, radix)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<u128 as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<u128 as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<u128 as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_f32":["#[inline]\nfn to_f32(&self) -> Option<f32>{\n                Some(*self as f32)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_f64":["#[inline]\nfn to_f64(&self) -> Option<f64>{\n                Some(*self as f64)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u128 as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u128 as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u128 as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u128 as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u128 as int::PrimInt>::count_ones":["#[inline]\nfn count_ones(self) -> u32{\n                <$T>::count_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::count_zeros":["#[inline]\nfn count_zeros(self) -> u32{\n                <$T>::count_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::from_be":["#[inline]\nfn from_be(x: Self) -> Self{\n                <$T>::from_be(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::from_le":["#[inline]\nfn from_le(x: Self) -> Self{\n                <$T>::from_le(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::leading_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn leading_ones(self) -> u32{\n                <$T>::leading_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::leading_zeros":["#[inline]\nfn leading_zeros(self) -> u32{\n                <$T>::leading_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::pow":["#[inline]\nfn pow(self, exp: u32) -> Self{\n                <$T>::pow(self, exp)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::reverse_bits":["#[cfg(has_reverse_bits)]\n#[inline]\nfn reverse_bits(self) -> Self{\n                <$T>::reverse_bits(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::rotate_left":["#[inline]\nfn rotate_left(self, n: u32) -> Self{\n                <$T>::rotate_left(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::rotate_right":["#[inline]\nfn rotate_right(self, n: u32) -> Self{\n                <$T>::rotate_right(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::signed_shl":["#[inline]\nfn signed_shl(self, n: u32) -> Self{\n                ((self as $S) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::signed_shr":["#[inline]\nfn signed_shr(self, n: u32) -> Self{\n                ((self as $S) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::swap_bytes":["#[inline]\nfn swap_bytes(self) -> Self{\n                <$T>::swap_bytes(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::to_be":["#[inline]\nfn to_be(self) -> Self{\n                <$T>::to_be(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::to_le":["#[inline]\nfn to_le(self) -> Self{\n                <$T>::to_le(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::trailing_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn trailing_ones(self) -> u32{\n                <$T>::trailing_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::trailing_zeros":["#[inline]\nfn trailing_zeros(self) -> u32{\n                <$T>::trailing_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::unsigned_shl":["#[inline]\nfn unsigned_shl(self, n: u32) -> Self{\n                ((self as $U) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as int::PrimInt>::unsigned_shr":["#[inline]\nfn unsigned_shr(self, n: u32) -> Self{\n                ((self as $U) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u128 as ops::checked::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u128 as ops::checked::CheckedDiv>::checked_div":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u128 as ops::checked::CheckedMul>::checked_mul":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u128 as ops::checked::CheckedNeg>::checked_neg":["#[inline]\nfn $method(&self) -> Option<$t>{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u128 as ops::checked::CheckedRem>::checked_rem":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u128 as ops::checked::CheckedShl>::checked_shl":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u128 as ops::checked::CheckedShr>::checked_shr":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u128 as ops::checked::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u128 as ops::euclid::CheckedEuclid>::checked_div_euclid":["#[inline]\nfn checked_div_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u128 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["#[inline]\nfn checked_rem_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u128 as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u128 as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u128 as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n                (self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<u128 as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n                *self = (*self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<u128 as ops::overflowing::OverflowingAdd>::overflowing_add":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u128 as ops::overflowing::OverflowingMul>::overflowing_mul":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u128 as ops::overflowing::OverflowingSub>::overflowing_sub":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u128 as ops::saturating::Saturating>::saturating_add":["#[inline]\nfn saturating_add(self, v: Self) -> Self{\n                Self::saturating_add(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u128 as ops::saturating::Saturating>::saturating_sub":["#[inline]\nfn saturating_sub(self, v: Self) -> Self{\n                Self::saturating_sub(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u128 as ops::saturating::SaturatingAdd>::saturating_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u128 as ops::saturating::SaturatingMul>::saturating_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u128 as ops::saturating::SaturatingSub>::saturating_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u128 as ops::wrapping::WrappingAdd>::wrapping_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u128 as ops::wrapping::WrappingMul>::wrapping_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u128 as ops::wrapping::WrappingNeg>::wrapping_neg":["#[inline]\nfn $method(&self) -> $t{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u128 as ops::wrapping::WrappingShl>::wrapping_shl":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u128 as ops::wrapping::WrappingShr>::wrapping_shr":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u128 as ops::wrapping::WrappingSub>::wrapping_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u128 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u128 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u128 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u128 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u128 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u128 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u128 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u128 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u16 as Num>::from_str_radix":["#[inline]\nfn from_str_radix(s: &str, radix: u32)\n                              -> Result<Self, ::core::num::ParseIntError>{\n                <$t>::from_str_radix(s, radix)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<u16 as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<u16 as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<u16 as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_f32":["#[inline]\nfn to_f32(&self) -> Option<f32>{\n                Some(*self as f32)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_f64":["#[inline]\nfn to_f64(&self) -> Option<f64>{\n                Some(*self as f64)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u16 as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u16 as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u16 as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u16 as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u16 as int::PrimInt>::count_ones":["#[inline]\nfn count_ones(self) -> u32{\n                <$T>::count_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::count_zeros":["#[inline]\nfn count_zeros(self) -> u32{\n                <$T>::count_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::from_be":["#[inline]\nfn from_be(x: Self) -> Self{\n                <$T>::from_be(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::from_le":["#[inline]\nfn from_le(x: Self) -> Self{\n                <$T>::from_le(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::leading_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn leading_ones(self) -> u32{\n                <$T>::leading_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::leading_zeros":["#[inline]\nfn leading_zeros(self) -> u32{\n                <$T>::leading_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::pow":["#[inline]\nfn pow(self, exp: u32) -> Self{\n                <$T>::pow(self, exp)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::reverse_bits":["#[cfg(has_reverse_bits)]\n#[inline]\nfn reverse_bits(self) -> Self{\n                <$T>::reverse_bits(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::rotate_left":["#[inline]\nfn rotate_left(self, n: u32) -> Self{\n                <$T>::rotate_left(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::rotate_right":["#[inline]\nfn rotate_right(self, n: u32) -> Self{\n                <$T>::rotate_right(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::signed_shl":["#[inline]\nfn signed_shl(self, n: u32) -> Self{\n                ((self as $S) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::signed_shr":["#[inline]\nfn signed_shr(self, n: u32) -> Self{\n                ((self as $S) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::swap_bytes":["#[inline]\nfn swap_bytes(self) -> Self{\n                <$T>::swap_bytes(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::to_be":["#[inline]\nfn to_be(self) -> Self{\n                <$T>::to_be(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::to_le":["#[inline]\nfn to_le(self) -> Self{\n                <$T>::to_le(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::trailing_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn trailing_ones(self) -> u32{\n                <$T>::trailing_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::trailing_zeros":["#[inline]\nfn trailing_zeros(self) -> u32{\n                <$T>::trailing_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::unsigned_shl":["#[inline]\nfn unsigned_shl(self, n: u32) -> Self{\n                ((self as $U) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as int::PrimInt>::unsigned_shr":["#[inline]\nfn unsigned_shr(self, n: u32) -> Self{\n                ((self as $U) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u16 as ops::checked::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u16 as ops::checked::CheckedDiv>::checked_div":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u16 as ops::checked::CheckedMul>::checked_mul":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u16 as ops::checked::CheckedNeg>::checked_neg":["#[inline]\nfn $method(&self) -> Option<$t>{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u16 as ops::checked::CheckedRem>::checked_rem":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u16 as ops::checked::CheckedShl>::checked_shl":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u16 as ops::checked::CheckedShr>::checked_shr":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u16 as ops::checked::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u16 as ops::euclid::CheckedEuclid>::checked_div_euclid":["#[inline]\nfn checked_div_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u16 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["#[inline]\nfn checked_rem_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u16 as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u16 as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u16 as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n                (self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<u16 as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n                *self = (*self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<u16 as ops::overflowing::OverflowingAdd>::overflowing_add":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u16 as ops::overflowing::OverflowingMul>::overflowing_mul":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u16 as ops::overflowing::OverflowingSub>::overflowing_sub":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u16 as ops::saturating::Saturating>::saturating_add":["#[inline]\nfn saturating_add(self, v: Self) -> Self{\n                Self::saturating_add(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u16 as ops::saturating::Saturating>::saturating_sub":["#[inline]\nfn saturating_sub(self, v: Self) -> Self{\n                Self::saturating_sub(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u16 as ops::saturating::SaturatingAdd>::saturating_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u16 as ops::saturating::SaturatingMul>::saturating_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u16 as ops::saturating::SaturatingSub>::saturating_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u16 as ops::wrapping::WrappingAdd>::wrapping_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u16 as ops::wrapping::WrappingMul>::wrapping_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u16 as ops::wrapping::WrappingNeg>::wrapping_neg":["#[inline]\nfn $method(&self) -> $t{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u16 as ops::wrapping::WrappingShl>::wrapping_shl":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u16 as ops::wrapping::WrappingShr>::wrapping_shr":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u16 as ops::wrapping::WrappingSub>::wrapping_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u16 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u16 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u16 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u16 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u16 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u16 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u16 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u16 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u32 as Num>::from_str_radix":["#[inline]\nfn from_str_radix(s: &str, radix: u32)\n                              -> Result<Self, ::core::num::ParseIntError>{\n                <$t>::from_str_radix(s, radix)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<u32 as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<u32 as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<u32 as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_f32":["#[inline]\nfn to_f32(&self) -> Option<f32>{\n                Some(*self as f32)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_f64":["#[inline]\nfn to_f64(&self) -> Option<f64>{\n                Some(*self as f64)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u32 as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u32 as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u32 as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u32 as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u32 as int::PrimInt>::count_ones":["#[inline]\nfn count_ones(self) -> u32{\n                <$T>::count_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::count_zeros":["#[inline]\nfn count_zeros(self) -> u32{\n                <$T>::count_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::from_be":["#[inline]\nfn from_be(x: Self) -> Self{\n                <$T>::from_be(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::from_le":["#[inline]\nfn from_le(x: Self) -> Self{\n                <$T>::from_le(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::leading_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn leading_ones(self) -> u32{\n                <$T>::leading_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::leading_zeros":["#[inline]\nfn leading_zeros(self) -> u32{\n                <$T>::leading_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::pow":["#[inline]\nfn pow(self, exp: u32) -> Self{\n                <$T>::pow(self, exp)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::reverse_bits":["#[cfg(has_reverse_bits)]\n#[inline]\nfn reverse_bits(self) -> Self{\n                <$T>::reverse_bits(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::rotate_left":["#[inline]\nfn rotate_left(self, n: u32) -> Self{\n                <$T>::rotate_left(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::rotate_right":["#[inline]\nfn rotate_right(self, n: u32) -> Self{\n                <$T>::rotate_right(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::signed_shl":["#[inline]\nfn signed_shl(self, n: u32) -> Self{\n                ((self as $S) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::signed_shr":["#[inline]\nfn signed_shr(self, n: u32) -> Self{\n                ((self as $S) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::swap_bytes":["#[inline]\nfn swap_bytes(self) -> Self{\n                <$T>::swap_bytes(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::to_be":["#[inline]\nfn to_be(self) -> Self{\n                <$T>::to_be(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::to_le":["#[inline]\nfn to_le(self) -> Self{\n                <$T>::to_le(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::trailing_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn trailing_ones(self) -> u32{\n                <$T>::trailing_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::trailing_zeros":["#[inline]\nfn trailing_zeros(self) -> u32{\n                <$T>::trailing_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::unsigned_shl":["#[inline]\nfn unsigned_shl(self, n: u32) -> Self{\n                ((self as $U) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as int::PrimInt>::unsigned_shr":["#[inline]\nfn unsigned_shr(self, n: u32) -> Self{\n                ((self as $U) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u32 as ops::checked::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u32 as ops::checked::CheckedDiv>::checked_div":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u32 as ops::checked::CheckedMul>::checked_mul":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u32 as ops::checked::CheckedNeg>::checked_neg":["#[inline]\nfn $method(&self) -> Option<$t>{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u32 as ops::checked::CheckedRem>::checked_rem":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u32 as ops::checked::CheckedShl>::checked_shl":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u32 as ops::checked::CheckedShr>::checked_shr":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u32 as ops::checked::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u32 as ops::euclid::CheckedEuclid>::checked_div_euclid":["#[inline]\nfn checked_div_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u32 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["#[inline]\nfn checked_rem_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u32 as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u32 as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u32 as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n                (self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<u32 as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n                *self = (*self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<u32 as ops::overflowing::OverflowingAdd>::overflowing_add":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u32 as ops::overflowing::OverflowingMul>::overflowing_mul":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u32 as ops::overflowing::OverflowingSub>::overflowing_sub":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u32 as ops::saturating::Saturating>::saturating_add":["#[inline]\nfn saturating_add(self, v: Self) -> Self{\n                Self::saturating_add(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u32 as ops::saturating::Saturating>::saturating_sub":["#[inline]\nfn saturating_sub(self, v: Self) -> Self{\n                Self::saturating_sub(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u32 as ops::saturating::SaturatingAdd>::saturating_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u32 as ops::saturating::SaturatingMul>::saturating_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u32 as ops::saturating::SaturatingSub>::saturating_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u32 as ops::wrapping::WrappingAdd>::wrapping_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u32 as ops::wrapping::WrappingMul>::wrapping_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u32 as ops::wrapping::WrappingNeg>::wrapping_neg":["#[inline]\nfn $method(&self) -> $t{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u32 as ops::wrapping::WrappingShl>::wrapping_shl":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u32 as ops::wrapping::WrappingShr>::wrapping_shr":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u32 as ops::wrapping::WrappingSub>::wrapping_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u32 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u32 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u32 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u32 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u32 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u32 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u32 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u32 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u64 as Num>::from_str_radix":["#[inline]\nfn from_str_radix(s: &str, radix: u32)\n                              -> Result<Self, ::core::num::ParseIntError>{\n                <$t>::from_str_radix(s, radix)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<u64 as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<u64 as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<u64 as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_f32":["#[inline]\nfn to_f32(&self) -> Option<f32>{\n                Some(*self as f32)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_f64":["#[inline]\nfn to_f64(&self) -> Option<f64>{\n                Some(*self as f64)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u64 as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u64 as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u64 as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u64 as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u64 as int::PrimInt>::count_ones":["#[inline]\nfn count_ones(self) -> u32{\n                <$T>::count_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::count_zeros":["#[inline]\nfn count_zeros(self) -> u32{\n                <$T>::count_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::from_be":["#[inline]\nfn from_be(x: Self) -> Self{\n                <$T>::from_be(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::from_le":["#[inline]\nfn from_le(x: Self) -> Self{\n                <$T>::from_le(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::leading_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn leading_ones(self) -> u32{\n                <$T>::leading_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::leading_zeros":["#[inline]\nfn leading_zeros(self) -> u32{\n                <$T>::leading_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::pow":["#[inline]\nfn pow(self, exp: u32) -> Self{\n                <$T>::pow(self, exp)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::reverse_bits":["#[cfg(has_reverse_bits)]\n#[inline]\nfn reverse_bits(self) -> Self{\n                <$T>::reverse_bits(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::rotate_left":["#[inline]\nfn rotate_left(self, n: u32) -> Self{\n                <$T>::rotate_left(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::rotate_right":["#[inline]\nfn rotate_right(self, n: u32) -> Self{\n                <$T>::rotate_right(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::signed_shl":["#[inline]\nfn signed_shl(self, n: u32) -> Self{\n                ((self as $S) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::signed_shr":["#[inline]\nfn signed_shr(self, n: u32) -> Self{\n                ((self as $S) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::swap_bytes":["#[inline]\nfn swap_bytes(self) -> Self{\n                <$T>::swap_bytes(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::to_be":["#[inline]\nfn to_be(self) -> Self{\n                <$T>::to_be(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::to_le":["#[inline]\nfn to_le(self) -> Self{\n                <$T>::to_le(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::trailing_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn trailing_ones(self) -> u32{\n                <$T>::trailing_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::trailing_zeros":["#[inline]\nfn trailing_zeros(self) -> u32{\n                <$T>::trailing_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::unsigned_shl":["#[inline]\nfn unsigned_shl(self, n: u32) -> Self{\n                ((self as $U) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as int::PrimInt>::unsigned_shr":["#[inline]\nfn unsigned_shr(self, n: u32) -> Self{\n                ((self as $U) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u64 as ops::checked::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u64 as ops::checked::CheckedDiv>::checked_div":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u64 as ops::checked::CheckedMul>::checked_mul":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u64 as ops::checked::CheckedNeg>::checked_neg":["#[inline]\nfn $method(&self) -> Option<$t>{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u64 as ops::checked::CheckedRem>::checked_rem":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u64 as ops::checked::CheckedShl>::checked_shl":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u64 as ops::checked::CheckedShr>::checked_shr":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u64 as ops::checked::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u64 as ops::euclid::CheckedEuclid>::checked_div_euclid":["#[inline]\nfn checked_div_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u64 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["#[inline]\nfn checked_rem_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u64 as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u64 as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u64 as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n                (self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<u64 as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n                *self = (*self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<u64 as ops::overflowing::OverflowingAdd>::overflowing_add":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u64 as ops::overflowing::OverflowingMul>::overflowing_mul":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u64 as ops::overflowing::OverflowingSub>::overflowing_sub":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u64 as ops::saturating::Saturating>::saturating_add":["#[inline]\nfn saturating_add(self, v: Self) -> Self{\n                Self::saturating_add(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u64 as ops::saturating::Saturating>::saturating_sub":["#[inline]\nfn saturating_sub(self, v: Self) -> Self{\n                Self::saturating_sub(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u64 as ops::saturating::SaturatingAdd>::saturating_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u64 as ops::saturating::SaturatingMul>::saturating_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u64 as ops::saturating::SaturatingSub>::saturating_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u64 as ops::wrapping::WrappingAdd>::wrapping_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u64 as ops::wrapping::WrappingMul>::wrapping_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u64 as ops::wrapping::WrappingNeg>::wrapping_neg":["#[inline]\nfn $method(&self) -> $t{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u64 as ops::wrapping::WrappingShl>::wrapping_shl":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u64 as ops::wrapping::WrappingShr>::wrapping_shr":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u64 as ops::wrapping::WrappingSub>::wrapping_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u64 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u64 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u64 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u64 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u64 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u64 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u64 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u64 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u8 as Num>::from_str_radix":["#[inline]\nfn from_str_radix(s: &str, radix: u32)\n                              -> Result<Self, ::core::num::ParseIntError>{\n                <$t>::from_str_radix(s, radix)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<u8 as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<u8 as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<u8 as cast::AsPrimitive<char>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_f32":["#[inline]\nfn to_f32(&self) -> Option<f32>{\n                Some(*self as f32)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_f64":["#[inline]\nfn to_f64(&self) -> Option<f64>{\n                Some(*self as f64)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<u8 as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u8 as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u8 as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u8 as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<u8 as int::PrimInt>::count_ones":["#[inline]\nfn count_ones(self) -> u32{\n                <$T>::count_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::count_zeros":["#[inline]\nfn count_zeros(self) -> u32{\n                <$T>::count_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::from_be":["#[inline]\nfn from_be(x: Self) -> Self{\n                <$T>::from_be(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::from_le":["#[inline]\nfn from_le(x: Self) -> Self{\n                <$T>::from_le(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::leading_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn leading_ones(self) -> u32{\n                <$T>::leading_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::leading_zeros":["#[inline]\nfn leading_zeros(self) -> u32{\n                <$T>::leading_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::pow":["#[inline]\nfn pow(self, exp: u32) -> Self{\n                <$T>::pow(self, exp)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::reverse_bits":["#[cfg(has_reverse_bits)]\n#[inline]\nfn reverse_bits(self) -> Self{\n                <$T>::reverse_bits(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::rotate_left":["#[inline]\nfn rotate_left(self, n: u32) -> Self{\n                <$T>::rotate_left(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::rotate_right":["#[inline]\nfn rotate_right(self, n: u32) -> Self{\n                <$T>::rotate_right(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::signed_shl":["#[inline]\nfn signed_shl(self, n: u32) -> Self{\n                ((self as $S) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::signed_shr":["#[inline]\nfn signed_shr(self, n: u32) -> Self{\n                ((self as $S) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::swap_bytes":["#[inline]\nfn swap_bytes(self) -> Self{\n                <$T>::swap_bytes(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::to_be":["#[inline]\nfn to_be(self) -> Self{\n                <$T>::to_be(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::to_le":["#[inline]\nfn to_le(self) -> Self{\n                <$T>::to_le(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::trailing_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn trailing_ones(self) -> u32{\n                <$T>::trailing_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::trailing_zeros":["#[inline]\nfn trailing_zeros(self) -> u32{\n                <$T>::trailing_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::unsigned_shl":["#[inline]\nfn unsigned_shl(self, n: u32) -> Self{\n                ((self as $U) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as int::PrimInt>::unsigned_shr":["#[inline]\nfn unsigned_shr(self, n: u32) -> Self{\n                ((self as $U) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<u8 as ops::checked::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u8 as ops::checked::CheckedDiv>::checked_div":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u8 as ops::checked::CheckedMul>::checked_mul":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u8 as ops::checked::CheckedNeg>::checked_neg":["#[inline]\nfn $method(&self) -> Option<$t>{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u8 as ops::checked::CheckedRem>::checked_rem":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u8 as ops::checked::CheckedShl>::checked_shl":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u8 as ops::checked::CheckedShr>::checked_shr":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u8 as ops::checked::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<u8 as ops::euclid::CheckedEuclid>::checked_div_euclid":["#[inline]\nfn checked_div_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u8 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["#[inline]\nfn checked_rem_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u8 as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u8 as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<u8 as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n                (self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<u8 as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n                *self = (*self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<u8 as ops::overflowing::OverflowingAdd>::overflowing_add":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u8 as ops::overflowing::OverflowingMul>::overflowing_mul":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u8 as ops::overflowing::OverflowingSub>::overflowing_sub":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<u8 as ops::saturating::Saturating>::saturating_add":["#[inline]\nfn saturating_add(self, v: Self) -> Self{\n                Self::saturating_add(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u8 as ops::saturating::Saturating>::saturating_sub":["#[inline]\nfn saturating_sub(self, v: Self) -> Self{\n                Self::saturating_sub(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u8 as ops::saturating::SaturatingAdd>::saturating_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u8 as ops::saturating::SaturatingMul>::saturating_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u8 as ops::saturating::SaturatingSub>::saturating_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<u8 as ops::wrapping::WrappingAdd>::wrapping_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u8 as ops::wrapping::WrappingMul>::wrapping_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u8 as ops::wrapping::WrappingNeg>::wrapping_neg":["#[inline]\nfn $method(&self) -> $t{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u8 as ops::wrapping::WrappingShl>::wrapping_shl":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u8 as ops::wrapping::WrappingShr>::wrapping_shr":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u8 as ops::wrapping::WrappingSub>::wrapping_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<u8 as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u8 as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u8 as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u8 as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u8 as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u8 as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u8 as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<u8 as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<usize as Num>::from_str_radix":["#[inline]\nfn from_str_radix(s: &str, radix: u32)\n                              -> Result<Self, ::core::num::ParseIntError>{\n                <$t>::from_str_radix(s, radix)\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<usize as bounds::Bounded>::max_value":["#[inline]\nfn max_value() -> $t{\n                $max\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<usize as bounds::Bounded>::min_value":["#[inline]\nfn min_value() -> $t{\n                $min\n            }","Real(LocalPath(\"src/bounds.rs\"))"],"<usize as cast::AsPrimitive<f32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<f64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<i128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<i16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<i32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<i64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<i8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<isize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<u128>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<u16>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<u32>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<u64>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<u8>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::AsPrimitive<usize>>::as_":["#[inline]\nfn as_(self) -> $U{ self as $U }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_f32":["#[inline]\nfn from_f32(n: f32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_f64":["#[inline]\nfn from_f64(n: f64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_i128":["#[cfg(has_i128)]\n#[inline]\nfn from_i128(n: i128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_i16":["#[inline]\nfn from_i16(n: i16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_i32":["#[inline]\nfn from_i32(n: i32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_i8":["#[inline]\nfn from_i8(n: i8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_isize":["#[inline]\nfn from_isize(n: isize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_u128":["#[cfg(has_i128)]\n#[inline]\nfn from_u128(n: u128) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_u16":["#[inline]\nfn from_u16(n: u16) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_u8":["#[inline]\nfn from_u8(n: u8) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::FromPrimitive>::from_usize":["#[inline]\nfn from_usize(n: usize) -> Option<$T>{\n                n.$to_ty()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::NumCast>::from":["#[inline]\n#[allow(deprecated)]\nfn from<N: ToPrimitive>(n: N) -> Option<$T>{\n                // `$conv` could be generated using `concat_idents!`, but that\n                // macro seems to be broken at the moment\n                n.$conv()\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_f32":["#[inline]\nfn to_f32(&self) -> Option<f32>{\n                Some(*self as f32)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_f64":["#[inline]\nfn to_f64(&self) -> Option<f64>{\n                Some(*self as f64)\n            }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_i128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_i16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_i32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_i64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_i8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_isize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_u128":["#[inline]\n#[$cfg]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_u16":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_u32":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_u64":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_u8":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as cast::ToPrimitive>::to_usize":["#[inline]\nfn $method(&self) -> Option<$DstT>{\n            let max = $DstT::MAX as $SrcT;\n            if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {\n                Some(*self as $DstT)\n            } else {\n                None\n            }\n        }","Real(LocalPath(\"src/cast.rs\"))"],"<usize as identities::One>::is_one":["#[inline]\nfn is_one(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<usize as identities::One>::one":["#[inline]\nfn one() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<usize as identities::Zero>::is_zero":["#[inline]\nfn is_zero(&self) -> bool{\n                *self == $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<usize as identities::Zero>::zero":["#[inline]\nfn zero() -> $t{\n                $v\n            }","Real(LocalPath(\"src/identities.rs\"))"],"<usize as int::PrimInt>::count_ones":["#[inline]\nfn count_ones(self) -> u32{\n                <$T>::count_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::count_zeros":["#[inline]\nfn count_zeros(self) -> u32{\n                <$T>::count_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::from_be":["#[inline]\nfn from_be(x: Self) -> Self{\n                <$T>::from_be(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::from_le":["#[inline]\nfn from_le(x: Self) -> Self{\n                <$T>::from_le(x)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::leading_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn leading_ones(self) -> u32{\n                <$T>::leading_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::leading_zeros":["#[inline]\nfn leading_zeros(self) -> u32{\n                <$T>::leading_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::pow":["#[inline]\nfn pow(self, exp: u32) -> Self{\n                <$T>::pow(self, exp)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::reverse_bits":["#[cfg(has_reverse_bits)]\n#[inline]\nfn reverse_bits(self) -> Self{\n                <$T>::reverse_bits(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::rotate_left":["#[inline]\nfn rotate_left(self, n: u32) -> Self{\n                <$T>::rotate_left(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::rotate_right":["#[inline]\nfn rotate_right(self, n: u32) -> Self{\n                <$T>::rotate_right(self, n)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::signed_shl":["#[inline]\nfn signed_shl(self, n: u32) -> Self{\n                ((self as $S) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::signed_shr":["#[inline]\nfn signed_shr(self, n: u32) -> Self{\n                ((self as $S) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::swap_bytes":["#[inline]\nfn swap_bytes(self) -> Self{\n                <$T>::swap_bytes(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::to_be":["#[inline]\nfn to_be(self) -> Self{\n                <$T>::to_be(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::to_le":["#[inline]\nfn to_le(self) -> Self{\n                <$T>::to_le(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::trailing_ones":["#[cfg(has_leading_trailing_ones)]\n#[inline]\nfn trailing_ones(self) -> u32{\n                <$T>::trailing_ones(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::trailing_zeros":["#[inline]\nfn trailing_zeros(self) -> u32{\n                <$T>::trailing_zeros(self)\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::unsigned_shl":["#[inline]\nfn unsigned_shl(self, n: u32) -> Self{\n                ((self as $U) << n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as int::PrimInt>::unsigned_shr":["#[inline]\nfn unsigned_shr(self, n: u32) -> Self{\n                ((self as $U) >> n) as $T\n            }","Real(LocalPath(\"src/int.rs\"))"],"<usize as ops::checked::CheckedAdd>::checked_add":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<usize as ops::checked::CheckedDiv>::checked_div":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<usize as ops::checked::CheckedMul>::checked_mul":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<usize as ops::checked::CheckedNeg>::checked_neg":["#[inline]\nfn $method(&self) -> Option<$t>{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<usize as ops::checked::CheckedRem>::checked_rem":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<usize as ops::checked::CheckedShl>::checked_shl":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<usize as ops::checked::CheckedShr>::checked_shr":["#[inline]\nfn $method(&self, rhs: u32) -> Option<$t>{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<usize as ops::checked::CheckedSub>::checked_sub":["#[inline]\nfn $method(&self, v: &$t) -> Option<$t>{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/checked.rs\"))"],"<usize as ops::euclid::CheckedEuclid>::checked_div_euclid":["#[inline]\nfn checked_div_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<usize as ops::euclid::CheckedEuclid>::checked_rem_euclid":["#[inline]\nfn checked_rem_euclid(&self, v: &$t) -> Option<Self>{\n                <$t>::checked_rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<usize as ops::euclid::Euclid>::div_euclid":["#[inline]\nfn div_euclid(&self, v: &$t) -> Self{\n                <$t>::div_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<usize as ops::euclid::Euclid>::rem_euclid":["#[inline]\nfn rem_euclid(&self, v: &$t) -> Self{\n                <$t>::rem_euclid(*self, *v)\n            }","Real(LocalPath(\"src/ops/euclid.rs\"))"],"<usize as ops::mul_add::MulAdd>::mul_add":["#[inline]\nfn mul_add(self, a: Self, b: Self) -> Self::Output{\n                (self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<usize as ops::mul_add::MulAddAssign>::mul_add_assign":["#[inline]\nfn mul_add_assign(&mut self, a: Self, b: Self){\n                *self = (*self * a) + b\n            }","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"<usize as ops::overflowing::OverflowingAdd>::overflowing_add":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<usize as ops::overflowing::OverflowingMul>::overflowing_mul":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<usize as ops::overflowing::OverflowingSub>::overflowing_sub":["#[inline]\nfn $method(&self, v: &Self) -> (Self, bool){\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"<usize as ops::saturating::Saturating>::saturating_add":["#[inline]\nfn saturating_add(self, v: Self) -> Self{\n                Self::saturating_add(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<usize as ops::saturating::Saturating>::saturating_sub":["#[inline]\nfn saturating_sub(self, v: Self) -> Self{\n                Self::saturating_sub(self, v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<usize as ops::saturating::SaturatingAdd>::saturating_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<usize as ops::saturating::SaturatingMul>::saturating_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<usize as ops::saturating::SaturatingSub>::saturating_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/saturating.rs\"))"],"<usize as ops::wrapping::WrappingAdd>::wrapping_add":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<usize as ops::wrapping::WrappingMul>::wrapping_mul":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<usize as ops::wrapping::WrappingNeg>::wrapping_neg":["#[inline]\nfn $method(&self) -> $t{\n                <$t>::$method(*self)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<usize as ops::wrapping::WrappingShl>::wrapping_shl":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<usize as ops::wrapping::WrappingShr>::wrapping_shr":["#[inline]\nfn $method(&self, rhs: u32) -> $t{\n                <$t>::$method(*self, rhs)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<usize as ops::wrapping::WrappingSub>::wrapping_sub":["#[inline]\nfn $method(&self, v: &Self) -> Self{\n                <$t>::$method(*self, *v)\n            }","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"<usize as pow::Pow<&'a u16>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<usize as pow::Pow<&'a u32>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<usize as pow::Pow<&'a u8>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<usize as pow::Pow<&'a usize>>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<usize as pow::Pow<u16>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<usize as pow::Pow<u32>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<usize as pow::Pow<u8>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"<usize as pow::Pow<usize>>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"FloatErrorKind":["pub enum FloatErrorKind {\n    Empty,\n    Invalid,\n}","Real(LocalPath(\"src/lib.rs\"))"],"Num":["/// The base trait for numeric types, covering `0` and `1` values,\n/// comparisons, basic numeric operations, and string conversion.\npub trait Num: PartialEq + Zero + One + NumOps {\n    type FromStrRadixErr;\n\n    /// Convert from a string and radix (typically `2..=36`).\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use num_traits::Num;\n    ///\n    /// let result = <i32 as Num>::from_str_radix(\"27\", 10);\n    /// assert_eq!(result, Ok(27));\n    ///\n    /// let result = <i32 as Num>::from_str_radix(\"foo\", 10);\n    /// assert!(result.is_err());\n    /// ```\n    ///\n    /// # Supported radices\n    ///\n    /// The exact range of supported radices is at the discretion of each type implementation. For\n    /// primitive integers, this is implemented by the inherent `from_str_radix` methods in the\n    /// standard library, which **panic** if the radix is not in the range from 2 to 36. The\n    /// implementation in this crate for primitive floats is similar.\n    ///\n    /// For third-party types, it is suggested that implementations should follow suit and at least\n    /// accept `2..=36` without panicking, but an `Err` may be returned for any unsupported radix.\n    /// It's possible that a type might not even support the common radix 10, nor any, if string\n    /// parsing doesn't make sense for that type.\n    fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr>;\n}","Real(LocalPath(\"src/lib.rs\"))"],"NumAssign":["/// The trait for `Num` types which also implement assignment operators.\n///\n/// This is automatically implemented for types which implement the operators.\npub trait NumAssign: Num + NumAssignOps {}","Real(LocalPath(\"src/lib.rs\"))"],"NumAssignOps":["/// Generic trait for types implementing numeric assignment operators (like `+=`).\n///\n/// This is automatically implemented for types which implement the operators.\npub trait NumAssignOps<Rhs = Self>:\n    AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>\n{\n}","Real(LocalPath(\"src/lib.rs\"))"],"NumAssignRef":["/// The trait for `NumAssign` types which also implement assignment operations\n/// taking the second operand by reference.\n///\n/// This is automatically implemented for types which implement the operators.\npub trait NumAssignRef: NumAssign + for<'r> NumAssignOps<&'r Self> {}","Real(LocalPath(\"src/lib.rs\"))"],"NumOps":["/// Generic trait for types implementing basic numeric operations\n///\n/// This is automatically implemented for types which implement the operators.\npub trait NumOps<Rhs = Self, Output = Self>:\n    Add<Rhs, Output = Output>\n    + Sub<Rhs, Output = Output>\n    + Mul<Rhs, Output = Output>\n    + Div<Rhs, Output = Output>\n    + Rem<Rhs, Output = Output>\n{\n}","Real(LocalPath(\"src/lib.rs\"))"],"NumRef":["/// The trait for `Num` types which also implement numeric operations taking\n/// the second operand by reference.\n///\n/// This is automatically implemented for types which implement the operators.\npub trait NumRef: Num + for<'r> NumOps<&'r Self> {}","Real(LocalPath(\"src/lib.rs\"))"],"ParseFloatError":["pub struct ParseFloatError {\n    pub kind: FloatErrorKind,\n}","Real(LocalPath(\"src/lib.rs\"))"],"RefNum":["/// The trait for `Num` references which implement numeric operations, taking the\n/// second operand either by value or by reference.\n///\n/// This is automatically implemented for all types which implement the operators. It covers\n/// every type implementing the operations though, regardless of it being a reference or\n/// related to `Num`.\npub trait RefNum<Base>: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}","Real(LocalPath(\"src/lib.rs\"))"],"bounds::Bounded":["/// Numbers which have upper and lower bounds\npub trait Bounded {\n    // FIXME (#5527): These should be associated constants\n    /// Returns the smallest finite number this type can represent\n    fn min_value() -> Self;\n    /// Returns the largest finite number this type can represent\n    fn max_value() -> Self;\n}","Real(LocalPath(\"src/bounds.rs\"))"],"bounds::LowerBounded":["/// Numbers which have lower bounds\npub trait LowerBounded {\n    /// Returns the smallest finite number this type can represent\n    fn min_value() -> Self;\n}","Real(LocalPath(\"src/bounds.rs\"))"],"bounds::UpperBounded":["/// Numbers which have upper bounds\npub trait UpperBounded {\n    /// Returns the largest finite number this type can represent\n    fn max_value() -> Self;\n}","Real(LocalPath(\"src/bounds.rs\"))"],"cast::AsPrimitive":["/// A generic interface for casting between machine scalars with the\n/// `as` operator, which admits narrowing and precision loss.\n/// Implementers of this trait `AsPrimitive` should behave like a primitive\n/// numeric type (e.g. a newtype around another primitive), and the\n/// intended conversion must never fail.\n///\n/// # Examples\n///\n/// ```\n/// # use num_traits::AsPrimitive;\n/// let three: i32 = (3.14159265f32).as_();\n/// assert_eq!(three, 3);\n/// ```\n///\n/// # Safety\n///\n/// **In Rust versions before 1.45.0**, some uses of the `as` operator were not entirely safe.\n/// In particular, it was undefined behavior if\n/// a truncated floating point value could not fit in the target integer\n/// type ([#10184](https://github.com/rust-lang/rust/issues/10184)).\n///\n/// ```ignore\n/// # use num_traits::AsPrimitive;\n/// let x: u8 = (1.04E+17).as_(); // UB\n/// ```\n///\npub trait AsPrimitive<T>: 'static + Copy\nwhere\n    T: 'static + Copy,\n{\n    /// Convert a value to another, using the `as` operator.\n    fn as_(self) -> T;\n}","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive":["/// A generic trait for converting a number to a value.\n///\n/// A value can be represented by the target type when it lies within\n/// the range of scalars supported by the target type.\n/// For example, a negative integer cannot be represented by an unsigned\n/// integer type, and an `i64` with a very high magnitude might not be\n/// convertible to an `i32`.\n/// On the other hand, conversions with possible precision loss or truncation\n/// are admitted, like an `f32` with a decimal part to an integer type, or\n/// even a large `f64` saturating to `f32` infinity.\npub trait FromPrimitive: Sized {\n    /// Converts an `isize` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    #[inline]\n    fn from_isize(n: isize) -> Option<Self> {\n        n.to_i64().and_then(FromPrimitive::from_i64)\n    }\n\n    /// Converts an `i8` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    #[inline]\n    fn from_i8(n: i8) -> Option<Self> {\n        FromPrimitive::from_i64(From::from(n))\n    }\n\n    /// Converts an `i16` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    #[inline]\n    fn from_i16(n: i16) -> Option<Self> {\n        FromPrimitive::from_i64(From::from(n))\n    }\n\n    /// Converts an `i32` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    #[inline]\n    fn from_i32(n: i32) -> Option<Self> {\n        FromPrimitive::from_i64(From::from(n))\n    }\n\n    /// Converts an `i64` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    fn from_i64(n: i64) -> Option<Self>;\n\n    /// Converts an `i128` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    ///\n    /// This method is only available with feature `i128` enabled on Rust >= 1.26.\n    ///\n    /// The default implementation converts through `from_i64()`. Types implementing\n    /// this trait should override this method if they can represent a greater range.\n    #[inline]\n    #[cfg(has_i128)]\n    fn from_i128(n: i128) -> Option<Self> {\n        n.to_i64().and_then(FromPrimitive::from_i64)\n    }\n\n    /// Converts a `usize` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    #[inline]\n    fn from_usize(n: usize) -> Option<Self> {\n        n.to_u64().and_then(FromPrimitive::from_u64)\n    }\n\n    /// Converts an `u8` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    #[inline]\n    fn from_u8(n: u8) -> Option<Self> {\n        FromPrimitive::from_u64(From::from(n))\n    }\n\n    /// Converts an `u16` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    #[inline]\n    fn from_u16(n: u16) -> Option<Self> {\n        FromPrimitive::from_u64(From::from(n))\n    }\n\n    /// Converts an `u32` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    #[inline]\n    fn from_u32(n: u32) -> Option<Self> {\n        FromPrimitive::from_u64(From::from(n))\n    }\n\n    /// Converts an `u64` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    fn from_u64(n: u64) -> Option<Self>;\n\n    /// Converts an `u128` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    ///\n    /// This method is only available with feature `i128` enabled on Rust >= 1.26.\n    ///\n    /// The default implementation converts through `from_u64()`. Types implementing\n    /// this trait should override this method if they can represent a greater range.\n    #[inline]\n    #[cfg(has_i128)]\n    fn from_u128(n: u128) -> Option<Self> {\n        n.to_u64().and_then(FromPrimitive::from_u64)\n    }\n\n    /// Converts a `f32` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    #[inline]\n    fn from_f32(n: f32) -> Option<Self> {\n        FromPrimitive::from_f64(From::from(n))\n    }\n\n    /// Converts a `f64` to return an optional value of this type. If the\n    /// value cannot be represented by this type, then `None` is returned.\n    ///\n    /// The default implementation tries to convert through `from_i64()`, and\n    /// failing that through `from_u64()`. Types implementing this trait should\n    /// override this method if they can represent a greater range.\n    #[inline]\n    fn from_f64(n: f64) -> Option<Self> {\n        match n.to_i64() {\n            Some(i) => FromPrimitive::from_i64(i),\n            None => n.to_u64().and_then(FromPrimitive::from_u64),\n        }\n    }\n}","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive::from_f32":["/// Converts a `f32` to return an optional value of this type. If the\n/// value cannot be represented by this type, then `None` is returned.\n#[inline]\nfn from_f32(n: f32) -> Option<Self>{\n        FromPrimitive::from_f64(From::from(n))\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive::from_f64":["/// Converts a `f64` to return an optional value of this type. If the\n/// value cannot be represented by this type, then `None` is returned.\n///\n/// The default implementation tries to convert through `from_i64()`, and\n/// failing that through `from_u64()`. Types implementing this trait should\n/// override this method if they can represent a greater range.\n#[inline]\nfn from_f64(n: f64) -> Option<Self>{\n        match n.to_i64() {\n            Some(i) => FromPrimitive::from_i64(i),\n            None => n.to_u64().and_then(FromPrimitive::from_u64),\n        }\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive::from_i128":["/// Converts an `i128` to return an optional value of this type. If the\n/// value cannot be represented by this type, then `None` is returned.\n///\n/// This method is only available with feature `i128` enabled on Rust >= 1.26.\n///\n/// The default implementation converts through `from_i64()`. Types implementing\n/// this trait should override this method if they can represent a greater range.\n#[inline]\n#[cfg(has_i128)]\nfn from_i128(n: i128) -> Option<Self>{\n        n.to_i64().and_then(FromPrimitive::from_i64)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive::from_i16":["/// Converts an `i16` to return an optional value of this type. If the\n/// value cannot be represented by this type, then `None` is returned.\n#[inline]\nfn from_i16(n: i16) -> Option<Self>{\n        FromPrimitive::from_i64(From::from(n))\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive::from_i32":["/// Converts an `i32` to return an optional value of this type. If the\n/// value cannot be represented by this type, then `None` is returned.\n#[inline]\nfn from_i32(n: i32) -> Option<Self>{\n        FromPrimitive::from_i64(From::from(n))\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive::from_i8":["/// Converts an `i8` to return an optional value of this type. If the\n/// value cannot be represented by this type, then `None` is returned.\n#[inline]\nfn from_i8(n: i8) -> Option<Self>{\n        FromPrimitive::from_i64(From::from(n))\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive::from_isize":["/// Converts an `isize` to return an optional value of this type. If the\n/// value cannot be represented by this type, then `None` is returned.\n#[inline]\nfn from_isize(n: isize) -> Option<Self>{\n        n.to_i64().and_then(FromPrimitive::from_i64)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive::from_u128":["/// Converts an `u128` to return an optional value of this type. If the\n/// value cannot be represented by this type, then `None` is returned.\n///\n/// This method is only available with feature `i128` enabled on Rust >= 1.26.\n///\n/// The default implementation converts through `from_u64()`. Types implementing\n/// this trait should override this method if they can represent a greater range.\n#[inline]\n#[cfg(has_i128)]\nfn from_u128(n: u128) -> Option<Self>{\n        n.to_u64().and_then(FromPrimitive::from_u64)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive::from_u16":["/// Converts an `u16` to return an optional value of this type. If the\n/// value cannot be represented by this type, then `None` is returned.\n#[inline]\nfn from_u16(n: u16) -> Option<Self>{\n        FromPrimitive::from_u64(From::from(n))\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive::from_u32":["/// Converts an `u32` to return an optional value of this type. If the\n/// value cannot be represented by this type, then `None` is returned.\n#[inline]\nfn from_u32(n: u32) -> Option<Self>{\n        FromPrimitive::from_u64(From::from(n))\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive::from_u8":["/// Converts an `u8` to return an optional value of this type. If the\n/// value cannot be represented by this type, then `None` is returned.\n#[inline]\nfn from_u8(n: u8) -> Option<Self>{\n        FromPrimitive::from_u64(From::from(n))\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::FromPrimitive::from_usize":["/// Converts a `usize` to return an optional value of this type. If the\n/// value cannot be represented by this type, then `None` is returned.\n#[inline]\nfn from_usize(n: usize) -> Option<Self>{\n        n.to_u64().and_then(FromPrimitive::from_u64)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::NumCast":["/// An interface for casting between machine scalars.\npub trait NumCast: Sized + ToPrimitive {\n    /// Creates a number from another value that can be converted into\n    /// a primitive via the `ToPrimitive` trait. If the source value cannot be\n    /// represented by the target type, then `None` is returned.\n    ///\n    /// A value can be represented by the target type when it lies within\n    /// the range of scalars supported by the target type.\n    /// For example, a negative integer cannot be represented by an unsigned\n    /// integer type, and an `i64` with a very high magnitude might not be\n    /// convertible to an `i32`.\n    /// On the other hand, conversions with possible precision loss or truncation\n    /// are admitted, like an `f32` with a decimal part to an integer type, or\n    /// even a large `f64` saturating to `f32` infinity.\n    fn from<T: ToPrimitive>(n: T) -> Option<Self>;\n}","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive":["/// A generic trait for converting a value to a number.\n///\n/// A value can be represented by the target type when it lies within\n/// the range of scalars supported by the target type.\n/// For example, a negative integer cannot be represented by an unsigned\n/// integer type, and an `i64` with a very high magnitude might not be\n/// convertible to an `i32`.\n/// On the other hand, conversions with possible precision loss or truncation\n/// are admitted, like an `f32` with a decimal part to an integer type, or\n/// even a large `f64` saturating to `f32` infinity.\npub trait ToPrimitive {\n    /// Converts the value of `self` to an `isize`. If the value cannot be\n    /// represented by an `isize`, then `None` is returned.\n    #[inline]\n    fn to_isize(&self) -> Option<isize> {\n        self.to_i64().as_ref().and_then(ToPrimitive::to_isize)\n    }\n\n    /// Converts the value of `self` to an `i8`. If the value cannot be\n    /// represented by an `i8`, then `None` is returned.\n    #[inline]\n    fn to_i8(&self) -> Option<i8> {\n        self.to_i64().as_ref().and_then(ToPrimitive::to_i8)\n    }\n\n    /// Converts the value of `self` to an `i16`. If the value cannot be\n    /// represented by an `i16`, then `None` is returned.\n    #[inline]\n    fn to_i16(&self) -> Option<i16> {\n        self.to_i64().as_ref().and_then(ToPrimitive::to_i16)\n    }\n\n    /// Converts the value of `self` to an `i32`. If the value cannot be\n    /// represented by an `i32`, then `None` is returned.\n    #[inline]\n    fn to_i32(&self) -> Option<i32> {\n        self.to_i64().as_ref().and_then(ToPrimitive::to_i32)\n    }\n\n    /// Converts the value of `self` to an `i64`. If the value cannot be\n    /// represented by an `i64`, then `None` is returned.\n    fn to_i64(&self) -> Option<i64>;\n\n    /// Converts the value of `self` to an `i128`. If the value cannot be\n    /// represented by an `i128` (`i64` under the default implementation), then\n    /// `None` is returned.\n    ///\n    /// This method is only available with feature `i128` enabled on Rust >= 1.26.\n    ///\n    /// The default implementation converts through `to_i64()`. Types implementing\n    /// this trait should override this method if they can represent a greater range.\n    #[inline]\n    #[cfg(has_i128)]\n    fn to_i128(&self) -> Option<i128> {\n        self.to_i64().map(From::from)\n    }\n\n    /// Converts the value of `self` to a `usize`. If the value cannot be\n    /// represented by a `usize`, then `None` is returned.\n    #[inline]\n    fn to_usize(&self) -> Option<usize> {\n        self.to_u64().as_ref().and_then(ToPrimitive::to_usize)\n    }\n\n    /// Converts the value of `self` to a `u8`. If the value cannot be\n    /// represented by a `u8`, then `None` is returned.\n    #[inline]\n    fn to_u8(&self) -> Option<u8> {\n        self.to_u64().as_ref().and_then(ToPrimitive::to_u8)\n    }\n\n    /// Converts the value of `self` to a `u16`. If the value cannot be\n    /// represented by a `u16`, then `None` is returned.\n    #[inline]\n    fn to_u16(&self) -> Option<u16> {\n        self.to_u64().as_ref().and_then(ToPrimitive::to_u16)\n    }\n\n    /// Converts the value of `self` to a `u32`. If the value cannot be\n    /// represented by a `u32`, then `None` is returned.\n    #[inline]\n    fn to_u32(&self) -> Option<u32> {\n        self.to_u64().as_ref().and_then(ToPrimitive::to_u32)\n    }\n\n    /// Converts the value of `self` to a `u64`. If the value cannot be\n    /// represented by a `u64`, then `None` is returned.\n    fn to_u64(&self) -> Option<u64>;\n\n    /// Converts the value of `self` to a `u128`. If the value cannot be\n    /// represented by a `u128` (`u64` under the default implementation), then\n    /// `None` is returned.\n    ///\n    /// This method is only available with feature `i128` enabled on Rust >= 1.26.\n    ///\n    /// The default implementation converts through `to_u64()`. Types implementing\n    /// this trait should override this method if they can represent a greater range.\n    #[inline]\n    #[cfg(has_i128)]\n    fn to_u128(&self) -> Option<u128> {\n        self.to_u64().map(From::from)\n    }\n\n    /// Converts the value of `self` to an `f32`. Overflows may map to positive\n    /// or negative inifinity, otherwise `None` is returned if the value cannot\n    /// be represented by an `f32`.\n    #[inline]\n    fn to_f32(&self) -> Option<f32> {\n        self.to_f64().as_ref().and_then(ToPrimitive::to_f32)\n    }\n\n    /// Converts the value of `self` to an `f64`. Overflows may map to positive\n    /// or negative inifinity, otherwise `None` is returned if the value cannot\n    /// be represented by an `f64`.\n    ///\n    /// The default implementation tries to convert through `to_i64()`, and\n    /// failing that through `to_u64()`. Types implementing this trait should\n    /// override this method if they can represent a greater range.\n    #[inline]\n    fn to_f64(&self) -> Option<f64> {\n        match self.to_i64() {\n            Some(i) => i.to_f64(),\n            None => self.to_u64().as_ref().and_then(ToPrimitive::to_f64),\n        }\n    }\n}","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive::to_f32":["/// Converts the value of `self` to an `f32`. Overflows may map to positive\n/// or negative inifinity, otherwise `None` is returned if the value cannot\n/// be represented by an `f32`.\n#[inline]\nfn to_f32(&self) -> Option<f32>{\n        self.to_f64().as_ref().and_then(ToPrimitive::to_f32)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive::to_f64":["/// Converts the value of `self` to an `f64`. Overflows may map to positive\n/// or negative inifinity, otherwise `None` is returned if the value cannot\n/// be represented by an `f64`.\n///\n/// The default implementation tries to convert through `to_i64()`, and\n/// failing that through `to_u64()`. Types implementing this trait should\n/// override this method if they can represent a greater range.\n#[inline]\nfn to_f64(&self) -> Option<f64>{\n        match self.to_i64() {\n            Some(i) => i.to_f64(),\n            None => self.to_u64().as_ref().and_then(ToPrimitive::to_f64),\n        }\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive::to_i128":["/// Converts the value of `self` to an `i128`. If the value cannot be\n/// represented by an `i128` (`i64` under the default implementation), then\n/// `None` is returned.\n///\n/// This method is only available with feature `i128` enabled on Rust >= 1.26.\n///\n/// The default implementation converts through `to_i64()`. Types implementing\n/// this trait should override this method if they can represent a greater range.\n#[inline]\n#[cfg(has_i128)]\nfn to_i128(&self) -> Option<i128>{\n        self.to_i64().map(From::from)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive::to_i16":["/// Converts the value of `self` to an `i16`. If the value cannot be\n/// represented by an `i16`, then `None` is returned.\n#[inline]\nfn to_i16(&self) -> Option<i16>{\n        self.to_i64().as_ref().and_then(ToPrimitive::to_i16)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive::to_i32":["/// Converts the value of `self` to an `i32`. If the value cannot be\n/// represented by an `i32`, then `None` is returned.\n#[inline]\nfn to_i32(&self) -> Option<i32>{\n        self.to_i64().as_ref().and_then(ToPrimitive::to_i32)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive::to_i8":["/// Converts the value of `self` to an `i8`. If the value cannot be\n/// represented by an `i8`, then `None` is returned.\n#[inline]\nfn to_i8(&self) -> Option<i8>{\n        self.to_i64().as_ref().and_then(ToPrimitive::to_i8)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive::to_isize":["/// Converts the value of `self` to an `isize`. If the value cannot be\n/// represented by an `isize`, then `None` is returned.\n#[inline]\nfn to_isize(&self) -> Option<isize>{\n        self.to_i64().as_ref().and_then(ToPrimitive::to_isize)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive::to_u128":["/// Converts the value of `self` to a `u128`. If the value cannot be\n/// represented by a `u128` (`u64` under the default implementation), then\n/// `None` is returned.\n///\n/// This method is only available with feature `i128` enabled on Rust >= 1.26.\n///\n/// The default implementation converts through `to_u64()`. Types implementing\n/// this trait should override this method if they can represent a greater range.\n#[inline]\n#[cfg(has_i128)]\nfn to_u128(&self) -> Option<u128>{\n        self.to_u64().map(From::from)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive::to_u16":["/// Converts the value of `self` to a `u16`. If the value cannot be\n/// represented by a `u16`, then `None` is returned.\n#[inline]\nfn to_u16(&self) -> Option<u16>{\n        self.to_u64().as_ref().and_then(ToPrimitive::to_u16)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive::to_u32":["/// Converts the value of `self` to a `u32`. If the value cannot be\n/// represented by a `u32`, then `None` is returned.\n#[inline]\nfn to_u32(&self) -> Option<u32>{\n        self.to_u64().as_ref().and_then(ToPrimitive::to_u32)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive::to_u8":["/// Converts the value of `self` to a `u8`. If the value cannot be\n/// represented by a `u8`, then `None` is returned.\n#[inline]\nfn to_u8(&self) -> Option<u8>{\n        self.to_u64().as_ref().and_then(ToPrimitive::to_u8)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::ToPrimitive::to_usize":["/// Converts the value of `self` to a `usize`. If the value cannot be\n/// represented by a `usize`, then `None` is returned.\n#[inline]\nfn to_usize(&self) -> Option<usize>{\n        self.to_u64().as_ref().and_then(ToPrimitive::to_usize)\n    }","Real(LocalPath(\"src/cast.rs\"))"],"cast::cast":["/// Cast from one machine scalar to another.\n///\n/// # Examples\n///\n/// ```\n/// # use num_traits as num;\n/// let twenty: f32 = num::cast(0x14).unwrap();\n/// assert_eq!(twenty, 20f32);\n/// ```\n///\n#[inline]\npub fn cast<T: NumCast, U: NumCast>(n: T) -> Option<U>{\n    NumCast::from(n)\n}","Real(LocalPath(\"src/cast.rs\"))"],"clamp":["/// A value bounded by a minimum and a maximum\n///\n///  If input is less than min then this returns min.\n///  If input is greater than max then this returns max.\n///  Otherwise this returns input.\n///\n/// **Panics** in debug mode if `!(min <= max)`.\n#[inline]\npub fn clamp<T: PartialOrd>(input: T, min: T, max: T) -> T{\n    debug_assert!(min <= max, \"min must be less than or equal to max\");\n    if input < min {\n        min\n    } else if input > max {\n        max\n    } else {\n        input\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"clamp_max":["/// A value bounded by a maximum value\n///\n///  If input is greater than max then this returns max.\n///  Otherwise this returns input.\n///  `clamp_max(std::f32::NAN, 1.0)` preserves `NAN` different from `f32::max(std::f32::NAN, 1.0)`.\n///\n/// **Panics** in debug mode if `!(max == max)`. (This occurs if `max` is `NAN`.)\n#[inline]\npub fn clamp_max<T: PartialOrd>(input: T, max: T) -> T{\n    debug_assert!(max == max, \"max must not be NAN\");\n    if input > max {\n        max\n    } else {\n        input\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"clamp_min":["/// A value bounded by a minimum value\n///\n///  If input is less than min then this returns min.\n///  Otherwise this returns input.\n///  `clamp_min(std::f32::NAN, 1.0)` preserves `NAN` different from `f32::min(std::f32::NAN, 1.0)`.\n///\n/// **Panics** in debug mode if `!(min == min)`. (This occurs if `min` is `NAN`.)\n#[inline]\npub fn clamp_min<T: PartialOrd>(input: T, min: T) -> T{\n    debug_assert!(min == min, \"min must not be NAN\");\n    if input < min {\n        min\n    } else {\n        input\n    }\n}","Real(LocalPath(\"src/lib.rs\"))"],"float::Float":["/// Generic trait for floating point numbers\n///\n/// This trait is only available with the `std` feature, or with the `libm` feature otherwise.\n#[cfg(any(feature = \"std\", feature = \"libm\"))]\npub trait Float: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> {\n    /// Returns the `NaN` value.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let nan: f32 = Float::nan();\n    ///\n    /// assert!(nan.is_nan());\n    /// ```\n    fn nan() -> Self;\n    /// Returns the infinite value.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f32;\n    ///\n    /// let infinity: f32 = Float::infinity();\n    ///\n    /// assert!(infinity.is_infinite());\n    /// assert!(!infinity.is_finite());\n    /// assert!(infinity > f32::MAX);\n    /// ```\n    fn infinity() -> Self;\n    /// Returns the negative infinite value.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f32;\n    ///\n    /// let neg_infinity: f32 = Float::neg_infinity();\n    ///\n    /// assert!(neg_infinity.is_infinite());\n    /// assert!(!neg_infinity.is_finite());\n    /// assert!(neg_infinity < f32::MIN);\n    /// ```\n    fn neg_infinity() -> Self;\n    /// Returns `-0.0`.\n    ///\n    /// ```\n    /// use num_traits::{Zero, Float};\n    ///\n    /// let inf: f32 = Float::infinity();\n    /// let zero: f32 = Zero::zero();\n    /// let neg_zero: f32 = Float::neg_zero();\n    ///\n    /// assert_eq!(zero, neg_zero);\n    /// assert_eq!(7.0f32/inf, zero);\n    /// assert_eq!(zero * 10.0, zero);\n    /// ```\n    fn neg_zero() -> Self;\n\n    /// Returns the smallest finite value that this type can represent.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let x: f64 = Float::min_value();\n    ///\n    /// assert_eq!(x, f64::MIN);\n    /// ```\n    fn min_value() -> Self;\n\n    /// Returns the smallest positive, normalized value that this type can represent.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let x: f64 = Float::min_positive_value();\n    ///\n    /// assert_eq!(x, f64::MIN_POSITIVE);\n    /// ```\n    fn min_positive_value() -> Self;\n\n    /// Returns epsilon, a small positive value.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let x: f64 = Float::epsilon();\n    ///\n    /// assert_eq!(x, f64::EPSILON);\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// The default implementation will panic if `f32::EPSILON` cannot\n    /// be cast to `Self`.\n    fn epsilon() -> Self {\n        Self::from(f32::EPSILON).expect(\"Unable to cast from f32::EPSILON\")\n    }\n\n    /// Returns the largest finite value that this type can represent.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let x: f64 = Float::max_value();\n    /// assert_eq!(x, f64::MAX);\n    /// ```\n    fn max_value() -> Self;\n\n    /// Returns `true` if this value is `NaN` and false otherwise.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let nan = f64::NAN;\n    /// let f = 7.0;\n    ///\n    /// assert!(nan.is_nan());\n    /// assert!(!f.is_nan());\n    /// ```\n    fn is_nan(self) -> bool;\n\n    /// Returns `true` if this value is positive infinity or negative infinity and\n    /// false otherwise.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f32;\n    ///\n    /// let f = 7.0f32;\n    /// let inf: f32 = Float::infinity();\n    /// let neg_inf: f32 = Float::neg_infinity();\n    /// let nan: f32 = f32::NAN;\n    ///\n    /// assert!(!f.is_infinite());\n    /// assert!(!nan.is_infinite());\n    ///\n    /// assert!(inf.is_infinite());\n    /// assert!(neg_inf.is_infinite());\n    /// ```\n    fn is_infinite(self) -> bool;\n\n    /// Returns `true` if this number is neither infinite nor `NaN`.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f32;\n    ///\n    /// let f = 7.0f32;\n    /// let inf: f32 = Float::infinity();\n    /// let neg_inf: f32 = Float::neg_infinity();\n    /// let nan: f32 = f32::NAN;\n    ///\n    /// assert!(f.is_finite());\n    ///\n    /// assert!(!nan.is_finite());\n    /// assert!(!inf.is_finite());\n    /// assert!(!neg_inf.is_finite());\n    /// ```\n    fn is_finite(self) -> bool;\n\n    /// Returns `true` if the number is neither zero, infinite,\n    /// [subnormal][subnormal], or `NaN`.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f32;\n    ///\n    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n    /// let max = f32::MAX;\n    /// let lower_than_min = 1.0e-40_f32;\n    /// let zero = 0.0f32;\n    ///\n    /// assert!(min.is_normal());\n    /// assert!(max.is_normal());\n    ///\n    /// assert!(!zero.is_normal());\n    /// assert!(!f32::NAN.is_normal());\n    /// assert!(!f32::INFINITY.is_normal());\n    /// // Values between `0` and `min` are Subnormal.\n    /// assert!(!lower_than_min.is_normal());\n    /// ```\n    /// [subnormal]: http://en.wikipedia.org/wiki/Denormal_number\n    fn is_normal(self) -> bool;\n\n    /// Returns the floating point category of the number. If only one property\n    /// is going to be tested, it is generally faster to use the specific\n    /// predicate instead.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::num::FpCategory;\n    /// use std::f32;\n    ///\n    /// let num = 12.4f32;\n    /// let inf = f32::INFINITY;\n    ///\n    /// assert_eq!(num.classify(), FpCategory::Normal);\n    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n    /// ```\n    fn classify(self) -> FpCategory;\n\n    /// Returns the largest integer less than or equal to a number.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let f = 3.99;\n    /// let g = 3.0;\n    ///\n    /// assert_eq!(f.floor(), 3.0);\n    /// assert_eq!(g.floor(), 3.0);\n    /// ```\n    fn floor(self) -> Self;\n\n    /// Returns the smallest integer greater than or equal to a number.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let f = 3.01;\n    /// let g = 4.0;\n    ///\n    /// assert_eq!(f.ceil(), 4.0);\n    /// assert_eq!(g.ceil(), 4.0);\n    /// ```\n    fn ceil(self) -> Self;\n\n    /// Returns the nearest integer to a number. Round half-way cases away from\n    /// `0.0`.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let f = 3.3;\n    /// let g = -3.3;\n    ///\n    /// assert_eq!(f.round(), 3.0);\n    /// assert_eq!(g.round(), -3.0);\n    /// ```\n    fn round(self) -> Self;\n\n    /// Return the integer part of a number.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let f = 3.3;\n    /// let g = -3.7;\n    ///\n    /// assert_eq!(f.trunc(), 3.0);\n    /// assert_eq!(g.trunc(), -3.0);\n    /// ```\n    fn trunc(self) -> Self;\n\n    /// Returns the fractional part of a number.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let x = 3.5;\n    /// let y = -3.5;\n    /// let abs_difference_x = (x.fract() - 0.5).abs();\n    /// let abs_difference_y = (y.fract() - (-0.5)).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    /// ```\n    fn fract(self) -> Self;\n\n    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n    /// number is `Float::nan()`.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let x = 3.5;\n    /// let y = -3.5;\n    ///\n    /// let abs_difference_x = (x.abs() - x).abs();\n    /// let abs_difference_y = (y.abs() - (-y)).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    ///\n    /// assert!(f64::NAN.abs().is_nan());\n    /// ```\n    fn abs(self) -> Self;\n\n    /// Returns a number that represents the sign of `self`.\n    ///\n    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n    /// - `Float::nan()` if the number is `Float::nan()`\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let f = 3.5;\n    ///\n    /// assert_eq!(f.signum(), 1.0);\n    /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);\n    ///\n    /// assert!(f64::NAN.signum().is_nan());\n    /// ```\n    fn signum(self) -> Self;\n\n    /// Returns `true` if `self` is positive, including `+0.0`,\n    /// `Float::infinity()`, and since Rust 1.20 also `Float::nan()`.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let neg_nan: f64 = -f64::NAN;\n    ///\n    /// let f = 7.0;\n    /// let g = -7.0;\n    ///\n    /// assert!(f.is_sign_positive());\n    /// assert!(!g.is_sign_positive());\n    /// assert!(!neg_nan.is_sign_positive());\n    /// ```\n    fn is_sign_positive(self) -> bool;\n\n    /// Returns `true` if `self` is negative, including `-0.0`,\n    /// `Float::neg_infinity()`, and since Rust 1.20 also `-Float::nan()`.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let nan: f64 = f64::NAN;\n    ///\n    /// let f = 7.0;\n    /// let g = -7.0;\n    ///\n    /// assert!(!f.is_sign_negative());\n    /// assert!(g.is_sign_negative());\n    /// assert!(!nan.is_sign_negative());\n    /// ```\n    fn is_sign_negative(self) -> bool;\n\n    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n    /// error, yielding a more accurate result than an unfused multiply-add.\n    ///\n    /// Using `mul_add` can be more performant than an unfused multiply-add if\n    /// the target architecture has a dedicated `fma` CPU instruction.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let m = 10.0;\n    /// let x = 4.0;\n    /// let b = 60.0;\n    ///\n    /// // 100.0\n    /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn mul_add(self, a: Self, b: Self) -> Self;\n    /// Take the reciprocal (inverse) of a number, `1/x`.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let x = 2.0;\n    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn recip(self) -> Self;\n\n    /// Raise a number to an integer power.\n    ///\n    /// Using this function is generally faster than using `powf`\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let x = 2.0;\n    /// let abs_difference = (x.powi(2) - x*x).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn powi(self, n: i32) -> Self;\n\n    /// Raise a number to a floating point power.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let x = 2.0;\n    /// let abs_difference = (x.powf(2.0) - x*x).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn powf(self, n: Self) -> Self;\n\n    /// Take the square root of a number.\n    ///\n    /// Returns NaN if `self` is a negative number.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let positive = 4.0;\n    /// let negative = -4.0;\n    ///\n    /// let abs_difference = (positive.sqrt() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// assert!(negative.sqrt().is_nan());\n    /// ```\n    fn sqrt(self) -> Self;\n\n    /// Returns `e^(self)`, (the exponential function).\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let one = 1.0;\n    /// // e^1\n    /// let e = one.exp();\n    ///\n    /// // ln(e) - 1 == 0\n    /// let abs_difference = (e.ln() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn exp(self) -> Self;\n\n    /// Returns `2^(self)`.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let f = 2.0;\n    ///\n    /// // 2^2 - 4 == 0\n    /// let abs_difference = (f.exp2() - 4.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn exp2(self) -> Self;\n\n    /// Returns the natural logarithm of the number.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let one = 1.0;\n    /// // e^1\n    /// let e = one.exp();\n    ///\n    /// // ln(e) - 1 == 0\n    /// let abs_difference = (e.ln() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn ln(self) -> Self;\n\n    /// Returns the logarithm of the number with respect to an arbitrary base.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let ten = 10.0;\n    /// let two = 2.0;\n    ///\n    /// // log10(10) - 1 == 0\n    /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();\n    ///\n    /// // log2(2) - 1 == 0\n    /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();\n    ///\n    /// assert!(abs_difference_10 < 1e-10);\n    /// assert!(abs_difference_2 < 1e-10);\n    /// ```\n    fn log(self, base: Self) -> Self;\n\n    /// Returns the base 2 logarithm of the number.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let two = 2.0;\n    ///\n    /// // log2(2) - 1 == 0\n    /// let abs_difference = (two.log2() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn log2(self) -> Self;\n\n    /// Returns the base 10 logarithm of the number.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let ten = 10.0;\n    ///\n    /// // log10(10) - 1 == 0\n    /// let abs_difference = (ten.log10() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn log10(self) -> Self;\n\n    /// Converts radians to degrees.\n    ///\n    /// ```\n    /// use std::f64::consts;\n    ///\n    /// let angle = consts::PI;\n    ///\n    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[inline]\n    fn to_degrees(self) -> Self {\n        let halfpi = Self::zero().acos();\n        let ninety = Self::from(90u8).unwrap();\n        self * ninety / halfpi\n    }\n\n    /// Converts degrees to radians.\n    ///\n    /// ```\n    /// use std::f64::consts;\n    ///\n    /// let angle = 180.0_f64;\n    ///\n    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[inline]\n    fn to_radians(self) -> Self {\n        let halfpi = Self::zero().acos();\n        let ninety = Self::from(90u8).unwrap();\n        self * halfpi / ninety\n    }\n\n    /// Returns the maximum of the two numbers.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let x = 1.0;\n    /// let y = 2.0;\n    ///\n    /// assert_eq!(x.max(y), y);\n    /// ```\n    fn max(self, other: Self) -> Self;\n\n    /// Returns the minimum of the two numbers.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let x = 1.0;\n    /// let y = 2.0;\n    ///\n    /// assert_eq!(x.min(y), x);\n    /// ```\n    fn min(self, other: Self) -> Self;\n\n    /// The positive difference of two numbers.\n    ///\n    /// * If `self <= other`: `0:0`\n    /// * Else: `self - other`\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let x = 3.0;\n    /// let y = -3.0;\n    ///\n    /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n    /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    /// ```\n    fn abs_sub(self, other: Self) -> Self;\n\n    /// Take the cubic root of a number.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let x = 8.0;\n    ///\n    /// // x^(1/3) - 2 == 0\n    /// let abs_difference = (x.cbrt() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn cbrt(self) -> Self;\n\n    /// Calculate the length of the hypotenuse of a right-angle triangle given\n    /// legs of length `x` and `y`.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let x = 2.0;\n    /// let y = 3.0;\n    ///\n    /// // sqrt(x^2 + y^2)\n    /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn hypot(self, other: Self) -> Self;\n\n    /// Computes the sine of a number (in radians).\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let x = f64::consts::PI/2.0;\n    ///\n    /// let abs_difference = (x.sin() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn sin(self) -> Self;\n\n    /// Computes the cosine of a number (in radians).\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let x = 2.0*f64::consts::PI;\n    ///\n    /// let abs_difference = (x.cos() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn cos(self) -> Self;\n\n    /// Computes the tangent of a number (in radians).\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let x = f64::consts::PI/4.0;\n    /// let abs_difference = (x.tan() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-14);\n    /// ```\n    fn tan(self) -> Self;\n\n    /// Computes the arcsine of a number. Return value is in radians in\n    /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n    /// [-1, 1].\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let f = f64::consts::PI / 2.0;\n    ///\n    /// // asin(sin(pi/2))\n    /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn asin(self) -> Self;\n\n    /// Computes the arccosine of a number. Return value is in radians in\n    /// the range [0, pi] or NaN if the number is outside the range\n    /// [-1, 1].\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let f = f64::consts::PI / 4.0;\n    ///\n    /// // acos(cos(pi/4))\n    /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn acos(self) -> Self;\n\n    /// Computes the arctangent of a number. Return value is in radians in the\n    /// range [-pi/2, pi/2];\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let f = 1.0;\n    ///\n    /// // atan(tan(1))\n    /// let abs_difference = (f.tan().atan() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn atan(self) -> Self;\n\n    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).\n    ///\n    /// * `x = 0`, `y = 0`: `0`\n    /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n    /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`\n    /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let pi = f64::consts::PI;\n    /// // All angles from horizontal right (+x)\n    /// // 45 deg counter-clockwise\n    /// let x1 = 3.0;\n    /// let y1 = -3.0;\n    ///\n    /// // 135 deg clockwise\n    /// let x2 = -3.0;\n    /// let y2 = 3.0;\n    ///\n    /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n    /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n    ///\n    /// assert!(abs_difference_1 < 1e-10);\n    /// assert!(abs_difference_2 < 1e-10);\n    /// ```\n    fn atan2(self, other: Self) -> Self;\n\n    /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n    /// `(sin(x), cos(x))`.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let x = f64::consts::PI/4.0;\n    /// let f = x.sin_cos();\n    ///\n    /// let abs_difference_0 = (f.0 - x.sin()).abs();\n    /// let abs_difference_1 = (f.1 - x.cos()).abs();\n    ///\n    /// assert!(abs_difference_0 < 1e-10);\n    /// assert!(abs_difference_0 < 1e-10);\n    /// ```\n    fn sin_cos(self) -> (Self, Self);\n\n    /// Returns `e^(self) - 1` in a way that is accurate even if the\n    /// number is close to zero.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let x = 7.0;\n    ///\n    /// // e^(ln(7)) - 1\n    /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn exp_m1(self) -> Self;\n\n    /// Returns `ln(1+n)` (natural logarithm) more accurately than if\n    /// the operations were performed separately.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let x = f64::consts::E - 1.0;\n    ///\n    /// // ln(1 + (e - 1)) == ln(e) == 1\n    /// let abs_difference = (x.ln_1p() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn ln_1p(self) -> Self;\n\n    /// Hyperbolic sine function.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let e = f64::consts::E;\n    /// let x = 1.0;\n    ///\n    /// let f = x.sinh();\n    /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n    /// let g = (e*e - 1.0)/(2.0*e);\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn sinh(self) -> Self;\n\n    /// Hyperbolic cosine function.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let e = f64::consts::E;\n    /// let x = 1.0;\n    /// let f = x.cosh();\n    /// // Solving cosh() at 1 gives this result\n    /// let g = (e*e + 1.0)/(2.0*e);\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// // Same result\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    fn cosh(self) -> Self;\n\n    /// Hyperbolic tangent function.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let e = f64::consts::E;\n    /// let x = 1.0;\n    ///\n    /// let f = x.tanh();\n    /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n    /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    fn tanh(self) -> Self;\n\n    /// Inverse hyperbolic sine function.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let x = 1.0;\n    /// let f = x.sinh().asinh();\n    ///\n    /// let abs_difference = (f - x).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    fn asinh(self) -> Self;\n\n    /// Inverse hyperbolic cosine function.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let x = 1.0;\n    /// let f = x.cosh().acosh();\n    ///\n    /// let abs_difference = (f - x).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    fn acosh(self) -> Self;\n\n    /// Inverse hyperbolic tangent function.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    /// use std::f64;\n    ///\n    /// let e = f64::consts::E;\n    /// let f = e.tanh().atanh();\n    ///\n    /// let abs_difference = (f - e).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    fn atanh(self) -> Self;\n\n    /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n    /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let num = 2.0f32;\n    ///\n    /// // (8388608, -22, 1)\n    /// let (mantissa, exponent, sign) = Float::integer_decode(num);\n    /// let sign_f = sign as f32;\n    /// let mantissa_f = mantissa as f32;\n    /// let exponent_f = num.powf(exponent as f32);\n    ///\n    /// // 1 * 8388608 * 2^(-22) == 2\n    /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn integer_decode(self) -> (u64, i16, i8);\n\n    /// Returns a number composed of the magnitude of `self` and the sign of\n    /// `sign`.\n    ///\n    /// Equal to `self` if the sign of `self` and `sign` are the same, otherwise\n    /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of\n    /// `sign` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::Float;\n    ///\n    /// let f = 3.5_f32;\n    ///\n    /// assert_eq!(f.copysign(0.42), 3.5_f32);\n    /// assert_eq!(f.copysign(-0.42), -3.5_f32);\n    /// assert_eq!((-f).copysign(0.42), 3.5_f32);\n    /// assert_eq!((-f).copysign(-0.42), -3.5_f32);\n    ///\n    /// assert!(f32::nan().copysign(1.0).is_nan());\n    /// ```\n    fn copysign(self, sign: Self) -> Self {\n        if self.is_sign_negative() == sign.is_sign_negative() {\n            self\n        } else {\n            self.neg()\n        }\n    }\n}","Real(LocalPath(\"src/float.rs\"))"],"float::Float::copysign":["/// Returns a number composed of the magnitude of `self` and the sign of\n/// `sign`.\n///\n/// Equal to `self` if the sign of `self` and `sign` are the same, otherwise\n/// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of\n/// `sign` is returned.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::Float;\n///\n/// let f = 3.5_f32;\n///\n/// assert_eq!(f.copysign(0.42), 3.5_f32);\n/// assert_eq!(f.copysign(-0.42), -3.5_f32);\n/// assert_eq!((-f).copysign(0.42), 3.5_f32);\n/// assert_eq!((-f).copysign(-0.42), -3.5_f32);\n///\n/// assert!(f32::nan().copysign(1.0).is_nan());\n/// ```\nfn copysign(self, sign: Self) -> Self{\n        if self.is_sign_negative() == sign.is_sign_negative() {\n            self\n        } else {\n            self.neg()\n        }\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::Float::epsilon":["/// Returns epsilon, a small positive value.\n///\n/// ```\n/// use num_traits::Float;\n/// use std::f64;\n///\n/// let x: f64 = Float::epsilon();\n///\n/// assert_eq!(x, f64::EPSILON);\n/// ```\n///\n/// # Panics\n///\n/// The default implementation will panic if `f32::EPSILON` cannot\n/// be cast to `Self`.\nfn epsilon() -> Self{\n        Self::from(f32::EPSILON).expect(\"Unable to cast from f32::EPSILON\")\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::Float::to_degrees":["/// Converts radians to degrees.\n///\n/// ```\n/// use std::f64::consts;\n///\n/// let angle = consts::PI;\n///\n/// let abs_difference = (angle.to_degrees() - 180.0).abs();\n///\n/// assert!(abs_difference < 1e-10);\n/// ```\n#[inline]\nfn to_degrees(self) -> Self{\n        let halfpi = Self::zero().acos();\n        let ninety = Self::from(90u8).unwrap();\n        self * ninety / halfpi\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::Float::to_radians":["/// Converts degrees to radians.\n///\n/// ```\n/// use std::f64::consts;\n///\n/// let angle = 180.0_f64;\n///\n/// let abs_difference = (angle.to_radians() - consts::PI).abs();\n///\n/// assert!(abs_difference < 1e-10);\n/// ```\n#[inline]\nfn to_radians(self) -> Self{\n        let halfpi = Self::zero().acos();\n        let ninety = Self::from(90u8).unwrap();\n        self * halfpi / ninety\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatConst":["#[allow(non_snake_case)]\npub trait FloatConst {\n            $(#[$doc] fn $constant() -> Self;)+\n            #[doc = \"Return the full circle constant ``.\"]\n            #[inline]\n            fn TAU() -> Self where Self: Sized + Add<Self, Output = Self> {\n                Self::PI() + Self::PI()\n            }\n            #[doc = \"Return `log10(2.0)`.\"]\n            #[inline]\n            fn LOG10_2() -> Self where Self: Sized + Div<Self, Output = Self> {\n                Self::LN_2() / Self::LN_10()\n            }\n            #[doc = \"Return `log2(10.0)`.\"]\n            #[inline]\n            fn LOG2_10() -> Self where Self: Sized + Div<Self, Output = Self> {\n                Self::LN_10() / Self::LN_2()\n            }\n        }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatConst::LOG10_2":["#[doc = \"Return `log10(2.0)`.\"]\n#[inline]\nfn LOG10_2() -> Self where Self: Sized + Div<Self, Output = Self>{\n                Self::LN_2() / Self::LN_10()\n            }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatConst::LOG2_10":["#[doc = \"Return `log2(10.0)`.\"]\n#[inline]\nfn LOG2_10() -> Self where Self: Sized + Div<Self, Output = Self>{\n                Self::LN_10() / Self::LN_2()\n            }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatConst::TAU":["#[doc = \"Return the full circle constant ``.\"]\n#[inline]\nfn TAU() -> Self where Self: Sized + Add<Self, Output = Self>{\n                Self::PI() + Self::PI()\n            }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore":["/// Generic trait for floating point numbers that works with `no_std`.\n///\n/// This trait implements a subset of the `Float` trait.\npub trait FloatCore: Num + NumCast + Neg<Output = Self> + PartialOrd + Copy {\n    /// Returns positive infinity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T) {\n    ///     assert!(T::infinity() == x);\n    /// }\n    ///\n    /// check(f32::INFINITY);\n    /// check(f64::INFINITY);\n    /// ```\n    fn infinity() -> Self;\n\n    /// Returns negative infinity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T) {\n    ///     assert!(T::neg_infinity() == x);\n    /// }\n    ///\n    /// check(f32::NEG_INFINITY);\n    /// check(f64::NEG_INFINITY);\n    /// ```\n    fn neg_infinity() -> Self;\n\n    /// Returns NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    ///\n    /// fn check<T: FloatCore>() {\n    ///     let n = T::nan();\n    ///     assert!(n != n);\n    /// }\n    ///\n    /// check::<f32>();\n    /// check::<f64>();\n    /// ```\n    fn nan() -> Self;\n\n    /// Returns `-0.0`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(n: T) {\n    ///     let z = T::neg_zero();\n    ///     assert!(z.is_zero());\n    ///     assert!(T::one() / z == n);\n    /// }\n    ///\n    /// check(f32::NEG_INFINITY);\n    /// check(f64::NEG_INFINITY);\n    /// ```\n    fn neg_zero() -> Self;\n\n    /// Returns the smallest finite value that this type can represent.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T) {\n    ///     assert!(T::min_value() == x);\n    /// }\n    ///\n    /// check(f32::MIN);\n    /// check(f64::MIN);\n    /// ```\n    fn min_value() -> Self;\n\n    /// Returns the smallest positive, normalized value that this type can represent.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T) {\n    ///     assert!(T::min_positive_value() == x);\n    /// }\n    ///\n    /// check(f32::MIN_POSITIVE);\n    /// check(f64::MIN_POSITIVE);\n    /// ```\n    fn min_positive_value() -> Self;\n\n    /// Returns epsilon, a small positive value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T) {\n    ///     assert!(T::epsilon() == x);\n    /// }\n    ///\n    /// check(f32::EPSILON);\n    /// check(f64::EPSILON);\n    /// ```\n    fn epsilon() -> Self;\n\n    /// Returns the largest finite value that this type can represent.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T) {\n    ///     assert!(T::max_value() == x);\n    /// }\n    ///\n    /// check(f32::MAX);\n    /// check(f64::MAX);\n    /// ```\n    fn max_value() -> Self;\n\n    /// Returns `true` if the number is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, p: bool) {\n    ///     assert!(x.is_nan() == p);\n    /// }\n    ///\n    /// check(f32::NAN, true);\n    /// check(f32::INFINITY, false);\n    /// check(f64::NAN, true);\n    /// check(0.0f64, false);\n    /// ```\n    #[inline]\n    fn is_nan(self) -> bool {\n        self != self\n    }\n\n    /// Returns `true` if the number is infinite.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, p: bool) {\n    ///     assert!(x.is_infinite() == p);\n    /// }\n    ///\n    /// check(f32::INFINITY, true);\n    /// check(f32::NEG_INFINITY, true);\n    /// check(f32::NAN, false);\n    /// check(f64::INFINITY, true);\n    /// check(f64::NEG_INFINITY, true);\n    /// check(0.0f64, false);\n    /// ```\n    #[inline]\n    fn is_infinite(self) -> bool {\n        self == Self::infinity() || self == Self::neg_infinity()\n    }\n\n    /// Returns `true` if the number is neither infinite or NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, p: bool) {\n    ///     assert!(x.is_finite() == p);\n    /// }\n    ///\n    /// check(f32::INFINITY, false);\n    /// check(f32::MAX, true);\n    /// check(f64::NEG_INFINITY, false);\n    /// check(f64::MIN_POSITIVE, true);\n    /// check(f64::NAN, false);\n    /// ```\n    #[inline]\n    fn is_finite(self) -> bool {\n        !(self.is_nan() || self.is_infinite())\n    }\n\n    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, p: bool) {\n    ///     assert!(x.is_normal() == p);\n    /// }\n    ///\n    /// check(f32::INFINITY, false);\n    /// check(f32::MAX, true);\n    /// check(f64::NEG_INFINITY, false);\n    /// check(f64::MIN_POSITIVE, true);\n    /// check(0.0f64, false);\n    /// ```\n    #[inline]\n    fn is_normal(self) -> bool {\n        self.classify() == FpCategory::Normal\n    }\n\n    /// Returns the floating point category of the number. If only one property\n    /// is going to be tested, it is generally faster to use the specific\n    /// predicate instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    /// use std::num::FpCategory;\n    ///\n    /// fn check<T: FloatCore>(x: T, c: FpCategory) {\n    ///     assert!(x.classify() == c);\n    /// }\n    ///\n    /// check(f32::INFINITY, FpCategory::Infinite);\n    /// check(f32::MAX, FpCategory::Normal);\n    /// check(f64::NAN, FpCategory::Nan);\n    /// check(f64::MIN_POSITIVE, FpCategory::Normal);\n    /// check(f64::MIN_POSITIVE / 2.0, FpCategory::Subnormal);\n    /// check(0.0f64, FpCategory::Zero);\n    /// ```\n    fn classify(self) -> FpCategory;\n\n    /// Returns the largest integer less than or equal to a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, y: T) {\n    ///     assert!(x.floor() == y);\n    /// }\n    ///\n    /// check(f32::INFINITY, f32::INFINITY);\n    /// check(0.9f32, 0.0);\n    /// check(1.0f32, 1.0);\n    /// check(1.1f32, 1.0);\n    /// check(-0.0f64, 0.0);\n    /// check(-0.9f64, -1.0);\n    /// check(-1.0f64, -1.0);\n    /// check(-1.1f64, -2.0);\n    /// check(f64::MIN, f64::MIN);\n    /// ```\n    #[inline]\n    fn floor(self) -> Self {\n        let f = self.fract();\n        if f.is_nan() || f.is_zero() {\n            self\n        } else if self < Self::zero() {\n            self - f - Self::one()\n        } else {\n            self - f\n        }\n    }\n\n    /// Returns the smallest integer greater than or equal to a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, y: T) {\n    ///     assert!(x.ceil() == y);\n    /// }\n    ///\n    /// check(f32::INFINITY, f32::INFINITY);\n    /// check(0.9f32, 1.0);\n    /// check(1.0f32, 1.0);\n    /// check(1.1f32, 2.0);\n    /// check(-0.0f64, 0.0);\n    /// check(-0.9f64, -0.0);\n    /// check(-1.0f64, -1.0);\n    /// check(-1.1f64, -1.0);\n    /// check(f64::MIN, f64::MIN);\n    /// ```\n    #[inline]\n    fn ceil(self) -> Self {\n        let f = self.fract();\n        if f.is_nan() || f.is_zero() {\n            self\n        } else if self > Self::zero() {\n            self - f + Self::one()\n        } else {\n            self - f\n        }\n    }\n\n    /// Returns the nearest integer to a number. Round half-way cases away from `0.0`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, y: T) {\n    ///     assert!(x.round() == y);\n    /// }\n    ///\n    /// check(f32::INFINITY, f32::INFINITY);\n    /// check(0.4f32, 0.0);\n    /// check(0.5f32, 1.0);\n    /// check(0.6f32, 1.0);\n    /// check(-0.4f64, 0.0);\n    /// check(-0.5f64, -1.0);\n    /// check(-0.6f64, -1.0);\n    /// check(f64::MIN, f64::MIN);\n    /// ```\n    #[inline]\n    fn round(self) -> Self {\n        let one = Self::one();\n        let h = Self::from(0.5).expect(\"Unable to cast from 0.5\");\n        let f = self.fract();\n        if f.is_nan() || f.is_zero() {\n            self\n        } else if self > Self::zero() {\n            if f < h {\n                self - f\n            } else {\n                self - f + one\n            }\n        } else {\n            if -f < h {\n                self - f\n            } else {\n                self - f - one\n            }\n        }\n    }\n\n    /// Return the integer part of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, y: T) {\n    ///     assert!(x.trunc() == y);\n    /// }\n    ///\n    /// check(f32::INFINITY, f32::INFINITY);\n    /// check(0.9f32, 0.0);\n    /// check(1.0f32, 1.0);\n    /// check(1.1f32, 1.0);\n    /// check(-0.0f64, 0.0);\n    /// check(-0.9f64, -0.0);\n    /// check(-1.0f64, -1.0);\n    /// check(-1.1f64, -1.0);\n    /// check(f64::MIN, f64::MIN);\n    /// ```\n    #[inline]\n    fn trunc(self) -> Self {\n        let f = self.fract();\n        if f.is_nan() {\n            self\n        } else {\n            self - f\n        }\n    }\n\n    /// Returns the fractional part of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, y: T) {\n    ///     assert!(x.fract() == y);\n    /// }\n    ///\n    /// check(f32::MAX, 0.0);\n    /// check(0.75f32, 0.75);\n    /// check(1.0f32, 0.0);\n    /// check(1.25f32, 0.25);\n    /// check(-0.0f64, 0.0);\n    /// check(-0.75f64, -0.75);\n    /// check(-1.0f64, 0.0);\n    /// check(-1.25f64, -0.25);\n    /// check(f64::MIN, 0.0);\n    /// ```\n    #[inline]\n    fn fract(self) -> Self {\n        if self.is_zero() {\n            Self::zero()\n        } else {\n            self % Self::one()\n        }\n    }\n\n    /// Computes the absolute value of `self`. Returns `FloatCore::nan()` if the\n    /// number is `FloatCore::nan()`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, y: T) {\n    ///     assert!(x.abs() == y);\n    /// }\n    ///\n    /// check(f32::INFINITY, f32::INFINITY);\n    /// check(1.0f32, 1.0);\n    /// check(0.0f64, 0.0);\n    /// check(-0.0f64, 0.0);\n    /// check(-1.0f64, 1.0);\n    /// check(f64::MIN, f64::MAX);\n    /// ```\n    #[inline]\n    fn abs(self) -> Self {\n        if self.is_sign_positive() {\n            return self;\n        }\n        if self.is_sign_negative() {\n            return -self;\n        }\n        Self::nan()\n    }\n\n    /// Returns a number that represents the sign of `self`.\n    ///\n    /// - `1.0` if the number is positive, `+0.0` or `FloatCore::infinity()`\n    /// - `-1.0` if the number is negative, `-0.0` or `FloatCore::neg_infinity()`\n    /// - `FloatCore::nan()` if the number is `FloatCore::nan()`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, y: T) {\n    ///     assert!(x.signum() == y);\n    /// }\n    ///\n    /// check(f32::INFINITY, 1.0);\n    /// check(3.0f32, 1.0);\n    /// check(0.0f32, 1.0);\n    /// check(-0.0f64, -1.0);\n    /// check(-3.0f64, -1.0);\n    /// check(f64::MIN, -1.0);\n    /// ```\n    #[inline]\n    fn signum(self) -> Self {\n        if self.is_nan() {\n            Self::nan()\n        } else if self.is_sign_negative() {\n            -Self::one()\n        } else {\n            Self::one()\n        }\n    }\n\n    /// Returns `true` if `self` is positive, including `+0.0` and\n    /// `FloatCore::infinity()`, and since Rust 1.20 also\n    /// `FloatCore::nan()`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, p: bool) {\n    ///     assert!(x.is_sign_positive() == p);\n    /// }\n    ///\n    /// check(f32::INFINITY, true);\n    /// check(f32::MAX, true);\n    /// check(0.0f32, true);\n    /// check(-0.0f64, false);\n    /// check(f64::NEG_INFINITY, false);\n    /// check(f64::MIN_POSITIVE, true);\n    /// check(-f64::NAN, false);\n    /// ```\n    #[inline]\n    fn is_sign_positive(self) -> bool {\n        !self.is_sign_negative()\n    }\n\n    /// Returns `true` if `self` is negative, including `-0.0` and\n    /// `FloatCore::neg_infinity()`, and since Rust 1.20 also\n    /// `-FloatCore::nan()`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, p: bool) {\n    ///     assert!(x.is_sign_negative() == p);\n    /// }\n    ///\n    /// check(f32::INFINITY, false);\n    /// check(f32::MAX, false);\n    /// check(0.0f32, false);\n    /// check(-0.0f64, true);\n    /// check(f64::NEG_INFINITY, true);\n    /// check(f64::MIN_POSITIVE, false);\n    /// check(f64::NAN, false);\n    /// ```\n    #[inline]\n    fn is_sign_negative(self) -> bool {\n        let (_, _, sign) = self.integer_decode();\n        sign < 0\n    }\n\n    /// Returns the minimum of the two numbers.\n    ///\n    /// If one of the arguments is NaN, then the other argument is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, y: T, min: T) {\n    ///     assert!(x.min(y) == min);\n    /// }\n    ///\n    /// check(1.0f32, 2.0, 1.0);\n    /// check(f32::NAN, 2.0, 2.0);\n    /// check(1.0f64, -2.0, -2.0);\n    /// check(1.0f64, f64::NAN, 1.0);\n    /// ```\n    #[inline]\n    fn min(self, other: Self) -> Self {\n        if self.is_nan() {\n            return other;\n        }\n        if other.is_nan() {\n            return self;\n        }\n        if self < other {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// Returns the maximum of the two numbers.\n    ///\n    /// If one of the arguments is NaN, then the other argument is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, y: T, max: T) {\n    ///     assert!(x.max(y) == max);\n    /// }\n    ///\n    /// check(1.0f32, 2.0, 2.0);\n    /// check(1.0f32, f32::NAN, 1.0);\n    /// check(-1.0f64, 2.0, 2.0);\n    /// check(-1.0f64, f64::NAN, -1.0);\n    /// ```\n    #[inline]\n    fn max(self, other: Self) -> Self {\n        if self.is_nan() {\n            return other;\n        }\n        if other.is_nan() {\n            return self;\n        }\n        if self > other {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// Returns the reciprocal (multiplicative inverse) of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, y: T) {\n    ///     assert!(x.recip() == y);\n    ///     assert!(y.recip() == x);\n    /// }\n    ///\n    /// check(f32::INFINITY, 0.0);\n    /// check(2.0f32, 0.5);\n    /// check(-0.25f64, -4.0);\n    /// check(-0.0f64, f64::NEG_INFINITY);\n    /// ```\n    #[inline]\n    fn recip(self) -> Self {\n        Self::one() / self\n    }\n\n    /// Raise a number to an integer power.\n    ///\n    /// Using this function is generally faster than using `powf`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    ///\n    /// fn check<T: FloatCore>(x: T, exp: i32, powi: T) {\n    ///     assert!(x.powi(exp) == powi);\n    /// }\n    ///\n    /// check(9.0f32, 2, 81.0);\n    /// check(1.0f32, -2, 1.0);\n    /// check(10.0f64, 20, 1e20);\n    /// check(4.0f64, -2, 0.0625);\n    /// check(-1.0f64, std::i32::MIN, 1.0);\n    /// ```\n    #[inline]\n    fn powi(mut self, mut exp: i32) -> Self {\n        if exp < 0 {\n            exp = exp.wrapping_neg();\n            self = self.recip();\n        }\n        // It should always be possible to convert a positive `i32` to a `usize`.\n        // Note, `i32::MIN` will wrap and still be negative, so we need to convert\n        // to `u32` without sign-extension before growing to `usize`.\n        super::pow(self, (exp as u32).to_usize().unwrap())\n    }\n\n    /// Converts to degrees, assuming the number is in radians.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(rad: T, deg: T) {\n    ///     assert!(rad.to_degrees() == deg);\n    /// }\n    ///\n    /// check(0.0f32, 0.0);\n    /// check(f32::consts::PI, 180.0);\n    /// check(f64::consts::FRAC_PI_4, 45.0);\n    /// check(f64::INFINITY, f64::INFINITY);\n    /// ```\n    fn to_degrees(self) -> Self;\n\n    /// Converts to radians, assuming the number is in degrees.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(deg: T, rad: T) {\n    ///     assert!(deg.to_radians() == rad);\n    /// }\n    ///\n    /// check(0.0f32, 0.0);\n    /// check(180.0, f32::consts::PI);\n    /// check(45.0, f64::consts::FRAC_PI_4);\n    /// check(f64::INFINITY, f64::INFINITY);\n    /// ```\n    fn to_radians(self) -> Self;\n\n    /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n    /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::float::FloatCore;\n    /// use std::{f32, f64};\n    ///\n    /// fn check<T: FloatCore>(x: T, m: u64, e: i16, s:i8) {\n    ///     let (mantissa, exponent, sign) = x.integer_decode();\n    ///     assert_eq!(mantissa, m);\n    ///     assert_eq!(exponent, e);\n    ///     assert_eq!(sign, s);\n    /// }\n    ///\n    /// check(2.0f32, 1 << 23, -22, 1);\n    /// check(-2.0f32, 1 << 23, -22, -1);\n    /// check(f32::INFINITY, 1 << 23, 105, 1);\n    /// check(f64::NEG_INFINITY, 1 << 52, 972, -1);\n    /// ```\n    fn integer_decode(self) -> (u64, i16, i8);\n}","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::abs":["/// Computes the absolute value of `self`. Returns `FloatCore::nan()` if the\n/// number is `FloatCore::nan()`.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, y: T) {\n///     assert!(x.abs() == y);\n/// }\n///\n/// check(f32::INFINITY, f32::INFINITY);\n/// check(1.0f32, 1.0);\n/// check(0.0f64, 0.0);\n/// check(-0.0f64, 0.0);\n/// check(-1.0f64, 1.0);\n/// check(f64::MIN, f64::MAX);\n/// ```\n#[inline]\nfn abs(self) -> Self{\n        if self.is_sign_positive() {\n            return self;\n        }\n        if self.is_sign_negative() {\n            return -self;\n        }\n        Self::nan()\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::ceil":["/// Returns the smallest integer greater than or equal to a number.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, y: T) {\n///     assert!(x.ceil() == y);\n/// }\n///\n/// check(f32::INFINITY, f32::INFINITY);\n/// check(0.9f32, 1.0);\n/// check(1.0f32, 1.0);\n/// check(1.1f32, 2.0);\n/// check(-0.0f64, 0.0);\n/// check(-0.9f64, -0.0);\n/// check(-1.0f64, -1.0);\n/// check(-1.1f64, -1.0);\n/// check(f64::MIN, f64::MIN);\n/// ```\n#[inline]\nfn ceil(self) -> Self{\n        let f = self.fract();\n        if f.is_nan() || f.is_zero() {\n            self\n        } else if self > Self::zero() {\n            self - f + Self::one()\n        } else {\n            self - f\n        }\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::floor":["/// Returns the largest integer less than or equal to a number.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, y: T) {\n///     assert!(x.floor() == y);\n/// }\n///\n/// check(f32::INFINITY, f32::INFINITY);\n/// check(0.9f32, 0.0);\n/// check(1.0f32, 1.0);\n/// check(1.1f32, 1.0);\n/// check(-0.0f64, 0.0);\n/// check(-0.9f64, -1.0);\n/// check(-1.0f64, -1.0);\n/// check(-1.1f64, -2.0);\n/// check(f64::MIN, f64::MIN);\n/// ```\n#[inline]\nfn floor(self) -> Self{\n        let f = self.fract();\n        if f.is_nan() || f.is_zero() {\n            self\n        } else if self < Self::zero() {\n            self - f - Self::one()\n        } else {\n            self - f\n        }\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::fract":["/// Returns the fractional part of a number.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, y: T) {\n///     assert!(x.fract() == y);\n/// }\n///\n/// check(f32::MAX, 0.0);\n/// check(0.75f32, 0.75);\n/// check(1.0f32, 0.0);\n/// check(1.25f32, 0.25);\n/// check(-0.0f64, 0.0);\n/// check(-0.75f64, -0.75);\n/// check(-1.0f64, 0.0);\n/// check(-1.25f64, -0.25);\n/// check(f64::MIN, 0.0);\n/// ```\n#[inline]\nfn fract(self) -> Self{\n        if self.is_zero() {\n            Self::zero()\n        } else {\n            self % Self::one()\n        }\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::is_finite":["/// Returns `true` if the number is neither infinite or NaN.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, p: bool) {\n///     assert!(x.is_finite() == p);\n/// }\n///\n/// check(f32::INFINITY, false);\n/// check(f32::MAX, true);\n/// check(f64::NEG_INFINITY, false);\n/// check(f64::MIN_POSITIVE, true);\n/// check(f64::NAN, false);\n/// ```\n#[inline]\nfn is_finite(self) -> bool{\n        !(self.is_nan() || self.is_infinite())\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::is_infinite":["/// Returns `true` if the number is infinite.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, p: bool) {\n///     assert!(x.is_infinite() == p);\n/// }\n///\n/// check(f32::INFINITY, true);\n/// check(f32::NEG_INFINITY, true);\n/// check(f32::NAN, false);\n/// check(f64::INFINITY, true);\n/// check(f64::NEG_INFINITY, true);\n/// check(0.0f64, false);\n/// ```\n#[inline]\nfn is_infinite(self) -> bool{\n        self == Self::infinity() || self == Self::neg_infinity()\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::is_nan":["/// Returns `true` if the number is NaN.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, p: bool) {\n///     assert!(x.is_nan() == p);\n/// }\n///\n/// check(f32::NAN, true);\n/// check(f32::INFINITY, false);\n/// check(f64::NAN, true);\n/// check(0.0f64, false);\n/// ```\n#[inline]\nfn is_nan(self) -> bool{\n        self != self\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::is_normal":["/// Returns `true` if the number is neither zero, infinite, subnormal or NaN.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, p: bool) {\n///     assert!(x.is_normal() == p);\n/// }\n///\n/// check(f32::INFINITY, false);\n/// check(f32::MAX, true);\n/// check(f64::NEG_INFINITY, false);\n/// check(f64::MIN_POSITIVE, true);\n/// check(0.0f64, false);\n/// ```\n#[inline]\nfn is_normal(self) -> bool{\n        self.classify() == FpCategory::Normal\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::is_sign_negative":["/// Returns `true` if `self` is negative, including `-0.0` and\n/// `FloatCore::neg_infinity()`, and since Rust 1.20 also\n/// `-FloatCore::nan()`.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, p: bool) {\n///     assert!(x.is_sign_negative() == p);\n/// }\n///\n/// check(f32::INFINITY, false);\n/// check(f32::MAX, false);\n/// check(0.0f32, false);\n/// check(-0.0f64, true);\n/// check(f64::NEG_INFINITY, true);\n/// check(f64::MIN_POSITIVE, false);\n/// check(f64::NAN, false);\n/// ```\n#[inline]\nfn is_sign_negative(self) -> bool{\n        let (_, _, sign) = self.integer_decode();\n        sign < 0\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::is_sign_positive":["/// Returns `true` if `self` is positive, including `+0.0` and\n/// `FloatCore::infinity()`, and since Rust 1.20 also\n/// `FloatCore::nan()`.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, p: bool) {\n///     assert!(x.is_sign_positive() == p);\n/// }\n///\n/// check(f32::INFINITY, true);\n/// check(f32::MAX, true);\n/// check(0.0f32, true);\n/// check(-0.0f64, false);\n/// check(f64::NEG_INFINITY, false);\n/// check(f64::MIN_POSITIVE, true);\n/// check(-f64::NAN, false);\n/// ```\n#[inline]\nfn is_sign_positive(self) -> bool{\n        !self.is_sign_negative()\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::max":["/// Returns the maximum of the two numbers.\n///\n/// If one of the arguments is NaN, then the other argument is returned.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, y: T, max: T) {\n///     assert!(x.max(y) == max);\n/// }\n///\n/// check(1.0f32, 2.0, 2.0);\n/// check(1.0f32, f32::NAN, 1.0);\n/// check(-1.0f64, 2.0, 2.0);\n/// check(-1.0f64, f64::NAN, -1.0);\n/// ```\n#[inline]\nfn max(self, other: Self) -> Self{\n        if self.is_nan() {\n            return other;\n        }\n        if other.is_nan() {\n            return self;\n        }\n        if self > other {\n            self\n        } else {\n            other\n        }\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::min":["/// Returns the minimum of the two numbers.\n///\n/// If one of the arguments is NaN, then the other argument is returned.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, y: T, min: T) {\n///     assert!(x.min(y) == min);\n/// }\n///\n/// check(1.0f32, 2.0, 1.0);\n/// check(f32::NAN, 2.0, 2.0);\n/// check(1.0f64, -2.0, -2.0);\n/// check(1.0f64, f64::NAN, 1.0);\n/// ```\n#[inline]\nfn min(self, other: Self) -> Self{\n        if self.is_nan() {\n            return other;\n        }\n        if other.is_nan() {\n            return self;\n        }\n        if self < other {\n            self\n        } else {\n            other\n        }\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::powi":["/// Raise a number to an integer power.\n///\n/// Using this function is generally faster than using `powf`\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n///\n/// fn check<T: FloatCore>(x: T, exp: i32, powi: T) {\n///     assert!(x.powi(exp) == powi);\n/// }\n///\n/// check(9.0f32, 2, 81.0);\n/// check(1.0f32, -2, 1.0);\n/// check(10.0f64, 20, 1e20);\n/// check(4.0f64, -2, 0.0625);\n/// check(-1.0f64, std::i32::MIN, 1.0);\n/// ```\n#[inline]\nfn powi(mut self, mut exp: i32) -> Self{\n        if exp < 0 {\n            exp = exp.wrapping_neg();\n            self = self.recip();\n        }\n        // It should always be possible to convert a positive `i32` to a `usize`.\n        // Note, `i32::MIN` will wrap and still be negative, so we need to convert\n        // to `u32` without sign-extension before growing to `usize`.\n        super::pow(self, (exp as u32).to_usize().unwrap())\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::recip":["/// Returns the reciprocal (multiplicative inverse) of the number.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, y: T) {\n///     assert!(x.recip() == y);\n///     assert!(y.recip() == x);\n/// }\n///\n/// check(f32::INFINITY, 0.0);\n/// check(2.0f32, 0.5);\n/// check(-0.25f64, -4.0);\n/// check(-0.0f64, f64::NEG_INFINITY);\n/// ```\n#[inline]\nfn recip(self) -> Self{\n        Self::one() / self\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::round":["/// Returns the nearest integer to a number. Round half-way cases away from `0.0`.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, y: T) {\n///     assert!(x.round() == y);\n/// }\n///\n/// check(f32::INFINITY, f32::INFINITY);\n/// check(0.4f32, 0.0);\n/// check(0.5f32, 1.0);\n/// check(0.6f32, 1.0);\n/// check(-0.4f64, 0.0);\n/// check(-0.5f64, -1.0);\n/// check(-0.6f64, -1.0);\n/// check(f64::MIN, f64::MIN);\n/// ```\n#[inline]\nfn round(self) -> Self{\n        let one = Self::one();\n        let h = Self::from(0.5).expect(\"Unable to cast from 0.5\");\n        let f = self.fract();\n        if f.is_nan() || f.is_zero() {\n            self\n        } else if self > Self::zero() {\n            if f < h {\n                self - f\n            } else {\n                self - f + one\n            }\n        } else {\n            if -f < h {\n                self - f\n            } else {\n                self - f - one\n            }\n        }\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::signum":["/// Returns a number that represents the sign of `self`.\n///\n/// - `1.0` if the number is positive, `+0.0` or `FloatCore::infinity()`\n/// - `-1.0` if the number is negative, `-0.0` or `FloatCore::neg_infinity()`\n/// - `FloatCore::nan()` if the number is `FloatCore::nan()`\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, y: T) {\n///     assert!(x.signum() == y);\n/// }\n///\n/// check(f32::INFINITY, 1.0);\n/// check(3.0f32, 1.0);\n/// check(0.0f32, 1.0);\n/// check(-0.0f64, -1.0);\n/// check(-3.0f64, -1.0);\n/// check(f64::MIN, -1.0);\n/// ```\n#[inline]\nfn signum(self) -> Self{\n        if self.is_nan() {\n            Self::nan()\n        } else if self.is_sign_negative() {\n            -Self::one()\n        } else {\n            Self::one()\n        }\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::FloatCore::trunc":["/// Return the integer part of a number.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::float::FloatCore;\n/// use std::{f32, f64};\n///\n/// fn check<T: FloatCore>(x: T, y: T) {\n///     assert!(x.trunc() == y);\n/// }\n///\n/// check(f32::INFINITY, f32::INFINITY);\n/// check(0.9f32, 0.0);\n/// check(1.0f32, 1.0);\n/// check(1.1f32, 1.0);\n/// check(-0.0f64, 0.0);\n/// check(-0.9f64, -0.0);\n/// check(-1.0f64, -1.0);\n/// check(-1.1f64, -1.0);\n/// check(f64::MIN, f64::MIN);\n/// ```\n#[inline]\nfn trunc(self) -> Self{\n        let f = self.fract();\n        if f.is_nan() {\n            self\n        } else {\n            self - f\n        }\n    }","Real(LocalPath(\"src/float.rs\"))"],"float::integer_decode_f32":["fn integer_decode_f32(f: f32) -> (u64, i16, i8){\n    // Safety: this identical to the implementation of f32::to_bits(),\n    // which is only available starting at Rust 1.20\n    let bits: u32 = unsafe { mem::transmute(f) };\n    let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n    let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n    let mantissa = if exponent == 0 {\n        (bits & 0x7fffff) << 1\n    } else {\n        (bits & 0x7fffff) | 0x800000\n    };\n    // Exponent bias + mantissa shift\n    exponent -= 127 + 23;\n    (mantissa as u64, exponent, sign)\n}","Real(LocalPath(\"src/float.rs\"))"],"float::integer_decode_f64":["fn integer_decode_f64(f: f64) -> (u64, i16, i8){\n    // Safety: this identical to the implementation of f64::to_bits(),\n    // which is only available starting at Rust 1.20\n    let bits: u64 = unsafe { mem::transmute(f) };\n    let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n    let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n    let mantissa = if exponent == 0 {\n        (bits & 0xfffffffffffff) << 1\n    } else {\n        (bits & 0xfffffffffffff) | 0x10000000000000\n    };\n    // Exponent bias + mantissa shift\n    exponent -= 1023 + 52;\n    (mantissa, exponent, sign)\n}","Real(LocalPath(\"src/float.rs\"))"],"identities::One":["/// Defines a multiplicative identity element for `Self`.\n///\n/// # Laws\n///\n/// ```{.text}\n/// a * 1 = a        a  Self\n/// 1 * a = a        a  Self\n/// ```\npub trait One: Sized + Mul<Self, Output = Self> {\n    /// Returns the multiplicative identity element of `Self`, `1`.\n    ///\n    /// # Purity\n    ///\n    /// This function should return the same result at all times regardless of\n    /// external mutable state, for example values stored in TLS or in\n    /// `static mut`s.\n    // This cannot be an associated constant, because of bignums.\n    fn one() -> Self;\n\n    /// Sets `self` to the multiplicative identity element of `Self`, `1`.\n    fn set_one(&mut self) {\n        *self = One::one();\n    }\n\n    /// Returns `true` if `self` is equal to the multiplicative identity.\n    ///\n    /// For performance reasons, it's best to implement this manually.\n    /// After a semver bump, this method will be required, and the\n    /// `where Self: PartialEq` bound will be removed.\n    #[inline]\n    fn is_one(&self) -> bool\n    where\n        Self: PartialEq,\n    {\n        *self == Self::one()\n    }\n}","Real(LocalPath(\"src/identities.rs\"))"],"identities::One::is_one":["/// Returns `true` if `self` is equal to the multiplicative identity.\n///\n/// For performance reasons, it's best to implement this manually.\n/// After a semver bump, this method will be required, and the\n/// `where Self: PartialEq` bound will be removed.\n#[inline]\nfn is_one(&self) -> bool\n    where\n        Self: PartialEq,{\n        *self == Self::one()\n    }","Real(LocalPath(\"src/identities.rs\"))"],"identities::One::set_one":["/// Sets `self` to the multiplicative identity element of `Self`, `1`.\nfn set_one(&mut self){\n        *self = One::one();\n    }","Real(LocalPath(\"src/identities.rs\"))"],"identities::Zero":["/// Defines an additive identity element for `Self`.\n///\n/// # Laws\n///\n/// ```{.text}\n/// a + 0 = a        a  Self\n/// 0 + a = a        a  Self\n/// ```\npub trait Zero: Sized + Add<Self, Output = Self> {\n    /// Returns the additive identity element of `Self`, `0`.\n    /// # Purity\n    ///\n    /// This function should return the same result at all times regardless of\n    /// external mutable state, for example values stored in TLS or in\n    /// `static mut`s.\n    // This cannot be an associated constant, because of bignums.\n    fn zero() -> Self;\n\n    /// Sets `self` to the additive identity element of `Self`, `0`.\n    fn set_zero(&mut self) {\n        *self = Zero::zero();\n    }\n\n    /// Returns `true` if `self` is equal to the additive identity.\n    fn is_zero(&self) -> bool;\n}","Real(LocalPath(\"src/identities.rs\"))"],"identities::Zero::set_zero":["/// Sets `self` to the additive identity element of `Self`, `0`.\nfn set_zero(&mut self){\n        *self = Zero::zero();\n    }","Real(LocalPath(\"src/identities.rs\"))"],"identities::one":["/// Returns the multiplicative identity, `1`.\n#[inline(always)]\npub fn one<T: One>() -> T{\n    One::one()\n}","Real(LocalPath(\"src/identities.rs\"))"],"identities::zero":["/// Returns the additive identity, `0`.\n#[inline(always)]\npub fn zero<T: Zero>() -> T{\n    Zero::zero()\n}","Real(LocalPath(\"src/identities.rs\"))"],"int::PrimInt":["/// Generic trait for primitive integers.\n///\n/// The `PrimInt` trait is an abstraction over the builtin primitive integer types (e.g., `u8`,\n/// `u32`, `isize`, `i128`, ...). It inherits the basic numeric traits and extends them with\n/// bitwise operators and non-wrapping arithmetic.\n///\n/// The trait explicitly inherits `Copy`, `Eq`, `Ord`, and `Sized`. The intention is that all\n/// types implementing this trait behave like primitive types that are passed by value by default\n/// and behave like builtin integers. Furthermore, the types are expected to expose the integer\n/// value in binary representation and support bitwise operators. The standard bitwise operations\n/// (e.g., bitwise-and, bitwise-or, right-shift, left-shift) are inherited and the trait extends\n/// these with introspective queries (e.g., `PrimInt::count_ones()`, `PrimInt::leading_zeros()`),\n/// bitwise combinators (e.g., `PrimInt::rotate_left()`), and endianness converters (e.g.,\n/// `PrimInt::to_be()`).\n///\n/// All `PrimInt` types are expected to be fixed-width binary integers. The width can be queried\n/// via `T::zero().count_zeros()`. The trait currently lacks a way to query the width at\n/// compile-time.\n///\n/// While a default implementation for all builtin primitive integers is provided, the trait is in\n/// no way restricted to these. Other integer types that fulfil the requirements are free to\n/// implement the trait was well.\n///\n/// This trait and many of the method names originate in the unstable `core::num::Int` trait from\n/// the rust standard library. The original trait was never stabilized and thus removed from the\n/// standard library.\npub trait PrimInt:\n    Sized\n    + Copy\n    + Num\n    + NumCast\n    + Bounded\n    + PartialOrd\n    + Ord\n    + Eq\n    + Not<Output = Self>\n    + BitAnd<Output = Self>\n    + BitOr<Output = Self>\n    + BitXor<Output = Self>\n    + Shl<usize, Output = Self>\n    + Shr<usize, Output = Self>\n    + CheckedAdd<Output = Self>\n    + CheckedSub<Output = Self>\n    + CheckedMul<Output = Self>\n    + CheckedDiv<Output = Self>\n    + Saturating\n{\n    /// Returns the number of ones in the binary representation of `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0b01001100u8;\n    ///\n    /// assert_eq!(n.count_ones(), 3);\n    /// ```\n    fn count_ones(self) -> u32;\n\n    /// Returns the number of zeros in the binary representation of `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0b01001100u8;\n    ///\n    /// assert_eq!(n.count_zeros(), 5);\n    /// ```\n    fn count_zeros(self) -> u32;\n\n    /// Returns the number of leading ones in the binary representation\n    /// of `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0xF00Du16;\n    ///\n    /// assert_eq!(n.leading_ones(), 4);\n    /// ```\n    fn leading_ones(self) -> u32 {\n        (!self).leading_zeros()\n    }\n\n    /// Returns the number of leading zeros in the binary representation\n    /// of `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0b0101000u16;\n    ///\n    /// assert_eq!(n.leading_zeros(), 10);\n    /// ```\n    fn leading_zeros(self) -> u32;\n\n    /// Returns the number of trailing ones in the binary representation\n    /// of `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0xBEEFu16;\n    ///\n    /// assert_eq!(n.trailing_ones(), 4);\n    /// ```\n    fn trailing_ones(self) -> u32 {\n        (!self).trailing_zeros()\n    }\n\n    /// Returns the number of trailing zeros in the binary representation\n    /// of `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0b0101000u16;\n    ///\n    /// assert_eq!(n.trailing_zeros(), 3);\n    /// ```\n    fn trailing_zeros(self) -> u32;\n\n    /// Shifts the bits to the left by a specified amount, `n`, wrapping\n    /// the truncated bits to the end of the resulting integer.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0x0123456789ABCDEFu64;\n    /// let m = 0x3456789ABCDEF012u64;\n    ///\n    /// assert_eq!(n.rotate_left(12), m);\n    /// ```\n    fn rotate_left(self, n: u32) -> Self;\n\n    /// Shifts the bits to the right by a specified amount, `n`, wrapping\n    /// the truncated bits to the beginning of the resulting integer.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0x0123456789ABCDEFu64;\n    /// let m = 0xDEF0123456789ABCu64;\n    ///\n    /// assert_eq!(n.rotate_right(12), m);\n    /// ```\n    fn rotate_right(self, n: u32) -> Self;\n\n    /// Shifts the bits to the left by a specified amount, `n`, filling\n    /// zeros in the least significant bits.\n    ///\n    /// This is bitwise equivalent to signed `Shl`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0x0123456789ABCDEFu64;\n    /// let m = 0x3456789ABCDEF000u64;\n    ///\n    /// assert_eq!(n.signed_shl(12), m);\n    /// ```\n    fn signed_shl(self, n: u32) -> Self;\n\n    /// Shifts the bits to the right by a specified amount, `n`, copying\n    /// the \"sign bit\" in the most significant bits even for unsigned types.\n    ///\n    /// This is bitwise equivalent to signed `Shr`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0xFEDCBA9876543210u64;\n    /// let m = 0xFFFFEDCBA9876543u64;\n    ///\n    /// assert_eq!(n.signed_shr(12), m);\n    /// ```\n    fn signed_shr(self, n: u32) -> Self;\n\n    /// Shifts the bits to the left by a specified amount, `n`, filling\n    /// zeros in the least significant bits.\n    ///\n    /// This is bitwise equivalent to unsigned `Shl`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0x0123456789ABCDEFi64;\n    /// let m = 0x3456789ABCDEF000i64;\n    ///\n    /// assert_eq!(n.unsigned_shl(12), m);\n    /// ```\n    fn unsigned_shl(self, n: u32) -> Self;\n\n    /// Shifts the bits to the right by a specified amount, `n`, filling\n    /// zeros in the most significant bits.\n    ///\n    /// This is bitwise equivalent to unsigned `Shr`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = -8i8; // 0b11111000\n    /// let m = 62i8; // 0b00111110\n    ///\n    /// assert_eq!(n.unsigned_shr(2), m);\n    /// ```\n    fn unsigned_shr(self, n: u32) -> Self;\n\n    /// Reverses the byte order of the integer.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0x0123456789ABCDEFu64;\n    /// let m = 0xEFCDAB8967452301u64;\n    ///\n    /// assert_eq!(n.swap_bytes(), m);\n    /// ```\n    fn swap_bytes(self) -> Self;\n\n    /// Reverses the order of bits in the integer.\n    ///\n    /// The least significant bit becomes the most significant bit, second least-significant bit\n    /// becomes second most-significant bit, etc.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0x12345678u32;\n    /// let m = 0x1e6a2c48u32;\n    ///\n    /// assert_eq!(n.reverse_bits(), m);\n    /// assert_eq!(0u32.reverse_bits(), 0);\n    /// ```\n    fn reverse_bits(self) -> Self {\n        reverse_bits_fallback(self)\n    }\n\n    /// Convert an integer from big endian to the target's endianness.\n    ///\n    /// On big endian this is a no-op. On little endian the bytes are swapped.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0x0123456789ABCDEFu64;\n    ///\n    /// if cfg!(target_endian = \"big\") {\n    ///     assert_eq!(u64::from_be(n), n)\n    /// } else {\n    ///     assert_eq!(u64::from_be(n), n.swap_bytes())\n    /// }\n    /// ```\n    fn from_be(x: Self) -> Self;\n\n    /// Convert an integer from little endian to the target's endianness.\n    ///\n    /// On little endian this is a no-op. On big endian the bytes are swapped.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0x0123456789ABCDEFu64;\n    ///\n    /// if cfg!(target_endian = \"little\") {\n    ///     assert_eq!(u64::from_le(n), n)\n    /// } else {\n    ///     assert_eq!(u64::from_le(n), n.swap_bytes())\n    /// }\n    /// ```\n    fn from_le(x: Self) -> Self;\n\n    /// Convert `self` to big endian from the target's endianness.\n    ///\n    /// On big endian this is a no-op. On little endian the bytes are swapped.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0x0123456789ABCDEFu64;\n    ///\n    /// if cfg!(target_endian = \"big\") {\n    ///     assert_eq!(n.to_be(), n)\n    /// } else {\n    ///     assert_eq!(n.to_be(), n.swap_bytes())\n    /// }\n    /// ```\n    fn to_be(self) -> Self;\n\n    /// Convert `self` to little endian from the target's endianness.\n    ///\n    /// On little endian this is a no-op. On big endian the bytes are swapped.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// let n = 0x0123456789ABCDEFu64;\n    ///\n    /// if cfg!(target_endian = \"little\") {\n    ///     assert_eq!(n.to_le(), n)\n    /// } else {\n    ///     assert_eq!(n.to_le(), n.swap_bytes())\n    /// }\n    /// ```\n    fn to_le(self) -> Self;\n\n    /// Raises self to the power of `exp`, using exponentiation by squaring.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::PrimInt;\n    ///\n    /// assert_eq!(2i32.pow(4), 16);\n    /// ```\n    fn pow(self, exp: u32) -> Self;\n}","Real(LocalPath(\"src/int.rs\"))"],"int::PrimInt::leading_ones":["/// Returns the number of leading ones in the binary representation\n/// of `self`.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::PrimInt;\n///\n/// let n = 0xF00Du16;\n///\n/// assert_eq!(n.leading_ones(), 4);\n/// ```\nfn leading_ones(self) -> u32{\n        (!self).leading_zeros()\n    }","Real(LocalPath(\"src/int.rs\"))"],"int::PrimInt::reverse_bits":["/// Reverses the order of bits in the integer.\n///\n/// The least significant bit becomes the most significant bit, second least-significant bit\n/// becomes second most-significant bit, etc.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::PrimInt;\n///\n/// let n = 0x12345678u32;\n/// let m = 0x1e6a2c48u32;\n///\n/// assert_eq!(n.reverse_bits(), m);\n/// assert_eq!(0u32.reverse_bits(), 0);\n/// ```\nfn reverse_bits(self) -> Self{\n        reverse_bits_fallback(self)\n    }","Real(LocalPath(\"src/int.rs\"))"],"int::PrimInt::trailing_ones":["/// Returns the number of trailing ones in the binary representation\n/// of `self`.\n///\n/// # Examples\n///\n/// ```\n/// use num_traits::PrimInt;\n///\n/// let n = 0xBEEFu16;\n///\n/// assert_eq!(n.trailing_ones(), 4);\n/// ```\nfn trailing_ones(self) -> u32{\n        (!self).trailing_zeros()\n    }","Real(LocalPath(\"src/int.rs\"))"],"int::one_per_byte":["fn one_per_byte<P: PrimInt>() -> P{\n    // i8, u8: return 0x01\n    // i16, u16: return 0x0101 = (0x01 << 8) | 0x01\n    // i32, u32: return 0x01010101 = (0x0101 << 16) | 0x0101\n    // ...\n    let mut ret = P::one();\n    let mut shift = 8;\n    let mut b = ret.count_zeros() >> 3;\n    while b != 0 {\n        ret = (ret << shift) | ret;\n        shift <<= 1;\n        b >>= 1;\n    }\n    ret\n}","Real(LocalPath(\"src/int.rs\"))"],"int::reverse_bits_fallback":["fn reverse_bits_fallback<P: PrimInt>(i: P) -> P{\n    let rep_01: P = one_per_byte();\n    let rep_03 = (rep_01 << 1) | rep_01;\n    let rep_05 = (rep_01 << 2) | rep_01;\n    let rep_0f = (rep_03 << 2) | rep_03;\n    let rep_33 = (rep_03 << 4) | rep_03;\n    let rep_55 = (rep_05 << 4) | rep_05;\n\n    // code above only used to determine rep_0f, rep_33, rep_55;\n    // optimizer should be able to do it in compile time\n    let mut ret = i.swap_bytes();\n    ret = ((ret & rep_0f) << 4) | ((ret >> 4) & rep_0f);\n    ret = ((ret & rep_33) << 2) | ((ret >> 2) & rep_33);\n    ret = ((ret & rep_55) << 1) | ((ret >> 1) & rep_55);\n    ret\n}","Real(LocalPath(\"src/int.rs\"))"],"ops::checked::CheckedAdd":["/// Performs addition that returns `None` instead of wrapping around on\n/// overflow.\npub trait CheckedAdd: Sized + Add<Self, Output = Self> {\n    /// Adds two numbers, checking for overflow. If overflow happens, `None` is\n    /// returned.\n    fn checked_add(&self, v: &Self) -> Option<Self>;\n}","Real(LocalPath(\"src/ops/checked.rs\"))"],"ops::checked::CheckedDiv":["/// Performs division that returns `None` instead of panicking on division by zero and instead of\n/// wrapping around on underflow and overflow.\npub trait CheckedDiv: Sized + Div<Self, Output = Self> {\n    /// Divides two numbers, checking for underflow, overflow and division by\n    /// zero. If any of that happens, `None` is returned.\n    fn checked_div(&self, v: &Self) -> Option<Self>;\n}","Real(LocalPath(\"src/ops/checked.rs\"))"],"ops::checked::CheckedMul":["/// Performs multiplication that returns `None` instead of wrapping around on underflow or\n/// overflow.\npub trait CheckedMul: Sized + Mul<Self, Output = Self> {\n    /// Multiplies two numbers, checking for underflow or overflow. If underflow\n    /// or overflow happens, `None` is returned.\n    fn checked_mul(&self, v: &Self) -> Option<Self>;\n}","Real(LocalPath(\"src/ops/checked.rs\"))"],"ops::checked::CheckedNeg":["/// Performs negation that returns `None` if the result can't be represented.\npub trait CheckedNeg: Sized {\n    /// Negates a number, returning `None` for results that can't be represented, like signed `MIN`\n    /// values that can't be positive, or non-zero unsigned values that can't be negative.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::CheckedNeg;\n    /// use std::i32::MIN;\n    ///\n    /// assert_eq!(CheckedNeg::checked_neg(&1_i32), Some(-1));\n    /// assert_eq!(CheckedNeg::checked_neg(&-1_i32), Some(1));\n    /// assert_eq!(CheckedNeg::checked_neg(&MIN), None);\n    ///\n    /// assert_eq!(CheckedNeg::checked_neg(&0_u32), Some(0));\n    /// assert_eq!(CheckedNeg::checked_neg(&1_u32), None);\n    /// ```\n    fn checked_neg(&self) -> Option<Self>;\n}","Real(LocalPath(\"src/ops/checked.rs\"))"],"ops::checked::CheckedRem":["/// Performs an integral remainder that returns `None` instead of panicking on division by zero and\n/// instead of wrapping around on underflow and overflow.\npub trait CheckedRem: Sized + Rem<Self, Output = Self> {\n    /// Finds the remainder of dividing two numbers, checking for underflow, overflow and division\n    /// by zero. If any of that happens, `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::CheckedRem;\n    /// use std::i32::MIN;\n    ///\n    /// assert_eq!(CheckedRem::checked_rem(&10, &7), Some(3));\n    /// assert_eq!(CheckedRem::checked_rem(&10, &-7), Some(3));\n    /// assert_eq!(CheckedRem::checked_rem(&-10, &7), Some(-3));\n    /// assert_eq!(CheckedRem::checked_rem(&-10, &-7), Some(-3));\n    ///\n    /// assert_eq!(CheckedRem::checked_rem(&10, &0), None);\n    ///\n    /// assert_eq!(CheckedRem::checked_rem(&MIN, &1), Some(0));\n    /// assert_eq!(CheckedRem::checked_rem(&MIN, &-1), None);\n    /// ```\n    fn checked_rem(&self, v: &Self) -> Option<Self>;\n}","Real(LocalPath(\"src/ops/checked.rs\"))"],"ops::checked::CheckedShl":["/// Performs a left shift that returns `None` on shifts larger than\n/// the type width.\npub trait CheckedShl: Sized + Shl<u32, Output = Self> {\n    /// Checked shift left. Computes `self << rhs`, returning `None`\n    /// if `rhs` is larger than or equal to the number of bits in `self`.\n    ///\n    /// ```\n    /// use num_traits::CheckedShl;\n    ///\n    /// let x: u16 = 0x0001;\n    ///\n    /// assert_eq!(CheckedShl::checked_shl(&x, 0),  Some(0x0001));\n    /// assert_eq!(CheckedShl::checked_shl(&x, 1),  Some(0x0002));\n    /// assert_eq!(CheckedShl::checked_shl(&x, 15), Some(0x8000));\n    /// assert_eq!(CheckedShl::checked_shl(&x, 16), None);\n    /// ```\n    fn checked_shl(&self, rhs: u32) -> Option<Self>;\n}","Real(LocalPath(\"src/ops/checked.rs\"))"],"ops::checked::CheckedShr":["/// Performs a right shift that returns `None` on shifts larger than\n/// the type width.\npub trait CheckedShr: Sized + Shr<u32, Output = Self> {\n    /// Checked shift right. Computes `self >> rhs`, returning `None`\n    /// if `rhs` is larger than or equal to the number of bits in `self`.\n    ///\n    /// ```\n    /// use num_traits::CheckedShr;\n    ///\n    /// let x: u16 = 0x8000;\n    ///\n    /// assert_eq!(CheckedShr::checked_shr(&x, 0),  Some(0x8000));\n    /// assert_eq!(CheckedShr::checked_shr(&x, 1),  Some(0x4000));\n    /// assert_eq!(CheckedShr::checked_shr(&x, 15), Some(0x0001));\n    /// assert_eq!(CheckedShr::checked_shr(&x, 16), None);\n    /// ```\n    fn checked_shr(&self, rhs: u32) -> Option<Self>;\n}","Real(LocalPath(\"src/ops/checked.rs\"))"],"ops::checked::CheckedSub":["/// Performs subtraction that returns `None` instead of wrapping around on underflow.\npub trait CheckedSub: Sized + Sub<Self, Output = Self> {\n    /// Subtracts two numbers, checking for underflow. If underflow happens,\n    /// `None` is returned.\n    fn checked_sub(&self, v: &Self) -> Option<Self>;\n}","Real(LocalPath(\"src/ops/checked.rs\"))"],"ops::euclid::CheckedEuclid":["pub trait CheckedEuclid: Euclid {\n    /// Performs euclid division that returns `None` instead of panicking on division by zero\n    /// and instead of wrapping around on underflow and overflow.\n    fn checked_div_euclid(&self, v: &Self) -> Option<Self>;\n\n    /// Finds the euclid remainder of dividing two numbers, checking for underflow, overflow and\n    /// division by zero. If any of that happens, `None` is returned.\n    fn checked_rem_euclid(&self, v: &Self) -> Option<Self>;\n}","Real(LocalPath(\"src/ops/euclid.rs\"))"],"ops::euclid::Euclid":["pub trait Euclid: Sized + Div<Self, Output = Self> + Rem<Self, Output = Self> {\n    /// Calculates Euclidean division, the matching method for `rem_euclid`.\n    ///\n    /// This computes the integer `n` such that\n    /// `self = n * v + self.rem_euclid(v)`.\n    /// In other words, the result is `self / v` rounded to the integer `n`\n    /// such that `self >= n * v`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::Euclid;\n    ///\n    /// let a: i32 = 7;\n    /// let b: i32 = 4;\n    /// assert_eq!(Euclid::div_euclid(&a, &b), 1); // 7 > 4 * 1\n    /// assert_eq!(Euclid::div_euclid(&-a, &b), -2); // -7 >= 4 * -2\n    /// assert_eq!(Euclid::div_euclid(&a, &-b), -1); // 7 >= -4 * -1\n    /// assert_eq!(Euclid::div_euclid(&-a, &-b), 2); // -7 >= -4 * 2\n    /// ```\n    fn div_euclid(&self, v: &Self) -> Self;\n\n    /// Calculates the least nonnegative remainder of `self (mod v)`.\n    ///\n    /// In particular, the return value `r` satisfies `0.0 <= r < v.abs()` in\n    /// most cases. However, due to a floating point round-off error it can\n    /// result in `r == v.abs()`, violating the mathematical definition, if\n    /// `self` is much smaller than `v.abs()` in magnitude and `self < 0.0`.\n    /// This result is not an element of the function's codomain, but it is the\n    /// closest floating point number in the real numbers and thus fulfills the\n    /// property `self == self.div_euclid(v) * v + self.rem_euclid(v)`\n    /// approximatively.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::Euclid;\n    ///\n    /// let a: i32 = 7;\n    /// let b: i32 = 4;\n    /// assert_eq!(Euclid::rem_euclid(&a, &b), 3);\n    /// assert_eq!(Euclid::rem_euclid(&-a, &b), 1);\n    /// assert_eq!(Euclid::rem_euclid(&a, &-b), 3);\n    /// assert_eq!(Euclid::rem_euclid(&-a, &-b), 1);\n    /// ```\n    fn rem_euclid(&self, v: &Self) -> Self;\n}","Real(LocalPath(\"src/ops/euclid.rs\"))"],"ops::inv::Inv":["/// Unary operator for retrieving the multiplicative inverse, or reciprocal, of a value.\npub trait Inv {\n    /// The result after applying the operator.\n    type Output;\n\n    /// Returns the multiplicative inverse of `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64::INFINITY;\n    /// use num_traits::Inv;\n    ///\n    /// assert_eq!(7.0.inv() * 7.0, 1.0);\n    /// assert_eq!((-0.0).inv(), -INFINITY);\n    /// ```\n    fn inv(self) -> Self::Output;\n}","Real(LocalPath(\"src/ops/inv.rs\"))"],"ops::mul_add::MulAdd":["/// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n/// error, yielding a more accurate result than an unfused multiply-add.\n///\n/// Using `mul_add` can be more performant than an unfused multiply-add if\n/// the target architecture has a dedicated `fma` CPU instruction.\n///\n/// Note that `A` and `B` are `Self` by default, but this is not mandatory.\n///\n/// # Example\n///\n/// ```\n/// use std::f32;\n///\n/// let m = 10.0_f32;\n/// let x = 4.0_f32;\n/// let b = 60.0_f32;\n///\n/// // 100.0\n/// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n///\n/// assert!(abs_difference <= 100.0 * f32::EPSILON);\n/// ```\npub trait MulAdd<A = Self, B = Self> {\n    /// The resulting type after applying the fused multiply-add.\n    type Output;\n\n    /// Performs the fused multiply-add operation.\n    fn mul_add(self, a: A, b: B) -> Self::Output;\n}","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"ops::mul_add::MulAddAssign":["/// The fused multiply-add assignment operation.\npub trait MulAddAssign<A = Self, B = Self> {\n    /// Performs the fused multiply-add operation.\n    fn mul_add_assign(&mut self, a: A, b: B);\n}","Real(LocalPath(\"src/ops/mul_add.rs\"))"],"ops::overflowing::OverflowingAdd":["/// Performs addition with a flag for overflow.\npub trait OverflowingAdd: Sized + Add<Self, Output = Self> {\n    /// Returns a tuple of the sum along with a boolean indicating whether an arithmetic overflow would occur.\n    /// If an overflow would have occurred then the wrapped value is returned.\n    fn overflowing_add(&self, v: &Self) -> (Self, bool);\n}","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"ops::overflowing::OverflowingMul":["/// Performs multiplication with a flag for overflow.\npub trait OverflowingMul: Sized + Mul<Self, Output = Self> {\n    /// Returns a tuple of the product along with a boolean indicating whether an arithmetic overflow would occur.\n    /// If an overflow would have occurred then the wrapped value is returned.\n    fn overflowing_mul(&self, v: &Self) -> (Self, bool);\n}","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"ops::overflowing::OverflowingSub":["/// Performs substraction with a flag for overflow.\npub trait OverflowingSub: Sized + Sub<Self, Output = Self> {\n    /// Returns a tuple of the difference along with a boolean indicating whether an arithmetic overflow would occur.\n    /// If an overflow would have occurred then the wrapped value is returned.\n    fn overflowing_sub(&self, v: &Self) -> (Self, bool);\n}","Real(LocalPath(\"src/ops/overflowing.rs\"))"],"ops::saturating::Saturating":["/// Saturating math operations. Deprecated, use `SaturatingAdd`, `SaturatingSub` and\n/// `SaturatingMul` instead.\npub trait Saturating {\n    /// Saturating addition operator.\n    /// Returns a+b, saturating at the numeric bounds instead of overflowing.\n    fn saturating_add(self, v: Self) -> Self;\n\n    /// Saturating subtraction operator.\n    /// Returns a-b, saturating at the numeric bounds instead of overflowing.\n    fn saturating_sub(self, v: Self) -> Self;\n}","Real(LocalPath(\"src/ops/saturating.rs\"))"],"ops::saturating::SaturatingAdd":["/// Performs addition that saturates at the numeric bounds instead of overflowing.\npub trait SaturatingAdd: Sized + Add<Self, Output = Self> {\n    /// Saturating addition. Computes `self + other`, saturating at the relevant high or low boundary of\n    /// the type.\n    fn saturating_add(&self, v: &Self) -> Self;\n}","Real(LocalPath(\"src/ops/saturating.rs\"))"],"ops::saturating::SaturatingMul":["/// Performs multiplication that saturates at the numeric bounds instead of overflowing.\npub trait SaturatingMul: Sized + Mul<Self, Output = Self> {\n    /// Saturating multiplication. Computes `self * other`, saturating at the relevant high or low boundary of\n    /// the type.\n    fn saturating_mul(&self, v: &Self) -> Self;\n}","Real(LocalPath(\"src/ops/saturating.rs\"))"],"ops::saturating::SaturatingSub":["/// Performs subtraction that saturates at the numeric bounds instead of overflowing.\npub trait SaturatingSub: Sized + Sub<Self, Output = Self> {\n    /// Saturating subtraction. Computes `self - other`, saturating at the relevant high or low boundary of\n    /// the type.\n    fn saturating_sub(&self, v: &Self) -> Self;\n}","Real(LocalPath(\"src/ops/saturating.rs\"))"],"ops::wrapping::WrappingAdd":["/// Performs addition that wraps around on overflow.\npub trait WrappingAdd: Sized + Add<Self, Output = Self> {\n    /// Wrapping (modular) addition. Computes `self + other`, wrapping around at the boundary of\n    /// the type.\n    fn wrapping_add(&self, v: &Self) -> Self;\n}","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"ops::wrapping::WrappingMul":["/// Performs multiplication that wraps around on overflow.\npub trait WrappingMul: Sized + Mul<Self, Output = Self> {\n    /// Wrapping (modular) multiplication. Computes `self * other`, wrapping around at the boundary\n    /// of the type.\n    fn wrapping_mul(&self, v: &Self) -> Self;\n}","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"ops::wrapping::WrappingNeg":["/// Performs a negation that does not panic.\npub trait WrappingNeg: Sized {\n    /// Wrapping (modular) negation. Computes `-self`,\n    /// wrapping around at the boundary of the type.\n    ///\n    /// Since unsigned types do not have negative equivalents\n    /// all applications of this function will wrap (except for `-0`).\n    /// For values smaller than the corresponding signed type's maximum\n    /// the result is the same as casting the corresponding signed value.\n    /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n    /// `MAX` is the corresponding signed type's maximum.\n    ///\n    /// ```\n    /// use num_traits::WrappingNeg;\n    ///\n    /// assert_eq!(100i8.wrapping_neg(), -100);\n    /// assert_eq!((-100i8).wrapping_neg(), 100);\n    /// assert_eq!((-128i8).wrapping_neg(), -128); // wrapped!\n    /// ```\n    fn wrapping_neg(&self) -> Self;\n}","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"ops::wrapping::WrappingShl":["/// Performs a left shift that does not panic.\npub trait WrappingShl: Sized + Shl<usize, Output = Self> {\n    /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n    /// where `mask` removes any high order bits of `rhs` that would\n    /// cause the shift to exceed the bitwidth of the type.\n    ///\n    /// ```\n    /// use num_traits::WrappingShl;\n    ///\n    /// let x: u16 = 0x0001;\n    ///\n    /// assert_eq!(WrappingShl::wrapping_shl(&x, 0),  0x0001);\n    /// assert_eq!(WrappingShl::wrapping_shl(&x, 1),  0x0002);\n    /// assert_eq!(WrappingShl::wrapping_shl(&x, 15), 0x8000);\n    /// assert_eq!(WrappingShl::wrapping_shl(&x, 16), 0x0001);\n    /// ```\n    fn wrapping_shl(&self, rhs: u32) -> Self;\n}","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"ops::wrapping::WrappingShr":["/// Performs a right shift that does not panic.\npub trait WrappingShr: Sized + Shr<usize, Output = Self> {\n    /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n    /// where `mask` removes any high order bits of `rhs` that would\n    /// cause the shift to exceed the bitwidth of the type.\n    ///\n    /// ```\n    /// use num_traits::WrappingShr;\n    ///\n    /// let x: u16 = 0x8000;\n    ///\n    /// assert_eq!(WrappingShr::wrapping_shr(&x, 0),  0x8000);\n    /// assert_eq!(WrappingShr::wrapping_shr(&x, 1),  0x4000);\n    /// assert_eq!(WrappingShr::wrapping_shr(&x, 15), 0x0001);\n    /// assert_eq!(WrappingShr::wrapping_shr(&x, 16), 0x8000);\n    /// ```\n    fn wrapping_shr(&self, rhs: u32) -> Self;\n}","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"ops::wrapping::WrappingSub":["/// Performs subtraction that wraps around on overflow.\npub trait WrappingSub: Sized + Sub<Self, Output = Self> {\n    /// Wrapping (modular) subtraction. Computes `self - other`, wrapping around at the boundary\n    /// of the type.\n    fn wrapping_sub(&self, v: &Self) -> Self;\n}","Real(LocalPath(\"src/ops/wrapping.rs\"))"],"pow::Pow":["/// Binary operator for raising a value to a power.\npub trait Pow<RHS> {\n    /// The result after applying the operator.\n    type Output;\n\n    /// Returns `self` to the power `rhs`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use num_traits::Pow;\n    /// assert_eq!(Pow::pow(10u32, 2u32), 100);\n    /// ```\n    fn pow(self, rhs: RHS) -> Self::Output;\n}","Real(LocalPath(\"src/pow.rs\"))"],"pow::checked_pow":["/// Raises a value to the power of exp, returning `None` if an overflow occurred.\n///\n/// Note that `0` (`checked_pow(0, 0)`) returns `Some(1)`. Mathematically this is undefined.\n///\n/// Otherwise same as the `pow` function.\n///\n/// # Example\n///\n/// ```rust\n/// use num_traits::checked_pow;\n///\n/// assert_eq!(checked_pow(2i8, 4), Some(16));\n/// assert_eq!(checked_pow(7i8, 8), None);\n/// assert_eq!(checked_pow(7u32, 8), Some(5_764_801));\n/// assert_eq!(checked_pow(0u32, 0), Some(1)); // Be aware if this case affect you\n/// ```\n#[inline]\npub fn checked_pow<T: Clone + One + CheckedMul>(mut base: T, mut exp: usize) -> Option<T>{\n    if exp == 0 {\n        return Some(T::one());\n    }\n\n    macro_rules! optry {\n        ($expr:expr) => {\n            if let Some(val) = $expr {\n                val\n            } else {\n                return None;\n            }\n        };\n    }\n\n    while exp & 1 == 0 {\n        base = optry!(base.checked_mul(&base));\n        exp >>= 1;\n    }\n    if exp == 1 {\n        return Some(base);\n    }\n\n    let mut acc = base.clone();\n    while exp > 1 {\n        exp >>= 1;\n        base = optry!(base.checked_mul(&base));\n        if exp & 1 == 1 {\n            acc = optry!(acc.checked_mul(&base));\n        }\n    }\n    Some(acc)\n}","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a f32> for &'b f32>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a f32> for &'b f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a f32> for f32>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a f32> for f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a f64> for &'b f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a f64> for f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a i16> for &'b f32>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a i16> for &'b f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a i16> for f32>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a i16> for f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a i32> for &'b f32>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a i32> for &'b f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a i32> for f32>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a i32> for f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a i8> for &'b f32>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a i8> for &'b f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a i8> for f32>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a i8> for f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a u16> for &'b f32>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a u16> for &'b f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a u16> for f32>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a u16> for f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a u8> for &'b f32>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a u8> for &'b f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a u8> for f32>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<&'a u8> for f64>::pow":["#[inline]\nfn pow(self, rhs: &'a $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(*rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<f32> for &'a f32>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<f32> for &'a f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<f32> for f32>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<f32> for f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<f64> for &'a f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<f64> for f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<i16> for &'a f32>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<i16> for &'a f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<i16> for f32>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<i16> for f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<i32> for &'a f32>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<i32> for &'a f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<i32> for f32>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<i32> for f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<i8> for &'a f32>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<i8> for &'a f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<i8> for f32>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<i8> for f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<u16> for &'a f32>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<u16> for &'a f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<u16> for f32>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<u16> for f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<u8> for &'a f32>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<u8> for &'a f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(*self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<u8> for f32>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::float_impls::<impl pow::Pow<u8> for f64>::pow":["#[inline]\nfn pow(self, rhs: $rhs) -> $t{\n                ($method)(self, <$desired_rhs>::from(rhs))\n            }","Real(LocalPath(\"src/pow.rs\"))"],"pow::pow":["/// Raises a value to the power of exp, using exponentiation by squaring.\n///\n/// Note that `0` (`pow(0, 0)`) returns `1`. Mathematically this is undefined.\n///\n/// # Example\n///\n/// ```rust\n/// use num_traits::pow;\n///\n/// assert_eq!(pow(2i8, 4), 16);\n/// assert_eq!(pow(6u8, 3), 216);\n/// assert_eq!(pow(0u8, 0), 1); // Be aware if this case affects you\n/// ```\n#[inline]\npub fn pow<T: Clone + One + Mul<T, Output = T>>(mut base: T, mut exp: usize) -> T{\n    if exp == 0 {\n        return T::one();\n    }\n\n    while exp & 1 == 0 {\n        base = base.clone() * base;\n        exp >>= 1;\n    }\n    if exp == 1 {\n        return base;\n    }\n\n    let mut acc = base.clone();\n    while exp > 1 {\n        exp >>= 1;\n        base = base.clone() * base;\n        if exp & 1 == 1 {\n            acc = acc * base.clone();\n        }\n    }\n    acc\n}","Real(LocalPath(\"src/pow.rs\"))"],"real::Real":["/// A trait for real number types that do not necessarily have\n/// floating-point-specific characteristics such as NaN and infinity.\n///\n/// See [this Wikipedia article](https://en.wikipedia.org/wiki/Real_data_type)\n/// for a list of data types that could meaningfully implement this trait.\n///\n/// This trait is only available with the `std` feature, or with the `libm` feature otherwise.\npub trait Real: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> {\n    /// Returns the smallest finite value that this type can represent.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let x: f64 = Real::min_value();\n    ///\n    /// assert_eq!(x, f64::MIN);\n    /// ```\n    fn min_value() -> Self;\n\n    /// Returns the smallest positive, normalized value that this type can represent.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let x: f64 = Real::min_positive_value();\n    ///\n    /// assert_eq!(x, f64::MIN_POSITIVE);\n    /// ```\n    fn min_positive_value() -> Self;\n\n    /// Returns epsilon, a small positive value.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let x: f64 = Real::epsilon();\n    ///\n    /// assert_eq!(x, f64::EPSILON);\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// The default implementation will panic if `f32::EPSILON` cannot\n    /// be cast to `Self`.\n    fn epsilon() -> Self;\n\n    /// Returns the largest finite value that this type can represent.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let x: f64 = Real::max_value();\n    /// assert_eq!(x, f64::MAX);\n    /// ```\n    fn max_value() -> Self;\n\n    /// Returns the largest integer less than or equal to a number.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let f = 3.99;\n    /// let g = 3.0;\n    ///\n    /// assert_eq!(f.floor(), 3.0);\n    /// assert_eq!(g.floor(), 3.0);\n    /// ```\n    fn floor(self) -> Self;\n\n    /// Returns the smallest integer greater than or equal to a number.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let f = 3.01;\n    /// let g = 4.0;\n    ///\n    /// assert_eq!(f.ceil(), 4.0);\n    /// assert_eq!(g.ceil(), 4.0);\n    /// ```\n    fn ceil(self) -> Self;\n\n    /// Returns the nearest integer to a number. Round half-way cases away from\n    /// `0.0`.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let f = 3.3;\n    /// let g = -3.3;\n    ///\n    /// assert_eq!(f.round(), 3.0);\n    /// assert_eq!(g.round(), -3.0);\n    /// ```\n    fn round(self) -> Self;\n\n    /// Return the integer part of a number.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let f = 3.3;\n    /// let g = -3.7;\n    ///\n    /// assert_eq!(f.trunc(), 3.0);\n    /// assert_eq!(g.trunc(), -3.0);\n    /// ```\n    fn trunc(self) -> Self;\n\n    /// Returns the fractional part of a number.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let x = 3.5;\n    /// let y = -3.5;\n    /// let abs_difference_x = (x.fract() - 0.5).abs();\n    /// let abs_difference_y = (y.fract() - (-0.5)).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    /// ```\n    fn fract(self) -> Self;\n\n    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n    /// number is `Float::nan()`.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let x = 3.5;\n    /// let y = -3.5;\n    ///\n    /// let abs_difference_x = (x.abs() - x).abs();\n    /// let abs_difference_y = (y.abs() - (-y)).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    ///\n    /// assert!(::num_traits::Float::is_nan(f64::NAN.abs()));\n    /// ```\n    fn abs(self) -> Self;\n\n    /// Returns a number that represents the sign of `self`.\n    ///\n    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n    /// - `Float::nan()` if the number is `Float::nan()`\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let f = 3.5;\n    ///\n    /// assert_eq!(f.signum(), 1.0);\n    /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);\n    ///\n    /// assert!(f64::NAN.signum().is_nan());\n    /// ```\n    fn signum(self) -> Self;\n\n    /// Returns `true` if `self` is positive, including `+0.0`,\n    /// `Float::infinity()`, and with newer versions of Rust `f64::NAN`.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let neg_nan: f64 = -f64::NAN;\n    ///\n    /// let f = 7.0;\n    /// let g = -7.0;\n    ///\n    /// assert!(f.is_sign_positive());\n    /// assert!(!g.is_sign_positive());\n    /// assert!(!neg_nan.is_sign_positive());\n    /// ```\n    fn is_sign_positive(self) -> bool;\n\n    /// Returns `true` if `self` is negative, including `-0.0`,\n    /// `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let nan: f64 = f64::NAN;\n    ///\n    /// let f = 7.0;\n    /// let g = -7.0;\n    ///\n    /// assert!(!f.is_sign_negative());\n    /// assert!(g.is_sign_negative());\n    /// assert!(!nan.is_sign_negative());\n    /// ```\n    fn is_sign_negative(self) -> bool;\n\n    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n    /// error, yielding a more accurate result than an unfused multiply-add.\n    ///\n    /// Using `mul_add` can be more performant than an unfused multiply-add if\n    /// the target architecture has a dedicated `fma` CPU instruction.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let m = 10.0;\n    /// let x = 4.0;\n    /// let b = 60.0;\n    ///\n    /// // 100.0\n    /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn mul_add(self, a: Self, b: Self) -> Self;\n\n    /// Take the reciprocal (inverse) of a number, `1/x`.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let x = 2.0;\n    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn recip(self) -> Self;\n\n    /// Raise a number to an integer power.\n    ///\n    /// Using this function is generally faster than using `powf`\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let x = 2.0;\n    /// let abs_difference = (x.powi(2) - x*x).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn powi(self, n: i32) -> Self;\n\n    /// Raise a number to a real number power.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let x = 2.0;\n    /// let abs_difference = (x.powf(2.0) - x*x).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn powf(self, n: Self) -> Self;\n\n    /// Take the square root of a number.\n    ///\n    /// Returns NaN if `self` is a negative floating-point number.  \n    ///\n    /// # Panics\n    ///\n    /// If the implementing type doesn't support NaN, this method should panic if `self < 0`.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let positive = 4.0;\n    /// let negative = -4.0;\n    ///\n    /// let abs_difference = (positive.sqrt() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// assert!(::num_traits::Float::is_nan(negative.sqrt()));\n    /// ```\n    fn sqrt(self) -> Self;\n\n    /// Returns `e^(self)`, (the exponential function).\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let one = 1.0;\n    /// // e^1\n    /// let e = one.exp();\n    ///\n    /// // ln(e) - 1 == 0\n    /// let abs_difference = (e.ln() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn exp(self) -> Self;\n\n    /// Returns `2^(self)`.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let f = 2.0;\n    ///\n    /// // 2^2 - 4 == 0\n    /// let abs_difference = (f.exp2() - 4.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn exp2(self) -> Self;\n\n    /// Returns the natural logarithm of the number.\n    ///\n    /// # Panics\n    ///\n    /// If `self <= 0` and this type does not support a NaN representation, this function should panic.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let one = 1.0;\n    /// // e^1\n    /// let e = one.exp();\n    ///\n    /// // ln(e) - 1 == 0\n    /// let abs_difference = (e.ln() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn ln(self) -> Self;\n\n    /// Returns the logarithm of the number with respect to an arbitrary base.\n    ///\n    /// # Panics\n    ///\n    /// If `self <= 0` and this type does not support a NaN representation, this function should panic.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let ten = 10.0;\n    /// let two = 2.0;\n    ///\n    /// // log10(10) - 1 == 0\n    /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();\n    ///\n    /// // log2(2) - 1 == 0\n    /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();\n    ///\n    /// assert!(abs_difference_10 < 1e-10);\n    /// assert!(abs_difference_2 < 1e-10);\n    /// ```\n    fn log(self, base: Self) -> Self;\n\n    /// Returns the base 2 logarithm of the number.\n    ///\n    /// # Panics\n    ///\n    /// If `self <= 0` and this type does not support a NaN representation, this function should panic.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let two = 2.0;\n    ///\n    /// // log2(2) - 1 == 0\n    /// let abs_difference = (two.log2() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn log2(self) -> Self;\n\n    /// Returns the base 10 logarithm of the number.\n    ///\n    /// # Panics\n    ///\n    /// If `self <= 0` and this type does not support a NaN representation, this function should panic.\n    ///\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let ten = 10.0;\n    ///\n    /// // log10(10) - 1 == 0\n    /// let abs_difference = (ten.log10() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn log10(self) -> Self;\n\n    /// Converts radians to degrees.\n    ///\n    /// ```\n    /// use std::f64::consts;\n    ///\n    /// let angle = consts::PI;\n    ///\n    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn to_degrees(self) -> Self;\n\n    /// Converts degrees to radians.\n    ///\n    /// ```\n    /// use std::f64::consts;\n    ///\n    /// let angle = 180.0_f64;\n    ///\n    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn to_radians(self) -> Self;\n\n    /// Returns the maximum of the two numbers.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let x = 1.0;\n    /// let y = 2.0;\n    ///\n    /// assert_eq!(x.max(y), y);\n    /// ```\n    fn max(self, other: Self) -> Self;\n\n    /// Returns the minimum of the two numbers.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let x = 1.0;\n    /// let y = 2.0;\n    ///\n    /// assert_eq!(x.min(y), x);\n    /// ```\n    fn min(self, other: Self) -> Self;\n\n    /// The positive difference of two numbers.\n    ///\n    /// * If `self <= other`: `0:0`\n    /// * Else: `self - other`\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let x = 3.0;\n    /// let y = -3.0;\n    ///\n    /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n    /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    /// ```\n    fn abs_sub(self, other: Self) -> Self;\n\n    /// Take the cubic root of a number.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let x = 8.0;\n    ///\n    /// // x^(1/3) - 2 == 0\n    /// let abs_difference = (x.cbrt() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn cbrt(self) -> Self;\n\n    /// Calculate the length of the hypotenuse of a right-angle triangle given\n    /// legs of length `x` and `y`.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let x = 2.0;\n    /// let y = 3.0;\n    ///\n    /// // sqrt(x^2 + y^2)\n    /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn hypot(self, other: Self) -> Self;\n\n    /// Computes the sine of a number (in radians).\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let x = f64::consts::PI/2.0;\n    ///\n    /// let abs_difference = (x.sin() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn sin(self) -> Self;\n\n    /// Computes the cosine of a number (in radians).\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let x = 2.0*f64::consts::PI;\n    ///\n    /// let abs_difference = (x.cos() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn cos(self) -> Self;\n\n    /// Computes the tangent of a number (in radians).\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let x = f64::consts::PI/4.0;\n    /// let abs_difference = (x.tan() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-14);\n    /// ```\n    fn tan(self) -> Self;\n\n    /// Computes the arcsine of a number. Return value is in radians in\n    /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n    /// [-1, 1].\n    ///\n    /// # Panics\n    ///\n    /// If this type does not support a NaN representation, this function should panic\n    /// if the number is outside the range [-1, 1].\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let f = f64::consts::PI / 2.0;\n    ///\n    /// // asin(sin(pi/2))\n    /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn asin(self) -> Self;\n\n    /// Computes the arccosine of a number. Return value is in radians in\n    /// the range [0, pi] or NaN if the number is outside the range\n    /// [-1, 1].\n    ///\n    /// # Panics\n    ///\n    /// If this type does not support a NaN representation, this function should panic\n    /// if the number is outside the range [-1, 1].\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let f = f64::consts::PI / 4.0;\n    ///\n    /// // acos(cos(pi/4))\n    /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn acos(self) -> Self;\n\n    /// Computes the arctangent of a number. Return value is in radians in the\n    /// range [-pi/2, pi/2];\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let f = 1.0;\n    ///\n    /// // atan(tan(1))\n    /// let abs_difference = (f.tan().atan() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn atan(self) -> Self;\n\n    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).\n    ///\n    /// * `x = 0`, `y = 0`: `0`\n    /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n    /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`\n    /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let pi = f64::consts::PI;\n    /// // All angles from horizontal right (+x)\n    /// // 45 deg counter-clockwise\n    /// let x1 = 3.0;\n    /// let y1 = -3.0;\n    ///\n    /// // 135 deg clockwise\n    /// let x2 = -3.0;\n    /// let y2 = 3.0;\n    ///\n    /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n    /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n    ///\n    /// assert!(abs_difference_1 < 1e-10);\n    /// assert!(abs_difference_2 < 1e-10);\n    /// ```\n    fn atan2(self, other: Self) -> Self;\n\n    /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n    /// `(sin(x), cos(x))`.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let x = f64::consts::PI/4.0;\n    /// let f = x.sin_cos();\n    ///\n    /// let abs_difference_0 = (f.0 - x.sin()).abs();\n    /// let abs_difference_1 = (f.1 - x.cos()).abs();\n    ///\n    /// assert!(abs_difference_0 < 1e-10);\n    /// assert!(abs_difference_0 < 1e-10);\n    /// ```\n    fn sin_cos(self) -> (Self, Self);\n\n    /// Returns `e^(self) - 1` in a way that is accurate even if the\n    /// number is close to zero.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let x = 7.0;\n    ///\n    /// // e^(ln(7)) - 1\n    /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn exp_m1(self) -> Self;\n\n    /// Returns `ln(1+n)` (natural logarithm) more accurately than if\n    /// the operations were performed separately.\n    ///\n    /// # Panics\n    ///\n    /// If this type does not support a NaN representation, this function should panic\n    /// if `self-1 <= 0`.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let x = f64::consts::E - 1.0;\n    ///\n    /// // ln(1 + (e - 1)) == ln(e) == 1\n    /// let abs_difference = (x.ln_1p() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn ln_1p(self) -> Self;\n\n    /// Hyperbolic sine function.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let e = f64::consts::E;\n    /// let x = 1.0;\n    ///\n    /// let f = x.sinh();\n    /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n    /// let g = (e*e - 1.0)/(2.0*e);\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    fn sinh(self) -> Self;\n\n    /// Hyperbolic cosine function.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let e = f64::consts::E;\n    /// let x = 1.0;\n    /// let f = x.cosh();\n    /// // Solving cosh() at 1 gives this result\n    /// let g = (e*e + 1.0)/(2.0*e);\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// // Same result\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    fn cosh(self) -> Self;\n\n    /// Hyperbolic tangent function.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let e = f64::consts::E;\n    /// let x = 1.0;\n    ///\n    /// let f = x.tanh();\n    /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n    /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    fn tanh(self) -> Self;\n\n    /// Inverse hyperbolic sine function.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let x = 1.0;\n    /// let f = x.sinh().asinh();\n    ///\n    /// let abs_difference = (f - x).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    fn asinh(self) -> Self;\n\n    /// Inverse hyperbolic cosine function.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    ///\n    /// let x = 1.0;\n    /// let f = x.cosh().acosh();\n    ///\n    /// let abs_difference = (f - x).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    fn acosh(self) -> Self;\n\n    /// Inverse hyperbolic tangent function.\n    ///\n    /// ```\n    /// use num_traits::real::Real;\n    /// use std::f64;\n    ///\n    /// let e = f64::consts::E;\n    /// let f = e.tanh().atanh();\n    ///\n    /// let abs_difference = (f - e).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    fn atanh(self) -> Self;\n}","Real(LocalPath(\"src/real.rs\"))"],"sign::Signed":["/// Useful functions for signed numbers (i.e. numbers that can be negative).\npub trait Signed: Sized + Num + Neg<Output = Self> {\n    /// Computes the absolute value.\n    ///\n    /// For `f32` and `f64`, `NaN` will be returned if the number is `NaN`.\n    ///\n    /// For signed integers, `::MIN` will be returned if the number is `::MIN`.\n    fn abs(&self) -> Self;\n\n    /// The positive difference of two numbers.\n    ///\n    /// Returns `zero` if the number is less than or equal to `other`, otherwise the difference\n    /// between `self` and `other` is returned.\n    fn abs_sub(&self, other: &Self) -> Self;\n\n    /// Returns the sign of the number.\n    ///\n    /// For `f32` and `f64`:\n    ///\n    /// * `1.0` if the number is positive, `+0.0` or `INFINITY`\n    /// * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n    /// * `NaN` if the number is `NaN`\n    ///\n    /// For signed integers:\n    ///\n    /// * `0` if the number is zero\n    /// * `1` if the number is positive\n    /// * `-1` if the number is negative\n    fn signum(&self) -> Self;\n\n    /// Returns true if the number is positive and false if the number is zero or negative.\n    fn is_positive(&self) -> bool;\n\n    /// Returns true if the number is negative and false if the number is zero or positive.\n    fn is_negative(&self) -> bool;\n}","Real(LocalPath(\"src/sign.rs\"))"],"sign::Unsigned":["/// A trait for values which cannot be negative\npub trait Unsigned: Num {}","Real(LocalPath(\"src/sign.rs\"))"],"sign::abs":["/// Computes the absolute value.\n///\n/// For `f32` and `f64`, `NaN` will be returned if the number is `NaN`\n///\n/// For signed integers, `::MIN` will be returned if the number is `::MIN`.\n#[inline(always)]\npub fn abs<T: Signed>(value: T) -> T{\n    value.abs()\n}","Real(LocalPath(\"src/sign.rs\"))"],"sign::abs_sub":["/// The positive difference of two numbers.\n///\n/// Returns zero if `x` is less than or equal to `y`, otherwise the difference\n/// between `x` and `y` is returned.\n#[inline(always)]\npub fn abs_sub<T: Signed>(x: T, y: T) -> T{\n    x.abs_sub(&y)\n}","Real(LocalPath(\"src/sign.rs\"))"],"sign::signum":["/// Returns the sign of the number.\n///\n/// For `f32` and `f64`:\n///\n/// * `1.0` if the number is positive, `+0.0` or `INFINITY`\n/// * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n/// * `NaN` if the number is `NaN`\n///\n/// For signed integers:\n///\n/// * `0` if the number is zero\n/// * `1` if the number is positive\n/// * `-1` if the number is negative\n#[inline(always)]\npub fn signum<T: Signed>(value: T) -> T{\n    value.signum()\n}","Real(LocalPath(\"src/sign.rs\"))"],"str_to_ascii_lower_eq_str":["fn str_to_ascii_lower_eq_str(a: &str, b: &str) -> bool{\n    a.len() == b.len()\n        && a.bytes().zip(b.bytes()).all(|(a, b)| {\n            let a_to_ascii_lower = a | (((b'A' <= a && a <= b'Z') as u8) << 5);\n            a_to_ascii_lower == b\n        })\n}","Real(LocalPath(\"src/lib.rs\"))"]},"struct_constructor":{"(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(G, H, I, J, K, L, M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(H, I, J, K, L, M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(I, J, K, L, M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(J, K, L, M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(K, L, M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(L, M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(M, N, O, P, Q, R, S, T)":["max_value","min_value"],"(N, O, P, Q, R, S, T)":["max_value","min_value"],"(O, P, Q, R, S, T)":["max_value","min_value"],"(P, Q, R, S, T)":["max_value","min_value"],"(Q, R, S, T)":["max_value","min_value"],"(R, S, T)":["max_value","min_value"],"(S, T)":["max_value","min_value"],"(Self, Self)":["sin_cos"],"(Self, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"(T, T)":["sin_cos"],"(T,)":["max_value","min_value"],"(f32, f32)":["sin_cos"],"(f64, f64)":["sin_cos"],"(i128, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"(i16, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"(i32, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"(i64, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"(i8, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"(isize, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"(u128, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"(u16, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"(u32, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"(u64, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"(u64, i16, i8)":["integer_decode","integer_decode_f32","integer_decode_f64"],"(u8, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"(usize, bool)":["overflowing_add","overflowing_mul","overflowing_sub"],"<Self as ops::inv::Inv>::Output":["inv"],"<Self as ops::mul_add::MulAdd<A, B>>::Output":["mul_add"],"<Self as pow::Pow<RHS>>::Output":["pow"],"<f32 as ops::mul_add::MulAdd>::Output":["mul_add"],"<f64 as ops::mul_add::MulAdd>::Output":["mul_add"],"<i128 as ops::mul_add::MulAdd>::Output":["mul_add"],"<i16 as ops::mul_add::MulAdd>::Output":["mul_add"],"<i32 as ops::mul_add::MulAdd>::Output":["mul_add"],"<i64 as ops::mul_add::MulAdd>::Output":["mul_add"],"<i8 as ops::mul_add::MulAdd>::Output":["mul_add"],"<isize as ops::mul_add::MulAdd>::Output":["mul_add"],"<u128 as ops::mul_add::MulAdd>::Output":["mul_add"],"<u16 as ops::mul_add::MulAdd>::Output":["mul_add"],"<u32 as ops::mul_add::MulAdd>::Output":["mul_add"],"<u64 as ops::mul_add::MulAdd>::Output":["mul_add"],"<u8 as ops::mul_add::MulAdd>::Output":["mul_add"],"<usize as ops::mul_add::MulAdd>::Output":["mul_add"],"bool":["is_finite","is_infinite","is_nan","is_negative","is_normal","is_one","is_positive","is_sign_negative","is_sign_positive","is_zero","str_to_ascii_lower_eq_str"],"char":["as_"],"core::num::FpCategory":["classify"],"core::num::Wrapping":["abs","abs_sub","max_value","min_value","one","pow","signum","wrapping_add","wrapping_mul","wrapping_neg","wrapping_shl","wrapping_shr","wrapping_sub","zero"],"core::option::Option":["cast","checked_add","checked_div","checked_div_euclid","checked_mul","checked_neg","checked_pow","checked_rem","checked_rem_euclid","checked_shl","checked_shr","checked_sub","from","from_f32","from_f64","from_i128","from_i16","from_i32","from_i64","from_i8","from_isize","from_u128","from_u16","from_u32","from_u64","from_u8","from_usize","slice_shift_char","to_f32","to_f64","to_i128","to_i16","to_i32","to_i64","to_i8","to_isize","to_u128","to_u16","to_u32","to_u64","to_u8","to_usize"],"core::result::Result":["fmt","from_str_radix"],"f32":["E","FRAC_1_PI","FRAC_1_SQRT_2","FRAC_2_PI","FRAC_2_SQRT_PI","FRAC_PI_2","FRAC_PI_3","FRAC_PI_4","FRAC_PI_6","FRAC_PI_8","LN_10","LN_2","LOG10_2","LOG10_E","LOG2_10","LOG2_E","PI","SQRT_2","TAU","abs","abs_sub","as_","div_euclid","epsilon","infinity","inv","max_value","min_positive_value","min_value","nan","neg_infinity","neg_zero","one","pow","rem_euclid","signum","zero"],"f64":["E","FRAC_1_PI","FRAC_1_SQRT_2","FRAC_2_PI","FRAC_2_SQRT_PI","FRAC_PI_2","FRAC_PI_3","FRAC_PI_4","FRAC_PI_6","FRAC_PI_8","LN_10","LN_2","LOG10_2","LOG10_E","LOG2_10","LOG2_E","PI","SQRT_2","TAU","abs","abs_sub","as_","div_euclid","epsilon","infinity","inv","max_value","min_positive_value","min_value","nan","neg_infinity","neg_zero","one","pow","rem_euclid","signum","zero"],"i128":["abs","abs_sub","as_","div_euclid","max_value","min_value","one","pow","rem_euclid","saturating_add","saturating_mul","saturating_sub","signum","wrapping_add","wrapping_mul","wrapping_neg","wrapping_shl","wrapping_shr","wrapping_sub","zero"],"i16":["abs","abs_sub","as_","div_euclid","max_value","min_value","one","pow","rem_euclid","saturating_add","saturating_mul","saturating_sub","signum","wrapping_add","wrapping_mul","wrapping_neg","wrapping_shl","wrapping_shr","wrapping_sub","zero"],"i32":["abs","abs_sub","as_","div_euclid","max_value","min_value","one","pow","rem_euclid","saturating_add","saturating_mul","saturating_sub","signum","wrapping_add","wrapping_mul","wrapping_neg","wrapping_shl","wrapping_shr","wrapping_sub","zero"],"i64":["abs","abs_sub","as_","div_euclid","max_value","min_value","one","pow","rem_euclid","saturating_add","saturating_mul","saturating_sub","signum","wrapping_add","wrapping_mul","wrapping_neg","wrapping_shl","wrapping_shr","wrapping_sub","zero"],"i8":["abs","abs_sub","as_","div_euclid","max_value","min_value","one","pow","rem_euclid","saturating_add","saturating_mul","saturating_sub","signum","wrapping_add","wrapping_mul","wrapping_neg","wrapping_shl","wrapping_shr","wrapping_sub","zero"],"isize":["abs","abs_sub","as_","div_euclid","max_value","min_value","one","pow","rem_euclid","saturating_add","saturating_mul","saturating_sub","signum","wrapping_add","wrapping_mul","wrapping_neg","wrapping_shl","wrapping_shr","wrapping_sub","zero"],"u128":["as_","div_euclid","max_value","min_value","one","pow","rem_euclid","saturating_add","saturating_mul","saturating_sub","wrapping_add","wrapping_mul","wrapping_neg","wrapping_shl","wrapping_shr","wrapping_sub","zero"],"u16":["as_","div_euclid","max_value","min_value","one","pow","rem_euclid","saturating_add","saturating_mul","saturating_sub","wrapping_add","wrapping_mul","wrapping_neg","wrapping_shl","wrapping_shr","wrapping_sub","zero"],"u32":["as_","count_ones","count_zeros","div_euclid","leading_ones","leading_zeros","max_value","min_value","one","pow","rem_euclid","saturating_add","saturating_mul","saturating_sub","trailing_ones","trailing_zeros","wrapping_add","wrapping_mul","wrapping_neg","wrapping_sub","zero"],"u64":["as_","div_euclid","max_value","min_value","one","pow","rem_euclid","saturating_add","saturating_mul","saturating_sub","wrapping_add","wrapping_mul","wrapping_neg","wrapping_shl","wrapping_shr","wrapping_sub","zero"],"u8":["as_","div_euclid","max_value","min_value","one","pow","rem_euclid","saturating_add","saturating_mul","saturating_sub","wrapping_add","wrapping_mul","wrapping_neg","wrapping_shl","wrapping_shr","wrapping_sub","zero"],"usize":["as_","div_euclid","max_value","min_value","one","pow","rem_euclid","saturating_add","saturating_mul","saturating_sub","wrapping_add","wrapping_mul","wrapping_neg","wrapping_shl","wrapping_shr","wrapping_sub","zero"]},"struct_to_trait":{"<T as NumAssign>::T":["NumAssign"],"<T as NumAssignOps<Rhs>>::T":["NumAssignOps"],"<T as NumAssignRef>::T":["NumAssignRef"],"<T as NumOps<Rhs, Output>>::T":["NumOps"],"<T as NumRef>::T":["NumRef"],"<T as RefNum<Base>>::T":["RefNum"],"<T as bounds::LowerBounded>::T":["bounds::LowerBounded"],"<T as bounds::UpperBounded>::T":["bounds::UpperBounded"],"<T as real::Real>::T":["real::Real"],"FloatErrorKind":["core::fmt::Debug"],"ParseFloatError":["core::fmt::Debug","core::fmt::Display"],"core::num::Wrapping":["Num","bounds::Bounded","cast::FromPrimitive","cast::NumCast","cast::ToPrimitive","identities::One","identities::Zero","ops::wrapping::WrappingAdd","ops::wrapping::WrappingMul","ops::wrapping::WrappingNeg","ops::wrapping::WrappingShl","ops::wrapping::WrappingShr","ops::wrapping::WrappingSub","pow::Pow","sign::Signed","sign::Unsigned"]},"targets":{"<&'a core::num::Wrapping<i128> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<i128> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<i16> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<i16> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<i32> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<i32> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<i64> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<i64> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<i8> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<i8> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<isize> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<isize> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<u128> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<u128> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<u16> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<u16> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<u32> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<u32> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<u64> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<u64> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<u8> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<u8> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<usize> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a core::num::Wrapping<usize> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a f32 as ops::inv::Inv>::inv":["inv","Real(LocalPath(\"src/ops/inv.rs\"))","ops::inv::Inv"],"<&'a f64 as ops::inv::Inv>::inv":["inv","Real(LocalPath(\"src/ops/inv.rs\"))","ops::inv::Inv"],"<&'a i128 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i128 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i128 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i128 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i16 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i16 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i16 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i16 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i32 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i32 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i32 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i32 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i64 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i64 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i64 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i64 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i8 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i8 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i8 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a i8 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a isize as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a isize as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a isize as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a isize as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u128 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u128 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u128 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u128 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u16 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u16 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u16 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u16 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u32 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u32 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u32 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u32 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u64 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u64 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u64 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u64 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u8 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u8 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u8 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a u8 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a usize as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a usize as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a usize as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'a usize as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<i128> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<i128> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<i16> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<i16> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<i32> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<i32> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<i64> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<i64> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<i8> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<i8> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<isize> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<isize> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<u128> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<u128> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<u16> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<u16> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<u32> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<u32> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<u64> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<u64> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<u8> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<u8> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<usize> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b core::num::Wrapping<usize> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i128 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i128 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i128 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i128 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i16 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i16 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i16 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i16 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i32 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i32 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i32 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i32 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i64 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i64 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i64 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i64 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i8 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i8 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i8 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b i8 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b isize as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b isize as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b isize as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b isize as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u128 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u128 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u128 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u128 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u16 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u16 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u16 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u16 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u32 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u32 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u32 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u32 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u64 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u64 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u64 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u64 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u8 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u8 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u8 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b u8 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b usize as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b usize as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b usize as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<&'b usize as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<() as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<() as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(G, H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(H, I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(I, J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(J, K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(K, L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(L, M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(M, N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(N, O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(N, O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(O, P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(O, P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(P, Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(P, Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(Q, R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(Q, R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(R, S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(R, S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(S, T) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(S, T) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(T,) as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<(T,) as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<ParseFloatError as core::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","core::fmt::Display"],"<T as bounds::LowerBounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::LowerBounded"],"<T as bounds::UpperBounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::UpperBounded"],"<T as real::Real>::abs":["abs","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::abs_sub":["abs_sub","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::acos":["acos","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::acosh":["acosh","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::asin":["asin","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::asinh":["asinh","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::atan":["atan","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::atan2":["atan2","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::atanh":["atanh","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::cbrt":["cbrt","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::ceil":["ceil","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::cos":["cos","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::cosh":["cosh","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::epsilon":["epsilon","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::exp":["exp","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::exp2":["exp2","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::exp_m1":["exp_m1","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::floor":["floor","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::fract":["fract","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::hypot":["hypot","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::is_sign_negative":["is_sign_negative","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::is_sign_positive":["is_sign_positive","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::ln":["ln","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::ln_1p":["ln_1p","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::log":["log","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::log10":["log10","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::log2":["log2","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::max":["max","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::max_value":["max_value","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::min":["min","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::min_positive_value":["min_positive_value","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::min_value":["min_value","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::mul_add":["mul_add","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::powf":["powf","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::powi":["powi","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::recip":["recip","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::round":["round","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::signum":["signum","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::sin":["sin","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::sin_cos":["sin_cos","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::sinh":["sinh","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::sqrt":["sqrt","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::tan":["tan","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::tanh":["tanh","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::to_degrees":["to_degrees","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::to_radians":["to_radians","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<T as real::Real>::trunc":["trunc","Real(LocalPath(\"src/macros.rs\"))","real::Real"],"<bool as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<bool as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<bool as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<bool as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<bool as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<bool as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<bool as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<bool as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<bool as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<bool as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<bool as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<bool as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<char>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<char as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<core::num::Wrapping<T> as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<core::num::Wrapping<T> as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<core::num::Wrapping<T> as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<core::num::Wrapping<T> as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<core::num::Wrapping<T> as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<core::num::Wrapping<T> as identities::One>::set_one":["set_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<core::num::Wrapping<T> as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<core::num::Wrapping<T> as identities::Zero>::set_zero":["set_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<core::num::Wrapping<T> as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<core::num::Wrapping<T> as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<core::num::Wrapping<T> as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<core::num::Wrapping<T> as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<core::num::Wrapping<T> as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<core::num::Wrapping<T> as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<core::num::Wrapping<T> as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<core::num::Wrapping<T> as sign::Signed>::abs":["abs","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<core::num::Wrapping<T> as sign::Signed>::abs_sub":["abs_sub","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<core::num::Wrapping<T> as sign::Signed>::is_negative":["is_negative","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<core::num::Wrapping<T> as sign::Signed>::is_positive":["is_positive","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<core::num::Wrapping<T> as sign::Signed>::signum":["signum","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<core::num::Wrapping<i128> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i128> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i128> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i128> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i16> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i16> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i16> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i16> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i32> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i32> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i32> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i32> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i64> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i64> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i64> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i64> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i8> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i8> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i8> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<i8> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<isize> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<isize> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<isize> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<isize> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u128> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u128> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u128> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u128> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u16> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u16> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u16> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u16> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u32> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u32> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u32> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u32> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u64> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u64> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u64> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u64> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u8> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u8> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u8> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<u8> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<usize> as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<usize> as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<usize> as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<core::num::Wrapping<usize> as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<f32 as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<f32 as Num>::from_str_radix::pow":["pow","Real(LocalPath(\"src/lib.rs\"))",""],"<f32 as Num>::from_str_radix::slice_shift_char":["slice_shift_char","Real(LocalPath(\"src/lib.rs\"))",""],"<f32 as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<f32 as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<f32 as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f32 as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f32 as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<f32 as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f32 as float::Float>::abs":["abs","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::abs_sub":["abs_sub","Real(LocalPath(\"src/float.rs\"))","float::Float"],"<f32 as float::Float>::acos":["acos","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::acosh":["acosh","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::asin":["asin","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::asinh":["asinh","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::atan":["atan","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::atan2":["atan2","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::atanh":["atanh","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::cbrt":["cbrt","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::ceil":["ceil","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::classify":["classify","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::copysign":["copysign","Real(LocalPath(\"src/float.rs\"))","float::Float"],"<f32 as float::Float>::cos":["cos","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::cosh":["cosh","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::epsilon":["epsilon","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::exp":["exp","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::exp2":["exp2","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::exp_m1":["exp_m1","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::floor":["floor","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::fract":["fract","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::hypot":["hypot","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::infinity":["infinity","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::integer_decode":["integer_decode","Real(LocalPath(\"src/float.rs\"))","float::Float"],"<f32 as float::Float>::is_finite":["is_finite","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::is_infinite":["is_infinite","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::is_nan":["is_nan","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::is_normal":["is_normal","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::is_sign_negative":["is_sign_negative","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::is_sign_positive":["is_sign_positive","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::ln":["ln","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::ln_1p":["ln_1p","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::log":["log","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::log10":["log10","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::log2":["log2","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::max":["max","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::max_value":["max_value","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::min":["min","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::min_positive_value":["min_positive_value","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::min_value":["min_value","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::mul_add":["mul_add","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::nan":["nan","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::neg_infinity":["neg_infinity","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::neg_zero":["neg_zero","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::powf":["powf","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::powi":["powi","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::recip":["recip","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::round":["round","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::signum":["signum","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::sin":["sin","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::sin_cos":["sin_cos","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::sinh":["sinh","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::sqrt":["sqrt","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::tan":["tan","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::tanh":["tanh","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::to_degrees":["to_degrees","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::to_radians":["to_radians","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::Float>::trunc":["trunc","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f32 as float::FloatConst>::E":["E","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::FRAC_1_PI":["FRAC_1_PI","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::FRAC_1_SQRT_2":["FRAC_1_SQRT_2","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::FRAC_2_PI":["FRAC_2_PI","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::FRAC_2_SQRT_PI":["FRAC_2_SQRT_PI","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::FRAC_PI_2":["FRAC_PI_2","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::FRAC_PI_3":["FRAC_PI_3","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::FRAC_PI_4":["FRAC_PI_4","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::FRAC_PI_6":["FRAC_PI_6","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::FRAC_PI_8":["FRAC_PI_8","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::LN_10":["LN_10","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::LN_2":["LN_2","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::LOG10_2":["LOG10_2","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::LOG10_E":["LOG10_E","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::LOG2_10":["LOG2_10","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::LOG2_E":["LOG2_E","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::PI":["PI","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::SQRT_2":["SQRT_2","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatConst>::TAU":["TAU","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f32 as float::FloatCore>::abs":["abs","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::ceil":["ceil","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::classify":["classify","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::epsilon":["epsilon","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::floor":["floor","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::fract":["fract","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::infinity":["infinity","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::integer_decode":["integer_decode","Real(LocalPath(\"src/float.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::is_finite":["is_finite","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::is_infinite":["is_infinite","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::is_nan":["is_nan","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::is_normal":["is_normal","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::is_sign_negative":["is_sign_negative","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::is_sign_positive":["is_sign_positive","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::max":["max","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::max_value":["max_value","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::min":["min","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::min_positive_value":["min_positive_value","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::min_value":["min_value","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::nan":["nan","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::neg_infinity":["neg_infinity","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::neg_zero":["neg_zero","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::powi":["powi","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::recip":["recip","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::round":["round","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::signum":["signum","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::to_degrees":["to_degrees","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::to_radians":["to_radians","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as float::FloatCore>::trunc":["trunc","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f32 as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<f32 as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<f32 as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<f32 as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<f32 as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<f32 as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<f32 as ops::inv::Inv>::inv":["inv","Real(LocalPath(\"src/ops/inv.rs\"))","ops::inv::Inv"],"<f32 as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<f32 as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<f32 as sign::Signed>::abs":["abs","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<f32 as sign::Signed>::abs_sub":["abs_sub","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<f32 as sign::Signed>::is_negative":["is_negative","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<f32 as sign::Signed>::is_positive":["is_positive","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<f32 as sign::Signed>::signum":["signum","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<f64 as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<f64 as Num>::from_str_radix::pow":["pow","Real(LocalPath(\"src/lib.rs\"))",""],"<f64 as Num>::from_str_radix::slice_shift_char":["slice_shift_char","Real(LocalPath(\"src/lib.rs\"))",""],"<f64 as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<f64 as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<f64 as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<f64 as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<f64 as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<f64 as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<f64 as float::Float>::abs":["abs","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::abs_sub":["abs_sub","Real(LocalPath(\"src/float.rs\"))","float::Float"],"<f64 as float::Float>::acos":["acos","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::acosh":["acosh","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::asin":["asin","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::asinh":["asinh","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::atan":["atan","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::atan2":["atan2","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::atanh":["atanh","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::cbrt":["cbrt","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::ceil":["ceil","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::classify":["classify","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::copysign":["copysign","Real(LocalPath(\"src/float.rs\"))","float::Float"],"<f64 as float::Float>::cos":["cos","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::cosh":["cosh","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::epsilon":["epsilon","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::exp":["exp","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::exp2":["exp2","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::exp_m1":["exp_m1","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::floor":["floor","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::fract":["fract","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::hypot":["hypot","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::infinity":["infinity","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::integer_decode":["integer_decode","Real(LocalPath(\"src/float.rs\"))","float::Float"],"<f64 as float::Float>::is_finite":["is_finite","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::is_infinite":["is_infinite","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::is_nan":["is_nan","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::is_normal":["is_normal","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::is_sign_negative":["is_sign_negative","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::is_sign_positive":["is_sign_positive","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::ln":["ln","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::ln_1p":["ln_1p","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::log":["log","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::log10":["log10","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::log2":["log2","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::max":["max","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::max_value":["max_value","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::min":["min","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::min_positive_value":["min_positive_value","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::min_value":["min_value","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::mul_add":["mul_add","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::nan":["nan","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::neg_infinity":["neg_infinity","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::neg_zero":["neg_zero","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::powf":["powf","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::powi":["powi","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::recip":["recip","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::round":["round","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::signum":["signum","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::sin":["sin","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::sin_cos":["sin_cos","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::sinh":["sinh","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::sqrt":["sqrt","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::tan":["tan","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::tanh":["tanh","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::to_degrees":["to_degrees","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::to_radians":["to_radians","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::Float>::trunc":["trunc","Real(LocalPath(\"src/macros.rs\"))","float::Float"],"<f64 as float::FloatConst>::E":["E","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::FRAC_1_PI":["FRAC_1_PI","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::FRAC_1_SQRT_2":["FRAC_1_SQRT_2","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::FRAC_2_PI":["FRAC_2_PI","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::FRAC_2_SQRT_PI":["FRAC_2_SQRT_PI","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::FRAC_PI_2":["FRAC_PI_2","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::FRAC_PI_3":["FRAC_PI_3","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::FRAC_PI_4":["FRAC_PI_4","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::FRAC_PI_6":["FRAC_PI_6","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::FRAC_PI_8":["FRAC_PI_8","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::LN_10":["LN_10","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::LN_2":["LN_2","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::LOG10_2":["LOG10_2","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::LOG10_E":["LOG10_E","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::LOG2_10":["LOG2_10","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::LOG2_E":["LOG2_E","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::PI":["PI","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::SQRT_2":["SQRT_2","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatConst>::TAU":["TAU","Real(LocalPath(\"src/macros.rs\"))","float::FloatConst"],"<f64 as float::FloatCore>::abs":["abs","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::ceil":["ceil","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::classify":["classify","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::epsilon":["epsilon","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::floor":["floor","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::fract":["fract","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::infinity":["infinity","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::integer_decode":["integer_decode","Real(LocalPath(\"src/float.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::is_finite":["is_finite","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::is_infinite":["is_infinite","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::is_nan":["is_nan","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::is_normal":["is_normal","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::is_sign_negative":["is_sign_negative","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::is_sign_positive":["is_sign_positive","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::max":["max","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::max_value":["max_value","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::min":["min","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::min_positive_value":["min_positive_value","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::min_value":["min_value","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::nan":["nan","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::neg_infinity":["neg_infinity","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::neg_zero":["neg_zero","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::powi":["powi","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::recip":["recip","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::round":["round","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::signum":["signum","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::to_degrees":["to_degrees","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::to_radians":["to_radians","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as float::FloatCore>::trunc":["trunc","Real(LocalPath(\"src/macros.rs\"))","float::FloatCore"],"<f64 as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<f64 as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<f64 as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<f64 as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<f64 as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<f64 as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<f64 as ops::inv::Inv>::inv":["inv","Real(LocalPath(\"src/ops/inv.rs\"))","ops::inv::Inv"],"<f64 as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<f64 as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<f64 as sign::Signed>::abs":["abs","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<f64 as sign::Signed>::abs_sub":["abs_sub","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<f64 as sign::Signed>::is_negative":["is_negative","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<f64 as sign::Signed>::is_positive":["is_positive","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<f64 as sign::Signed>::signum":["signum","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i128 as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<i128 as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<i128 as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<i128 as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i128 as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i128 as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<i128 as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i128 as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<i128 as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<i128 as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<i128 as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<i128 as int::PrimInt>::count_ones":["count_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::count_zeros":["count_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::from_be":["from_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::from_le":["from_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::leading_zeros":["leading_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::pow":["pow","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::rotate_left":["rotate_left","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::rotate_right":["rotate_right","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::signed_shl":["signed_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::signed_shr":["signed_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::swap_bytes":["swap_bytes","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::to_be":["to_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::to_le":["to_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::trailing_zeros":["trailing_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::unsigned_shl":["unsigned_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as int::PrimInt>::unsigned_shr":["unsigned_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i128 as ops::checked::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedAdd"],"<i128 as ops::checked::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedDiv"],"<i128 as ops::checked::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedMul"],"<i128 as ops::checked::CheckedNeg>::checked_neg":["checked_neg","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedNeg"],"<i128 as ops::checked::CheckedRem>::checked_rem":["checked_rem","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedRem"],"<i128 as ops::checked::CheckedShl>::checked_shl":["checked_shl","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShl"],"<i128 as ops::checked::CheckedShr>::checked_shr":["checked_shr","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShr"],"<i128 as ops::checked::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedSub"],"<i128 as ops::euclid::CheckedEuclid>::checked_div_euclid":["checked_div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<i128 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["checked_rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<i128 as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<i128 as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<i128 as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<i128 as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<i128 as ops::overflowing::OverflowingAdd>::overflowing_add":["overflowing_add","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingAdd"],"<i128 as ops::overflowing::OverflowingMul>::overflowing_mul":["overflowing_mul","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingMul"],"<i128 as ops::overflowing::OverflowingSub>::overflowing_sub":["overflowing_sub","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingSub"],"<i128 as ops::saturating::Saturating>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<i128 as ops::saturating::Saturating>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<i128 as ops::saturating::SaturatingAdd>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingAdd"],"<i128 as ops::saturating::SaturatingMul>::saturating_mul":["saturating_mul","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingMul"],"<i128 as ops::saturating::SaturatingSub>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingSub"],"<i128 as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<i128 as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<i128 as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<i128 as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<i128 as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<i128 as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<i128 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i128 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i128 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i128 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i128 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i128 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i128 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i128 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i128 as sign::Signed>::abs":["abs","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i128 as sign::Signed>::abs_sub":["abs_sub","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i128 as sign::Signed>::is_negative":["is_negative","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i128 as sign::Signed>::is_positive":["is_positive","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i128 as sign::Signed>::signum":["signum","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i16 as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<i16 as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<i16 as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<i16 as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i16 as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i16 as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<i16 as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i16 as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<i16 as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<i16 as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<i16 as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<i16 as int::PrimInt>::count_ones":["count_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::count_zeros":["count_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::from_be":["from_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::from_le":["from_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::leading_zeros":["leading_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::pow":["pow","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::rotate_left":["rotate_left","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::rotate_right":["rotate_right","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::signed_shl":["signed_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::signed_shr":["signed_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::swap_bytes":["swap_bytes","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::to_be":["to_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::to_le":["to_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::trailing_zeros":["trailing_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::unsigned_shl":["unsigned_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as int::PrimInt>::unsigned_shr":["unsigned_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i16 as ops::checked::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedAdd"],"<i16 as ops::checked::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedDiv"],"<i16 as ops::checked::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedMul"],"<i16 as ops::checked::CheckedNeg>::checked_neg":["checked_neg","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedNeg"],"<i16 as ops::checked::CheckedRem>::checked_rem":["checked_rem","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedRem"],"<i16 as ops::checked::CheckedShl>::checked_shl":["checked_shl","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShl"],"<i16 as ops::checked::CheckedShr>::checked_shr":["checked_shr","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShr"],"<i16 as ops::checked::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedSub"],"<i16 as ops::euclid::CheckedEuclid>::checked_div_euclid":["checked_div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<i16 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["checked_rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<i16 as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<i16 as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<i16 as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<i16 as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<i16 as ops::overflowing::OverflowingAdd>::overflowing_add":["overflowing_add","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingAdd"],"<i16 as ops::overflowing::OverflowingMul>::overflowing_mul":["overflowing_mul","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingMul"],"<i16 as ops::overflowing::OverflowingSub>::overflowing_sub":["overflowing_sub","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingSub"],"<i16 as ops::saturating::Saturating>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<i16 as ops::saturating::Saturating>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<i16 as ops::saturating::SaturatingAdd>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingAdd"],"<i16 as ops::saturating::SaturatingMul>::saturating_mul":["saturating_mul","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingMul"],"<i16 as ops::saturating::SaturatingSub>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingSub"],"<i16 as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<i16 as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<i16 as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<i16 as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<i16 as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<i16 as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<i16 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i16 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i16 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i16 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i16 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i16 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i16 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i16 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i16 as sign::Signed>::abs":["abs","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i16 as sign::Signed>::abs_sub":["abs_sub","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i16 as sign::Signed>::is_negative":["is_negative","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i16 as sign::Signed>::is_positive":["is_positive","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i16 as sign::Signed>::signum":["signum","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i32 as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<i32 as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<i32 as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<i32 as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i32 as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i32 as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<i32 as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i32 as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<i32 as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<i32 as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<i32 as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<i32 as int::PrimInt>::count_ones":["count_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::count_zeros":["count_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::from_be":["from_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::from_le":["from_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::leading_zeros":["leading_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::pow":["pow","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::rotate_left":["rotate_left","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::rotate_right":["rotate_right","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::signed_shl":["signed_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::signed_shr":["signed_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::swap_bytes":["swap_bytes","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::to_be":["to_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::to_le":["to_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::trailing_zeros":["trailing_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::unsigned_shl":["unsigned_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as int::PrimInt>::unsigned_shr":["unsigned_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i32 as ops::checked::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedAdd"],"<i32 as ops::checked::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedDiv"],"<i32 as ops::checked::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedMul"],"<i32 as ops::checked::CheckedNeg>::checked_neg":["checked_neg","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedNeg"],"<i32 as ops::checked::CheckedRem>::checked_rem":["checked_rem","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedRem"],"<i32 as ops::checked::CheckedShl>::checked_shl":["checked_shl","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShl"],"<i32 as ops::checked::CheckedShr>::checked_shr":["checked_shr","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShr"],"<i32 as ops::checked::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedSub"],"<i32 as ops::euclid::CheckedEuclid>::checked_div_euclid":["checked_div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<i32 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["checked_rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<i32 as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<i32 as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<i32 as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<i32 as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<i32 as ops::overflowing::OverflowingAdd>::overflowing_add":["overflowing_add","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingAdd"],"<i32 as ops::overflowing::OverflowingMul>::overflowing_mul":["overflowing_mul","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingMul"],"<i32 as ops::overflowing::OverflowingSub>::overflowing_sub":["overflowing_sub","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingSub"],"<i32 as ops::saturating::Saturating>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<i32 as ops::saturating::Saturating>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<i32 as ops::saturating::SaturatingAdd>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingAdd"],"<i32 as ops::saturating::SaturatingMul>::saturating_mul":["saturating_mul","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingMul"],"<i32 as ops::saturating::SaturatingSub>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingSub"],"<i32 as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<i32 as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<i32 as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<i32 as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<i32 as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<i32 as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<i32 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i32 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i32 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i32 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i32 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i32 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i32 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i32 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i32 as sign::Signed>::abs":["abs","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i32 as sign::Signed>::abs_sub":["abs_sub","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i32 as sign::Signed>::is_negative":["is_negative","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i32 as sign::Signed>::is_positive":["is_positive","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i32 as sign::Signed>::signum":["signum","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i64 as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<i64 as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<i64 as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<i64 as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i64 as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i64 as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<i64 as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i64 as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<i64 as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<i64 as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<i64 as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<i64 as int::PrimInt>::count_ones":["count_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::count_zeros":["count_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::from_be":["from_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::from_le":["from_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::leading_zeros":["leading_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::pow":["pow","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::rotate_left":["rotate_left","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::rotate_right":["rotate_right","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::signed_shl":["signed_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::signed_shr":["signed_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::swap_bytes":["swap_bytes","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::to_be":["to_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::to_le":["to_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::trailing_zeros":["trailing_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::unsigned_shl":["unsigned_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as int::PrimInt>::unsigned_shr":["unsigned_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i64 as ops::checked::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedAdd"],"<i64 as ops::checked::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedDiv"],"<i64 as ops::checked::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedMul"],"<i64 as ops::checked::CheckedNeg>::checked_neg":["checked_neg","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedNeg"],"<i64 as ops::checked::CheckedRem>::checked_rem":["checked_rem","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedRem"],"<i64 as ops::checked::CheckedShl>::checked_shl":["checked_shl","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShl"],"<i64 as ops::checked::CheckedShr>::checked_shr":["checked_shr","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShr"],"<i64 as ops::checked::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedSub"],"<i64 as ops::euclid::CheckedEuclid>::checked_div_euclid":["checked_div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<i64 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["checked_rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<i64 as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<i64 as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<i64 as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<i64 as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<i64 as ops::overflowing::OverflowingAdd>::overflowing_add":["overflowing_add","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingAdd"],"<i64 as ops::overflowing::OverflowingMul>::overflowing_mul":["overflowing_mul","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingMul"],"<i64 as ops::overflowing::OverflowingSub>::overflowing_sub":["overflowing_sub","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingSub"],"<i64 as ops::saturating::Saturating>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<i64 as ops::saturating::Saturating>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<i64 as ops::saturating::SaturatingAdd>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingAdd"],"<i64 as ops::saturating::SaturatingMul>::saturating_mul":["saturating_mul","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingMul"],"<i64 as ops::saturating::SaturatingSub>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingSub"],"<i64 as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<i64 as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<i64 as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<i64 as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<i64 as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<i64 as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<i64 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i64 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i64 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i64 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i64 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i64 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i64 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i64 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i64 as sign::Signed>::abs":["abs","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i64 as sign::Signed>::abs_sub":["abs_sub","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i64 as sign::Signed>::is_negative":["is_negative","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i64 as sign::Signed>::is_positive":["is_positive","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i64 as sign::Signed>::signum":["signum","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i8 as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<i8 as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<i8 as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<i8 as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<i8 as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<i8 as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<i8 as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<i8 as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<i8 as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<i8 as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<i8 as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<i8 as int::PrimInt>::count_ones":["count_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::count_zeros":["count_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::from_be":["from_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::from_le":["from_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::leading_zeros":["leading_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::pow":["pow","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::rotate_left":["rotate_left","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::rotate_right":["rotate_right","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::signed_shl":["signed_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::signed_shr":["signed_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::swap_bytes":["swap_bytes","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::to_be":["to_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::to_le":["to_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::trailing_zeros":["trailing_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::unsigned_shl":["unsigned_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as int::PrimInt>::unsigned_shr":["unsigned_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<i8 as ops::checked::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedAdd"],"<i8 as ops::checked::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedDiv"],"<i8 as ops::checked::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedMul"],"<i8 as ops::checked::CheckedNeg>::checked_neg":["checked_neg","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedNeg"],"<i8 as ops::checked::CheckedRem>::checked_rem":["checked_rem","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedRem"],"<i8 as ops::checked::CheckedShl>::checked_shl":["checked_shl","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShl"],"<i8 as ops::checked::CheckedShr>::checked_shr":["checked_shr","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShr"],"<i8 as ops::checked::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedSub"],"<i8 as ops::euclid::CheckedEuclid>::checked_div_euclid":["checked_div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<i8 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["checked_rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<i8 as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<i8 as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<i8 as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<i8 as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<i8 as ops::overflowing::OverflowingAdd>::overflowing_add":["overflowing_add","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingAdd"],"<i8 as ops::overflowing::OverflowingMul>::overflowing_mul":["overflowing_mul","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingMul"],"<i8 as ops::overflowing::OverflowingSub>::overflowing_sub":["overflowing_sub","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingSub"],"<i8 as ops::saturating::Saturating>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<i8 as ops::saturating::Saturating>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<i8 as ops::saturating::SaturatingAdd>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingAdd"],"<i8 as ops::saturating::SaturatingMul>::saturating_mul":["saturating_mul","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingMul"],"<i8 as ops::saturating::SaturatingSub>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingSub"],"<i8 as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<i8 as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<i8 as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<i8 as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<i8 as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<i8 as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<i8 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i8 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i8 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i8 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i8 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i8 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i8 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i8 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<i8 as sign::Signed>::abs":["abs","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i8 as sign::Signed>::abs_sub":["abs_sub","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i8 as sign::Signed>::is_negative":["is_negative","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i8 as sign::Signed>::is_positive":["is_positive","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<i8 as sign::Signed>::signum":["signum","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<isize as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<isize as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<isize as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<isize as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<isize as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<isize as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<isize as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<isize as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<isize as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<isize as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<isize as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<isize as int::PrimInt>::count_ones":["count_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::count_zeros":["count_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::from_be":["from_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::from_le":["from_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::leading_zeros":["leading_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::pow":["pow","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::rotate_left":["rotate_left","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::rotate_right":["rotate_right","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::signed_shl":["signed_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::signed_shr":["signed_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::swap_bytes":["swap_bytes","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::to_be":["to_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::to_le":["to_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::trailing_zeros":["trailing_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::unsigned_shl":["unsigned_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as int::PrimInt>::unsigned_shr":["unsigned_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<isize as ops::checked::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedAdd"],"<isize as ops::checked::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedDiv"],"<isize as ops::checked::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedMul"],"<isize as ops::checked::CheckedNeg>::checked_neg":["checked_neg","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedNeg"],"<isize as ops::checked::CheckedRem>::checked_rem":["checked_rem","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedRem"],"<isize as ops::checked::CheckedShl>::checked_shl":["checked_shl","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShl"],"<isize as ops::checked::CheckedShr>::checked_shr":["checked_shr","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShr"],"<isize as ops::checked::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedSub"],"<isize as ops::euclid::CheckedEuclid>::checked_div_euclid":["checked_div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<isize as ops::euclid::CheckedEuclid>::checked_rem_euclid":["checked_rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<isize as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<isize as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<isize as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<isize as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<isize as ops::overflowing::OverflowingAdd>::overflowing_add":["overflowing_add","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingAdd"],"<isize as ops::overflowing::OverflowingMul>::overflowing_mul":["overflowing_mul","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingMul"],"<isize as ops::overflowing::OverflowingSub>::overflowing_sub":["overflowing_sub","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingSub"],"<isize as ops::saturating::Saturating>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<isize as ops::saturating::Saturating>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<isize as ops::saturating::SaturatingAdd>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingAdd"],"<isize as ops::saturating::SaturatingMul>::saturating_mul":["saturating_mul","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingMul"],"<isize as ops::saturating::SaturatingSub>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingSub"],"<isize as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<isize as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<isize as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<isize as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<isize as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<isize as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<isize as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<isize as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<isize as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<isize as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<isize as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<isize as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<isize as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<isize as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<isize as sign::Signed>::abs":["abs","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<isize as sign::Signed>::abs_sub":["abs_sub","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<isize as sign::Signed>::is_negative":["is_negative","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<isize as sign::Signed>::is_positive":["is_positive","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<isize as sign::Signed>::signum":["signum","Real(LocalPath(\"src/sign.rs\"))","sign::Signed"],"<u128 as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<u128 as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<u128 as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<u128 as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u128 as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u128 as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<u128 as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u128 as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<u128 as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<u128 as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<u128 as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<u128 as int::PrimInt>::count_ones":["count_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::count_zeros":["count_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::from_be":["from_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::from_le":["from_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::leading_zeros":["leading_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::pow":["pow","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::rotate_left":["rotate_left","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::rotate_right":["rotate_right","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::signed_shl":["signed_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::signed_shr":["signed_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::swap_bytes":["swap_bytes","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::to_be":["to_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::to_le":["to_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::trailing_zeros":["trailing_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::unsigned_shl":["unsigned_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as int::PrimInt>::unsigned_shr":["unsigned_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u128 as ops::checked::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedAdd"],"<u128 as ops::checked::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedDiv"],"<u128 as ops::checked::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedMul"],"<u128 as ops::checked::CheckedNeg>::checked_neg":["checked_neg","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedNeg"],"<u128 as ops::checked::CheckedRem>::checked_rem":["checked_rem","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedRem"],"<u128 as ops::checked::CheckedShl>::checked_shl":["checked_shl","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShl"],"<u128 as ops::checked::CheckedShr>::checked_shr":["checked_shr","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShr"],"<u128 as ops::checked::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedSub"],"<u128 as ops::euclid::CheckedEuclid>::checked_div_euclid":["checked_div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<u128 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["checked_rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<u128 as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<u128 as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<u128 as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<u128 as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<u128 as ops::overflowing::OverflowingAdd>::overflowing_add":["overflowing_add","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingAdd"],"<u128 as ops::overflowing::OverflowingMul>::overflowing_mul":["overflowing_mul","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingMul"],"<u128 as ops::overflowing::OverflowingSub>::overflowing_sub":["overflowing_sub","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingSub"],"<u128 as ops::saturating::Saturating>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<u128 as ops::saturating::Saturating>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<u128 as ops::saturating::SaturatingAdd>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingAdd"],"<u128 as ops::saturating::SaturatingMul>::saturating_mul":["saturating_mul","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingMul"],"<u128 as ops::saturating::SaturatingSub>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingSub"],"<u128 as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<u128 as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<u128 as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<u128 as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<u128 as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<u128 as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<u128 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u128 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u128 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u128 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u128 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u128 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u128 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u128 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u16 as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<u16 as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<u16 as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<u16 as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u16 as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u16 as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<u16 as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u16 as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<u16 as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<u16 as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<u16 as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<u16 as int::PrimInt>::count_ones":["count_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::count_zeros":["count_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::from_be":["from_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::from_le":["from_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::leading_zeros":["leading_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::pow":["pow","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::rotate_left":["rotate_left","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::rotate_right":["rotate_right","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::signed_shl":["signed_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::signed_shr":["signed_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::swap_bytes":["swap_bytes","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::to_be":["to_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::to_le":["to_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::trailing_zeros":["trailing_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::unsigned_shl":["unsigned_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as int::PrimInt>::unsigned_shr":["unsigned_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u16 as ops::checked::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedAdd"],"<u16 as ops::checked::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedDiv"],"<u16 as ops::checked::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedMul"],"<u16 as ops::checked::CheckedNeg>::checked_neg":["checked_neg","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedNeg"],"<u16 as ops::checked::CheckedRem>::checked_rem":["checked_rem","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedRem"],"<u16 as ops::checked::CheckedShl>::checked_shl":["checked_shl","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShl"],"<u16 as ops::checked::CheckedShr>::checked_shr":["checked_shr","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShr"],"<u16 as ops::checked::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedSub"],"<u16 as ops::euclid::CheckedEuclid>::checked_div_euclid":["checked_div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<u16 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["checked_rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<u16 as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<u16 as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<u16 as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<u16 as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<u16 as ops::overflowing::OverflowingAdd>::overflowing_add":["overflowing_add","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingAdd"],"<u16 as ops::overflowing::OverflowingMul>::overflowing_mul":["overflowing_mul","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingMul"],"<u16 as ops::overflowing::OverflowingSub>::overflowing_sub":["overflowing_sub","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingSub"],"<u16 as ops::saturating::Saturating>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<u16 as ops::saturating::Saturating>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<u16 as ops::saturating::SaturatingAdd>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingAdd"],"<u16 as ops::saturating::SaturatingMul>::saturating_mul":["saturating_mul","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingMul"],"<u16 as ops::saturating::SaturatingSub>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingSub"],"<u16 as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<u16 as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<u16 as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<u16 as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<u16 as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<u16 as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<u16 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u16 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u16 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u16 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u16 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u16 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u16 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u16 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u32 as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<u32 as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<u32 as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<u32 as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u32 as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u32 as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<u32 as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u32 as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<u32 as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<u32 as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<u32 as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<u32 as int::PrimInt>::count_ones":["count_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::count_zeros":["count_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::from_be":["from_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::from_le":["from_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::leading_zeros":["leading_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::pow":["pow","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::rotate_left":["rotate_left","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::rotate_right":["rotate_right","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::signed_shl":["signed_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::signed_shr":["signed_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::swap_bytes":["swap_bytes","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::to_be":["to_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::to_le":["to_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::trailing_zeros":["trailing_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::unsigned_shl":["unsigned_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as int::PrimInt>::unsigned_shr":["unsigned_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u32 as ops::checked::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedAdd"],"<u32 as ops::checked::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedDiv"],"<u32 as ops::checked::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedMul"],"<u32 as ops::checked::CheckedNeg>::checked_neg":["checked_neg","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedNeg"],"<u32 as ops::checked::CheckedRem>::checked_rem":["checked_rem","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedRem"],"<u32 as ops::checked::CheckedShl>::checked_shl":["checked_shl","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShl"],"<u32 as ops::checked::CheckedShr>::checked_shr":["checked_shr","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShr"],"<u32 as ops::checked::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedSub"],"<u32 as ops::euclid::CheckedEuclid>::checked_div_euclid":["checked_div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<u32 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["checked_rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<u32 as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<u32 as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<u32 as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<u32 as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<u32 as ops::overflowing::OverflowingAdd>::overflowing_add":["overflowing_add","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingAdd"],"<u32 as ops::overflowing::OverflowingMul>::overflowing_mul":["overflowing_mul","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingMul"],"<u32 as ops::overflowing::OverflowingSub>::overflowing_sub":["overflowing_sub","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingSub"],"<u32 as ops::saturating::Saturating>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<u32 as ops::saturating::Saturating>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<u32 as ops::saturating::SaturatingAdd>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingAdd"],"<u32 as ops::saturating::SaturatingMul>::saturating_mul":["saturating_mul","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingMul"],"<u32 as ops::saturating::SaturatingSub>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingSub"],"<u32 as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<u32 as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<u32 as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<u32 as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<u32 as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<u32 as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<u32 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u32 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u32 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u32 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u32 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u32 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u32 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u32 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u64 as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<u64 as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<u64 as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<u64 as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u64 as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u64 as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<u64 as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u64 as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<u64 as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<u64 as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<u64 as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<u64 as int::PrimInt>::count_ones":["count_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::count_zeros":["count_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::from_be":["from_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::from_le":["from_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::leading_zeros":["leading_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::pow":["pow","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::rotate_left":["rotate_left","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::rotate_right":["rotate_right","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::signed_shl":["signed_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::signed_shr":["signed_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::swap_bytes":["swap_bytes","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::to_be":["to_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::to_le":["to_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::trailing_zeros":["trailing_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::unsigned_shl":["unsigned_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as int::PrimInt>::unsigned_shr":["unsigned_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u64 as ops::checked::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedAdd"],"<u64 as ops::checked::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedDiv"],"<u64 as ops::checked::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedMul"],"<u64 as ops::checked::CheckedNeg>::checked_neg":["checked_neg","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedNeg"],"<u64 as ops::checked::CheckedRem>::checked_rem":["checked_rem","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedRem"],"<u64 as ops::checked::CheckedShl>::checked_shl":["checked_shl","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShl"],"<u64 as ops::checked::CheckedShr>::checked_shr":["checked_shr","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShr"],"<u64 as ops::checked::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedSub"],"<u64 as ops::euclid::CheckedEuclid>::checked_div_euclid":["checked_div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<u64 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["checked_rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<u64 as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<u64 as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<u64 as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<u64 as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<u64 as ops::overflowing::OverflowingAdd>::overflowing_add":["overflowing_add","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingAdd"],"<u64 as ops::overflowing::OverflowingMul>::overflowing_mul":["overflowing_mul","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingMul"],"<u64 as ops::overflowing::OverflowingSub>::overflowing_sub":["overflowing_sub","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingSub"],"<u64 as ops::saturating::Saturating>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<u64 as ops::saturating::Saturating>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<u64 as ops::saturating::SaturatingAdd>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingAdd"],"<u64 as ops::saturating::SaturatingMul>::saturating_mul":["saturating_mul","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingMul"],"<u64 as ops::saturating::SaturatingSub>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingSub"],"<u64 as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<u64 as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<u64 as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<u64 as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<u64 as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<u64 as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<u64 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u64 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u64 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u64 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u64 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u64 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u64 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u64 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u8 as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<u8 as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<u8 as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<u8 as cast::AsPrimitive<char>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<u8 as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<u8 as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<u8 as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<u8 as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<u8 as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<u8 as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<u8 as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<u8 as int::PrimInt>::count_ones":["count_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::count_zeros":["count_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::from_be":["from_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::from_le":["from_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::leading_zeros":["leading_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::pow":["pow","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::rotate_left":["rotate_left","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::rotate_right":["rotate_right","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::signed_shl":["signed_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::signed_shr":["signed_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::swap_bytes":["swap_bytes","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::to_be":["to_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::to_le":["to_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::trailing_zeros":["trailing_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::unsigned_shl":["unsigned_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as int::PrimInt>::unsigned_shr":["unsigned_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<u8 as ops::checked::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedAdd"],"<u8 as ops::checked::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedDiv"],"<u8 as ops::checked::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedMul"],"<u8 as ops::checked::CheckedNeg>::checked_neg":["checked_neg","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedNeg"],"<u8 as ops::checked::CheckedRem>::checked_rem":["checked_rem","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedRem"],"<u8 as ops::checked::CheckedShl>::checked_shl":["checked_shl","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShl"],"<u8 as ops::checked::CheckedShr>::checked_shr":["checked_shr","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShr"],"<u8 as ops::checked::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedSub"],"<u8 as ops::euclid::CheckedEuclid>::checked_div_euclid":["checked_div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<u8 as ops::euclid::CheckedEuclid>::checked_rem_euclid":["checked_rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<u8 as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<u8 as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<u8 as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<u8 as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<u8 as ops::overflowing::OverflowingAdd>::overflowing_add":["overflowing_add","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingAdd"],"<u8 as ops::overflowing::OverflowingMul>::overflowing_mul":["overflowing_mul","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingMul"],"<u8 as ops::overflowing::OverflowingSub>::overflowing_sub":["overflowing_sub","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingSub"],"<u8 as ops::saturating::Saturating>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<u8 as ops::saturating::Saturating>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<u8 as ops::saturating::SaturatingAdd>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingAdd"],"<u8 as ops::saturating::SaturatingMul>::saturating_mul":["saturating_mul","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingMul"],"<u8 as ops::saturating::SaturatingSub>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingSub"],"<u8 as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<u8 as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<u8 as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<u8 as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<u8 as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<u8 as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<u8 as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u8 as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u8 as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u8 as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u8 as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u8 as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u8 as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<u8 as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<usize as Num>::from_str_radix":["from_str_radix","Real(LocalPath(\"src/lib.rs\"))","Num"],"<usize as bounds::Bounded>::max_value":["max_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<usize as bounds::Bounded>::min_value":["min_value","Real(LocalPath(\"src/bounds.rs\"))","bounds::Bounded"],"<usize as cast::AsPrimitive<f32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<f64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<i128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<i16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<i32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<i64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<i8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<isize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<u128>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<u16>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<u32>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<u64>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<u8>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::AsPrimitive<usize>>::as_":["as_","Real(LocalPath(\"src/cast.rs\"))","cast::AsPrimitive"],"<usize as cast::FromPrimitive>::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::FromPrimitive>::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))","cast::FromPrimitive"],"<usize as cast::NumCast>::from":["from","Real(LocalPath(\"src/cast.rs\"))","cast::NumCast"],"<usize as cast::ToPrimitive>::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_i64":["to_i64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_u64":["to_u64","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as cast::ToPrimitive>::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))","cast::ToPrimitive"],"<usize as identities::One>::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<usize as identities::One>::one":["one","Real(LocalPath(\"src/identities.rs\"))","identities::One"],"<usize as identities::Zero>::is_zero":["is_zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<usize as identities::Zero>::zero":["zero","Real(LocalPath(\"src/identities.rs\"))","identities::Zero"],"<usize as int::PrimInt>::count_ones":["count_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::count_zeros":["count_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::from_be":["from_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::from_le":["from_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::leading_zeros":["leading_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::pow":["pow","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::rotate_left":["rotate_left","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::rotate_right":["rotate_right","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::signed_shl":["signed_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::signed_shr":["signed_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::swap_bytes":["swap_bytes","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::to_be":["to_be","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::to_le":["to_le","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::trailing_zeros":["trailing_zeros","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::unsigned_shl":["unsigned_shl","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as int::PrimInt>::unsigned_shr":["unsigned_shr","Real(LocalPath(\"src/int.rs\"))","int::PrimInt"],"<usize as ops::checked::CheckedAdd>::checked_add":["checked_add","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedAdd"],"<usize as ops::checked::CheckedDiv>::checked_div":["checked_div","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedDiv"],"<usize as ops::checked::CheckedMul>::checked_mul":["checked_mul","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedMul"],"<usize as ops::checked::CheckedNeg>::checked_neg":["checked_neg","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedNeg"],"<usize as ops::checked::CheckedRem>::checked_rem":["checked_rem","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedRem"],"<usize as ops::checked::CheckedShl>::checked_shl":["checked_shl","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShl"],"<usize as ops::checked::CheckedShr>::checked_shr":["checked_shr","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedShr"],"<usize as ops::checked::CheckedSub>::checked_sub":["checked_sub","Real(LocalPath(\"src/ops/checked.rs\"))","ops::checked::CheckedSub"],"<usize as ops::euclid::CheckedEuclid>::checked_div_euclid":["checked_div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<usize as ops::euclid::CheckedEuclid>::checked_rem_euclid":["checked_rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::CheckedEuclid"],"<usize as ops::euclid::Euclid>::div_euclid":["div_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<usize as ops::euclid::Euclid>::rem_euclid":["rem_euclid","Real(LocalPath(\"src/ops/euclid.rs\"))","ops::euclid::Euclid"],"<usize as ops::mul_add::MulAdd>::mul_add":["mul_add","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAdd"],"<usize as ops::mul_add::MulAddAssign>::mul_add_assign":["mul_add_assign","Real(LocalPath(\"src/ops/mul_add.rs\"))","ops::mul_add::MulAddAssign"],"<usize as ops::overflowing::OverflowingAdd>::overflowing_add":["overflowing_add","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingAdd"],"<usize as ops::overflowing::OverflowingMul>::overflowing_mul":["overflowing_mul","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingMul"],"<usize as ops::overflowing::OverflowingSub>::overflowing_sub":["overflowing_sub","Real(LocalPath(\"src/ops/overflowing.rs\"))","ops::overflowing::OverflowingSub"],"<usize as ops::saturating::Saturating>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<usize as ops::saturating::Saturating>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::Saturating"],"<usize as ops::saturating::SaturatingAdd>::saturating_add":["saturating_add","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingAdd"],"<usize as ops::saturating::SaturatingMul>::saturating_mul":["saturating_mul","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingMul"],"<usize as ops::saturating::SaturatingSub>::saturating_sub":["saturating_sub","Real(LocalPath(\"src/ops/saturating.rs\"))","ops::saturating::SaturatingSub"],"<usize as ops::wrapping::WrappingAdd>::wrapping_add":["wrapping_add","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingAdd"],"<usize as ops::wrapping::WrappingMul>::wrapping_mul":["wrapping_mul","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingMul"],"<usize as ops::wrapping::WrappingNeg>::wrapping_neg":["wrapping_neg","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingNeg"],"<usize as ops::wrapping::WrappingShl>::wrapping_shl":["wrapping_shl","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShl"],"<usize as ops::wrapping::WrappingShr>::wrapping_shr":["wrapping_shr","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingShr"],"<usize as ops::wrapping::WrappingSub>::wrapping_sub":["wrapping_sub","Real(LocalPath(\"src/ops/wrapping.rs\"))","ops::wrapping::WrappingSub"],"<usize as pow::Pow<&'a u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<usize as pow::Pow<&'a u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<usize as pow::Pow<&'a u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<usize as pow::Pow<&'a usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<usize as pow::Pow<u16>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<usize as pow::Pow<u32>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<usize as pow::Pow<u8>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"<usize as pow::Pow<usize>>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"cast::FromPrimitive::from_f32":["from_f32","Real(LocalPath(\"src/cast.rs\"))",""],"cast::FromPrimitive::from_f64":["from_f64","Real(LocalPath(\"src/cast.rs\"))",""],"cast::FromPrimitive::from_i128":["from_i128","Real(LocalPath(\"src/cast.rs\"))",""],"cast::FromPrimitive::from_i16":["from_i16","Real(LocalPath(\"src/cast.rs\"))",""],"cast::FromPrimitive::from_i32":["from_i32","Real(LocalPath(\"src/cast.rs\"))",""],"cast::FromPrimitive::from_i8":["from_i8","Real(LocalPath(\"src/cast.rs\"))",""],"cast::FromPrimitive::from_isize":["from_isize","Real(LocalPath(\"src/cast.rs\"))",""],"cast::FromPrimitive::from_u128":["from_u128","Real(LocalPath(\"src/cast.rs\"))",""],"cast::FromPrimitive::from_u16":["from_u16","Real(LocalPath(\"src/cast.rs\"))",""],"cast::FromPrimitive::from_u32":["from_u32","Real(LocalPath(\"src/cast.rs\"))",""],"cast::FromPrimitive::from_u8":["from_u8","Real(LocalPath(\"src/cast.rs\"))",""],"cast::FromPrimitive::from_usize":["from_usize","Real(LocalPath(\"src/cast.rs\"))",""],"cast::ToPrimitive::to_f32":["to_f32","Real(LocalPath(\"src/cast.rs\"))",""],"cast::ToPrimitive::to_f64":["to_f64","Real(LocalPath(\"src/cast.rs\"))",""],"cast::ToPrimitive::to_i128":["to_i128","Real(LocalPath(\"src/cast.rs\"))",""],"cast::ToPrimitive::to_i16":["to_i16","Real(LocalPath(\"src/cast.rs\"))",""],"cast::ToPrimitive::to_i32":["to_i32","Real(LocalPath(\"src/cast.rs\"))",""],"cast::ToPrimitive::to_i8":["to_i8","Real(LocalPath(\"src/cast.rs\"))",""],"cast::ToPrimitive::to_isize":["to_isize","Real(LocalPath(\"src/cast.rs\"))",""],"cast::ToPrimitive::to_u128":["to_u128","Real(LocalPath(\"src/cast.rs\"))",""],"cast::ToPrimitive::to_u16":["to_u16","Real(LocalPath(\"src/cast.rs\"))",""],"cast::ToPrimitive::to_u32":["to_u32","Real(LocalPath(\"src/cast.rs\"))",""],"cast::ToPrimitive::to_u8":["to_u8","Real(LocalPath(\"src/cast.rs\"))",""],"cast::ToPrimitive::to_usize":["to_usize","Real(LocalPath(\"src/cast.rs\"))",""],"cast::cast":["cast","Real(LocalPath(\"src/cast.rs\"))",""],"clamp":["clamp","Real(LocalPath(\"src/lib.rs\"))",""],"clamp_max":["clamp_max","Real(LocalPath(\"src/lib.rs\"))",""],"clamp_min":["clamp_min","Real(LocalPath(\"src/lib.rs\"))",""],"float::Float::copysign":["copysign","Real(LocalPath(\"src/float.rs\"))",""],"float::Float::epsilon":["epsilon","Real(LocalPath(\"src/float.rs\"))",""],"float::Float::to_degrees":["to_degrees","Real(LocalPath(\"src/float.rs\"))",""],"float::Float::to_radians":["to_radians","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatConst::LOG10_2":["LOG10_2","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatConst::LOG2_10":["LOG2_10","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatConst::TAU":["TAU","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::abs":["abs","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::ceil":["ceil","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::floor":["floor","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::fract":["fract","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::is_finite":["is_finite","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::is_infinite":["is_infinite","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::is_nan":["is_nan","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::is_normal":["is_normal","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::is_sign_negative":["is_sign_negative","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::is_sign_positive":["is_sign_positive","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::max":["max","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::min":["min","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::powi":["powi","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::recip":["recip","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::round":["round","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::signum":["signum","Real(LocalPath(\"src/float.rs\"))",""],"float::FloatCore::trunc":["trunc","Real(LocalPath(\"src/float.rs\"))",""],"float::integer_decode_f32":["integer_decode_f32","Real(LocalPath(\"src/float.rs\"))",""],"float::integer_decode_f64":["integer_decode_f64","Real(LocalPath(\"src/float.rs\"))",""],"identities::One::is_one":["is_one","Real(LocalPath(\"src/identities.rs\"))",""],"identities::One::set_one":["set_one","Real(LocalPath(\"src/identities.rs\"))",""],"identities::Zero::set_zero":["set_zero","Real(LocalPath(\"src/identities.rs\"))",""],"identities::one":["one","Real(LocalPath(\"src/identities.rs\"))",""],"identities::zero":["zero","Real(LocalPath(\"src/identities.rs\"))",""],"int::PrimInt::leading_ones":["leading_ones","Real(LocalPath(\"src/int.rs\"))",""],"int::PrimInt::reverse_bits":["reverse_bits","Real(LocalPath(\"src/int.rs\"))",""],"int::PrimInt::trailing_ones":["trailing_ones","Real(LocalPath(\"src/int.rs\"))",""],"int::one_per_byte":["one_per_byte","Real(LocalPath(\"src/int.rs\"))",""],"int::reverse_bits_fallback":["reverse_bits_fallback","Real(LocalPath(\"src/int.rs\"))",""],"pow::checked_pow":["checked_pow","Real(LocalPath(\"src/pow.rs\"))",""],"pow::float_impls::<impl pow::Pow<&'a f32> for &'b f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a f32> for &'b f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a f32> for f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a f32> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a f64> for &'b f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a f64> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a i16> for &'b f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a i16> for &'b f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a i16> for f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a i16> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a i32> for &'b f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a i32> for &'b f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a i32> for f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a i32> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a i8> for &'b f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a i8> for &'b f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a i8> for f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a i8> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a u16> for &'b f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a u16> for &'b f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a u16> for f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a u16> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a u8> for &'b f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a u8> for &'b f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a u8> for f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<&'a u8> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<f32> for &'a f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<f32> for &'a f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<f32> for f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<f32> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<f64> for &'a f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<f64> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<i16> for &'a f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<i16> for &'a f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<i16> for f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<i16> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<i32> for &'a f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<i32> for &'a f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<i32> for f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<i32> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<i8> for &'a f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<i8> for &'a f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<i8> for f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<i8> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<u16> for &'a f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<u16> for &'a f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<u16> for f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<u16> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<u8> for &'a f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<u8> for &'a f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<u8> for f32>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::float_impls::<impl pow::Pow<u8> for f64>::pow":["pow","Real(LocalPath(\"src/pow.rs\"))","pow::Pow"],"pow::pow":["pow","Real(LocalPath(\"src/pow.rs\"))",""],"sign::abs":["abs","Real(LocalPath(\"src/sign.rs\"))",""],"sign::abs_sub":["abs_sub","Real(LocalPath(\"src/sign.rs\"))",""],"sign::signum":["signum","Real(LocalPath(\"src/sign.rs\"))",""],"str_to_ascii_lower_eq_str":["str_to_ascii_lower_eq_str","Real(LocalPath(\"src/lib.rs\"))",""]},"trait_to_struct":{"Num":["core::num::Wrapping"],"NumAssign":["<T as NumAssign>::T"],"NumAssignOps":["<T as NumAssignOps<Rhs>>::T"],"NumAssignRef":["<T as NumAssignRef>::T"],"NumOps":["<T as NumOps<Rhs, Output>>::T"],"NumRef":["<T as NumRef>::T"],"RefNum":["<T as RefNum<Base>>::T"],"bounds::Bounded":["core::num::Wrapping"],"bounds::LowerBounded":["<T as bounds::LowerBounded>::T"],"bounds::UpperBounded":["<T as bounds::UpperBounded>::T"],"cast::FromPrimitive":["core::num::Wrapping"],"cast::NumCast":["core::num::Wrapping"],"cast::ToPrimitive":["core::num::Wrapping"],"core::fmt::Debug":["FloatErrorKind","ParseFloatError"],"core::fmt::Display":["ParseFloatError"],"identities::One":["core::num::Wrapping"],"identities::Zero":["core::num::Wrapping"],"ops::wrapping::WrappingAdd":["core::num::Wrapping"],"ops::wrapping::WrappingMul":["core::num::Wrapping"],"ops::wrapping::WrappingNeg":["core::num::Wrapping"],"ops::wrapping::WrappingShl":["core::num::Wrapping"],"ops::wrapping::WrappingShr":["core::num::Wrapping"],"ops::wrapping::WrappingSub":["core::num::Wrapping"],"pow::Pow":["core::num::Wrapping"],"real::Real":["<T as real::Real>::T"],"sign::Signed":["core::num::Wrapping"],"sign::Unsigned":["core::num::Wrapping"]},"type_to_def_path":{"FloatErrorKind":"FloatErrorKind","ParseFloatError":"ParseFloatError"}}