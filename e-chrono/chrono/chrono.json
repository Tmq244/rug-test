{"dependencies":{"<OutOfRange as std::clone::Clone>::clone":["OutOfRange"],"<OutOfRange as std::cmp::Eq>::assert_receiver_is_total_eq":["OutOfRange"],"<OutOfRange as std::cmp::PartialEq>::eq":["OutOfRange"],"<OutOfRange as std::fmt::Debug>::fmt":["OutOfRange","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<OutOfRange as std::fmt::Display>::fmt":["OutOfRange","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<OutOfRange as std::hash::Hash>::hash":["OutOfRange","std::hash::Hasher","std::marker::Sized"],"<T as round::SubsecRound>::round_subsecs":[],"<T as round::SubsecRound>::trunc_subsecs":[],"<date::Date<Tz> as std::clone::Clone>::clone":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as std::cmp::Ord>::cmp":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::cmp::Ordering","std::marker::Sized"],"<date::Date<Tz> as std::cmp::PartialEq<date::Date<Tz2>>>::eq":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as std::cmp::PartialOrd>::partial_cmp":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<date::Date<Tz> as std::fmt::Debug>::fmt":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<date::Date<Tz> as std::fmt::Display>::fmt":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<date::Date<Tz> as std::hash::Hash>::hash":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::hash::Hasher","std::marker::Sized"],"<date::Date<Tz> as std::ops::Add<oldtime::Duration>>::add":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as std::ops::AddAssign<oldtime::Duration>>::add_assign":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as std::ops::Sub<oldtime::Duration>>::sub":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as std::ops::Sub>::sub":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as traits::Datelike>::day":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as traits::Datelike>::day0":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as traits::Datelike>::iso_week":["OutOfRange","date::Date","naive::date::NaiveDate","naive::isoweek::IsoWeek","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as traits::Datelike>::month":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as traits::Datelike>::month0":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as traits::Datelike>::ordinal":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as traits::Datelike>::ordinal0":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<date::Date<Tz> as traits::Datelike>::weekday":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","weekday::Weekday"],"<date::Date<Tz> as traits::Datelike>::with_day":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<date::Date<Tz> as traits::Datelike>::with_day0":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<date::Date<Tz> as traits::Datelike>::with_month":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<date::Date<Tz> as traits::Datelike>::with_month0":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<date::Date<Tz> as traits::Datelike>::with_ordinal":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<date::Date<Tz> as traits::Datelike>::with_ordinal0":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<date::Date<Tz> as traits::Datelike>::with_year":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<date::Date<Tz> as traits::Datelike>::year":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as round::DurationRound>::duration_round":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized","std::result::Result"],"<datetime::DateTime<Tz> as round::DurationRound>::duration_trunc":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized","std::result::Result"],"<datetime::DateTime<Tz> as std::clone::Clone>::clone":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as std::cmp::Ord>::cmp":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::cmp::Ordering","std::marker::Sized"],"<datetime::DateTime<Tz> as std::cmp::PartialEq<datetime::DateTime<Tz2>>>::eq":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as std::cmp::PartialOrd<datetime::DateTime<Tz2>>>::partial_cmp":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<datetime::DateTime<Tz> as std::fmt::Debug>::fmt":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<datetime::DateTime<Tz> as std::fmt::Display>::fmt":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<datetime::DateTime<Tz> as std::hash::Hash>::hash":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::hash::Hasher","std::marker::Sized"],"<datetime::DateTime<Tz> as std::ops::Add<month::Months>>::add":["OutOfRange","datetime::DateTime","month::Months","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as std::ops::Add<naive::date::Days>>::add":["OutOfRange","datetime::DateTime","naive::date::Days","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as std::ops::Add<oldtime::Duration>>::add":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as std::ops::AddAssign<oldtime::Duration>>::add_assign":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as std::ops::Sub<month::Months>>::sub":["OutOfRange","datetime::DateTime","month::Months","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as std::ops::Sub<naive::date::Days>>::sub":["OutOfRange","datetime::DateTime","naive::date::Days","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as std::ops::Sub<oldtime::Duration>>::sub":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as std::ops::Sub>::sub":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Datelike>::day":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Datelike>::day0":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Datelike>::iso_week":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::isoweek::IsoWeek","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Datelike>::month":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Datelike>::month0":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Datelike>::ordinal":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Datelike>::ordinal0":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Datelike>::weekday":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","weekday::Weekday"],"<datetime::DateTime<Tz> as traits::Datelike>::with_day":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<datetime::DateTime<Tz> as traits::Datelike>::with_day0":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<datetime::DateTime<Tz> as traits::Datelike>::with_month":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<datetime::DateTime<Tz> as traits::Datelike>::with_month0":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal0":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<datetime::DateTime<Tz> as traits::Datelike>::with_year":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<datetime::DateTime<Tz> as traits::Datelike>::year":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Timelike>::hour":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Timelike>::minute":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Timelike>::nanosecond":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Timelike>::second":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<Tz> as traits::Timelike>::with_hour":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<datetime::DateTime<Tz> as traits::Timelike>::with_minute":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<datetime::DateTime<Tz> as traits::Timelike>::with_nanosecond":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<datetime::DateTime<Tz> as traits::Timelike>::with_second":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"<datetime::DateTime<offset::fixed::FixedOffset> as std::convert::From<datetime::DateTime<offset::local::Local>>>::from":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<offset::fixed::FixedOffset> as std::convert::From<datetime::DateTime<offset::utc::Utc>>>::from":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<offset::fixed::FixedOffset> as std::default::Default>::default":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<offset::local::Local> as std::convert::From<datetime::DateTime<offset::fixed::FixedOffset>>>::from":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<offset::local::Local> as std::convert::From<datetime::DateTime<offset::utc::Utc>>>::from":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<offset::local::Local> as std::convert::From<std::time::SystemTime>>::from":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::time::SystemTime"],"<datetime::DateTime<offset::local::Local> as std::default::Default>::default":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<offset::local::Local> as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<datetime::DateTime<offset::utc::Utc> as std::convert::From<datetime::DateTime<offset::fixed::FixedOffset>>>::from":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<offset::utc::Utc> as std::convert::From<datetime::DateTime<offset::local::Local>>>::from":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<offset::utc::Utc> as std::convert::From<std::time::SystemTime>>::from":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::time::SystemTime"],"<datetime::DateTime<offset::utc::Utc> as std::default::Default>::default":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"<datetime::DateTime<offset::utc::Utc> as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<datetime::SecondsFormat as std::clone::Clone>::clone":["datetime::SecondsFormat"],"<datetime::SecondsFormat as std::cmp::Eq>::assert_receiver_is_total_eq":["datetime::SecondsFormat"],"<datetime::SecondsFormat as std::cmp::PartialEq>::eq":["datetime::SecondsFormat"],"<datetime::SecondsFormat as std::fmt::Debug>::fmt":["datetime::SecondsFormat","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<datetime::SecondsFormat as std::hash::Hash>::hash":["datetime::SecondsFormat","std::hash::Hasher","std::marker::Sized"],"<format::Colons as std::clone::Clone>::clone":["format::Colons"],"<format::Colons as std::cmp::Eq>::assert_receiver_is_total_eq":["format::Colons"],"<format::Colons as std::cmp::PartialEq>::eq":["format::Colons"],"<format::Colons as std::fmt::Debug>::fmt":["format::Colons","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::Colons as std::hash::Hash>::hash":["format::Colons","std::hash::Hasher","std::marker::Sized"],"<format::DelayedFormat<I> as std::fmt::Debug>::fmt":["format::DelayedFormat","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<format::DelayedFormat<I> as std::fmt::Display>::fmt":["format::DelayedFormat","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<format::Fixed as std::clone::Clone>::clone":["format::Fixed","format::InternalFixed","format::InternalInternal"],"<format::Fixed as std::cmp::Eq>::assert_receiver_is_total_eq":["format::Fixed","format::InternalFixed","format::InternalInternal"],"<format::Fixed as std::cmp::PartialEq>::eq":["format::Fixed","format::InternalFixed","format::InternalInternal"],"<format::Fixed as std::fmt::Debug>::fmt":["format::Fixed","format::InternalFixed","format::InternalInternal","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::Fixed as std::hash::Hash>::hash":["format::Fixed","format::InternalFixed","format::InternalInternal","std::hash::Hasher","std::marker::Sized"],"<format::InternalFixed as std::clone::Clone>::clone":["format::InternalFixed","format::InternalInternal"],"<format::InternalFixed as std::cmp::Eq>::assert_receiver_is_total_eq":["format::InternalFixed","format::InternalInternal"],"<format::InternalFixed as std::cmp::PartialEq>::eq":["format::InternalFixed","format::InternalInternal"],"<format::InternalFixed as std::fmt::Debug>::fmt":["format::InternalFixed","format::InternalInternal","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::InternalFixed as std::hash::Hash>::hash":["format::InternalFixed","format::InternalInternal","std::hash::Hasher","std::marker::Sized"],"<format::InternalInternal as std::clone::Clone>::clone":["format::InternalInternal"],"<format::InternalInternal as std::cmp::Eq>::assert_receiver_is_total_eq":["format::InternalInternal"],"<format::InternalInternal as std::cmp::PartialEq>::eq":["format::InternalInternal"],"<format::InternalInternal as std::fmt::Debug>::fmt":["format::InternalInternal","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::InternalInternal as std::hash::Hash>::hash":["format::InternalInternal","std::hash::Hasher","std::marker::Sized"],"<format::InternalNumeric as std::clone::Clone>::clone":["format::InternalNumeric","format::Void"],"<format::InternalNumeric as std::cmp::Eq>::assert_receiver_is_total_eq":["format::InternalNumeric","format::Void"],"<format::InternalNumeric as std::cmp::PartialEq>::eq":["format::InternalNumeric","format::Void"],"<format::InternalNumeric as std::fmt::Debug>::fmt":["format::InternalNumeric","format::Void","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::InternalNumeric as std::hash::Hash>::hash":["format::InternalNumeric","format::Void","std::hash::Hasher","std::marker::Sized"],"<format::Item<'a> as std::clone::Clone>::clone":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<format::Item<'a> as std::cmp::Eq>::assert_receiver_is_total_eq":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<format::Item<'a> as std::cmp::PartialEq>::eq":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<format::Item<'a> as std::fmt::Debug>::fmt":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::Item<'a> as std::hash::Hash>::hash":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","std::alloc::Allocator","std::boxed::Box","std::hash::Hasher","std::marker::Sized"],"<format::Locale as std::fmt::Debug>::fmt":["format::Locale","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::Numeric as std::clone::Clone>::clone":["format::InternalNumeric","format::Numeric","format::Void"],"<format::Numeric as std::cmp::Eq>::assert_receiver_is_total_eq":["format::InternalNumeric","format::Numeric","format::Void"],"<format::Numeric as std::cmp::PartialEq>::eq":["format::InternalNumeric","format::Numeric","format::Void"],"<format::Numeric as std::fmt::Debug>::fmt":["format::InternalNumeric","format::Numeric","format::Void","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::Numeric as std::hash::Hash>::hash":["format::InternalNumeric","format::Numeric","format::Void","std::hash::Hasher","std::marker::Sized"],"<format::Pad as std::clone::Clone>::clone":["format::Pad"],"<format::Pad as std::cmp::Eq>::assert_receiver_is_total_eq":["format::Pad"],"<format::Pad as std::cmp::PartialEq>::eq":["format::Pad"],"<format::Pad as std::fmt::Debug>::fmt":["format::Pad","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::Pad as std::hash::Hash>::hash":["format::Pad","std::hash::Hasher","std::marker::Sized"],"<format::ParseError as std::clone::Clone>::clone":["format::ParseError","format::ParseErrorKind"],"<format::ParseError as std::cmp::Eq>::assert_receiver_is_total_eq":["format::ParseError","format::ParseErrorKind"],"<format::ParseError as std::cmp::PartialEq>::eq":["format::ParseError","format::ParseErrorKind"],"<format::ParseError as std::error::Error>::description":["format::ParseError","format::ParseErrorKind"],"<format::ParseError as std::fmt::Debug>::fmt":["format::ParseError","format::ParseErrorKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::ParseError as std::fmt::Display>::fmt":["format::ParseError","format::ParseErrorKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::ParseError as std::hash::Hash>::hash":["format::ParseError","format::ParseErrorKind","std::hash::Hasher","std::marker::Sized"],"<format::ParseErrorKind as std::clone::Clone>::clone":["format::ParseErrorKind"],"<format::ParseErrorKind as std::cmp::Eq>::assert_receiver_is_total_eq":["format::ParseErrorKind"],"<format::ParseErrorKind as std::cmp::PartialEq>::eq":["format::ParseErrorKind"],"<format::ParseErrorKind as std::fmt::Debug>::fmt":["format::ParseErrorKind","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::ParseErrorKind as std::hash::Hash>::hash":["format::ParseErrorKind","std::hash::Hasher","std::marker::Sized"],"<format::Void as std::clone::Clone>::clone":["format::Void"],"<format::Void as std::cmp::Eq>::assert_receiver_is_total_eq":["format::Void"],"<format::Void as std::cmp::PartialEq>::eq":["format::Void"],"<format::Void as std::hash::Hash>::hash":["format::Void","std::hash::Hasher","std::marker::Sized"],"<format::parsed::Parsed as std::clone::Clone>::clone":["format::parsed::Parsed","std::marker::Sized","std::option::Option"],"<format::parsed::Parsed as std::cmp::Eq>::assert_receiver_is_total_eq":["format::parsed::Parsed","std::marker::Sized","std::option::Option"],"<format::parsed::Parsed as std::cmp::PartialEq>::eq":["format::parsed::Parsed","std::marker::Sized","std::option::Option"],"<format::parsed::Parsed as std::default::Default>::default":["format::parsed::Parsed","std::marker::Sized","std::option::Option"],"<format::parsed::Parsed as std::fmt::Debug>::fmt":["format::parsed::Parsed","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<format::parsed::Parsed as std::hash::Hash>::hash":["format::parsed::Parsed","std::hash::Hasher","std::marker::Sized","std::option::Option"],"<format::strftime::StrftimeItems<'a> as std::clone::Clone>::clone":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::strftime::StrftimeItems","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<format::strftime::StrftimeItems<'a> as std::fmt::Debug>::fmt":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::strftime::StrftimeItems","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<format::strftime::StrftimeItems<'a> as std::iter::Iterator>::next":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::strftime::StrftimeItems","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option"],"<month::Month as num_traits::FromPrimitive>::from_i64":["std::marker::Sized","std::option::Option"],"<month::Month as num_traits::FromPrimitive>::from_u32":["std::marker::Sized","std::option::Option"],"<month::Month as num_traits::FromPrimitive>::from_u64":["std::marker::Sized","std::option::Option"],"<month::Month as std::clone::Clone>::clone":["month::Month"],"<month::Month as std::cmp::Eq>::assert_receiver_is_total_eq":["month::Month"],"<month::Month as std::cmp::PartialEq>::eq":["month::Month"],"<month::Month as std::cmp::PartialOrd>::partial_cmp":["month::Month","std::marker::Sized","std::option::Option"],"<month::Month as std::convert::TryFrom<u8>>::try_from":["std::marker::Sized","std::result::Result"],"<month::Month as std::fmt::Debug>::fmt":["month::Month","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<month::Month as std::hash::Hash>::hash":["month::Month","std::hash::Hasher","std::marker::Sized"],"<month::Months as std::clone::Clone>::clone":["month::Months"],"<month::Months as std::cmp::Eq>::assert_receiver_is_total_eq":["month::Months"],"<month::Months as std::cmp::PartialEq>::eq":["month::Months"],"<month::Months as std::cmp::PartialOrd>::partial_cmp":["month::Months","std::marker::Sized","std::option::Option"],"<month::Months as std::fmt::Debug>::fmt":["month::Months","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<month::Months as std::hash::Hash>::hash":["month::Months","std::hash::Hasher","std::marker::Sized"],"<month::ParseMonthError as std::clone::Clone>::clone":["month::ParseMonthError"],"<month::ParseMonthError as std::cmp::Eq>::assert_receiver_is_total_eq":["month::ParseMonthError"],"<month::ParseMonthError as std::cmp::PartialEq>::eq":["month::ParseMonthError"],"<month::ParseMonthError as std::fmt::Debug>::fmt":["month::ParseMonthError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::date::Days as std::clone::Clone>::clone":["naive::date::Days"],"<naive::date::Days as std::cmp::Eq>::assert_receiver_is_total_eq":["naive::date::Days"],"<naive::date::Days as std::cmp::PartialEq>::eq":["naive::date::Days"],"<naive::date::Days as std::cmp::PartialOrd>::partial_cmp":["naive::date::Days","std::marker::Sized","std::option::Option"],"<naive::date::Days as std::fmt::Debug>::fmt":["naive::date::Days","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::date::Days as std::hash::Hash>::hash":["naive::date::Days","std::hash::Hasher","std::marker::Sized"],"<naive::date::NaiveDate as std::clone::Clone>::clone":["naive::date::NaiveDate"],"<naive::date::NaiveDate as std::cmp::Eq>::assert_receiver_is_total_eq":["naive::date::NaiveDate"],"<naive::date::NaiveDate as std::cmp::Ord>::cmp":["naive::date::NaiveDate","std::cmp::Ordering"],"<naive::date::NaiveDate as std::cmp::PartialEq>::eq":["naive::date::NaiveDate"],"<naive::date::NaiveDate as std::cmp::PartialOrd>::partial_cmp":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDate as std::convert::From<naive::datetime::NaiveDateTime>>::from":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::date::NaiveDate as std::default::Default>::default":["naive::date::NaiveDate"],"<naive::date::NaiveDate as std::fmt::Debug>::fmt":["naive::date::NaiveDate","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::date::NaiveDate as std::fmt::Display>::fmt":["naive::date::NaiveDate","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::date::NaiveDate as std::hash::Hash>::hash":["naive::date::NaiveDate","std::hash::Hasher","std::marker::Sized"],"<naive::date::NaiveDate as std::ops::Add<month::Months>>::add":["month::Months","naive::date::NaiveDate"],"<naive::date::NaiveDate as std::ops::Add<naive::date::Days>>::add":["naive::date::Days","naive::date::NaiveDate"],"<naive::date::NaiveDate as std::ops::Add<oldtime::Duration>>::add":["naive::date::NaiveDate","oldtime::Duration"],"<naive::date::NaiveDate as std::ops::AddAssign<oldtime::Duration>>::add_assign":["naive::date::NaiveDate","oldtime::Duration"],"<naive::date::NaiveDate as std::ops::Sub<month::Months>>::sub":["month::Months","naive::date::NaiveDate"],"<naive::date::NaiveDate as std::ops::Sub<naive::date::Days>>::sub":["naive::date::Days","naive::date::NaiveDate"],"<naive::date::NaiveDate as std::ops::Sub<oldtime::Duration>>::sub":["naive::date::NaiveDate","oldtime::Duration"],"<naive::date::NaiveDate as std::ops::Sub>::sub":["naive::date::NaiveDate","oldtime::Duration"],"<naive::date::NaiveDate as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["naive::date::NaiveDate","oldtime::Duration"],"<naive::date::NaiveDate as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<naive::date::NaiveDate as traits::Datelike>::day":["naive::date::NaiveDate"],"<naive::date::NaiveDate as traits::Datelike>::day0":["naive::date::NaiveDate"],"<naive::date::NaiveDate as traits::Datelike>::iso_week":["naive::date::NaiveDate","naive::isoweek::IsoWeek"],"<naive::date::NaiveDate as traits::Datelike>::month":["naive::date::NaiveDate"],"<naive::date::NaiveDate as traits::Datelike>::month0":["naive::date::NaiveDate"],"<naive::date::NaiveDate as traits::Datelike>::ordinal":["naive::date::NaiveDate"],"<naive::date::NaiveDate as traits::Datelike>::ordinal0":["naive::date::NaiveDate"],"<naive::date::NaiveDate as traits::Datelike>::weekday":["naive::date::NaiveDate","weekday::Weekday"],"<naive::date::NaiveDate as traits::Datelike>::with_day":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDate as traits::Datelike>::with_day0":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDate as traits::Datelike>::with_month":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDate as traits::Datelike>::with_month0":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDate as traits::Datelike>::with_ordinal":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDate as traits::Datelike>::with_ordinal0":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDate as traits::Datelike>::with_year":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDate as traits::Datelike>::year":["naive::date::NaiveDate"],"<naive::date::NaiveDateDaysIterator as std::clone::Clone>::clone":["naive::date::NaiveDate","naive::date::NaiveDateDaysIterator"],"<naive::date::NaiveDateDaysIterator as std::cmp::Eq>::assert_receiver_is_total_eq":["naive::date::NaiveDate","naive::date::NaiveDateDaysIterator"],"<naive::date::NaiveDateDaysIterator as std::cmp::Ord>::cmp":["naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","std::cmp::Ordering"],"<naive::date::NaiveDateDaysIterator as std::cmp::PartialEq>::eq":["naive::date::NaiveDate","naive::date::NaiveDateDaysIterator"],"<naive::date::NaiveDateDaysIterator as std::cmp::PartialOrd>::partial_cmp":["naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDateDaysIterator as std::fmt::Debug>::fmt":["naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::date::NaiveDateDaysIterator as std::hash::Hash>::hash":["naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","std::hash::Hasher","std::marker::Sized"],"<naive::date::NaiveDateDaysIterator as std::iter::DoubleEndedIterator>::next_back":["naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDateDaysIterator as std::iter::Iterator>::next":["naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDateDaysIterator as std::iter::Iterator>::size_hint":["naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDateWeeksIterator as std::clone::Clone>::clone":["naive::date::NaiveDate","naive::date::NaiveDateWeeksIterator"],"<naive::date::NaiveDateWeeksIterator as std::cmp::Eq>::assert_receiver_is_total_eq":["naive::date::NaiveDate","naive::date::NaiveDateWeeksIterator"],"<naive::date::NaiveDateWeeksIterator as std::cmp::Ord>::cmp":["naive::date::NaiveDate","naive::date::NaiveDateWeeksIterator","std::cmp::Ordering"],"<naive::date::NaiveDateWeeksIterator as std::cmp::PartialEq>::eq":["naive::date::NaiveDate","naive::date::NaiveDateWeeksIterator"],"<naive::date::NaiveDateWeeksIterator as std::cmp::PartialOrd>::partial_cmp":["naive::date::NaiveDate","naive::date::NaiveDateWeeksIterator","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDateWeeksIterator as std::fmt::Debug>::fmt":["naive::date::NaiveDate","naive::date::NaiveDateWeeksIterator","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::date::NaiveDateWeeksIterator as std::hash::Hash>::hash":["naive::date::NaiveDate","naive::date::NaiveDateWeeksIterator","std::hash::Hasher","std::marker::Sized"],"<naive::date::NaiveDateWeeksIterator as std::iter::DoubleEndedIterator>::next_back":["naive::date::NaiveDate","naive::date::NaiveDateWeeksIterator","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::next":["naive::date::NaiveDate","naive::date::NaiveDateWeeksIterator","std::marker::Sized","std::option::Option"],"<naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::size_hint":["naive::date::NaiveDate","naive::date::NaiveDateWeeksIterator","std::marker::Sized","std::option::Option"],"<naive::date::NaiveWeek as std::fmt::Debug>::fmt":["naive::date::NaiveDate","naive::date::NaiveWeek","std::fmt::Formatter","std::marker::Sized","std::result::Result","weekday::Weekday"],"<naive::datetime::NaiveDateTime as round::DurationRound>::duration_round":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","oldtime::Duration","std::marker::Sized","std::result::Result"],"<naive::datetime::NaiveDateTime as round::DurationRound>::duration_trunc":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","oldtime::Duration","std::marker::Sized","std::result::Result"],"<naive::datetime::NaiveDateTime as std::clone::Clone>::clone":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as std::cmp::Eq>::assert_receiver_is_total_eq":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as std::cmp::Ord>::cmp":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::cmp::Ordering"],"<naive::datetime::NaiveDateTime as std::cmp::PartialEq>::eq":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as std::cmp::PartialOrd>::partial_cmp":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::datetime::NaiveDateTime as std::default::Default>::default":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as std::fmt::Debug>::fmt":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::datetime::NaiveDateTime as std::fmt::Display>::fmt":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::datetime::NaiveDateTime as std::hash::Hash>::hash":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::hash::Hasher","std::marker::Sized"],"<naive::datetime::NaiveDateTime as std::ops::Add<month::Months>>::add":["month::Months","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as std::ops::Add<naive::date::Days>>::add":["naive::date::Days","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as std::ops::Add<oldtime::Duration>>::add":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","oldtime::Duration"],"<naive::datetime::NaiveDateTime as std::ops::AddAssign<oldtime::Duration>>::add_assign":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","oldtime::Duration"],"<naive::datetime::NaiveDateTime as std::ops::Sub<month::Months>>::sub":["month::Months","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as std::ops::Sub<naive::date::Days>>::sub":["naive::date::Days","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as std::ops::Sub<oldtime::Duration>>::sub":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","oldtime::Duration"],"<naive::datetime::NaiveDateTime as std::ops::Sub>::sub":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","oldtime::Duration"],"<naive::datetime::NaiveDateTime as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","oldtime::Duration"],"<naive::datetime::NaiveDateTime as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<naive::datetime::NaiveDateTime as traits::Datelike>::day":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as traits::Datelike>::day0":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as traits::Datelike>::iso_week":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::isoweek::IsoWeek","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as traits::Datelike>::month":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as traits::Datelike>::month0":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as traits::Datelike>::ordinal":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as traits::Datelike>::ordinal0":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as traits::Datelike>::weekday":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","weekday::Weekday"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_day":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_day0":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_month":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_month0":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_ordinal":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_ordinal0":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_year":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::datetime::NaiveDateTime as traits::Datelike>::year":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as traits::Timelike>::hour":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as traits::Timelike>::minute":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as traits::Timelike>::nanosecond":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as traits::Timelike>::second":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"<naive::datetime::NaiveDateTime as traits::Timelike>::with_hour":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::datetime::NaiveDateTime as traits::Timelike>::with_minute":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::datetime::NaiveDateTime as traits::Timelike>::with_nanosecond":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::datetime::NaiveDateTime as traits::Timelike>::with_second":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::internals::Mdf as std::clone::Clone>::clone":["naive::internals::Mdf"],"<naive::internals::Mdf as std::cmp::PartialEq>::eq":["naive::internals::Mdf"],"<naive::internals::Mdf as std::cmp::PartialOrd>::partial_cmp":["naive::internals::Mdf","std::marker::Sized","std::option::Option"],"<naive::internals::Mdf as std::fmt::Debug>::fmt":["naive::internals::Mdf","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::internals::Of as std::clone::Clone>::clone":["naive::internals::Of"],"<naive::internals::Of as std::cmp::PartialEq>::eq":["naive::internals::Of"],"<naive::internals::Of as std::cmp::PartialOrd>::partial_cmp":["naive::internals::Of","std::marker::Sized","std::option::Option"],"<naive::internals::Of as std::fmt::Debug>::fmt":["naive::internals::Of","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::internals::YearFlags as std::clone::Clone>::clone":["naive::internals::YearFlags"],"<naive::internals::YearFlags as std::cmp::Eq>::assert_receiver_is_total_eq":["naive::internals::YearFlags"],"<naive::internals::YearFlags as std::cmp::PartialEq>::eq":["naive::internals::YearFlags"],"<naive::internals::YearFlags as std::fmt::Debug>::fmt":["naive::internals::YearFlags","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::internals::YearFlags as std::hash::Hash>::hash":["naive::internals::YearFlags","std::hash::Hasher","std::marker::Sized"],"<naive::isoweek::IsoWeek as std::clone::Clone>::clone":["naive::isoweek::IsoWeek"],"<naive::isoweek::IsoWeek as std::cmp::Eq>::assert_receiver_is_total_eq":["naive::isoweek::IsoWeek"],"<naive::isoweek::IsoWeek as std::cmp::Ord>::cmp":["naive::isoweek::IsoWeek","std::cmp::Ordering"],"<naive::isoweek::IsoWeek as std::cmp::PartialEq>::eq":["naive::isoweek::IsoWeek"],"<naive::isoweek::IsoWeek as std::cmp::PartialOrd>::partial_cmp":["naive::isoweek::IsoWeek","std::marker::Sized","std::option::Option"],"<naive::isoweek::IsoWeek as std::fmt::Debug>::fmt":["naive::isoweek::IsoWeek","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::isoweek::IsoWeek as std::hash::Hash>::hash":["naive::isoweek::IsoWeek","std::hash::Hasher","std::marker::Sized"],"<naive::time::NaiveTime as std::clone::Clone>::clone":["naive::time::NaiveTime"],"<naive::time::NaiveTime as std::cmp::Eq>::assert_receiver_is_total_eq":["naive::time::NaiveTime"],"<naive::time::NaiveTime as std::cmp::Ord>::cmp":["naive::time::NaiveTime","std::cmp::Ordering"],"<naive::time::NaiveTime as std::cmp::PartialEq>::eq":["naive::time::NaiveTime"],"<naive::time::NaiveTime as std::cmp::PartialOrd>::partial_cmp":["naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::time::NaiveTime as std::default::Default>::default":["naive::time::NaiveTime"],"<naive::time::NaiveTime as std::fmt::Debug>::fmt":["naive::time::NaiveTime","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::time::NaiveTime as std::fmt::Display>::fmt":["naive::time::NaiveTime","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<naive::time::NaiveTime as std::hash::Hash>::hash":["naive::time::NaiveTime","std::hash::Hasher","std::marker::Sized"],"<naive::time::NaiveTime as std::ops::Add<oldtime::Duration>>::add":["naive::time::NaiveTime","oldtime::Duration"],"<naive::time::NaiveTime as std::ops::AddAssign<oldtime::Duration>>::add_assign":["naive::time::NaiveTime","oldtime::Duration"],"<naive::time::NaiveTime as std::ops::Sub<oldtime::Duration>>::sub":["naive::time::NaiveTime","oldtime::Duration"],"<naive::time::NaiveTime as std::ops::Sub>::sub":["naive::time::NaiveTime","oldtime::Duration"],"<naive::time::NaiveTime as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["naive::time::NaiveTime","oldtime::Duration"],"<naive::time::NaiveTime as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<naive::time::NaiveTime as traits::Timelike>::hour":["naive::time::NaiveTime"],"<naive::time::NaiveTime as traits::Timelike>::minute":["naive::time::NaiveTime"],"<naive::time::NaiveTime as traits::Timelike>::nanosecond":["naive::time::NaiveTime"],"<naive::time::NaiveTime as traits::Timelike>::num_seconds_from_midnight":["naive::time::NaiveTime"],"<naive::time::NaiveTime as traits::Timelike>::second":["naive::time::NaiveTime"],"<naive::time::NaiveTime as traits::Timelike>::with_hour":["naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::time::NaiveTime as traits::Timelike>::with_minute":["naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::time::NaiveTime as traits::Timelike>::with_nanosecond":["naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<naive::time::NaiveTime as traits::Timelike>::with_second":["naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"<offset::LocalResult<T> as std::clone::Clone>::clone":["offset::LocalResult","std::marker::Sized"],"<offset::LocalResult<T> as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::LocalResult","std::marker::Sized"],"<offset::LocalResult<T> as std::cmp::PartialEq>::eq":["offset::LocalResult","std::marker::Sized"],"<offset::LocalResult<T> as std::fmt::Debug>::fmt":["offset::LocalResult","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::LocalResult<T> as std::hash::Hash>::hash":["offset::LocalResult","std::hash::Hasher","std::marker::Sized"],"<offset::fixed::FixedOffset as offset::Offset>::fix":["offset::fixed::FixedOffset"],"<offset::fixed::FixedOffset as offset::TimeZone>::from_offset":["offset::fixed::FixedOffset"],"<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_local_date":["naive::date::NaiveDate","offset::LocalResult","offset::fixed::FixedOffset","std::marker::Sized"],"<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_local_datetime":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::LocalResult","offset::fixed::FixedOffset","std::marker::Sized"],"<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_utc_date":["naive::date::NaiveDate","offset::fixed::FixedOffset"],"<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_utc_datetime":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::fixed::FixedOffset"],"<offset::fixed::FixedOffset as std::clone::Clone>::clone":["offset::fixed::FixedOffset"],"<offset::fixed::FixedOffset as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::fixed::FixedOffset"],"<offset::fixed::FixedOffset as std::cmp::PartialEq>::eq":["offset::fixed::FixedOffset"],"<offset::fixed::FixedOffset as std::fmt::Debug>::fmt":["offset::fixed::FixedOffset","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::fixed::FixedOffset as std::fmt::Display>::fmt":["offset::fixed::FixedOffset","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::fixed::FixedOffset as std::hash::Hash>::hash":["offset::fixed::FixedOffset","std::hash::Hasher","std::marker::Sized"],"<offset::local::Local as offset::TimeZone>::from_offset":["offset::fixed::FixedOffset","offset::local::Local"],"<offset::local::Local as offset::TimeZone>::offset_from_local_date":["naive::date::NaiveDate","offset::LocalResult","offset::local::Local","std::marker::Sized"],"<offset::local::Local as offset::TimeZone>::offset_from_local_datetime":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::LocalResult","offset::local::Local","std::marker::Sized"],"<offset::local::Local as offset::TimeZone>::offset_from_utc_date":["naive::date::NaiveDate","offset::fixed::FixedOffset","offset::local::Local"],"<offset::local::Local as offset::TimeZone>::offset_from_utc_datetime":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::fixed::FixedOffset","offset::local::Local"],"<offset::local::Local as std::clone::Clone>::clone":["offset::local::Local"],"<offset::local::Local as std::fmt::Debug>::fmt":["offset::local::Local","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::local::inner::Cache as std::default::Default>::default":["offset::local::inner::Cache","offset::local::inner::Source","offset::local::tz_info::timezone::TimeZone","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::time::SystemTime","std::vec::Vec"],"<offset::local::tz_info::Error as std::convert::From<std::io::Error>>::from":["offset::local::tz_info::Error","std::io::Error","std::num::ParseIntError","std::str::Utf8Error","std::time::SystemTimeError"],"<offset::local::tz_info::Error as std::convert::From<std::num::ParseIntError>>::from":["offset::local::tz_info::Error","std::io::Error","std::num::ParseIntError","std::str::Utf8Error","std::time::SystemTimeError"],"<offset::local::tz_info::Error as std::convert::From<std::str::Utf8Error>>::from":["offset::local::tz_info::Error","std::io::Error","std::num::ParseIntError","std::str::Utf8Error","std::time::SystemTimeError"],"<offset::local::tz_info::Error as std::convert::From<std::time::SystemTimeError>>::from":["offset::local::tz_info::Error","std::io::Error","std::num::ParseIntError","std::str::Utf8Error","std::time::SystemTimeError"],"<offset::local::tz_info::Error as std::fmt::Debug>::fmt":["offset::local::tz_info::Error","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::num::ParseIntError","std::result::Result","std::str::Utf8Error","std::time::SystemTimeError"],"<offset::local::tz_info::Error as std::fmt::Display>::fmt":["offset::local::tz_info::Error","std::fmt::Formatter","std::io::Error","std::marker::Sized","std::num::ParseIntError","std::result::Result","std::str::Utf8Error","std::time::SystemTimeError"],"<offset::local::tz_info::parser::Cursor<'a> as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::local::tz_info::parser::Cursor"],"<offset::local::tz_info::parser::Cursor<'a> as std::cmp::PartialEq>::eq":["offset::local::tz_info::parser::Cursor"],"<offset::local::tz_info::parser::Cursor<'a> as std::fmt::Debug>::fmt":["offset::local::tz_info::parser::Cursor","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::local::tz_info::parser::Header as std::fmt::Debug>::fmt":["offset::local::tz_info::parser::Header","offset::local::tz_info::parser::Version","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::local::tz_info::parser::Version as std::clone::Clone>::clone":["offset::local::tz_info::parser::Version"],"<offset::local::tz_info::parser::Version as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::local::tz_info::parser::Version"],"<offset::local::tz_info::parser::Version as std::cmp::PartialEq>::eq":["offset::local::tz_info::parser::Version"],"<offset::local::tz_info::parser::Version as std::fmt::Debug>::fmt":["offset::local::tz_info::parser::Version","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::local::tz_info::rule::AlternateTime as std::clone::Clone>::clone":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::rule::AlternateTime as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::rule::AlternateTime as std::cmp::PartialEq>::eq":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::rule::AlternateTime as std::fmt::Debug>::fmt":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::timezone::LocalTimeType","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<offset::local::tz_info::rule::RuleDay as std::clone::Clone>::clone":["offset::local::tz_info::rule::RuleDay"],"<offset::local::tz_info::rule::RuleDay as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::local::tz_info::rule::RuleDay"],"<offset::local::tz_info::rule::RuleDay as std::cmp::PartialEq>::eq":["offset::local::tz_info::rule::RuleDay"],"<offset::local::tz_info::rule::RuleDay as std::fmt::Debug>::fmt":["offset::local::tz_info::rule::RuleDay","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::local::tz_info::rule::TransitionRule as std::clone::Clone>::clone":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::rule::TransitionRule as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::rule::TransitionRule as std::cmp::PartialEq>::eq":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::rule::TransitionRule as std::convert::From<offset::local::tz_info::rule::AlternateTime>>::from":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::rule::TransitionRule as std::convert::From<offset::local::tz_info::timezone::LocalTimeType>>::from":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::rule::TransitionRule as std::fmt::Debug>::fmt":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::timezone::LocalTimeType","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<offset::local::tz_info::rule::UtcDateTime as std::clone::Clone>::clone":["offset::local::tz_info::rule::UtcDateTime"],"<offset::local::tz_info::rule::UtcDateTime as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::local::tz_info::rule::UtcDateTime"],"<offset::local::tz_info::rule::UtcDateTime as std::cmp::Ord>::cmp":["offset::local::tz_info::rule::UtcDateTime","std::cmp::Ordering"],"<offset::local::tz_info::rule::UtcDateTime as std::cmp::PartialEq>::eq":["offset::local::tz_info::rule::UtcDateTime"],"<offset::local::tz_info::rule::UtcDateTime as std::cmp::PartialOrd>::partial_cmp":["offset::local::tz_info::rule::UtcDateTime","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::rule::UtcDateTime as std::fmt::Debug>::fmt":["offset::local::tz_info::rule::UtcDateTime","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::local::tz_info::timezone::LeapSecond as std::clone::Clone>::clone":["offset::local::tz_info::timezone::LeapSecond"],"<offset::local::tz_info::timezone::LeapSecond as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::local::tz_info::timezone::LeapSecond"],"<offset::local::tz_info::timezone::LeapSecond as std::cmp::PartialEq>::eq":["offset::local::tz_info::timezone::LeapSecond"],"<offset::local::tz_info::timezone::LeapSecond as std::fmt::Debug>::fmt":["offset::local::tz_info::timezone::LeapSecond","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::local::tz_info::timezone::LocalTimeType as std::clone::Clone>::clone":["offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::timezone::LocalTimeType as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::timezone::LocalTimeType as std::cmp::PartialEq>::eq":["offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::timezone::LocalTimeType as std::fmt::Debug>::fmt":["offset::local::tz_info::timezone::LocalTimeType","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<offset::local::tz_info::timezone::TimeZone as std::clone::Clone>::clone":["offset::local::tz_info::timezone::TimeZone","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<offset::local::tz_info::timezone::TimeZone as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::local::tz_info::timezone::TimeZone","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<offset::local::tz_info::timezone::TimeZone as std::cmp::PartialEq>::eq":["offset::local::tz_info::timezone::TimeZone","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<offset::local::tz_info::timezone::TimeZone as std::fmt::Debug>::fmt":["offset::local::tz_info::timezone::TimeZone","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"<offset::local::tz_info::timezone::TimeZoneName as std::clone::Clone>::clone":["offset::local::tz_info::timezone::TimeZoneName"],"<offset::local::tz_info::timezone::TimeZoneName as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::local::tz_info::timezone::TimeZoneName"],"<offset::local::tz_info::timezone::TimeZoneName as std::cmp::PartialEq>::eq":["offset::local::tz_info::timezone::TimeZoneName"],"<offset::local::tz_info::timezone::TimeZoneName as std::convert::AsRef<str>>::as_ref":["offset::local::tz_info::timezone::TimeZoneName"],"<offset::local::tz_info::timezone::TimeZoneName as std::fmt::Debug>::fmt":["offset::local::tz_info::timezone::TimeZoneName","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::local::tz_info::timezone::TimeZoneRef<'a> as std::clone::Clone>::clone":["offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::timezone::TimeZoneRef<'a> as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::timezone::TimeZoneRef<'a> as std::cmp::PartialEq>::eq":["offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","std::marker::Sized","std::option::Option"],"<offset::local::tz_info::timezone::TimeZoneRef<'a> as std::fmt::Debug>::fmt":["offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<offset::local::tz_info::timezone::Transition as std::clone::Clone>::clone":["offset::local::tz_info::timezone::Transition"],"<offset::local::tz_info::timezone::Transition as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::local::tz_info::timezone::Transition"],"<offset::local::tz_info::timezone::Transition as std::cmp::PartialEq>::eq":["offset::local::tz_info::timezone::Transition"],"<offset::local::tz_info::timezone::Transition as std::fmt::Debug>::fmt":["offset::local::tz_info::timezone::Transition","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::utc::Utc as offset::Offset>::fix":["offset::fixed::FixedOffset","offset::utc::Utc"],"<offset::utc::Utc as offset::TimeZone>::from_offset":["offset::utc::Utc"],"<offset::utc::Utc as offset::TimeZone>::offset_from_local_date":["naive::date::NaiveDate","offset::LocalResult","offset::utc::Utc","std::marker::Sized"],"<offset::utc::Utc as offset::TimeZone>::offset_from_local_datetime":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::LocalResult","offset::utc::Utc","std::marker::Sized"],"<offset::utc::Utc as offset::TimeZone>::offset_from_utc_date":["naive::date::NaiveDate","offset::utc::Utc"],"<offset::utc::Utc as offset::TimeZone>::offset_from_utc_datetime":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::utc::Utc"],"<offset::utc::Utc as std::clone::Clone>::clone":["offset::utc::Utc"],"<offset::utc::Utc as std::cmp::Eq>::assert_receiver_is_total_eq":["offset::utc::Utc"],"<offset::utc::Utc as std::cmp::PartialEq>::eq":["offset::utc::Utc"],"<offset::utc::Utc as std::fmt::Debug>::fmt":["offset::utc::Utc","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::utc::Utc as std::fmt::Display>::fmt":["offset::utc::Utc","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<offset::utc::Utc as std::hash::Hash>::hash":["offset::utc::Utc","std::hash::Hasher","std::marker::Sized"],"<round::RoundingError as std::clone::Clone>::clone":["round::RoundingError"],"<round::RoundingError as std::cmp::Eq>::assert_receiver_is_total_eq":["round::RoundingError"],"<round::RoundingError as std::cmp::PartialEq>::eq":["round::RoundingError"],"<round::RoundingError as std::error::Error>::description":["round::RoundingError"],"<round::RoundingError as std::fmt::Debug>::fmt":["round::RoundingError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<round::RoundingError as std::fmt::Display>::fmt":["round::RoundingError","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<weekday::ParseWeekdayError as std::clone::Clone>::clone":["weekday::ParseWeekdayError"],"<weekday::ParseWeekdayError as std::cmp::Eq>::assert_receiver_is_total_eq":["weekday::ParseWeekdayError"],"<weekday::ParseWeekdayError as std::cmp::PartialEq>::eq":["weekday::ParseWeekdayError"],"<weekday::ParseWeekdayError as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","weekday::ParseWeekdayError"],"<weekday::ParseWeekdayError as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","weekday::ParseWeekdayError"],"<weekday::Weekday as num_traits::FromPrimitive>::from_i64":["std::marker::Sized","std::option::Option"],"<weekday::Weekday as num_traits::FromPrimitive>::from_u64":["std::marker::Sized","std::option::Option"],"<weekday::Weekday as std::clone::Clone>::clone":["weekday::Weekday"],"<weekday::Weekday as std::cmp::Eq>::assert_receiver_is_total_eq":["weekday::Weekday"],"<weekday::Weekday as std::cmp::PartialEq>::eq":["weekday::Weekday"],"<weekday::Weekday as std::convert::TryFrom<u8>>::try_from":["std::marker::Sized","std::result::Result"],"<weekday::Weekday as std::fmt::Debug>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","weekday::Weekday"],"<weekday::Weekday as std::fmt::Display>::fmt":["std::fmt::Formatter","std::marker::Sized","std::result::Result","weekday::Weekday"],"<weekday::Weekday as std::hash::Hash>::hash":["std::hash::Hasher","std::marker::Sized","weekday::Weekday"],"OutOfRange":["OutOfRange"],"OutOfRange::new":["OutOfRange"],"date::Date":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::and_hms":["OutOfRange","date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::and_hms_micro":["OutOfRange","date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::and_hms_micro_opt":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"date::Date::<Tz>::and_hms_milli":["OutOfRange","date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::and_hms_milli_opt":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"date::Date::<Tz>::and_hms_nano":["OutOfRange","date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::and_hms_nano_opt":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"date::Date::<Tz>::and_hms_opt":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"date::Date::<Tz>::and_time":["OutOfRange","date::Date","naive::date::NaiveDate","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"date::Date::<Tz>::checked_add_signed":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized","std::option::Option"],"date::Date::<Tz>::checked_sub_signed":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized","std::option::Option"],"date::Date::<Tz>::format":["OutOfRange","date::Date","format::DelayedFormat","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"date::Date::<Tz>::format_with_items":["OutOfRange","date::Date","format::DelayedFormat","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::strftime::StrftimeItems","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::clone::Clone","std::iter::Iterator","std::marker::Sized","std::option::Option"],"date::Date::<Tz>::from_utc":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::naive_local":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::naive_utc":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::offset":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::pred":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::pred_opt":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"date::Date::<Tz>::signed_duration_since":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::succ":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::succ_opt":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"date::Date::<Tz>::timezone":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::with_timezone":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"date::Date::<Tz>::years_since":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"date::map_local":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::ops::FnMut","std::option::Option"],"datetime::<impl std::convert::From<datetime::DateTime<Tz>> for std::time::SystemTime>::from":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::time::SystemTime"],"datetime::DateTime":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::checked_add_days":["OutOfRange","datetime::DateTime","naive::date::Days","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"datetime::DateTime::<Tz>::checked_add_months":["OutOfRange","datetime::DateTime","month::Months","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"datetime::DateTime::<Tz>::checked_add_signed":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized","std::option::Option"],"datetime::DateTime::<Tz>::checked_sub_days":["OutOfRange","datetime::DateTime","naive::date::Days","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"datetime::DateTime::<Tz>::checked_sub_months":["OutOfRange","datetime::DateTime","month::Months","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"datetime::DateTime::<Tz>::checked_sub_signed":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized","std::option::Option"],"datetime::DateTime::<Tz>::date":["OutOfRange","date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::date_naive":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::fixed_offset":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::format":["OutOfRange","datetime::DateTime","format::DelayedFormat","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"datetime::DateTime::<Tz>::format_with_items":["OutOfRange","datetime::DateTime","format::DelayedFormat","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::strftime::StrftimeItems","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::clone::Clone","std::iter::Iterator","std::marker::Sized","std::option::Option"],"datetime::DateTime::<Tz>::from_local":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::from_utc":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::naive_local":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::naive_utc":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::offset":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::signed_duration_since":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::time":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::timestamp":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::timestamp_micros":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::timestamp_millis":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::timestamp_nanos":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::timestamp_subsec_micros":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::timestamp_subsec_millis":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::timestamp_subsec_nanos":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::timezone":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::to_rfc2822":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::string::String"],"datetime::DateTime::<Tz>::to_rfc3339":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::string::String"],"datetime::DateTime::<Tz>::to_rfc3339_opts":["OutOfRange","datetime::DateTime","datetime::SecondsFormat","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::string::String"],"datetime::DateTime::<Tz>::with_timezone":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"datetime::DateTime::<Tz>::years_since":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::option::Option"],"datetime::DateTime::<offset::fixed::FixedOffset>::parse_and_remainder":["std::marker::Sized","std::result::Result"],"datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_rfc2822":["std::marker::Sized","std::result::Result"],"datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_rfc3339":["std::marker::Sized","std::result::Result"],"datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_str":["std::marker::Sized","std::result::Result"],"datetime::SecondsFormat":["datetime::SecondsFormat"],"datetime::map_local":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::ops::FnMut","std::option::Option"],"format::<impl std::str::FromStr for month::Month>::from_str":["std::marker::Sized","std::result::Result"],"format::<impl std::str::FromStr for weekday::Weekday>::from_str":["std::marker::Sized","std::result::Result"],"format::Colons":["format::Colons"],"format::DelayedFormat":["format::DelayedFormat","std::marker::Sized","std::option::Option"],"format::DelayedFormat::<I>::new":["format::DelayedFormat","std::marker::Sized","std::option::Option"],"format::DelayedFormat::<I>::new_with_offset":["OutOfRange","format::DelayedFormat","offset::Offset","offset::fixed::FixedOffset","std::fmt::Display","std::marker::Sized","std::option::Option"],"format::Fixed":["format::Fixed","format::InternalFixed","format::InternalInternal"],"format::InternalFixed":["format::InternalFixed","format::InternalInternal"],"format::InternalInternal":["format::InternalInternal"],"format::InternalNumeric":["format::InternalNumeric","format::Void"],"format::Item":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"format::Locale":["format::Locale"],"format::Locales":["format::Locales"],"format::Locales::new":["format::Locales","std::marker::Sized","std::option::Option"],"format::Numeric":["format::InternalNumeric","format::Numeric","format::Void"],"format::Pad":["format::Pad"],"format::ParseError":["format::ParseError","format::ParseErrorKind"],"format::ParseError::kind":["format::ParseError","format::ParseErrorKind"],"format::ParseErrorKind":["format::ParseErrorKind"],"format::Void":["format::Void"],"format::format":["OutOfRange","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::strftime::StrftimeItems","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::clone::Clone","std::fmt::Formatter","std::iter::Iterator","std::marker::Sized","std::option::Option","std::result::Result"],"format::format_inner":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::result::Result","std::string::String"],"format::format_item":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"format::parse::<impl std::str::FromStr for datetime::DateTime<offset::fixed::FixedOffset>>::from_str":["std::marker::Sized","std::result::Result"],"format::parse::parse":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::parsed::Parsed","format::strftime::StrftimeItems","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::iter::Iterator","std::marker::Sized","std::option::Option","std::result::Result"],"format::parse::parse_and_remainder":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::parsed::Parsed","format::strftime::StrftimeItems","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::iter::Iterator","std::marker::Sized","std::option::Option","std::result::Result"],"format::parse::parse_internal":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::parsed::Parsed","format::strftime::StrftimeItems","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::iter::Iterator","std::marker::Sized","std::option::Option","std::result::Result"],"format::parse::parse_rfc2822":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parse::parse_rfc3339":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parse::set_weekday_with_num_days_from_sunday":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parse::set_weekday_with_number_from_monday":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed":["format::parsed::Parsed","std::marker::Sized","std::option::Option"],"format::parsed::Parsed::new":["format::parsed::Parsed","std::marker::Sized","std::option::Option"],"format::parsed::Parsed::set_ampm":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_day":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_hour":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_hour12":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_isoweek":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_isoyear":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_isoyear_div_100":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_isoyear_mod_100":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_minute":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_month":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_nanosecond":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_offset":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_ordinal":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_second":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_timestamp":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_week_from_mon":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_week_from_sun":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_weekday":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result","weekday::Weekday"],"format::parsed::Parsed::set_year":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_year_div_100":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::set_year_mod_100":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::to_datetime":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::to_datetime_with_timezone":["format::parsed::Parsed","offset::TimeZone","offset::fixed::FixedOffset","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::to_fixed_offset":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::to_naive_date":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::to_naive_date::resolve_year":["std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::to_naive_datetime_with_offset":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::Parsed::to_naive_time":["format::parsed::Parsed","std::marker::Sized","std::option::Option","std::result::Result"],"format::parsed::set_if_consistent":["OutOfRange","std::cmp::PartialEq","std::marker::Sized","std::option::Option","std::result::Result"],"format::scan::CommentState":["format::scan::CommentState"],"format::scan::char":["std::marker::Sized","std::result::Result"],"format::scan::comment_2822":["std::marker::Sized","std::result::Result"],"format::scan::consume_colon_maybe":["std::marker::Sized","std::result::Result"],"format::scan::equals":[],"format::scan::nanosecond":["std::marker::Sized","std::result::Result"],"format::scan::nanosecond_fixed":["std::marker::Sized","std::result::Result"],"format::scan::number":["std::marker::Sized","std::result::Result"],"format::scan::s_next":[],"format::scan::short_month0":["std::marker::Sized","std::result::Result"],"format::scan::short_or_long_month0":["std::marker::Sized","std::result::Result"],"format::scan::short_or_long_weekday":["std::marker::Sized","std::result::Result"],"format::scan::short_weekday":["std::marker::Sized","std::result::Result"],"format::scan::space":["std::marker::Sized","std::result::Result"],"format::scan::timezone_name_skip":["std::marker::Sized","std::result::Result"],"format::scan::timezone_offset":["std::marker::Sized","std::ops::FnMut","std::result::Result"],"format::scan::timezone_offset_2822":["std::marker::Sized","std::result::Result"],"format::scan::timezone_offset_internal":["std::marker::Sized","std::ops::FnMut","std::result::Result"],"format::scan::timezone_offset_internal::digits":["std::marker::Sized","std::result::Result"],"format::scan::timezone_offset_permissive":["std::marker::Sized","std::ops::FnMut","std::result::Result"],"format::scan::timezone_offset_zulu":["std::marker::Sized","std::ops::FnMut","std::result::Result"],"format::scan::trim1":[],"format::strftime::StrftimeItems":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::strftime::StrftimeItems","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"format::strftime::StrftimeItems::<'a>::new":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::strftime::StrftimeItems","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"format::strftime::StrftimeItems::<'a>::with_remainer":["format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::strftime::StrftimeItems","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"format::write_hundreds":["std::fmt::Write","std::marker::Sized","std::result::Result"],"format::write_local_minus_utc":["format::Colons","offset::fixed::FixedOffset","std::marker::Sized","std::result::Result","std::string::String"],"format::write_rfc2822":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::fixed::FixedOffset","std::marker::Sized","std::result::Result","std::string::String"],"format::write_rfc2822_inner":["format::Locales","naive::date::NaiveDate","naive::time::NaiveTime","offset::fixed::FixedOffset","std::marker::Sized","std::result::Result","std::string::String"],"format::write_rfc3339":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::fixed::FixedOffset","std::marker::Sized","std::result::Result","std::string::String"],"month::Month":["month::Month"],"month::Month::name":["month::Month"],"month::Month::number_from_month":["month::Month"],"month::Month::pred":["month::Month"],"month::Month::succ":["month::Month"],"month::Months":["month::Months"],"month::Months::new":["month::Months"],"month::ParseMonthError":["month::ParseMonthError"],"naive::date::Days":["naive::date::Days"],"naive::date::Days::new":["naive::date::Days"],"naive::date::NaiveDate":["naive::date::NaiveDate"],"naive::date::NaiveDate::and_hms":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::date::NaiveDate::and_hms_micro":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::date::NaiveDate::and_hms_micro_opt":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::and_hms_milli":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::date::NaiveDate::and_hms_milli_opt":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::and_hms_nano":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::date::NaiveDate::and_hms_nano_opt":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::and_hms_opt":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::and_time":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::date::NaiveDate::checked_add_days":["naive::date::Days","naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::checked_add_months":["month::Months","naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::checked_add_signed":["naive::date::NaiveDate","oldtime::Duration","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::checked_sub_days":["naive::date::Days","naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::checked_sub_months":["month::Months","naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::checked_sub_signed":["naive::date::NaiveDate","oldtime::Duration","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::diff_days":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::diff_months":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::format":["format::DelayedFormat","naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::format_with_items":["OutOfRange","format::DelayedFormat","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::strftime::StrftimeItems","naive::date::NaiveDate","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::clone::Clone","std::iter::Iterator","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::from_isoywd":["naive::date::NaiveDate","weekday::Weekday"],"naive::date::NaiveDate::from_isoywd_opt":["std::marker::Sized","std::option::Option","weekday::Weekday"],"naive::date::NaiveDate::from_mdf":["naive::internals::Mdf","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::from_num_days_from_ce":["naive::date::NaiveDate"],"naive::date::NaiveDate::from_num_days_from_ce_opt":["std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::from_ordinal_and_flags":["naive::internals::YearFlags","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::from_weekday_of_month":["naive::date::NaiveDate","weekday::Weekday"],"naive::date::NaiveDate::from_weekday_of_month_opt":["std::marker::Sized","std::option::Option","weekday::Weekday"],"naive::date::NaiveDate::from_ymd":["naive::date::NaiveDate"],"naive::date::NaiveDate::from_ymd_opt":["std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::from_yo":["naive::date::NaiveDate"],"naive::date::NaiveDate::from_yo_opt":["std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::iter_days":["naive::date::NaiveDate","naive::date::NaiveDateDaysIterator"],"naive::date::NaiveDate::iter_weeks":["naive::date::NaiveDate","naive::date::NaiveDateWeeksIterator"],"naive::date::NaiveDate::mdf":["naive::date::NaiveDate","naive::internals::Mdf"],"naive::date::NaiveDate::of":["naive::date::NaiveDate","naive::internals::Of"],"naive::date::NaiveDate::parse_and_remainder":["std::marker::Sized","std::result::Result"],"naive::date::NaiveDate::parse_from_str":["std::marker::Sized","std::result::Result"],"naive::date::NaiveDate::pred":["naive::date::NaiveDate"],"naive::date::NaiveDate::pred_opt":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::signed_duration_since":["naive::date::NaiveDate","oldtime::Duration"],"naive::date::NaiveDate::succ":["naive::date::NaiveDate"],"naive::date::NaiveDate::succ_opt":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::week":["naive::date::NaiveDate","naive::date::NaiveWeek","weekday::Weekday"],"naive::date::NaiveDate::weeks_from":["naive::date::NaiveDate","weekday::Weekday"],"naive::date::NaiveDate::with_mdf":["naive::date::NaiveDate","naive::internals::Mdf","std::marker::Sized","std::option::Option"],"naive::date::NaiveDate::with_of":["naive::date::NaiveDate","naive::internals::Of"],"naive::date::NaiveDate::years_since":["naive::date::NaiveDate","std::marker::Sized","std::option::Option"],"naive::date::NaiveDateDaysIterator":["naive::date::NaiveDate","naive::date::NaiveDateDaysIterator"],"naive::date::NaiveDateWeeksIterator":["naive::date::NaiveDate","naive::date::NaiveDateWeeksIterator"],"naive::date::NaiveWeek":["naive::date::NaiveDate","naive::date::NaiveWeek","weekday::Weekday"],"naive::date::NaiveWeek::days":["naive::date::NaiveDate","naive::date::NaiveWeek","std::marker::Sized","std::ops::RangeInclusive","weekday::Weekday"],"naive::date::NaiveWeek::first_day":["naive::date::NaiveDate","naive::date::NaiveWeek","weekday::Weekday"],"naive::date::NaiveWeek::last_day":["naive::date::NaiveDate","naive::date::NaiveWeek","weekday::Weekday"],"naive::date::div_mod_floor":[],"naive::datetime::NaiveDateTime":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::datetime::NaiveDateTime::and_local_timezone":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::LocalResult","offset::TimeZone","offset::fixed::FixedOffset","std::marker::Sized"],"naive::datetime::NaiveDateTime::and_utc":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"naive::datetime::NaiveDateTime::checked_add_days":["naive::date::Days","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"naive::datetime::NaiveDateTime::checked_add_months":["month::Months","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"naive::datetime::NaiveDateTime::checked_add_signed":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","oldtime::Duration","std::marker::Sized","std::option::Option"],"naive::datetime::NaiveDateTime::checked_sub_days":["naive::date::Days","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"naive::datetime::NaiveDateTime::checked_sub_months":["month::Months","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"naive::datetime::NaiveDateTime::checked_sub_signed":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","oldtime::Duration","std::marker::Sized","std::option::Option"],"naive::datetime::NaiveDateTime::date":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::datetime::NaiveDateTime::format":["format::DelayedFormat","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"naive::datetime::NaiveDateTime::format_with_items":["OutOfRange","format::DelayedFormat","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::strftime::StrftimeItems","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::clone::Clone","std::iter::Iterator","std::marker::Sized","std::option::Option"],"naive::datetime::NaiveDateTime::from_timestamp":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::datetime::NaiveDateTime::from_timestamp_micros":["std::marker::Sized","std::option::Option"],"naive::datetime::NaiveDateTime::from_timestamp_millis":["std::marker::Sized","std::option::Option"],"naive::datetime::NaiveDateTime::from_timestamp_opt":["std::marker::Sized","std::option::Option"],"naive::datetime::NaiveDateTime::new":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::datetime::NaiveDateTime::parse_and_remainder":["std::marker::Sized","std::result::Result"],"naive::datetime::NaiveDateTime::parse_from_str":["std::marker::Sized","std::result::Result"],"naive::datetime::NaiveDateTime::signed_duration_since":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","oldtime::Duration"],"naive::datetime::NaiveDateTime::time":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::datetime::NaiveDateTime::timestamp":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::datetime::NaiveDateTime::timestamp_micros":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::datetime::NaiveDateTime::timestamp_millis":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::datetime::NaiveDateTime::timestamp_nanos":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::datetime::NaiveDateTime::timestamp_subsec_micros":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::datetime::NaiveDateTime::timestamp_subsec_millis":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::datetime::NaiveDateTime::timestamp_subsec_nanos":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"naive::internals::Mdf":["naive::internals::Mdf"],"naive::internals::Mdf::day":["naive::internals::Mdf"],"naive::internals::Mdf::from_of":["naive::internals::Mdf","naive::internals::Of"],"naive::internals::Mdf::month":["naive::internals::Mdf"],"naive::internals::Mdf::new":["naive::internals::YearFlags","std::marker::Sized","std::option::Option"],"naive::internals::Mdf::to_of":["naive::internals::Mdf","std::marker::Sized","std::option::Option"],"naive::internals::Mdf::with_day":["naive::internals::Mdf","std::marker::Sized","std::option::Option"],"naive::internals::Mdf::with_flags":["naive::internals::Mdf","naive::internals::YearFlags"],"naive::internals::Mdf::with_month":["naive::internals::Mdf","std::marker::Sized","std::option::Option"],"naive::internals::Of":["naive::internals::Of"],"naive::internals::Of::flags":["naive::internals::Of","naive::internals::YearFlags"],"naive::internals::Of::from_date_impl":["naive::internals::Of"],"naive::internals::Of::from_mdf":["naive::internals::Mdf","std::marker::Sized","std::option::Option"],"naive::internals::Of::inner":["naive::internals::Of"],"naive::internals::Of::isoweekdate_raw":["naive::internals::Of","weekday::Weekday"],"naive::internals::Of::new":["naive::internals::YearFlags","std::marker::Sized","std::option::Option"],"naive::internals::Of::ol":["naive::internals::Of"],"naive::internals::Of::ordinal":["naive::internals::Of"],"naive::internals::Of::pred":["naive::internals::Of","std::marker::Sized","std::option::Option"],"naive::internals::Of::succ":["naive::internals::Of","std::marker::Sized","std::option::Option"],"naive::internals::Of::to_mdf":["naive::internals::Mdf","naive::internals::Of"],"naive::internals::Of::validate":["naive::internals::Of","std::marker::Sized","std::option::Option"],"naive::internals::Of::weekday":["naive::internals::Of","weekday::Weekday"],"naive::internals::Of::with_ordinal":["naive::internals::Of","std::marker::Sized","std::option::Option"],"naive::internals::YearFlags":["naive::internals::YearFlags"],"naive::internals::YearFlags::from_year":["naive::internals::YearFlags"],"naive::internals::YearFlags::from_year_mod_400":["naive::internals::YearFlags"],"naive::internals::YearFlags::isoweek_delta":["naive::internals::YearFlags"],"naive::internals::YearFlags::ndays":["naive::internals::YearFlags"],"naive::internals::YearFlags::nisoweeks":["naive::internals::YearFlags"],"naive::internals::cycle_to_yo":[],"naive::internals::weekday_from_u32_mod7":["weekday::Weekday"],"naive::internals::yo_to_cycle":[],"naive::isoweek::IsoWeek":["naive::isoweek::IsoWeek"],"naive::isoweek::IsoWeek::week":["naive::isoweek::IsoWeek"],"naive::isoweek::IsoWeek::week0":["naive::isoweek::IsoWeek"],"naive::isoweek::IsoWeek::year":["naive::isoweek::IsoWeek"],"naive::isoweek::iso_week_from_yof":["naive::internals::Of","naive::isoweek::IsoWeek"],"naive::time::NaiveTime":["naive::time::NaiveTime"],"naive::time::NaiveTime::format":["format::DelayedFormat","naive::time::NaiveTime","std::marker::Sized","std::option::Option"],"naive::time::NaiveTime::format_with_items":["OutOfRange","format::DelayedFormat","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::Void","format::strftime::StrftimeItems","naive::time::NaiveTime","std::alloc::Allocator","std::borrow::Borrow","std::boxed::Box","std::clone::Clone","std::iter::Iterator","std::marker::Sized","std::option::Option"],"naive::time::NaiveTime::from_hms":["naive::time::NaiveTime"],"naive::time::NaiveTime::from_hms_micro":["naive::time::NaiveTime"],"naive::time::NaiveTime::from_hms_micro_opt":["std::marker::Sized","std::option::Option"],"naive::time::NaiveTime::from_hms_milli":["naive::time::NaiveTime"],"naive::time::NaiveTime::from_hms_milli_opt":["std::marker::Sized","std::option::Option"],"naive::time::NaiveTime::from_hms_nano":["naive::time::NaiveTime"],"naive::time::NaiveTime::from_hms_nano_opt":["std::marker::Sized","std::option::Option"],"naive::time::NaiveTime::from_hms_opt":["std::marker::Sized","std::option::Option"],"naive::time::NaiveTime::from_num_seconds_from_midnight":["naive::time::NaiveTime"],"naive::time::NaiveTime::from_num_seconds_from_midnight_opt":["std::marker::Sized","std::option::Option"],"naive::time::NaiveTime::hms":["naive::time::NaiveTime"],"naive::time::NaiveTime::overflowing_add_signed":["naive::time::NaiveTime","oldtime::Duration"],"naive::time::NaiveTime::overflowing_sub_signed":["naive::time::NaiveTime","oldtime::Duration"],"naive::time::NaiveTime::parse_and_remainder":["std::marker::Sized","std::result::Result"],"naive::time::NaiveTime::parse_from_str":["std::marker::Sized","std::result::Result"],"naive::time::NaiveTime::signed_duration_since":["naive::time::NaiveTime","oldtime::Duration"],"offset::LocalResult":["offset::LocalResult","std::marker::Sized"],"offset::LocalResult::<T>::earliest":["offset::LocalResult","std::marker::Sized","std::option::Option"],"offset::LocalResult::<T>::latest":["offset::LocalResult","std::marker::Sized","std::option::Option"],"offset::LocalResult::<T>::map":["offset::LocalResult","std::marker::Sized","std::ops::FnMut"],"offset::LocalResult::<T>::single":["offset::LocalResult","std::marker::Sized","std::option::Option"],"offset::LocalResult::<T>::unwrap":["offset::LocalResult","std::marker::Sized"],"offset::LocalResult::<date::Date<Tz>>::and_hms_micro_opt":["offset::LocalResult","std::marker::Sized"],"offset::LocalResult::<date::Date<Tz>>::and_hms_milli_opt":["offset::LocalResult","std::marker::Sized"],"offset::LocalResult::<date::Date<Tz>>::and_hms_nano_opt":["offset::LocalResult","std::marker::Sized"],"offset::LocalResult::<date::Date<Tz>>::and_hms_opt":["offset::LocalResult","std::marker::Sized"],"offset::LocalResult::<date::Date<Tz>>::and_time":["naive::time::NaiveTime","offset::LocalResult","std::marker::Sized"],"offset::Offset::fix":["offset::fixed::FixedOffset"],"offset::TimeZone::datetime_from_str":["std::marker::Sized","std::result::Result"],"offset::TimeZone::from_local_date":["naive::date::NaiveDate","offset::LocalResult","std::marker::Sized"],"offset::TimeZone::from_local_datetime":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::LocalResult","std::marker::Sized"],"offset::TimeZone::from_offset":[],"offset::TimeZone::from_utc_date":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"offset::TimeZone::from_utc_datetime":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"offset::TimeZone::isoywd":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","weekday::Weekday"],"offset::TimeZone::isoywd_opt":["offset::LocalResult","std::marker::Sized","weekday::Weekday"],"offset::TimeZone::offset_from_local_date":["naive::date::NaiveDate","offset::LocalResult","std::marker::Sized"],"offset::TimeZone::offset_from_local_datetime":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::LocalResult","std::marker::Sized"],"offset::TimeZone::offset_from_utc_date":["naive::date::NaiveDate"],"offset::TimeZone::offset_from_utc_datetime":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"offset::TimeZone::timestamp":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"offset::TimeZone::timestamp_millis":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"offset::TimeZone::timestamp_millis_opt":["offset::LocalResult","std::marker::Sized"],"offset::TimeZone::timestamp_nanos":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"offset::TimeZone::timestamp_opt":["offset::LocalResult","std::marker::Sized"],"offset::TimeZone::with_ymd_and_hms":["offset::LocalResult","std::marker::Sized"],"offset::TimeZone::ymd":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"offset::TimeZone::ymd_opt":["offset::LocalResult","std::marker::Sized"],"offset::TimeZone::yo":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"offset::TimeZone::yo_opt":["offset::LocalResult","std::marker::Sized"],"offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::add":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for naive::datetime::NaiveDateTime>::add":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::fixed::FixedOffset"],"offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for naive::time::NaiveTime>::add":["naive::time::NaiveTime","offset::fixed::FixedOffset"],"offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::sub":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for naive::datetime::NaiveDateTime>::sub":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::fixed::FixedOffset"],"offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for naive::time::NaiveTime>::sub":["naive::time::NaiveTime","offset::fixed::FixedOffset"],"offset::fixed::FixedOffset":["offset::fixed::FixedOffset"],"offset::fixed::FixedOffset::east":["offset::fixed::FixedOffset"],"offset::fixed::FixedOffset::east_opt":["std::marker::Sized","std::option::Option"],"offset::fixed::FixedOffset::local_minus_utc":["offset::fixed::FixedOffset"],"offset::fixed::FixedOffset::utc_minus_local":["offset::fixed::FixedOffset"],"offset::fixed::FixedOffset::west":["offset::fixed::FixedOffset"],"offset::fixed::FixedOffset::west_opt":["std::marker::Sized","std::option::Option"],"offset::fixed::add_with_leapsecond":["OutOfRange","date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized","std::ops::Add","traits::Timelike"],"offset::local::Local":["offset::local::Local"],"offset::local::Local::now":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"offset::local::Local::today":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"offset::local::inner::Cache":["offset::local::inner::Cache","offset::local::inner::Source","offset::local::tz_info::timezone::TimeZone","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::time::SystemTime","std::vec::Vec"],"offset::local::inner::Cache::offset":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::LocalResult","offset::local::inner::Cache","offset::local::inner::Source","offset::local::tz_info::timezone::TimeZone","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::time::SystemTime","std::vec::Vec"],"offset::local::inner::Source":["offset::local::inner::Source","std::time::SystemTime"],"offset::local::inner::Source::new":["offset::local::inner::Source","std::marker::Sized","std::option::Option","std::time::SystemTime"],"offset::local::inner::TZ_INFO::__getit":["std::marker::Sized","std::option::Option"],"offset::local::inner::TZ_INFO::__init":["std::cell::RefCell"],"offset::local::inner::current_zone":["offset::local::tz_info::timezone::TimeZone","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"offset::local::inner::fallback_timezone":["std::marker::Sized","std::option::Option"],"offset::local::inner::offset":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::LocalResult","std::marker::Sized"],"offset::local::inner::offset_from_local_datetime":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::LocalResult","std::marker::Sized"],"offset::local::inner::offset_from_utc_datetime":["naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::LocalResult","std::marker::Sized"],"offset::local::tz_info::Error":["offset::local::tz_info::Error","std::io::Error","std::num::ParseIntError","std::str::Utf8Error","std::time::SystemTimeError"],"offset::local::tz_info::parser::Cursor":["offset::local::tz_info::parser::Cursor"],"offset::local::tz_info::parser::Cursor::<'a>::is_empty":["offset::local::tz_info::parser::Cursor"],"offset::local::tz_info::parser::Cursor::<'a>::new":["offset::local::tz_info::parser::Cursor"],"offset::local::tz_info::parser::Cursor::<'a>::peek":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::option::Option"],"offset::local::tz_info::parser::Cursor::<'a>::read_be_u32":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::parser::Cursor::<'a>::read_exact":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::parser::Cursor::<'a>::read_int":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","offset::local::tz_info::parser::Cursor","std::clone::Clone","std::marker::Sized","std::result::Result","std::str::FromStr"],"offset::local::tz_info::parser::Cursor::<'a>::read_optional_tag":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::parser::Cursor::<'a>::read_tag":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::parser::Cursor::<'a>::read_until":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::ops::Fn","std::result::Result"],"offset::local::tz_info::parser::Cursor::<'a>::read_while":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::ops::Fn","std::result::Result"],"offset::local::tz_info::parser::Cursor::<'a>::remaining":["offset::local::tz_info::parser::Cursor"],"offset::local::tz_info::parser::Header":["offset::local::tz_info::parser::Header","offset::local::tz_info::parser::Version"],"offset::local::tz_info::parser::Header::new":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::parser::State":["offset::local::tz_info::parser::Header","offset::local::tz_info::parser::State","offset::local::tz_info::parser::Version"],"offset::local::tz_info::parser::State::<'a>::new":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::parser::State::<'a>::parse_time":["offset::local::tz_info::parser::Header","offset::local::tz_info::parser::State","offset::local::tz_info::parser::Version","std::marker::Sized","std::result::Result"],"offset::local::tz_info::parser::Version":["offset::local::tz_info::parser::Version"],"offset::local::tz_info::parser::parse":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::parser::read_be_i32":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::parser::read_be_i64":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::rule::AlternateTime":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"offset::local::tz_info::rule::AlternateTime::find_local_time_type":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option","std::result::Result"],"offset::local::tz_info::rule::AlternateTime::find_local_time_type_from_local":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option","std::result::Result"],"offset::local::tz_info::rule::AlternateTime::new":["offset::local::tz_info::rule::RuleDay","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option","std::result::Result"],"offset::local::tz_info::rule::RuleDay":["offset::local::tz_info::rule::RuleDay"],"offset::local::tz_info::rule::RuleDay::julian_0":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::rule::RuleDay::julian_1":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::rule::RuleDay::month_weekday":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::rule::RuleDay::parse":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::rule::RuleDay::transition_date":["offset::local::tz_info::rule::RuleDay"],"offset::local::tz_info::rule::RuleDay::unix_time":["offset::local::tz_info::rule::RuleDay"],"offset::local::tz_info::rule::TransitionRule":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"offset::local::tz_info::rule::TransitionRule::find_local_time_type":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option","std::result::Result"],"offset::local::tz_info::rule::TransitionRule::find_local_time_type_from_local":["offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option","std::result::Result"],"offset::local::tz_info::rule::TransitionRule::from_tz_string":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::rule::UtcDateTime":["offset::local::tz_info::rule::UtcDateTime"],"offset::local::tz_info::rule::UtcDateTime::from_timespec":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::rule::days_since_unix_epoch":[],"offset::local::tz_info::rule::is_leap_year":[],"offset::local::tz_info::rule::parse_hhmmss":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::rule::parse_name":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::rule::parse_offset":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::rule::parse_rule_time":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::rule::parse_rule_time_extended":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::rule::parse_signed_hhmmss":["offset::local::tz_info::parser::Cursor","std::marker::Sized","std::result::Result"],"offset::local::tz_info::timezone::LeapSecond":["offset::local::tz_info::timezone::LeapSecond"],"offset::local::tz_info::timezone::LeapSecond::new":["offset::local::tz_info::timezone::LeapSecond"],"offset::local::tz_info::timezone::LeapSecond::unix_leap_time":["offset::local::tz_info::timezone::LeapSecond"],"offset::local::tz_info::timezone::LocalTimeType":["offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"offset::local::tz_info::timezone::LocalTimeType::is_dst":["offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"offset::local::tz_info::timezone::LocalTimeType::new":["std::marker::Sized","std::option::Option","std::result::Result"],"offset::local::tz_info::timezone::LocalTimeType::offset":["offset::local::tz_info::timezone::LocalTimeType","std::marker::Sized","std::option::Option"],"offset::local::tz_info::timezone::LocalTimeType::with_offset":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::timezone::TimeZone":["offset::local::tz_info::timezone::TimeZone","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"offset::local::tz_info::timezone::TimeZone::as_ref":["offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZone","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"offset::local::tz_info::timezone::TimeZone::find_local_time_type":["offset::local::tz_info::timezone::TimeZone","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"offset::local::tz_info::timezone::TimeZone::find_local_time_type_from_local":["offset::local::tz_info::timezone::TimeZone","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"offset::local::tz_info::timezone::TimeZone::fixed":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::timezone::TimeZone::from_file":["std::fs::File","std::marker::Sized","std::result::Result"],"offset::local::tz_info::timezone::TimeZone::from_posix_tz":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::timezone::TimeZone::from_tz_data":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::timezone::TimeZone::local":["std::marker::Sized","std::option::Option","std::result::Result"],"offset::local::tz_info::timezone::TimeZone::new":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"offset::local::tz_info::timezone::TimeZone::utc":["offset::local::tz_info::timezone::TimeZone","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"offset::local::tz_info::timezone::TimeZoneName":["offset::local::tz_info::timezone::TimeZoneName"],"offset::local::tz_info::timezone::TimeZoneName::as_bytes":["offset::local::tz_info::timezone::TimeZoneName"],"offset::local::tz_info::timezone::TimeZoneName::equal":["offset::local::tz_info::timezone::TimeZoneName"],"offset::local::tz_info::timezone::TimeZoneName::new":["std::marker::Sized","std::result::Result"],"offset::local::tz_info::timezone::TimeZoneRef":["offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","std::marker::Sized","std::option::Option"],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::find_local_time_type":["offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","std::marker::Sized","std::option::Option","std::result::Result"],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::find_local_time_type_from_local":["offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","std::marker::Sized","std::option::Option","std::result::Result"],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::unix_leap_time_to_unix_time":["offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","std::marker::Sized","std::option::Option","std::result::Result"],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::unix_time_to_unix_leap_time":["offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","std::marker::Sized","std::option::Option","std::result::Result"],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::validate":["offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","std::marker::Sized","std::option::Option","std::result::Result"],"offset::local::tz_info::timezone::Transition":["offset::local::tz_info::timezone::Transition"],"offset::local::tz_info::timezone::Transition::new":["offset::local::tz_info::timezone::Transition"],"offset::local::tz_info::timezone::Transition::unix_leap_time":["offset::local::tz_info::timezone::Transition"],"offset::local::tz_info::timezone::find_tz_file":["offset::local::tz_info::timezone::TimeZoneName","std::convert::AsRef","std::marker::Sized","std::result::Result"],"offset::local::tz_info::timezone::saturating_abs":[],"offset::utc::Utc":["offset::utc::Utc"],"offset::utc::Utc::now":["OutOfRange","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"offset::utc::Utc::today":["OutOfRange","date::Date","naive::date::NaiveDate","offset::TimeZone","offset::fixed::FixedOffset","std::clone::Clone","std::marker::Sized"],"round::DurationRound::duration_round":["oldtime::Duration","std::marker::Sized","std::result::Result"],"round::DurationRound::duration_trunc":["oldtime::Duration","std::marker::Sized","std::result::Result"],"round::RoundingError":["round::RoundingError"],"round::SubsecRound::round_subsecs":[],"round::SubsecRound::trunc_subsecs":[],"round::duration_round":["OutOfRange","date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized","std::ops::Add","std::ops::Sub","std::result::Result","traits::Timelike"],"round::duration_trunc":["OutOfRange","date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::TimeZone","offset::fixed::FixedOffset","oldtime::Duration","std::clone::Clone","std::marker::Sized","std::ops::Add","std::ops::Sub","std::result::Result","traits::Timelike"],"round::span_for_digits":[],"traits::Datelike::day":[],"traits::Datelike::day0":[],"traits::Datelike::iso_week":["naive::isoweek::IsoWeek"],"traits::Datelike::month":[],"traits::Datelike::month0":[],"traits::Datelike::num_days_from_ce":[],"traits::Datelike::ordinal":[],"traits::Datelike::ordinal0":[],"traits::Datelike::weekday":["weekday::Weekday"],"traits::Datelike::with_day":["std::marker::Sized","std::option::Option"],"traits::Datelike::with_day0":["std::marker::Sized","std::option::Option"],"traits::Datelike::with_month":["std::marker::Sized","std::option::Option"],"traits::Datelike::with_month0":["std::marker::Sized","std::option::Option"],"traits::Datelike::with_ordinal":["std::marker::Sized","std::option::Option"],"traits::Datelike::with_ordinal0":["std::marker::Sized","std::option::Option"],"traits::Datelike::with_year":["std::marker::Sized","std::option::Option"],"traits::Datelike::year":[],"traits::Datelike::year_ce":[],"traits::Timelike::hour":[],"traits::Timelike::hour12":[],"traits::Timelike::minute":[],"traits::Timelike::nanosecond":[],"traits::Timelike::num_seconds_from_midnight":[],"traits::Timelike::second":[],"traits::Timelike::with_hour":["std::marker::Sized","std::option::Option"],"traits::Timelike::with_minute":["std::marker::Sized","std::option::Option"],"traits::Timelike::with_nanosecond":["std::marker::Sized","std::option::Option"],"traits::Timelike::with_second":["std::marker::Sized","std::option::Option"],"weekday::ParseWeekdayError":["weekday::ParseWeekdayError"],"weekday::Weekday":["weekday::Weekday"],"weekday::Weekday::num_days_from":["weekday::Weekday"],"weekday::Weekday::num_days_from_monday":["weekday::Weekday"],"weekday::Weekday::num_days_from_sunday":["weekday::Weekday"],"weekday::Weekday::number_from_monday":["weekday::Weekday"],"weekday::Weekday::number_from_sunday":["weekday::Weekday"],"weekday::Weekday::pred":["weekday::Weekday"],"weekday::Weekday::succ":["weekday::Weekday"]},"glob_path_import":{},"self_to_fn":{"<T as round::SubsecRound>::T":["impl<T> SubsecRound for T\nwhere\n    T: Timelike + Add<Duration, Output = T> + Sub<Duration, Output = T>,\n{\n    fn round_subsecs(self, digits: u16) -> T {\n        let span = span_for_digits(digits);\n        let delta_down = self.nanosecond() % span;\n        if delta_down > 0 {\n            let delta_up = span - delta_down;\n            if delta_up <= delta_down {\n                self + Duration::nanoseconds(delta_up.into())\n            } else {\n                self - Duration::nanoseconds(delta_down.into())\n            }\n        } else {\n            self // unchanged\n        }\n    }\n\n    fn trunc_subsecs(self, digits: u16) -> T {\n        let span = span_for_digits(digits);\n        let delta_down = self.nanosecond() % span;\n        if delta_down > 0 {\n            self - Duration::nanoseconds(delta_down.into())\n        } else {\n            self // unchanged\n        }\n    }\n}"],"OutOfRange":["Clone","Copy","Eq","Hash","PartialEq","impl OutOfRange {\n    const fn new() -> OutOfRange {\n        OutOfRange { _private: () }\n    }\n}","impl fmt::Debug for OutOfRange {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"out of range\")\n    }\n}","impl fmt::Display for OutOfRange {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"out of range\")\n    }\n}","impl std::error::Error for OutOfRange {}"],"date::Date":["Clone","impl<Tz: TimeZone, Tz2: TimeZone> PartialEq<Date<Tz2>> for Date<Tz> {\n    fn eq(&self, other: &Date<Tz2>) -> bool {\n        self.date == other.date\n    }\n}","impl<Tz: TimeZone> Add<OldDuration> for Date<Tz> {\n    type Output = Date<Tz>;\n\n    #[inline]\n    fn add(self, rhs: OldDuration) -> Date<Tz> {\n        self.checked_add_signed(rhs).expect(\"`Date + Duration` overflowed\")\n    }\n}","impl<Tz: TimeZone> AddAssign<OldDuration> for Date<Tz> {\n    #[inline]\n    fn add_assign(&mut self, rhs: OldDuration) {\n        self.date = self.date.checked_add_signed(rhs).expect(\"`Date + Duration` overflowed\");\n    }\n}","impl<Tz: TimeZone> Copy for Date<Tz> where <Tz as TimeZone>::Offset: Copy {}","impl<Tz: TimeZone> Date<Tz>\nwhere\n    Tz::Offset: fmt::Display,\n{\n    /// Formats the date with the specified formatting items.\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[inline]\n    #[must_use]\n    pub fn format_with_items<'a, I, B>(&self, items: I) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,\n    {\n        DelayedFormat::new_with_offset(Some(self.naive_local()), None, &self.offset, items)\n    }\n\n    /// Formats the date with the specified format string.\n    /// See the [`crate::format::strftime`] module\n    /// on the supported escape sequences.\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[inline]\n    #[must_use]\n    pub fn format<'a>(&self, fmt: &'a str) -> DelayedFormat<StrftimeItems<'a>> {\n        self.format_with_items(StrftimeItems::new(fmt))\n    }\n\n    /// Formats the date with the specified formatting items and locale.\n    #[cfg(feature = \"unstable-locales\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"unstable-locales\")))]\n    #[inline]\n    #[must_use]\n    pub fn format_localized_with_items<'a, I, B>(\n        &self,\n        items: I,\n        locale: Locale,\n    ) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,\n    {\n        DelayedFormat::new_with_offset_and_locale(\n            Some(self.naive_local()),\n            None,\n            &self.offset,\n            items,\n            locale,\n        )\n    }\n\n    /// Formats the date with the specified format string and locale.\n    /// See the [`crate::format::strftime`] module\n    /// on the supported escape sequences.\n    #[cfg(feature = \"unstable-locales\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"unstable-locales\")))]\n    #[inline]\n    #[must_use]\n    pub fn format_localized<'a>(\n        &self,\n        fmt: &'a str,\n        locale: Locale,\n    ) -> DelayedFormat<StrftimeItems<'a>> {\n        self.format_localized_with_items(StrftimeItems::new_with_locale(fmt, locale), locale)\n    }\n}","impl<Tz: TimeZone> Date<Tz> {\n    /// Makes a new `Date` with given *UTC* date and offset.\n    /// The local date should be constructed via the `TimeZone` trait.\n    //\n    // note: this constructor is purposely not named to `new` to discourage the direct usage.\n    #[inline]\n    #[must_use]\n    pub fn from_utc(date: NaiveDate, offset: Tz::Offset) -> Date<Tz> {\n        Date { date, offset }\n    }\n\n    /// Makes a new `DateTime` from the current date and given `NaiveTime`.\n    /// The offset in the current date is preserved.\n    ///\n    /// Panics on invalid datetime.\n    #[inline]\n    #[must_use]\n    pub fn and_time(&self, time: NaiveTime) -> Option<DateTime<Tz>> {\n        let localdt = self.naive_local().and_time(time);\n        self.timezone().from_local_datetime(&localdt).single()\n    }\n\n    /// Makes a new `DateTime` from the current date, hour, minute and second.\n    /// The offset in the current date is preserved.\n    ///\n    /// Panics on invalid hour, minute and/or second.\n    #[deprecated(since = \"0.4.23\", note = \"Use and_hms_opt() instead\")]\n    #[inline]\n    #[must_use]\n    pub fn and_hms(&self, hour: u32, min: u32, sec: u32) -> DateTime<Tz> {\n        self.and_hms_opt(hour, min, sec).expect(\"invalid time\")\n    }\n\n    /// Makes a new `DateTime` from the current date, hour, minute and second.\n    /// The offset in the current date is preserved.\n    ///\n    /// Returns `None` on invalid hour, minute and/or second.\n    #[inline]\n    #[must_use]\n    pub fn and_hms_opt(&self, hour: u32, min: u32, sec: u32) -> Option<DateTime<Tz>> {\n        NaiveTime::from_hms_opt(hour, min, sec).and_then(|time| self.and_time(time))\n    }\n\n    /// Makes a new `DateTime` from the current date, hour, minute, second and millisecond.\n    /// The millisecond part can exceed 1,000 in order to represent the leap second.\n    /// The offset in the current date is preserved.\n    ///\n    /// Panics on invalid hour, minute, second and/or millisecond.\n    #[deprecated(since = \"0.4.23\", note = \"Use and_hms_milli_opt() instead\")]\n    #[inline]\n    #[must_use]\n    pub fn and_hms_milli(&self, hour: u32, min: u32, sec: u32, milli: u32) -> DateTime<Tz> {\n        self.and_hms_milli_opt(hour, min, sec, milli).expect(\"invalid time\")\n    }\n\n    /// Makes a new `DateTime` from the current date, hour, minute, second and millisecond.\n    /// The millisecond part can exceed 1,000 in order to represent the leap second.\n    /// The offset in the current date is preserved.\n    ///\n    /// Returns `None` on invalid hour, minute, second and/or millisecond.\n    #[inline]\n    #[must_use]\n    pub fn and_hms_milli_opt(\n        &self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        milli: u32,\n    ) -> Option<DateTime<Tz>> {\n        NaiveTime::from_hms_milli_opt(hour, min, sec, milli).and_then(|time| self.and_time(time))\n    }\n\n    /// Makes a new `DateTime` from the current date, hour, minute, second and microsecond.\n    /// The microsecond part can exceed 1,000,000 in order to represent the leap second.\n    /// The offset in the current date is preserved.\n    ///\n    /// Panics on invalid hour, minute, second and/or microsecond.\n    #[deprecated(since = \"0.4.23\", note = \"Use and_hms_micro_opt() instead\")]\n    #[inline]\n    #[must_use]\n    pub fn and_hms_micro(&self, hour: u32, min: u32, sec: u32, micro: u32) -> DateTime<Tz> {\n        self.and_hms_micro_opt(hour, min, sec, micro).expect(\"invalid time\")\n    }\n\n    /// Makes a new `DateTime` from the current date, hour, minute, second and microsecond.\n    /// The microsecond part can exceed 1,000,000 in order to represent the leap second.\n    /// The offset in the current date is preserved.\n    ///\n    /// Returns `None` on invalid hour, minute, second and/or microsecond.\n    #[inline]\n    #[must_use]\n    pub fn and_hms_micro_opt(\n        &self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        micro: u32,\n    ) -> Option<DateTime<Tz>> {\n        NaiveTime::from_hms_micro_opt(hour, min, sec, micro).and_then(|time| self.and_time(time))\n    }\n\n    /// Makes a new `DateTime` from the current date, hour, minute, second and nanosecond.\n    /// The nanosecond part can exceed 1,000,000,000 in order to represent the leap second.\n    /// The offset in the current date is preserved.\n    ///\n    /// Panics on invalid hour, minute, second and/or nanosecond.\n    #[deprecated(since = \"0.4.23\", note = \"Use and_hms_nano_opt() instead\")]\n    #[inline]\n    #[must_use]\n    pub fn and_hms_nano(&self, hour: u32, min: u32, sec: u32, nano: u32) -> DateTime<Tz> {\n        self.and_hms_nano_opt(hour, min, sec, nano).expect(\"invalid time\")\n    }\n\n    /// Makes a new `DateTime` from the current date, hour, minute, second and nanosecond.\n    /// The nanosecond part can exceed 1,000,000,000 in order to represent the leap second.\n    /// The offset in the current date is preserved.\n    ///\n    /// Returns `None` on invalid hour, minute, second and/or nanosecond.\n    #[inline]\n    #[must_use]\n    pub fn and_hms_nano_opt(\n        &self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        nano: u32,\n    ) -> Option<DateTime<Tz>> {\n        NaiveTime::from_hms_nano_opt(hour, min, sec, nano).and_then(|time| self.and_time(time))\n    }\n\n    /// Makes a new `Date` for the next date.\n    ///\n    /// Panics when `self` is the last representable date.\n    #[deprecated(since = \"0.4.23\", note = \"Use succ_opt() instead\")]\n    #[inline]\n    #[must_use]\n    pub fn succ(&self) -> Date<Tz> {\n        self.succ_opt().expect(\"out of bound\")\n    }\n\n    /// Makes a new `Date` for the next date.\n    ///\n    /// Returns `None` when `self` is the last representable date.\n    #[inline]\n    #[must_use]\n    pub fn succ_opt(&self) -> Option<Date<Tz>> {\n        self.date.succ_opt().map(|date| Date::from_utc(date, self.offset.clone()))\n    }\n\n    /// Makes a new `Date` for the prior date.\n    ///\n    /// Panics when `self` is the first representable date.\n    #[deprecated(since = \"0.4.23\", note = \"Use pred_opt() instead\")]\n    #[inline]\n    #[must_use]\n    pub fn pred(&self) -> Date<Tz> {\n        self.pred_opt().expect(\"out of bound\")\n    }\n\n    /// Makes a new `Date` for the prior date.\n    ///\n    /// Returns `None` when `self` is the first representable date.\n    #[inline]\n    #[must_use]\n    pub fn pred_opt(&self) -> Option<Date<Tz>> {\n        self.date.pred_opt().map(|date| Date::from_utc(date, self.offset.clone()))\n    }\n\n    /// Retrieves an associated offset from UTC.\n    #[inline]\n    #[must_use]\n    pub fn offset(&self) -> &Tz::Offset {\n        &self.offset\n    }\n\n    /// Retrieves an associated time zone.\n    #[inline]\n    #[must_use]\n    pub fn timezone(&self) -> Tz {\n        TimeZone::from_offset(&self.offset)\n    }\n\n    /// Changes the associated time zone.\n    /// This does not change the actual `Date` (but will change the string representation).\n    #[inline]\n    #[must_use]\n    pub fn with_timezone<Tz2: TimeZone>(&self, tz: &Tz2) -> Date<Tz2> {\n        tz.from_utc_date(&self.date)\n    }\n\n    /// Adds given `Duration` to the current date.\n    ///\n    /// Returns `None` when it will result in overflow.\n    #[inline]\n    #[must_use]\n    pub fn checked_add_signed(self, rhs: OldDuration) -> Option<Date<Tz>> {\n        let date = self.date.checked_add_signed(rhs)?;\n        Some(Date { date, offset: self.offset })\n    }\n\n    /// Subtracts given `Duration` from the current date.\n    ///\n    /// Returns `None` when it will result in overflow.\n    #[inline]\n    #[must_use]\n    pub fn checked_sub_signed(self, rhs: OldDuration) -> Option<Date<Tz>> {\n        let date = self.date.checked_sub_signed(rhs)?;\n        Some(Date { date, offset: self.offset })\n    }\n\n    /// Subtracts another `Date` from the current date.\n    /// Returns a `Duration` of integral numbers.\n    ///\n    /// This does not overflow or underflow at all,\n    /// as all possible output fits in the range of `Duration`.\n    #[inline]\n    #[must_use]\n    pub fn signed_duration_since<Tz2: TimeZone>(self, rhs: Date<Tz2>) -> OldDuration {\n        self.date.signed_duration_since(rhs.date)\n    }\n\n    /// Returns a view to the naive UTC date.\n    #[inline]\n    #[must_use]\n    pub fn naive_utc(&self) -> NaiveDate {\n        self.date\n    }\n\n    /// Returns a view to the naive local date.\n    ///\n    /// This is technically the same as [`naive_utc`](#method.naive_utc)\n    /// because the offset is restricted to never exceed one day,\n    /// but provided for the consistency.\n    #[inline]\n    #[must_use]\n    pub fn naive_local(&self) -> NaiveDate {\n        self.date\n    }\n\n    /// Returns the number of whole years from the given `base` until `self`.\n    #[must_use]\n    pub fn years_since(&self, base: Self) -> Option<u32> {\n        self.date.years_since(base.date)\n    }\n\n    /// The minimum possible `Date`.\n    pub const MIN_UTC: Date<Utc> = Date { date: NaiveDate::MIN, offset: Utc };\n    /// The maximum possible `Date`.\n    pub const MAX_UTC: Date<Utc> = Date { date: NaiveDate::MAX, offset: Utc };\n}","impl<Tz: TimeZone> Datelike for Date<Tz> {\n    #[inline]\n    fn year(&self) -> i32 {\n        self.naive_local().year()\n    }\n    #[inline]\n    fn month(&self) -> u32 {\n        self.naive_local().month()\n    }\n    #[inline]\n    fn month0(&self) -> u32 {\n        self.naive_local().month0()\n    }\n    #[inline]\n    fn day(&self) -> u32 {\n        self.naive_local().day()\n    }\n    #[inline]\n    fn day0(&self) -> u32 {\n        self.naive_local().day0()\n    }\n    #[inline]\n    fn ordinal(&self) -> u32 {\n        self.naive_local().ordinal()\n    }\n    #[inline]\n    fn ordinal0(&self) -> u32 {\n        self.naive_local().ordinal0()\n    }\n    #[inline]\n    fn weekday(&self) -> Weekday {\n        self.naive_local().weekday()\n    }\n    #[inline]\n    fn iso_week(&self) -> IsoWeek {\n        self.naive_local().iso_week()\n    }\n\n    #[inline]\n    fn with_year(&self, year: i32) -> Option<Date<Tz>> {\n        map_local(self, |date| date.with_year(year))\n    }\n\n    #[inline]\n    fn with_month(&self, month: u32) -> Option<Date<Tz>> {\n        map_local(self, |date| date.with_month(month))\n    }\n\n    #[inline]\n    fn with_month0(&self, month0: u32) -> Option<Date<Tz>> {\n        map_local(self, |date| date.with_month0(month0))\n    }\n\n    #[inline]\n    fn with_day(&self, day: u32) -> Option<Date<Tz>> {\n        map_local(self, |date| date.with_day(day))\n    }\n\n    #[inline]\n    fn with_day0(&self, day0: u32) -> Option<Date<Tz>> {\n        map_local(self, |date| date.with_day0(day0))\n    }\n\n    #[inline]\n    fn with_ordinal(&self, ordinal: u32) -> Option<Date<Tz>> {\n        map_local(self, |date| date.with_ordinal(ordinal))\n    }\n\n    #[inline]\n    fn with_ordinal0(&self, ordinal0: u32) -> Option<Date<Tz>> {\n        map_local(self, |date| date.with_ordinal0(ordinal0))\n    }\n}","impl<Tz: TimeZone> Eq for Date<Tz> {}","impl<Tz: TimeZone> Ord for Date<Tz> {\n    fn cmp(&self, other: &Date<Tz>) -> Ordering {\n        self.date.cmp(&other.date)\n    }\n}","impl<Tz: TimeZone> PartialOrd for Date<Tz> {\n    fn partial_cmp(&self, other: &Date<Tz>) -> Option<Ordering> {\n        self.date.partial_cmp(&other.date)\n    }\n}","impl<Tz: TimeZone> Sub<Date<Tz>> for Date<Tz> {\n    type Output = OldDuration;\n\n    #[inline]\n    fn sub(self, rhs: Date<Tz>) -> OldDuration {\n        self.signed_duration_since(rhs)\n    }\n}","impl<Tz: TimeZone> Sub<OldDuration> for Date<Tz> {\n    type Output = Date<Tz>;\n\n    #[inline]\n    fn sub(self, rhs: OldDuration) -> Date<Tz> {\n        self.checked_sub_signed(rhs).expect(\"`Date - Duration` overflowed\")\n    }\n}","impl<Tz: TimeZone> SubAssign<OldDuration> for Date<Tz> {\n    #[inline]\n    fn sub_assign(&mut self, rhs: OldDuration) {\n        self.date = self.date.checked_sub_signed(rhs).expect(\"`Date - Duration` overflowed\");\n    }\n}","impl<Tz: TimeZone> fmt::Debug for Date<Tz> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.naive_local().fmt(f)?;\n        self.offset.fmt(f)\n    }\n}","impl<Tz: TimeZone> fmt::Display for Date<Tz>\nwhere\n    Tz::Offset: fmt::Display,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.naive_local().fmt(f)?;\n        self.offset.fmt(f)\n    }\n}","impl<Tz: TimeZone> hash::Hash for Date<Tz> {\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        self.date.hash(state)\n    }\n}","unsafe impl<Tz: TimeZone> Send for Date<Tz> where <Tz as TimeZone>::Offset: Send {}"],"datetime::DateTime":["Clone","impl DateTime<FixedOffset> {\n    /// Parses an RFC 2822 date-and-time string into a `DateTime<FixedOffset>` value.\n    ///\n    /// This parses valid RFC 2822 datetime strings (such as `Tue, 1 Jul 2003 10:52:37 +0200`)\n    /// and returns a new [`DateTime`] instance with the parsed timezone as the [`FixedOffset`].\n    ///\n    /// RFC 2822 is the internet message standard that specifies the representation of times in HTTP\n    /// and email headers.\n    ///\n    /// The RFC 2822 standard allows arbitrary intermixed whitespace.\n    /// See [RFC 2822 Appendix A.5]\n    ///\n    /// ```\n    /// # use chrono::{DateTime, FixedOffset, TimeZone};\n    /// assert_eq!(\n    ///     DateTime::parse_from_rfc2822(\"Wed, 18 Feb 2015 23:16:09 GMT\").unwrap(),\n    ///     FixedOffset::east_opt(0).unwrap().with_ymd_and_hms(2015, 2, 18, 23, 16, 9).unwrap()\n    /// );\n    /// ```\n    ///\n    /// [RFC 2822 Appendix A.5]: https://www.rfc-editor.org/rfc/rfc2822#appendix-A.5\n    pub fn parse_from_rfc2822(s: &str) -> ParseResult<DateTime<FixedOffset>> {\n        const ITEMS: &[Item<'static>] = &[Item::Fixed(Fixed::RFC2822)];\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, ITEMS.iter())?;\n        parsed.to_datetime()\n    }\n\n    /// Parses an RFC 3339 date-and-time string into a `DateTime<FixedOffset>` value.\n    ///\n    /// Parses all valid RFC 3339 values (as well as the subset of valid ISO 8601 values that are\n    /// also valid RFC 3339 date-and-time values) and returns a new [`DateTime`] with a\n    /// [`FixedOffset`] corresponding to the parsed timezone. While RFC 3339 values come in a wide\n    /// variety of shapes and sizes, `1996-12-19T16:39:57-08:00` is an example of the most commonly\n    /// encountered variety of RFC 3339 formats.\n    ///\n    /// Why isn't this named `parse_from_iso8601`? That's because ISO 8601 allows representing\n    /// values in a wide range of formats, only some of which represent actual date-and-time\n    /// instances (rather than periods, ranges, dates, or times). Some valid ISO 8601 values are\n    /// also simultaneously valid RFC 3339 values, but not all RFC 3339 values are valid ISO 8601\n    /// values (or the other way around).\n    pub fn parse_from_rfc3339(s: &str) -> ParseResult<DateTime<FixedOffset>> {\n        const ITEMS: &[Item<'static>] = &[Item::Fixed(Fixed::RFC3339)];\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, ITEMS.iter())?;\n        parsed.to_datetime()\n    }\n\n    /// Parses a string from a user-specified format into a `DateTime<FixedOffset>` value.\n    ///\n    /// Note that this method *requires a timezone* in the input string. See\n    /// [`NaiveDateTime::parse_from_str`](./naive/struct.NaiveDateTime.html#method.parse_from_str)\n    /// for a version that does not require a timezone in the to-be-parsed str. The returned\n    /// [`DateTime`] value will have a [`FixedOffset`] reflecting the parsed timezone.\n    ///\n    /// See the [`format::strftime` module](./format/strftime/index.html) for supported format\n    /// sequences.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use chrono::{DateTime, FixedOffset, TimeZone, NaiveDate};\n    ///\n    /// let dt = DateTime::parse_from_str(\n    ///     \"1983 Apr 13 12:09:14.274 +0000\", \"%Y %b %d %H:%M:%S%.3f %z\");\n    /// assert_eq!(dt, Ok(FixedOffset::east_opt(0).unwrap().from_local_datetime(&NaiveDate::from_ymd_opt(1983, 4, 13).unwrap().and_hms_milli_opt(12, 9, 14, 274).unwrap()).unwrap()));\n    /// ```\n    pub fn parse_from_str(s: &str, fmt: &str) -> ParseResult<DateTime<FixedOffset>> {\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_datetime()\n    }\n\n    /// Parses a string from a user-specified format into a `DateTime<FixedOffset>` value, and a\n    /// slice with the remaining portion of the string.\n    ///\n    /// Note that this method *requires a timezone* in the input string. See\n    /// [`NaiveDateTime::parse_and_remainder`] for a version that does not\n    /// require a timezone in `s`. The returned [`DateTime`] value will have a [`FixedOffset`]\n    /// reflecting the parsed timezone.\n    ///\n    /// See the [`format::strftime` module](./format/strftime/index.html) for supported format\n    /// sequences.\n    ///\n    /// Similar to [`parse_from_str`](#method.parse_from_str).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use chrono::{DateTime, FixedOffset, TimeZone};\n    /// let (datetime, remainder) = DateTime::parse_and_remainder(\n    ///     \"2015-02-18 23:16:09 +0200 trailing text\", \"%Y-%m-%d %H:%M:%S %z\").unwrap();\n    /// assert_eq!(\n    ///     datetime,\n    ///     FixedOffset::east_opt(2*3600).unwrap().with_ymd_and_hms(2015, 2, 18, 23, 16, 9).unwrap()\n    /// );\n    /// assert_eq!(remainder, \" trailing text\");\n    /// ```\n    pub fn parse_and_remainder<'a>(\n        s: &'a str,\n        fmt: &str,\n    ) -> ParseResult<(DateTime<FixedOffset>, &'a str)> {\n        let mut parsed = Parsed::new();\n        let remainder = parse_and_remainder(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_datetime().map(|d| (d, remainder))\n    }\n}","impl Default for DateTime<FixedOffset> {\n    fn default() -> Self {\n        FixedOffset::west_opt(0).unwrap().from_utc_datetime(&NaiveDateTime::default())\n    }\n}","impl Default for DateTime<Local> {\n    fn default() -> Self {\n        Local.from_utc_datetime(&NaiveDateTime::default())\n    }\n}","impl Default for DateTime<Utc> {\n    fn default() -> Self {\n        Utc.from_utc_datetime(&NaiveDateTime::default())\n    }\n}","impl From<DateTime<FixedOffset>> for DateTime<Local> {\n    /// Convert this `DateTime<FixedOffset>` instance into a `DateTime<Local>` instance.\n    ///\n    /// Conversion is performed via [`DateTime::with_timezone`]. Returns the equivalent value in local\n    /// time.\n    fn from(src: DateTime<FixedOffset>) -> Self {\n        src.with_timezone(&Local)\n    }\n}","impl From<DateTime<FixedOffset>> for DateTime<Utc> {\n    /// Convert this `DateTime<FixedOffset>` instance into a `DateTime<Utc>` instance.\n    ///\n    /// Conversion is performed via [`DateTime::with_timezone`], accounting for the timezone\n    /// difference.\n    fn from(src: DateTime<FixedOffset>) -> Self {\n        src.with_timezone(&Utc)\n    }\n}","impl From<DateTime<Local>> for DateTime<FixedOffset> {\n    /// Convert this `DateTime<Local>` instance into a `DateTime<FixedOffset>` instance.\n    ///\n    /// Conversion is performed via [`DateTime::with_timezone`].\n    fn from(src: DateTime<Local>) -> Self {\n        src.with_timezone(&src.offset().fix())\n    }\n}","impl From<DateTime<Local>> for DateTime<Utc> {\n    /// Convert this `DateTime<Local>` instance into a `DateTime<Utc>` instance.\n    ///\n    /// Conversion is performed via [`DateTime::with_timezone`], accounting for the difference in\n    /// timezones.\n    fn from(src: DateTime<Local>) -> Self {\n        src.with_timezone(&Utc)\n    }\n}","impl From<DateTime<Utc>> for DateTime<FixedOffset> {\n    /// Convert this `DateTime<Utc>` instance into a `DateTime<FixedOffset>` instance.\n    ///\n    /// Conversion is done via [`DateTime::with_timezone`]. Note that the converted value returned by\n    /// this will be created with a fixed timezone offset of 0.\n    fn from(src: DateTime<Utc>) -> Self {\n        src.with_timezone(&FixedOffset::east_opt(0).unwrap())\n    }\n}","impl From<DateTime<Utc>> for DateTime<Local> {\n    /// Convert this `DateTime<Utc>` instance into a `DateTime<Local>` instance.\n    ///\n    /// Conversion is performed via [`DateTime::with_timezone`], accounting for the difference in timezones.\n    fn from(src: DateTime<Utc>) -> Self {\n        src.with_timezone(&Local)\n    }\n}","impl From<SystemTime> for DateTime<Local> {\n    fn from(t: SystemTime) -> DateTime<Local> {\n        DateTime::<Utc>::from(t).with_timezone(&Local)\n    }\n}","impl From<SystemTime> for DateTime<Utc> {\n    fn from(t: SystemTime) -> DateTime<Utc> {\n        let (sec, nsec) = match t.duration_since(UNIX_EPOCH) {\n            Ok(dur) => (dur.as_secs() as i64, dur.subsec_nanos()),\n            Err(e) => {\n                // unlikely but should be handled\n                let dur = e.duration();\n                let (sec, nsec) = (dur.as_secs() as i64, dur.subsec_nanos());\n                if nsec == 0 {\n                    (-sec, 0)\n                } else {\n                    (-sec - 1, 1_000_000_000 - nsec)\n                }\n            }\n        };\n        Utc.timestamp_opt(sec, nsec).unwrap()\n    }\n}","impl str::FromStr for DateTime<FixedOffset> {\n    type Err = ParseError;\n\n    fn from_str(s: &str) -> ParseResult<DateTime<FixedOffset>> {\n        const DATE_ITEMS: &[Item<'static>] = &[\n            Item::Numeric(Numeric::Year, Pad::Zero),\n            Item::Literal(\"-\"),\n            Item::Numeric(Numeric::Month, Pad::Zero),\n            Item::Literal(\"-\"),\n            Item::Numeric(Numeric::Day, Pad::Zero),\n        ];\n        const TIME_ITEMS: &[Item<'static>] = &[\n            Item::Numeric(Numeric::Hour, Pad::Zero),\n            Item::Literal(\":\"),\n            Item::Numeric(Numeric::Minute, Pad::Zero),\n            Item::Literal(\":\"),\n            Item::Numeric(Numeric::Second, Pad::Zero),\n            Item::Fixed(Fixed::Nanosecond),\n            Item::Fixed(Fixed::TimezoneOffsetZ),\n        ];\n\n        let mut parsed = Parsed::new();\n        match parse_internal(&mut parsed, s, DATE_ITEMS.iter()) {\n            Err((remainder, e)) if e.0 == ParseErrorKind::TooLong => {\n                if remainder.starts_with('T') || remainder.starts_with(' ') {\n                    parse(&mut parsed, &remainder[1..], TIME_ITEMS.iter())?;\n                } else {\n                    return Err(INVALID);\n                }\n            }\n            Err((_s, e)) => return Err(e),\n            Ok(_) => return Err(NOT_ENOUGH),\n        };\n        parsed.to_datetime()\n    }\n}","impl str::FromStr for DateTime<Local> {\n    type Err = ParseError;\n\n    fn from_str(s: &str) -> ParseResult<DateTime<Local>> {\n        s.parse::<DateTime<FixedOffset>>().map(|dt| dt.with_timezone(&Local))\n    }\n}","impl str::FromStr for DateTime<Utc> {\n    type Err = ParseError;\n\n    fn from_str(s: &str) -> ParseResult<DateTime<Utc>> {\n        s.parse::<DateTime<FixedOffset>>().map(|dt| dt.with_timezone(&Utc))\n    }\n}","impl<Tz: TimeZone, Tz2: TimeZone> PartialEq<DateTime<Tz2>> for DateTime<Tz> {\n    fn eq(&self, other: &DateTime<Tz2>) -> bool {\n        self.datetime == other.datetime\n    }\n}","impl<Tz: TimeZone, Tz2: TimeZone> PartialOrd<DateTime<Tz2>> for DateTime<Tz> {\n    /// Compare two DateTimes based on their true time, ignoring time zones\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::prelude::*;\n    ///\n    /// let earlier = Utc.with_ymd_and_hms(2015, 5, 15, 2, 0, 0).unwrap().with_timezone(&FixedOffset::west_opt(1 * 3600).unwrap());\n    /// let later   = Utc.with_ymd_and_hms(2015, 5, 15, 3, 0, 0).unwrap().with_timezone(&FixedOffset::west_opt(5 * 3600).unwrap());\n    ///\n    /// assert_eq!(earlier.to_string(), \"2015-05-15 01:00:00 -01:00\");\n    /// assert_eq!(later.to_string(), \"2015-05-14 22:00:00 -05:00\");\n    ///\n    /// assert!(later > earlier);\n    /// ```\n    fn partial_cmp(&self, other: &DateTime<Tz2>) -> Option<Ordering> {\n        self.datetime.partial_cmp(&other.datetime)\n    }\n}","impl<Tz: TimeZone> Add<Days> for DateTime<Tz> {\n    type Output = DateTime<Tz>;\n\n    fn add(self, days: Days) -> Self::Output {\n        self.checked_add_days(days).unwrap()\n    }\n}","impl<Tz: TimeZone> Add<FixedOffset> for DateTime<Tz> {\n    type Output = DateTime<Tz>;\n\n    #[inline]\n    fn add(self, rhs: FixedOffset) -> DateTime<Tz> {\n        add_with_leapsecond(&self, rhs.local_minus_utc)\n    }\n}","impl<Tz: TimeZone> Add<Months> for DateTime<Tz> {\n    type Output = DateTime<Tz>;\n\n    fn add(self, rhs: Months) -> Self::Output {\n        self.checked_add_months(rhs).unwrap()\n    }\n}","impl<Tz: TimeZone> Add<OldDuration> for DateTime<Tz> {\n    type Output = DateTime<Tz>;\n\n    #[inline]\n    fn add(self, rhs: OldDuration) -> DateTime<Tz> {\n        self.checked_add_signed(rhs).expect(\"`DateTime + Duration` overflowed\")\n    }\n}","impl<Tz: TimeZone> AddAssign<OldDuration> for DateTime<Tz> {\n    #[inline]\n    fn add_assign(&mut self, rhs: OldDuration) {\n        let datetime =\n            self.datetime.checked_add_signed(rhs).expect(\"`DateTime + Duration` overflowed\");\n        let tz = self.timezone();\n        *self = tz.from_utc_datetime(&datetime);\n    }\n}","impl<Tz: TimeZone> Copy for DateTime<Tz> where <Tz as TimeZone>::Offset: Copy {}","impl<Tz: TimeZone> DateTime<Tz>\nwhere\n    Tz::Offset: fmt::Display,\n{\n    /// Returns an RFC 2822 date and time string such as `Tue, 1 Jul 2003 10:52:37 +0200`.\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[must_use]\n    pub fn to_rfc2822(&self) -> String {\n        let mut result = String::with_capacity(32);\n        crate::format::write_rfc2822(&mut result, self.naive_local(), self.offset.fix())\n            .expect(\"writing rfc2822 datetime to string should never fail\");\n        result\n    }\n\n    /// Returns an RFC 3339 and ISO 8601 date and time string such as `1996-12-19T16:39:57-08:00`.\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[must_use]\n    pub fn to_rfc3339(&self) -> String {\n        let mut result = String::with_capacity(32);\n        crate::format::write_rfc3339(&mut result, self.naive_local(), self.offset.fix())\n            .expect(\"writing rfc3339 datetime to string should never fail\");\n        result\n    }\n\n    /// Return an RFC 3339 and ISO 8601 date and time string with subseconds\n    /// formatted as per `SecondsFormat`.\n    ///\n    /// If `use_z` is true and the timezone is UTC (offset 0), uses `Z` as\n    /// per [`Fixed::TimezoneOffsetColonZ`]. If `use_z` is false, uses\n    /// [`Fixed::TimezoneOffsetColon`]\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use chrono::{FixedOffset, SecondsFormat, TimeZone, Utc, NaiveDate};\n    /// let dt = NaiveDate::from_ymd_opt(2018, 1, 26).unwrap().and_hms_micro_opt(18, 30, 9, 453_829).unwrap().and_local_timezone(Utc).unwrap();\n    /// assert_eq!(dt.to_rfc3339_opts(SecondsFormat::Millis, false),\n    ///            \"2018-01-26T18:30:09.453+00:00\");\n    /// assert_eq!(dt.to_rfc3339_opts(SecondsFormat::Millis, true),\n    ///            \"2018-01-26T18:30:09.453Z\");\n    /// assert_eq!(dt.to_rfc3339_opts(SecondsFormat::Secs, true),\n    ///            \"2018-01-26T18:30:09Z\");\n    ///\n    /// let pst = FixedOffset::east_opt(8 * 60 * 60).unwrap();\n    /// let dt = pst.from_local_datetime(&NaiveDate::from_ymd_opt(2018, 1, 26).unwrap().and_hms_micro_opt(10, 30, 9, 453_829).unwrap()).unwrap();\n    /// assert_eq!(dt.to_rfc3339_opts(SecondsFormat::Secs, true),\n    ///            \"2018-01-26T10:30:09+08:00\");\n    /// ```\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[must_use]\n    pub fn to_rfc3339_opts(&self, secform: SecondsFormat, use_z: bool) -> String {\n        use crate::format::Numeric::*;\n        use crate::format::Pad::Zero;\n        use crate::SecondsFormat::*;\n\n        debug_assert!(secform != __NonExhaustive, \"Do not use __NonExhaustive!\");\n\n        const PREFIX: &[Item<'static>] = &[\n            Item::Numeric(Year, Zero),\n            Item::Literal(\"-\"),\n            Item::Numeric(Month, Zero),\n            Item::Literal(\"-\"),\n            Item::Numeric(Day, Zero),\n            Item::Literal(\"T\"),\n            Item::Numeric(Hour, Zero),\n            Item::Literal(\":\"),\n            Item::Numeric(Minute, Zero),\n            Item::Literal(\":\"),\n            Item::Numeric(Second, Zero),\n        ];\n\n        let ssitem = match secform {\n            Secs => None,\n            Millis => Some(Item::Fixed(Fixed::Nanosecond3)),\n            Micros => Some(Item::Fixed(Fixed::Nanosecond6)),\n            Nanos => Some(Item::Fixed(Fixed::Nanosecond9)),\n            AutoSi => Some(Item::Fixed(Fixed::Nanosecond)),\n            __NonExhaustive => unreachable!(),\n        };\n\n        let tzitem = Item::Fixed(if use_z {\n            Fixed::TimezoneOffsetColonZ\n        } else {\n            Fixed::TimezoneOffsetColon\n        });\n\n        match ssitem {\n            None => self.format_with_items(PREFIX.iter().chain([tzitem].iter())).to_string(),\n            Some(s) => self.format_with_items(PREFIX.iter().chain([s, tzitem].iter())).to_string(),\n        }\n    }\n\n    /// Formats the combined date and time with the specified formatting items.\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[inline]\n    #[must_use]\n    pub fn format_with_items<'a, I, B>(&self, items: I) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,\n    {\n        let local = self.naive_local();\n        DelayedFormat::new_with_offset(Some(local.date()), Some(local.time()), &self.offset, items)\n    }\n\n    /// Formats the combined date and time per the specified format string.\n    ///\n    /// See the [`crate::format::strftime`] module for the supported escape sequences.\n    ///\n    /// # Example\n    /// ```rust\n    /// use chrono::prelude::*;\n    ///\n    /// let date_time: DateTime<Utc> = Utc.with_ymd_and_hms(2017, 04, 02, 12, 50, 32).unwrap();\n    /// let formatted = format!(\"{}\", date_time.format(\"%d/%m/%Y %H:%M\"));\n    /// assert_eq!(formatted, \"02/04/2017 12:50\");\n    /// ```\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[inline]\n    #[must_use]\n    pub fn format<'a>(&self, fmt: &'a str) -> DelayedFormat<StrftimeItems<'a>> {\n        self.format_with_items(StrftimeItems::new(fmt))\n    }\n\n    /// Formats the combined date and time with the specified formatting items and locale.\n    #[cfg(feature = \"unstable-locales\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"unstable-locales\")))]\n    #[inline]\n    #[must_use]\n    pub fn format_localized_with_items<'a, I, B>(\n        &self,\n        items: I,\n        locale: Locale,\n    ) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,\n    {\n        let local = self.naive_local();\n        DelayedFormat::new_with_offset_and_locale(\n            Some(local.date()),\n            Some(local.time()),\n            &self.offset,\n            items,\n            locale,\n        )\n    }\n\n    /// Formats the combined date and time per the specified format string and\n    /// locale.\n    ///\n    /// See the [`crate::format::strftime`] module on the supported escape\n    /// sequences.\n    #[cfg(feature = \"unstable-locales\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"unstable-locales\")))]\n    #[inline]\n    #[must_use]\n    pub fn format_localized<'a>(\n        &self,\n        fmt: &'a str,\n        locale: Locale,\n    ) -> DelayedFormat<StrftimeItems<'a>> {\n        self.format_localized_with_items(StrftimeItems::new_with_locale(fmt, locale), locale)\n    }\n}","impl<Tz: TimeZone> DateTime<Tz> {\n    /// Makes a new `DateTime` with given *UTC* datetime and offset.\n    /// The local datetime should be constructed via the `TimeZone` trait.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{DateTime, TimeZone, NaiveDateTime, Utc};\n    ///\n    /// let dt = DateTime::<Utc>::from_utc(NaiveDateTime::from_timestamp_opt(61, 0).unwrap(), Utc);\n    /// assert_eq!(Utc.timestamp_opt(61, 0).unwrap(), dt);\n    /// ```\n    //\n    // note: this constructor is purposely not named to `new` to discourage the direct usage.\n    #[inline]\n    #[must_use]\n    pub fn from_utc(datetime: NaiveDateTime, offset: Tz::Offset) -> DateTime<Tz> {\n        DateTime { datetime, offset }\n    }\n\n    /// Makes a new `DateTime` with given **local** datetime and offset that\n    /// presents local timezone.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::DateTime;\n    /// use chrono::naive::NaiveDate;\n    /// use chrono::offset::{Utc, FixedOffset};\n    ///\n    /// let naivedatetime_utc = NaiveDate::from_ymd_opt(2000, 1, 12).unwrap().and_hms_opt(2, 0, 0).unwrap();\n    /// let datetime_utc = DateTime::<Utc>::from_utc(naivedatetime_utc, Utc);\n    ///\n    /// let timezone_east = FixedOffset::east_opt(8 * 60 * 60).unwrap();\n    /// let naivedatetime_east = NaiveDate::from_ymd_opt(2000, 1, 12).unwrap().and_hms_opt(10, 0, 0).unwrap();\n    /// let datetime_east = DateTime::<FixedOffset>::from_local(naivedatetime_east, timezone_east);\n    ///\n    /// let timezone_west = FixedOffset::west_opt(7 * 60 * 60).unwrap();\n    /// let naivedatetime_west = NaiveDate::from_ymd_opt(2000, 1, 11).unwrap().and_hms_opt(19, 0, 0).unwrap();\n    /// let datetime_west = DateTime::<FixedOffset>::from_local(naivedatetime_west, timezone_west);\n\n    /// assert_eq!(datetime_east, datetime_utc.with_timezone(&timezone_east));\n    /// assert_eq!(datetime_west, datetime_utc.with_timezone(&timezone_west));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn from_local(datetime: NaiveDateTime, offset: Tz::Offset) -> DateTime<Tz> {\n        let datetime_utc = datetime - offset.fix();\n\n        DateTime { datetime: datetime_utc, offset }\n    }\n\n    /// Retrieves a date component\n    ///\n    /// Unless you are immediately planning on turning this into a `DateTime`\n    /// with the same Timezone you should use the\n    /// [`date_naive`](DateTime::date_naive) method.\n    #[inline]\n    #[deprecated(since = \"0.4.23\", note = \"Use `date_naive()` instead\")]\n    #[allow(deprecated)]\n    #[must_use]\n    pub fn date(&self) -> Date<Tz> {\n        Date::from_utc(self.naive_local().date(), self.offset.clone())\n    }\n\n    /// Retrieves the Date without an associated timezone\n    ///\n    /// [`NaiveDate`] is a more well-defined type, and has more traits implemented on it,\n    /// so should be preferred to [`Date`] any time you truly want to operate on Dates.\n    ///\n    /// ```\n    /// use chrono::prelude::*;\n    ///\n    /// let date: DateTime<Utc> = Utc.with_ymd_and_hms(2020, 1, 1, 0, 0, 0).unwrap();\n    /// let other: DateTime<FixedOffset> = FixedOffset::east_opt(23).unwrap().with_ymd_and_hms(2020, 1, 1, 0, 0, 0).unwrap();\n    /// assert_eq!(date.date_naive(), other.date_naive());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn date_naive(&self) -> NaiveDate {\n        let local = self.naive_local();\n        NaiveDate::from_ymd_opt(local.year(), local.month(), local.day()).unwrap()\n    }\n\n    /// Retrieves a time component.\n    /// Unlike `date`, this is not associated to the time zone.\n    #[inline]\n    #[must_use]\n    pub fn time(&self) -> NaiveTime {\n        self.datetime.time() + self.offset.fix()\n    }\n\n    /// Returns the number of non-leap seconds since January 1, 1970 0:00:00 UTC\n    /// (aka \"UNIX timestamp\").\n    #[inline]\n    #[must_use]\n    pub fn timestamp(&self) -> i64 {\n        self.datetime.timestamp()\n    }\n\n    /// Returns the number of non-leap-milliseconds since January 1, 1970 UTC\n    ///\n    /// Note that this does reduce the number of years that can be represented\n    /// from ~584 Billion to ~584 Million. (If this is a problem, please file\n    /// an issue to let me know what domain needs millisecond precision over\n    /// billions of years, I'm curious.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Utc, NaiveDate};\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_milli_opt(0, 0, 1, 444).unwrap().and_local_timezone(Utc).unwrap();\n    /// assert_eq!(dt.timestamp_millis(), 1_444);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_milli_opt(1, 46, 40, 555).unwrap().and_local_timezone(Utc).unwrap();\n    /// assert_eq!(dt.timestamp_millis(), 1_000_000_000_555);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn timestamp_millis(&self) -> i64 {\n        self.datetime.timestamp_millis()\n    }\n\n    /// Returns the number of non-leap-microseconds since January 1, 1970 UTC\n    ///\n    /// Note that this does reduce the number of years that can be represented\n    /// from ~584 Billion to ~584 Thousand. (If this is a problem, please file\n    /// an issue to let me know what domain needs microsecond precision over\n    /// millennia, I'm curious.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Utc, NaiveDate};\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_micro_opt(0, 0, 1, 444).unwrap().and_local_timezone(Utc).unwrap();\n    /// assert_eq!(dt.timestamp_micros(), 1_000_444);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_micro_opt(1, 46, 40, 555).unwrap().and_local_timezone(Utc).unwrap();\n    /// assert_eq!(dt.timestamp_micros(), 1_000_000_000_000_555);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn timestamp_micros(&self) -> i64 {\n        self.datetime.timestamp_micros()\n    }\n\n    /// Returns the number of non-leap-nanoseconds since January 1, 1970 UTC\n    ///\n    /// Note that this does reduce the number of years that can be represented\n    /// from ~584 Billion to ~584. (If this is a problem, please file\n    /// an issue to let me know what domain needs nanosecond precision over\n    /// millennia, I'm curious.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Utc, NaiveDate};\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_nano_opt(0, 0, 1, 444).unwrap().and_local_timezone(Utc).unwrap();\n    /// assert_eq!(dt.timestamp_nanos(), 1_000_000_444);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_nano_opt(1, 46, 40, 555).unwrap().and_local_timezone(Utc).unwrap();\n    /// assert_eq!(dt.timestamp_nanos(), 1_000_000_000_000_000_555);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn timestamp_nanos(&self) -> i64 {\n        self.datetime.timestamp_nanos()\n    }\n\n    /// Returns the number of milliseconds since the last second boundary\n    ///\n    /// warning: in event of a leap second, this may exceed 999\n    ///\n    /// note: this is not the number of milliseconds since January 1, 1970 0:00:00 UTC\n    #[inline]\n    #[must_use]\n    pub fn timestamp_subsec_millis(&self) -> u32 {\n        self.datetime.timestamp_subsec_millis()\n    }\n\n    /// Returns the number of microseconds since the last second boundary\n    ///\n    /// warning: in event of a leap second, this may exceed 999_999\n    ///\n    /// note: this is not the number of microseconds since January 1, 1970 0:00:00 UTC\n    #[inline]\n    #[must_use]\n    pub fn timestamp_subsec_micros(&self) -> u32 {\n        self.datetime.timestamp_subsec_micros()\n    }\n\n    /// Returns the number of nanoseconds since the last second boundary\n    ///\n    /// warning: in event of a leap second, this may exceed 999_999_999\n    ///\n    /// note: this is not the number of nanoseconds since January 1, 1970 0:00:00 UTC\n    #[inline]\n    #[must_use]\n    pub fn timestamp_subsec_nanos(&self) -> u32 {\n        self.datetime.timestamp_subsec_nanos()\n    }\n\n    /// Retrieves an associated offset from UTC.\n    #[inline]\n    #[must_use]\n    pub fn offset(&self) -> &Tz::Offset {\n        &self.offset\n    }\n\n    /// Retrieves an associated time zone.\n    #[inline]\n    #[must_use]\n    pub fn timezone(&self) -> Tz {\n        TimeZone::from_offset(&self.offset)\n    }\n\n    /// Changes the associated time zone.\n    /// The returned `DateTime` references the same instant of time from the perspective of the provided time zone.\n    #[inline]\n    #[must_use]\n    pub fn with_timezone<Tz2: TimeZone>(&self, tz: &Tz2) -> DateTime<Tz2> {\n        tz.from_utc_datetime(&self.datetime)\n    }\n\n    /// Fix the offset from UTC to its current value, dropping the associated timezone information.\n    /// This it useful for converting a generic `DateTime<Tz: Timezone>` to `DateTime<FixedOffset>`.\n    #[inline]\n    #[must_use]\n    pub fn fixed_offset(&self) -> DateTime<FixedOffset> {\n        self.with_timezone(&self.offset().fix())\n    }\n\n    /// Adds given `Duration` to the current date and time.\n    ///\n    /// Returns `None` when it will result in overflow.\n    #[inline]\n    #[must_use]\n    pub fn checked_add_signed(self, rhs: OldDuration) -> Option<DateTime<Tz>> {\n        let datetime = self.datetime.checked_add_signed(rhs)?;\n        let tz = self.timezone();\n        Some(tz.from_utc_datetime(&datetime))\n    }\n\n    /// Adds given `Months` to the current date and time.\n    ///\n    /// Returns `None` when it will result in overflow, or if the\n    /// local time is not valid on the newly calculated date.\n    ///\n    /// See [`NaiveDate::checked_add_months`] for more details on behavior\n    #[must_use]\n    pub fn checked_add_months(self, rhs: Months) -> Option<DateTime<Tz>> {\n        self.naive_local()\n            .checked_add_months(rhs)?\n            .and_local_timezone(Tz::from_offset(&self.offset))\n            .single()\n    }\n\n    /// Subtracts given `Duration` from the current date and time.\n    ///\n    /// Returns `None` when it will result in overflow.\n    #[inline]\n    #[must_use]\n    pub fn checked_sub_signed(self, rhs: OldDuration) -> Option<DateTime<Tz>> {\n        let datetime = self.datetime.checked_sub_signed(rhs)?;\n        let tz = self.timezone();\n        Some(tz.from_utc_datetime(&datetime))\n    }\n\n    /// Subtracts given `Months` from the current date and time.\n    ///\n    /// Returns `None` when it will result in overflow, or if the\n    /// local time is not valid on the newly calculated date.\n    ///\n    /// See [`NaiveDate::checked_sub_months`] for more details on behavior\n    #[must_use]\n    pub fn checked_sub_months(self, rhs: Months) -> Option<DateTime<Tz>> {\n        self.naive_local()\n            .checked_sub_months(rhs)?\n            .and_local_timezone(Tz::from_offset(&self.offset))\n            .single()\n    }\n\n    /// Add a duration in [`Days`] to the date part of the `DateTime`\n    ///\n    /// Returns `None` if the resulting date would be out of range.\n    #[must_use]\n    pub fn checked_add_days(self, days: Days) -> Option<Self> {\n        self.naive_local()\n            .checked_add_days(days)?\n            .and_local_timezone(TimeZone::from_offset(&self.offset))\n            .single()\n    }\n\n    /// Subtract a duration in [`Days`] from the date part of the `DateTime`\n    ///\n    /// Returns `None` if the resulting date would be out of range.\n    #[must_use]\n    pub fn checked_sub_days(self, days: Days) -> Option<Self> {\n        self.naive_local()\n            .checked_sub_days(days)?\n            .and_local_timezone(TimeZone::from_offset(&self.offset))\n            .single()\n    }\n\n    /// Subtracts another `DateTime` from the current date and time.\n    /// This does not overflow or underflow at all.\n    #[inline]\n    #[must_use]\n    pub fn signed_duration_since<Tz2: TimeZone>(self, rhs: DateTime<Tz2>) -> OldDuration {\n        self.datetime.signed_duration_since(rhs.datetime)\n    }\n\n    /// Returns a view to the naive UTC datetime.\n    #[inline]\n    #[must_use]\n    pub fn naive_utc(&self) -> NaiveDateTime {\n        self.datetime\n    }\n\n    /// Returns a view to the naive local datetime.\n    #[inline]\n    #[must_use]\n    pub fn naive_local(&self) -> NaiveDateTime {\n        self.datetime + self.offset.fix()\n    }\n\n    /// Retrieve the elapsed years from now to the given [`DateTime`].\n    #[must_use]\n    pub fn years_since(&self, base: Self) -> Option<u32> {\n        let mut years = self.year() - base.year();\n        let earlier_time =\n            (self.month(), self.day(), self.time()) < (base.month(), base.day(), base.time());\n\n        years -= match earlier_time {\n            true => 1,\n            false => 0,\n        };\n\n        match years >= 0 {\n            true => Some(years as u32),\n            false => None,\n        }\n    }\n\n    /// The minimum possible `DateTime<Utc>`.\n    pub const MIN_UTC: DateTime<Utc> = DateTime { datetime: NaiveDateTime::MIN, offset: Utc };\n    /// The maximum possible `DateTime<Utc>`.\n    pub const MAX_UTC: DateTime<Utc> = DateTime { datetime: NaiveDateTime::MAX, offset: Utc };\n}","impl<Tz: TimeZone> Datelike for DateTime<Tz> {\n    #[inline]\n    fn year(&self) -> i32 {\n        self.naive_local().year()\n    }\n    #[inline]\n    fn month(&self) -> u32 {\n        self.naive_local().month()\n    }\n    #[inline]\n    fn month0(&self) -> u32 {\n        self.naive_local().month0()\n    }\n    #[inline]\n    fn day(&self) -> u32 {\n        self.naive_local().day()\n    }\n    #[inline]\n    fn day0(&self) -> u32 {\n        self.naive_local().day0()\n    }\n    #[inline]\n    fn ordinal(&self) -> u32 {\n        self.naive_local().ordinal()\n    }\n    #[inline]\n    fn ordinal0(&self) -> u32 {\n        self.naive_local().ordinal0()\n    }\n    #[inline]\n    fn weekday(&self) -> Weekday {\n        self.naive_local().weekday()\n    }\n    #[inline]\n    fn iso_week(&self) -> IsoWeek {\n        self.naive_local().iso_week()\n    }\n\n    #[inline]\n    fn with_year(&self, year: i32) -> Option<DateTime<Tz>> {\n        map_local(self, |datetime| datetime.with_year(year))\n    }\n\n    #[inline]\n    fn with_month(&self, month: u32) -> Option<DateTime<Tz>> {\n        map_local(self, |datetime| datetime.with_month(month))\n    }\n\n    #[inline]\n    fn with_month0(&self, month0: u32) -> Option<DateTime<Tz>> {\n        map_local(self, |datetime| datetime.with_month0(month0))\n    }\n\n    #[inline]\n    fn with_day(&self, day: u32) -> Option<DateTime<Tz>> {\n        map_local(self, |datetime| datetime.with_day(day))\n    }\n\n    #[inline]\n    fn with_day0(&self, day0: u32) -> Option<DateTime<Tz>> {\n        map_local(self, |datetime| datetime.with_day0(day0))\n    }\n\n    #[inline]\n    fn with_ordinal(&self, ordinal: u32) -> Option<DateTime<Tz>> {\n        map_local(self, |datetime| datetime.with_ordinal(ordinal))\n    }\n\n    #[inline]\n    fn with_ordinal0(&self, ordinal0: u32) -> Option<DateTime<Tz>> {\n        map_local(self, |datetime| datetime.with_ordinal0(ordinal0))\n    }\n}","impl<Tz: TimeZone> DurationRound for DateTime<Tz> {\n    type Err = RoundingError;\n\n    fn duration_round(self, duration: Duration) -> Result<Self, Self::Err> {\n        duration_round(self.naive_local(), self, duration)\n    }\n\n    fn duration_trunc(self, duration: Duration) -> Result<Self, Self::Err> {\n        duration_trunc(self.naive_local(), self, duration)\n    }\n}","impl<Tz: TimeZone> Eq for DateTime<Tz> {}","impl<Tz: TimeZone> Ord for DateTime<Tz> {\n    fn cmp(&self, other: &DateTime<Tz>) -> Ordering {\n        self.datetime.cmp(&other.datetime)\n    }\n}","impl<Tz: TimeZone> Sub<DateTime<Tz>> for DateTime<Tz> {\n    type Output = OldDuration;\n\n    #[inline]\n    fn sub(self, rhs: DateTime<Tz>) -> OldDuration {\n        self.signed_duration_since(rhs)\n    }\n}","impl<Tz: TimeZone> Sub<Days> for DateTime<Tz> {\n    type Output = DateTime<Tz>;\n\n    fn sub(self, days: Days) -> Self::Output {\n        self.checked_sub_days(days).unwrap()\n    }\n}","impl<Tz: TimeZone> Sub<FixedOffset> for DateTime<Tz> {\n    type Output = DateTime<Tz>;\n\n    #[inline]\n    fn sub(self, rhs: FixedOffset) -> DateTime<Tz> {\n        add_with_leapsecond(&self, -rhs.local_minus_utc)\n    }\n}","impl<Tz: TimeZone> Sub<Months> for DateTime<Tz> {\n    type Output = DateTime<Tz>;\n\n    fn sub(self, rhs: Months) -> Self::Output {\n        self.checked_sub_months(rhs).unwrap()\n    }\n}","impl<Tz: TimeZone> Sub<OldDuration> for DateTime<Tz> {\n    type Output = DateTime<Tz>;\n\n    #[inline]\n    fn sub(self, rhs: OldDuration) -> DateTime<Tz> {\n        self.checked_sub_signed(rhs).expect(\"`DateTime - Duration` overflowed\")\n    }\n}","impl<Tz: TimeZone> SubAssign<OldDuration> for DateTime<Tz> {\n    #[inline]\n    fn sub_assign(&mut self, rhs: OldDuration) {\n        let datetime =\n            self.datetime.checked_sub_signed(rhs).expect(\"`DateTime - Duration` overflowed\");\n        let tz = self.timezone();\n        *self = tz.from_utc_datetime(&datetime)\n    }\n}","impl<Tz: TimeZone> Timelike for DateTime<Tz> {\n    #[inline]\n    fn hour(&self) -> u32 {\n        self.naive_local().hour()\n    }\n    #[inline]\n    fn minute(&self) -> u32 {\n        self.naive_local().minute()\n    }\n    #[inline]\n    fn second(&self) -> u32 {\n        self.naive_local().second()\n    }\n    #[inline]\n    fn nanosecond(&self) -> u32 {\n        self.naive_local().nanosecond()\n    }\n\n    #[inline]\n    fn with_hour(&self, hour: u32) -> Option<DateTime<Tz>> {\n        map_local(self, |datetime| datetime.with_hour(hour))\n    }\n\n    #[inline]\n    fn with_minute(&self, min: u32) -> Option<DateTime<Tz>> {\n        map_local(self, |datetime| datetime.with_minute(min))\n    }\n\n    #[inline]\n    fn with_second(&self, sec: u32) -> Option<DateTime<Tz>> {\n        map_local(self, |datetime| datetime.with_second(sec))\n    }\n\n    #[inline]\n    fn with_nanosecond(&self, nano: u32) -> Option<DateTime<Tz>> {\n        map_local(self, |datetime| datetime.with_nanosecond(nano))\n    }\n}","impl<Tz: TimeZone> fmt::Debug for DateTime<Tz> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.naive_local().fmt(f)?;\n        self.offset.fmt(f)\n    }\n}","impl<Tz: TimeZone> fmt::Display for DateTime<Tz>\nwhere\n    Tz::Offset: fmt::Display,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.naive_local().fmt(f)?;\n        f.write_char(' ')?;\n        self.offset.fmt(f)\n    }\n}","impl<Tz: TimeZone> hash::Hash for DateTime<Tz> {\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        self.datetime.hash(state)\n    }\n}","unsafe impl<Tz: TimeZone> Send for DateTime<Tz> where <Tz as TimeZone>::Offset: Send {}"],"datetime::SecondsFormat":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"format::Colons":["Clone","Debug","Eq","Hash","PartialEq"],"format::DelayedFormat":["Debug","impl<'a, I: Iterator<Item = B> + Clone, B: Borrow<Item<'a>>> DelayedFormat<I> {\n    /// Makes a new `DelayedFormat` value out of local date and time.\n    #[must_use]\n    pub fn new(date: Option<NaiveDate>, time: Option<NaiveTime>, items: I) -> DelayedFormat<I> {\n        DelayedFormat {\n            date,\n            time,\n            off: None,\n            items,\n            #[cfg(feature = \"unstable-locales\")]\n            locale: None,\n        }\n    }\n\n    /// Makes a new `DelayedFormat` value out of local date and time and UTC offset.\n    #[must_use]\n    pub fn new_with_offset<Off>(\n        date: Option<NaiveDate>,\n        time: Option<NaiveTime>,\n        offset: &Off,\n        items: I,\n    ) -> DelayedFormat<I>\n    where\n        Off: Offset + fmt::Display,\n    {\n        let name_and_diff = (offset.to_string(), offset.fix());\n        DelayedFormat {\n            date,\n            time,\n            off: Some(name_and_diff),\n            items,\n            #[cfg(feature = \"unstable-locales\")]\n            locale: None,\n        }\n    }\n\n    /// Makes a new `DelayedFormat` value out of local date and time and locale.\n    #[cfg(feature = \"unstable-locales\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"unstable-locales\")))]\n    #[must_use]\n    pub fn new_with_locale(\n        date: Option<NaiveDate>,\n        time: Option<NaiveTime>,\n        items: I,\n        locale: Locale,\n    ) -> DelayedFormat<I> {\n        DelayedFormat { date, time, off: None, items, locale: Some(locale) }\n    }\n\n    /// Makes a new `DelayedFormat` value out of local date and time, UTC offset and locale.\n    #[cfg(feature = \"unstable-locales\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"unstable-locales\")))]\n    #[must_use]\n    pub fn new_with_offset_and_locale<Off>(\n        date: Option<NaiveDate>,\n        time: Option<NaiveTime>,\n        offset: &Off,\n        items: I,\n        locale: Locale,\n    ) -> DelayedFormat<I>\n    where\n        Off: Offset + fmt::Display,\n    {\n        let name_and_diff = (offset.to_string(), offset.fix());\n        DelayedFormat { date, time, off: Some(name_and_diff), items, locale: Some(locale) }\n    }\n}","impl<'a, I: Iterator<Item = B> + Clone, B: Borrow<Item<'a>>> fmt::Display for DelayedFormat<I> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        #[cfg(feature = \"unstable-locales\")]\n        {\n            if let Some(locale) = self.locale {\n                return format_localized(\n                    f,\n                    self.date.as_ref(),\n                    self.time.as_ref(),\n                    self.off.as_ref(),\n                    self.items.clone(),\n                    locale,\n                );\n            }\n        }\n\n        format(f, self.date.as_ref(), self.time.as_ref(), self.off.as_ref(), self.items.clone())\n    }\n}"],"format::Fixed":["Clone","Debug","Eq","Hash","PartialEq"],"format::InternalFixed":["Clone","Debug","Eq","Hash","PartialEq"],"format::InternalInternal":["Clone","Debug","Eq","Hash","PartialEq"],"format::InternalNumeric":["Clone","Eq","Hash","PartialEq","impl fmt::Debug for InternalNumeric {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"<InternalNumeric>\")\n    }\n}"],"format::Item":["Clone","Debug","Eq","Hash","PartialEq"],"format::Locale":["Debug"],"format::Locales":["impl Locales {\n    fn new(_locale: Option<Locale>) -> Self {\n        #[cfg(feature = \"unstable-locales\")]\n        {\n            let locale = _locale.unwrap_or(Locale::POSIX);\n            Self {\n                short_months: locales::short_months(locale),\n                long_months: locales::long_months(locale),\n                short_weekdays: locales::short_weekdays(locale),\n                long_weekdays: locales::long_weekdays(locale),\n                am_pm: locales::am_pm(locale),\n            }\n        }\n        #[cfg(not(feature = \"unstable-locales\"))]\n        Self {\n            short_months: &[\n                \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n            ],\n            long_months: &[\n                \"January\",\n                \"February\",\n                \"March\",\n                \"April\",\n                \"May\",\n                \"June\",\n                \"July\",\n                \"August\",\n                \"September\",\n                \"October\",\n                \"November\",\n                \"December\",\n            ],\n            short_weekdays: &[\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n            long_weekdays: &[\n                \"Sunday\",\n                \"Monday\",\n                \"Tuesday\",\n                \"Wednesday\",\n                \"Thursday\",\n                \"Friday\",\n                \"Saturday\",\n            ],\n            am_pm: &[\"AM\", \"PM\"],\n        }\n    }\n}"],"format::Numeric":["Clone","Debug","Eq","Hash","PartialEq"],"format::Pad":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"format::ParseError":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl Error for ParseError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"parser error, see to_string() for details\"\n    }\n}","impl ParseError {\n    /// The category of parse error\n    pub const fn kind(&self) -> ParseErrorKind {\n        self.0\n    }\n}","impl fmt::Display for ParseError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self.0 {\n            ParseErrorKind::OutOfRange => write!(f, \"input is out of range\"),\n            ParseErrorKind::Impossible => write!(f, \"no possible date and time matching input\"),\n            ParseErrorKind::NotEnough => write!(f, \"input is not enough for unique date and time\"),\n            ParseErrorKind::Invalid => write!(f, \"input contains invalid characters\"),\n            ParseErrorKind::TooShort => write!(f, \"premature end of input\"),\n            ParseErrorKind::TooLong => write!(f, \"trailing input\"),\n            ParseErrorKind::BadFormat => write!(f, \"bad or unsupported format string\"),\n            _ => unreachable!(),\n        }\n    }\n}"],"format::ParseErrorKind":["Clone","Copy","Debug","Eq","Hash","PartialEq"],"format::Void":["Clone","Eq","Hash","PartialEq"],"format::parsed::Parsed":["Clone","Debug","Default","Eq","Hash","PartialEq","impl Parsed {\n    /// Returns the initial value of parsed parts.\n    #[must_use]\n    pub fn new() -> Parsed {\n        Parsed::default()\n    }\n\n    /// Tries to set the [`year`](#structfield.year) field from given value.\n    #[inline]\n    pub fn set_year(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.year, i32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`year_div_100`](#structfield.year_div_100) field from given value.\n    #[inline]\n    pub fn set_year_div_100(&mut self, value: i64) -> ParseResult<()> {\n        if value < 0 {\n            return Err(OUT_OF_RANGE);\n        }\n        set_if_consistent(&mut self.year_div_100, i32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`year_mod_100`](#structfield.year_mod_100) field from given value.\n    #[inline]\n    pub fn set_year_mod_100(&mut self, value: i64) -> ParseResult<()> {\n        if value < 0 {\n            return Err(OUT_OF_RANGE);\n        }\n        set_if_consistent(&mut self.year_mod_100, i32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`isoyear`](#structfield.isoyear) field from given value.\n    #[inline]\n    pub fn set_isoyear(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.isoyear, i32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`isoyear_div_100`](#structfield.isoyear_div_100) field from given value.\n    #[inline]\n    pub fn set_isoyear_div_100(&mut self, value: i64) -> ParseResult<()> {\n        if value < 0 {\n            return Err(OUT_OF_RANGE);\n        }\n        set_if_consistent(\n            &mut self.isoyear_div_100,\n            i32::try_from(value).map_err(|_| OUT_OF_RANGE)?,\n        )\n    }\n\n    /// Tries to set the [`isoyear_mod_100`](#structfield.isoyear_mod_100) field from given value.\n    #[inline]\n    pub fn set_isoyear_mod_100(&mut self, value: i64) -> ParseResult<()> {\n        if value < 0 {\n            return Err(OUT_OF_RANGE);\n        }\n        set_if_consistent(\n            &mut self.isoyear_mod_100,\n            i32::try_from(value).map_err(|_| OUT_OF_RANGE)?,\n        )\n    }\n\n    /// Tries to set the [`month`](#structfield.month) field from given value.\n    #[inline]\n    pub fn set_month(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.month, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`week_from_sun`](#structfield.week_from_sun) field from given value.\n    #[inline]\n    pub fn set_week_from_sun(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.week_from_sun, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`week_from_mon`](#structfield.week_from_mon) field from given value.\n    #[inline]\n    pub fn set_week_from_mon(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.week_from_mon, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`isoweek`](#structfield.isoweek) field from given value.\n    #[inline]\n    pub fn set_isoweek(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.isoweek, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`weekday`](#structfield.weekday) field from given value.\n    #[inline]\n    pub fn set_weekday(&mut self, value: Weekday) -> ParseResult<()> {\n        set_if_consistent(&mut self.weekday, value)\n    }\n\n    /// Tries to set the [`ordinal`](#structfield.ordinal) field from given value.\n    #[inline]\n    pub fn set_ordinal(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.ordinal, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`day`](#structfield.day) field from given value.\n    #[inline]\n    pub fn set_day(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.day, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`hour_div_12`](#structfield.hour_div_12) field from given value.\n    /// (`false` for AM, `true` for PM)\n    #[inline]\n    pub fn set_ampm(&mut self, value: bool) -> ParseResult<()> {\n        set_if_consistent(&mut self.hour_div_12, u32::from(value))\n    }\n\n    /// Tries to set the [`hour_mod_12`](#structfield.hour_mod_12) field from\n    /// given hour number in 12-hour clocks.\n    #[inline]\n    pub fn set_hour12(&mut self, value: i64) -> ParseResult<()> {\n        if !(1..=12).contains(&value) {\n            return Err(OUT_OF_RANGE);\n        }\n        set_if_consistent(&mut self.hour_mod_12, value as u32 % 12)\n    }\n\n    /// Tries to set both [`hour_div_12`](#structfield.hour_div_12) and\n    /// [`hour_mod_12`](#structfield.hour_mod_12) fields from given value.\n    #[inline]\n    pub fn set_hour(&mut self, value: i64) -> ParseResult<()> {\n        let v = u32::try_from(value).map_err(|_| OUT_OF_RANGE)?;\n        set_if_consistent(&mut self.hour_div_12, v / 12)?;\n        set_if_consistent(&mut self.hour_mod_12, v % 12)?;\n        Ok(())\n    }\n\n    /// Tries to set the [`minute`](#structfield.minute) field from given value.\n    #[inline]\n    pub fn set_minute(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.minute, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`second`](#structfield.second) field from given value.\n    #[inline]\n    pub fn set_second(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.second, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`nanosecond`](#structfield.nanosecond) field from given value.\n    #[inline]\n    pub fn set_nanosecond(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.nanosecond, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Tries to set the [`timestamp`](#structfield.timestamp) field from given value.\n    #[inline]\n    pub fn set_timestamp(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.timestamp, value)\n    }\n\n    /// Tries to set the [`offset`](#structfield.offset) field from given value.\n    #[inline]\n    pub fn set_offset(&mut self, value: i64) -> ParseResult<()> {\n        set_if_consistent(&mut self.offset, i32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }\n\n    /// Returns a parsed naive date out of given fields.\n    ///\n    /// This method is able to determine the date from given subset of fields:\n    ///\n    /// - Year, month, day.\n    /// - Year, day of the year (ordinal).\n    /// - Year, week number counted from Sunday or Monday, day of the week.\n    /// - ISO week date.\n    ///\n    /// Gregorian year and ISO week date year can have their century number (`*_div_100`) omitted,\n    /// the two-digit year is used to guess the century number then.\n    pub fn to_naive_date(&self) -> ParseResult<NaiveDate> {\n        fn resolve_year(\n            y: Option<i32>,\n            q: Option<i32>,\n            r: Option<i32>,\n        ) -> ParseResult<Option<i32>> {\n            match (y, q, r) {\n                // if there is no further information, simply return the given full year.\n                // this is a common case, so let's avoid division here.\n                (y, None, None) => Ok(y),\n\n                // if there is a full year *and* also quotient and/or modulo,\n                // check if present quotient and/or modulo is consistent to the full year.\n                // since the presence of those fields means a positive full year,\n                // we should filter a negative full year first.\n                (Some(y), q, r @ Some(0..=99)) | (Some(y), q, r @ None) => {\n                    if y < 0 {\n                        return Err(OUT_OF_RANGE);\n                    }\n                    let q_ = y / 100;\n                    let r_ = y % 100;\n                    if q.unwrap_or(q_) == q_ && r.unwrap_or(r_) == r_ {\n                        Ok(Some(y))\n                    } else {\n                        Err(IMPOSSIBLE)\n                    }\n                }\n\n                // the full year is missing but we have quotient and modulo.\n                // reconstruct the full year. make sure that the result is always positive.\n                (None, Some(q), Some(r @ 0..=99)) => {\n                    if q < 0 {\n                        return Err(OUT_OF_RANGE);\n                    }\n                    let y = q.checked_mul(100).and_then(|v| v.checked_add(r));\n                    Ok(Some(y.ok_or(OUT_OF_RANGE)?))\n                }\n\n                // we only have modulo. try to interpret a modulo as a conventional two-digit year.\n                // note: we are affected by Rust issue #18060. avoid multiple range patterns.\n                (None, None, Some(r @ 0..=99)) => Ok(Some(r + if r < 70 { 2000 } else { 1900 })),\n\n                // otherwise it is an out-of-bound or insufficient condition.\n                (None, Some(_), None) => Err(NOT_ENOUGH),\n                (_, _, Some(_)) => Err(OUT_OF_RANGE),\n            }\n        }\n\n        let given_year = resolve_year(self.year, self.year_div_100, self.year_mod_100)?;\n        let given_isoyear = resolve_year(self.isoyear, self.isoyear_div_100, self.isoyear_mod_100)?;\n\n        // verify the normal year-month-day date.\n        let verify_ymd = |date: NaiveDate| {\n            let year = date.year();\n            let (year_div_100, year_mod_100) = if year >= 0 {\n                (Some(year / 100), Some(year % 100))\n            } else {\n                (None, None) // they should be empty to be consistent\n            };\n            let month = date.month();\n            let day = date.day();\n            self.year.unwrap_or(year) == year\n                && self.year_div_100.or(year_div_100) == year_div_100\n                && self.year_mod_100.or(year_mod_100) == year_mod_100\n                && self.month.unwrap_or(month) == month\n                && self.day.unwrap_or(day) == day\n        };\n\n        // verify the ISO week date.\n        let verify_isoweekdate = |date: NaiveDate| {\n            let week = date.iso_week();\n            let isoyear = week.year();\n            let isoweek = week.week();\n            let weekday = date.weekday();\n            let (isoyear_div_100, isoyear_mod_100) = if isoyear >= 0 {\n                (Some(isoyear / 100), Some(isoyear % 100))\n            } else {\n                (None, None) // they should be empty to be consistent\n            };\n            self.isoyear.unwrap_or(isoyear) == isoyear\n                && self.isoyear_div_100.or(isoyear_div_100) == isoyear_div_100\n                && self.isoyear_mod_100.or(isoyear_mod_100) == isoyear_mod_100\n                && self.isoweek.unwrap_or(isoweek) == isoweek\n                && self.weekday.unwrap_or(weekday) == weekday\n        };\n\n        // verify the ordinal and other (non-ISO) week dates.\n        let verify_ordinal = |date: NaiveDate| {\n            let ordinal = date.ordinal();\n            let week_from_sun = date.weeks_from(Weekday::Sun);\n            let week_from_mon = date.weeks_from(Weekday::Mon);\n            self.ordinal.unwrap_or(ordinal) == ordinal\n                && self.week_from_sun.map_or(week_from_sun, |v| v as i32) == week_from_sun\n                && self.week_from_mon.map_or(week_from_mon, |v| v as i32) == week_from_mon\n        };\n\n        // test several possibilities.\n        // tries to construct a full `NaiveDate` as much as possible, then verifies that\n        // it is consistent with other given fields.\n        let (verified, parsed_date) = match (given_year, given_isoyear, self) {\n            (Some(year), _, &Parsed { month: Some(month), day: Some(day), .. }) => {\n                // year, month, day\n                let date = NaiveDate::from_ymd_opt(year, month, day).ok_or(OUT_OF_RANGE)?;\n                (verify_isoweekdate(date) && verify_ordinal(date), date)\n            }\n\n            (Some(year), _, &Parsed { ordinal: Some(ordinal), .. }) => {\n                // year, day of the year\n                let date = NaiveDate::from_yo_opt(year, ordinal).ok_or(OUT_OF_RANGE)?;\n                (verify_ymd(date) && verify_isoweekdate(date) && verify_ordinal(date), date)\n            }\n\n            (\n                Some(year),\n                _,\n                &Parsed { week_from_sun: Some(week_from_sun), weekday: Some(weekday), .. },\n            ) => {\n                // year, week (starting at 1st Sunday), day of the week\n                let newyear = NaiveDate::from_yo_opt(year, 1).ok_or(OUT_OF_RANGE)?;\n                let firstweek = match newyear.weekday() {\n                    Weekday::Sun => 0,\n                    Weekday::Mon => 6,\n                    Weekday::Tue => 5,\n                    Weekday::Wed => 4,\n                    Weekday::Thu => 3,\n                    Weekday::Fri => 2,\n                    Weekday::Sat => 1,\n                };\n\n                // `firstweek+1`-th day of January is the beginning of the week 1.\n                if week_from_sun > 53 {\n                    return Err(OUT_OF_RANGE);\n                } // can it overflow?\n                let ndays = firstweek\n                    + (week_from_sun as i32 - 1) * 7\n                    + weekday.num_days_from_sunday() as i32;\n                let date = newyear\n                    .checked_add_signed(OldDuration::days(i64::from(ndays)))\n                    .ok_or(OUT_OF_RANGE)?;\n                if date.year() != year {\n                    return Err(OUT_OF_RANGE);\n                } // early exit for correct error\n\n                (verify_ymd(date) && verify_isoweekdate(date) && verify_ordinal(date), date)\n            }\n\n            (\n                Some(year),\n                _,\n                &Parsed { week_from_mon: Some(week_from_mon), weekday: Some(weekday), .. },\n            ) => {\n                // year, week (starting at 1st Monday), day of the week\n                let newyear = NaiveDate::from_yo_opt(year, 1).ok_or(OUT_OF_RANGE)?;\n                let firstweek = match newyear.weekday() {\n                    Weekday::Sun => 1,\n                    Weekday::Mon => 0,\n                    Weekday::Tue => 6,\n                    Weekday::Wed => 5,\n                    Weekday::Thu => 4,\n                    Weekday::Fri => 3,\n                    Weekday::Sat => 2,\n                };\n\n                // `firstweek+1`-th day of January is the beginning of the week 1.\n                if week_from_mon > 53 {\n                    return Err(OUT_OF_RANGE);\n                } // can it overflow?\n                let ndays = firstweek\n                    + (week_from_mon as i32 - 1) * 7\n                    + weekday.num_days_from_monday() as i32;\n                let date = newyear\n                    .checked_add_signed(OldDuration::days(i64::from(ndays)))\n                    .ok_or(OUT_OF_RANGE)?;\n                if date.year() != year {\n                    return Err(OUT_OF_RANGE);\n                } // early exit for correct error\n\n                (verify_ymd(date) && verify_isoweekdate(date) && verify_ordinal(date), date)\n            }\n\n            (_, Some(isoyear), &Parsed { isoweek: Some(isoweek), weekday: Some(weekday), .. }) => {\n                // ISO year, week, day of the week\n                let date = NaiveDate::from_isoywd_opt(isoyear, isoweek, weekday);\n                let date = date.ok_or(OUT_OF_RANGE)?;\n                (verify_ymd(date) && verify_ordinal(date), date)\n            }\n\n            (_, _, _) => return Err(NOT_ENOUGH),\n        };\n\n        if verified {\n            Ok(parsed_date)\n        } else {\n            Err(IMPOSSIBLE)\n        }\n    }\n\n    /// Returns a parsed naive time out of given fields.\n    ///\n    /// This method is able to determine the time from given subset of fields:\n    ///\n    /// - Hour, minute. (second and nanosecond assumed to be 0)\n    /// - Hour, minute, second. (nanosecond assumed to be 0)\n    /// - Hour, minute, second, nanosecond.\n    ///\n    /// It is able to handle leap seconds when given second is 60.\n    pub fn to_naive_time(&self) -> ParseResult<NaiveTime> {\n        let hour_div_12 = match self.hour_div_12 {\n            Some(v @ 0..=1) => v,\n            Some(_) => return Err(OUT_OF_RANGE),\n            None => return Err(NOT_ENOUGH),\n        };\n        let hour_mod_12 = match self.hour_mod_12 {\n            Some(v @ 0..=11) => v,\n            Some(_) => return Err(OUT_OF_RANGE),\n            None => return Err(NOT_ENOUGH),\n        };\n        let hour = hour_div_12 * 12 + hour_mod_12;\n\n        let minute = match self.minute {\n            Some(v @ 0..=59) => v,\n            Some(_) => return Err(OUT_OF_RANGE),\n            None => return Err(NOT_ENOUGH),\n        };\n\n        // we allow omitting seconds or nanoseconds, but they should be in the range.\n        let (second, mut nano) = match self.second.unwrap_or(0) {\n            v @ 0..=59 => (v, 0),\n            60 => (59, 1_000_000_000),\n            _ => return Err(OUT_OF_RANGE),\n        };\n        nano += match self.nanosecond {\n            Some(v @ 0..=999_999_999) if self.second.is_some() => v,\n            Some(0..=999_999_999) => return Err(NOT_ENOUGH), // second is missing\n            Some(_) => return Err(OUT_OF_RANGE),\n            None => 0,\n        };\n\n        NaiveTime::from_hms_nano_opt(hour, minute, second, nano).ok_or(OUT_OF_RANGE)\n    }\n\n    /// Returns a parsed naive date and time out of given fields,\n    /// except for the [`offset`](#structfield.offset) field (assumed to have a given value).\n    /// This is required for parsing a local time or other known-timezone inputs.\n    ///\n    /// This method is able to determine the combined date and time\n    /// from date and time fields or a single [`timestamp`](#structfield.timestamp) field.\n    /// Either way those fields have to be consistent to each other.\n    pub fn to_naive_datetime_with_offset(&self, offset: i32) -> ParseResult<NaiveDateTime> {\n        let date = self.to_naive_date();\n        let time = self.to_naive_time();\n        if let (Ok(date), Ok(time)) = (date, time) {\n            let datetime = date.and_time(time);\n\n            // verify the timestamp field if any\n            // the following is safe, `timestamp` is very limited in range\n            let timestamp = datetime.timestamp() - i64::from(offset);\n            if let Some(given_timestamp) = self.timestamp {\n                // if `datetime` represents a leap second, it might be off by one second.\n                if given_timestamp != timestamp\n                    && !(datetime.nanosecond() >= 1_000_000_000 && given_timestamp == timestamp + 1)\n                {\n                    return Err(IMPOSSIBLE);\n                }\n            }\n\n            Ok(datetime)\n        } else if let Some(timestamp) = self.timestamp {\n            use super::ParseError as PE;\n            use super::ParseErrorKind::{Impossible, OutOfRange};\n\n            // if date and time is problematic already, there is no point proceeding.\n            // we at least try to give a correct error though.\n            match (date, time) {\n                (Err(PE(OutOfRange)), _) | (_, Err(PE(OutOfRange))) => return Err(OUT_OF_RANGE),\n                (Err(PE(Impossible)), _) | (_, Err(PE(Impossible))) => return Err(IMPOSSIBLE),\n                (_, _) => {} // one of them is insufficient\n            }\n\n            // reconstruct date and time fields from timestamp\n            let ts = timestamp.checked_add(i64::from(offset)).ok_or(OUT_OF_RANGE)?;\n            let datetime = NaiveDateTime::from_timestamp_opt(ts, 0);\n            let mut datetime = datetime.ok_or(OUT_OF_RANGE)?;\n\n            // fill year, ordinal, hour, minute and second fields from timestamp.\n            // if existing fields are consistent, this will allow the full date/time reconstruction.\n            let mut parsed = self.clone();\n            if parsed.second == Some(60) {\n                // `datetime.second()` cannot be 60, so this is the only case for a leap second.\n                match datetime.second() {\n                    // it's okay, just do not try to overwrite the existing field.\n                    59 => {}\n                    // `datetime` is known to be off by one second.\n                    0 => {\n                        datetime -= OldDuration::seconds(1);\n                    }\n                    // otherwise it is impossible.\n                    _ => return Err(IMPOSSIBLE),\n                }\n            // ...and we have the correct candidates for other fields.\n            } else {\n                parsed.set_second(i64::from(datetime.second()))?;\n            }\n            parsed.set_year(i64::from(datetime.year()))?;\n            parsed.set_ordinal(i64::from(datetime.ordinal()))?; // more efficient than ymd\n            parsed.set_hour(i64::from(datetime.hour()))?;\n            parsed.set_minute(i64::from(datetime.minute()))?;\n\n            // validate other fields (e.g. week) and return\n            let date = parsed.to_naive_date()?;\n            let time = parsed.to_naive_time()?;\n            Ok(date.and_time(time))\n        } else {\n            // reproduce the previous error(s)\n            date?;\n            time?;\n            unreachable!()\n        }\n    }\n\n    /// Returns a parsed fixed time zone offset out of given fields.\n    pub fn to_fixed_offset(&self) -> ParseResult<FixedOffset> {\n        self.offset.and_then(FixedOffset::east_opt).ok_or(OUT_OF_RANGE)\n    }\n\n    /// Returns a parsed timezone-aware date and time out of given fields.\n    ///\n    /// This method is able to determine the combined date and time\n    /// from date and time fields or a single [`timestamp`](#structfield.timestamp) field,\n    /// plus a time zone offset.\n    /// Either way those fields have to be consistent to each other.\n    pub fn to_datetime(&self) -> ParseResult<DateTime<FixedOffset>> {\n        let offset = self.offset.ok_or(NOT_ENOUGH)?;\n        let datetime = self.to_naive_datetime_with_offset(offset)?;\n        let offset = FixedOffset::east_opt(offset).ok_or(OUT_OF_RANGE)?;\n\n        // this is used to prevent an overflow when calling FixedOffset::from_local_datetime\n        datetime\n            .checked_sub_signed(OldDuration::seconds(i64::from(offset.local_minus_utc())))\n            .ok_or(OUT_OF_RANGE)?;\n\n        match offset.from_local_datetime(&datetime) {\n            LocalResult::None => Err(IMPOSSIBLE),\n            LocalResult::Single(t) => Ok(t),\n            LocalResult::Ambiguous(..) => Err(NOT_ENOUGH),\n        }\n    }\n\n    /// Returns a parsed timezone-aware date and time out of given fields,\n    /// with an additional `TimeZone` used to interpret and validate the local date.\n    ///\n    /// This method is able to determine the combined date and time\n    /// from date and time fields or a single [`timestamp`](#structfield.timestamp) field,\n    /// plus a time zone offset.\n    /// Either way those fields have to be consistent to each other.\n    /// If parsed fields include an UTC offset, it also has to be consistent to\n    /// [`offset`](#structfield.offset).\n    pub fn to_datetime_with_timezone<Tz: TimeZone>(&self, tz: &Tz) -> ParseResult<DateTime<Tz>> {\n        // if we have `timestamp` specified, guess an offset from that.\n        let mut guessed_offset = 0;\n        if let Some(timestamp) = self.timestamp {\n            // make a naive `DateTime` from given timestamp and (if any) nanosecond.\n            // an empty `nanosecond` is always equal to zero, so missing nanosecond is fine.\n            let nanosecond = self.nanosecond.unwrap_or(0);\n            let dt = NaiveDateTime::from_timestamp_opt(timestamp, nanosecond);\n            let dt = dt.ok_or(OUT_OF_RANGE)?;\n            guessed_offset = tz.offset_from_utc_datetime(&dt).fix().local_minus_utc();\n        }\n\n        // checks if the given `DateTime` has a consistent `Offset` with given `self.offset`.\n        let check_offset = |dt: &DateTime<Tz>| {\n            if let Some(offset) = self.offset {\n                dt.offset().fix().local_minus_utc() == offset\n            } else {\n                true\n            }\n        };\n\n        // `guessed_offset` should be correct when `self.timestamp` is given.\n        // it will be 0 otherwise, but this is fine as the algorithm ignores offset for that case.\n        let datetime = self.to_naive_datetime_with_offset(guessed_offset)?;\n        match tz.from_local_datetime(&datetime) {\n            LocalResult::None => Err(IMPOSSIBLE),\n            LocalResult::Single(t) => {\n                if check_offset(&t) {\n                    Ok(t)\n                } else {\n                    Err(IMPOSSIBLE)\n                }\n            }\n            LocalResult::Ambiguous(min, max) => {\n                // try to disambiguate two possible local dates by offset.\n                match (check_offset(&min), check_offset(&max)) {\n                    (false, false) => Err(IMPOSSIBLE),\n                    (false, true) => Ok(max),\n                    (true, false) => Ok(min),\n                    (true, true) => Err(NOT_ENOUGH),\n                }\n            }\n        }\n    }\n}"],"format::strftime::StrftimeItems":["Clone","Debug","impl<'a> Iterator for StrftimeItems<'a> {\n    type Item = Item<'a>;\n\n    fn next(&mut self) -> Option<Item<'a>> {\n        // we have some reconstructed items to return\n        if !self.recons.is_empty() {\n            let item;\n            #[cfg(feature = \"unstable-locales\")]\n            {\n                item = self.recons.remove(0);\n            }\n            #[cfg(not(feature = \"unstable-locales\"))]\n            {\n                item = self.recons[0].clone();\n                self.recons = &self.recons[1..];\n            }\n            return Some(item);\n        }\n\n        match self.remainder.chars().next() {\n            // we are done\n            None => None,\n\n            // the next item is a specifier\n            Some('%') => {\n                self.remainder = &self.remainder[1..];\n\n                macro_rules! next {\n                    () => {\n                        match self.remainder.chars().next() {\n                            Some(x) => {\n                                self.remainder = &self.remainder[x.len_utf8()..];\n                                x\n                            }\n                            None => return Some(Item::Error), // premature end of string\n                        }\n                    };\n                }\n\n                let spec = next!();\n                let pad_override = match spec {\n                    '-' => Some(Pad::None),\n                    '0' => Some(Pad::Zero),\n                    '_' => Some(Pad::Space),\n                    _ => None,\n                };\n                let is_alternate = spec == '#';\n                let spec = if pad_override.is_some() || is_alternate { next!() } else { spec };\n                if is_alternate && !HAVE_ALTERNATES.contains(spec) {\n                    return Some(Item::Error);\n                }\n\n                macro_rules! recons {\n                    [$head:expr, $($tail:expr),+ $(,)*] => ({\n                        #[cfg(feature = \"unstable-locales\")]\n                        {\n                            self.recons.clear();\n                            $(self.recons.push($tail);)+\n                        }\n                        #[cfg(not(feature = \"unstable-locales\"))]\n                        {\n                            const RECONS: &'static [Item<'static>] = &[$($tail),+];\n                            self.recons = RECONS;\n                        }\n                        $head\n                    })\n                }\n\n                macro_rules! recons_from_slice {\n                    ($slice:expr) => {{\n                        #[cfg(feature = \"unstable-locales\")]\n                        {\n                            self.recons.clear();\n                            self.recons.extend_from_slice(&$slice[1..]);\n                        }\n                        #[cfg(not(feature = \"unstable-locales\"))]\n                        {\n                            self.recons = &$slice[1..];\n                        }\n                        $slice[0].clone()\n                    }};\n                }\n\n                let item = match spec {\n                    'A' => fix!(LongWeekdayName),\n                    'B' => fix!(LongMonthName),\n                    'C' => num0!(YearDiv100),\n                    'D' => {\n                        recons![num0!(Month), lit!(\"/\"), num0!(Day), lit!(\"/\"), num0!(YearMod100)]\n                    }\n                    'F' => recons![num0!(Year), lit!(\"-\"), num0!(Month), lit!(\"-\"), num0!(Day)],\n                    'G' => num0!(IsoYear),\n                    'H' => num0!(Hour),\n                    'I' => num0!(Hour12),\n                    'M' => num0!(Minute),\n                    'P' => fix!(LowerAmPm),\n                    'R' => recons![num0!(Hour), lit!(\":\"), num0!(Minute)],\n                    'S' => num0!(Second),\n                    'T' => recons![num0!(Hour), lit!(\":\"), num0!(Minute), lit!(\":\"), num0!(Second)],\n                    'U' => num0!(WeekFromSun),\n                    'V' => num0!(IsoWeek),\n                    'W' => num0!(WeekFromMon),\n                    'X' => recons_from_slice!(self.t_fmt),\n                    'Y' => num0!(Year),\n                    'Z' => fix!(TimezoneName),\n                    'a' => fix!(ShortWeekdayName),\n                    'b' | 'h' => fix!(ShortMonthName),\n                    'c' => recons_from_slice!(self.d_t_fmt),\n                    'd' => num0!(Day),\n                    'e' => nums!(Day),\n                    'f' => num0!(Nanosecond),\n                    'g' => num0!(IsoYearMod100),\n                    'j' => num0!(Ordinal),\n                    'k' => nums!(Hour),\n                    'l' => nums!(Hour12),\n                    'm' => num0!(Month),\n                    'n' => sp!(\"\\n\"),\n                    'p' => fix!(UpperAmPm),\n                    'r' => recons![\n                        num0!(Hour12),\n                        lit!(\":\"),\n                        num0!(Minute),\n                        lit!(\":\"),\n                        num0!(Second),\n                        sp!(\" \"),\n                        fix!(UpperAmPm)\n                    ],\n                    's' => num!(Timestamp),\n                    't' => sp!(\"\\t\"),\n                    'u' => num!(WeekdayFromMon),\n                    'v' => {\n                        recons![nums!(Day), lit!(\"-\"), fix!(ShortMonthName), lit!(\"-\"), num0!(Year)]\n                    }\n                    'w' => num!(NumDaysFromSun),\n                    'x' => recons_from_slice!(self.d_fmt),\n                    'y' => num0!(YearMod100),\n                    'z' => {\n                        if is_alternate {\n                            internal_fix!(TimezoneOffsetPermissive)\n                        } else {\n                            fix!(TimezoneOffset)\n                        }\n                    }\n                    '+' => fix!(RFC3339),\n                    ':' => {\n                        if self.remainder.starts_with(\"::z\") {\n                            self.remainder = &self.remainder[3..];\n                            fix!(TimezoneOffsetTripleColon)\n                        } else if self.remainder.starts_with(\":z\") {\n                            self.remainder = &self.remainder[2..];\n                            fix!(TimezoneOffsetDoubleColon)\n                        } else if self.remainder.starts_with('z') {\n                            self.remainder = &self.remainder[1..];\n                            fix!(TimezoneOffsetColon)\n                        } else {\n                            Item::Error\n                        }\n                    }\n                    '.' => match next!() {\n                        '3' => match next!() {\n                            'f' => fix!(Nanosecond3),\n                            _ => Item::Error,\n                        },\n                        '6' => match next!() {\n                            'f' => fix!(Nanosecond6),\n                            _ => Item::Error,\n                        },\n                        '9' => match next!() {\n                            'f' => fix!(Nanosecond9),\n                            _ => Item::Error,\n                        },\n                        'f' => fix!(Nanosecond),\n                        _ => Item::Error,\n                    },\n                    '3' => match next!() {\n                        'f' => internal_fix!(Nanosecond3NoDot),\n                        _ => Item::Error,\n                    },\n                    '6' => match next!() {\n                        'f' => internal_fix!(Nanosecond6NoDot),\n                        _ => Item::Error,\n                    },\n                    '9' => match next!() {\n                        'f' => internal_fix!(Nanosecond9NoDot),\n                        _ => Item::Error,\n                    },\n                    '%' => lit!(\"%\"),\n                    _ => Item::Error, // no such specifier\n                };\n\n                // adjust `item` if we have any padding modifier\n                if let Some(new_pad) = pad_override {\n                    match item {\n                        Item::Numeric(ref kind, _pad) if self.recons.is_empty() => {\n                            Some(Item::Numeric(kind.clone(), new_pad))\n                        }\n                        _ => Some(Item::Error), // no reconstructed or non-numeric item allowed\n                    }\n                } else {\n                    Some(item)\n                }\n            }\n\n            // the next item is space\n            Some(c) if c.is_whitespace() => {\n                // `%` is not a whitespace, so `c != '%'` is redundant\n                let nextspec = self\n                    .remainder\n                    .find(|c: char| !c.is_whitespace())\n                    .unwrap_or(self.remainder.len());\n                assert!(nextspec > 0);\n                let item = sp!(&self.remainder[..nextspec]);\n                self.remainder = &self.remainder[nextspec..];\n                Some(item)\n            }\n\n            // the next item is literal\n            _ => {\n                let nextspec = self\n                    .remainder\n                    .find(|c: char| c.is_whitespace() || c == '%')\n                    .unwrap_or(self.remainder.len());\n                assert!(nextspec > 0);\n                let item = lit!(&self.remainder[..nextspec]);\n                self.remainder = &self.remainder[nextspec..];\n                Some(item)\n            }\n        }\n    }\n}","impl<'a> StrftimeItems<'a> {\n    /// Creates a new parsing iterator from the `strftime`-like format string.\n    #[must_use]\n    pub fn new(s: &'a str) -> StrftimeItems<'a> {\n        Self::with_remainer(s)\n    }\n\n    /// Creates a new parsing iterator from the `strftime`-like format string.\n    #[cfg(feature = \"unstable-locales\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"unstable-locales\")))]\n    #[must_use]\n    pub fn new_with_locale(s: &'a str, locale: Locale) -> StrftimeItems<'a> {\n        let d_fmt = StrftimeItems::new(locales::d_fmt(locale)).collect();\n        let d_t_fmt = StrftimeItems::new(locales::d_t_fmt(locale)).collect();\n        let t_fmt = StrftimeItems::new(locales::t_fmt(locale)).collect();\n\n        StrftimeItems { remainder: s, recons: Vec::new(), d_fmt, d_t_fmt, t_fmt }\n    }\n\n    #[cfg(not(feature = \"unstable-locales\"))]\n    fn with_remainer(s: &'a str) -> StrftimeItems<'a> {\n        static FMT_NONE: &[Item<'static>; 0] = &[];\n\n        StrftimeItems {\n            remainder: s,\n            recons: FMT_NONE,\n            d_fmt: D_FMT,\n            d_t_fmt: D_T_FMT,\n            t_fmt: T_FMT,\n        }\n    }\n\n    #[cfg(feature = \"unstable-locales\")]\n    fn with_remainer(s: &'a str) -> StrftimeItems<'a> {\n        StrftimeItems {\n            remainder: s,\n            recons: Vec::new(),\n            d_fmt: D_FMT.to_vec(),\n            d_t_fmt: D_T_FMT.to_vec(),\n            t_fmt: T_FMT.to_vec(),\n        }\n    }\n}"],"month::Month":["Clone","Copy","Debug","Eq","Hash","PartialEq","PartialOrd","impl FromStr for Month {\n    type Err = ParseMonthError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        if let Ok((\"\", w)) = scan::short_or_long_month0(s) {\n            match w {\n                0 => Ok(Month::January),\n                1 => Ok(Month::February),\n                2 => Ok(Month::March),\n                3 => Ok(Month::April),\n                4 => Ok(Month::May),\n                5 => Ok(Month::June),\n                6 => Ok(Month::July),\n                7 => Ok(Month::August),\n                8 => Ok(Month::September),\n                9 => Ok(Month::October),\n                10 => Ok(Month::November),\n                11 => Ok(Month::December),\n                _ => Err(ParseMonthError { _dummy: () }),\n            }\n        } else {\n            Err(ParseMonthError { _dummy: () })\n        }\n    }\n}","impl Month {\n    /// The next month.\n    ///\n    /// `m`:        | `January`  | `February` | `...` | `December`\n    /// ----------- | ---------  | ---------- | --- | ---------\n    /// `m.succ()`: | `February` | `March`    | `...` | `January`\n    #[inline]\n    #[must_use]\n    pub const fn succ(&self) -> Month {\n        match *self {\n            Month::January => Month::February,\n            Month::February => Month::March,\n            Month::March => Month::April,\n            Month::April => Month::May,\n            Month::May => Month::June,\n            Month::June => Month::July,\n            Month::July => Month::August,\n            Month::August => Month::September,\n            Month::September => Month::October,\n            Month::October => Month::November,\n            Month::November => Month::December,\n            Month::December => Month::January,\n        }\n    }\n\n    /// The previous month.\n    ///\n    /// `m`:        | `January`  | `February` | `...` | `December`\n    /// ----------- | ---------  | ---------- | --- | ---------\n    /// `m.pred()`: | `December` | `January`  | `...` | `November`\n    #[inline]\n    #[must_use]\n    pub const fn pred(&self) -> Month {\n        match *self {\n            Month::January => Month::December,\n            Month::February => Month::January,\n            Month::March => Month::February,\n            Month::April => Month::March,\n            Month::May => Month::April,\n            Month::June => Month::May,\n            Month::July => Month::June,\n            Month::August => Month::July,\n            Month::September => Month::August,\n            Month::October => Month::September,\n            Month::November => Month::October,\n            Month::December => Month::November,\n        }\n    }\n\n    /// Returns a month-of-year number starting from January = 1.\n    ///\n    /// `m`:                     | `January` | `February` | `...` | `December`\n    /// -------------------------| --------- | ---------- | --- | -----\n    /// `m.number_from_month()`: | 1         | 2          | `...` | 12\n    #[inline]\n    #[must_use]\n    pub const fn number_from_month(&self) -> u32 {\n        match *self {\n            Month::January => 1,\n            Month::February => 2,\n            Month::March => 3,\n            Month::April => 4,\n            Month::May => 5,\n            Month::June => 6,\n            Month::July => 7,\n            Month::August => 8,\n            Month::September => 9,\n            Month::October => 10,\n            Month::November => 11,\n            Month::December => 12,\n        }\n    }\n\n    /// Get the name of the month\n    ///\n    /// ```\n    /// use chrono::Month;\n    ///\n    /// assert_eq!(Month::January.name(), \"January\")\n    /// ```\n    #[must_use]\n    pub const fn name(&self) -> &'static str {\n        match *self {\n            Month::January => \"January\",\n            Month::February => \"February\",\n            Month::March => \"March\",\n            Month::April => \"April\",\n            Month::May => \"May\",\n            Month::June => \"June\",\n            Month::July => \"July\",\n            Month::August => \"August\",\n            Month::September => \"September\",\n            Month::October => \"October\",\n            Month::November => \"November\",\n            Month::December => \"December\",\n        }\n    }\n}","impl TryFrom<u8> for Month {\n    type Error = OutOfRange;\n\n    fn try_from(value: u8) -> Result<Self, Self::Error> {\n        match value {\n            1 => Ok(Month::January),\n            2 => Ok(Month::February),\n            3 => Ok(Month::March),\n            4 => Ok(Month::April),\n            5 => Ok(Month::May),\n            6 => Ok(Month::June),\n            7 => Ok(Month::July),\n            8 => Ok(Month::August),\n            9 => Ok(Month::September),\n            10 => Ok(Month::October),\n            11 => Ok(Month::November),\n            12 => Ok(Month::December),\n            _ => Err(OutOfRange::new()),\n        }\n    }\n}","impl num_traits::FromPrimitive for Month {\n    /// Returns an `Option<Month>` from a i64, assuming a 1-index, January = 1.\n    ///\n    /// `Month::from_i64(n: i64)`: | `1`                  | `2`                   | ... | `12`\n    /// ---------------------------| -------------------- | --------------------- | ... | -----\n    /// ``:                        | Some(Month::January) | Some(Month::February) | ... | Some(Month::December)\n\n    #[inline]\n    fn from_u64(n: u64) -> Option<Month> {\n        Self::from_u32(n as u32)\n    }\n\n    #[inline]\n    fn from_i64(n: i64) -> Option<Month> {\n        Self::from_u32(n as u32)\n    }\n\n    #[inline]\n    fn from_u32(n: u32) -> Option<Month> {\n        match n {\n            1 => Some(Month::January),\n            2 => Some(Month::February),\n            3 => Some(Month::March),\n            4 => Some(Month::April),\n            5 => Some(Month::May),\n            6 => Some(Month::June),\n            7 => Some(Month::July),\n            8 => Some(Month::August),\n            9 => Some(Month::September),\n            10 => Some(Month::October),\n            11 => Some(Month::November),\n            12 => Some(Month::December),\n            _ => None,\n        }\n    }\n}"],"month::Months":["Clone","Copy","Debug","Eq","Hash","PartialEq","PartialOrd","impl Months {\n    /// Construct a new `Months` from a number of months\n    pub const fn new(num: u32) -> Self {\n        Self(num)\n    }\n}"],"month::ParseMonthError":["Clone","Eq","PartialEq","impl fmt::Debug for ParseMonthError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"ParseMonthError {{ .. }}\")\n    }\n}"],"naive::date::Days":["Clone","Copy","Debug","Eq","Hash","PartialEq","PartialOrd","impl Days {\n    /// Construct a new `Days` from a number of days\n    pub const fn new(num: u64) -> Self {\n        Self(num)\n    }\n}"],"naive::date::NaiveDate":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl Add<Days> for NaiveDate {\n    type Output = NaiveDate;\n\n    fn add(self, days: Days) -> Self::Output {\n        self.checked_add_days(days).unwrap()\n    }\n}","impl Add<Months> for NaiveDate {\n    type Output = NaiveDate;\n\n    /// An addition of months to `NaiveDate` clamped to valid days in resulting month.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the resulting date would be out of range.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Months};\n    ///\n    /// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n    ///\n    /// assert_eq!(from_ymd(2014, 1, 1) + Months::new(1), from_ymd(2014, 2, 1));\n    /// assert_eq!(from_ymd(2014, 1, 1) + Months::new(11), from_ymd(2014, 12, 1));\n    /// assert_eq!(from_ymd(2014, 1, 1) + Months::new(12), from_ymd(2015, 1, 1));\n    /// assert_eq!(from_ymd(2014, 1, 1) + Months::new(13), from_ymd(2015, 2, 1));\n    /// assert_eq!(from_ymd(2014, 1, 31) + Months::new(1), from_ymd(2014, 2, 28));\n    /// assert_eq!(from_ymd(2020, 1, 31) + Months::new(1), from_ymd(2020, 2, 29));\n    /// ```\n    fn add(self, months: Months) -> Self::Output {\n        self.checked_add_months(months).unwrap()\n    }\n}","impl Add<OldDuration> for NaiveDate {\n    type Output = NaiveDate;\n\n    #[inline]\n    fn add(self, rhs: OldDuration) -> NaiveDate {\n        self.checked_add_signed(rhs).expect(\"`NaiveDate + Duration` overflowed\")\n    }\n}","impl AddAssign<OldDuration> for NaiveDate {\n    #[inline]\n    fn add_assign(&mut self, rhs: OldDuration) {\n        *self = self.add(rhs);\n    }\n}","impl Datelike for NaiveDate {\n    /// Returns the year number in the [calendar date](#calendar-date).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().year(), 2015);\n    /// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().year(), -308); // 309 BCE\n    /// ```\n    #[inline]\n    fn year(&self) -> i32 {\n        self.ymdf >> 13\n    }\n\n    /// Returns the month number starting from 1.\n    ///\n    /// The return value ranges from 1 to 12.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().month(), 9);\n    /// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().month(), 3);\n    /// ```\n    #[inline]\n    fn month(&self) -> u32 {\n        self.mdf().month()\n    }\n\n    /// Returns the month number starting from 0.\n    ///\n    /// The return value ranges from 0 to 11.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().month0(), 8);\n    /// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().month0(), 2);\n    /// ```\n    #[inline]\n    fn month0(&self) -> u32 {\n        self.mdf().month() - 1\n    }\n\n    /// Returns the day of month starting from 1.\n    ///\n    /// The return value ranges from 1 to 31. (The last day of month differs by months.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().day(), 8);\n    /// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().day(), 14);\n    /// ```\n    ///\n    /// Combined with [`NaiveDate::pred`](#method.pred),\n    /// one can determine the number of days in a particular month.\n    /// (Note that this panics when `year` is out of range.)\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// fn ndays_in_month(year: i32, month: u32) -> u32 {\n    ///     // the first day of the next month...\n    ///     let (y, m) = if month == 12 { (year + 1, 1) } else { (year, month + 1) };\n    ///     let d = NaiveDate::from_ymd_opt(y, m, 1).unwrap();\n    ///\n    ///     // ...is preceded by the last day of the original month\n    ///     d.pred_opt().unwrap().day()\n    /// }\n    ///\n    /// assert_eq!(ndays_in_month(2015, 8), 31);\n    /// assert_eq!(ndays_in_month(2015, 9), 30);\n    /// assert_eq!(ndays_in_month(2015, 12), 31);\n    /// assert_eq!(ndays_in_month(2016, 2), 29);\n    /// assert_eq!(ndays_in_month(2017, 2), 28);\n    /// ```\n    #[inline]\n    fn day(&self) -> u32 {\n        self.mdf().day()\n    }\n\n    /// Returns the day of month starting from 0.\n    ///\n    /// The return value ranges from 0 to 30. (The last day of month differs by months.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().day0(), 7);\n    /// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().day0(), 13);\n    /// ```\n    #[inline]\n    fn day0(&self) -> u32 {\n        self.mdf().day() - 1\n    }\n\n    /// Returns the day of year starting from 1.\n    ///\n    /// The return value ranges from 1 to 366. (The last day of year differs by years.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().ordinal(), 251);\n    /// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().ordinal(), 74);\n    /// ```\n    ///\n    /// Combined with [`NaiveDate::pred`](#method.pred),\n    /// one can determine the number of days in a particular year.\n    /// (Note that this panics when `year` is out of range.)\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// fn ndays_in_year(year: i32) -> u32 {\n    ///     // the first day of the next year...\n    ///     let d = NaiveDate::from_ymd_opt(year + 1, 1, 1).unwrap();\n    ///\n    ///     // ...is preceded by the last day of the original year\n    ///     d.pred_opt().unwrap().ordinal()\n    /// }\n    ///\n    /// assert_eq!(ndays_in_year(2015), 365);\n    /// assert_eq!(ndays_in_year(2016), 366);\n    /// assert_eq!(ndays_in_year(2017), 365);\n    /// assert_eq!(ndays_in_year(2000), 366);\n    /// assert_eq!(ndays_in_year(2100), 365);\n    /// ```\n    #[inline]\n    fn ordinal(&self) -> u32 {\n        self.of().ordinal()\n    }\n\n    /// Returns the day of year starting from 0.\n    ///\n    /// The return value ranges from 0 to 365. (The last day of year differs by years.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().ordinal0(), 250);\n    /// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().ordinal0(), 73);\n    /// ```\n    #[inline]\n    fn ordinal0(&self) -> u32 {\n        self.of().ordinal() - 1\n    }\n\n    /// Returns the day of week.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike, Weekday};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().weekday(), Weekday::Tue);\n    /// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().weekday(), Weekday::Fri);\n    /// ```\n    #[inline]\n    fn weekday(&self) -> Weekday {\n        self.of().weekday()\n    }\n\n    #[inline]\n    fn iso_week(&self) -> IsoWeek {\n        isoweek::iso_week_from_yof(self.year(), self.of())\n    }\n\n    /// Makes a new `NaiveDate` with the year number changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDate` would be invalid.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_year(2016),\n    ///            Some(NaiveDate::from_ymd_opt(2016, 9, 8).unwrap()));\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_year(-308),\n    ///            Some(NaiveDate::from_ymd_opt(-308, 9, 8).unwrap()));\n    /// ```\n    ///\n    /// A leap day (February 29) is a good example that this method can return `None`.\n    ///\n    /// ```\n    /// # use chrono::{NaiveDate, Datelike};\n    /// assert!(NaiveDate::from_ymd_opt(2016, 2, 29).unwrap().with_year(2015).is_none());\n    /// assert!(NaiveDate::from_ymd_opt(2016, 2, 29).unwrap().with_year(2020).is_some());\n    /// ```\n    #[inline]\n    fn with_year(&self, year: i32) -> Option<NaiveDate> {\n        // we need to operate with `mdf` since we should keep the month and day number as is\n        let mdf = self.mdf();\n\n        // adjust the flags as needed\n        let flags = YearFlags::from_year(year);\n        let mdf = mdf.with_flags(flags);\n\n        NaiveDate::from_mdf(year, mdf)\n    }\n\n    /// Makes a new `NaiveDate` with the month number (starting from 1) changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDate` would be invalid.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_month(10),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 10, 8).unwrap()));\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_month(13), None); // no month 13\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 30).unwrap().with_month(2), None); // no February 30\n    /// ```\n    #[inline]\n    fn with_month(&self, month: u32) -> Option<NaiveDate> {\n        self.with_mdf(self.mdf().with_month(month)?)\n    }\n\n    /// Makes a new `NaiveDate` with the month number (starting from 0) changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDate` would be invalid.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_month0(9),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 10, 8).unwrap()));\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_month0(12), None); // no month 13\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 30).unwrap().with_month0(1), None); // no February 30\n    /// ```\n    #[inline]\n    fn with_month0(&self, month0: u32) -> Option<NaiveDate> {\n        let month = month0.checked_add(1)?;\n        self.with_mdf(self.mdf().with_month(month)?)\n    }\n\n    /// Makes a new `NaiveDate` with the day of month (starting from 1) changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDate` would be invalid.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_day(30),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 9, 30).unwrap()));\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_day(31),\n    ///            None); // no September 31\n    /// ```\n    #[inline]\n    fn with_day(&self, day: u32) -> Option<NaiveDate> {\n        self.with_mdf(self.mdf().with_day(day)?)\n    }\n\n    /// Makes a new `NaiveDate` with the day of month (starting from 0) changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDate` would be invalid.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_day0(29),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 9, 30).unwrap()));\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_day0(30),\n    ///            None); // no September 31\n    /// ```\n    #[inline]\n    fn with_day0(&self, day0: u32) -> Option<NaiveDate> {\n        let day = day0.checked_add(1)?;\n        self.with_mdf(self.mdf().with_day(day)?)\n    }\n\n    /// Makes a new `NaiveDate` with the day of year (starting from 1) changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDate` would be invalid.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 1, 1).unwrap().with_ordinal(60),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 3, 1).unwrap()));\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 1, 1).unwrap().with_ordinal(366),\n    ///            None); // 2015 had only 365 days\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2016, 1, 1).unwrap().with_ordinal(60),\n    ///            Some(NaiveDate::from_ymd_opt(2016, 2, 29).unwrap()));\n    /// assert_eq!(NaiveDate::from_ymd_opt(2016, 1, 1).unwrap().with_ordinal(366),\n    ///            Some(NaiveDate::from_ymd_opt(2016, 12, 31).unwrap()));\n    /// ```\n    #[inline]\n    fn with_ordinal(&self, ordinal: u32) -> Option<NaiveDate> {\n        self.of().with_ordinal(ordinal).map(|of| self.with_of(of))\n    }\n\n    /// Makes a new `NaiveDate` with the day of year (starting from 0) changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDate` would be invalid.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 1, 1).unwrap().with_ordinal0(59),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 3, 1).unwrap()));\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 1, 1).unwrap().with_ordinal0(365),\n    ///            None); // 2015 had only 365 days\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2016, 1, 1).unwrap().with_ordinal0(59),\n    ///            Some(NaiveDate::from_ymd_opt(2016, 2, 29).unwrap()));\n    /// assert_eq!(NaiveDate::from_ymd_opt(2016, 1, 1).unwrap().with_ordinal0(365),\n    ///            Some(NaiveDate::from_ymd_opt(2016, 12, 31).unwrap()));\n    /// ```\n    #[inline]\n    fn with_ordinal0(&self, ordinal0: u32) -> Option<NaiveDate> {\n        let ordinal = ordinal0.checked_add(1)?;\n        self.with_ordinal(ordinal)\n    }\n}","impl Default for NaiveDate {\n    fn default() -> Self {\n        NaiveDate::from_ymd_opt(1970, 1, 1).unwrap()\n    }\n}","impl From<NaiveDateTime> for NaiveDate {\n    fn from(naive_datetime: NaiveDateTime) -> Self {\n        naive_datetime.date()\n    }\n}","impl NaiveDate {\n    pub(crate) fn weeks_from(&self, day: Weekday) -> i32 {\n        (self.ordinal() as i32 - self.weekday().num_days_from(day) as i32 + 6) / 7\n    }\n\n    /// Makes a new `NaiveDate` from year, ordinal and flags.\n    /// Does not check whether the flags are correct for the provided year.\n    const fn from_ordinal_and_flags(\n        year: i32,\n        ordinal: u32,\n        flags: YearFlags,\n    ) -> Option<NaiveDate> {\n        if year < MIN_YEAR || year > MAX_YEAR {\n            return None; // Out-of-range\n        }\n        // Enable debug check once the MSRV >= 1.57 (panicking in const feature)\n        // debug_assert!(YearFlags::from_year(year).0 == flags.0);\n        match Of::new(ordinal, flags) {\n            Some(of) => Some(NaiveDate { ymdf: (year << 13) | (of.inner() as DateImpl) }),\n            None => None, // Invalid: Ordinal outside of the nr of days in a year with those flags.\n        }\n    }\n\n    /// Makes a new `NaiveDate` from year and packed month-day-flags.\n    /// Does not check whether the flags are correct for the provided year.\n    const fn from_mdf(year: i32, mdf: Mdf) -> Option<NaiveDate> {\n        if year < MIN_YEAR || year > MAX_YEAR {\n            return None; // Out-of-range\n        }\n        match mdf.to_of() {\n            Some(of) => Some(NaiveDate { ymdf: (year << 13) | (of.inner() as DateImpl) }),\n            None => None, // Non-existing date\n        }\n    }\n\n    /// Makes a new `NaiveDate` from the [calendar date](#calendar-date)\n    /// (year, month and day).\n    ///\n    /// Panics on the out-of-range date, invalid month and/or day.\n    #[deprecated(since = \"0.4.23\", note = \"use `from_ymd_opt()` instead\")]\n    #[must_use]\n    pub fn from_ymd(year: i32, month: u32, day: u32) -> NaiveDate {\n        NaiveDate::from_ymd_opt(year, month, day).expect(\"invalid or out-of-range date\")\n    }\n\n    /// Makes a new `NaiveDate` from the [calendar date](#calendar-date)\n    /// (year, month and day).\n    ///\n    /// Returns `None` on the out-of-range date, invalid month and/or day.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let from_ymd_opt = NaiveDate::from_ymd_opt;\n    ///\n    /// assert!(from_ymd_opt(2015, 3, 14).is_some());\n    /// assert!(from_ymd_opt(2015, 0, 14).is_none());\n    /// assert!(from_ymd_opt(2015, 2, 29).is_none());\n    /// assert!(from_ymd_opt(-4, 2, 29).is_some()); // 5 BCE is a leap year\n    /// assert!(from_ymd_opt(400000, 1, 1).is_none());\n    /// assert!(from_ymd_opt(-400000, 1, 1).is_none());\n    /// ```\n    #[must_use]\n    pub fn from_ymd_opt(year: i32, month: u32, day: u32) -> Option<NaiveDate> {\n        let flags = YearFlags::from_year(year);\n        NaiveDate::from_mdf(year, Mdf::new(month, day, flags)?)\n    }\n\n    /// Makes a new `NaiveDate` from the [ordinal date](#ordinal-date)\n    /// (year and day of the year).\n    ///\n    /// Panics on the out-of-range date and/or invalid day of year.\n    #[deprecated(since = \"0.4.23\", note = \"use `from_yo_opt()` instead\")]\n    #[must_use]\n    pub fn from_yo(year: i32, ordinal: u32) -> NaiveDate {\n        NaiveDate::from_yo_opt(year, ordinal).expect(\"invalid or out-of-range date\")\n    }\n\n    /// Makes a new `NaiveDate` from the [ordinal date](#ordinal-date)\n    /// (year and day of the year).\n    ///\n    /// Returns `None` on the out-of-range date and/or invalid day of year.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let from_yo_opt = NaiveDate::from_yo_opt;\n    ///\n    /// assert!(from_yo_opt(2015, 100).is_some());\n    /// assert!(from_yo_opt(2015, 0).is_none());\n    /// assert!(from_yo_opt(2015, 365).is_some());\n    /// assert!(from_yo_opt(2015, 366).is_none());\n    /// assert!(from_yo_opt(-4, 366).is_some()); // 5 BCE is a leap year\n    /// assert!(from_yo_opt(400000, 1).is_none());\n    /// assert!(from_yo_opt(-400000, 1).is_none());\n    /// ```\n    #[must_use]\n    pub fn from_yo_opt(year: i32, ordinal: u32) -> Option<NaiveDate> {\n        let flags = YearFlags::from_year(year);\n        NaiveDate::from_ordinal_and_flags(year, ordinal, flags)\n    }\n\n    /// Makes a new `NaiveDate` from the [ISO week date](#week-date)\n    /// (year, week number and day of the week).\n    /// The resulting `NaiveDate` may have a different year from the input year.\n    ///\n    /// Panics on the out-of-range date and/or invalid week number.\n    #[deprecated(since = \"0.4.23\", note = \"use `from_isoywd_opt()` instead\")]\n    #[must_use]\n    pub fn from_isoywd(year: i32, week: u32, weekday: Weekday) -> NaiveDate {\n        NaiveDate::from_isoywd_opt(year, week, weekday).expect(\"invalid or out-of-range date\")\n    }\n\n    /// Makes a new `NaiveDate` from the [ISO week date](#week-date)\n    /// (year, week number and day of the week).\n    /// The resulting `NaiveDate` may have a different year from the input year.\n    ///\n    /// Returns `None` on the out-of-range date and/or invalid week number.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Weekday};\n    ///\n    /// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n    /// let from_isoywd_opt = NaiveDate::from_isoywd_opt;\n    ///\n    /// assert_eq!(from_isoywd_opt(2015, 0, Weekday::Sun), None);\n    /// assert_eq!(from_isoywd_opt(2015, 10, Weekday::Sun), Some(from_ymd(2015, 3, 8)));\n    /// assert_eq!(from_isoywd_opt(2015, 30, Weekday::Mon), Some(from_ymd(2015, 7, 20)));\n    /// assert_eq!(from_isoywd_opt(2015, 60, Weekday::Mon), None);\n    ///\n    /// assert_eq!(from_isoywd_opt(400000, 10, Weekday::Fri), None);\n    /// assert_eq!(from_isoywd_opt(-400000, 10, Weekday::Sat), None);\n    /// ```\n    ///\n    /// The year number of ISO week date may differ from that of the calendar date.\n    ///\n    /// ```\n    /// # use chrono::{NaiveDate, Weekday};\n    /// # let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n    /// # let from_isoywd_opt = NaiveDate::from_isoywd_opt;\n    /// //           Mo Tu We Th Fr Sa Su\n    /// // 2014-W52  22 23 24 25 26 27 28    has 4+ days of new year,\n    /// // 2015-W01  29 30 31  1  2  3  4 <- so this is the first week\n    /// assert_eq!(from_isoywd_opt(2014, 52, Weekday::Sun), Some(from_ymd(2014, 12, 28)));\n    /// assert_eq!(from_isoywd_opt(2014, 53, Weekday::Mon), None);\n    /// assert_eq!(from_isoywd_opt(2015, 1, Weekday::Mon), Some(from_ymd(2014, 12, 29)));\n    ///\n    /// // 2015-W52  21 22 23 24 25 26 27    has 4+ days of old year,\n    /// // 2015-W53  28 29 30 31  1  2  3 <- so this is the last week\n    /// // 2016-W01   4  5  6  7  8  9 10\n    /// assert_eq!(from_isoywd_opt(2015, 52, Weekday::Sun), Some(from_ymd(2015, 12, 27)));\n    /// assert_eq!(from_isoywd_opt(2015, 53, Weekday::Sun), Some(from_ymd(2016, 1, 3)));\n    /// assert_eq!(from_isoywd_opt(2015, 54, Weekday::Mon), None);\n    /// assert_eq!(from_isoywd_opt(2016, 1, Weekday::Mon), Some(from_ymd(2016, 1, 4)));\n    /// ```\n    #[must_use]\n    pub fn from_isoywd_opt(year: i32, week: u32, weekday: Weekday) -> Option<NaiveDate> {\n        let flags = YearFlags::from_year(year);\n        let nweeks = flags.nisoweeks();\n        if 1 <= week && week <= nweeks {\n            // ordinal = week ordinal - delta\n            let weekord = week * 7 + weekday as u32;\n            let delta = flags.isoweek_delta();\n            if weekord <= delta {\n                // ordinal < 1, previous year\n                let prevflags = YearFlags::from_year(year - 1);\n                NaiveDate::from_ordinal_and_flags(\n                    year - 1,\n                    weekord + prevflags.ndays() - delta,\n                    prevflags,\n                )\n            } else {\n                let ordinal = weekord - delta;\n                let ndays = flags.ndays();\n                if ordinal <= ndays {\n                    // this year\n                    NaiveDate::from_ordinal_and_flags(year, ordinal, flags)\n                } else {\n                    // ordinal > ndays, next year\n                    let nextflags = YearFlags::from_year(year + 1);\n                    NaiveDate::from_ordinal_and_flags(year + 1, ordinal - ndays, nextflags)\n                }\n            }\n        } else {\n            None\n        }\n    }\n\n    /// Makes a new `NaiveDate` from a day's number in the proleptic Gregorian calendar, with\n    /// January 1, 1 being day 1.\n    ///\n    /// Panics if the date is out of range.\n    #[deprecated(since = \"0.4.23\", note = \"use `from_num_days_from_ce_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn from_num_days_from_ce(days: i32) -> NaiveDate {\n        NaiveDate::from_num_days_from_ce_opt(days).expect(\"out-of-range date\")\n    }\n\n    /// Makes a new `NaiveDate` from a day's number in the proleptic Gregorian calendar, with\n    /// January 1, 1 being day 1.\n    ///\n    /// Returns `None` if the date is out of range.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let from_ndays_opt = NaiveDate::from_num_days_from_ce_opt;\n    /// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n    ///\n    /// assert_eq!(from_ndays_opt(730_000),      Some(from_ymd(1999, 9, 3)));\n    /// assert_eq!(from_ndays_opt(1),            Some(from_ymd(1, 1, 1)));\n    /// assert_eq!(from_ndays_opt(0),            Some(from_ymd(0, 12, 31)));\n    /// assert_eq!(from_ndays_opt(-1),           Some(from_ymd(0, 12, 30)));\n    /// assert_eq!(from_ndays_opt(100_000_000),  None);\n    /// assert_eq!(from_ndays_opt(-100_000_000), None);\n    /// ```\n    #[must_use]\n    pub fn from_num_days_from_ce_opt(days: i32) -> Option<NaiveDate> {\n        let days = days.checked_add(365)?; // make December 31, 1 BCE equal to day 0\n        let (year_div_400, cycle) = div_mod_floor(days, 146_097);\n        let (year_mod_400, ordinal) = internals::cycle_to_yo(cycle as u32);\n        let flags = YearFlags::from_year_mod_400(year_mod_400 as i32);\n        NaiveDate::from_ordinal_and_flags(year_div_400 * 400 + year_mod_400 as i32, ordinal, flags)\n    }\n\n    /// Makes a new `NaiveDate` by counting the number of occurrences of a particular day-of-week\n    /// since the beginning of the given month.  For instance, if you want the 2nd Friday of March\n    /// 2017, you would use `NaiveDate::from_weekday_of_month(2017, 3, Weekday::Fri, 2)`.\n    ///\n    /// # Panics\n    ///\n    /// The resulting `NaiveDate` is guaranteed to be in `month`.  If `n` is larger than the number\n    /// of `weekday` in `month` (eg. the 6th Friday of March 2017) then this function will panic.\n    ///\n    /// `n` is 1-indexed.  Passing `n=0` will cause a panic.\n    #[deprecated(since = \"0.4.23\", note = \"use `from_weekday_of_month_opt()` instead\")]\n    #[must_use]\n    pub fn from_weekday_of_month(year: i32, month: u32, weekday: Weekday, n: u8) -> NaiveDate {\n        NaiveDate::from_weekday_of_month_opt(year, month, weekday, n).expect(\"out-of-range date\")\n    }\n\n    /// Makes a new `NaiveDate` by counting the number of occurrences of a particular day-of-week\n    /// since the beginning of the given month.  For instance, if you want the 2nd Friday of March\n    /// 2017, you would use `NaiveDate::from_weekday_of_month(2017, 3, Weekday::Fri, 2)`.  `n` is 1-indexed.\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Weekday};\n    /// assert_eq!(NaiveDate::from_weekday_of_month_opt(2017, 3, Weekday::Fri, 2),\n    ///            NaiveDate::from_ymd_opt(2017, 3, 10))\n    /// ```\n    ///\n    /// Returns `None` if `n` out-of-range; ie. if `n` is larger than the number of `weekday` in\n    /// `month` (eg. the 6th Friday of March 2017), or if `n == 0`.\n    #[must_use]\n    pub fn from_weekday_of_month_opt(\n        year: i32,\n        month: u32,\n        weekday: Weekday,\n        n: u8,\n    ) -> Option<NaiveDate> {\n        if n == 0 {\n            return None;\n        }\n        let first = NaiveDate::from_ymd_opt(year, month, 1)?.weekday();\n        let first_to_dow = (7 + weekday.number_from_monday() - first.number_from_monday()) % 7;\n        let day = (u32::from(n) - 1) * 7 + first_to_dow + 1;\n        NaiveDate::from_ymd_opt(year, month, day)\n    }\n\n    /// Parses a string with the specified format string and returns a new `NaiveDate`.\n    /// See the [`format::strftime` module](../format/strftime/index.html)\n    /// on the supported escape sequences.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let parse_from_str = NaiveDate::parse_from_str;\n    ///\n    /// assert_eq!(parse_from_str(\"2015-09-05\", \"%Y-%m-%d\"),\n    ///            Ok(NaiveDate::from_ymd_opt(2015, 9, 5).unwrap()));\n    /// assert_eq!(parse_from_str(\"5sep2015\", \"%d%b%Y\"),\n    ///            Ok(NaiveDate::from_ymd_opt(2015, 9, 5).unwrap()));\n    /// ```\n    ///\n    /// Time and offset is ignored for the purpose of parsing.\n    ///\n    /// ```\n    /// # use chrono::NaiveDate;\n    /// # let parse_from_str = NaiveDate::parse_from_str;\n    /// assert_eq!(parse_from_str(\"2014-5-17T12:34:56+09:30\", \"%Y-%m-%dT%H:%M:%S%z\"),\n    ///            Ok(NaiveDate::from_ymd_opt(2014, 5, 17).unwrap()));\n    /// ```\n    ///\n    /// Out-of-bound dates or insufficient fields are errors.\n    ///\n    /// ```\n    /// # use chrono::NaiveDate;\n    /// # let parse_from_str = NaiveDate::parse_from_str;\n    /// assert!(parse_from_str(\"2015/9\", \"%Y/%m\").is_err());\n    /// assert!(parse_from_str(\"2015/9/31\", \"%Y/%m/%d\").is_err());\n    /// ```\n    ///\n    /// All parsed fields should be consistent to each other, otherwise it's an error.\n    ///\n    /// ```\n    /// # use chrono::NaiveDate;\n    /// # let parse_from_str = NaiveDate::parse_from_str;\n    /// assert!(parse_from_str(\"Sat, 09 Aug 2013\", \"%a, %d %b %Y\").is_err());\n    /// ```\n    pub fn parse_from_str(s: &str, fmt: &str) -> ParseResult<NaiveDate> {\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_naive_date()\n    }\n\n    /// Parses a string from a user-specified format into a new `NaiveDate` value, and a slice with\n    /// the remaining portion of the string.\n    /// See the [`format::strftime` module](../format/strftime/index.html)\n    /// on the supported escape sequences.\n    ///\n    /// Similar to [`parse_from_str`](#method.parse_from_str).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use chrono::{NaiveDate};\n    /// let (date, remainder) = NaiveDate::parse_and_remainder(\n    ///     \"2015-02-18 trailing text\", \"%Y-%m-%d\").unwrap();\n    /// assert_eq!(date, NaiveDate::from_ymd_opt(2015, 2, 18).unwrap());\n    /// assert_eq!(remainder, \" trailing text\");\n    /// ```\n    pub fn parse_and_remainder<'a>(s: &'a str, fmt: &str) -> ParseResult<(NaiveDate, &'a str)> {\n        let mut parsed = Parsed::new();\n        let remainder = parse_and_remainder(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_naive_date().map(|d| (d, remainder))\n    }\n\n    /// Add a duration in [`Months`] to the date\n    ///\n    /// If the day would be out of range for the resulting month, use the last day for that month.\n    ///\n    /// Returns `None` if the resulting date would be out of range.\n    ///\n    /// ```\n    /// # use chrono::{NaiveDate, Months};\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2022, 2, 20).unwrap().checked_add_months(Months::new(6)),\n    ///     Some(NaiveDate::from_ymd_opt(2022, 8, 20).unwrap())\n    /// );\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2022, 7, 31).unwrap().checked_add_months(Months::new(2)),\n    ///     Some(NaiveDate::from_ymd_opt(2022, 9, 30).unwrap())\n    /// );\n    /// ```\n    #[must_use]\n    pub fn checked_add_months(self, months: Months) -> Option<Self> {\n        if months.0 == 0 {\n            return Some(self);\n        }\n\n        match months.0 <= core::i32::MAX as u32 {\n            true => self.diff_months(months.0 as i32),\n            false => None,\n        }\n    }\n\n    /// Subtract a duration in [`Months`] from the date\n    ///\n    /// If the day would be out of range for the resulting month, use the last day for that month.\n    ///\n    /// Returns `None` if the resulting date would be out of range.\n    ///\n    /// ```\n    /// # use chrono::{NaiveDate, Months};\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2022, 2, 20).unwrap().checked_sub_months(Months::new(6)),\n    ///     Some(NaiveDate::from_ymd_opt(2021, 8, 20).unwrap())\n    /// );\n    ///\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap()\n    ///         .checked_sub_months(Months::new(core::i32::MAX as u32 + 1)),\n    ///     None\n    /// );\n    /// ```\n    #[must_use]\n    pub fn checked_sub_months(self, months: Months) -> Option<Self> {\n        if months.0 == 0 {\n            return Some(self);\n        }\n\n        // Copy `i32::MAX` here so we don't have to do a complicated cast\n        match months.0 <= 2_147_483_647 {\n            true => self.diff_months(-(months.0 as i32)),\n            false => None,\n        }\n    }\n\n    fn diff_months(self, months: i32) -> Option<Self> {\n        let (years, left) = ((months / 12), (months % 12));\n\n        // Determine new year (without taking months into account for now\n\n        let year = if (years > 0 && years > (MAX_YEAR - self.year()))\n            || (years < 0 && years < (MIN_YEAR - self.year()))\n        {\n            return None;\n        } else {\n            self.year() + years\n        };\n\n        // Determine new month\n\n        let month = self.month() as i32 + left;\n        let (year, month) = if month <= 0 {\n            if year == MIN_YEAR {\n                return None;\n            }\n\n            (year - 1, month + 12)\n        } else if month > 12 {\n            if year == MAX_YEAR {\n                return None;\n            }\n\n            (year + 1, month - 12)\n        } else {\n            (year, month)\n        };\n\n        // Clamp original day in case new month is shorter\n\n        let flags = YearFlags::from_year(year);\n        let feb_days = if flags.ndays() == 366 { 29 } else { 28 };\n        let days = [31, feb_days, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        let day = Ord::min(self.day(), days[(month - 1) as usize]);\n\n        NaiveDate::from_mdf(year, Mdf::new(month as u32, day, flags)?)\n    }\n\n    /// Add a duration in [`Days`] to the date\n    ///\n    /// Returns `None` if the resulting date would be out of range.\n    ///\n    /// ```\n    /// # use chrono::{NaiveDate, Days};\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2022, 2, 20).unwrap().checked_add_days(Days::new(9)),\n    ///     Some(NaiveDate::from_ymd_opt(2022, 3, 1).unwrap())\n    /// );\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2022, 7, 31).unwrap().checked_add_days(Days::new(2)),\n    ///     Some(NaiveDate::from_ymd_opt(2022, 8, 2).unwrap())\n    /// );\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2022, 7, 31).unwrap().checked_add_days(Days::new(1000000000000)),\n    ///     None\n    /// );\n    /// ```\n    #[must_use]\n    pub fn checked_add_days(self, days: Days) -> Option<Self> {\n        if days.0 == 0 {\n            return Some(self);\n        }\n\n        i64::try_from(days.0).ok().and_then(|d| self.diff_days(d))\n    }\n\n    /// Subtract a duration in [`Days`] from the date\n    ///\n    /// Returns `None` if the resulting date would be out of range.\n    ///\n    /// ```\n    /// # use chrono::{NaiveDate, Days};\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2022, 2, 20).unwrap().checked_sub_days(Days::new(6)),\n    ///     Some(NaiveDate::from_ymd_opt(2022, 2, 14).unwrap())\n    /// );\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2022, 2, 20).unwrap().checked_sub_days(Days::new(1000000000000)),\n    ///     None\n    /// );\n    /// ```\n    #[must_use]\n    pub fn checked_sub_days(self, days: Days) -> Option<Self> {\n        if days.0 == 0 {\n            return Some(self);\n        }\n\n        i64::try_from(days.0).ok().and_then(|d| self.diff_days(-d))\n    }\n\n    fn diff_days(self, days: i64) -> Option<Self> {\n        let secs = days.checked_mul(86400)?; // 86400 seconds in one day\n        if secs >= core::i64::MAX / 1000 || secs <= core::i64::MIN / 1000 {\n            return None; // See the `time` 0.1 crate. Outside these bounds, `Duration::seconds` will panic\n        }\n        self.checked_add_signed(Duration::seconds(secs))\n    }\n\n    /// Makes a new `NaiveDateTime` from the current date and given `NaiveTime`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveTime, NaiveDateTime};\n    ///\n    /// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n    /// let t = NaiveTime::from_hms_milli_opt(12, 34, 56, 789).unwrap();\n    ///\n    /// let dt: NaiveDateTime = d.and_time(t);\n    /// assert_eq!(dt.date(), d);\n    /// assert_eq!(dt.time(), t);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub const fn and_time(&self, time: NaiveTime) -> NaiveDateTime {\n        NaiveDateTime::new(*self, time)\n    }\n\n    /// Makes a new `NaiveDateTime` from the current date, hour, minute and second.\n    ///\n    /// No [leap second](./struct.NaiveTime.html#leap-second-handling) is allowed here;\n    /// use `NaiveDate::and_hms_*` methods with a subsecond parameter instead.\n    ///\n    /// Panics on invalid hour, minute and/or second.\n    #[deprecated(since = \"0.4.23\", note = \"use `and_hms_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn and_hms(&self, hour: u32, min: u32, sec: u32) -> NaiveDateTime {\n        self.and_hms_opt(hour, min, sec).expect(\"invalid time\")\n    }\n\n    /// Makes a new `NaiveDateTime` from the current date, hour, minute and second.\n    ///\n    /// No [leap second](./struct.NaiveTime.html#leap-second-handling) is allowed here;\n    /// use `NaiveDate::and_hms_*_opt` methods with a subsecond parameter instead.\n    ///\n    /// Returns `None` on invalid hour, minute and/or second.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n    /// assert!(d.and_hms_opt(12, 34, 56).is_some());\n    /// assert!(d.and_hms_opt(12, 34, 60).is_none()); // use `and_hms_milli_opt` instead\n    /// assert!(d.and_hms_opt(12, 60, 56).is_none());\n    /// assert!(d.and_hms_opt(24, 34, 56).is_none());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn and_hms_opt(&self, hour: u32, min: u32, sec: u32) -> Option<NaiveDateTime> {\n        NaiveTime::from_hms_opt(hour, min, sec).map(|time| self.and_time(time))\n    }\n\n    /// Makes a new `NaiveDateTime` from the current date, hour, minute, second and millisecond.\n    ///\n    /// The millisecond part can exceed 1,000\n    /// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n    ///\n    /// Panics on invalid hour, minute, second and/or millisecond.\n    #[deprecated(since = \"0.4.23\", note = \"use `and_hms_milli_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn and_hms_milli(&self, hour: u32, min: u32, sec: u32, milli: u32) -> NaiveDateTime {\n        self.and_hms_milli_opt(hour, min, sec, milli).expect(\"invalid time\")\n    }\n\n    /// Makes a new `NaiveDateTime` from the current date, hour, minute, second and millisecond.\n    ///\n    /// The millisecond part can exceed 1,000\n    /// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n    ///\n    /// Returns `None` on invalid hour, minute, second and/or millisecond.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n    /// assert!(d.and_hms_milli_opt(12, 34, 56,   789).is_some());\n    /// assert!(d.and_hms_milli_opt(12, 34, 59, 1_789).is_some()); // leap second\n    /// assert!(d.and_hms_milli_opt(12, 34, 59, 2_789).is_none());\n    /// assert!(d.and_hms_milli_opt(12, 34, 60,   789).is_none());\n    /// assert!(d.and_hms_milli_opt(12, 60, 56,   789).is_none());\n    /// assert!(d.and_hms_milli_opt(24, 34, 56,   789).is_none());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn and_hms_milli_opt(\n        &self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        milli: u32,\n    ) -> Option<NaiveDateTime> {\n        NaiveTime::from_hms_milli_opt(hour, min, sec, milli).map(|time| self.and_time(time))\n    }\n\n    /// Makes a new `NaiveDateTime` from the current date, hour, minute, second and microsecond.\n    ///\n    /// The microsecond part can exceed 1,000,000\n    /// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n    ///\n    /// Panics on invalid hour, minute, second and/or microsecond.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike, Timelike, Weekday};\n    ///\n    /// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n    ///\n    /// let dt: NaiveDateTime = d.and_hms_micro_opt(12, 34, 56, 789_012).unwrap();\n    /// assert_eq!(dt.year(), 2015);\n    /// assert_eq!(dt.weekday(), Weekday::Wed);\n    /// assert_eq!(dt.second(), 56);\n    /// assert_eq!(dt.nanosecond(), 789_012_000);\n    /// ```\n    #[deprecated(since = \"0.4.23\", note = \"use `and_hms_micro_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn and_hms_micro(&self, hour: u32, min: u32, sec: u32, micro: u32) -> NaiveDateTime {\n        self.and_hms_micro_opt(hour, min, sec, micro).expect(\"invalid time\")\n    }\n\n    /// Makes a new `NaiveDateTime` from the current date, hour, minute, second and microsecond.\n    ///\n    /// The microsecond part can exceed 1,000,000\n    /// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n    ///\n    /// Returns `None` on invalid hour, minute, second and/or microsecond.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n    /// assert!(d.and_hms_micro_opt(12, 34, 56,   789_012).is_some());\n    /// assert!(d.and_hms_micro_opt(12, 34, 59, 1_789_012).is_some()); // leap second\n    /// assert!(d.and_hms_micro_opt(12, 34, 59, 2_789_012).is_none());\n    /// assert!(d.and_hms_micro_opt(12, 34, 60,   789_012).is_none());\n    /// assert!(d.and_hms_micro_opt(12, 60, 56,   789_012).is_none());\n    /// assert!(d.and_hms_micro_opt(24, 34, 56,   789_012).is_none());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn and_hms_micro_opt(\n        &self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        micro: u32,\n    ) -> Option<NaiveDateTime> {\n        NaiveTime::from_hms_micro_opt(hour, min, sec, micro).map(|time| self.and_time(time))\n    }\n\n    /// Makes a new `NaiveDateTime` from the current date, hour, minute, second and nanosecond.\n    ///\n    /// The nanosecond part can exceed 1,000,000,000\n    /// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n    ///\n    /// Panics on invalid hour, minute, second and/or nanosecond.\n    #[deprecated(since = \"0.4.23\", note = \"use `and_hms_nano_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn and_hms_nano(&self, hour: u32, min: u32, sec: u32, nano: u32) -> NaiveDateTime {\n        self.and_hms_nano_opt(hour, min, sec, nano).expect(\"invalid time\")\n    }\n\n    /// Makes a new `NaiveDateTime` from the current date, hour, minute, second and nanosecond.\n    ///\n    /// The nanosecond part can exceed 1,000,000,000\n    /// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n    ///\n    /// Returns `None` on invalid hour, minute, second and/or nanosecond.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n    /// assert!(d.and_hms_nano_opt(12, 34, 56,   789_012_345).is_some());\n    /// assert!(d.and_hms_nano_opt(12, 34, 59, 1_789_012_345).is_some()); // leap second\n    /// assert!(d.and_hms_nano_opt(12, 34, 59, 2_789_012_345).is_none());\n    /// assert!(d.and_hms_nano_opt(12, 34, 60,   789_012_345).is_none());\n    /// assert!(d.and_hms_nano_opt(12, 60, 56,   789_012_345).is_none());\n    /// assert!(d.and_hms_nano_opt(24, 34, 56,   789_012_345).is_none());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn and_hms_nano_opt(\n        &self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        nano: u32,\n    ) -> Option<NaiveDateTime> {\n        NaiveTime::from_hms_nano_opt(hour, min, sec, nano).map(|time| self.and_time(time))\n    }\n\n    /// Returns the packed month-day-flags.\n    #[inline]\n    fn mdf(&self) -> Mdf {\n        self.of().to_mdf()\n    }\n\n    /// Returns the packed ordinal-flags.\n    #[inline]\n    const fn of(&self) -> Of {\n        Of::from_date_impl(self.ymdf)\n    }\n\n    /// Makes a new `NaiveDate` with the packed month-day-flags changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDate` would be invalid.\n    #[inline]\n    fn with_mdf(&self, mdf: Mdf) -> Option<NaiveDate> {\n        Some(self.with_of(mdf.to_of()?))\n    }\n\n    /// Makes a new `NaiveDate` with the packed ordinal-flags changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDate` would be invalid.\n    /// Does not check if the year flags match the year.\n    #[inline]\n    const fn with_of(&self, of: Of) -> NaiveDate {\n        NaiveDate { ymdf: (self.ymdf & !0b1_1111_1111_1111) | of.inner() as DateImpl }\n    }\n\n    /// Makes a new `NaiveDate` for the next calendar date.\n    ///\n    /// Panics when `self` is the last representable date.\n    #[deprecated(since = \"0.4.23\", note = \"use `succ_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn succ(&self) -> NaiveDate {\n        self.succ_opt().expect(\"out of bound\")\n    }\n\n    /// Makes a new `NaiveDate` for the next calendar date.\n    ///\n    /// Returns `None` when `self` is the last representable date.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 6, 3).unwrap().succ_opt(),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 6, 4).unwrap()));\n    /// assert_eq!(NaiveDate::MAX.succ_opt(), None);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn succ_opt(&self) -> Option<NaiveDate> {\n        match self.of().succ() {\n            Some(of) => Some(self.with_of(of)),\n            None => NaiveDate::from_ymd_opt(self.year() + 1, 1, 1),\n        }\n    }\n\n    /// Makes a new `NaiveDate` for the previous calendar date.\n    ///\n    /// Panics when `self` is the first representable date.\n    #[deprecated(since = \"0.4.23\", note = \"use `pred_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn pred(&self) -> NaiveDate {\n        self.pred_opt().expect(\"out of bound\")\n    }\n\n    /// Makes a new `NaiveDate` for the previous calendar date.\n    ///\n    /// Returns `None` when `self` is the first representable date.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(2015, 6, 3).unwrap().pred_opt(),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 6, 2).unwrap()));\n    /// assert_eq!(NaiveDate::MIN.pred_opt(), None);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn pred_opt(&self) -> Option<NaiveDate> {\n        match self.of().pred() {\n            Some(of) => Some(self.with_of(of)),\n            None => NaiveDate::from_ymd_opt(self.year() - 1, 12, 31),\n        }\n    }\n\n    /// Adds the `days` part of given `Duration` to the current date.\n    ///\n    /// Returns `None` when it will result in overflow.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Duration, NaiveDate};\n    ///\n    /// let d = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap();\n    /// assert_eq!(d.checked_add_signed(Duration::days(40)),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 10, 15).unwrap()));\n    /// assert_eq!(d.checked_add_signed(Duration::days(-40)),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 7, 27).unwrap()));\n    /// assert_eq!(d.checked_add_signed(Duration::days(1_000_000_000)), None);\n    /// assert_eq!(d.checked_add_signed(Duration::days(-1_000_000_000)), None);\n    /// assert_eq!(NaiveDate::MAX.checked_add_signed(Duration::days(1)), None);\n    /// ```\n    #[must_use]\n    pub fn checked_add_signed(self, rhs: OldDuration) -> Option<NaiveDate> {\n        let year = self.year();\n        let (mut year_div_400, year_mod_400) = div_mod_floor(year, 400);\n        let cycle = internals::yo_to_cycle(year_mod_400 as u32, self.of().ordinal());\n        let cycle = (cycle as i32).checked_add(i32::try_from(rhs.num_days()).ok()?)?;\n        let (cycle_div_400y, cycle) = div_mod_floor(cycle, 146_097);\n        year_div_400 += cycle_div_400y;\n\n        let (year_mod_400, ordinal) = internals::cycle_to_yo(cycle as u32);\n        let flags = YearFlags::from_year_mod_400(year_mod_400 as i32);\n        NaiveDate::from_ordinal_and_flags(year_div_400 * 400 + year_mod_400 as i32, ordinal, flags)\n    }\n\n    /// Subtracts the `days` part of given `Duration` from the current date.\n    ///\n    /// Returns `None` when it will result in overflow.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Duration, NaiveDate};\n    ///\n    /// let d = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap();\n    /// assert_eq!(d.checked_sub_signed(Duration::days(40)),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 7, 27).unwrap()));\n    /// assert_eq!(d.checked_sub_signed(Duration::days(-40)),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 10, 15).unwrap()));\n    /// assert_eq!(d.checked_sub_signed(Duration::days(1_000_000_000)), None);\n    /// assert_eq!(d.checked_sub_signed(Duration::days(-1_000_000_000)), None);\n    /// assert_eq!(NaiveDate::MIN.checked_sub_signed(Duration::days(1)), None);\n    /// ```\n    #[must_use]\n    pub fn checked_sub_signed(self, rhs: OldDuration) -> Option<NaiveDate> {\n        let year = self.year();\n        let (mut year_div_400, year_mod_400) = div_mod_floor(year, 400);\n        let cycle = internals::yo_to_cycle(year_mod_400 as u32, self.of().ordinal());\n        let cycle = (cycle as i32).checked_sub(i32::try_from(rhs.num_days()).ok()?)?;\n        let (cycle_div_400y, cycle) = div_mod_floor(cycle, 146_097);\n        year_div_400 += cycle_div_400y;\n\n        let (year_mod_400, ordinal) = internals::cycle_to_yo(cycle as u32);\n        let flags = YearFlags::from_year_mod_400(year_mod_400 as i32);\n        NaiveDate::from_ordinal_and_flags(year_div_400 * 400 + year_mod_400 as i32, ordinal, flags)\n    }\n\n    /// Subtracts another `NaiveDate` from the current date.\n    /// Returns a `Duration` of integral numbers.\n    ///\n    /// This does not overflow or underflow at all,\n    /// as all possible output fits in the range of `Duration`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Duration, NaiveDate};\n    ///\n    /// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n    /// let since = NaiveDate::signed_duration_since;\n    ///\n    /// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(2014, 1, 1)), Duration::zero());\n    /// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(2013, 12, 31)), Duration::days(1));\n    /// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(2014, 1, 2)), Duration::days(-1));\n    /// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(2013, 9, 23)), Duration::days(100));\n    /// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(2013, 1, 1)), Duration::days(365));\n    /// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(2010, 1, 1)), Duration::days(365*4 + 1));\n    /// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(1614, 1, 1)), Duration::days(365*400 + 97));\n    /// ```\n    #[must_use]\n    pub fn signed_duration_since(self, rhs: NaiveDate) -> OldDuration {\n        let year1 = self.year();\n        let year2 = rhs.year();\n        let (year1_div_400, year1_mod_400) = div_mod_floor(year1, 400);\n        let (year2_div_400, year2_mod_400) = div_mod_floor(year2, 400);\n        let cycle1 = i64::from(internals::yo_to_cycle(year1_mod_400 as u32, self.of().ordinal()));\n        let cycle2 = i64::from(internals::yo_to_cycle(year2_mod_400 as u32, rhs.of().ordinal()));\n        OldDuration::days(\n            (i64::from(year1_div_400) - i64::from(year2_div_400)) * 146_097 + (cycle1 - cycle2),\n        )\n    }\n\n    /// Returns the number of whole years from the given `base` until `self`.\n    #[must_use]\n    pub fn years_since(&self, base: Self) -> Option<u32> {\n        let mut years = self.year() - base.year();\n        if (self.month(), self.day()) < (base.month(), base.day()) {\n            years -= 1;\n        }\n\n        match years >= 0 {\n            true => Some(years as u32),\n            false => None,\n        }\n    }\n\n    /// Formats the date with the specified formatting items.\n    /// Otherwise it is the same as the ordinary `format` method.\n    ///\n    /// The `Iterator` of items should be `Clone`able,\n    /// since the resulting `DelayedFormat` value may be formatted multiple times.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    /// use chrono::format::strftime::StrftimeItems;\n    ///\n    /// let fmt = StrftimeItems::new(\"%Y-%m-%d\");\n    /// let d = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap();\n    /// assert_eq!(d.format_with_items(fmt.clone()).to_string(), \"2015-09-05\");\n    /// assert_eq!(d.format(\"%Y-%m-%d\").to_string(),             \"2015-09-05\");\n    /// ```\n    ///\n    /// The resulting `DelayedFormat` can be formatted directly via the `Display` trait.\n    ///\n    /// ```\n    /// # use chrono::NaiveDate;\n    /// # use chrono::format::strftime::StrftimeItems;\n    /// # let fmt = StrftimeItems::new(\"%Y-%m-%d\").clone();\n    /// # let d = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap();\n    /// assert_eq!(format!(\"{}\", d.format_with_items(fmt)), \"2015-09-05\");\n    /// ```\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[inline]\n    #[must_use]\n    pub fn format_with_items<'a, I, B>(&self, items: I) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,\n    {\n        DelayedFormat::new(Some(*self), None, items)\n    }\n\n    /// Formats the date with the specified format string.\n    /// See the [`format::strftime` module](../format/strftime/index.html)\n    /// on the supported escape sequences.\n    ///\n    /// This returns a `DelayedFormat`,\n    /// which gets converted to a string only when actual formatting happens.\n    /// You may use the `to_string` method to get a `String`,\n    /// or just feed it into `print!` and other formatting macros.\n    /// (In this way it avoids the redundant memory allocation.)\n    ///\n    /// A wrong format string does *not* issue an error immediately.\n    /// Rather, converting or formatting the `DelayedFormat` fails.\n    /// You are recommended to immediately use `DelayedFormat` for this reason.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let d = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap();\n    /// assert_eq!(d.format(\"%Y-%m-%d\").to_string(), \"2015-09-05\");\n    /// assert_eq!(d.format(\"%A, %-d %B, %C%y\").to_string(), \"Saturday, 5 September, 2015\");\n    /// ```\n    ///\n    /// The resulting `DelayedFormat` can be formatted directly via the `Display` trait.\n    ///\n    /// ```\n    /// # use chrono::NaiveDate;\n    /// # let d = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap();\n    /// assert_eq!(format!(\"{}\", d.format(\"%Y-%m-%d\")), \"2015-09-05\");\n    /// assert_eq!(format!(\"{}\", d.format(\"%A, %-d %B, %C%y\")), \"Saturday, 5 September, 2015\");\n    /// ```\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[inline]\n    #[must_use]\n    pub fn format<'a>(&self, fmt: &'a str) -> DelayedFormat<StrftimeItems<'a>> {\n        self.format_with_items(StrftimeItems::new(fmt))\n    }\n\n    /// Formats the date with the specified formatting items and locale.\n    #[cfg(feature = \"unstable-locales\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"unstable-locales\")))]\n    #[inline]\n    #[must_use]\n    pub fn format_localized_with_items<'a, I, B>(\n        &self,\n        items: I,\n        locale: Locale,\n    ) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,\n    {\n        DelayedFormat::new_with_locale(Some(*self), None, items, locale)\n    }\n\n    /// Formats the date with the specified format string and locale.\n    ///\n    /// See the [`crate::format::strftime`] module on the supported escape\n    /// sequences.\n    #[cfg(feature = \"unstable-locales\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"unstable-locales\")))]\n    #[inline]\n    #[must_use]\n    pub fn format_localized<'a>(\n        &self,\n        fmt: &'a str,\n        locale: Locale,\n    ) -> DelayedFormat<StrftimeItems<'a>> {\n        self.format_localized_with_items(StrftimeItems::new_with_locale(fmt, locale), locale)\n    }\n\n    /// Returns an iterator that steps by days across all representable dates.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use chrono::NaiveDate;\n    ///\n    /// let expected = [\n    ///     NaiveDate::from_ymd_opt(2016, 2, 27).unwrap(),\n    ///     NaiveDate::from_ymd_opt(2016, 2, 28).unwrap(),\n    ///     NaiveDate::from_ymd_opt(2016, 2, 29).unwrap(),\n    ///     NaiveDate::from_ymd_opt(2016, 3, 1).unwrap(),\n    /// ];\n    ///\n    /// let mut count = 0;\n    /// for (idx, d) in NaiveDate::from_ymd_opt(2016, 2, 27).unwrap().iter_days().take(4).enumerate() {\n    ///    assert_eq!(d, expected[idx]);\n    ///    count += 1;\n    /// }\n    /// assert_eq!(count, 4);\n    ///\n    /// for d in NaiveDate::from_ymd_opt(2016, 3, 1).unwrap().iter_days().rev().take(4) {\n    ///     count -= 1;\n    ///     assert_eq!(d, expected[count]);\n    /// }\n    /// ```\n    #[inline]\n    pub const fn iter_days(&self) -> NaiveDateDaysIterator {\n        NaiveDateDaysIterator { value: *self }\n    }\n\n    /// Returns an iterator that steps by weeks across all representable dates.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use chrono::NaiveDate;\n    ///\n    /// let expected = [\n    ///     NaiveDate::from_ymd_opt(2016, 2, 27).unwrap(),\n    ///     NaiveDate::from_ymd_opt(2016, 3, 5).unwrap(),\n    ///     NaiveDate::from_ymd_opt(2016, 3, 12).unwrap(),\n    ///     NaiveDate::from_ymd_opt(2016, 3, 19).unwrap(),\n    /// ];\n    ///\n    /// let mut count = 0;\n    /// for (idx, d) in NaiveDate::from_ymd_opt(2016, 2, 27).unwrap().iter_weeks().take(4).enumerate() {\n    ///    assert_eq!(d, expected[idx]);\n    ///    count += 1;\n    /// }\n    /// assert_eq!(count, 4);\n    ///\n    /// for d in NaiveDate::from_ymd_opt(2016, 3, 19).unwrap().iter_weeks().rev().take(4) {\n    ///     count -= 1;\n    ///     assert_eq!(d, expected[count]);\n    /// }\n    /// ```\n    #[inline]\n    pub const fn iter_weeks(&self) -> NaiveDateWeeksIterator {\n        NaiveDateWeeksIterator { value: *self }\n    }\n\n    /// Returns the [`NaiveWeek`] that the date belongs to, starting with the [`Weekday`]\n    /// specified.\n    #[inline]\n    pub const fn week(&self, start: Weekday) -> NaiveWeek {\n        NaiveWeek { date: *self, start }\n    }\n\n    /// The minimum possible `NaiveDate` (January 1, 262145 BCE).\n    pub const MIN: NaiveDate = NaiveDate { ymdf: (MIN_YEAR << 13) | (1 << 4) | 0o07 /*FE*/ };\n    /// The maximum possible `NaiveDate` (December 31, 262143 CE).\n    pub const MAX: NaiveDate = NaiveDate { ymdf: (MAX_YEAR << 13) | (365 << 4) | 0o17 /*F*/ };\n}","impl Sub<Days> for NaiveDate {\n    type Output = NaiveDate;\n\n    fn sub(self, days: Days) -> Self::Output {\n        self.checked_sub_days(days).unwrap()\n    }\n}","impl Sub<Months> for NaiveDate {\n    type Output = NaiveDate;\n\n    /// A subtraction of Months from `NaiveDate` clamped to valid days in resulting month.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the resulting date would be out of range.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Months};\n    ///\n    /// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n    ///\n    /// assert_eq!(from_ymd(2014, 1, 1) - Months::new(11), from_ymd(2013, 2, 1));\n    /// assert_eq!(from_ymd(2014, 1, 1) - Months::new(12), from_ymd(2013, 1, 1));\n    /// assert_eq!(from_ymd(2014, 1, 1) - Months::new(13), from_ymd(2012, 12, 1));\n    /// ```\n    fn sub(self, months: Months) -> Self::Output {\n        self.checked_sub_months(months).unwrap()\n    }\n}","impl Sub<NaiveDate> for NaiveDate {\n    type Output = OldDuration;\n\n    #[inline]\n    fn sub(self, rhs: NaiveDate) -> OldDuration {\n        self.signed_duration_since(rhs)\n    }\n}","impl Sub<OldDuration> for NaiveDate {\n    type Output = NaiveDate;\n\n    #[inline]\n    fn sub(self, rhs: OldDuration) -> NaiveDate {\n        self.checked_sub_signed(rhs).expect(\"`NaiveDate - Duration` overflowed\")\n    }\n}","impl SubAssign<OldDuration> for NaiveDate {\n    #[inline]\n    fn sub_assign(&mut self, rhs: OldDuration) {\n        *self = self.sub(rhs);\n    }\n}","impl fmt::Debug for NaiveDate {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use core::fmt::Write;\n\n        let year = self.year();\n        let mdf = self.mdf();\n        if (0..=9999).contains(&year) {\n            write_hundreds(f, (year / 100) as u8)?;\n            write_hundreds(f, (year % 100) as u8)?;\n        } else {\n            // ISO 8601 requires the explicit sign for out-of-range years\n            write!(f, \"{:+05}\", year)?;\n        }\n\n        f.write_char('-')?;\n        write_hundreds(f, mdf.month() as u8)?;\n        f.write_char('-')?;\n        write_hundreds(f, mdf.day() as u8)\n    }\n}","impl fmt::Display for NaiveDate {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(self, f)\n    }\n}","impl str::FromStr for NaiveDate {\n    type Err = ParseError;\n\n    fn from_str(s: &str) -> ParseResult<NaiveDate> {\n        const ITEMS: &[Item<'static>] = &[\n            Item::Numeric(Numeric::Year, Pad::Zero),\n            Item::Literal(\"-\"),\n            Item::Numeric(Numeric::Month, Pad::Zero),\n            Item::Literal(\"-\"),\n            Item::Numeric(Numeric::Day, Pad::Zero),\n        ];\n\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, ITEMS.iter())?;\n        parsed.to_naive_date()\n    }\n}"],"naive::date::NaiveDateDaysIterator":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl DoubleEndedIterator for NaiveDateDaysIterator {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.value == NaiveDate::MIN {\n            return None;\n        }\n        let current = self.value;\n        self.value = current.pred_opt().unwrap();\n        Some(current)\n    }\n}","impl ExactSizeIterator for NaiveDateDaysIterator {}","impl Iterator for NaiveDateDaysIterator {\n    type Item = NaiveDate;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.value == NaiveDate::MAX {\n            return None;\n        }\n        // current < NaiveDate::MAX from here on:\n        let current = self.value;\n        // This can't panic because current is < NaiveDate::MAX:\n        self.value = current.succ_opt().unwrap();\n        Some(current)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let exact_size = NaiveDate::MAX.signed_duration_since(self.value).num_days();\n        (exact_size as usize, Some(exact_size as usize))\n    }\n}"],"naive::date::NaiveDateWeeksIterator":["Clone","Copy","Debug","Eq","Hash","Ord","PartialEq","PartialOrd","impl DoubleEndedIterator for NaiveDateWeeksIterator {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.value - NaiveDate::MIN < OldDuration::weeks(1) {\n            return None;\n        }\n        let current = self.value;\n        self.value = current - OldDuration::weeks(1);\n        Some(current)\n    }\n}","impl ExactSizeIterator for NaiveDateWeeksIterator {}","impl Iterator for NaiveDateWeeksIterator {\n    type Item = NaiveDate;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if NaiveDate::MAX - self.value < OldDuration::weeks(1) {\n            return None;\n        }\n        let current = self.value;\n        self.value = current + OldDuration::weeks(1);\n        Some(current)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let exact_size = NaiveDate::MAX.signed_duration_since(self.value).num_weeks();\n        (exact_size as usize, Some(exact_size as usize))\n    }\n}"],"naive::date::NaiveWeek":["Debug","impl NaiveWeek {\n    /// Returns a date representing the first day of the week.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Weekday};\n    ///\n    /// let date = NaiveDate::from_ymd_opt(2022, 4, 18).unwrap();\n    /// let week = date.week(Weekday::Mon);\n    /// assert!(week.first_day() <= date);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn first_day(&self) -> NaiveDate {\n        let start = self.start.num_days_from_monday() as i32;\n        let ref_day = self.date.weekday().num_days_from_monday() as i32;\n        // Calculate the number of days to subtract from `self.date`.\n        // Do not construct an intermediate date beyond `self.date`, because that may be out of\n        // range if `date` is close to `NaiveDate::MAX`.\n        let days = start - ref_day - if start > ref_day { 7 } else { 0 };\n        self.date.diff_days(days as i64).unwrap()\n    }\n\n    /// Returns a date representing the last day of the week.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Weekday};\n    ///\n    /// let date = NaiveDate::from_ymd_opt(2022, 4, 18).unwrap();\n    /// let week = date.week(Weekday::Mon);\n    /// assert!(week.last_day() >= date);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn last_day(&self) -> NaiveDate {\n        let end = self.start.pred().num_days_from_monday() as i32;\n        let ref_day = self.date.weekday().num_days_from_monday() as i32;\n        // Calculate the number of days to add to `self.date`.\n        // Do not construct an intermediate date before `self.date` (like with `first_day()`),\n        // because that may be out of range if `date` is close to `NaiveDate::MIN`.\n        let days = end - ref_day + if end < ref_day { 7 } else { 0 };\n        self.date.diff_days(days as i64).unwrap()\n    }\n\n    /// Returns a [`RangeInclusive<T>`] representing the whole week bounded by\n    /// [first_day](./struct.NaiveWeek.html#method.first_day) and\n    /// [last_day](./struct.NaiveWeek.html#method.last_day) functions.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Weekday};\n    ///\n    /// let date = NaiveDate::from_ymd_opt(2022, 4, 18).unwrap();\n    /// let week = date.week(Weekday::Mon);\n    /// let days = week.days();\n    /// assert!(days.contains(&date));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn days(&self) -> RangeInclusive<NaiveDate> {\n        self.first_day()..=self.last_day()\n    }\n}"],"naive::datetime::NaiveDateTime":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl Add<Days> for NaiveDateTime {\n    type Output = NaiveDateTime;\n\n    fn add(self, days: Days) -> Self::Output {\n        self.checked_add_days(days).unwrap()\n    }\n}","impl Add<FixedOffset> for NaiveDateTime {\n    type Output = NaiveDateTime;\n\n    #[inline]\n    fn add(self, rhs: FixedOffset) -> NaiveDateTime {\n        add_with_leapsecond(&self, rhs.local_minus_utc)\n    }\n}","impl Add<Months> for NaiveDateTime {\n    type Output = NaiveDateTime;\n\n    /// An addition of months to `NaiveDateTime` clamped to valid days in resulting month.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the resulting date would be out of range.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Months, NaiveDate};\n    ///\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(1, 0, 0).unwrap() + Months::new(1),\n    ///     NaiveDate::from_ymd_opt(2014, 2, 1).unwrap().and_hms_opt(1, 0, 0).unwrap()\n    /// );\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(0, 2, 0).unwrap() + Months::new(11),\n    ///     NaiveDate::from_ymd_opt(2014, 12, 1).unwrap().and_hms_opt(0, 2, 0).unwrap()\n    /// );\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(0, 0, 3).unwrap() + Months::new(12),\n    ///     NaiveDate::from_ymd_opt(2015, 1, 1).unwrap().and_hms_opt(0, 0, 3).unwrap()\n    /// );\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(0, 0, 4).unwrap() + Months::new(13),\n    ///     NaiveDate::from_ymd_opt(2015, 2, 1).unwrap().and_hms_opt(0, 0, 4).unwrap()\n    /// );\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2014, 1, 31).unwrap().and_hms_opt(0, 5, 0).unwrap() + Months::new(1),\n    ///     NaiveDate::from_ymd_opt(2014, 2, 28).unwrap().and_hms_opt(0, 5, 0).unwrap()\n    /// );\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2020, 1, 31).unwrap().and_hms_opt(6, 0, 0).unwrap() + Months::new(1),\n    ///     NaiveDate::from_ymd_opt(2020, 2, 29).unwrap().and_hms_opt(6, 0, 0).unwrap()\n    /// );\n    /// ```\n    fn add(self, rhs: Months) -> Self::Output {\n        Self { date: self.date.checked_add_months(rhs).unwrap(), time: self.time }\n    }\n}","impl Add<OldDuration> for NaiveDateTime {\n    type Output = NaiveDateTime;\n\n    #[inline]\n    fn add(self, rhs: OldDuration) -> NaiveDateTime {\n        self.checked_add_signed(rhs).expect(\"`NaiveDateTime + Duration` overflowed\")\n    }\n}","impl AddAssign<OldDuration> for NaiveDateTime {\n    #[inline]\n    fn add_assign(&mut self, rhs: OldDuration) {\n        *self = self.add(rhs);\n    }\n}","impl Datelike for NaiveDateTime {\n    /// Returns the year number in the [calendar date](./struct.NaiveDate.html#calendar-date).\n    ///\n    /// See also the [`NaiveDate::year`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.year(), 2015);\n    /// ```\n    #[inline]\n    fn year(&self) -> i32 {\n        self.date.year()\n    }\n\n    /// Returns the month number starting from 1.\n    ///\n    /// The return value ranges from 1 to 12.\n    ///\n    /// See also the [`NaiveDate::month`](./struct.NaiveDate.html#method.month) method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.month(), 9);\n    /// ```\n    #[inline]\n    fn month(&self) -> u32 {\n        self.date.month()\n    }\n\n    /// Returns the month number starting from 0.\n    ///\n    /// The return value ranges from 0 to 11.\n    ///\n    /// See also the [`NaiveDate::month0`](./struct.NaiveDate.html#method.month0) method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.month0(), 8);\n    /// ```\n    #[inline]\n    fn month0(&self) -> u32 {\n        self.date.month0()\n    }\n\n    /// Returns the day of month starting from 1.\n    ///\n    /// The return value ranges from 1 to 31. (The last day of month differs by months.)\n    ///\n    /// See also the [`NaiveDate::day`](./struct.NaiveDate.html#method.day) method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.day(), 25);\n    /// ```\n    #[inline]\n    fn day(&self) -> u32 {\n        self.date.day()\n    }\n\n    /// Returns the day of month starting from 0.\n    ///\n    /// The return value ranges from 0 to 30. (The last day of month differs by months.)\n    ///\n    /// See also the [`NaiveDate::day0`](./struct.NaiveDate.html#method.day0) method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.day0(), 24);\n    /// ```\n    #[inline]\n    fn day0(&self) -> u32 {\n        self.date.day0()\n    }\n\n    /// Returns the day of year starting from 1.\n    ///\n    /// The return value ranges from 1 to 366. (The last day of year differs by years.)\n    ///\n    /// See also the [`NaiveDate::ordinal`](./struct.NaiveDate.html#method.ordinal) method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.ordinal(), 268);\n    /// ```\n    #[inline]\n    fn ordinal(&self) -> u32 {\n        self.date.ordinal()\n    }\n\n    /// Returns the day of year starting from 0.\n    ///\n    /// The return value ranges from 0 to 365. (The last day of year differs by years.)\n    ///\n    /// See also the [`NaiveDate::ordinal0`](./struct.NaiveDate.html#method.ordinal0) method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.ordinal0(), 267);\n    /// ```\n    #[inline]\n    fn ordinal0(&self) -> u32 {\n        self.date.ordinal0()\n    }\n\n    /// Returns the day of week.\n    ///\n    /// See also the [`NaiveDate::weekday`](./struct.NaiveDate.html#method.weekday) method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike, Weekday};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.weekday(), Weekday::Fri);\n    /// ```\n    #[inline]\n    fn weekday(&self) -> Weekday {\n        self.date.weekday()\n    }\n\n    #[inline]\n    fn iso_week(&self) -> IsoWeek {\n        self.date.iso_week()\n    }\n\n    /// Makes a new `NaiveDateTime` with the year number changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n    ///\n    /// See also the [`NaiveDate::with_year`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.with_year(2016), Some(NaiveDate::from_ymd_opt(2016, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// assert_eq!(dt.with_year(-308), Some(NaiveDate::from_ymd_opt(-308, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// ```\n    #[inline]\n    fn with_year(&self, year: i32) -> Option<NaiveDateTime> {\n        self.date.with_year(year).map(|d| NaiveDateTime { date: d, ..*self })\n    }\n\n    /// Makes a new `NaiveDateTime` with the month number (starting from 1) changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n    ///\n    /// See also the [`NaiveDate::with_month`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 30).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.with_month(10), Some(NaiveDate::from_ymd_opt(2015, 10, 30).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// assert_eq!(dt.with_month(13), None); // no month 13\n    /// assert_eq!(dt.with_month(2), None); // no February 30\n    /// ```\n    #[inline]\n    fn with_month(&self, month: u32) -> Option<NaiveDateTime> {\n        self.date.with_month(month).map(|d| NaiveDateTime { date: d, ..*self })\n    }\n\n    /// Makes a new `NaiveDateTime` with the month number (starting from 0) changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n    ///\n    /// See also the [`NaiveDate::with_month0`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 30).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.with_month0(9), Some(NaiveDate::from_ymd_opt(2015, 10, 30).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// assert_eq!(dt.with_month0(12), None); // no month 13\n    /// assert_eq!(dt.with_month0(1), None); // no February 30\n    /// ```\n    #[inline]\n    fn with_month0(&self, month0: u32) -> Option<NaiveDateTime> {\n        self.date.with_month0(month0).map(|d| NaiveDateTime { date: d, ..*self })\n    }\n\n    /// Makes a new `NaiveDateTime` with the day of month (starting from 1) changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n    ///\n    /// See also the [`NaiveDate::with_day`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.with_day(30), Some(NaiveDate::from_ymd_opt(2015, 9, 30).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// assert_eq!(dt.with_day(31), None); // no September 31\n    /// ```\n    #[inline]\n    fn with_day(&self, day: u32) -> Option<NaiveDateTime> {\n        self.date.with_day(day).map(|d| NaiveDateTime { date: d, ..*self })\n    }\n\n    /// Makes a new `NaiveDateTime` with the day of month (starting from 0) changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n    ///\n    /// See also the [`NaiveDate::with_day0`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.with_day0(29), Some(NaiveDate::from_ymd_opt(2015, 9, 30).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// assert_eq!(dt.with_day0(30), None); // no September 31\n    /// ```\n    #[inline]\n    fn with_day0(&self, day0: u32) -> Option<NaiveDateTime> {\n        self.date.with_day0(day0).map(|d| NaiveDateTime { date: d, ..*self })\n    }\n\n    /// Makes a new `NaiveDateTime` with the day of year (starting from 1) changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n    ///\n    /// See also the [`NaiveDate::with_ordinal`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.with_ordinal(60),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 3, 1).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// assert_eq!(dt.with_ordinal(366), None); // 2015 had only 365 days\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2016, 9, 8).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.with_ordinal(60),\n    ///            Some(NaiveDate::from_ymd_opt(2016, 2, 29).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// assert_eq!(dt.with_ordinal(366),\n    ///            Some(NaiveDate::from_ymd_opt(2016, 12, 31).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// ```\n    #[inline]\n    fn with_ordinal(&self, ordinal: u32) -> Option<NaiveDateTime> {\n        self.date.with_ordinal(ordinal).map(|d| NaiveDateTime { date: d, ..*self })\n    }\n\n    /// Makes a new `NaiveDateTime` with the day of year (starting from 0) changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n    ///\n    /// See also the [`NaiveDate::with_ordinal0`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.with_ordinal0(59),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 3, 1).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// assert_eq!(dt.with_ordinal0(365), None); // 2015 had only 365 days\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2016, 9, 8).unwrap().and_hms_opt(12, 34, 56).unwrap();\n    /// assert_eq!(dt.with_ordinal0(59),\n    ///            Some(NaiveDate::from_ymd_opt(2016, 2, 29).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// assert_eq!(dt.with_ordinal0(365),\n    ///            Some(NaiveDate::from_ymd_opt(2016, 12, 31).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// ```\n    #[inline]\n    fn with_ordinal0(&self, ordinal0: u32) -> Option<NaiveDateTime> {\n        self.date.with_ordinal0(ordinal0).map(|d| NaiveDateTime { date: d, ..*self })\n    }\n}","impl Default for NaiveDateTime {\n    fn default() -> Self {\n        NaiveDateTime::from_timestamp_opt(0, 0).unwrap()\n    }\n}","impl DurationRound for NaiveDateTime {\n    type Err = RoundingError;\n\n    fn duration_round(self, duration: Duration) -> Result<Self, Self::Err> {\n        duration_round(self, self, duration)\n    }\n\n    fn duration_trunc(self, duration: Duration) -> Result<Self, Self::Err> {\n        duration_trunc(self, self, duration)\n    }\n}","impl NaiveDateTime {\n    /// Makes a new `NaiveDateTime` from date and time components.\n    /// Equivalent to [`date.and_time(time)`](./struct.NaiveDate.html#method.and_time)\n    /// and many other helper constructors on `NaiveDate`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveTime, NaiveDateTime};\n    ///\n    /// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n    /// let t = NaiveTime::from_hms_milli_opt(12, 34, 56, 789).unwrap();\n    ///\n    /// let dt = NaiveDateTime::new(d, t);\n    /// assert_eq!(dt.date(), d);\n    /// assert_eq!(dt.time(), t);\n    /// ```\n    #[inline]\n    pub const fn new(date: NaiveDate, time: NaiveTime) -> NaiveDateTime {\n        NaiveDateTime { date, time }\n    }\n\n    /// Makes a new `NaiveDateTime` corresponding to a UTC date and time,\n    /// from the number of non-leap seconds\n    /// since the midnight UTC on January 1, 1970 (aka \"UNIX timestamp\")\n    /// and the number of nanoseconds since the last whole non-leap second.\n    ///\n    /// For a non-naive version of this function see\n    /// [`TimeZone::timestamp`](../offset/trait.TimeZone.html#method.timestamp).\n    ///\n    /// The nanosecond part can exceed 1,000,000,000 in order to represent the\n    /// [leap second](./struct.NaiveTime.html#leap-second-handling). (The true \"UNIX\n    /// timestamp\" cannot represent a leap second unambiguously.)\n    ///\n    /// Panics on the out-of-range number of seconds and/or invalid nanosecond.\n    #[deprecated(since = \"0.4.23\", note = \"use `from_timestamp_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn from_timestamp(secs: i64, nsecs: u32) -> NaiveDateTime {\n        let datetime = NaiveDateTime::from_timestamp_opt(secs, nsecs);\n        datetime.expect(\"invalid or out-of-range datetime\")\n    }\n\n    /// Creates a new [NaiveDateTime] from milliseconds since the UNIX epoch.\n    ///\n    /// The UNIX epoch starts on midnight, January 1, 1970, UTC.\n    ///\n    /// Returns `None` on an out-of-range number of milliseconds.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDateTime;\n    /// let timestamp_millis: i64 = 1662921288000; //Sunday, September 11, 2022 6:34:48 PM\n    /// let naive_datetime = NaiveDateTime::from_timestamp_millis(timestamp_millis);\n    /// assert!(naive_datetime.is_some());\n    /// assert_eq!(timestamp_millis, naive_datetime.unwrap().timestamp_millis());\n    ///\n    /// // Negative timestamps (before the UNIX epoch) are supported as well.\n    /// let timestamp_millis: i64 = -2208936075000; //Mon Jan 01 1900 14:38:45 GMT+0000\n    /// let naive_datetime = NaiveDateTime::from_timestamp_millis(timestamp_millis);\n    /// assert!(naive_datetime.is_some());\n    /// assert_eq!(timestamp_millis, naive_datetime.unwrap().timestamp_millis());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn from_timestamp_millis(millis: i64) -> Option<NaiveDateTime> {\n        let secs = millis.div_euclid(1000);\n        let nsecs = millis.rem_euclid(1000) as u32 * 1_000_000;\n        NaiveDateTime::from_timestamp_opt(secs, nsecs)\n    }\n\n    /// Creates a new [NaiveDateTime] from microseconds since the UNIX epoch.\n    ///\n    /// The UNIX epoch starts on midnight, January 1, 1970, UTC.\n    ///\n    /// Returns `None` on an out-of-range number of microseconds.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDateTime;\n    /// let timestamp_micros: i64 = 1662921288000000; //Sunday, September 11, 2022 6:34:48 PM\n    /// let naive_datetime = NaiveDateTime::from_timestamp_micros(timestamp_micros);\n    /// assert!(naive_datetime.is_some());\n    /// assert_eq!(timestamp_micros, naive_datetime.unwrap().timestamp_micros());\n    ///\n    /// // Negative timestamps (before the UNIX epoch) are supported as well.\n    /// let timestamp_micros: i64 = -2208936075000000; //Mon Jan 01 1900 14:38:45 GMT+0000\n    /// let naive_datetime = NaiveDateTime::from_timestamp_micros(timestamp_micros);\n    /// assert!(naive_datetime.is_some());\n    /// assert_eq!(timestamp_micros, naive_datetime.unwrap().timestamp_micros());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn from_timestamp_micros(micros: i64) -> Option<NaiveDateTime> {\n        let secs = micros.div_euclid(1_000_000);\n        let nsecs = micros.rem_euclid(1_000_000) as u32 * 1000;\n        NaiveDateTime::from_timestamp_opt(secs, nsecs)\n    }\n\n    /// Makes a new `NaiveDateTime` corresponding to a UTC date and time,\n    /// from the number of non-leap seconds\n    /// since the midnight UTC on January 1, 1970 (aka \"UNIX timestamp\")\n    /// and the number of nanoseconds since the last whole non-leap second.\n    ///\n    /// The nanosecond part can exceed 1,000,000,000\n    /// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n    /// (The true \"UNIX timestamp\" cannot represent a leap second unambiguously.)\n    ///\n    /// Returns `None` on the out-of-range number of seconds (more than 262 000 years away\n    /// from common era) and/or invalid nanosecond (2 seconds or more).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDateTime;\n    /// use std::i64;\n    ///\n    /// let from_timestamp_opt = NaiveDateTime::from_timestamp_opt;\n    ///\n    /// assert!(from_timestamp_opt(0, 0).is_some());\n    /// assert!(from_timestamp_opt(0, 999_999_999).is_some());\n    /// assert!(from_timestamp_opt(0, 1_500_000_000).is_some()); // leap second\n    /// assert!(from_timestamp_opt(0, 2_000_000_000).is_none());\n    /// assert!(from_timestamp_opt(i64::MAX, 0).is_none());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn from_timestamp_opt(secs: i64, nsecs: u32) -> Option<NaiveDateTime> {\n        let days = secs.div_euclid(86_400);\n        let secs = secs.rem_euclid(86_400);\n        let date = i32::try_from(days)\n            .ok()\n            .and_then(|days| days.checked_add(719_163))\n            .and_then(NaiveDate::from_num_days_from_ce_opt);\n        let time = NaiveTime::from_num_seconds_from_midnight_opt(secs as u32, nsecs);\n        match (date, time) {\n            (Some(date), Some(time)) => Some(NaiveDateTime { date, time }),\n            (_, _) => None,\n        }\n    }\n\n    /// Parses a string with the specified format string and returns a new `NaiveDateTime`.\n    /// See the [`format::strftime` module](../format/strftime/index.html)\n    /// on the supported escape sequences.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDateTime, NaiveDate};\n    ///\n    /// let parse_from_str = NaiveDateTime::parse_from_str;\n    ///\n    /// assert_eq!(parse_from_str(\"2015-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\"),\n    ///            Ok(NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap()));\n    /// assert_eq!(parse_from_str(\"5sep2015pm012345.6789\", \"%d%b%Y%p%I%M%S%.f\"),\n    ///            Ok(NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_micro_opt(13, 23, 45, 678_900).unwrap()));\n    /// ```\n    ///\n    /// Offset is ignored for the purpose of parsing.\n    ///\n    /// ```\n    /// # use chrono::{NaiveDateTime, NaiveDate};\n    /// # let parse_from_str = NaiveDateTime::parse_from_str;\n    /// assert_eq!(parse_from_str(\"2014-5-17T12:34:56+09:30\", \"%Y-%m-%dT%H:%M:%S%z\"),\n    ///            Ok(NaiveDate::from_ymd_opt(2014, 5, 17).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n    /// ```\n    ///\n    /// [Leap seconds](./struct.NaiveTime.html#leap-second-handling) are correctly handled by\n    /// treating any time of the form `hh:mm:60` as a leap second.\n    /// (This equally applies to the formatting, so the round trip is possible.)\n    ///\n    /// ```\n    /// # use chrono::{NaiveDateTime, NaiveDate};\n    /// # let parse_from_str = NaiveDateTime::parse_from_str;\n    /// assert_eq!(parse_from_str(\"2015-07-01 08:59:60.123\", \"%Y-%m-%d %H:%M:%S%.f\"),\n    ///            Ok(NaiveDate::from_ymd_opt(2015, 7, 1).unwrap().and_hms_milli_opt(8, 59, 59, 1_123).unwrap()));\n    /// ```\n    ///\n    /// Missing seconds are assumed to be zero,\n    /// but out-of-bound times or insufficient fields are errors otherwise.\n    ///\n    /// ```\n    /// # use chrono::{NaiveDateTime, NaiveDate};\n    /// # let parse_from_str = NaiveDateTime::parse_from_str;\n    /// assert_eq!(parse_from_str(\"94/9/4 7:15\", \"%y/%m/%d %H:%M\"),\n    ///            Ok(NaiveDate::from_ymd_opt(1994, 9, 4).unwrap().and_hms_opt(7, 15, 0).unwrap()));\n    ///\n    /// assert!(parse_from_str(\"04m33s\", \"%Mm%Ss\").is_err());\n    /// assert!(parse_from_str(\"94/9/4 12\", \"%y/%m/%d %H\").is_err());\n    /// assert!(parse_from_str(\"94/9/4 17:60\", \"%y/%m/%d %H:%M\").is_err());\n    /// assert!(parse_from_str(\"94/9/4 24:00:00\", \"%y/%m/%d %H:%M:%S\").is_err());\n    /// ```\n    ///\n    /// All parsed fields should be consistent to each other, otherwise it's an error.\n    ///\n    /// ```\n    /// # use chrono::NaiveDateTime;\n    /// # let parse_from_str = NaiveDateTime::parse_from_str;\n    /// let fmt = \"%Y-%m-%d %H:%M:%S = UNIX timestamp %s\";\n    /// assert!(parse_from_str(\"2001-09-09 01:46:39 = UNIX timestamp 999999999\", fmt).is_ok());\n    /// assert!(parse_from_str(\"1970-01-01 00:00:00 = UNIX timestamp 1\", fmt).is_err());\n    /// ```\n    ///\n    /// Years before 1 BCE or after 9999 CE, require an initial sign\n    ///\n    ///```\n    /// # use chrono::NaiveDateTime;\n    /// # let parse_from_str = NaiveDateTime::parse_from_str;\n    /// let fmt = \"%Y-%m-%d %H:%M:%S\";\n    /// assert!(parse_from_str(\"10000-09-09 01:46:39\", fmt).is_err());\n    /// assert!(parse_from_str(\"+10000-09-09 01:46:39\", fmt).is_ok());\n    ///```\n    pub fn parse_from_str(s: &str, fmt: &str) -> ParseResult<NaiveDateTime> {\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_naive_datetime_with_offset(0) // no offset adjustment\n    }\n\n    /// Parses a string with the specified format string and returns a new `NaiveDateTime`, and a\n    /// slice with the remaining portion of the string.\n    /// See the [`format::strftime` module](../format/strftime/index.html)\n    /// on the supported escape sequences.\n    ///\n    /// Similar to [`parse_from_str`](#method.parse_from_str).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use chrono::{NaiveDate, NaiveDateTime};\n    /// let (datetime, remainder) = NaiveDateTime::parse_and_remainder(\n    ///     \"2015-02-18 23:16:09 trailing text\", \"%Y-%m-%d %H:%M:%S\").unwrap();\n    /// assert_eq!(\n    ///     datetime,\n    ///     NaiveDate::from_ymd_opt(2015, 2, 18).unwrap().and_hms_opt(23, 16, 9).unwrap()\n    /// );\n    /// assert_eq!(remainder, \" trailing text\");\n    /// ```\n    pub fn parse_and_remainder<'a>(s: &'a str, fmt: &str) -> ParseResult<(NaiveDateTime, &'a str)> {\n        let mut parsed = Parsed::new();\n        let remainder = parse_and_remainder(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_naive_datetime_with_offset(0).map(|d| (d, remainder)) // no offset adjustment\n    }\n\n    /// Retrieves a date component.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_opt(9, 10, 11).unwrap();\n    /// assert_eq!(dt.date(), NaiveDate::from_ymd_opt(2016, 7, 8).unwrap());\n    /// ```\n    #[inline]\n    pub const fn date(&self) -> NaiveDate {\n        self.date\n    }\n\n    /// Retrieves a time component.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveTime};\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_opt(9, 10, 11).unwrap();\n    /// assert_eq!(dt.time(), NaiveTime::from_hms_opt(9, 10, 11).unwrap());\n    /// ```\n    #[inline]\n    pub const fn time(&self) -> NaiveTime {\n        self.time\n    }\n\n    /// Returns the number of non-leap seconds since the midnight on January 1, 1970.\n    ///\n    /// Note that this does *not* account for the timezone!\n    /// The true \"UNIX timestamp\" would count seconds since the midnight *UTC* on the epoch.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_milli_opt(0, 0, 1, 980).unwrap();\n    /// assert_eq!(dt.timestamp(), 1);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_opt(1, 46, 40).unwrap();\n    /// assert_eq!(dt.timestamp(), 1_000_000_000);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(1969, 12, 31).unwrap().and_hms_opt(23, 59, 59).unwrap();\n    /// assert_eq!(dt.timestamp(), -1);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(-1, 1, 1).unwrap().and_hms_opt(0, 0, 0).unwrap();\n    /// assert_eq!(dt.timestamp(), -62198755200);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn timestamp(&self) -> i64 {\n        const UNIX_EPOCH_DAY: i64 = 719_163;\n        let gregorian_day = i64::from(self.date.num_days_from_ce());\n        let seconds_from_midnight = i64::from(self.time.num_seconds_from_midnight());\n        (gregorian_day - UNIX_EPOCH_DAY) * 86_400 + seconds_from_midnight\n    }\n\n    /// Returns the number of non-leap *milliseconds* since midnight on January 1, 1970.\n    ///\n    /// Note that this does *not* account for the timezone!\n    /// The true \"UNIX timestamp\" would count seconds since the midnight *UTC* on the epoch.\n    ///\n    /// Note also that this does reduce the number of years that can be\n    /// represented from ~584 Billion to ~584 Million. (If this is a problem,\n    /// please file an issue to let me know what domain needs millisecond\n    /// precision over billions of years, I'm curious.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_milli_opt(0, 0, 1, 444).unwrap();\n    /// assert_eq!(dt.timestamp_millis(), 1_444);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_milli_opt(1, 46, 40, 555).unwrap();\n    /// assert_eq!(dt.timestamp_millis(), 1_000_000_000_555);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(1969, 12, 31).unwrap().and_hms_milli_opt(23, 59, 59, 100).unwrap();\n    /// assert_eq!(dt.timestamp_millis(), -900);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn timestamp_millis(&self) -> i64 {\n        let as_ms = self.timestamp() * 1000;\n        as_ms + i64::from(self.timestamp_subsec_millis())\n    }\n\n    /// Returns the number of non-leap *microseconds* since midnight on January 1, 1970.\n    ///\n    /// Note that this does *not* account for the timezone!\n    /// The true \"UNIX timestamp\" would count seconds since the midnight *UTC* on the epoch.\n    ///\n    /// Note also that this does reduce the number of years that can be\n    /// represented from ~584 Billion to ~584 Thousand. (If this is a problem,\n    /// please file an issue to let me know what domain needs microsecond\n    /// precision over millennia, I'm curious.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_micro_opt(0, 0, 1, 444).unwrap();\n    /// assert_eq!(dt.timestamp_micros(), 1_000_444);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_micro_opt(1, 46, 40, 555).unwrap();\n    /// assert_eq!(dt.timestamp_micros(), 1_000_000_000_000_555);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn timestamp_micros(&self) -> i64 {\n        let as_us = self.timestamp() * 1_000_000;\n        as_us + i64::from(self.timestamp_subsec_micros())\n    }\n\n    /// Returns the number of non-leap *nanoseconds* since midnight on January 1, 1970.\n    ///\n    /// Note that this does *not* account for the timezone!\n    /// The true \"UNIX timestamp\" would count seconds since the midnight *UTC* on the epoch.\n    ///\n    /// # Panics\n    ///\n    /// Note also that this does reduce the number of years that can be\n    /// represented from ~584 Billion to ~584 years. The dates that can be\n    /// represented as nanoseconds are between 1677-09-21T00:12:44.0 and\n    /// 2262-04-11T23:47:16.854775804.\n    ///\n    /// (If this is a problem, please file an issue to let me know what domain\n    /// needs nanosecond precision over millennia, I'm curious.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime};\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_nano_opt(0, 0, 1, 444).unwrap();\n    /// assert_eq!(dt.timestamp_nanos(), 1_000_000_444);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_nano_opt(1, 46, 40, 555).unwrap();\n    ///\n    /// const A_BILLION: i64 = 1_000_000_000;\n    /// let nanos = dt.timestamp_nanos();\n    /// assert_eq!(nanos, 1_000_000_000_000_000_555);\n    /// assert_eq!(\n    ///     Some(dt),\n    ///     NaiveDateTime::from_timestamp_opt(nanos / A_BILLION, (nanos % A_BILLION) as u32)\n    /// );\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn timestamp_nanos(&self) -> i64 {\n        let as_ns = self.timestamp() * 1_000_000_000;\n        as_ns + i64::from(self.timestamp_subsec_nanos())\n    }\n\n    /// Returns the number of milliseconds since the last whole non-leap second.\n    ///\n    /// The return value ranges from 0 to 999,\n    /// or for [leap seconds](./struct.NaiveTime.html#leap-second-handling), to 1,999.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_nano_opt(9, 10, 11, 123_456_789).unwrap();\n    /// assert_eq!(dt.timestamp_subsec_millis(), 123);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2015, 7, 1).unwrap().and_hms_nano_opt(8, 59, 59, 1_234_567_890).unwrap();\n    /// assert_eq!(dt.timestamp_subsec_millis(), 1_234);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn timestamp_subsec_millis(&self) -> u32 {\n        self.timestamp_subsec_nanos() / 1_000_000\n    }\n\n    /// Returns the number of microseconds since the last whole non-leap second.\n    ///\n    /// The return value ranges from 0 to 999,999,\n    /// or for [leap seconds](./struct.NaiveTime.html#leap-second-handling), to 1,999,999.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_nano_opt(9, 10, 11, 123_456_789).unwrap();\n    /// assert_eq!(dt.timestamp_subsec_micros(), 123_456);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2015, 7, 1).unwrap().and_hms_nano_opt(8, 59, 59, 1_234_567_890).unwrap();\n    /// assert_eq!(dt.timestamp_subsec_micros(), 1_234_567);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn timestamp_subsec_micros(&self) -> u32 {\n        self.timestamp_subsec_nanos() / 1_000\n    }\n\n    /// Returns the number of nanoseconds since the last whole non-leap second.\n    ///\n    /// The return value ranges from 0 to 999,999,999,\n    /// or for [leap seconds](./struct.NaiveTime.html#leap-second-handling), to 1,999,999,999.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_nano_opt(9, 10, 11, 123_456_789).unwrap();\n    /// assert_eq!(dt.timestamp_subsec_nanos(), 123_456_789);\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2015, 7, 1).unwrap().and_hms_nano_opt(8, 59, 59, 1_234_567_890).unwrap();\n    /// assert_eq!(dt.timestamp_subsec_nanos(), 1_234_567_890);\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn timestamp_subsec_nanos(&self) -> u32 {\n        self.time.nanosecond()\n    }\n\n    /// Adds given `Duration` to the current date and time.\n    ///\n    /// As a part of Chrono's [leap second handling](./struct.NaiveTime.html#leap-second-handling),\n    /// the addition assumes that **there is no leap second ever**,\n    /// except when the `NaiveDateTime` itself represents a leap second\n    /// in which case the assumption becomes that **there is exactly a single leap second ever**.\n    ///\n    /// Returns `None` when it will result in overflow.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Duration, NaiveDate};\n    ///\n    /// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n    ///\n    /// let d = from_ymd(2016, 7, 8);\n    /// let hms = |h, m, s| d.and_hms_opt(h, m, s).unwrap();\n    /// assert_eq!(hms(3, 5, 7).checked_add_signed(Duration::zero()),\n    ///            Some(hms(3, 5, 7)));\n    /// assert_eq!(hms(3, 5, 7).checked_add_signed(Duration::seconds(1)),\n    ///            Some(hms(3, 5, 8)));\n    /// assert_eq!(hms(3, 5, 7).checked_add_signed(Duration::seconds(-1)),\n    ///            Some(hms(3, 5, 6)));\n    /// assert_eq!(hms(3, 5, 7).checked_add_signed(Duration::seconds(3600 + 60)),\n    ///            Some(hms(4, 6, 7)));\n    /// assert_eq!(hms(3, 5, 7).checked_add_signed(Duration::seconds(86_400)),\n    ///            Some(from_ymd(2016, 7, 9).and_hms_opt(3, 5, 7).unwrap()));\n    ///\n    /// let hmsm = |h, m, s, milli| d.and_hms_milli_opt(h, m, s, milli).unwrap();\n    /// assert_eq!(hmsm(3, 5, 7, 980).checked_add_signed(Duration::milliseconds(450)),\n    ///            Some(hmsm(3, 5, 8, 430)));\n    /// ```\n    ///\n    /// Overflow returns `None`.\n    ///\n    /// ```\n    /// # use chrono::{Duration, NaiveDate};\n    /// # let hms = |h, m, s| NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_opt(h, m, s).unwrap();\n    /// assert_eq!(hms(3, 5, 7).checked_add_signed(Duration::days(1_000_000_000)), None);\n    /// ```\n    ///\n    /// Leap seconds are handled,\n    /// but the addition assumes that it is the only leap second happened.\n    ///\n    /// ```\n    /// # use chrono::{Duration, NaiveDate};\n    /// # let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n    /// # let hmsm = |h, m, s, milli| from_ymd(2016, 7, 8).and_hms_milli_opt(h, m, s, milli).unwrap();\n    /// let leap = hmsm(3, 5, 59, 1_300);\n    /// assert_eq!(leap.checked_add_signed(Duration::zero()),\n    ///            Some(hmsm(3, 5, 59, 1_300)));\n    /// assert_eq!(leap.checked_add_signed(Duration::milliseconds(-500)),\n    ///            Some(hmsm(3, 5, 59, 800)));\n    /// assert_eq!(leap.checked_add_signed(Duration::milliseconds(500)),\n    ///            Some(hmsm(3, 5, 59, 1_800)));\n    /// assert_eq!(leap.checked_add_signed(Duration::milliseconds(800)),\n    ///            Some(hmsm(3, 6, 0, 100)));\n    /// assert_eq!(leap.checked_add_signed(Duration::seconds(10)),\n    ///            Some(hmsm(3, 6, 9, 300)));\n    /// assert_eq!(leap.checked_add_signed(Duration::seconds(-10)),\n    ///            Some(hmsm(3, 5, 50, 300)));\n    /// assert_eq!(leap.checked_add_signed(Duration::days(1)),\n    ///            Some(from_ymd(2016, 7, 9).and_hms_milli_opt(3, 5, 59, 300).unwrap()));\n    /// ```\n    #[must_use]\n    pub fn checked_add_signed(self, rhs: OldDuration) -> Option<NaiveDateTime> {\n        let (time, rhs) = self.time.overflowing_add_signed(rhs);\n\n        // early checking to avoid overflow in OldDuration::seconds\n        if rhs <= (-1 << MAX_SECS_BITS) || rhs >= (1 << MAX_SECS_BITS) {\n            return None;\n        }\n\n        let date = self.date.checked_add_signed(OldDuration::seconds(rhs))?;\n        Some(NaiveDateTime { date, time })\n    }\n\n    /// Adds given `Months` to the current date and time.\n    ///\n    /// Returns `None` when it will result in overflow.\n    ///\n    /// Overflow returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Months, NaiveDate};\n    ///\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(1, 0, 0).unwrap()\n    ///         .checked_add_months(Months::new(1)),\n    ///     Some(NaiveDate::from_ymd_opt(2014, 2, 1).unwrap().and_hms_opt(1, 0, 0).unwrap())\n    /// );\n    ///\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(1, 0, 0).unwrap()\n    ///         .checked_add_months(Months::new(core::i32::MAX as u32 + 1)),\n    ///     None\n    /// );\n    /// ```\n    #[must_use]\n    pub fn checked_add_months(self, rhs: Months) -> Option<NaiveDateTime> {\n        Some(Self { date: self.date.checked_add_months(rhs)?, time: self.time })\n    }\n\n    /// Subtracts given `Duration` from the current date and time.\n    ///\n    /// As a part of Chrono's [leap second handling](./struct.NaiveTime.html#leap-second-handling),\n    /// the subtraction assumes that **there is no leap second ever**,\n    /// except when the `NaiveDateTime` itself represents a leap second\n    /// in which case the assumption becomes that **there is exactly a single leap second ever**.\n    ///\n    /// Returns `None` when it will result in overflow.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Duration, NaiveDate};\n    ///\n    /// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n    ///\n    /// let d = from_ymd(2016, 7, 8);\n    /// let hms = |h, m, s| d.and_hms_opt(h, m, s).unwrap();\n    /// assert_eq!(hms(3, 5, 7).checked_sub_signed(Duration::zero()),\n    ///            Some(hms(3, 5, 7)));\n    /// assert_eq!(hms(3, 5, 7).checked_sub_signed(Duration::seconds(1)),\n    ///            Some(hms(3, 5, 6)));\n    /// assert_eq!(hms(3, 5, 7).checked_sub_signed(Duration::seconds(-1)),\n    ///            Some(hms(3, 5, 8)));\n    /// assert_eq!(hms(3, 5, 7).checked_sub_signed(Duration::seconds(3600 + 60)),\n    ///            Some(hms(2, 4, 7)));\n    /// assert_eq!(hms(3, 5, 7).checked_sub_signed(Duration::seconds(86_400)),\n    ///            Some(from_ymd(2016, 7, 7).and_hms_opt(3, 5, 7).unwrap()));\n    ///\n    /// let hmsm = |h, m, s, milli| d.and_hms_milli_opt(h, m, s, milli).unwrap();\n    /// assert_eq!(hmsm(3, 5, 7, 450).checked_sub_signed(Duration::milliseconds(670)),\n    ///            Some(hmsm(3, 5, 6, 780)));\n    /// ```\n    ///\n    /// Overflow returns `None`.\n    ///\n    /// ```\n    /// # use chrono::{Duration, NaiveDate};\n    /// # let hms = |h, m, s| NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_opt(h, m, s).unwrap();\n    /// assert_eq!(hms(3, 5, 7).checked_sub_signed(Duration::days(1_000_000_000)), None);\n    /// ```\n    ///\n    /// Leap seconds are handled,\n    /// but the subtraction assumes that it is the only leap second happened.\n    ///\n    /// ```\n    /// # use chrono::{Duration, NaiveDate};\n    /// # let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n    /// # let hmsm = |h, m, s, milli| from_ymd(2016, 7, 8).and_hms_milli_opt(h, m, s, milli).unwrap();\n    /// let leap = hmsm(3, 5, 59, 1_300);\n    /// assert_eq!(leap.checked_sub_signed(Duration::zero()),\n    ///            Some(hmsm(3, 5, 59, 1_300)));\n    /// assert_eq!(leap.checked_sub_signed(Duration::milliseconds(200)),\n    ///            Some(hmsm(3, 5, 59, 1_100)));\n    /// assert_eq!(leap.checked_sub_signed(Duration::milliseconds(500)),\n    ///            Some(hmsm(3, 5, 59, 800)));\n    /// assert_eq!(leap.checked_sub_signed(Duration::seconds(60)),\n    ///            Some(hmsm(3, 5, 0, 300)));\n    /// assert_eq!(leap.checked_sub_signed(Duration::days(1)),\n    ///            Some(from_ymd(2016, 7, 7).and_hms_milli_opt(3, 6, 0, 300).unwrap()));\n    /// ```\n    #[must_use]\n    pub fn checked_sub_signed(self, rhs: OldDuration) -> Option<NaiveDateTime> {\n        let (time, rhs) = self.time.overflowing_sub_signed(rhs);\n\n        // early checking to avoid overflow in OldDuration::seconds\n        if rhs <= (-1 << MAX_SECS_BITS) || rhs >= (1 << MAX_SECS_BITS) {\n            return None;\n        }\n\n        let date = self.date.checked_sub_signed(OldDuration::seconds(rhs))?;\n        Some(NaiveDateTime { date, time })\n    }\n\n    /// Subtracts given `Months` from the current date and time.\n    ///\n    /// Returns `None` when it will result in overflow.\n    ///\n    /// Overflow returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Months, NaiveDate};\n    ///\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(1, 0, 0).unwrap()\n    ///         .checked_sub_months(Months::new(1)),\n    ///     Some(NaiveDate::from_ymd_opt(2013, 12, 1).unwrap().and_hms_opt(1, 0, 0).unwrap())\n    /// );\n    ///\n    /// assert_eq!(\n    ///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(1, 0, 0).unwrap()\n    ///         .checked_sub_months(Months::new(core::i32::MAX as u32 + 1)),\n    ///     None\n    /// );\n    /// ```\n    #[must_use]\n    pub fn checked_sub_months(self, rhs: Months) -> Option<NaiveDateTime> {\n        Some(Self { date: self.date.checked_sub_months(rhs)?, time: self.time })\n    }\n\n    /// Add a duration in [`Days`] to the date part of the `NaiveDateTime`\n    ///\n    /// Returns `None` if the resulting date would be out of range.\n    #[must_use]\n    pub fn checked_add_days(self, days: Days) -> Option<Self> {\n        Some(Self { date: self.date.checked_add_days(days)?, ..self })\n    }\n\n    /// Subtract a duration in [`Days`] from the date part of the `NaiveDateTime`\n    ///\n    /// Returns `None` if the resulting date would be out of range.\n    #[must_use]\n    pub fn checked_sub_days(self, days: Days) -> Option<Self> {\n        Some(Self { date: self.date.checked_sub_days(days)?, ..self })\n    }\n\n    /// Subtracts another `NaiveDateTime` from the current date and time.\n    /// This does not overflow or underflow at all.\n    ///\n    /// As a part of Chrono's [leap second handling](./struct.NaiveTime.html#leap-second-handling),\n    /// the subtraction assumes that **there is no leap second ever**,\n    /// except when any of the `NaiveDateTime`s themselves represents a leap second\n    /// in which case the assumption becomes that\n    /// **there are exactly one (or two) leap second(s) ever**.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Duration, NaiveDate};\n    ///\n    /// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n    ///\n    /// let d = from_ymd(2016, 7, 8);\n    /// assert_eq!(d.and_hms_opt(3, 5, 7).unwrap().signed_duration_since(d.and_hms_opt(2, 4, 6).unwrap()),\n    ///            Duration::seconds(3600 + 60 + 1));\n    ///\n    /// // July 8 is 190th day in the year 2016\n    /// let d0 = from_ymd(2016, 1, 1);\n    /// assert_eq!(d.and_hms_milli_opt(0, 7, 6, 500).unwrap().signed_duration_since(d0.and_hms_opt(0, 0, 0).unwrap()),\n    ///            Duration::seconds(189 * 86_400 + 7 * 60 + 6) + Duration::milliseconds(500));\n    /// ```\n    ///\n    /// Leap seconds are handled, but the subtraction assumes that\n    /// there were no other leap seconds happened.\n    ///\n    /// ```\n    /// # use chrono::{Duration, NaiveDate};\n    /// # let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n    /// let leap = from_ymd(2015, 6, 30).and_hms_milli_opt(23, 59, 59, 1_500).unwrap();\n    /// assert_eq!(leap.signed_duration_since(from_ymd(2015, 6, 30).and_hms_opt(23, 0, 0).unwrap()),\n    ///            Duration::seconds(3600) + Duration::milliseconds(500));\n    /// assert_eq!(from_ymd(2015, 7, 1).and_hms_opt(1, 0, 0).unwrap().signed_duration_since(leap),\n    ///            Duration::seconds(3600) - Duration::milliseconds(500));\n    /// ```\n    #[must_use]\n    pub fn signed_duration_since(self, rhs: NaiveDateTime) -> OldDuration {\n        self.date.signed_duration_since(rhs.date) + self.time.signed_duration_since(rhs.time)\n    }\n\n    /// Formats the combined date and time with the specified formatting items.\n    /// Otherwise it is the same as the ordinary [`format`](#method.format) method.\n    ///\n    /// The `Iterator` of items should be `Clone`able,\n    /// since the resulting `DelayedFormat` value may be formatted multiple times.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    /// use chrono::format::strftime::StrftimeItems;\n    ///\n    /// let fmt = StrftimeItems::new(\"%Y-%m-%d %H:%M:%S\");\n    /// let dt = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap();\n    /// assert_eq!(dt.format_with_items(fmt.clone()).to_string(), \"2015-09-05 23:56:04\");\n    /// assert_eq!(dt.format(\"%Y-%m-%d %H:%M:%S\").to_string(),    \"2015-09-05 23:56:04\");\n    /// ```\n    ///\n    /// The resulting `DelayedFormat` can be formatted directly via the `Display` trait.\n    ///\n    /// ```\n    /// # use chrono::NaiveDate;\n    /// # use chrono::format::strftime::StrftimeItems;\n    /// # let fmt = StrftimeItems::new(\"%Y-%m-%d %H:%M:%S\").clone();\n    /// # let dt = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap();\n    /// assert_eq!(format!(\"{}\", dt.format_with_items(fmt)), \"2015-09-05 23:56:04\");\n    /// ```\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[inline]\n    #[must_use]\n    pub fn format_with_items<'a, I, B>(&self, items: I) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,\n    {\n        DelayedFormat::new(Some(self.date), Some(self.time), items)\n    }\n\n    /// Formats the combined date and time with the specified format string.\n    /// See the [`format::strftime` module](../format/strftime/index.html)\n    /// on the supported escape sequences.\n    ///\n    /// This returns a `DelayedFormat`,\n    /// which gets converted to a string only when actual formatting happens.\n    /// You may use the `to_string` method to get a `String`,\n    /// or just feed it into `print!` and other formatting macros.\n    /// (In this way it avoids the redundant memory allocation.)\n    ///\n    /// A wrong format string does *not* issue an error immediately.\n    /// Rather, converting or formatting the `DelayedFormat` fails.\n    /// You are recommended to immediately use `DelayedFormat` for this reason.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveDate;\n    ///\n    /// let dt = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap();\n    /// assert_eq!(dt.format(\"%Y-%m-%d %H:%M:%S\").to_string(), \"2015-09-05 23:56:04\");\n    /// assert_eq!(dt.format(\"around %l %p on %b %-d\").to_string(), \"around 11 PM on Sep 5\");\n    /// ```\n    ///\n    /// The resulting `DelayedFormat` can be formatted directly via the `Display` trait.\n    ///\n    /// ```\n    /// # use chrono::NaiveDate;\n    /// # let dt = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap();\n    /// assert_eq!(format!(\"{}\", dt.format(\"%Y-%m-%d %H:%M:%S\")), \"2015-09-05 23:56:04\");\n    /// assert_eq!(format!(\"{}\", dt.format(\"around %l %p on %b %-d\")), \"around 11 PM on Sep 5\");\n    /// ```\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[inline]\n    #[must_use]\n    pub fn format<'a>(&self, fmt: &'a str) -> DelayedFormat<StrftimeItems<'a>> {\n        self.format_with_items(StrftimeItems::new(fmt))\n    }\n\n    /// Converts the `NaiveDateTime` into the timezone-aware `DateTime<Tz>`\n    /// with the provided timezone, if possible.\n    ///\n    /// This can fail in cases where the local time represented by the `NaiveDateTime`\n    /// is not a valid local timestamp in the target timezone due to an offset transition\n    /// for example if the target timezone had a change from +00:00 to +01:00\n    /// occuring at 2015-09-05 22:59:59, then a local time of 2015-09-05 23:56:04\n    /// could never occur. Similarly, if the offset transitioned in the opposite direction\n    /// then there would be two local times of 2015-09-05 23:56:04, one at +00:00 and one\n    /// at +01:00.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, FixedOffset};\n    /// let hour = 3600;\n    /// let tz = FixedOffset::east_opt(5 * hour).unwrap();\n    /// let dt = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap().and_local_timezone(tz).unwrap();\n    /// assert_eq!(dt.timezone(), tz);\n    /// ```\n    #[must_use]\n    pub fn and_local_timezone<Tz: TimeZone>(&self, tz: Tz) -> LocalResult<DateTime<Tz>> {\n        tz.from_local_datetime(self)\n    }\n\n    /// Converts the `NaiveDateTime` into the timezone-aware `DateTime<Utc>`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Utc};\n    /// let dt = NaiveDate::from_ymd_opt(2023, 1, 30).unwrap().and_hms_opt(19, 32, 33).unwrap().and_utc();\n    /// assert_eq!(dt.timezone(), Utc);\n    /// ```\n    #[must_use]\n    pub fn and_utc(&self) -> DateTime<Utc> {\n        Utc.from_utc_datetime(self)\n    }\n\n    /// The minimum possible `NaiveDateTime`.\n    pub const MIN: Self = Self { date: NaiveDate::MIN, time: NaiveTime::MIN };\n    /// The maximum possible `NaiveDateTime`.\n    pub const MAX: Self = Self { date: NaiveDate::MAX, time: NaiveTime::MAX };\n}","impl Sub<Days> for NaiveDateTime {\n    type Output = NaiveDateTime;\n\n    fn sub(self, days: Days) -> Self::Output {\n        self.checked_sub_days(days).unwrap()\n    }\n}","impl Sub<FixedOffset> for NaiveDateTime {\n    type Output = NaiveDateTime;\n\n    #[inline]\n    fn sub(self, rhs: FixedOffset) -> NaiveDateTime {\n        add_with_leapsecond(&self, -rhs.local_minus_utc)\n    }\n}","impl Sub<Months> for NaiveDateTime {\n    type Output = NaiveDateTime;\n\n    fn sub(self, rhs: Months) -> Self::Output {\n        Self { date: self.date.checked_sub_months(rhs).unwrap(), time: self.time }\n    }\n}","impl Sub<NaiveDateTime> for NaiveDateTime {\n    type Output = OldDuration;\n\n    #[inline]\n    fn sub(self, rhs: NaiveDateTime) -> OldDuration {\n        self.signed_duration_since(rhs)\n    }\n}","impl Sub<OldDuration> for NaiveDateTime {\n    type Output = NaiveDateTime;\n\n    #[inline]\n    fn sub(self, rhs: OldDuration) -> NaiveDateTime {\n        self.checked_sub_signed(rhs).expect(\"`NaiveDateTime - Duration` overflowed\")\n    }\n}","impl SubAssign<OldDuration> for NaiveDateTime {\n    #[inline]\n    fn sub_assign(&mut self, rhs: OldDuration) {\n        *self = self.sub(rhs);\n    }\n}","impl Timelike for NaiveDateTime {\n    /// Returns the hour number from 0 to 23.\n    ///\n    /// See also the [`NaiveTime::hour`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n    /// assert_eq!(dt.hour(), 12);\n    /// ```\n    #[inline]\n    fn hour(&self) -> u32 {\n        self.time.hour()\n    }\n\n    /// Returns the minute number from 0 to 59.\n    ///\n    /// See also the [`NaiveTime::minute`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n    /// assert_eq!(dt.minute(), 34);\n    /// ```\n    #[inline]\n    fn minute(&self) -> u32 {\n        self.time.minute()\n    }\n\n    /// Returns the second number from 0 to 59.\n    ///\n    /// See also the [`NaiveTime::second`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n    /// assert_eq!(dt.second(), 56);\n    /// ```\n    #[inline]\n    fn second(&self) -> u32 {\n        self.time.second()\n    }\n\n    /// Returns the number of nanoseconds since the whole non-leap second.\n    /// The range from 1,000,000,000 to 1,999,999,999 represents\n    /// the [leap second](./struct.NaiveTime.html#leap-second-handling).\n    ///\n    /// See also the [`NaiveTime::nanosecond`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n    /// assert_eq!(dt.nanosecond(), 789_000_000);\n    /// ```\n    #[inline]\n    fn nanosecond(&self) -> u32 {\n        self.time.nanosecond()\n    }\n\n    /// Makes a new `NaiveDateTime` with the hour number changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n    ///\n    /// See also the [`NaiveTime::with_hour`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n    /// assert_eq!(dt.with_hour(7),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(7, 34, 56, 789).unwrap()));\n    /// assert_eq!(dt.with_hour(24), None);\n    /// ```\n    #[inline]\n    fn with_hour(&self, hour: u32) -> Option<NaiveDateTime> {\n        self.time.with_hour(hour).map(|t| NaiveDateTime { time: t, ..*self })\n    }\n\n    /// Makes a new `NaiveDateTime` with the minute number changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n    ///\n    /// See also the\n    /// [`NaiveTime::with_minute`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n    /// assert_eq!(dt.with_minute(45),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 45, 56, 789).unwrap()));\n    /// assert_eq!(dt.with_minute(60), None);\n    /// ```\n    #[inline]\n    fn with_minute(&self, min: u32) -> Option<NaiveDateTime> {\n        self.time.with_minute(min).map(|t| NaiveDateTime { time: t, ..*self })\n    }\n\n    /// Makes a new `NaiveDateTime` with the second number changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDateTime` would be invalid. As\n    /// with the [`NaiveDateTime::second`] method, the input range is\n    /// restricted to 0 through 59.\n    ///\n    /// See also the [`NaiveTime::with_second`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n    /// assert_eq!(dt.with_second(17),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 17, 789).unwrap()));\n    /// assert_eq!(dt.with_second(60), None);\n    /// ```\n    #[inline]\n    fn with_second(&self, sec: u32) -> Option<NaiveDateTime> {\n        self.time.with_second(sec).map(|t| NaiveDateTime { time: t, ..*self })\n    }\n\n    /// Makes a new `NaiveDateTime` with nanoseconds since the whole non-leap second changed.\n    ///\n    /// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n    /// As with the [`NaiveDateTime::nanosecond`] method,\n    /// the input range can exceed 1,000,000,000 for leap seconds.\n    ///\n    /// See also the [`NaiveTime::with_nanosecond`] method.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n    ///\n    /// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n    /// assert_eq!(dt.with_nanosecond(333_333_333),\n    ///            Some(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_nano_opt(12, 34, 56, 333_333_333).unwrap()));\n    /// assert_eq!(dt.with_nanosecond(1_333_333_333), // leap second\n    ///            Some(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_nano_opt(12, 34, 56, 1_333_333_333).unwrap()));\n    /// assert_eq!(dt.with_nanosecond(2_000_000_000), None);\n    /// ```\n    #[inline]\n    fn with_nanosecond(&self, nano: u32) -> Option<NaiveDateTime> {\n        self.time.with_nanosecond(nano).map(|t| NaiveDateTime { time: t, ..*self })\n    }\n}","impl fmt::Debug for NaiveDateTime {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.date.fmt(f)?;\n        f.write_char('T')?;\n        self.time.fmt(f)\n    }\n}","impl fmt::Display for NaiveDateTime {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.date.fmt(f)?;\n        f.write_char(' ')?;\n        self.time.fmt(f)\n    }\n}","impl str::FromStr for NaiveDateTime {\n    type Err = ParseError;\n\n    fn from_str(s: &str) -> ParseResult<NaiveDateTime> {\n        const ITEMS: &[Item<'static>] = &[\n            Item::Numeric(Numeric::Year, Pad::Zero),\n            Item::Space(\"\"),\n            Item::Literal(\"-\"),\n            Item::Numeric(Numeric::Month, Pad::Zero),\n            Item::Space(\"\"),\n            Item::Literal(\"-\"),\n            Item::Numeric(Numeric::Day, Pad::Zero),\n            Item::Space(\"\"),\n            Item::Literal(\"T\"), // XXX shouldn't this be case-insensitive?\n            Item::Numeric(Numeric::Hour, Pad::Zero),\n            Item::Space(\"\"),\n            Item::Literal(\":\"),\n            Item::Numeric(Numeric::Minute, Pad::Zero),\n            Item::Space(\"\"),\n            Item::Literal(\":\"),\n            Item::Numeric(Numeric::Second, Pad::Zero),\n            Item::Fixed(Fixed::Nanosecond),\n            Item::Space(\"\"),\n        ];\n\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, ITEMS.iter())?;\n        parsed.to_naive_datetime_with_offset(0)\n    }\n}"],"naive::internals::Mdf":["Clone","Copy","PartialEq","PartialOrd","impl Mdf {\n    #[inline]\n    pub(super) const fn new(month: u32, day: u32, YearFlags(flags): YearFlags) -> Option<Mdf> {\n        match month >= 1 && month <= 12 && day >= 1 && day <= 31 {\n            true => Some(Mdf((month << 9) | (day << 4) | flags as u32)),\n            false => None,\n        }\n    }\n\n    #[inline]\n    pub(super) const fn from_of(Of(of): Of) -> Mdf {\n        let ol = of >> 3;\n        if ol <= MAX_OL {\n            // Array is indexed from `[1..=MAX_OL]`, with a `0` index having a meaningless value.\n            Mdf(of + ((OL_TO_MDL[ol as usize] as u32) << 3))\n        } else {\n            // Panicking here would be reasonable, but we are just going on with a safe value.\n            Mdf(0)\n        }\n    }\n\n    #[cfg(test)]\n    pub(super) const fn valid(&self) -> bool {\n        let Mdf(mdf) = *self;\n        let mdl = mdf >> 3;\n        if mdl <= MAX_MDL {\n            // Array is indexed from `[1..=MAX_MDL]`, with a `0` index having a meaningless value.\n            MDL_TO_OL[mdl as usize] >= 0\n        } else {\n            // Panicking here would be reasonable, but we are just going on with a safe value.\n            false\n        }\n    }\n\n    #[inline]\n    pub(super) const fn month(&self) -> u32 {\n        let Mdf(mdf) = *self;\n        mdf >> 9\n    }\n\n    #[inline]\n    pub(super) const fn with_month(&self, month: u32) -> Option<Mdf> {\n        if month > 12 {\n            return None;\n        }\n\n        let Mdf(mdf) = *self;\n        Some(Mdf((mdf & 0b1_1111_1111) | (month << 9)))\n    }\n\n    #[inline]\n    pub(super) const fn day(&self) -> u32 {\n        let Mdf(mdf) = *self;\n        (mdf >> 4) & 0b1_1111\n    }\n\n    #[inline]\n    pub(super) const fn with_day(&self, day: u32) -> Option<Mdf> {\n        if day > 31 {\n            return None;\n        }\n\n        let Mdf(mdf) = *self;\n        Some(Mdf((mdf & !0b1_1111_0000) | (day << 4)))\n    }\n\n    #[inline]\n    pub(super) const fn with_flags(&self, YearFlags(flags): YearFlags) -> Mdf {\n        let Mdf(mdf) = *self;\n        Mdf((mdf & !0b1111) | flags as u32)\n    }\n\n    #[cfg_attr(feature = \"cargo-clippy\", allow(clippy::wrong_self_convention))]\n    #[inline]\n    pub(super) const fn to_of(&self) -> Option<Of> {\n        Of::from_mdf(*self)\n    }\n}","impl fmt::Debug for Mdf {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let Mdf(mdf) = *self;\n        write!(\n            f,\n            \"Mdf(({} << 9) | ({} << 4) | {:#04o} /*{:?}*/)\",\n            mdf >> 9,\n            (mdf >> 4) & 0b1_1111,\n            mdf & 0b1111,\n            YearFlags((mdf & 0b1111) as u8)\n        )\n    }\n}"],"naive::internals::Of":["Clone","Copy","PartialEq","PartialOrd","impl Of {\n    #[inline]\n    pub(super) const fn new(ordinal: u32, YearFlags(flags): YearFlags) -> Option<Of> {\n        let of = Of((ordinal << 4) | flags as u32);\n        of.validate()\n    }\n\n    pub(super) const fn from_date_impl(date_impl: DateImpl) -> Of {\n        // We assume the value in the `DateImpl` is valid.\n        Of((date_impl & 0b1_1111_1111_1111) as u32)\n    }\n\n    #[inline]\n    pub(super) const fn from_mdf(Mdf(mdf): Mdf) -> Option<Of> {\n        let mdl = mdf >> 3;\n        if mdl > MAX_MDL {\n            // Panicking on out-of-bounds indexing would be reasonable, but just return `None`.\n            return None;\n        }\n        // Array is indexed from `[1..=MAX_MDL]`, with a `0` index having a meaningless value.\n        let v = MDL_TO_OL[mdl as usize];\n        let of = Of(mdf.wrapping_sub((v as i32 as u32 & 0x3ff) << 3));\n        of.validate()\n    }\n\n    #[inline]\n    pub(super) const fn inner(&self) -> u32 {\n        self.0\n    }\n\n    /// Returns `(ordinal << 1) | leap-year-flag`.\n    #[inline]\n    const fn ol(&self) -> u32 {\n        self.0 >> 3\n    }\n\n    #[inline]\n    const fn validate(self) -> Option<Of> {\n        let ol = self.ol();\n        match ol >= MIN_OL && ol <= MAX_OL {\n            true => Some(self),\n            false => None,\n        }\n    }\n\n    #[inline]\n    pub(super) const fn ordinal(&self) -> u32 {\n        self.0 >> 4\n    }\n\n    #[inline]\n    pub(super) const fn with_ordinal(&self, ordinal: u32) -> Option<Of> {\n        let of = Of((ordinal << 4) | (self.0 & 0b1111));\n        of.validate()\n    }\n\n    #[inline]\n    pub(super) const fn flags(&self) -> YearFlags {\n        YearFlags((self.0 & 0b1111) as u8)\n    }\n\n    #[inline]\n    pub(super) const fn weekday(&self) -> Weekday {\n        let Of(of) = *self;\n        weekday_from_u32_mod7((of >> 4) + (of & 0b111))\n    }\n\n    #[inline]\n    pub(super) fn isoweekdate_raw(&self) -> (u32, Weekday) {\n        // week ordinal = ordinal + delta\n        let Of(of) = *self;\n        let weekord = (of >> 4).wrapping_add(self.flags().isoweek_delta());\n        (weekord / 7, weekday_from_u32_mod7(weekord))\n    }\n\n    #[cfg_attr(feature = \"cargo-clippy\", allow(clippy::wrong_self_convention))]\n    #[inline]\n    pub(super) const fn to_mdf(&self) -> Mdf {\n        Mdf::from_of(*self)\n    }\n\n    /// Returns an `Of` with the next day, or `None` if this is the last day of the year.\n    #[inline]\n    pub(super) const fn succ(&self) -> Option<Of> {\n        let of = Of(self.0 + (1 << 4));\n        of.validate()\n    }\n\n    /// Returns an `Of` with the previous day, or `None` if this is the first day of the year.\n    #[inline]\n    pub(super) const fn pred(&self) -> Option<Of> {\n        match self.ordinal() {\n            1 => None,\n            _ => Some(Of(self.0 - (1 << 4))),\n        }\n    }\n}","impl fmt::Debug for Of {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let Of(of) = *self;\n        write!(\n            f,\n            \"Of(({} << 4) | {:#04o} /*{:?}*/)\",\n            of >> 4,\n            of & 0b1111,\n            YearFlags((of & 0b1111) as u8)\n        )\n    }\n}"],"naive::internals::YearFlags":["Clone","Copy","Eq","Hash","PartialEq","impl YearFlags {\n    #[allow(unreachable_pub)] // public as an alias for benchmarks only\n    #[doc(hidden)] // for benchmarks only\n    #[inline]\n    #[must_use]\n    pub const fn from_year(year: i32) -> YearFlags {\n        let year = year.rem_euclid(400);\n        YearFlags::from_year_mod_400(year)\n    }\n\n    #[inline]\n    pub(super) const fn from_year_mod_400(year: i32) -> YearFlags {\n        YEAR_TO_FLAGS[year as usize]\n    }\n\n    #[inline]\n    pub(super) const fn ndays(&self) -> u32 {\n        let YearFlags(flags) = *self;\n        366 - (flags >> 3) as u32\n    }\n\n    #[inline]\n    pub(super) const fn isoweek_delta(&self) -> u32 {\n        let YearFlags(flags) = *self;\n        let mut delta = (flags & 0b0111) as u32;\n        if delta < 3 {\n            delta += 7;\n        }\n        delta\n    }\n\n    #[inline]\n    pub(super) const fn nisoweeks(&self) -> u32 {\n        let YearFlags(flags) = *self;\n        52 + ((0b0000_0100_0000_0110 >> flags as usize) & 1)\n    }\n}","impl fmt::Debug for YearFlags {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let YearFlags(flags) = *self;\n        match flags {\n            0o15 => \"A\".fmt(f),\n            0o05 => \"AG\".fmt(f),\n            0o14 => \"B\".fmt(f),\n            0o04 => \"BA\".fmt(f),\n            0o13 => \"C\".fmt(f),\n            0o03 => \"CB\".fmt(f),\n            0o12 => \"D\".fmt(f),\n            0o02 => \"DC\".fmt(f),\n            0o11 => \"E\".fmt(f),\n            0o01 => \"ED\".fmt(f),\n            0o10 => \"F?\".fmt(f),\n            0o00 => \"FE?\".fmt(f), // non-canonical\n            0o17 => \"F\".fmt(f),\n            0o07 => \"FE\".fmt(f),\n            0o16 => \"G\".fmt(f),\n            0o06 => \"GF\".fmt(f),\n            _ => write!(f, \"YearFlags({})\", flags),\n        }\n    }\n}"],"naive::isoweek::IsoWeek":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl IsoWeek {\n    /// Returns the year number for this ISO week.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike, Weekday};\n    ///\n    /// let d = NaiveDate::from_isoywd_opt(2015, 1, Weekday::Mon).unwrap();\n    /// assert_eq!(d.iso_week().year(), 2015);\n    /// ```\n    ///\n    /// This year number might not match the calendar year number.\n    /// Continuing the example...\n    ///\n    /// ```\n    /// # use chrono::{NaiveDate, Datelike, Weekday};\n    /// # let d = NaiveDate::from_isoywd_opt(2015, 1, Weekday::Mon).unwrap();\n    /// assert_eq!(d.year(), 2014);\n    /// assert_eq!(d, NaiveDate::from_ymd_opt(2014, 12, 29).unwrap());\n    /// ```\n    #[inline]\n    pub const fn year(&self) -> i32 {\n        self.ywf >> 10\n    }\n\n    /// Returns the ISO week number starting from 1.\n    ///\n    /// The return value ranges from 1 to 53. (The last week of year differs by years.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike, Weekday};\n    ///\n    /// let d = NaiveDate::from_isoywd_opt(2015, 15, Weekday::Mon).unwrap();\n    /// assert_eq!(d.iso_week().week(), 15);\n    /// ```\n    #[inline]\n    pub const fn week(&self) -> u32 {\n        ((self.ywf >> 4) & 0x3f) as u32\n    }\n\n    /// Returns the ISO week number starting from 0.\n    ///\n    /// The return value ranges from 0 to 52. (The last week of year differs by years.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike, Weekday};\n    ///\n    /// let d = NaiveDate::from_isoywd_opt(2015, 15, Weekday::Mon).unwrap();\n    /// assert_eq!(d.iso_week().week0(), 14);\n    /// ```\n    #[inline]\n    pub const fn week0(&self) -> u32 {\n        ((self.ywf >> 4) & 0x3f) as u32 - 1\n    }\n}","impl fmt::Debug for IsoWeek {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let year = self.year();\n        let week = self.week();\n        if (0..=9999).contains(&year) {\n            write!(f, \"{:04}-W{:02}\", year, week)\n        } else {\n            // ISO 8601 requires the explicit sign for out-of-range years\n            write!(f, \"{:+05}-W{:02}\", year, week)\n        }\n    }\n}"],"naive::time::NaiveTime":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl Add<FixedOffset> for NaiveTime {\n    type Output = NaiveTime;\n\n    #[inline]\n    fn add(self, rhs: FixedOffset) -> NaiveTime {\n        add_with_leapsecond(&self, rhs.local_minus_utc)\n    }\n}","impl Add<OldDuration> for NaiveTime {\n    type Output = NaiveTime;\n\n    #[inline]\n    fn add(self, rhs: OldDuration) -> NaiveTime {\n        self.overflowing_add_signed(rhs).0\n    }\n}","impl AddAssign<OldDuration> for NaiveTime {\n    #[inline]\n    fn add_assign(&mut self, rhs: OldDuration) {\n        *self = self.add(rhs);\n    }\n}","impl Default for NaiveTime {\n    fn default() -> Self {\n        NaiveTime::from_hms_opt(0, 0, 0).unwrap()\n    }\n}","impl NaiveTime {\n    /// Makes a new `NaiveTime` from hour, minute and second.\n    ///\n    /// No [leap second](#leap-second-handling) is allowed here;\n    /// use `NaiveTime::from_hms_*` methods with a subsecond parameter instead.\n    ///\n    /// Panics on invalid hour, minute and/or second.\n    #[deprecated(since = \"0.4.23\", note = \"use `from_hms_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn from_hms(hour: u32, min: u32, sec: u32) -> NaiveTime {\n        NaiveTime::from_hms_opt(hour, min, sec).expect(\"invalid time\")\n    }\n\n    /// Makes a new `NaiveTime` from hour, minute and second.\n    ///\n    /// No [leap second](#leap-second-handling) is allowed here;\n    /// use `NaiveTime::from_hms_*_opt` methods with a subsecond parameter instead.\n    ///\n    /// Returns `None` on invalid hour, minute and/or second.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveTime;\n    ///\n    /// let from_hms_opt = NaiveTime::from_hms_opt;\n    ///\n    /// assert!(from_hms_opt(0, 0, 0).is_some());\n    /// assert!(from_hms_opt(23, 59, 59).is_some());\n    /// assert!(from_hms_opt(24, 0, 0).is_none());\n    /// assert!(from_hms_opt(23, 60, 0).is_none());\n    /// assert!(from_hms_opt(23, 59, 60).is_none());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub const fn from_hms_opt(hour: u32, min: u32, sec: u32) -> Option<NaiveTime> {\n        NaiveTime::from_hms_nano_opt(hour, min, sec, 0)\n    }\n\n    /// Makes a new `NaiveTime` from hour, minute, second and millisecond.\n    ///\n    /// The millisecond part can exceed 1,000\n    /// in order to represent the [leap second](#leap-second-handling).\n    ///\n    /// Panics on invalid hour, minute, second and/or millisecond.\n    #[deprecated(since = \"0.4.23\", note = \"use `from_hms_milli_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn from_hms_milli(hour: u32, min: u32, sec: u32, milli: u32) -> NaiveTime {\n        NaiveTime::from_hms_milli_opt(hour, min, sec, milli).expect(\"invalid time\")\n    }\n\n    /// Makes a new `NaiveTime` from hour, minute, second and millisecond.\n    ///\n    /// The millisecond part can exceed 1,000\n    /// in order to represent the [leap second](#leap-second-handling).\n    ///\n    /// Returns `None` on invalid hour, minute, second and/or millisecond.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveTime;\n    ///\n    /// let from_hmsm_opt = NaiveTime::from_hms_milli_opt;\n    ///\n    /// assert!(from_hmsm_opt(0, 0, 0, 0).is_some());\n    /// assert!(from_hmsm_opt(23, 59, 59, 999).is_some());\n    /// assert!(from_hmsm_opt(23, 59, 59, 1_999).is_some()); // a leap second after 23:59:59\n    /// assert!(from_hmsm_opt(24, 0, 0, 0).is_none());\n    /// assert!(from_hmsm_opt(23, 60, 0, 0).is_none());\n    /// assert!(from_hmsm_opt(23, 59, 60, 0).is_none());\n    /// assert!(from_hmsm_opt(23, 59, 59, 2_000).is_none());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn from_hms_milli_opt(hour: u32, min: u32, sec: u32, milli: u32) -> Option<NaiveTime> {\n        milli\n            .checked_mul(1_000_000)\n            .and_then(|nano| NaiveTime::from_hms_nano_opt(hour, min, sec, nano))\n    }\n\n    /// Makes a new `NaiveTime` from hour, minute, second and microsecond.\n    ///\n    /// The microsecond part can exceed 1,000,000\n    /// in order to represent the [leap second](#leap-second-handling).\n    ///\n    /// Panics on invalid hour, minute, second and/or microsecond.\n    #[deprecated(since = \"0.4.23\", note = \"use `from_hms_micro_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn from_hms_micro(hour: u32, min: u32, sec: u32, micro: u32) -> NaiveTime {\n        NaiveTime::from_hms_micro_opt(hour, min, sec, micro).expect(\"invalid time\")\n    }\n\n    /// Makes a new `NaiveTime` from hour, minute, second and microsecond.\n    ///\n    /// The microsecond part can exceed 1,000,000\n    /// in order to represent the [leap second](#leap-second-handling).\n    ///\n    /// Returns `None` on invalid hour, minute, second and/or microsecond.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveTime;\n    ///\n    /// let from_hmsu_opt = NaiveTime::from_hms_micro_opt;\n    ///\n    /// assert!(from_hmsu_opt(0, 0, 0, 0).is_some());\n    /// assert!(from_hmsu_opt(23, 59, 59, 999_999).is_some());\n    /// assert!(from_hmsu_opt(23, 59, 59, 1_999_999).is_some()); // a leap second after 23:59:59\n    /// assert!(from_hmsu_opt(24, 0, 0, 0).is_none());\n    /// assert!(from_hmsu_opt(23, 60, 0, 0).is_none());\n    /// assert!(from_hmsu_opt(23, 59, 60, 0).is_none());\n    /// assert!(from_hmsu_opt(23, 59, 59, 2_000_000).is_none());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn from_hms_micro_opt(hour: u32, min: u32, sec: u32, micro: u32) -> Option<NaiveTime> {\n        micro.checked_mul(1_000).and_then(|nano| NaiveTime::from_hms_nano_opt(hour, min, sec, nano))\n    }\n\n    /// Makes a new `NaiveTime` from hour, minute, second and nanosecond.\n    ///\n    /// The nanosecond part can exceed 1,000,000,000\n    /// in order to represent the [leap second](#leap-second-handling).\n    ///\n    /// Panics on invalid hour, minute, second and/or nanosecond.\n    #[deprecated(since = \"0.4.23\", note = \"use `from_hms_nano_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn from_hms_nano(hour: u32, min: u32, sec: u32, nano: u32) -> NaiveTime {\n        NaiveTime::from_hms_nano_opt(hour, min, sec, nano).expect(\"invalid time\")\n    }\n\n    /// Makes a new `NaiveTime` from hour, minute, second and nanosecond.\n    ///\n    /// The nanosecond part can exceed 1,000,000,000\n    /// in order to represent the [leap second](#leap-second-handling).\n    ///\n    /// Returns `None` on invalid hour, minute, second and/or nanosecond.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveTime;\n    ///\n    /// let from_hmsn_opt = NaiveTime::from_hms_nano_opt;\n    ///\n    /// assert!(from_hmsn_opt(0, 0, 0, 0).is_some());\n    /// assert!(from_hmsn_opt(23, 59, 59, 999_999_999).is_some());\n    /// assert!(from_hmsn_opt(23, 59, 59, 1_999_999_999).is_some()); // a leap second after 23:59:59\n    /// assert!(from_hmsn_opt(24, 0, 0, 0).is_none());\n    /// assert!(from_hmsn_opt(23, 60, 0, 0).is_none());\n    /// assert!(from_hmsn_opt(23, 59, 60, 0).is_none());\n    /// assert!(from_hmsn_opt(23, 59, 59, 2_000_000_000).is_none());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub const fn from_hms_nano_opt(hour: u32, min: u32, sec: u32, nano: u32) -> Option<NaiveTime> {\n        if hour >= 24 || min >= 60 || sec >= 60 || nano >= 2_000_000_000 {\n            return None;\n        }\n        let secs = hour * 3600 + min * 60 + sec;\n        Some(NaiveTime { secs, frac: nano })\n    }\n\n    /// Makes a new `NaiveTime` from the number of seconds since midnight and nanosecond.\n    ///\n    /// The nanosecond part can exceed 1,000,000,000\n    /// in order to represent the [leap second](#leap-second-handling).\n    ///\n    /// Panics on invalid number of seconds and/or nanosecond.\n    #[deprecated(since = \"0.4.23\", note = \"use `from_num_seconds_from_midnight_opt()` instead\")]\n    #[inline]\n    #[must_use]\n    pub fn from_num_seconds_from_midnight(secs: u32, nano: u32) -> NaiveTime {\n        NaiveTime::from_num_seconds_from_midnight_opt(secs, nano).expect(\"invalid time\")\n    }\n\n    /// Makes a new `NaiveTime` from the number of seconds since midnight and nanosecond.\n    ///\n    /// The nanosecond part can exceed 1,000,000,000\n    /// in order to represent the [leap second](#leap-second-handling).\n    ///\n    /// Returns `None` on invalid number of seconds and/or nanosecond.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveTime;\n    ///\n    /// let from_nsecs_opt = NaiveTime::from_num_seconds_from_midnight_opt;\n    ///\n    /// assert!(from_nsecs_opt(0, 0).is_some());\n    /// assert!(from_nsecs_opt(86399, 999_999_999).is_some());\n    /// assert!(from_nsecs_opt(86399, 1_999_999_999).is_some()); // a leap second after 23:59:59\n    /// assert!(from_nsecs_opt(86_400, 0).is_none());\n    /// assert!(from_nsecs_opt(86399, 2_000_000_000).is_none());\n    /// ```\n    #[inline]\n    #[must_use]\n    pub const fn from_num_seconds_from_midnight_opt(secs: u32, nano: u32) -> Option<NaiveTime> {\n        if secs >= 86_400 || nano >= 2_000_000_000 {\n            return None;\n        }\n        Some(NaiveTime { secs, frac: nano })\n    }\n\n    /// Parses a string with the specified format string and returns a new `NaiveTime`.\n    /// See the [`format::strftime` module](../format/strftime/index.html)\n    /// on the supported escape sequences.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveTime;\n    ///\n    /// let parse_from_str = NaiveTime::parse_from_str;\n    ///\n    /// assert_eq!(parse_from_str(\"23:56:04\", \"%H:%M:%S\"),\n    ///            Ok(NaiveTime::from_hms_opt(23, 56, 4).unwrap()));\n    /// assert_eq!(parse_from_str(\"pm012345.6789\", \"%p%I%M%S%.f\"),\n    ///            Ok(NaiveTime::from_hms_micro_opt(13, 23, 45, 678_900).unwrap()));\n    /// ```\n    ///\n    /// Date and offset is ignored for the purpose of parsing.\n    ///\n    /// ```\n    /// # use chrono::NaiveTime;\n    /// # let parse_from_str = NaiveTime::parse_from_str;\n    /// assert_eq!(parse_from_str(\"2014-5-17T12:34:56+09:30\", \"%Y-%m-%dT%H:%M:%S%z\"),\n    ///            Ok(NaiveTime::from_hms_opt(12, 34, 56).unwrap()));\n    /// ```\n    ///\n    /// [Leap seconds](#leap-second-handling) are correctly handled by\n    /// treating any time of the form `hh:mm:60` as a leap second.\n    /// (This equally applies to the formatting, so the round trip is possible.)\n    ///\n    /// ```\n    /// # use chrono::NaiveTime;\n    /// # let parse_from_str = NaiveTime::parse_from_str;\n    /// assert_eq!(parse_from_str(\"08:59:60.123\", \"%H:%M:%S%.f\"),\n    ///            Ok(NaiveTime::from_hms_milli_opt(8, 59, 59, 1_123).unwrap()));\n    /// ```\n    ///\n    /// Missing seconds are assumed to be zero,\n    /// but out-of-bound times or insufficient fields are errors otherwise.\n    ///\n    /// ```\n    /// # use chrono::NaiveTime;\n    /// # let parse_from_str = NaiveTime::parse_from_str;\n    /// assert_eq!(parse_from_str(\"7:15\", \"%H:%M\"),\n    ///            Ok(NaiveTime::from_hms_opt(7, 15, 0).unwrap()));\n    ///\n    /// assert!(parse_from_str(\"04m33s\", \"%Mm%Ss\").is_err());\n    /// assert!(parse_from_str(\"12\", \"%H\").is_err());\n    /// assert!(parse_from_str(\"17:60\", \"%H:%M\").is_err());\n    /// assert!(parse_from_str(\"24:00:00\", \"%H:%M:%S\").is_err());\n    /// ```\n    ///\n    /// All parsed fields should be consistent to each other, otherwise it's an error.\n    /// Here `%H` is for 24-hour clocks, unlike `%I`,\n    /// and thus can be independently determined without AM/PM.\n    ///\n    /// ```\n    /// # use chrono::NaiveTime;\n    /// # let parse_from_str = NaiveTime::parse_from_str;\n    /// assert!(parse_from_str(\"13:07 AM\", \"%H:%M %p\").is_err());\n    /// ```\n    pub fn parse_from_str(s: &str, fmt: &str) -> ParseResult<NaiveTime> {\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_naive_time()\n    }\n\n    /// Parses a string from a user-specified format into a new `NaiveTime` value, and a slice with\n    /// the remaining portion of the string.\n    /// See the [`format::strftime` module](../format/strftime/index.html)\n    /// on the supported escape sequences.\n    ///\n    /// Similar to [`parse_from_str`](#method.parse_from_str).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use chrono::{NaiveTime};\n    /// let (time, remainder) = NaiveTime::parse_and_remainder(\n    ///     \"3h4m33s trailing text\", \"%-Hh%-Mm%-Ss\").unwrap();\n    /// assert_eq!(time, NaiveTime::from_hms_opt(3, 4, 33).unwrap());\n    /// assert_eq!(remainder, \" trailing text\");\n    /// ```\n    pub fn parse_and_remainder<'a>(s: &'a str, fmt: &str) -> ParseResult<(NaiveTime, &'a str)> {\n        let mut parsed = Parsed::new();\n        let remainder = parse_and_remainder(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_naive_time().map(|t| (t, remainder))\n    }\n\n    /// Adds given `Duration` to the current time,\n    /// and also returns the number of *seconds*\n    /// in the integral number of days ignored from the addition.\n    /// (We cannot return `Duration` because it is subject to overflow or underflow.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Duration, NaiveTime};\n    ///\n    /// let from_hms = |h, m, s| { NaiveTime::from_hms_opt(h, m, s).unwrap() };\n    ///\n    /// assert_eq!(from_hms(3, 4, 5).overflowing_add_signed(Duration::hours(11)),\n    ///            (from_hms(14, 4, 5), 0));\n    /// assert_eq!(from_hms(3, 4, 5).overflowing_add_signed(Duration::hours(23)),\n    ///            (from_hms(2, 4, 5), 86_400));\n    /// assert_eq!(from_hms(3, 4, 5).overflowing_add_signed(Duration::hours(-7)),\n    ///            (from_hms(20, 4, 5), -86_400));\n    /// ```\n    #[must_use]\n    pub fn overflowing_add_signed(&self, mut rhs: OldDuration) -> (NaiveTime, i64) {\n        let mut secs = self.secs;\n        let mut frac = self.frac;\n\n        // check if `self` is a leap second and adding `rhs` would escape that leap second.\n        // if it's the case, update `self` and `rhs` to involve no leap second;\n        // otherwise the addition immediately finishes.\n        if frac >= 1_000_000_000 {\n            let rfrac = 2_000_000_000 - frac;\n            if rhs >= OldDuration::nanoseconds(i64::from(rfrac)) {\n                rhs = rhs - OldDuration::nanoseconds(i64::from(rfrac));\n                secs += 1;\n                frac = 0;\n            } else if rhs < OldDuration::nanoseconds(-i64::from(frac)) {\n                rhs = rhs + OldDuration::nanoseconds(i64::from(frac));\n                frac = 0;\n            } else {\n                frac = (i64::from(frac) + rhs.num_nanoseconds().unwrap()) as u32;\n                debug_assert!(frac < 2_000_000_000);\n                return (NaiveTime { secs, frac }, 0);\n            }\n        }\n        debug_assert!(secs <= 86_400);\n        debug_assert!(frac < 1_000_000_000);\n\n        let rhssecs = rhs.num_seconds();\n        let rhsfrac = (rhs - OldDuration::seconds(rhssecs)).num_nanoseconds().unwrap();\n        debug_assert_eq!(OldDuration::seconds(rhssecs) + OldDuration::nanoseconds(rhsfrac), rhs);\n        let rhssecsinday = rhssecs % 86_400;\n        let mut morerhssecs = rhssecs - rhssecsinday;\n        let rhssecs = rhssecsinday as i32;\n        let rhsfrac = rhsfrac as i32;\n        debug_assert!(-86_400 < rhssecs && rhssecs < 86_400);\n        debug_assert_eq!(morerhssecs % 86_400, 0);\n        debug_assert!(-1_000_000_000 < rhsfrac && rhsfrac < 1_000_000_000);\n\n        let mut secs = secs as i32 + rhssecs;\n        let mut frac = frac as i32 + rhsfrac;\n        debug_assert!(-86_400 < secs && secs < 2 * 86_400);\n        debug_assert!(-1_000_000_000 < frac && frac < 2_000_000_000);\n\n        if frac < 0 {\n            frac += 1_000_000_000;\n            secs -= 1;\n        } else if frac >= 1_000_000_000 {\n            frac -= 1_000_000_000;\n            secs += 1;\n        }\n        debug_assert!((-86_400..2 * 86_400).contains(&secs));\n        debug_assert!((0..1_000_000_000).contains(&frac));\n\n        if secs < 0 {\n            secs += 86_400;\n            morerhssecs -= 86_400;\n        } else if secs >= 86_400 {\n            secs -= 86_400;\n            morerhssecs += 86_400;\n        }\n        debug_assert!((0..86_400).contains(&secs));\n\n        (NaiveTime { secs: secs as u32, frac: frac as u32 }, morerhssecs)\n    }\n\n    /// Subtracts given `Duration` from the current time,\n    /// and also returns the number of *seconds*\n    /// in the integral number of days ignored from the subtraction.\n    /// (We cannot return `Duration` because it is subject to overflow or underflow.)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Duration, NaiveTime};\n    ///\n    /// let from_hms = |h, m, s| { NaiveTime::from_hms_opt(h, m, s).unwrap() };\n    ///\n    /// assert_eq!(from_hms(3, 4, 5).overflowing_sub_signed(Duration::hours(2)),\n    ///            (from_hms(1, 4, 5), 0));\n    /// assert_eq!(from_hms(3, 4, 5).overflowing_sub_signed(Duration::hours(17)),\n    ///            (from_hms(10, 4, 5), 86_400));\n    /// assert_eq!(from_hms(3, 4, 5).overflowing_sub_signed(Duration::hours(-22)),\n    ///            (from_hms(1, 4, 5), -86_400));\n    /// ```\n    #[inline]\n    #[must_use]\n    pub fn overflowing_sub_signed(&self, rhs: OldDuration) -> (NaiveTime, i64) {\n        let (time, rhs) = self.overflowing_add_signed(-rhs);\n        (time, -rhs) // safe to negate, rhs is within +/- (2^63 / 1000)\n    }\n\n    /// Subtracts another `NaiveTime` from the current time.\n    /// Returns a `Duration` within +/- 1 day.\n    /// This does not overflow or underflow at all.\n    ///\n    /// As a part of Chrono's [leap second handling](#leap-second-handling),\n    /// the subtraction assumes that **there is no leap second ever**,\n    /// except when any of the `NaiveTime`s themselves represents a leap second\n    /// in which case the assumption becomes that\n    /// **there are exactly one (or two) leap second(s) ever**.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Duration, NaiveTime};\n    ///\n    /// let from_hmsm = |h, m, s, milli| { NaiveTime::from_hms_milli_opt(h, m, s, milli).unwrap() };\n    /// let since = NaiveTime::signed_duration_since;\n    ///\n    /// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(3, 5, 7, 900)),\n    ///            Duration::zero());\n    /// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(3, 5, 7, 875)),\n    ///            Duration::milliseconds(25));\n    /// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(3, 5, 6, 925)),\n    ///            Duration::milliseconds(975));\n    /// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(3, 5, 0, 900)),\n    ///            Duration::seconds(7));\n    /// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(3, 0, 7, 900)),\n    ///            Duration::seconds(5 * 60));\n    /// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(0, 5, 7, 900)),\n    ///            Duration::seconds(3 * 3600));\n    /// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(4, 5, 7, 900)),\n    ///            Duration::seconds(-3600));\n    /// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(2, 4, 6, 800)),\n    ///            Duration::seconds(3600 + 60 + 1) + Duration::milliseconds(100));\n    /// ```\n    ///\n    /// Leap seconds are handled, but the subtraction assumes that\n    /// there were no other leap seconds happened.\n    ///\n    /// ```\n    /// # use chrono::{Duration, NaiveTime};\n    /// # let from_hmsm = |h, m, s, milli| { NaiveTime::from_hms_milli_opt(h, m, s, milli).unwrap() };\n    /// # let since = NaiveTime::signed_duration_since;\n    /// assert_eq!(since(from_hmsm(3, 0, 59, 1_000), from_hmsm(3, 0, 59, 0)),\n    ///            Duration::seconds(1));\n    /// assert_eq!(since(from_hmsm(3, 0, 59, 1_500), from_hmsm(3, 0, 59, 0)),\n    ///            Duration::milliseconds(1500));\n    /// assert_eq!(since(from_hmsm(3, 0, 59, 1_000), from_hmsm(3, 0, 0, 0)),\n    ///            Duration::seconds(60));\n    /// assert_eq!(since(from_hmsm(3, 0, 0, 0), from_hmsm(2, 59, 59, 1_000)),\n    ///            Duration::seconds(1));\n    /// assert_eq!(since(from_hmsm(3, 0, 59, 1_000), from_hmsm(2, 59, 59, 1_000)),\n    ///            Duration::seconds(61));\n    /// ```\n    #[must_use]\n    pub fn signed_duration_since(self, rhs: NaiveTime) -> OldDuration {\n        //     |    |    :leap|    |    |    |    |    |    |    :leap|    |\n        //     |    |    :    |    |    |    |    |    |    |    :    |    |\n        // ----+----+-----*---+----+----+----+----+----+----+-------*-+----+----\n        //          |   `rhs` |                             |    `self`\n        //          |======================================>|       |\n        //          |     |  `self.secs - rhs.secs`         |`self.frac`\n        //          |====>|   |                             |======>|\n        //      `rhs.frac`|========================================>|\n        //          |     |   |        `self - rhs`         |       |\n\n        use core::cmp::Ordering;\n\n        let secs = i64::from(self.secs) - i64::from(rhs.secs);\n        let frac = i64::from(self.frac) - i64::from(rhs.frac);\n\n        // `secs` may contain a leap second yet to be counted\n        let adjust = match self.secs.cmp(&rhs.secs) {\n            Ordering::Greater => i64::from(rhs.frac >= 1_000_000_000),\n            Ordering::Equal => 0,\n            Ordering::Less => {\n                if self.frac >= 1_000_000_000 {\n                    -1\n                } else {\n                    0\n                }\n            }\n        };\n\n        OldDuration::seconds(secs + adjust) + OldDuration::nanoseconds(frac)\n    }\n\n    /// Formats the time with the specified formatting items.\n    /// Otherwise it is the same as the ordinary [`format`](#method.format) method.\n    ///\n    /// The `Iterator` of items should be `Clone`able,\n    /// since the resulting `DelayedFormat` value may be formatted multiple times.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveTime;\n    /// use chrono::format::strftime::StrftimeItems;\n    ///\n    /// let fmt = StrftimeItems::new(\"%H:%M:%S\");\n    /// let t = NaiveTime::from_hms_opt(23, 56, 4).unwrap();\n    /// assert_eq!(t.format_with_items(fmt.clone()).to_string(), \"23:56:04\");\n    /// assert_eq!(t.format(\"%H:%M:%S\").to_string(),             \"23:56:04\");\n    /// ```\n    ///\n    /// The resulting `DelayedFormat` can be formatted directly via the `Display` trait.\n    ///\n    /// ```\n    /// # use chrono::NaiveTime;\n    /// # use chrono::format::strftime::StrftimeItems;\n    /// # let fmt = StrftimeItems::new(\"%H:%M:%S\").clone();\n    /// # let t = NaiveTime::from_hms_opt(23, 56, 4).unwrap();\n    /// assert_eq!(format!(\"{}\", t.format_with_items(fmt)), \"23:56:04\");\n    /// ```\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[inline]\n    #[must_use]\n    pub fn format_with_items<'a, I, B>(&self, items: I) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,\n    {\n        DelayedFormat::new(None, Some(*self), items)\n    }\n\n    /// Formats the time with the specified format string.\n    /// See the [`format::strftime` module](../format/strftime/index.html)\n    /// on the supported escape sequences.\n    ///\n    /// This returns a `DelayedFormat`,\n    /// which gets converted to a string only when actual formatting happens.\n    /// You may use the `to_string` method to get a `String`,\n    /// or just feed it into `print!` and other formatting macros.\n    /// (In this way it avoids the redundant memory allocation.)\n    ///\n    /// A wrong format string does *not* issue an error immediately.\n    /// Rather, converting or formatting the `DelayedFormat` fails.\n    /// You are recommended to immediately use `DelayedFormat` for this reason.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::NaiveTime;\n    ///\n    /// let t = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n    /// assert_eq!(t.format(\"%H:%M:%S\").to_string(), \"23:56:04\");\n    /// assert_eq!(t.format(\"%H:%M:%S%.6f\").to_string(), \"23:56:04.012345\");\n    /// assert_eq!(t.format(\"%-I:%M %p\").to_string(), \"11:56 PM\");\n    /// ```\n    ///\n    /// The resulting `DelayedFormat` can be formatted directly via the `Display` trait.\n    ///\n    /// ```\n    /// # use chrono::NaiveTime;\n    /// # let t = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n    /// assert_eq!(format!(\"{}\", t.format(\"%H:%M:%S\")), \"23:56:04\");\n    /// assert_eq!(format!(\"{}\", t.format(\"%H:%M:%S%.6f\")), \"23:56:04.012345\");\n    /// assert_eq!(format!(\"{}\", t.format(\"%-I:%M %p\")), \"11:56 PM\");\n    /// ```\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    #[inline]\n    #[must_use]\n    pub fn format<'a>(&self, fmt: &'a str) -> DelayedFormat<StrftimeItems<'a>> {\n        self.format_with_items(StrftimeItems::new(fmt))\n    }\n\n    /// Returns a triple of the hour, minute and second numbers.\n    fn hms(&self) -> (u32, u32, u32) {\n        let sec = self.secs % 60;\n        let mins = self.secs / 60;\n        let min = mins % 60;\n        let hour = mins / 60;\n        (hour, min, sec)\n    }\n\n    /// The earliest possible `NaiveTime`\n    pub const MIN: Self = Self { secs: 0, frac: 0 };\n    pub(super) const MAX: Self = Self { secs: 23 * 3600 + 59 * 60 + 59, frac: 999_999_999 };\n}","impl Sub<FixedOffset> for NaiveTime {\n    type Output = NaiveTime;\n\n    #[inline]\n    fn sub(self, rhs: FixedOffset) -> NaiveTime {\n        add_with_leapsecond(&self, -rhs.local_minus_utc)\n    }\n}","impl Sub<NaiveTime> for NaiveTime {\n    type Output = OldDuration;\n\n    #[inline]\n    fn sub(self, rhs: NaiveTime) -> OldDuration {\n        self.signed_duration_since(rhs)\n    }\n}","impl Sub<OldDuration> for NaiveTime {\n    type Output = NaiveTime;\n\n    #[inline]\n    fn sub(self, rhs: OldDuration) -> NaiveTime {\n        self.overflowing_sub_signed(rhs).0\n    }\n}","impl SubAssign<OldDuration> for NaiveTime {\n    #[inline]\n    fn sub_assign(&mut self, rhs: OldDuration) {\n        *self = self.sub(rhs);\n    }\n}","impl Timelike for NaiveTime {\n    /// Returns the hour number from 0 to 23.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveTime, Timelike};\n    ///\n    /// assert_eq!(NaiveTime::from_hms_opt(0, 0, 0).unwrap().hour(), 0);\n    /// assert_eq!(NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap().hour(), 23);\n    /// ```\n    #[inline]\n    fn hour(&self) -> u32 {\n        self.hms().0\n    }\n\n    /// Returns the minute number from 0 to 59.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveTime, Timelike};\n    ///\n    /// assert_eq!(NaiveTime::from_hms_opt(0, 0, 0).unwrap().minute(), 0);\n    /// assert_eq!(NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap().minute(), 56);\n    /// ```\n    #[inline]\n    fn minute(&self) -> u32 {\n        self.hms().1\n    }\n\n    /// Returns the second number from 0 to 59.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveTime, Timelike};\n    ///\n    /// assert_eq!(NaiveTime::from_hms_opt(0, 0, 0).unwrap().second(), 0);\n    /// assert_eq!(NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap().second(), 4);\n    /// ```\n    ///\n    /// This method never returns 60 even when it is a leap second.\n    /// ([Why?](#leap-second-handling))\n    /// Use the proper [formatting method](#method.format) to get a human-readable representation.\n    ///\n    #[cfg_attr(not(feature = \"std\"), doc = \"```ignore\")]\n    #[cfg_attr(feature = \"std\", doc = \"```\")]\n    /// # use chrono::{NaiveTime, Timelike};\n    /// let leap = NaiveTime::from_hms_milli_opt(23, 59, 59, 1_000).unwrap();\n    /// assert_eq!(leap.second(), 59);\n    /// assert_eq!(leap.format(\"%H:%M:%S\").to_string(), \"23:59:60\");\n    /// ```\n    #[inline]\n    fn second(&self) -> u32 {\n        self.hms().2\n    }\n\n    /// Returns the number of nanoseconds since the whole non-leap second.\n    /// The range from 1,000,000,000 to 1,999,999,999 represents\n    /// the [leap second](#leap-second-handling).\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveTime, Timelike};\n    ///\n    /// assert_eq!(NaiveTime::from_hms_opt(0, 0, 0).unwrap().nanosecond(), 0);\n    /// assert_eq!(NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap().nanosecond(), 12_345_678);\n    /// ```\n    ///\n    /// Leap seconds may have seemingly out-of-range return values.\n    /// You can reduce the range with `time.nanosecond() % 1_000_000_000`, or\n    /// use the proper [formatting method](#method.format) to get a human-readable representation.\n    ///\n    #[cfg_attr(not(feature = \"std\"), doc = \"```ignore\")]\n    #[cfg_attr(feature = \"std\", doc = \"```\")]\n    /// # use chrono::{NaiveTime, Timelike};\n    /// let leap = NaiveTime::from_hms_milli_opt(23, 59, 59, 1_000).unwrap();\n    /// assert_eq!(leap.nanosecond(), 1_000_000_000);\n    /// assert_eq!(leap.format(\"%H:%M:%S%.9f\").to_string(), \"23:59:60.000000000\");\n    /// ```\n    #[inline]\n    fn nanosecond(&self) -> u32 {\n        self.frac\n    }\n\n    /// Makes a new `NaiveTime` with the hour number changed.\n    ///\n    /// Returns `None` when the resulting `NaiveTime` would be invalid.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveTime, Timelike};\n    ///\n    /// let dt = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n    /// assert_eq!(dt.with_hour(7), Some(NaiveTime::from_hms_nano_opt(7, 56, 4, 12_345_678).unwrap()));\n    /// assert_eq!(dt.with_hour(24), None);\n    /// ```\n    #[inline]\n    fn with_hour(&self, hour: u32) -> Option<NaiveTime> {\n        if hour >= 24 {\n            return None;\n        }\n        let secs = hour * 3600 + self.secs % 3600;\n        Some(NaiveTime { secs, ..*self })\n    }\n\n    /// Makes a new `NaiveTime` with the minute number changed.\n    ///\n    /// Returns `None` when the resulting `NaiveTime` would be invalid.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveTime, Timelike};\n    ///\n    /// let dt = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n    /// assert_eq!(dt.with_minute(45), Some(NaiveTime::from_hms_nano_opt(23, 45, 4, 12_345_678).unwrap()));\n    /// assert_eq!(dt.with_minute(60), None);\n    /// ```\n    #[inline]\n    fn with_minute(&self, min: u32) -> Option<NaiveTime> {\n        if min >= 60 {\n            return None;\n        }\n        let secs = self.secs / 3600 * 3600 + min * 60 + self.secs % 60;\n        Some(NaiveTime { secs, ..*self })\n    }\n\n    /// Makes a new `NaiveTime` with the second number changed.\n    ///\n    /// Returns `None` when the resulting `NaiveTime` would be invalid.\n    /// As with the [`second`](#method.second) method,\n    /// the input range is restricted to 0 through 59.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveTime, Timelike};\n    ///\n    /// let dt = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n    /// assert_eq!(dt.with_second(17), Some(NaiveTime::from_hms_nano_opt(23, 56, 17, 12_345_678).unwrap()));\n    /// assert_eq!(dt.with_second(60), None);\n    /// ```\n    #[inline]\n    fn with_second(&self, sec: u32) -> Option<NaiveTime> {\n        if sec >= 60 {\n            return None;\n        }\n        let secs = self.secs / 60 * 60 + sec;\n        Some(NaiveTime { secs, ..*self })\n    }\n\n    /// Makes a new `NaiveTime` with nanoseconds since the whole non-leap second changed.\n    ///\n    /// Returns `None` when the resulting `NaiveTime` would be invalid.\n    /// As with the [`nanosecond`](#method.nanosecond) method,\n    /// the input range can exceed 1,000,000,000 for leap seconds.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveTime, Timelike};\n    ///\n    /// let dt = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n    /// assert_eq!(dt.with_nanosecond(333_333_333),\n    ///            Some(NaiveTime::from_hms_nano_opt(23, 56, 4, 333_333_333).unwrap()));\n    /// assert_eq!(dt.with_nanosecond(2_000_000_000), None);\n    /// ```\n    ///\n    /// Leap seconds can theoretically follow *any* whole second.\n    /// The following would be a proper leap second at the time zone offset of UTC-00:03:57\n    /// (there are several historical examples comparable to this \"non-sense\" offset),\n    /// and therefore is allowed.\n    ///\n    /// ```\n    /// # use chrono::{NaiveTime, Timelike};\n    /// # let dt = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n    /// assert_eq!(dt.with_nanosecond(1_333_333_333),\n    ///            Some(NaiveTime::from_hms_nano_opt(23, 56, 4, 1_333_333_333).unwrap()));\n    /// ```\n    #[inline]\n    fn with_nanosecond(&self, nano: u32) -> Option<NaiveTime> {\n        if nano >= 2_000_000_000 {\n            return None;\n        }\n        Some(NaiveTime { frac: nano, ..*self })\n    }\n\n    /// Returns the number of non-leap seconds past the last midnight.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{NaiveTime, Timelike};\n    ///\n    /// assert_eq!(NaiveTime::from_hms_opt(1, 2, 3).unwrap().num_seconds_from_midnight(),\n    ///            3723);\n    /// assert_eq!(NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap().num_seconds_from_midnight(),\n    ///            86164);\n    /// assert_eq!(NaiveTime::from_hms_milli_opt(23, 59, 59, 1_000).unwrap().num_seconds_from_midnight(),\n    ///            86399);\n    /// ```\n    #[inline]\n    fn num_seconds_from_midnight(&self) -> u32 {\n        self.secs // do not repeat the calculation!\n    }\n}","impl fmt::Debug for NaiveTime {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let (hour, min, sec) = self.hms();\n        let (sec, nano) = if self.frac >= 1_000_000_000 {\n            (sec + 1, self.frac - 1_000_000_000)\n        } else {\n            (sec, self.frac)\n        };\n\n        use core::fmt::Write;\n        write_hundreds(f, hour as u8)?;\n        f.write_char(':')?;\n        write_hundreds(f, min as u8)?;\n        f.write_char(':')?;\n        write_hundreds(f, sec as u8)?;\n\n        if nano == 0 {\n            Ok(())\n        } else if nano % 1_000_000 == 0 {\n            write!(f, \".{:03}\", nano / 1_000_000)\n        } else if nano % 1_000 == 0 {\n            write!(f, \".{:06}\", nano / 1_000)\n        } else {\n            write!(f, \".{:09}\", nano)\n        }\n    }\n}","impl fmt::Display for NaiveTime {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(self, f)\n    }\n}","impl str::FromStr for NaiveTime {\n    type Err = ParseError;\n\n    fn from_str(s: &str) -> ParseResult<NaiveTime> {\n        const ITEMS: &[Item<'static>] = &[\n            Item::Numeric(Numeric::Hour, Pad::Zero),\n            Item::Literal(\":\"),\n            Item::Numeric(Numeric::Minute, Pad::Zero),\n            Item::Literal(\":\"),\n            Item::Numeric(Numeric::Second, Pad::Zero),\n            Item::Fixed(Fixed::Nanosecond),\n        ];\n\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, ITEMS.iter())?;\n        parsed.to_naive_time()\n    }\n}"],"offset::LocalResult":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl<T: fmt::Debug> LocalResult<T> {\n    /// Returns the single unique conversion result, or panics accordingly.\n    #[must_use]\n    #[track_caller]\n    pub fn unwrap(self) -> T {\n        match self {\n            LocalResult::None => panic!(\"No such local time\"),\n            LocalResult::Single(t) => t,\n            LocalResult::Ambiguous(t1, t2) => {\n                panic!(\"Ambiguous local time, ranging from {:?} to {:?}\", t1, t2)\n            }\n        }\n    }\n}","impl<T> LocalResult<T> {\n    /// Returns `Some` only when the conversion result is unique, or `None` otherwise.\n    #[must_use]\n    pub fn single(self) -> Option<T> {\n        match self {\n            LocalResult::Single(t) => Some(t),\n            _ => None,\n        }\n    }\n\n    /// Returns `Some` for the earliest possible conversion result, or `None` if none.\n    #[must_use]\n    pub fn earliest(self) -> Option<T> {\n        match self {\n            LocalResult::Single(t) | LocalResult::Ambiguous(t, _) => Some(t),\n            _ => None,\n        }\n    }\n\n    /// Returns `Some` for the latest possible conversion result, or `None` if none.\n    #[must_use]\n    pub fn latest(self) -> Option<T> {\n        match self {\n            LocalResult::Single(t) | LocalResult::Ambiguous(_, t) => Some(t),\n            _ => None,\n        }\n    }\n\n    /// Maps a `LocalResult<T>` into `LocalResult<U>` with given function.\n    #[must_use]\n    pub fn map<U, F: FnMut(T) -> U>(self, mut f: F) -> LocalResult<U> {\n        match self {\n            LocalResult::None => LocalResult::None,\n            LocalResult::Single(v) => LocalResult::Single(f(v)),\n            LocalResult::Ambiguous(min, max) => LocalResult::Ambiguous(f(min), f(max)),\n        }\n    }\n}","impl<Tz: TimeZone> LocalResult<Date<Tz>> {\n    /// Makes a new `DateTime` from the current date and given `NaiveTime`.\n    /// The offset in the current date is preserved.\n    ///\n    /// Propagates any error. Ambiguous result would be discarded.\n    #[inline]\n    #[must_use]\n    pub fn and_time(self, time: NaiveTime) -> LocalResult<DateTime<Tz>> {\n        match self {\n            LocalResult::Single(d) => {\n                d.and_time(time).map_or(LocalResult::None, LocalResult::Single)\n            }\n            _ => LocalResult::None,\n        }\n    }\n\n    /// Makes a new `DateTime` from the current date, hour, minute and second.\n    /// The offset in the current date is preserved.\n    ///\n    /// Propagates any error. Ambiguous result would be discarded.\n    #[inline]\n    #[must_use]\n    pub fn and_hms_opt(self, hour: u32, min: u32, sec: u32) -> LocalResult<DateTime<Tz>> {\n        match self {\n            LocalResult::Single(d) => {\n                d.and_hms_opt(hour, min, sec).map_or(LocalResult::None, LocalResult::Single)\n            }\n            _ => LocalResult::None,\n        }\n    }\n\n    /// Makes a new `DateTime` from the current date, hour, minute, second and millisecond.\n    /// The millisecond part can exceed 1,000 in order to represent the leap second.\n    /// The offset in the current date is preserved.\n    ///\n    /// Propagates any error. Ambiguous result would be discarded.\n    #[inline]\n    #[must_use]\n    pub fn and_hms_milli_opt(\n        self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        milli: u32,\n    ) -> LocalResult<DateTime<Tz>> {\n        match self {\n            LocalResult::Single(d) => d\n                .and_hms_milli_opt(hour, min, sec, milli)\n                .map_or(LocalResult::None, LocalResult::Single),\n            _ => LocalResult::None,\n        }\n    }\n\n    /// Makes a new `DateTime` from the current date, hour, minute, second and microsecond.\n    /// The microsecond part can exceed 1,000,000 in order to represent the leap second.\n    /// The offset in the current date is preserved.\n    ///\n    /// Propagates any error. Ambiguous result would be discarded.\n    #[inline]\n    #[must_use]\n    pub fn and_hms_micro_opt(\n        self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        micro: u32,\n    ) -> LocalResult<DateTime<Tz>> {\n        match self {\n            LocalResult::Single(d) => d\n                .and_hms_micro_opt(hour, min, sec, micro)\n                .map_or(LocalResult::None, LocalResult::Single),\n            _ => LocalResult::None,\n        }\n    }\n\n    /// Makes a new `DateTime` from the current date, hour, minute, second and nanosecond.\n    /// The nanosecond part can exceed 1,000,000,000 in order to represent the leap second.\n    /// The offset in the current date is preserved.\n    ///\n    /// Propagates any error. Ambiguous result would be discarded.\n    #[inline]\n    #[must_use]\n    pub fn and_hms_nano_opt(\n        self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        nano: u32,\n    ) -> LocalResult<DateTime<Tz>> {\n        match self {\n            LocalResult::Single(d) => d\n                .and_hms_nano_opt(hour, min, sec, nano)\n                .map_or(LocalResult::None, LocalResult::Single),\n            _ => LocalResult::None,\n        }\n    }\n}"],"offset::fixed::FixedOffset":["Clone","Copy","Eq","Hash","PartialEq","impl FixedOffset {\n    /// Makes a new `FixedOffset` for the Eastern Hemisphere with given timezone difference.\n    /// The negative `secs` means the Western Hemisphere.\n    ///\n    /// Panics on the out-of-bound `secs`.\n    #[deprecated(since = \"0.4.23\", note = \"use `east_opt()` instead\")]\n    #[must_use]\n    pub fn east(secs: i32) -> FixedOffset {\n        FixedOffset::east_opt(secs).expect(\"FixedOffset::east out of bounds\")\n    }\n\n    /// Makes a new `FixedOffset` for the Eastern Hemisphere with given timezone difference.\n    /// The negative `secs` means the Western Hemisphere.\n    ///\n    /// Returns `None` on the out-of-bound `secs`.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(not(feature = \"std\"), doc = \"```ignore\")]\n    #[cfg_attr(feature = \"std\", doc = \"```\")]\n    /// use chrono::{FixedOffset, TimeZone};\n    /// let hour = 3600;\n    /// let datetime = FixedOffset::east_opt(5 * hour)\n    ///     .unwrap()\n    ///     .with_ymd_and_hms(2016, 11, 08, 0, 0, 0)\n    ///     .unwrap();\n    /// assert_eq!(&datetime.to_rfc3339(), \"2016-11-08T00:00:00+05:00\")\n    /// ```\n    #[must_use]\n    pub const fn east_opt(secs: i32) -> Option<FixedOffset> {\n        if -86_400 < secs && secs < 86_400 {\n            Some(FixedOffset { local_minus_utc: secs })\n        } else {\n            None\n        }\n    }\n\n    /// Makes a new `FixedOffset` for the Western Hemisphere with given timezone difference.\n    /// The negative `secs` means the Eastern Hemisphere.\n    ///\n    /// Panics on the out-of-bound `secs`.\n    #[deprecated(since = \"0.4.23\", note = \"use `west_opt()` instead\")]\n    #[must_use]\n    pub fn west(secs: i32) -> FixedOffset {\n        FixedOffset::west_opt(secs).expect(\"FixedOffset::west out of bounds\")\n    }\n\n    /// Makes a new `FixedOffset` for the Western Hemisphere with given timezone difference.\n    /// The negative `secs` means the Eastern Hemisphere.\n    ///\n    /// Returns `None` on the out-of-bound `secs`.\n    ///\n    /// # Example\n    ///\n    #[cfg_attr(not(feature = \"std\"), doc = \"```ignore\")]\n    #[cfg_attr(feature = \"std\", doc = \"```\")]\n    /// use chrono::{FixedOffset, TimeZone};\n    /// let hour = 3600;\n    /// let datetime = FixedOffset::west_opt(5 * hour)\n    ///     .unwrap()\n    ///     .with_ymd_and_hms(2016, 11, 08, 0, 0, 0)\n    ///     .unwrap();\n    /// assert_eq!(&datetime.to_rfc3339(), \"2016-11-08T00:00:00-05:00\")\n    /// ```\n    #[must_use]\n    pub const fn west_opt(secs: i32) -> Option<FixedOffset> {\n        if -86_400 < secs && secs < 86_400 {\n            Some(FixedOffset { local_minus_utc: -secs })\n        } else {\n            None\n        }\n    }\n\n    /// Returns the number of seconds to add to convert from UTC to the local time.\n    #[inline]\n    pub const fn local_minus_utc(&self) -> i32 {\n        self.local_minus_utc\n    }\n\n    /// Returns the number of seconds to add to convert from the local time to UTC.\n    #[inline]\n    pub const fn utc_minus_local(&self) -> i32 {\n        -self.local_minus_utc\n    }\n}","impl Offset for FixedOffset {\n    fn fix(&self) -> FixedOffset {\n        *self\n    }\n}","impl TimeZone for FixedOffset {\n    type Offset = FixedOffset;\n\n    fn from_offset(offset: &FixedOffset) -> FixedOffset {\n        *offset\n    }\n\n    fn offset_from_local_date(&self, _local: &NaiveDate) -> LocalResult<FixedOffset> {\n        LocalResult::Single(*self)\n    }\n    fn offset_from_local_datetime(&self, _local: &NaiveDateTime) -> LocalResult<FixedOffset> {\n        LocalResult::Single(*self)\n    }\n\n    fn offset_from_utc_date(&self, _utc: &NaiveDate) -> FixedOffset {\n        *self\n    }\n    fn offset_from_utc_datetime(&self, _utc: &NaiveDateTime) -> FixedOffset {\n        *self\n    }\n}","impl fmt::Debug for FixedOffset {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let offset = self.local_minus_utc;\n        let (sign, offset) = if offset < 0 { ('-', -offset) } else { ('+', offset) };\n        let sec = offset.rem_euclid(60);\n        let mins = offset.div_euclid(60);\n        let min = mins.rem_euclid(60);\n        let hour = mins.div_euclid(60);\n        if sec == 0 {\n            write!(f, \"{}{:02}:{:02}\", sign, hour, min)\n        } else {\n            write!(f, \"{}{:02}:{:02}:{:02}\", sign, hour, min, sec)\n        }\n    }\n}","impl fmt::Display for FixedOffset {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        fmt::Debug::fmt(self, f)\n    }\n}"],"offset::local::Local":["Clone","Copy","Debug","impl Local {\n    /// Returns a `Date` which corresponds to the current date.\n    #[deprecated(since = \"0.4.23\", note = \"use `Local::now()` instead\")]\n    #[allow(deprecated)]\n    #[must_use]\n    pub fn today() -> Date<Local> {\n        Local::now().date()\n    }\n\n    /// Returns a `DateTime` which corresponds to the current date and time.\n    #[cfg(not(all(\n        target_arch = \"wasm32\",\n        feature = \"wasmbind\",\n        not(any(target_os = \"emscripten\", target_os = \"wasi\"))\n    )))]\n    #[must_use]\n    pub fn now() -> DateTime<Local> {\n        Utc::now().with_timezone(&Local)\n    }\n\n    /// Returns a `DateTime` which corresponds to the current date and time.\n    #[cfg(all(\n        target_arch = \"wasm32\",\n        feature = \"wasmbind\",\n        not(any(target_os = \"emscripten\", target_os = \"wasi\"))\n    ))]\n    #[must_use]\n    pub fn now() -> DateTime<Local> {\n        use super::Utc;\n        let now: DateTime<Utc> = super::Utc::now();\n\n        // Workaround missing timezone logic in `time` crate\n        let offset =\n            FixedOffset::west_opt((js_sys::Date::new_0().get_timezone_offset() as i32) * 60)\n                .unwrap();\n        DateTime::from_utc(now.naive_utc(), offset)\n    }\n}","impl TimeZone for Local {\n    type Offset = FixedOffset;\n\n    fn from_offset(_offset: &FixedOffset) -> Local {\n        Local\n    }\n\n    #[allow(deprecated)]\n    fn offset_from_local_date(&self, local: &NaiveDate) -> LocalResult<FixedOffset> {\n        // Get the offset at local midnight.\n        self.offset_from_local_datetime(&local.and_time(NaiveTime::MIN))\n    }\n\n    fn offset_from_local_datetime(&self, local: &NaiveDateTime) -> LocalResult<FixedOffset> {\n        inner::offset_from_local_datetime(local)\n    }\n\n    #[allow(deprecated)]\n    fn offset_from_utc_date(&self, utc: &NaiveDate) -> FixedOffset {\n        // Get the offset at midnight.\n        self.offset_from_utc_datetime(&utc.and_time(NaiveTime::MIN))\n    }\n\n    fn offset_from_utc_datetime(&self, utc: &NaiveDateTime) -> FixedOffset {\n        inner::offset_from_utc_datetime(utc).unwrap()\n    }\n}"],"offset::local::inner::Cache":["impl Cache {\n    fn offset(&mut self, d: NaiveDateTime, local: bool) -> LocalResult<FixedOffset> {\n        let now = SystemTime::now();\n\n        match now.duration_since(self.last_checked) {\n            // If the cache has been around for less than a second then we reuse it\n            // unconditionally. This is a reasonable tradeoff because the timezone\n            // generally won't be changing _that_ often, but if the time zone does\n            // change, it will reflect sufficiently quickly from an application\n            // user's perspective.\n            Ok(d) if d.as_secs() < 1 => (),\n            Ok(_) | Err(_) => {\n                let env_tz = env::var(\"TZ\").ok();\n                let env_ref = env_tz.as_deref();\n                let new_source = Source::new(env_ref);\n\n                let out_of_date = match (&self.source, &new_source) {\n                    // change from env to file or file to env, must recreate the zone\n                    (Source::Environment { .. }, Source::LocalTime { .. })\n                    | (Source::LocalTime { .. }, Source::Environment { .. }) => true,\n                    // stay as file, but mtime has changed\n                    (Source::LocalTime { mtime: old_mtime }, Source::LocalTime { mtime })\n                        if old_mtime != mtime =>\n                    {\n                        true\n                    }\n                    // stay as env, but hash of variable has changed\n                    (Source::Environment { hash: old_hash }, Source::Environment { hash })\n                        if old_hash != hash =>\n                    {\n                        true\n                    }\n                    // cache can be reused\n                    _ => false,\n                };\n\n                if out_of_date {\n                    self.zone = current_zone(env_ref);\n                }\n\n                self.last_checked = now;\n                self.source = new_source;\n            }\n        }\n\n        if !local {\n            let offset = self\n                .zone\n                .find_local_time_type(d.timestamp())\n                .expect(\"unable to select local time type\")\n                .offset();\n\n            return match FixedOffset::east_opt(offset) {\n                Some(offset) => LocalResult::Single(offset),\n                None => LocalResult::None,\n            };\n        }\n\n        // we pass through the year as the year of a local point in time must either be valid in that locale, or\n        // the entire time was skipped in which case we will return LocalResult::None anyway.\n        self.zone\n            .find_local_time_type_from_local(d.timestamp(), d.year())\n            .expect(\"unable to select local time type\")\n            .map(|o| FixedOffset::east_opt(o.offset()).unwrap())\n    }\n}","impl Default for Cache {\n    fn default() -> Cache {\n        // default to UTC if no local timezone can be found\n        let env_tz = env::var(\"TZ\").ok();\n        let env_ref = env_tz.as_deref();\n        Cache {\n            last_checked: SystemTime::now(),\n            source: Source::new(env_ref),\n            zone: current_zone(env_ref),\n        }\n    }\n}"],"offset::local::inner::Source":["impl Source {\n    fn new(env_tz: Option<&str>) -> Source {\n        match env_tz {\n            Some(tz) => {\n                let mut hasher = hash_map::DefaultHasher::new();\n                hasher.write(tz.as_bytes());\n                let hash = hasher.finish();\n                Source::Environment { hash }\n            }\n            None => match fs::symlink_metadata(\"/etc/localtime\") {\n                Ok(data) => Source::LocalTime {\n                    // we have to pick a sensible default when the mtime fails\n                    // by picking SystemTime::now() we raise the probability of\n                    // the cache being invalidated if/when the mtime starts working\n                    mtime: data.modified().unwrap_or_else(|_| SystemTime::now()),\n                },\n                Err(_) => {\n                    // as above, now() should be a better default than some constant\n                    // TODO: see if we can improve caching in the case where the fallback is a valid timezone\n                    Source::LocalTime { mtime: SystemTime::now() }\n                }\n            },\n        }\n    }\n}"],"offset::local::tz_info::Error":["Debug","impl From<ParseIntError> for Error {\n    fn from(error: ParseIntError) -> Self {\n        Error::ParseInt(error)\n    }\n}","impl From<SystemTimeError> for Error {\n    fn from(error: SystemTimeError) -> Self {\n        Error::SystemTime(error)\n    }\n}","impl From<Utf8Error> for Error {\n    fn from(error: Utf8Error) -> Self {\n        Error::Utf8(error)\n    }\n}","impl From<io::Error> for Error {\n    fn from(error: io::Error) -> Self {\n        Error::Io(error)\n    }\n}","impl error::Error for Error {}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        use Error::*;\n        match self {\n            DateTime(error) => write!(f, \"invalid date time: {}\", error),\n            FindLocalTimeType(error) => error.fmt(f),\n            LocalTimeType(error) => write!(f, \"invalid local time type: {}\", error),\n            InvalidSlice(error) => error.fmt(f),\n            InvalidTzString(error) => write!(f, \"invalid TZ string: {}\", error),\n            InvalidTzFile(error) => error.fmt(f),\n            Io(error) => error.fmt(f),\n            OutOfRange(error) => error.fmt(f),\n            ParseInt(error) => error.fmt(f),\n            ProjectDateTime(error) => error.fmt(f),\n            SystemTime(error) => error.fmt(f),\n            TransitionRule(error) => write!(f, \"invalid transition rule: {}\", error),\n            TimeZone(error) => write!(f, \"invalid time zone: {}\", error),\n            UnsupportedTzFile(error) => error.fmt(f),\n            UnsupportedTzString(error) => write!(f, \"unsupported TZ string: {}\", error),\n            Utf8(error) => error.fmt(f),\n        }\n    }\n}"],"offset::local::tz_info::parser::Cursor":["Debug","Eq","PartialEq","impl<'a> Cursor<'a> {\n    /// Construct a new `Cursor` from remaining data\n    pub(crate) const fn new(remaining: &'a [u8]) -> Self {\n        Self { remaining, read_count: 0 }\n    }\n\n    pub(crate) fn peek(&self) -> Option<&u8> {\n        self.remaining().first()\n    }\n\n    /// Returns remaining data\n    pub(crate) const fn remaining(&self) -> &'a [u8] {\n        self.remaining\n    }\n\n    /// Returns `true` if data is remaining\n    pub(crate) const fn is_empty(&self) -> bool {\n        self.remaining.is_empty()\n    }\n\n    pub(crate) fn read_be_u32(&mut self) -> Result<u32, Error> {\n        let mut buf = [0; 4];\n        buf.copy_from_slice(self.read_exact(4)?);\n        Ok(u32::from_be_bytes(buf))\n    }\n\n    /// Read exactly `count` bytes, reducing remaining data and incrementing read count\n    pub(crate) fn read_exact(&mut self, count: usize) -> Result<&'a [u8], io::Error> {\n        match (self.remaining.get(..count), self.remaining.get(count..)) {\n            (Some(result), Some(remaining)) => {\n                self.remaining = remaining;\n                self.read_count += count;\n                Ok(result)\n            }\n            _ => Err(io::Error::from(ErrorKind::UnexpectedEof)),\n        }\n    }\n\n    /// Read bytes and compare them to the provided tag\n    pub(crate) fn read_tag(&mut self, tag: &[u8]) -> Result<(), io::Error> {\n        if self.read_exact(tag.len())? == tag {\n            Ok(())\n        } else {\n            Err(io::Error::from(ErrorKind::InvalidData))\n        }\n    }\n\n    /// Read bytes if the remaining data is prefixed by the provided tag\n    pub(crate) fn read_optional_tag(&mut self, tag: &[u8]) -> Result<bool, io::Error> {\n        if self.remaining.starts_with(tag) {\n            self.read_exact(tag.len())?;\n            Ok(true)\n        } else {\n            Ok(false)\n        }\n    }\n\n    /// Read bytes as long as the provided predicate is true\n    pub(crate) fn read_while<F: Fn(&u8) -> bool>(&mut self, f: F) -> Result<&'a [u8], io::Error> {\n        match self.remaining.iter().position(|x| !f(x)) {\n            None => self.read_exact(self.remaining.len()),\n            Some(position) => self.read_exact(position),\n        }\n    }\n\n    // Parse an integer out of the ASCII digits\n    pub(crate) fn read_int<T: FromStr<Err = ParseIntError>>(&mut self) -> Result<T, Error> {\n        let bytes = self.read_while(u8::is_ascii_digit)?;\n        Ok(str::from_utf8(bytes)?.parse()?)\n    }\n\n    /// Read bytes until the provided predicate is true\n    pub(crate) fn read_until<F: Fn(&u8) -> bool>(&mut self, f: F) -> Result<&'a [u8], io::Error> {\n        match self.remaining.iter().position(f) {\n            None => self.read_exact(self.remaining.len()),\n            Some(position) => self.read_exact(position),\n        }\n    }\n}"],"offset::local::tz_info::parser::Header":["Debug","impl Header {\n    fn new(cursor: &mut Cursor) -> Result<Self, Error> {\n        let magic = cursor.read_exact(4)?;\n        if magic != *b\"TZif\" {\n            return Err(Error::InvalidTzFile(\"invalid magic number\"));\n        }\n\n        let version = match cursor.read_exact(1)? {\n            [0x00] => Version::V1,\n            [0x32] => Version::V2,\n            [0x33] => Version::V3,\n            _ => return Err(Error::UnsupportedTzFile(\"unsupported TZif version\")),\n        };\n\n        cursor.read_exact(15)?;\n        let ut_local_count = cursor.read_be_u32()?;\n        let std_wall_count = cursor.read_be_u32()?;\n        let leap_count = cursor.read_be_u32()?;\n        let transition_count = cursor.read_be_u32()?;\n        let type_count = cursor.read_be_u32()?;\n        let char_count = cursor.read_be_u32()?;\n\n        if !(type_count != 0\n            && char_count != 0\n            && (ut_local_count == 0 || ut_local_count == type_count)\n            && (std_wall_count == 0 || std_wall_count == type_count))\n        {\n            return Err(Error::InvalidTzFile(\"invalid header\"));\n        }\n\n        Ok(Self {\n            version,\n            ut_local_count: ut_local_count as usize,\n            std_wall_count: std_wall_count as usize,\n            leap_count: leap_count as usize,\n            transition_count: transition_count as usize,\n            type_count: type_count as usize,\n            char_count: char_count as usize,\n        })\n    }\n}"],"offset::local::tz_info::parser::State":["impl<'a> State<'a> {\n    /// Read TZif data blocks\n    fn new(cursor: &mut Cursor<'a>, first: bool) -> Result<Self, Error> {\n        let header = Header::new(cursor)?;\n        let time_size = match first {\n            true => 4, // We always parse V1 first\n            false => 8,\n        };\n\n        Ok(Self {\n            time_size,\n            transition_times: cursor.read_exact(header.transition_count * time_size)?,\n            transition_types: cursor.read_exact(header.transition_count)?,\n            local_time_types: cursor.read_exact(header.type_count * 6)?,\n            names: cursor.read_exact(header.char_count)?,\n            leap_seconds: cursor.read_exact(header.leap_count * (time_size + 4))?,\n            std_walls: cursor.read_exact(header.std_wall_count)?,\n            ut_locals: cursor.read_exact(header.ut_local_count)?,\n            header,\n        })\n    }\n\n    /// Parse time values\n    fn parse_time(&self, arr: &[u8], version: Version) -> Result<i64, Error> {\n        match version {\n            Version::V1 => Ok(read_be_i32(&arr[..4])?.into()),\n            Version::V2 | Version::V3 => read_be_i64(arr),\n        }\n    }\n}"],"offset::local::tz_info::parser::Version":["Clone","Copy","Debug","Eq","PartialEq"],"offset::local::tz_info::rule::AlternateTime":["Clone","Copy","Debug","Eq","PartialEq","impl AlternateTime {\n    /// Construct a transition rule representing alternate local time types\n    const fn new(\n        std: LocalTimeType,\n        dst: LocalTimeType,\n        dst_start: RuleDay,\n        dst_start_time: i32,\n        dst_end: RuleDay,\n        dst_end_time: i32,\n    ) -> Result<Self, Error> {\n        // Overflow is not possible\n        if !((dst_start_time as i64).abs() < SECONDS_PER_WEEK\n            && (dst_end_time as i64).abs() < SECONDS_PER_WEEK)\n        {\n            return Err(Error::TransitionRule(\"invalid DST start or end time\"));\n        }\n\n        Ok(Self { std, dst, dst_start, dst_start_time, dst_end, dst_end_time })\n    }\n\n    /// Find the local time type associated to the alternate transition rule at the specified Unix time in seconds\n    fn find_local_time_type(&self, unix_time: i64) -> Result<&LocalTimeType, Error> {\n        // Overflow is not possible\n        let dst_start_time_in_utc = self.dst_start_time as i64 - self.std.ut_offset as i64;\n        let dst_end_time_in_utc = self.dst_end_time as i64 - self.dst.ut_offset as i64;\n\n        let current_year = match UtcDateTime::from_timespec(unix_time) {\n            Ok(dt) => dt.year,\n            Err(error) => return Err(error),\n        };\n\n        // Check if the current year is valid for the following computations\n        if !(i32::min_value() + 2 <= current_year && current_year <= i32::max_value() - 2) {\n            return Err(Error::OutOfRange(\"out of range date time\"));\n        }\n\n        let current_year_dst_start_unix_time =\n            self.dst_start.unix_time(current_year, dst_start_time_in_utc);\n        let current_year_dst_end_unix_time =\n            self.dst_end.unix_time(current_year, dst_end_time_in_utc);\n\n        // Check DST start/end Unix times for previous/current/next years to support for transition day times outside of [0h, 24h] range\n        let is_dst =\n            match Ord::cmp(&current_year_dst_start_unix_time, &current_year_dst_end_unix_time) {\n                Ordering::Less | Ordering::Equal => {\n                    if unix_time < current_year_dst_start_unix_time {\n                        let previous_year_dst_end_unix_time =\n                            self.dst_end.unix_time(current_year - 1, dst_end_time_in_utc);\n                        if unix_time < previous_year_dst_end_unix_time {\n                            let previous_year_dst_start_unix_time =\n                                self.dst_start.unix_time(current_year - 1, dst_start_time_in_utc);\n                            previous_year_dst_start_unix_time <= unix_time\n                        } else {\n                            false\n                        }\n                    } else if unix_time < current_year_dst_end_unix_time {\n                        true\n                    } else {\n                        let next_year_dst_start_unix_time =\n                            self.dst_start.unix_time(current_year + 1, dst_start_time_in_utc);\n                        if next_year_dst_start_unix_time <= unix_time {\n                            let next_year_dst_end_unix_time =\n                                self.dst_end.unix_time(current_year + 1, dst_end_time_in_utc);\n                            unix_time < next_year_dst_end_unix_time\n                        } else {\n                            false\n                        }\n                    }\n                }\n                Ordering::Greater => {\n                    if unix_time < current_year_dst_end_unix_time {\n                        let previous_year_dst_start_unix_time =\n                            self.dst_start.unix_time(current_year - 1, dst_start_time_in_utc);\n                        if unix_time < previous_year_dst_start_unix_time {\n                            let previous_year_dst_end_unix_time =\n                                self.dst_end.unix_time(current_year - 1, dst_end_time_in_utc);\n                            unix_time < previous_year_dst_end_unix_time\n                        } else {\n                            true\n                        }\n                    } else if unix_time < current_year_dst_start_unix_time {\n                        false\n                    } else {\n                        let next_year_dst_end_unix_time =\n                            self.dst_end.unix_time(current_year + 1, dst_end_time_in_utc);\n                        if next_year_dst_end_unix_time <= unix_time {\n                            let next_year_dst_start_unix_time =\n                                self.dst_start.unix_time(current_year + 1, dst_start_time_in_utc);\n                            next_year_dst_start_unix_time <= unix_time\n                        } else {\n                            true\n                        }\n                    }\n                }\n            };\n\n        if is_dst {\n            Ok(&self.dst)\n        } else {\n            Ok(&self.std)\n        }\n    }\n\n    fn find_local_time_type_from_local(\n        &self,\n        local_time: i64,\n        current_year: i32,\n    ) -> Result<crate::LocalResult<LocalTimeType>, Error> {\n        // Check if the current year is valid for the following computations\n        if !(i32::min_value() + 2 <= current_year && current_year <= i32::max_value() - 2) {\n            return Err(Error::OutOfRange(\"out of range date time\"));\n        }\n\n        let dst_start_transition_start =\n            self.dst_start.unix_time(current_year, 0) + i64::from(self.dst_start_time);\n        let dst_start_transition_end = self.dst_start.unix_time(current_year, 0)\n            + i64::from(self.dst_start_time)\n            + i64::from(self.dst.ut_offset)\n            - i64::from(self.std.ut_offset);\n\n        let dst_end_transition_start =\n            self.dst_end.unix_time(current_year, 0) + i64::from(self.dst_end_time);\n        let dst_end_transition_end = self.dst_end.unix_time(current_year, 0)\n            + i64::from(self.dst_end_time)\n            + i64::from(self.std.ut_offset)\n            - i64::from(self.dst.ut_offset);\n\n        match self.std.ut_offset.cmp(&self.dst.ut_offset) {\n            Ordering::Equal => Ok(crate::LocalResult::Single(self.std)),\n            Ordering::Less => {\n                if self.dst_start.transition_date(current_year).0\n                    < self.dst_end.transition_date(current_year).0\n                {\n                    // northern hemisphere\n                    // For the DST END transition, the `start` happens at a later timestamp than the `end`.\n                    if local_time <= dst_start_transition_start {\n                        Ok(crate::LocalResult::Single(self.std))\n                    } else if local_time > dst_start_transition_start\n                        && local_time < dst_start_transition_end\n                    {\n                        Ok(crate::LocalResult::None)\n                    } else if local_time >= dst_start_transition_end\n                        && local_time < dst_end_transition_end\n                    {\n                        Ok(crate::LocalResult::Single(self.dst))\n                    } else if local_time >= dst_end_transition_end\n                        && local_time <= dst_end_transition_start\n                    {\n                        Ok(crate::LocalResult::Ambiguous(self.std, self.dst))\n                    } else {\n                        Ok(crate::LocalResult::Single(self.std))\n                    }\n                } else {\n                    // southern hemisphere regular DST\n                    // For the DST END transition, the `start` happens at a later timestamp than the `end`.\n                    if local_time < dst_end_transition_end {\n                        Ok(crate::LocalResult::Single(self.dst))\n                    } else if local_time >= dst_end_transition_end\n                        && local_time <= dst_end_transition_start\n                    {\n                        Ok(crate::LocalResult::Ambiguous(self.std, self.dst))\n                    } else if local_time > dst_end_transition_end\n                        && local_time < dst_start_transition_start\n                    {\n                        Ok(crate::LocalResult::Single(self.std))\n                    } else if local_time >= dst_start_transition_start\n                        && local_time < dst_start_transition_end\n                    {\n                        Ok(crate::LocalResult::None)\n                    } else {\n                        Ok(crate::LocalResult::Single(self.dst))\n                    }\n                }\n            }\n            Ordering::Greater => {\n                if self.dst_start.transition_date(current_year).0\n                    < self.dst_end.transition_date(current_year).0\n                {\n                    // southern hemisphere reverse DST\n                    // For the DST END transition, the `start` happens at a later timestamp than the `end`.\n                    if local_time < dst_start_transition_end {\n                        Ok(crate::LocalResult::Single(self.std))\n                    } else if local_time >= dst_start_transition_end\n                        && local_time <= dst_start_transition_start\n                    {\n                        Ok(crate::LocalResult::Ambiguous(self.dst, self.std))\n                    } else if local_time > dst_start_transition_start\n                        && local_time < dst_end_transition_start\n                    {\n                        Ok(crate::LocalResult::Single(self.dst))\n                    } else if local_time >= dst_end_transition_start\n                        && local_time < dst_end_transition_end\n                    {\n                        Ok(crate::LocalResult::None)\n                    } else {\n                        Ok(crate::LocalResult::Single(self.std))\n                    }\n                } else {\n                    // northern hemisphere reverse DST\n                    // For the DST END transition, the `start` happens at a later timestamp than the `end`.\n                    if local_time <= dst_end_transition_start {\n                        Ok(crate::LocalResult::Single(self.dst))\n                    } else if local_time > dst_end_transition_start\n                        && local_time < dst_end_transition_end\n                    {\n                        Ok(crate::LocalResult::None)\n                    } else if local_time >= dst_end_transition_end\n                        && local_time < dst_start_transition_end\n                    {\n                        Ok(crate::LocalResult::Single(self.std))\n                    } else if local_time >= dst_start_transition_end\n                        && local_time <= dst_start_transition_start\n                    {\n                        Ok(crate::LocalResult::Ambiguous(self.dst, self.std))\n                    } else {\n                        Ok(crate::LocalResult::Single(self.dst))\n                    }\n                }\n            }\n        }\n    }\n}"],"offset::local::tz_info::rule::RuleDay":["Clone","Copy","Debug","Eq","PartialEq","impl RuleDay {\n    /// Parse transition rule\n    fn parse(cursor: &mut Cursor, use_string_extensions: bool) -> Result<(Self, i32), Error> {\n        let date = match cursor.peek() {\n            Some(b'M') => {\n                cursor.read_exact(1)?;\n                let month = cursor.read_int()?;\n                cursor.read_tag(b\".\")?;\n                let week = cursor.read_int()?;\n                cursor.read_tag(b\".\")?;\n                let week_day = cursor.read_int()?;\n                RuleDay::month_weekday(month, week, week_day)?\n            }\n            Some(b'J') => {\n                cursor.read_exact(1)?;\n                RuleDay::julian_1(cursor.read_int()?)?\n            }\n            _ => RuleDay::julian_0(cursor.read_int()?)?,\n        };\n\n        Ok((\n            date,\n            match (cursor.read_optional_tag(b\"/\")?, use_string_extensions) {\n                (false, _) => 2 * 3600,\n                (true, true) => parse_rule_time_extended(cursor)?,\n                (true, false) => parse_rule_time(cursor)?,\n            },\n        ))\n    }\n\n    /// Construct a transition rule day represented by a Julian day in `[1, 365]`, without taking occasional Feb 29 into account, which is not referenceable\n    fn julian_1(julian_day_1: u16) -> Result<Self, Error> {\n        if !(1..=365).contains(&julian_day_1) {\n            return Err(Error::TransitionRule(\"invalid rule day julian day\"));\n        }\n\n        Ok(RuleDay::Julian1WithoutLeap(julian_day_1))\n    }\n\n    /// Construct a transition rule day represented by a zero-based Julian day in `[0, 365]`, taking occasional Feb 29 into account\n    const fn julian_0(julian_day_0: u16) -> Result<Self, Error> {\n        if julian_day_0 > 365 {\n            return Err(Error::TransitionRule(\"invalid rule day julian day\"));\n        }\n\n        Ok(RuleDay::Julian0WithLeap(julian_day_0))\n    }\n\n    /// Construct a transition rule day represented by a month, a month week and a week day\n    fn month_weekday(month: u8, week: u8, week_day: u8) -> Result<Self, Error> {\n        if !(1..=12).contains(&month) {\n            return Err(Error::TransitionRule(\"invalid rule day month\"));\n        }\n\n        if !(1..=5).contains(&week) {\n            return Err(Error::TransitionRule(\"invalid rule day week\"));\n        }\n\n        if week_day > 6 {\n            return Err(Error::TransitionRule(\"invalid rule day week day\"));\n        }\n\n        Ok(RuleDay::MonthWeekday { month, week, week_day })\n    }\n\n    /// Get the transition date for the provided year\n    ///\n    /// ## Outputs\n    ///\n    /// * `month`: Month in `[1, 12]`\n    /// * `month_day`: Day of the month in `[1, 31]`\n    fn transition_date(&self, year: i32) -> (usize, i64) {\n        match *self {\n            RuleDay::Julian1WithoutLeap(year_day) => {\n                let year_day = year_day as i64;\n\n                let month = match CUMUL_DAY_IN_MONTHS_NORMAL_YEAR.binary_search(&(year_day - 1)) {\n                    Ok(x) => x + 1,\n                    Err(x) => x,\n                };\n\n                let month_day = year_day - CUMUL_DAY_IN_MONTHS_NORMAL_YEAR[month - 1];\n\n                (month, month_day)\n            }\n            RuleDay::Julian0WithLeap(year_day) => {\n                let leap = is_leap_year(year) as i64;\n\n                let cumul_day_in_months = [\n                    0,\n                    31,\n                    59 + leap,\n                    90 + leap,\n                    120 + leap,\n                    151 + leap,\n                    181 + leap,\n                    212 + leap,\n                    243 + leap,\n                    273 + leap,\n                    304 + leap,\n                    334 + leap,\n                ];\n\n                let year_day = year_day as i64;\n\n                let month = match cumul_day_in_months.binary_search(&year_day) {\n                    Ok(x) => x + 1,\n                    Err(x) => x,\n                };\n\n                let month_day = 1 + year_day - cumul_day_in_months[month - 1];\n\n                (month, month_day)\n            }\n            RuleDay::MonthWeekday { month: rule_month, week, week_day } => {\n                let leap = is_leap_year(year) as i64;\n\n                let month = rule_month as usize;\n\n                let mut day_in_month = DAY_IN_MONTHS_NORMAL_YEAR[month - 1];\n                if month == 2 {\n                    day_in_month += leap;\n                }\n\n                let week_day_of_first_month_day =\n                    (4 + days_since_unix_epoch(year, month, 1)).rem_euclid(DAYS_PER_WEEK);\n                let first_week_day_occurence_in_month =\n                    1 + (week_day as i64 - week_day_of_first_month_day).rem_euclid(DAYS_PER_WEEK);\n\n                let mut month_day =\n                    first_week_day_occurence_in_month + (week as i64 - 1) * DAYS_PER_WEEK;\n                if month_day > day_in_month {\n                    month_day -= DAYS_PER_WEEK\n                }\n\n                (month, month_day)\n            }\n        }\n    }\n\n    /// Returns the UTC Unix time in seconds associated to the transition date for the provided year\n    fn unix_time(&self, year: i32, day_time_in_utc: i64) -> i64 {\n        let (month, month_day) = self.transition_date(year);\n        days_since_unix_epoch(year, month, month_day) * SECONDS_PER_DAY + day_time_in_utc\n    }\n}"],"offset::local::tz_info::rule::TransitionRule":["Clone","Copy","Debug","Eq","PartialEq","impl From<AlternateTime> for TransitionRule {\n    fn from(inner: AlternateTime) -> Self {\n        TransitionRule::Alternate(inner)\n    }\n}","impl From<LocalTimeType> for TransitionRule {\n    fn from(inner: LocalTimeType) -> Self {\n        TransitionRule::Fixed(inner)\n    }\n}","impl TransitionRule {\n    /// Parse a POSIX TZ string containing a time zone description, as described in [the POSIX documentation of the `TZ` environment variable](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html).\n    ///\n    /// TZ string extensions from [RFC 8536](https://datatracker.ietf.org/doc/html/rfc8536#section-3.3.1) may be used.\n    ///\n    pub(super) fn from_tz_string(\n        tz_string: &[u8],\n        use_string_extensions: bool,\n    ) -> Result<Self, Error> {\n        let mut cursor = Cursor::new(tz_string);\n\n        let std_time_zone = Some(parse_name(&mut cursor)?);\n        let std_offset = parse_offset(&mut cursor)?;\n\n        if cursor.is_empty() {\n            return Ok(LocalTimeType::new(-std_offset, false, std_time_zone)?.into());\n        }\n\n        let dst_time_zone = Some(parse_name(&mut cursor)?);\n\n        let dst_offset = match cursor.peek() {\n            Some(&b',') => std_offset - 3600,\n            Some(_) => parse_offset(&mut cursor)?,\n            None => {\n                return Err(Error::UnsupportedTzString(\"DST start and end rules must be provided\"))\n            }\n        };\n\n        if cursor.is_empty() {\n            return Err(Error::UnsupportedTzString(\"DST start and end rules must be provided\"));\n        }\n\n        cursor.read_tag(b\",\")?;\n        let (dst_start, dst_start_time) = RuleDay::parse(&mut cursor, use_string_extensions)?;\n\n        cursor.read_tag(b\",\")?;\n        let (dst_end, dst_end_time) = RuleDay::parse(&mut cursor, use_string_extensions)?;\n\n        if !cursor.is_empty() {\n            return Err(Error::InvalidTzString(\"remaining data after parsing TZ string\"));\n        }\n\n        Ok(AlternateTime::new(\n            LocalTimeType::new(-std_offset, false, std_time_zone)?,\n            LocalTimeType::new(-dst_offset, true, dst_time_zone)?,\n            dst_start,\n            dst_start_time,\n            dst_end,\n            dst_end_time,\n        )?\n        .into())\n    }\n\n    /// Find the local time type associated to the transition rule at the specified Unix time in seconds\n    pub(super) fn find_local_time_type(&self, unix_time: i64) -> Result<&LocalTimeType, Error> {\n        match self {\n            TransitionRule::Fixed(local_time_type) => Ok(local_time_type),\n            TransitionRule::Alternate(alternate_time) => {\n                alternate_time.find_local_time_type(unix_time)\n            }\n        }\n    }\n\n    /// Find the local time type associated to the transition rule at the specified Unix time in seconds\n    pub(super) fn find_local_time_type_from_local(\n        &self,\n        local_time: i64,\n        year: i32,\n    ) -> Result<crate::LocalResult<LocalTimeType>, Error> {\n        match self {\n            TransitionRule::Fixed(local_time_type) => {\n                Ok(crate::LocalResult::Single(*local_time_type))\n            }\n            TransitionRule::Alternate(alternate_time) => {\n                alternate_time.find_local_time_type_from_local(local_time, year)\n            }\n        }\n    }\n}"],"offset::local::tz_info::rule::UtcDateTime":["Clone","Copy","Debug","Eq","Ord","PartialEq","PartialOrd","impl UtcDateTime {\n    /// Construct a UTC date time from a Unix time in seconds and nanoseconds\n    pub(crate) fn from_timespec(unix_time: i64) -> Result<Self, Error> {\n        let seconds = match unix_time.checked_sub(UNIX_OFFSET_SECS) {\n            Some(seconds) => seconds,\n            None => return Err(Error::OutOfRange(\"out of range operation\")),\n        };\n\n        let mut remaining_days = seconds / SECONDS_PER_DAY;\n        let mut remaining_seconds = seconds % SECONDS_PER_DAY;\n        if remaining_seconds < 0 {\n            remaining_seconds += SECONDS_PER_DAY;\n            remaining_days -= 1;\n        }\n\n        let mut cycles_400_years = remaining_days / DAYS_PER_400_YEARS;\n        remaining_days %= DAYS_PER_400_YEARS;\n        if remaining_days < 0 {\n            remaining_days += DAYS_PER_400_YEARS;\n            cycles_400_years -= 1;\n        }\n\n        let cycles_100_years = Ord::min(remaining_days / DAYS_PER_100_YEARS, 3);\n        remaining_days -= cycles_100_years * DAYS_PER_100_YEARS;\n\n        let cycles_4_years = Ord::min(remaining_days / DAYS_PER_4_YEARS, 24);\n        remaining_days -= cycles_4_years * DAYS_PER_4_YEARS;\n\n        let remaining_years = Ord::min(remaining_days / DAYS_PER_NORMAL_YEAR, 3);\n        remaining_days -= remaining_years * DAYS_PER_NORMAL_YEAR;\n\n        let mut year = OFFSET_YEAR\n            + remaining_years\n            + cycles_4_years * 4\n            + cycles_100_years * 100\n            + cycles_400_years * 400;\n\n        let mut month = 0;\n        while month < DAY_IN_MONTHS_LEAP_YEAR_FROM_MARCH.len() {\n            let days = DAY_IN_MONTHS_LEAP_YEAR_FROM_MARCH[month];\n            if remaining_days < days {\n                break;\n            }\n            remaining_days -= days;\n            month += 1;\n        }\n        month += 2;\n\n        if month >= MONTHS_PER_YEAR as usize {\n            month -= MONTHS_PER_YEAR as usize;\n            year += 1;\n        }\n        month += 1;\n\n        let month_day = 1 + remaining_days;\n\n        let hour = remaining_seconds / SECONDS_PER_HOUR;\n        let minute = (remaining_seconds / SECONDS_PER_MINUTE) % MINUTES_PER_HOUR;\n        let second = remaining_seconds % SECONDS_PER_MINUTE;\n\n        let year = match year >= i32::min_value() as i64 && year <= i32::max_value() as i64 {\n            true => year as i32,\n            false => return Err(Error::OutOfRange(\"i64 is out of range for i32\")),\n        };\n\n        Ok(Self {\n            year,\n            month: month as u8,\n            month_day: month_day as u8,\n            hour: hour as u8,\n            minute: minute as u8,\n            second: second as u8,\n        })\n    }\n}"],"offset::local::tz_info::timezone::LeapSecond":["Clone","Copy","Debug","Eq","PartialEq","impl LeapSecond {\n    /// Construct a TZif file leap second\n    pub(super) const fn new(unix_leap_time: i64, correction: i32) -> Self {\n        Self { unix_leap_time, correction }\n    }\n\n    /// Returns Unix leap time\n    const fn unix_leap_time(&self) -> i64 {\n        self.unix_leap_time\n    }\n}"],"offset::local::tz_info::timezone::LocalTimeType":["Clone","Copy","Debug","Eq","PartialEq","impl LocalTimeType {\n    /// Construct a local time type\n    pub(super) fn new(ut_offset: i32, is_dst: bool, name: Option<&[u8]>) -> Result<Self, Error> {\n        if ut_offset == i32::min_value() {\n            return Err(Error::LocalTimeType(\"invalid UTC offset\"));\n        }\n\n        let name = match name {\n            Some(name) => TimeZoneName::new(name)?,\n            None => return Ok(Self { ut_offset, is_dst, name: None }),\n        };\n\n        Ok(Self { ut_offset, is_dst, name: Some(name) })\n    }\n\n    /// Construct a local time type with the specified UTC offset in seconds\n    pub(super) const fn with_offset(ut_offset: i32) -> Result<Self, Error> {\n        if ut_offset == i32::min_value() {\n            return Err(Error::LocalTimeType(\"invalid UTC offset\"));\n        }\n\n        Ok(Self { ut_offset, is_dst: false, name: None })\n    }\n\n    /// Returns offset from UTC in seconds\n    pub(crate) const fn offset(&self) -> i32 {\n        self.ut_offset\n    }\n\n    /// Returns daylight saving time indicator\n    pub(super) const fn is_dst(&self) -> bool {\n        self.is_dst\n    }\n\n    pub(super) const UTC: LocalTimeType = Self { ut_offset: 0, is_dst: false, name: None };\n}"],"offset::local::tz_info::timezone::TimeZone":["Clone","Debug","Eq","PartialEq","impl TimeZone {\n    /// Returns local time zone.\n    ///\n    /// This method in not supported on non-UNIX platforms, and returns the UTC time zone instead.\n    ///\n    pub(crate) fn local(env_tz: Option<&str>) -> Result<Self, Error> {\n        match env_tz {\n            Some(tz) => Self::from_posix_tz(tz),\n            None => Self::from_posix_tz(\"localtime\"),\n        }\n    }\n\n    /// Construct a time zone from a POSIX TZ string, as described in [the POSIX documentation of the `TZ` environment variable](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html).\n    fn from_posix_tz(tz_string: &str) -> Result<Self, Error> {\n        if tz_string.is_empty() {\n            return Err(Error::InvalidTzString(\"empty TZ string\"));\n        }\n\n        if tz_string == \"localtime\" {\n            return Self::from_tz_data(&fs::read(\"/etc/localtime\")?);\n        }\n\n        // attributes are not allowed on if blocks in Rust 1.38\n        #[cfg(target_os = \"android\")]\n        {\n            if let Ok(bytes) = android_tzdata::find_tz_data(tz_string) {\n                return Self::from_tz_data(&bytes);\n            }\n        }\n\n        let mut chars = tz_string.chars();\n        if chars.next() == Some(':') {\n            return Self::from_file(&mut find_tz_file(chars.as_str())?);\n        }\n\n        if let Ok(mut file) = find_tz_file(tz_string) {\n            return Self::from_file(&mut file);\n        }\n\n        // TZ string extensions are not allowed\n        let tz_string = tz_string.trim_matches(|c: char| c.is_ascii_whitespace());\n        let rule = TransitionRule::from_tz_string(tz_string.as_bytes(), false)?;\n        Self::new(\n            vec![],\n            match rule {\n                TransitionRule::Fixed(local_time_type) => vec![local_time_type],\n                TransitionRule::Alternate(AlternateTime { std, dst, .. }) => vec![std, dst],\n            },\n            vec![],\n            Some(rule),\n        )\n    }\n\n    /// Construct a time zone\n    pub(super) fn new(\n        transitions: Vec<Transition>,\n        local_time_types: Vec<LocalTimeType>,\n        leap_seconds: Vec<LeapSecond>,\n        extra_rule: Option<TransitionRule>,\n    ) -> Result<Self, Error> {\n        let new = Self { transitions, local_time_types, leap_seconds, extra_rule };\n        new.as_ref().validate()?;\n        Ok(new)\n    }\n\n    /// Construct a time zone from the contents of a time zone file\n    fn from_file(file: &mut File) -> Result<Self, Error> {\n        let mut bytes = Vec::new();\n        file.read_to_end(&mut bytes)?;\n        Self::from_tz_data(&bytes)\n    }\n\n    /// Construct a time zone from the contents of a time zone file\n    ///\n    /// Parse TZif data as described in [RFC 8536](https://datatracker.ietf.org/doc/html/rfc8536).\n    pub(crate) fn from_tz_data(bytes: &[u8]) -> Result<Self, Error> {\n        parser::parse(bytes)\n    }\n\n    /// Construct a time zone with the specified UTC offset in seconds\n    fn fixed(ut_offset: i32) -> Result<Self, Error> {\n        Ok(Self {\n            transitions: Vec::new(),\n            local_time_types: vec![LocalTimeType::with_offset(ut_offset)?],\n            leap_seconds: Vec::new(),\n            extra_rule: None,\n        })\n    }\n\n    /// Construct the time zone associated to UTC\n    pub(crate) fn utc() -> Self {\n        Self {\n            transitions: Vec::new(),\n            local_time_types: vec![LocalTimeType::UTC],\n            leap_seconds: Vec::new(),\n            extra_rule: None,\n        }\n    }\n\n    /// Find the local time type associated to the time zone at the specified Unix time in seconds\n    pub(crate) fn find_local_time_type(&self, unix_time: i64) -> Result<&LocalTimeType, Error> {\n        self.as_ref().find_local_time_type(unix_time)\n    }\n\n    // should we pass NaiveDateTime all the way through to this fn?\n    pub(crate) fn find_local_time_type_from_local(\n        &self,\n        local_time: i64,\n        year: i32,\n    ) -> Result<crate::LocalResult<LocalTimeType>, Error> {\n        self.as_ref().find_local_time_type_from_local(local_time, year)\n    }\n\n    /// Returns a reference to the time zone\n    fn as_ref(&self) -> TimeZoneRef {\n        TimeZoneRef {\n            transitions: &self.transitions,\n            local_time_types: &self.local_time_types,\n            leap_seconds: &self.leap_seconds,\n            extra_rule: &self.extra_rule,\n        }\n    }\n}"],"offset::local::tz_info::timezone::TimeZoneName":["Clone","Copy","Eq","PartialEq","impl AsRef<str> for TimeZoneName {\n    fn as_ref(&self) -> &str {\n        // SAFETY: ASCII is valid UTF-8\n        unsafe { str::from_utf8_unchecked(self.as_bytes()) }\n    }\n}","impl TimeZoneName {\n    /// Construct a time zone name\n    fn new(input: &[u8]) -> Result<Self, Error> {\n        let len = input.len();\n\n        if !(3..=7).contains(&len) {\n            return Err(Error::LocalTimeType(\n                \"time zone name must have between 3 and 7 characters\",\n            ));\n        }\n\n        let mut bytes = [0; 8];\n        bytes[0] = input.len() as u8;\n\n        let mut i = 0;\n        while i < len {\n            let b = input[i];\n            match b {\n                b'0'..=b'9' | b'A'..=b'Z' | b'a'..=b'z' | b'+' | b'-' => {}\n                _ => return Err(Error::LocalTimeType(\"invalid characters in time zone name\")),\n            }\n\n            bytes[i + 1] = b;\n            i += 1;\n        }\n\n        Ok(Self { bytes })\n    }\n\n    /// Returns time zone name as a byte slice\n    fn as_bytes(&self) -> &[u8] {\n        match self.bytes[0] {\n            3 => &self.bytes[1..4],\n            4 => &self.bytes[1..5],\n            5 => &self.bytes[1..6],\n            6 => &self.bytes[1..7],\n            7 => &self.bytes[1..8],\n            _ => unreachable!(),\n        }\n    }\n\n    /// Check if two time zone names are equal\n    fn equal(&self, other: &Self) -> bool {\n        self.bytes == other.bytes\n    }\n}","impl fmt::Debug for TimeZoneName {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        self.as_ref().fmt(f)\n    }\n}"],"offset::local::tz_info::timezone::TimeZoneRef":["Clone","Copy","Debug","Eq","PartialEq","impl<'a> TimeZoneRef<'a> {\n    /// Find the local time type associated to the time zone at the specified Unix time in seconds\n    pub(crate) fn find_local_time_type(&self, unix_time: i64) -> Result<&'a LocalTimeType, Error> {\n        let extra_rule = match self.transitions.last() {\n            None => match self.extra_rule {\n                Some(extra_rule) => extra_rule,\n                None => return Ok(&self.local_time_types[0]),\n            },\n            Some(last_transition) => {\n                let unix_leap_time = match self.unix_time_to_unix_leap_time(unix_time) {\n                    Ok(unix_leap_time) => unix_leap_time,\n                    Err(Error::OutOfRange(error)) => return Err(Error::FindLocalTimeType(error)),\n                    Err(err) => return Err(err),\n                };\n\n                if unix_leap_time >= last_transition.unix_leap_time {\n                    match self.extra_rule {\n                        Some(extra_rule) => extra_rule,\n                        None => {\n                            return Err(Error::FindLocalTimeType(\n                                \"no local time type is available for the specified timestamp\",\n                            ))\n                        }\n                    }\n                } else {\n                    let index = match self\n                        .transitions\n                        .binary_search_by_key(&unix_leap_time, Transition::unix_leap_time)\n                    {\n                        Ok(x) => x + 1,\n                        Err(x) => x,\n                    };\n\n                    let local_time_type_index = if index > 0 {\n                        self.transitions[index - 1].local_time_type_index\n                    } else {\n                        0\n                    };\n                    return Ok(&self.local_time_types[local_time_type_index]);\n                }\n            }\n        };\n\n        match extra_rule.find_local_time_type(unix_time) {\n            Ok(local_time_type) => Ok(local_time_type),\n            Err(Error::OutOfRange(error)) => Err(Error::FindLocalTimeType(error)),\n            err => err,\n        }\n    }\n\n    pub(crate) fn find_local_time_type_from_local(\n        &self,\n        local_time: i64,\n        year: i32,\n    ) -> Result<crate::LocalResult<LocalTimeType>, Error> {\n        // #TODO: this is wrong as we need 'local_time_to_local_leap_time ?\n        // but ... does the local time even include leap seconds ??\n        // let unix_leap_time = match self.unix_time_to_unix_leap_time(local_time) {\n        //     Ok(unix_leap_time) => unix_leap_time,\n        //     Err(Error::OutOfRange(error)) => return Err(Error::FindLocalTimeType(error)),\n        //     Err(err) => return Err(err),\n        // };\n        let local_leap_time = local_time;\n\n        // if we have at least one transition,\n        // we must check _all_ of them, incase of any Overlapping (LocalResult::Ambiguous) or Skipping (LocalResult::None) transitions\n        if !self.transitions.is_empty() {\n            let mut prev = Some(self.local_time_types[0]);\n\n            for transition in self.transitions {\n                let after_ltt = self.local_time_types[transition.local_time_type_index];\n\n                // the end and start here refers to where the time starts prior to the transition\n                // and where it ends up after. not the temporal relationship.\n                let transition_end = transition.unix_leap_time + i64::from(after_ltt.ut_offset);\n                let transition_start =\n                    transition.unix_leap_time + i64::from(prev.unwrap().ut_offset);\n\n                match transition_start.cmp(&transition_end) {\n                    Ordering::Greater => {\n                        // bakwards transition, eg from DST to regular\n                        // this means a given local time could have one of two possible offsets\n                        if local_leap_time < transition_end {\n                            return Ok(crate::LocalResult::Single(prev.unwrap()));\n                        } else if local_leap_time >= transition_end\n                            && local_leap_time <= transition_start\n                        {\n                            if prev.unwrap().ut_offset < after_ltt.ut_offset {\n                                return Ok(crate::LocalResult::Ambiguous(prev.unwrap(), after_ltt));\n                            } else {\n                                return Ok(crate::LocalResult::Ambiguous(after_ltt, prev.unwrap()));\n                            }\n                        }\n                    }\n                    Ordering::Equal => {\n                        // should this ever happen? presumably we have to handle it anyway.\n                        if local_leap_time < transition_start {\n                            return Ok(crate::LocalResult::Single(prev.unwrap()));\n                        } else if local_leap_time == transition_end {\n                            if prev.unwrap().ut_offset < after_ltt.ut_offset {\n                                return Ok(crate::LocalResult::Ambiguous(prev.unwrap(), after_ltt));\n                            } else {\n                                return Ok(crate::LocalResult::Ambiguous(after_ltt, prev.unwrap()));\n                            }\n                        }\n                    }\n                    Ordering::Less => {\n                        // forwards transition, eg from regular to DST\n                        // this means that times that are skipped are invalid local times\n                        if local_leap_time <= transition_start {\n                            return Ok(crate::LocalResult::Single(prev.unwrap()));\n                        } else if local_leap_time < transition_end {\n                            return Ok(crate::LocalResult::None);\n                        } else if local_leap_time == transition_end {\n                            return Ok(crate::LocalResult::Single(after_ltt));\n                        }\n                    }\n                }\n\n                // try the next transition, we are fully after this one\n                prev = Some(after_ltt);\n            }\n        };\n\n        if let Some(extra_rule) = self.extra_rule {\n            match extra_rule.find_local_time_type_from_local(local_time, year) {\n                Ok(local_time_type) => Ok(local_time_type),\n                Err(Error::OutOfRange(error)) => Err(Error::FindLocalTimeType(error)),\n                err => err,\n            }\n        } else {\n            Ok(crate::LocalResult::Single(self.local_time_types[0]))\n        }\n    }\n\n    /// Check time zone inputs\n    fn validate(&self) -> Result<(), Error> {\n        // Check local time types\n        let local_time_types_size = self.local_time_types.len();\n        if local_time_types_size == 0 {\n            return Err(Error::TimeZone(\"list of local time types must not be empty\"));\n        }\n\n        // Check transitions\n        let mut i_transition = 0;\n        while i_transition < self.transitions.len() {\n            if self.transitions[i_transition].local_time_type_index >= local_time_types_size {\n                return Err(Error::TimeZone(\"invalid local time type index\"));\n            }\n\n            if i_transition + 1 < self.transitions.len()\n                && self.transitions[i_transition].unix_leap_time\n                    >= self.transitions[i_transition + 1].unix_leap_time\n            {\n                return Err(Error::TimeZone(\"invalid transition\"));\n            }\n\n            i_transition += 1;\n        }\n\n        // Check leap seconds\n        if !(self.leap_seconds.is_empty()\n            || self.leap_seconds[0].unix_leap_time >= 0\n                && saturating_abs(self.leap_seconds[0].correction) == 1)\n        {\n            return Err(Error::TimeZone(\"invalid leap second\"));\n        }\n\n        let min_interval = SECONDS_PER_28_DAYS - 1;\n\n        let mut i_leap_second = 0;\n        while i_leap_second < self.leap_seconds.len() {\n            if i_leap_second + 1 < self.leap_seconds.len() {\n                let x0 = &self.leap_seconds[i_leap_second];\n                let x1 = &self.leap_seconds[i_leap_second + 1];\n\n                let diff_unix_leap_time = x1.unix_leap_time.saturating_sub(x0.unix_leap_time);\n                let abs_diff_correction =\n                    saturating_abs(x1.correction.saturating_sub(x0.correction));\n\n                if !(diff_unix_leap_time >= min_interval && abs_diff_correction == 1) {\n                    return Err(Error::TimeZone(\"invalid leap second\"));\n                }\n            }\n            i_leap_second += 1;\n        }\n\n        // Check extra rule\n        let (extra_rule, last_transition) = match (&self.extra_rule, self.transitions.last()) {\n            (Some(rule), Some(trans)) => (rule, trans),\n            _ => return Ok(()),\n        };\n\n        let last_local_time_type = &self.local_time_types[last_transition.local_time_type_index];\n        let unix_time = match self.unix_leap_time_to_unix_time(last_transition.unix_leap_time) {\n            Ok(unix_time) => unix_time,\n            Err(Error::OutOfRange(error)) => return Err(Error::TimeZone(error)),\n            Err(err) => return Err(err),\n        };\n\n        let rule_local_time_type = match extra_rule.find_local_time_type(unix_time) {\n            Ok(rule_local_time_type) => rule_local_time_type,\n            Err(Error::OutOfRange(error)) => return Err(Error::TimeZone(error)),\n            Err(err) => return Err(err),\n        };\n\n        let check = last_local_time_type.ut_offset == rule_local_time_type.ut_offset\n            && last_local_time_type.is_dst == rule_local_time_type.is_dst\n            && match (&last_local_time_type.name, &rule_local_time_type.name) {\n                (Some(x), Some(y)) => x.equal(y),\n                (None, None) => true,\n                _ => false,\n            };\n\n        if !check {\n            return Err(Error::TimeZone(\n                \"extra transition rule is inconsistent with the last transition\",\n            ));\n        }\n\n        Ok(())\n    }\n\n    /// Convert Unix time to Unix leap time, from the list of leap seconds in a time zone\n    const fn unix_time_to_unix_leap_time(&self, unix_time: i64) -> Result<i64, Error> {\n        let mut unix_leap_time = unix_time;\n\n        let mut i = 0;\n        while i < self.leap_seconds.len() {\n            let leap_second = &self.leap_seconds[i];\n\n            if unix_leap_time < leap_second.unix_leap_time {\n                break;\n            }\n\n            unix_leap_time = match unix_time.checked_add(leap_second.correction as i64) {\n                Some(unix_leap_time) => unix_leap_time,\n                None => return Err(Error::OutOfRange(\"out of range operation\")),\n            };\n\n            i += 1;\n        }\n\n        Ok(unix_leap_time)\n    }\n\n    /// Convert Unix leap time to Unix time, from the list of leap seconds in a time zone\n    fn unix_leap_time_to_unix_time(&self, unix_leap_time: i64) -> Result<i64, Error> {\n        if unix_leap_time == i64::min_value() {\n            return Err(Error::OutOfRange(\"out of range operation\"));\n        }\n\n        let index = match self\n            .leap_seconds\n            .binary_search_by_key(&(unix_leap_time - 1), LeapSecond::unix_leap_time)\n        {\n            Ok(x) => x + 1,\n            Err(x) => x,\n        };\n\n        let correction = if index > 0 { self.leap_seconds[index - 1].correction } else { 0 };\n\n        match unix_leap_time.checked_sub(correction as i64) {\n            Some(unix_time) => Ok(unix_time),\n            None => Err(Error::OutOfRange(\"out of range operation\")),\n        }\n    }\n\n    /// The UTC time zone\n    const UTC: TimeZoneRef<'static> = TimeZoneRef {\n        transitions: &[],\n        local_time_types: &[LocalTimeType::UTC],\n        leap_seconds: &[],\n        extra_rule: &None,\n    };\n}"],"offset::local::tz_info::timezone::Transition":["Clone","Copy","Debug","Eq","PartialEq","impl Transition {\n    /// Construct a TZif file transition\n    pub(super) const fn new(unix_leap_time: i64, local_time_type_index: usize) -> Self {\n        Self { unix_leap_time, local_time_type_index }\n    }\n\n    /// Returns Unix leap time\n    const fn unix_leap_time(&self) -> i64 {\n        self.unix_leap_time\n    }\n}"],"offset::utc::Utc":["Clone","Copy","Eq","Hash","PartialEq","impl Offset for Utc {\n    fn fix(&self) -> FixedOffset {\n        FixedOffset::east_opt(0).unwrap()\n    }\n}","impl TimeZone for Utc {\n    type Offset = Utc;\n\n    fn from_offset(_state: &Utc) -> Utc {\n        Utc\n    }\n\n    fn offset_from_local_date(&self, _local: &NaiveDate) -> LocalResult<Utc> {\n        LocalResult::Single(Utc)\n    }\n    fn offset_from_local_datetime(&self, _local: &NaiveDateTime) -> LocalResult<Utc> {\n        LocalResult::Single(Utc)\n    }\n\n    fn offset_from_utc_date(&self, _utc: &NaiveDate) -> Utc {\n        Utc\n    }\n    fn offset_from_utc_datetime(&self, _utc: &NaiveDateTime) -> Utc {\n        Utc\n    }\n}","impl Utc {\n    /// Returns a `Date` which corresponds to the current date.\n    #[deprecated(\n        since = \"0.4.23\",\n        note = \"use `Utc::now()` instead, potentially with `.date_naive()`\"\n    )]\n    #[allow(deprecated)]\n    #[must_use]\n    pub fn today() -> Date<Utc> {\n        Utc::now().date()\n    }\n\n    /// Returns a `DateTime` which corresponds to the current date and time.\n    #[cfg(not(all(\n        target_arch = \"wasm32\",\n        feature = \"wasmbind\",\n        not(any(target_os = \"emscripten\", target_os = \"wasi\"))\n    )))]\n    #[must_use]\n    pub fn now() -> DateTime<Utc> {\n        let now =\n            SystemTime::now().duration_since(UNIX_EPOCH).expect(\"system time before Unix epoch\");\n        let naive =\n            NaiveDateTime::from_timestamp_opt(now.as_secs() as i64, now.subsec_nanos()).unwrap();\n        DateTime::from_utc(naive, Utc)\n    }\n\n    /// Returns a `DateTime` which corresponds to the current date and time.\n    #[cfg(all(\n        target_arch = \"wasm32\",\n        feature = \"wasmbind\",\n        not(any(target_os = \"emscripten\", target_os = \"wasi\"))\n    ))]\n    #[must_use]\n    pub fn now() -> DateTime<Utc> {\n        let now = js_sys::Date::new_0();\n        DateTime::<Utc>::from(now)\n    }\n}","impl fmt::Debug for Utc {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Z\")\n    }\n}","impl fmt::Display for Utc {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"UTC\")\n    }\n}"],"round::RoundingError":["Clone","Copy","Debug","Eq","PartialEq","impl fmt::Display for RoundingError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            RoundingError::DurationExceedsTimestamp => {\n                write!(f, \"duration in nanoseconds exceeds timestamp\")\n            }\n            RoundingError::DurationExceedsLimit => {\n                write!(f, \"duration exceeds num_nanoseconds limit\")\n            }\n            RoundingError::TimestampExceedsLimit => {\n                write!(f, \"timestamp exceeds num_nanoseconds limit\")\n            }\n        }\n    }\n}","impl std::error::Error for RoundingError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        \"error from rounding or truncating with DurationRound\"\n    }\n}"],"std::time::SystemTime":["impl<Tz: TimeZone> From<DateTime<Tz>> for SystemTime {\n    fn from(dt: DateTime<Tz>) -> SystemTime {\n        use std::time::Duration;\n\n        let sec = dt.timestamp();\n        let nsec = dt.timestamp_subsec_nanos();\n        if sec < 0 {\n            // unlikely but should be handled\n            UNIX_EPOCH - Duration::new(-sec as u64, 0) + Duration::new(0, nsec)\n        } else {\n            UNIX_EPOCH + Duration::new(sec as u64, nsec)\n        }\n    }\n}"],"weekday::ParseWeekdayError":["Clone","Eq","PartialEq","impl fmt::Debug for ParseWeekdayError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"ParseWeekdayError {{ .. }}\")\n    }\n}","impl fmt::Display for ParseWeekdayError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_fmt(format_args!(\"{:?}\", self))\n    }\n}","impl std::error::Error for ParseWeekdayError {}"],"weekday::Weekday":["Clone","Copy","Debug","Eq","Hash","PartialEq","impl FromStr for Weekday {\n    type Err = ParseWeekdayError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        if let Ok((\"\", w)) = scan::short_or_long_weekday(s) {\n            Ok(w)\n        } else {\n            Err(ParseWeekdayError { _dummy: () })\n        }\n    }\n}","impl TryFrom<u8> for Weekday {\n    type Error = OutOfRange;\n\n    fn try_from(value: u8) -> Result<Self, Self::Error> {\n        match value {\n            0 => Ok(Weekday::Mon),\n            1 => Ok(Weekday::Tue),\n            2 => Ok(Weekday::Wed),\n            3 => Ok(Weekday::Thu),\n            4 => Ok(Weekday::Fri),\n            5 => Ok(Weekday::Sat),\n            6 => Ok(Weekday::Sun),\n            _ => Err(OutOfRange::new()),\n        }\n    }\n}","impl Weekday {\n    /// The next day in the week.\n    ///\n    /// `w`:        | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun`\n    /// ----------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n    /// `w.succ()`: | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun` | `Mon`\n    #[inline]\n    #[must_use]\n    pub const fn succ(&self) -> Weekday {\n        match *self {\n            Weekday::Mon => Weekday::Tue,\n            Weekday::Tue => Weekday::Wed,\n            Weekday::Wed => Weekday::Thu,\n            Weekday::Thu => Weekday::Fri,\n            Weekday::Fri => Weekday::Sat,\n            Weekday::Sat => Weekday::Sun,\n            Weekday::Sun => Weekday::Mon,\n        }\n    }\n\n    /// The previous day in the week.\n    ///\n    /// `w`:        | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun`\n    /// ----------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n    /// `w.pred()`: | `Sun` | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat`\n    #[inline]\n    #[must_use]\n    pub const fn pred(&self) -> Weekday {\n        match *self {\n            Weekday::Mon => Weekday::Sun,\n            Weekday::Tue => Weekday::Mon,\n            Weekday::Wed => Weekday::Tue,\n            Weekday::Thu => Weekday::Wed,\n            Weekday::Fri => Weekday::Thu,\n            Weekday::Sat => Weekday::Fri,\n            Weekday::Sun => Weekday::Sat,\n        }\n    }\n\n    /// Returns a day-of-week number starting from Monday = 1. (ISO 8601 weekday number)\n    ///\n    /// `w`:                      | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun`\n    /// ------------------------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n    /// `w.number_from_monday()`: | 1     | 2     | 3     | 4     | 5     | 6     | 7\n    #[inline]\n    pub const fn number_from_monday(&self) -> u32 {\n        self.num_days_from(Weekday::Mon) + 1\n    }\n\n    /// Returns a day-of-week number starting from Sunday = 1.\n    ///\n    /// `w`:                      | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun`\n    /// ------------------------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n    /// `w.number_from_sunday()`: | 2     | 3     | 4     | 5     | 6     | 7     | 1\n    #[inline]\n    pub const fn number_from_sunday(&self) -> u32 {\n        self.num_days_from(Weekday::Sun) + 1\n    }\n\n    /// Returns a day-of-week number starting from Monday = 0.\n    ///\n    /// `w`:                        | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun`\n    /// --------------------------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n    /// `w.num_days_from_monday()`: | 0     | 1     | 2     | 3     | 4     | 5     | 6\n    #[inline]\n    pub const fn num_days_from_monday(&self) -> u32 {\n        self.num_days_from(Weekday::Mon)\n    }\n\n    /// Returns a day-of-week number starting from Sunday = 0.\n    ///\n    /// `w`:                        | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun`\n    /// --------------------------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n    /// `w.num_days_from_sunday()`: | 1     | 2     | 3     | 4     | 5     | 6     | 0\n    #[inline]\n    pub const fn num_days_from_sunday(&self) -> u32 {\n        self.num_days_from(Weekday::Sun)\n    }\n\n    /// Returns a day-of-week number starting from the parameter `day` (D) = 0.\n    ///\n    /// `w`:                        | `D`   | `D+1` | `D+2` | `D+3` | `D+4` | `D+5` | `D+6`\n    /// --------------------------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n    /// `w.num_days_from(wd)`:      | 0     | 1     | 2     | 3     | 4     | 5     | 6\n    #[inline]\n    pub(crate) const fn num_days_from(&self, day: Weekday) -> u32 {\n        (*self as u32 + 7 - day as u32) % 7\n    }\n}","impl fmt::Display for Weekday {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.write_str(match *self {\n            Weekday::Mon => \"Mon\",\n            Weekday::Tue => \"Tue\",\n            Weekday::Wed => \"Wed\",\n            Weekday::Thu => \"Thu\",\n            Weekday::Fri => \"Fri\",\n            Weekday::Sat => \"Sat\",\n            Weekday::Sun => \"Sun\",\n        })\n    }\n}","impl num_traits::FromPrimitive for Weekday {\n    #[inline]\n    fn from_i64(n: i64) -> Option<Weekday> {\n        match n {\n            0 => Some(Weekday::Mon),\n            1 => Some(Weekday::Tue),\n            2 => Some(Weekday::Wed),\n            3 => Some(Weekday::Thu),\n            4 => Some(Weekday::Fri),\n            5 => Some(Weekday::Sat),\n            6 => Some(Weekday::Sun),\n            _ => None,\n        }\n    }\n\n    #[inline]\n    fn from_u64(n: u64) -> Option<Weekday> {\n        match n {\n            0 => Some(Weekday::Mon),\n            1 => Some(Weekday::Tue),\n            2 => Some(Weekday::Wed),\n            3 => Some(Weekday::Thu),\n            4 => Some(Weekday::Fri),\n            5 => Some(Weekday::Sat),\n            6 => Some(Weekday::Sun),\n            _ => None,\n        }\n    }\n}"]},"single_path_import":{"date::Date":"Date","date::MAX_DATE":"MAX_DATE","date::MIN_DATE":"MIN_DATE","datetime::DateTime":"DateTime","datetime::MAX_DATETIME":"MAX_DATETIME","datetime::MIN_DATETIME":"MIN_DATETIME","datetime::SecondsFormat":"SecondsFormat","format::ParseError":"ParseError","format::ParseResult":"ParseResult","format::parse::parse":"format::parse","format::parse::parse_and_remainder":"format::parse_and_remainder","format::parsed::Parsed":"format::Parsed","format::strftime::StrftimeItems":"format::StrftimeItems","month::Month":"Month","month::Months":"Months","month::ParseMonthError":"ParseMonthError","naive::date::Days":"Days","naive::date::MAX_DATE":"naive::MAX_DATE","naive::date::MIN_DATE":"naive::MIN_DATE","naive::date::NaiveDate":"NaiveDate","naive::date::NaiveWeek":"NaiveWeek","naive::datetime::MAX_DATETIME":"naive::MAX_DATETIME","naive::datetime::MIN_DATETIME":"naive::MIN_DATETIME","naive::datetime::NaiveDateTime":"NaiveDateTime","naive::isoweek::IsoWeek":"IsoWeek","naive::time::NaiveTime":"NaiveTime","offset::LocalResult":"LocalResult","offset::Offset":"Offset","offset::TimeZone":"TimeZone","offset::fixed::FixedOffset":"FixedOffset","offset::local::Local":"Local","offset::utc::Utc":"Utc","oldtime::Duration":"Duration","oldtime::OutOfRangeError":"OutOfRangeError","round::DurationRound":"DurationRound","round::RoundingError":"RoundingError","round::SubsecRound":"SubsecRound","traits::Datelike":"Datelike","traits::Timelike":"Timelike","weekday::ParseWeekdayError":"ParseWeekdayError","weekday::Weekday":"Weekday"},"srcs":{"<OutOfRange as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"out of range\")\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<OutOfRange as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"out of range\")\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<T as round::SubsecRound>::round_subsecs":["fn round_subsecs(self, digits: u16) -> T{\n        let span = span_for_digits(digits);\n        let delta_down = self.nanosecond() % span;\n        if delta_down > 0 {\n            let delta_up = span - delta_down;\n            if delta_up <= delta_down {\n                self + Duration::nanoseconds(delta_up.into())\n            } else {\n                self - Duration::nanoseconds(delta_down.into())\n            }\n        } else {\n            self // unchanged\n        }\n    }","Real(LocalPath(\"src/round.rs\"))"],"<T as round::SubsecRound>::trunc_subsecs":["fn trunc_subsecs(self, digits: u16) -> T{\n        let span = span_for_digits(digits);\n        let delta_down = self.nanosecond() % span;\n        if delta_down > 0 {\n            self - Duration::nanoseconds(delta_down.into())\n        } else {\n            self // unchanged\n        }\n    }","Real(LocalPath(\"src/round.rs\"))"],"<date::Date<Tz> as std::cmp::Ord>::cmp":["fn cmp(&self, other: &Date<Tz>) -> Ordering{\n        self.date.cmp(&other.date)\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as std::cmp::PartialEq<date::Date<Tz2>>>::eq":["fn eq(&self, other: &Date<Tz2>) -> bool{\n        self.date == other.date\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as std::cmp::PartialOrd>::partial_cmp":["fn partial_cmp(&self, other: &Date<Tz>) -> Option<Ordering>{\n        self.date.partial_cmp(&other.date)\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.naive_local().fmt(f)?;\n        self.offset.fmt(f)\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.naive_local().fmt(f)?;\n        self.offset.fmt(f)\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as std::hash::Hash>::hash":["fn hash<H: hash::Hasher>(&self, state: &mut H){\n        self.date.hash(state)\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as std::ops::Add<oldtime::Duration>>::add":["#[inline]\nfn add(self, rhs: OldDuration) -> Date<Tz>{\n        self.checked_add_signed(rhs).expect(\"`Date + Duration` overflowed\")\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as std::ops::AddAssign<oldtime::Duration>>::add_assign":["#[inline]\nfn add_assign(&mut self, rhs: OldDuration){\n        self.date = self.date.checked_add_signed(rhs).expect(\"`Date + Duration` overflowed\");\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as std::ops::Sub<oldtime::Duration>>::sub":["#[inline]\nfn sub(self, rhs: OldDuration) -> Date<Tz>{\n        self.checked_sub_signed(rhs).expect(\"`Date - Duration` overflowed\")\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as std::ops::Sub>::sub":["#[inline]\nfn sub(self, rhs: Date<Tz>) -> OldDuration{\n        self.signed_duration_since(rhs)\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["#[inline]\nfn sub_assign(&mut self, rhs: OldDuration){\n        self.date = self.date.checked_sub_signed(rhs).expect(\"`Date - Duration` overflowed\");\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::day":["#[inline]\nfn day(&self) -> u32{\n        self.naive_local().day()\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::day0":["#[inline]\nfn day0(&self) -> u32{\n        self.naive_local().day0()\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::iso_week":["#[inline]\nfn iso_week(&self) -> IsoWeek{\n        self.naive_local().iso_week()\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::month":["#[inline]\nfn month(&self) -> u32{\n        self.naive_local().month()\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::month0":["#[inline]\nfn month0(&self) -> u32{\n        self.naive_local().month0()\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::ordinal":["#[inline]\nfn ordinal(&self) -> u32{\n        self.naive_local().ordinal()\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::ordinal0":["#[inline]\nfn ordinal0(&self) -> u32{\n        self.naive_local().ordinal0()\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::weekday":["#[inline]\nfn weekday(&self) -> Weekday{\n        self.naive_local().weekday()\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::with_day":["#[inline]\nfn with_day(&self, day: u32) -> Option<Date<Tz>>{\n        map_local(self, |date| date.with_day(day))\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::with_day0":["#[inline]\nfn with_day0(&self, day0: u32) -> Option<Date<Tz>>{\n        map_local(self, |date| date.with_day0(day0))\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::with_month":["#[inline]\nfn with_month(&self, month: u32) -> Option<Date<Tz>>{\n        map_local(self, |date| date.with_month(month))\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::with_month0":["#[inline]\nfn with_month0(&self, month0: u32) -> Option<Date<Tz>>{\n        map_local(self, |date| date.with_month0(month0))\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::with_ordinal":["#[inline]\nfn with_ordinal(&self, ordinal: u32) -> Option<Date<Tz>>{\n        map_local(self, |date| date.with_ordinal(ordinal))\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::with_ordinal0":["#[inline]\nfn with_ordinal0(&self, ordinal0: u32) -> Option<Date<Tz>>{\n        map_local(self, |date| date.with_ordinal0(ordinal0))\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::with_year":["#[inline]\nfn with_year(&self, year: i32) -> Option<Date<Tz>>{\n        map_local(self, |date| date.with_year(year))\n    }","Real(LocalPath(\"src/date.rs\"))"],"<date::Date<Tz> as traits::Datelike>::year":["#[inline]\nfn year(&self) -> i32{\n        self.naive_local().year()\n    }","Real(LocalPath(\"src/date.rs\"))"],"<datetime::DateTime<Tz> as round::DurationRound>::duration_round":["fn duration_round(self, duration: Duration) -> Result<Self, Self::Err>{\n        duration_round(self.naive_local(), self, duration)\n    }","Real(LocalPath(\"src/round.rs\"))"],"<datetime::DateTime<Tz> as round::DurationRound>::duration_trunc":["fn duration_trunc(self, duration: Duration) -> Result<Self, Self::Err>{\n        duration_trunc(self.naive_local(), self, duration)\n    }","Real(LocalPath(\"src/round.rs\"))"],"<datetime::DateTime<Tz> as std::cmp::Ord>::cmp":["fn cmp(&self, other: &DateTime<Tz>) -> Ordering{\n        self.datetime.cmp(&other.datetime)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::cmp::PartialEq<datetime::DateTime<Tz2>>>::eq":["fn eq(&self, other: &DateTime<Tz2>) -> bool{\n        self.datetime == other.datetime\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::cmp::PartialOrd<datetime::DateTime<Tz2>>>::partial_cmp":["/// Compare two DateTimes based on their true time, ignoring time zones\n///\n/// # Example\n///\n/// ```\n/// use chrono::prelude::*;\n///\n/// let earlier = Utc.with_ymd_and_hms(2015, 5, 15, 2, 0, 0).unwrap().with_timezone(&FixedOffset::west_opt(1 * 3600).unwrap());\n/// let later   = Utc.with_ymd_and_hms(2015, 5, 15, 3, 0, 0).unwrap().with_timezone(&FixedOffset::west_opt(5 * 3600).unwrap());\n///\n/// assert_eq!(earlier.to_string(), \"2015-05-15 01:00:00 -01:00\");\n/// assert_eq!(later.to_string(), \"2015-05-14 22:00:00 -05:00\");\n///\n/// assert!(later > earlier);\n/// ```\nfn partial_cmp(&self, other: &DateTime<Tz2>) -> Option<Ordering>{\n        self.datetime.partial_cmp(&other.datetime)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.naive_local().fmt(f)?;\n        self.offset.fmt(f)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.naive_local().fmt(f)?;\n        f.write_char(' ')?;\n        self.offset.fmt(f)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::hash::Hash>::hash":["fn hash<H: hash::Hasher>(&self, state: &mut H){\n        self.datetime.hash(state)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::ops::Add<month::Months>>::add":["fn add(self, rhs: Months) -> Self::Output{\n        self.checked_add_months(rhs).unwrap()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::ops::Add<naive::date::Days>>::add":["fn add(self, days: Days) -> Self::Output{\n        self.checked_add_days(days).unwrap()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::ops::Add<oldtime::Duration>>::add":["#[inline]\nfn add(self, rhs: OldDuration) -> DateTime<Tz>{\n        self.checked_add_signed(rhs).expect(\"`DateTime + Duration` overflowed\")\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::ops::AddAssign<oldtime::Duration>>::add_assign":["#[inline]\nfn add_assign(&mut self, rhs: OldDuration){\n        let datetime =\n            self.datetime.checked_add_signed(rhs).expect(\"`DateTime + Duration` overflowed\");\n        let tz = self.timezone();\n        *self = tz.from_utc_datetime(&datetime);\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::ops::Sub<month::Months>>::sub":["fn sub(self, rhs: Months) -> Self::Output{\n        self.checked_sub_months(rhs).unwrap()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::ops::Sub<naive::date::Days>>::sub":["fn sub(self, days: Days) -> Self::Output{\n        self.checked_sub_days(days).unwrap()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::ops::Sub<oldtime::Duration>>::sub":["#[inline]\nfn sub(self, rhs: OldDuration) -> DateTime<Tz>{\n        self.checked_sub_signed(rhs).expect(\"`DateTime - Duration` overflowed\")\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::ops::Sub>::sub":["#[inline]\nfn sub(self, rhs: DateTime<Tz>) -> OldDuration{\n        self.signed_duration_since(rhs)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["#[inline]\nfn sub_assign(&mut self, rhs: OldDuration){\n        let datetime =\n            self.datetime.checked_sub_signed(rhs).expect(\"`DateTime - Duration` overflowed\");\n        let tz = self.timezone();\n        *self = tz.from_utc_datetime(&datetime)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::day":["#[inline]\nfn day(&self) -> u32{\n        self.naive_local().day()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::day0":["#[inline]\nfn day0(&self) -> u32{\n        self.naive_local().day0()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::iso_week":["#[inline]\nfn iso_week(&self) -> IsoWeek{\n        self.naive_local().iso_week()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::month":["#[inline]\nfn month(&self) -> u32{\n        self.naive_local().month()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::month0":["#[inline]\nfn month0(&self) -> u32{\n        self.naive_local().month0()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::ordinal":["#[inline]\nfn ordinal(&self) -> u32{\n        self.naive_local().ordinal()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::ordinal0":["#[inline]\nfn ordinal0(&self) -> u32{\n        self.naive_local().ordinal0()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::weekday":["#[inline]\nfn weekday(&self) -> Weekday{\n        self.naive_local().weekday()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::with_day":["#[inline]\nfn with_day(&self, day: u32) -> Option<DateTime<Tz>>{\n        map_local(self, |datetime| datetime.with_day(day))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::with_day0":["#[inline]\nfn with_day0(&self, day0: u32) -> Option<DateTime<Tz>>{\n        map_local(self, |datetime| datetime.with_day0(day0))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::with_month":["#[inline]\nfn with_month(&self, month: u32) -> Option<DateTime<Tz>>{\n        map_local(self, |datetime| datetime.with_month(month))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::with_month0":["#[inline]\nfn with_month0(&self, month0: u32) -> Option<DateTime<Tz>>{\n        map_local(self, |datetime| datetime.with_month0(month0))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal":["#[inline]\nfn with_ordinal(&self, ordinal: u32) -> Option<DateTime<Tz>>{\n        map_local(self, |datetime| datetime.with_ordinal(ordinal))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal0":["#[inline]\nfn with_ordinal0(&self, ordinal0: u32) -> Option<DateTime<Tz>>{\n        map_local(self, |datetime| datetime.with_ordinal0(ordinal0))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::with_year":["#[inline]\nfn with_year(&self, year: i32) -> Option<DateTime<Tz>>{\n        map_local(self, |datetime| datetime.with_year(year))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Datelike>::year":["#[inline]\nfn year(&self) -> i32{\n        self.naive_local().year()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Timelike>::hour":["#[inline]\nfn hour(&self) -> u32{\n        self.naive_local().hour()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Timelike>::minute":["#[inline]\nfn minute(&self) -> u32{\n        self.naive_local().minute()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Timelike>::nanosecond":["#[inline]\nfn nanosecond(&self) -> u32{\n        self.naive_local().nanosecond()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Timelike>::second":["#[inline]\nfn second(&self) -> u32{\n        self.naive_local().second()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Timelike>::with_hour":["#[inline]\nfn with_hour(&self, hour: u32) -> Option<DateTime<Tz>>{\n        map_local(self, |datetime| datetime.with_hour(hour))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Timelike>::with_minute":["#[inline]\nfn with_minute(&self, min: u32) -> Option<DateTime<Tz>>{\n        map_local(self, |datetime| datetime.with_minute(min))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Timelike>::with_nanosecond":["#[inline]\nfn with_nanosecond(&self, nano: u32) -> Option<DateTime<Tz>>{\n        map_local(self, |datetime| datetime.with_nanosecond(nano))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<Tz> as traits::Timelike>::with_second":["#[inline]\nfn with_second(&self, sec: u32) -> Option<DateTime<Tz>>{\n        map_local(self, |datetime| datetime.with_second(sec))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::fixed::FixedOffset> as std::convert::From<datetime::DateTime<offset::local::Local>>>::from":["/// Convert this `DateTime<Local>` instance into a `DateTime<FixedOffset>` instance.\n///\n/// Conversion is performed via [`DateTime::with_timezone`].\nfn from(src: DateTime<Local>) -> Self{\n        src.with_timezone(&src.offset().fix())\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::fixed::FixedOffset> as std::convert::From<datetime::DateTime<offset::utc::Utc>>>::from":["/// Convert this `DateTime<Utc>` instance into a `DateTime<FixedOffset>` instance.\n///\n/// Conversion is done via [`DateTime::with_timezone`]. Note that the converted value returned by\n/// this will be created with a fixed timezone offset of 0.\nfn from(src: DateTime<Utc>) -> Self{\n        src.with_timezone(&FixedOffset::east_opt(0).unwrap())\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::fixed::FixedOffset> as std::default::Default>::default":["fn default() -> Self{\n        FixedOffset::west_opt(0).unwrap().from_utc_datetime(&NaiveDateTime::default())\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::local::Local> as std::convert::From<datetime::DateTime<offset::fixed::FixedOffset>>>::from":["/// Convert this `DateTime<FixedOffset>` instance into a `DateTime<Local>` instance.\n///\n/// Conversion is performed via [`DateTime::with_timezone`]. Returns the equivalent value in local\n/// time.\nfn from(src: DateTime<FixedOffset>) -> Self{\n        src.with_timezone(&Local)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::local::Local> as std::convert::From<datetime::DateTime<offset::utc::Utc>>>::from":["/// Convert this `DateTime<Utc>` instance into a `DateTime<Local>` instance.\n///\n/// Conversion is performed via [`DateTime::with_timezone`], accounting for the difference in timezones.\nfn from(src: DateTime<Utc>) -> Self{\n        src.with_timezone(&Local)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::local::Local> as std::convert::From<std::time::SystemTime>>::from":["fn from(t: SystemTime) -> DateTime<Local>{\n        DateTime::<Utc>::from(t).with_timezone(&Local)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::local::Local> as std::default::Default>::default":["fn default() -> Self{\n        Local.from_utc_datetime(&NaiveDateTime::default())\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::local::Local> as std::str::FromStr>::from_str":["fn from_str(s: &str) -> ParseResult<DateTime<Local>>{\n        s.parse::<DateTime<FixedOffset>>().map(|dt| dt.with_timezone(&Local))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::utc::Utc> as std::convert::From<datetime::DateTime<offset::fixed::FixedOffset>>>::from":["/// Convert this `DateTime<FixedOffset>` instance into a `DateTime<Utc>` instance.\n///\n/// Conversion is performed via [`DateTime::with_timezone`], accounting for the timezone\n/// difference.\nfn from(src: DateTime<FixedOffset>) -> Self{\n        src.with_timezone(&Utc)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::utc::Utc> as std::convert::From<datetime::DateTime<offset::local::Local>>>::from":["/// Convert this `DateTime<Local>` instance into a `DateTime<Utc>` instance.\n///\n/// Conversion is performed via [`DateTime::with_timezone`], accounting for the difference in\n/// timezones.\nfn from(src: DateTime<Local>) -> Self{\n        src.with_timezone(&Utc)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::utc::Utc> as std::convert::From<std::time::SystemTime>>::from":["fn from(t: SystemTime) -> DateTime<Utc>{\n        let (sec, nsec) = match t.duration_since(UNIX_EPOCH) {\n            Ok(dur) => (dur.as_secs() as i64, dur.subsec_nanos()),\n            Err(e) => {\n                // unlikely but should be handled\n                let dur = e.duration();\n                let (sec, nsec) = (dur.as_secs() as i64, dur.subsec_nanos());\n                if nsec == 0 {\n                    (-sec, 0)\n                } else {\n                    (-sec - 1, 1_000_000_000 - nsec)\n                }\n            }\n        };\n        Utc.timestamp_opt(sec, nsec).unwrap()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::utc::Utc> as std::default::Default>::default":["fn default() -> Self{\n        Utc.from_utc_datetime(&NaiveDateTime::default())\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<datetime::DateTime<offset::utc::Utc> as std::str::FromStr>::from_str":["fn from_str(s: &str) -> ParseResult<DateTime<Utc>>{\n        s.parse::<DateTime<FixedOffset>>().map(|dt| dt.with_timezone(&Utc))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"<format::DelayedFormat<I> as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        #[cfg(feature = \"unstable-locales\")]\n        {\n            if let Some(locale) = self.locale {\n                return format_localized(\n                    f,\n                    self.date.as_ref(),\n                    self.time.as_ref(),\n                    self.off.as_ref(),\n                    self.items.clone(),\n                    locale,\n                );\n            }\n        }\n\n        format(f, self.date.as_ref(), self.time.as_ref(), self.off.as_ref(), self.items.clone())\n    }","Real(LocalPath(\"src/format/mod.rs\"))"],"<format::InternalNumeric as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"<InternalNumeric>\")\n    }","Real(LocalPath(\"src/format/mod.rs\"))"],"<format::ParseError as std::error::Error>::description":["#[allow(deprecated)]\nfn description(&self) -> &str{\n        \"parser error, see to_string() for details\"\n    }","Real(LocalPath(\"src/format/mod.rs\"))"],"<format::ParseError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match self.0 {\n            ParseErrorKind::OutOfRange => write!(f, \"input is out of range\"),\n            ParseErrorKind::Impossible => write!(f, \"no possible date and time matching input\"),\n            ParseErrorKind::NotEnough => write!(f, \"input is not enough for unique date and time\"),\n            ParseErrorKind::Invalid => write!(f, \"input contains invalid characters\"),\n            ParseErrorKind::TooShort => write!(f, \"premature end of input\"),\n            ParseErrorKind::TooLong => write!(f, \"trailing input\"),\n            ParseErrorKind::BadFormat => write!(f, \"bad or unsupported format string\"),\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/format/mod.rs\"))"],"<format::strftime::StrftimeItems<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Item<'a>>{\n        // we have some reconstructed items to return\n        if !self.recons.is_empty() {\n            let item;\n            #[cfg(feature = \"unstable-locales\")]\n            {\n                item = self.recons.remove(0);\n            }\n            #[cfg(not(feature = \"unstable-locales\"))]\n            {\n                item = self.recons[0].clone();\n                self.recons = &self.recons[1..];\n            }\n            return Some(item);\n        }\n\n        match self.remainder.chars().next() {\n            // we are done\n            None => None,\n\n            // the next item is a specifier\n            Some('%') => {\n                self.remainder = &self.remainder[1..];\n\n                macro_rules! next {\n                    () => {\n                        match self.remainder.chars().next() {\n                            Some(x) => {\n                                self.remainder = &self.remainder[x.len_utf8()..];\n                                x\n                            }\n                            None => return Some(Item::Error), // premature end of string\n                        }\n                    };\n                }\n\n                let spec = next!();\n                let pad_override = match spec {\n                    '-' => Some(Pad::None),\n                    '0' => Some(Pad::Zero),\n                    '_' => Some(Pad::Space),\n                    _ => None,\n                };\n                let is_alternate = spec == '#';\n                let spec = if pad_override.is_some() || is_alternate { next!() } else { spec };\n                if is_alternate && !HAVE_ALTERNATES.contains(spec) {\n                    return Some(Item::Error);\n                }\n\n                macro_rules! recons {\n                    [$head:expr, $($tail:expr),+ $(,)*] => ({\n                        #[cfg(feature = \"unstable-locales\")]\n                        {\n                            self.recons.clear();\n                            $(self.recons.push($tail);)+\n                        }\n                        #[cfg(not(feature = \"unstable-locales\"))]\n                        {\n                            const RECONS: &'static [Item<'static>] = &[$($tail),+];\n                            self.recons = RECONS;\n                        }\n                        $head\n                    })\n                }\n\n                macro_rules! recons_from_slice {\n                    ($slice:expr) => {{\n                        #[cfg(feature = \"unstable-locales\")]\n                        {\n                            self.recons.clear();\n                            self.recons.extend_from_slice(&$slice[1..]);\n                        }\n                        #[cfg(not(feature = \"unstable-locales\"))]\n                        {\n                            self.recons = &$slice[1..];\n                        }\n                        $slice[0].clone()\n                    }};\n                }\n\n                let item = match spec {\n                    'A' => fix!(LongWeekdayName),\n                    'B' => fix!(LongMonthName),\n                    'C' => num0!(YearDiv100),\n                    'D' => {\n                        recons![num0!(Month), lit!(\"/\"), num0!(Day), lit!(\"/\"), num0!(YearMod100)]\n                    }\n                    'F' => recons![num0!(Year), lit!(\"-\"), num0!(Month), lit!(\"-\"), num0!(Day)],\n                    'G' => num0!(IsoYear),\n                    'H' => num0!(Hour),\n                    'I' => num0!(Hour12),\n                    'M' => num0!(Minute),\n                    'P' => fix!(LowerAmPm),\n                    'R' => recons![num0!(Hour), lit!(\":\"), num0!(Minute)],\n                    'S' => num0!(Second),\n                    'T' => recons![num0!(Hour), lit!(\":\"), num0!(Minute), lit!(\":\"), num0!(Second)],\n                    'U' => num0!(WeekFromSun),\n                    'V' => num0!(IsoWeek),\n                    'W' => num0!(WeekFromMon),\n                    'X' => recons_from_slice!(self.t_fmt),\n                    'Y' => num0!(Year),\n                    'Z' => fix!(TimezoneName),\n                    'a' => fix!(ShortWeekdayName),\n                    'b' | 'h' => fix!(ShortMonthName),\n                    'c' => recons_from_slice!(self.d_t_fmt),\n                    'd' => num0!(Day),\n                    'e' => nums!(Day),\n                    'f' => num0!(Nanosecond),\n                    'g' => num0!(IsoYearMod100),\n                    'j' => num0!(Ordinal),\n                    'k' => nums!(Hour),\n                    'l' => nums!(Hour12),\n                    'm' => num0!(Month),\n                    'n' => sp!(\"\\n\"),\n                    'p' => fix!(UpperAmPm),\n                    'r' => recons![\n                        num0!(Hour12),\n                        lit!(\":\"),\n                        num0!(Minute),\n                        lit!(\":\"),\n                        num0!(Second),\n                        sp!(\" \"),\n                        fix!(UpperAmPm)\n                    ],\n                    's' => num!(Timestamp),\n                    't' => sp!(\"\\t\"),\n                    'u' => num!(WeekdayFromMon),\n                    'v' => {\n                        recons![nums!(Day), lit!(\"-\"), fix!(ShortMonthName), lit!(\"-\"), num0!(Year)]\n                    }\n                    'w' => num!(NumDaysFromSun),\n                    'x' => recons_from_slice!(self.d_fmt),\n                    'y' => num0!(YearMod100),\n                    'z' => {\n                        if is_alternate {\n                            internal_fix!(TimezoneOffsetPermissive)\n                        } else {\n                            fix!(TimezoneOffset)\n                        }\n                    }\n                    '+' => fix!(RFC3339),\n                    ':' => {\n                        if self.remainder.starts_with(\"::z\") {\n                            self.remainder = &self.remainder[3..];\n                            fix!(TimezoneOffsetTripleColon)\n                        } else if self.remainder.starts_with(\":z\") {\n                            self.remainder = &self.remainder[2..];\n                            fix!(TimezoneOffsetDoubleColon)\n                        } else if self.remainder.starts_with('z') {\n                            self.remainder = &self.remainder[1..];\n                            fix!(TimezoneOffsetColon)\n                        } else {\n                            Item::Error\n                        }\n                    }\n                    '.' => match next!() {\n                        '3' => match next!() {\n                            'f' => fix!(Nanosecond3),\n                            _ => Item::Error,\n                        },\n                        '6' => match next!() {\n                            'f' => fix!(Nanosecond6),\n                            _ => Item::Error,\n                        },\n                        '9' => match next!() {\n                            'f' => fix!(Nanosecond9),\n                            _ => Item::Error,\n                        },\n                        'f' => fix!(Nanosecond),\n                        _ => Item::Error,\n                    },\n                    '3' => match next!() {\n                        'f' => internal_fix!(Nanosecond3NoDot),\n                        _ => Item::Error,\n                    },\n                    '6' => match next!() {\n                        'f' => internal_fix!(Nanosecond6NoDot),\n                        _ => Item::Error,\n                    },\n                    '9' => match next!() {\n                        'f' => internal_fix!(Nanosecond9NoDot),\n                        _ => Item::Error,\n                    },\n                    '%' => lit!(\"%\"),\n                    _ => Item::Error, // no such specifier\n                };\n\n                // adjust `item` if we have any padding modifier\n                if let Some(new_pad) = pad_override {\n                    match item {\n                        Item::Numeric(ref kind, _pad) if self.recons.is_empty() => {\n                            Some(Item::Numeric(kind.clone(), new_pad))\n                        }\n                        _ => Some(Item::Error), // no reconstructed or non-numeric item allowed\n                    }\n                } else {\n                    Some(item)\n                }\n            }\n\n            // the next item is space\n            Some(c) if c.is_whitespace() => {\n                // `%` is not a whitespace, so `c != '%'` is redundant\n                let nextspec = self\n                    .remainder\n                    .find(|c: char| !c.is_whitespace())\n                    .unwrap_or(self.remainder.len());\n                assert!(nextspec > 0);\n                let item = sp!(&self.remainder[..nextspec]);\n                self.remainder = &self.remainder[nextspec..];\n                Some(item)\n            }\n\n            // the next item is literal\n            _ => {\n                let nextspec = self\n                    .remainder\n                    .find(|c: char| c.is_whitespace() || c == '%')\n                    .unwrap_or(self.remainder.len());\n                assert!(nextspec > 0);\n                let item = lit!(&self.remainder[..nextspec]);\n                self.remainder = &self.remainder[nextspec..];\n                Some(item)\n            }\n        }\n    }","Real(LocalPath(\"src/format/strftime.rs\"))"],"<month::Month as num_traits::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<Month>{\n        Self::from_u32(n as u32)\n    }","Real(LocalPath(\"src/month.rs\"))"],"<month::Month as num_traits::FromPrimitive>::from_u32":["#[inline]\nfn from_u32(n: u32) -> Option<Month>{\n        match n {\n            1 => Some(Month::January),\n            2 => Some(Month::February),\n            3 => Some(Month::March),\n            4 => Some(Month::April),\n            5 => Some(Month::May),\n            6 => Some(Month::June),\n            7 => Some(Month::July),\n            8 => Some(Month::August),\n            9 => Some(Month::September),\n            10 => Some(Month::October),\n            11 => Some(Month::November),\n            12 => Some(Month::December),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/month.rs\"))"],"<month::Month as num_traits::FromPrimitive>::from_u64":["/// Returns an `Option<Month>` from a i64, assuming a 1-index, January = 1.\n///\n/// `Month::from_i64(n: i64)`: | `1`                  | `2`                   | ... | `12`\n/// ---------------------------| -------------------- | --------------------- | ... | -----\n/// ``:                        | Some(Month::January) | Some(Month::February) | ... | Some(Month::December)\n#[inline]\nfn from_u64(n: u64) -> Option<Month>{\n        Self::from_u32(n as u32)\n    }","Real(LocalPath(\"src/month.rs\"))"],"<month::Month as std::convert::TryFrom<u8>>::try_from":["fn try_from(value: u8) -> Result<Self, Self::Error>{\n        match value {\n            1 => Ok(Month::January),\n            2 => Ok(Month::February),\n            3 => Ok(Month::March),\n            4 => Ok(Month::April),\n            5 => Ok(Month::May),\n            6 => Ok(Month::June),\n            7 => Ok(Month::July),\n            8 => Ok(Month::August),\n            9 => Ok(Month::September),\n            10 => Ok(Month::October),\n            11 => Ok(Month::November),\n            12 => Ok(Month::December),\n            _ => Err(OutOfRange::new()),\n        }\n    }","Real(LocalPath(\"src/month.rs\"))"],"<month::ParseMonthError as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"ParseMonthError {{ .. }}\")\n    }","Real(LocalPath(\"src/month.rs\"))"],"<naive::date::NaiveDate as std::convert::From<naive::datetime::NaiveDateTime>>::from":["fn from(naive_datetime: NaiveDateTime) -> Self{\n        naive_datetime.date()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::default::Default>::default":["fn default() -> Self{\n        NaiveDate::from_ymd_opt(1970, 1, 1).unwrap()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use core::fmt::Write;\n\n        let year = self.year();\n        let mdf = self.mdf();\n        if (0..=9999).contains(&year) {\n            write_hundreds(f, (year / 100) as u8)?;\n            write_hundreds(f, (year % 100) as u8)?;\n        } else {\n            // ISO 8601 requires the explicit sign for out-of-range years\n            write!(f, \"{:+05}\", year)?;\n        }\n\n        f.write_char('-')?;\n        write_hundreds(f, mdf.month() as u8)?;\n        f.write_char('-')?;\n        write_hundreds(f, mdf.day() as u8)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Debug::fmt(self, f)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::ops::Add<month::Months>>::add":["/// An addition of months to `NaiveDate` clamped to valid days in resulting month.\n///\n/// # Panics\n///\n/// Panics if the resulting date would be out of range.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Months};\n///\n/// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n///\n/// assert_eq!(from_ymd(2014, 1, 1) + Months::new(1), from_ymd(2014, 2, 1));\n/// assert_eq!(from_ymd(2014, 1, 1) + Months::new(11), from_ymd(2014, 12, 1));\n/// assert_eq!(from_ymd(2014, 1, 1) + Months::new(12), from_ymd(2015, 1, 1));\n/// assert_eq!(from_ymd(2014, 1, 1) + Months::new(13), from_ymd(2015, 2, 1));\n/// assert_eq!(from_ymd(2014, 1, 31) + Months::new(1), from_ymd(2014, 2, 28));\n/// assert_eq!(from_ymd(2020, 1, 31) + Months::new(1), from_ymd(2020, 2, 29));\n/// ```\nfn add(self, months: Months) -> Self::Output{\n        self.checked_add_months(months).unwrap()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::ops::Add<naive::date::Days>>::add":["fn add(self, days: Days) -> Self::Output{\n        self.checked_add_days(days).unwrap()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::ops::Add<oldtime::Duration>>::add":["#[inline]\nfn add(self, rhs: OldDuration) -> NaiveDate{\n        self.checked_add_signed(rhs).expect(\"`NaiveDate + Duration` overflowed\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::ops::AddAssign<oldtime::Duration>>::add_assign":["#[inline]\nfn add_assign(&mut self, rhs: OldDuration){\n        *self = self.add(rhs);\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::ops::Sub<month::Months>>::sub":["/// A subtraction of Months from `NaiveDate` clamped to valid days in resulting month.\n///\n/// # Panics\n///\n/// Panics if the resulting date would be out of range.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Months};\n///\n/// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n///\n/// assert_eq!(from_ymd(2014, 1, 1) - Months::new(11), from_ymd(2013, 2, 1));\n/// assert_eq!(from_ymd(2014, 1, 1) - Months::new(12), from_ymd(2013, 1, 1));\n/// assert_eq!(from_ymd(2014, 1, 1) - Months::new(13), from_ymd(2012, 12, 1));\n/// ```\nfn sub(self, months: Months) -> Self::Output{\n        self.checked_sub_months(months).unwrap()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::ops::Sub<naive::date::Days>>::sub":["fn sub(self, days: Days) -> Self::Output{\n        self.checked_sub_days(days).unwrap()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::ops::Sub<oldtime::Duration>>::sub":["#[inline]\nfn sub(self, rhs: OldDuration) -> NaiveDate{\n        self.checked_sub_signed(rhs).expect(\"`NaiveDate - Duration` overflowed\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::ops::Sub>::sub":["#[inline]\nfn sub(self, rhs: NaiveDate) -> OldDuration{\n        self.signed_duration_since(rhs)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["#[inline]\nfn sub_assign(&mut self, rhs: OldDuration){\n        *self = self.sub(rhs);\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as std::str::FromStr>::from_str":["fn from_str(s: &str) -> ParseResult<NaiveDate>{\n        const ITEMS: &[Item<'static>] = &[\n            Item::Numeric(Numeric::Year, Pad::Zero),\n            Item::Literal(\"-\"),\n            Item::Numeric(Numeric::Month, Pad::Zero),\n            Item::Literal(\"-\"),\n            Item::Numeric(Numeric::Day, Pad::Zero),\n        ];\n\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, ITEMS.iter())?;\n        parsed.to_naive_date()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::day":["/// Returns the day of month starting from 1.\n///\n/// The return value ranges from 1 to 31. (The last day of month differs by months.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().day(), 8);\n/// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().day(), 14);\n/// ```\n///\n/// Combined with [`NaiveDate::pred`](#method.pred),\n/// one can determine the number of days in a particular month.\n/// (Note that this panics when `year` is out of range.)\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// fn ndays_in_month(year: i32, month: u32) -> u32 {\n///     // the first day of the next month...\n///     let (y, m) = if month == 12 { (year + 1, 1) } else { (year, month + 1) };\n///     let d = NaiveDate::from_ymd_opt(y, m, 1).unwrap();\n///\n///     // ...is preceded by the last day of the original month\n///     d.pred_opt().unwrap().day()\n/// }\n///\n/// assert_eq!(ndays_in_month(2015, 8), 31);\n/// assert_eq!(ndays_in_month(2015, 9), 30);\n/// assert_eq!(ndays_in_month(2015, 12), 31);\n/// assert_eq!(ndays_in_month(2016, 2), 29);\n/// assert_eq!(ndays_in_month(2017, 2), 28);\n/// ```\n#[inline]\nfn day(&self) -> u32{\n        self.mdf().day()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::day0":["/// Returns the day of month starting from 0.\n///\n/// The return value ranges from 0 to 30. (The last day of month differs by months.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().day0(), 7);\n/// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().day0(), 13);\n/// ```\n#[inline]\nfn day0(&self) -> u32{\n        self.mdf().day() - 1\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::iso_week":["#[inline]\nfn iso_week(&self) -> IsoWeek{\n        isoweek::iso_week_from_yof(self.year(), self.of())\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::month":["/// Returns the month number starting from 1.\n///\n/// The return value ranges from 1 to 12.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().month(), 9);\n/// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().month(), 3);\n/// ```\n#[inline]\nfn month(&self) -> u32{\n        self.mdf().month()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::month0":["/// Returns the month number starting from 0.\n///\n/// The return value ranges from 0 to 11.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().month0(), 8);\n/// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().month0(), 2);\n/// ```\n#[inline]\nfn month0(&self) -> u32{\n        self.mdf().month() - 1\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::ordinal":["/// Returns the day of year starting from 1.\n///\n/// The return value ranges from 1 to 366. (The last day of year differs by years.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().ordinal(), 251);\n/// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().ordinal(), 74);\n/// ```\n///\n/// Combined with [`NaiveDate::pred`](#method.pred),\n/// one can determine the number of days in a particular year.\n/// (Note that this panics when `year` is out of range.)\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// fn ndays_in_year(year: i32) -> u32 {\n///     // the first day of the next year...\n///     let d = NaiveDate::from_ymd_opt(year + 1, 1, 1).unwrap();\n///\n///     // ...is preceded by the last day of the original year\n///     d.pred_opt().unwrap().ordinal()\n/// }\n///\n/// assert_eq!(ndays_in_year(2015), 365);\n/// assert_eq!(ndays_in_year(2016), 366);\n/// assert_eq!(ndays_in_year(2017), 365);\n/// assert_eq!(ndays_in_year(2000), 366);\n/// assert_eq!(ndays_in_year(2100), 365);\n/// ```\n#[inline]\nfn ordinal(&self) -> u32{\n        self.of().ordinal()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::ordinal0":["/// Returns the day of year starting from 0.\n///\n/// The return value ranges from 0 to 365. (The last day of year differs by years.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().ordinal0(), 250);\n/// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().ordinal0(), 73);\n/// ```\n#[inline]\nfn ordinal0(&self) -> u32{\n        self.of().ordinal() - 1\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::weekday":["/// Returns the day of week.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike, Weekday};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().weekday(), Weekday::Tue);\n/// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().weekday(), Weekday::Fri);\n/// ```\n#[inline]\nfn weekday(&self) -> Weekday{\n        self.of().weekday()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::with_day":["/// Makes a new `NaiveDate` with the day of month (starting from 1) changed.\n///\n/// Returns `None` when the resulting `NaiveDate` would be invalid.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_day(30),\n///            Some(NaiveDate::from_ymd_opt(2015, 9, 30).unwrap()));\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_day(31),\n///            None); // no September 31\n/// ```\n#[inline]\nfn with_day(&self, day: u32) -> Option<NaiveDate>{\n        self.with_mdf(self.mdf().with_day(day)?)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::with_day0":["/// Makes a new `NaiveDate` with the day of month (starting from 0) changed.\n///\n/// Returns `None` when the resulting `NaiveDate` would be invalid.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_day0(29),\n///            Some(NaiveDate::from_ymd_opt(2015, 9, 30).unwrap()));\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_day0(30),\n///            None); // no September 31\n/// ```\n#[inline]\nfn with_day0(&self, day0: u32) -> Option<NaiveDate>{\n        let day = day0.checked_add(1)?;\n        self.with_mdf(self.mdf().with_day(day)?)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::with_month":["/// Makes a new `NaiveDate` with the month number (starting from 1) changed.\n///\n/// Returns `None` when the resulting `NaiveDate` would be invalid.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_month(10),\n///            Some(NaiveDate::from_ymd_opt(2015, 10, 8).unwrap()));\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_month(13), None); // no month 13\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 30).unwrap().with_month(2), None); // no February 30\n/// ```\n#[inline]\nfn with_month(&self, month: u32) -> Option<NaiveDate>{\n        self.with_mdf(self.mdf().with_month(month)?)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::with_month0":["/// Makes a new `NaiveDate` with the month number (starting from 0) changed.\n///\n/// Returns `None` when the resulting `NaiveDate` would be invalid.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_month0(9),\n///            Some(NaiveDate::from_ymd_opt(2015, 10, 8).unwrap()));\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_month0(12), None); // no month 13\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 30).unwrap().with_month0(1), None); // no February 30\n/// ```\n#[inline]\nfn with_month0(&self, month0: u32) -> Option<NaiveDate>{\n        let month = month0.checked_add(1)?;\n        self.with_mdf(self.mdf().with_month(month)?)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::with_ordinal":["/// Makes a new `NaiveDate` with the day of year (starting from 1) changed.\n///\n/// Returns `None` when the resulting `NaiveDate` would be invalid.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 1, 1).unwrap().with_ordinal(60),\n///            Some(NaiveDate::from_ymd_opt(2015, 3, 1).unwrap()));\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 1, 1).unwrap().with_ordinal(366),\n///            None); // 2015 had only 365 days\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2016, 1, 1).unwrap().with_ordinal(60),\n///            Some(NaiveDate::from_ymd_opt(2016, 2, 29).unwrap()));\n/// assert_eq!(NaiveDate::from_ymd_opt(2016, 1, 1).unwrap().with_ordinal(366),\n///            Some(NaiveDate::from_ymd_opt(2016, 12, 31).unwrap()));\n/// ```\n#[inline]\nfn with_ordinal(&self, ordinal: u32) -> Option<NaiveDate>{\n        self.of().with_ordinal(ordinal).map(|of| self.with_of(of))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::with_ordinal0":["/// Makes a new `NaiveDate` with the day of year (starting from 0) changed.\n///\n/// Returns `None` when the resulting `NaiveDate` would be invalid.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 1, 1).unwrap().with_ordinal0(59),\n///            Some(NaiveDate::from_ymd_opt(2015, 3, 1).unwrap()));\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 1, 1).unwrap().with_ordinal0(365),\n///            None); // 2015 had only 365 days\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2016, 1, 1).unwrap().with_ordinal0(59),\n///            Some(NaiveDate::from_ymd_opt(2016, 2, 29).unwrap()));\n/// assert_eq!(NaiveDate::from_ymd_opt(2016, 1, 1).unwrap().with_ordinal0(365),\n///            Some(NaiveDate::from_ymd_opt(2016, 12, 31).unwrap()));\n/// ```\n#[inline]\nfn with_ordinal0(&self, ordinal0: u32) -> Option<NaiveDate>{\n        let ordinal = ordinal0.checked_add(1)?;\n        self.with_ordinal(ordinal)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::with_year":["/// Makes a new `NaiveDate` with the year number changed.\n///\n/// Returns `None` when the resulting `NaiveDate` would be invalid.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_year(2016),\n///            Some(NaiveDate::from_ymd_opt(2016, 9, 8).unwrap()));\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().with_year(-308),\n///            Some(NaiveDate::from_ymd_opt(-308, 9, 8).unwrap()));\n/// ```\n///\n/// A leap day (February 29) is a good example that this method can return `None`.\n///\n/// ```\n/// # use chrono::{NaiveDate, Datelike};\n/// assert!(NaiveDate::from_ymd_opt(2016, 2, 29).unwrap().with_year(2015).is_none());\n/// assert!(NaiveDate::from_ymd_opt(2016, 2, 29).unwrap().with_year(2020).is_some());\n/// ```\n#[inline]\nfn with_year(&self, year: i32) -> Option<NaiveDate>{\n        // we need to operate with `mdf` since we should keep the month and day number as is\n        let mdf = self.mdf();\n\n        // adjust the flags as needed\n        let flags = YearFlags::from_year(year);\n        let mdf = mdf.with_flags(flags);\n\n        NaiveDate::from_mdf(year, mdf)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDate as traits::Datelike>::year":["/// Returns the year number in the [calendar date](#calendar-date).\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().year(), 2015);\n/// assert_eq!(NaiveDate::from_ymd_opt(-308, 3, 14).unwrap().year(), -308); // 309 BCE\n/// ```\n#[inline]\nfn year(&self) -> i32{\n        self.ymdf >> 13\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDateDaysIterator as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        if self.value == NaiveDate::MIN {\n            return None;\n        }\n        let current = self.value;\n        self.value = current.pred_opt().unwrap();\n        Some(current)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDateDaysIterator as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        if self.value == NaiveDate::MAX {\n            return None;\n        }\n        // current < NaiveDate::MAX from here on:\n        let current = self.value;\n        // This can't panic because current is < NaiveDate::MAX:\n        self.value = current.succ_opt().unwrap();\n        Some(current)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDateDaysIterator as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let exact_size = NaiveDate::MAX.signed_duration_since(self.value).num_days();\n        (exact_size as usize, Some(exact_size as usize))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDateWeeksIterator as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<Self::Item>{\n        if self.value - NaiveDate::MIN < OldDuration::weeks(1) {\n            return None;\n        }\n        let current = self.value;\n        self.value = current - OldDuration::weeks(1);\n        Some(current)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        if NaiveDate::MAX - self.value < OldDuration::weeks(1) {\n            return None;\n        }\n        let current = self.value;\n        self.value = current + OldDuration::weeks(1);\n        Some(current)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let exact_size = NaiveDate::MAX.signed_duration_since(self.value).num_weeks();\n        (exact_size as usize, Some(exact_size as usize))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"<naive::datetime::NaiveDateTime as round::DurationRound>::duration_round":["fn duration_round(self, duration: Duration) -> Result<Self, Self::Err>{\n        duration_round(self, self, duration)\n    }","Real(LocalPath(\"src/round.rs\"))"],"<naive::datetime::NaiveDateTime as round::DurationRound>::duration_trunc":["fn duration_trunc(self, duration: Duration) -> Result<Self, Self::Err>{\n        duration_trunc(self, self, duration)\n    }","Real(LocalPath(\"src/round.rs\"))"],"<naive::datetime::NaiveDateTime as std::default::Default>::default":["fn default() -> Self{\n        NaiveDateTime::from_timestamp_opt(0, 0).unwrap()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.date.fmt(f)?;\n        f.write_char('T')?;\n        self.time.fmt(f)\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.date.fmt(f)?;\n        f.write_char(' ')?;\n        self.time.fmt(f)\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as std::ops::Add<month::Months>>::add":["/// An addition of months to `NaiveDateTime` clamped to valid days in resulting month.\n///\n/// # Panics\n///\n/// Panics if the resulting date would be out of range.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Months, NaiveDate};\n///\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(1, 0, 0).unwrap() + Months::new(1),\n///     NaiveDate::from_ymd_opt(2014, 2, 1).unwrap().and_hms_opt(1, 0, 0).unwrap()\n/// );\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(0, 2, 0).unwrap() + Months::new(11),\n///     NaiveDate::from_ymd_opt(2014, 12, 1).unwrap().and_hms_opt(0, 2, 0).unwrap()\n/// );\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(0, 0, 3).unwrap() + Months::new(12),\n///     NaiveDate::from_ymd_opt(2015, 1, 1).unwrap().and_hms_opt(0, 0, 3).unwrap()\n/// );\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(0, 0, 4).unwrap() + Months::new(13),\n///     NaiveDate::from_ymd_opt(2015, 2, 1).unwrap().and_hms_opt(0, 0, 4).unwrap()\n/// );\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2014, 1, 31).unwrap().and_hms_opt(0, 5, 0).unwrap() + Months::new(1),\n///     NaiveDate::from_ymd_opt(2014, 2, 28).unwrap().and_hms_opt(0, 5, 0).unwrap()\n/// );\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2020, 1, 31).unwrap().and_hms_opt(6, 0, 0).unwrap() + Months::new(1),\n///     NaiveDate::from_ymd_opt(2020, 2, 29).unwrap().and_hms_opt(6, 0, 0).unwrap()\n/// );\n/// ```\nfn add(self, rhs: Months) -> Self::Output{\n        Self { date: self.date.checked_add_months(rhs).unwrap(), time: self.time }\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as std::ops::Add<naive::date::Days>>::add":["fn add(self, days: Days) -> Self::Output{\n        self.checked_add_days(days).unwrap()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as std::ops::Add<oldtime::Duration>>::add":["#[inline]\nfn add(self, rhs: OldDuration) -> NaiveDateTime{\n        self.checked_add_signed(rhs).expect(\"`NaiveDateTime + Duration` overflowed\")\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as std::ops::AddAssign<oldtime::Duration>>::add_assign":["#[inline]\nfn add_assign(&mut self, rhs: OldDuration){\n        *self = self.add(rhs);\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as std::ops::Sub<month::Months>>::sub":["fn sub(self, rhs: Months) -> Self::Output{\n        Self { date: self.date.checked_sub_months(rhs).unwrap(), time: self.time }\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as std::ops::Sub<naive::date::Days>>::sub":["fn sub(self, days: Days) -> Self::Output{\n        self.checked_sub_days(days).unwrap()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as std::ops::Sub<oldtime::Duration>>::sub":["#[inline]\nfn sub(self, rhs: OldDuration) -> NaiveDateTime{\n        self.checked_sub_signed(rhs).expect(\"`NaiveDateTime - Duration` overflowed\")\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as std::ops::Sub>::sub":["#[inline]\nfn sub(self, rhs: NaiveDateTime) -> OldDuration{\n        self.signed_duration_since(rhs)\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["#[inline]\nfn sub_assign(&mut self, rhs: OldDuration){\n        *self = self.sub(rhs);\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as std::str::FromStr>::from_str":["fn from_str(s: &str) -> ParseResult<NaiveDateTime>{\n        const ITEMS: &[Item<'static>] = &[\n            Item::Numeric(Numeric::Year, Pad::Zero),\n            Item::Space(\"\"),\n            Item::Literal(\"-\"),\n            Item::Numeric(Numeric::Month, Pad::Zero),\n            Item::Space(\"\"),\n            Item::Literal(\"-\"),\n            Item::Numeric(Numeric::Day, Pad::Zero),\n            Item::Space(\"\"),\n            Item::Literal(\"T\"), // XXX shouldn't this be case-insensitive?\n            Item::Numeric(Numeric::Hour, Pad::Zero),\n            Item::Space(\"\"),\n            Item::Literal(\":\"),\n            Item::Numeric(Numeric::Minute, Pad::Zero),\n            Item::Space(\"\"),\n            Item::Literal(\":\"),\n            Item::Numeric(Numeric::Second, Pad::Zero),\n            Item::Fixed(Fixed::Nanosecond),\n            Item::Space(\"\"),\n        ];\n\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, ITEMS.iter())?;\n        parsed.to_naive_datetime_with_offset(0)\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::day":["/// Returns the day of month starting from 1.\n///\n/// The return value ranges from 1 to 31. (The last day of month differs by months.)\n///\n/// See also the [`NaiveDate::day`](./struct.NaiveDate.html#method.day) method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.day(), 25);\n/// ```\n#[inline]\nfn day(&self) -> u32{\n        self.date.day()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::day0":["/// Returns the day of month starting from 0.\n///\n/// The return value ranges from 0 to 30. (The last day of month differs by months.)\n///\n/// See also the [`NaiveDate::day0`](./struct.NaiveDate.html#method.day0) method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.day0(), 24);\n/// ```\n#[inline]\nfn day0(&self) -> u32{\n        self.date.day0()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::iso_week":["#[inline]\nfn iso_week(&self) -> IsoWeek{\n        self.date.iso_week()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::month":["/// Returns the month number starting from 1.\n///\n/// The return value ranges from 1 to 12.\n///\n/// See also the [`NaiveDate::month`](./struct.NaiveDate.html#method.month) method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.month(), 9);\n/// ```\n#[inline]\nfn month(&self) -> u32{\n        self.date.month()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::month0":["/// Returns the month number starting from 0.\n///\n/// The return value ranges from 0 to 11.\n///\n/// See also the [`NaiveDate::month0`](./struct.NaiveDate.html#method.month0) method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.month0(), 8);\n/// ```\n#[inline]\nfn month0(&self) -> u32{\n        self.date.month0()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::ordinal":["/// Returns the day of year starting from 1.\n///\n/// The return value ranges from 1 to 366. (The last day of year differs by years.)\n///\n/// See also the [`NaiveDate::ordinal`](./struct.NaiveDate.html#method.ordinal) method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.ordinal(), 268);\n/// ```\n#[inline]\nfn ordinal(&self) -> u32{\n        self.date.ordinal()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::ordinal0":["/// Returns the day of year starting from 0.\n///\n/// The return value ranges from 0 to 365. (The last day of year differs by years.)\n///\n/// See also the [`NaiveDate::ordinal0`](./struct.NaiveDate.html#method.ordinal0) method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.ordinal0(), 267);\n/// ```\n#[inline]\nfn ordinal0(&self) -> u32{\n        self.date.ordinal0()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::weekday":["/// Returns the day of week.\n///\n/// See also the [`NaiveDate::weekday`](./struct.NaiveDate.html#method.weekday) method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike, Weekday};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.weekday(), Weekday::Fri);\n/// ```\n#[inline]\nfn weekday(&self) -> Weekday{\n        self.date.weekday()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_day":["/// Makes a new `NaiveDateTime` with the day of month (starting from 1) changed.\n///\n/// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n///\n/// See also the [`NaiveDate::with_day`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.with_day(30), Some(NaiveDate::from_ymd_opt(2015, 9, 30).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// assert_eq!(dt.with_day(31), None); // no September 31\n/// ```\n#[inline]\nfn with_day(&self, day: u32) -> Option<NaiveDateTime>{\n        self.date.with_day(day).map(|d| NaiveDateTime { date: d, ..*self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_day0":["/// Makes a new `NaiveDateTime` with the day of month (starting from 0) changed.\n///\n/// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n///\n/// See also the [`NaiveDate::with_day0`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.with_day0(29), Some(NaiveDate::from_ymd_opt(2015, 9, 30).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// assert_eq!(dt.with_day0(30), None); // no September 31\n/// ```\n#[inline]\nfn with_day0(&self, day0: u32) -> Option<NaiveDateTime>{\n        self.date.with_day0(day0).map(|d| NaiveDateTime { date: d, ..*self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_month":["/// Makes a new `NaiveDateTime` with the month number (starting from 1) changed.\n///\n/// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n///\n/// See also the [`NaiveDate::with_month`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 30).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.with_month(10), Some(NaiveDate::from_ymd_opt(2015, 10, 30).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// assert_eq!(dt.with_month(13), None); // no month 13\n/// assert_eq!(dt.with_month(2), None); // no February 30\n/// ```\n#[inline]\nfn with_month(&self, month: u32) -> Option<NaiveDateTime>{\n        self.date.with_month(month).map(|d| NaiveDateTime { date: d, ..*self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_month0":["/// Makes a new `NaiveDateTime` with the month number (starting from 0) changed.\n///\n/// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n///\n/// See also the [`NaiveDate::with_month0`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 30).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.with_month0(9), Some(NaiveDate::from_ymd_opt(2015, 10, 30).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// assert_eq!(dt.with_month0(12), None); // no month 13\n/// assert_eq!(dt.with_month0(1), None); // no February 30\n/// ```\n#[inline]\nfn with_month0(&self, month0: u32) -> Option<NaiveDateTime>{\n        self.date.with_month0(month0).map(|d| NaiveDateTime { date: d, ..*self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_ordinal":["/// Makes a new `NaiveDateTime` with the day of year (starting from 1) changed.\n///\n/// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n///\n/// See also the [`NaiveDate::with_ordinal`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.with_ordinal(60),\n///            Some(NaiveDate::from_ymd_opt(2015, 3, 1).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// assert_eq!(dt.with_ordinal(366), None); // 2015 had only 365 days\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2016, 9, 8).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.with_ordinal(60),\n///            Some(NaiveDate::from_ymd_opt(2016, 2, 29).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// assert_eq!(dt.with_ordinal(366),\n///            Some(NaiveDate::from_ymd_opt(2016, 12, 31).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// ```\n#[inline]\nfn with_ordinal(&self, ordinal: u32) -> Option<NaiveDateTime>{\n        self.date.with_ordinal(ordinal).map(|d| NaiveDateTime { date: d, ..*self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_ordinal0":["/// Makes a new `NaiveDateTime` with the day of year (starting from 0) changed.\n///\n/// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n///\n/// See also the [`NaiveDate::with_ordinal0`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.with_ordinal0(59),\n///            Some(NaiveDate::from_ymd_opt(2015, 3, 1).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// assert_eq!(dt.with_ordinal0(365), None); // 2015 had only 365 days\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2016, 9, 8).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.with_ordinal0(59),\n///            Some(NaiveDate::from_ymd_opt(2016, 2, 29).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// assert_eq!(dt.with_ordinal0(365),\n///            Some(NaiveDate::from_ymd_opt(2016, 12, 31).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// ```\n#[inline]\nfn with_ordinal0(&self, ordinal0: u32) -> Option<NaiveDateTime>{\n        self.date.with_ordinal0(ordinal0).map(|d| NaiveDateTime { date: d, ..*self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_year":["/// Makes a new `NaiveDateTime` with the year number changed.\n///\n/// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n///\n/// See also the [`NaiveDate::with_year`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.with_year(2016), Some(NaiveDate::from_ymd_opt(2016, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// assert_eq!(dt.with_year(-308), Some(NaiveDate::from_ymd_opt(-308, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// ```\n#[inline]\nfn with_year(&self, year: i32) -> Option<NaiveDateTime>{\n        self.date.with_year(year).map(|d| NaiveDateTime { date: d, ..*self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Datelike>::year":["/// Returns the year number in the [calendar date](./struct.NaiveDate.html#calendar-date).\n///\n/// See also the [`NaiveDate::year`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 25).unwrap().and_hms_opt(12, 34, 56).unwrap();\n/// assert_eq!(dt.year(), 2015);\n/// ```\n#[inline]\nfn year(&self) -> i32{\n        self.date.year()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Timelike>::hour":["/// Returns the hour number from 0 to 23.\n///\n/// See also the [`NaiveTime::hour`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n/// assert_eq!(dt.hour(), 12);\n/// ```\n#[inline]\nfn hour(&self) -> u32{\n        self.time.hour()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Timelike>::minute":["/// Returns the minute number from 0 to 59.\n///\n/// See also the [`NaiveTime::minute`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n/// assert_eq!(dt.minute(), 34);\n/// ```\n#[inline]\nfn minute(&self) -> u32{\n        self.time.minute()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Timelike>::nanosecond":["/// Returns the number of nanoseconds since the whole non-leap second.\n/// The range from 1,000,000,000 to 1,999,999,999 represents\n/// the [leap second](./struct.NaiveTime.html#leap-second-handling).\n///\n/// See also the [`NaiveTime::nanosecond`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n/// assert_eq!(dt.nanosecond(), 789_000_000);\n/// ```\n#[inline]\nfn nanosecond(&self) -> u32{\n        self.time.nanosecond()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Timelike>::second":["/// Returns the second number from 0 to 59.\n///\n/// See also the [`NaiveTime::second`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n/// assert_eq!(dt.second(), 56);\n/// ```\n#[inline]\nfn second(&self) -> u32{\n        self.time.second()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Timelike>::with_hour":["/// Makes a new `NaiveDateTime` with the hour number changed.\n///\n/// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n///\n/// See also the [`NaiveTime::with_hour`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n/// assert_eq!(dt.with_hour(7),\n///            Some(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(7, 34, 56, 789).unwrap()));\n/// assert_eq!(dt.with_hour(24), None);\n/// ```\n#[inline]\nfn with_hour(&self, hour: u32) -> Option<NaiveDateTime>{\n        self.time.with_hour(hour).map(|t| NaiveDateTime { time: t, ..*self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Timelike>::with_minute":["/// Makes a new `NaiveDateTime` with the minute number changed.\n///\n/// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n///\n/// See also the\n/// [`NaiveTime::with_minute`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n/// assert_eq!(dt.with_minute(45),\n///            Some(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 45, 56, 789).unwrap()));\n/// assert_eq!(dt.with_minute(60), None);\n/// ```\n#[inline]\nfn with_minute(&self, min: u32) -> Option<NaiveDateTime>{\n        self.time.with_minute(min).map(|t| NaiveDateTime { time: t, ..*self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Timelike>::with_nanosecond":["/// Makes a new `NaiveDateTime` with nanoseconds since the whole non-leap second changed.\n///\n/// Returns `None` when the resulting `NaiveDateTime` would be invalid.\n/// As with the [`NaiveDateTime::nanosecond`] method,\n/// the input range can exceed 1,000,000,000 for leap seconds.\n///\n/// See also the [`NaiveTime::with_nanosecond`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n/// assert_eq!(dt.with_nanosecond(333_333_333),\n///            Some(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_nano_opt(12, 34, 56, 333_333_333).unwrap()));\n/// assert_eq!(dt.with_nanosecond(1_333_333_333), // leap second\n///            Some(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_nano_opt(12, 34, 56, 1_333_333_333).unwrap()));\n/// assert_eq!(dt.with_nanosecond(2_000_000_000), None);\n/// ```\n#[inline]\nfn with_nanosecond(&self, nano: u32) -> Option<NaiveDateTime>{\n        self.time.with_nanosecond(nano).map(|t| NaiveDateTime { time: t, ..*self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::datetime::NaiveDateTime as traits::Timelike>::with_second":["/// Makes a new `NaiveDateTime` with the second number changed.\n///\n/// Returns `None` when the resulting `NaiveDateTime` would be invalid. As\n/// with the [`NaiveDateTime::second`] method, the input range is\n/// restricted to 0 through 59.\n///\n/// See also the [`NaiveTime::with_second`] method.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Timelike};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 56, 789).unwrap();\n/// assert_eq!(dt.with_second(17),\n///            Some(NaiveDate::from_ymd_opt(2015, 9, 8).unwrap().and_hms_milli_opt(12, 34, 17, 789).unwrap()));\n/// assert_eq!(dt.with_second(60), None);\n/// ```\n#[inline]\nfn with_second(&self, sec: u32) -> Option<NaiveDateTime>{\n        self.time.with_second(sec).map(|t| NaiveDateTime { time: t, ..*self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"<naive::internals::Mdf as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let Mdf(mdf) = *self;\n        write!(\n            f,\n            \"Mdf(({} << 9) | ({} << 4) | {:#04o} /*{:?}*/)\",\n            mdf >> 9,\n            (mdf >> 4) & 0b1_1111,\n            mdf & 0b1111,\n            YearFlags((mdf & 0b1111) as u8)\n        )\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"<naive::internals::Of as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let Of(of) = *self;\n        write!(\n            f,\n            \"Of(({} << 4) | {:#04o} /*{:?}*/)\",\n            of >> 4,\n            of & 0b1111,\n            YearFlags((of & 0b1111) as u8)\n        )\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"<naive::internals::YearFlags as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let YearFlags(flags) = *self;\n        match flags {\n            0o15 => \"A\".fmt(f),\n            0o05 => \"AG\".fmt(f),\n            0o14 => \"B\".fmt(f),\n            0o04 => \"BA\".fmt(f),\n            0o13 => \"C\".fmt(f),\n            0o03 => \"CB\".fmt(f),\n            0o12 => \"D\".fmt(f),\n            0o02 => \"DC\".fmt(f),\n            0o11 => \"E\".fmt(f),\n            0o01 => \"ED\".fmt(f),\n            0o10 => \"F?\".fmt(f),\n            0o00 => \"FE?\".fmt(f), // non-canonical\n            0o17 => \"F\".fmt(f),\n            0o07 => \"FE\".fmt(f),\n            0o16 => \"G\".fmt(f),\n            0o06 => \"GF\".fmt(f),\n            _ => write!(f, \"YearFlags({})\", flags),\n        }\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"<naive::isoweek::IsoWeek as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let year = self.year();\n        let week = self.week();\n        if (0..=9999).contains(&year) {\n            write!(f, \"{:04}-W{:02}\", year, week)\n        } else {\n            // ISO 8601 requires the explicit sign for out-of-range years\n            write!(f, \"{:+05}-W{:02}\", year, week)\n        }\n    }","Real(LocalPath(\"src/naive/isoweek.rs\"))"],"<naive::time::NaiveTime as std::default::Default>::default":["fn default() -> Self{\n        NaiveTime::from_hms_opt(0, 0, 0).unwrap()\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let (hour, min, sec) = self.hms();\n        let (sec, nano) = if self.frac >= 1_000_000_000 {\n            (sec + 1, self.frac - 1_000_000_000)\n        } else {\n            (sec, self.frac)\n        };\n\n        use core::fmt::Write;\n        write_hundreds(f, hour as u8)?;\n        f.write_char(':')?;\n        write_hundreds(f, min as u8)?;\n        f.write_char(':')?;\n        write_hundreds(f, sec as u8)?;\n\n        if nano == 0 {\n            Ok(())\n        } else if nano % 1_000_000 == 0 {\n            write!(f, \".{:03}\", nano / 1_000_000)\n        } else if nano % 1_000 == 0 {\n            write!(f, \".{:06}\", nano / 1_000)\n        } else {\n            write!(f, \".{:09}\", nano)\n        }\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Debug::fmt(self, f)\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as std::ops::Add<oldtime::Duration>>::add":["#[inline]\nfn add(self, rhs: OldDuration) -> NaiveTime{\n        self.overflowing_add_signed(rhs).0\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as std::ops::AddAssign<oldtime::Duration>>::add_assign":["#[inline]\nfn add_assign(&mut self, rhs: OldDuration){\n        *self = self.add(rhs);\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as std::ops::Sub<oldtime::Duration>>::sub":["#[inline]\nfn sub(self, rhs: OldDuration) -> NaiveTime{\n        self.overflowing_sub_signed(rhs).0\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as std::ops::Sub>::sub":["#[inline]\nfn sub(self, rhs: NaiveTime) -> OldDuration{\n        self.signed_duration_since(rhs)\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["#[inline]\nfn sub_assign(&mut self, rhs: OldDuration){\n        *self = self.sub(rhs);\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as std::str::FromStr>::from_str":["fn from_str(s: &str) -> ParseResult<NaiveTime>{\n        const ITEMS: &[Item<'static>] = &[\n            Item::Numeric(Numeric::Hour, Pad::Zero),\n            Item::Literal(\":\"),\n            Item::Numeric(Numeric::Minute, Pad::Zero),\n            Item::Literal(\":\"),\n            Item::Numeric(Numeric::Second, Pad::Zero),\n            Item::Fixed(Fixed::Nanosecond),\n        ];\n\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, ITEMS.iter())?;\n        parsed.to_naive_time()\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as traits::Timelike>::hour":["/// Returns the hour number from 0 to 23.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveTime, Timelike};\n///\n/// assert_eq!(NaiveTime::from_hms_opt(0, 0, 0).unwrap().hour(), 0);\n/// assert_eq!(NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap().hour(), 23);\n/// ```\n#[inline]\nfn hour(&self) -> u32{\n        self.hms().0\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as traits::Timelike>::minute":["/// Returns the minute number from 0 to 59.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveTime, Timelike};\n///\n/// assert_eq!(NaiveTime::from_hms_opt(0, 0, 0).unwrap().minute(), 0);\n/// assert_eq!(NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap().minute(), 56);\n/// ```\n#[inline]\nfn minute(&self) -> u32{\n        self.hms().1\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as traits::Timelike>::nanosecond":["/// Returns the number of nanoseconds since the whole non-leap second.\n/// The range from 1,000,000,000 to 1,999,999,999 represents\n/// the [leap second](#leap-second-handling).\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveTime, Timelike};\n///\n/// assert_eq!(NaiveTime::from_hms_opt(0, 0, 0).unwrap().nanosecond(), 0);\n/// assert_eq!(NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap().nanosecond(), 12_345_678);\n/// ```\n///\n/// Leap seconds may have seemingly out-of-range return values.\n/// You can reduce the range with `time.nanosecond() % 1_000_000_000`, or\n/// use the proper [formatting method](#method.format) to get a human-readable representation.\n///\ndoc = \"```\"\n/// # use chrono::{NaiveTime, Timelike};\n/// let leap = NaiveTime::from_hms_milli_opt(23, 59, 59, 1_000).unwrap();\n/// assert_eq!(leap.nanosecond(), 1_000_000_000);\n/// assert_eq!(leap.format(\"%H:%M:%S%.9f\").to_string(), \"23:59:60.000000000\");\n/// ```\n#[inline]\nfn nanosecond(&self) -> u32{\n        self.frac\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as traits::Timelike>::num_seconds_from_midnight":["/// Returns the number of non-leap seconds past the last midnight.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveTime, Timelike};\n///\n/// assert_eq!(NaiveTime::from_hms_opt(1, 2, 3).unwrap().num_seconds_from_midnight(),\n///            3723);\n/// assert_eq!(NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap().num_seconds_from_midnight(),\n///            86164);\n/// assert_eq!(NaiveTime::from_hms_milli_opt(23, 59, 59, 1_000).unwrap().num_seconds_from_midnight(),\n///            86399);\n/// ```\n#[inline]\nfn num_seconds_from_midnight(&self) -> u32{\n        self.secs // do not repeat the calculation!\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as traits::Timelike>::second":["/// Returns the second number from 0 to 59.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveTime, Timelike};\n///\n/// assert_eq!(NaiveTime::from_hms_opt(0, 0, 0).unwrap().second(), 0);\n/// assert_eq!(NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap().second(), 4);\n/// ```\n///\n/// This method never returns 60 even when it is a leap second.\n/// ([Why?](#leap-second-handling))\n/// Use the proper [formatting method](#method.format) to get a human-readable representation.\n///\ndoc = \"```\"\n/// # use chrono::{NaiveTime, Timelike};\n/// let leap = NaiveTime::from_hms_milli_opt(23, 59, 59, 1_000).unwrap();\n/// assert_eq!(leap.second(), 59);\n/// assert_eq!(leap.format(\"%H:%M:%S\").to_string(), \"23:59:60\");\n/// ```\n#[inline]\nfn second(&self) -> u32{\n        self.hms().2\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as traits::Timelike>::with_hour":["/// Makes a new `NaiveTime` with the hour number changed.\n///\n/// Returns `None` when the resulting `NaiveTime` would be invalid.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveTime, Timelike};\n///\n/// let dt = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n/// assert_eq!(dt.with_hour(7), Some(NaiveTime::from_hms_nano_opt(7, 56, 4, 12_345_678).unwrap()));\n/// assert_eq!(dt.with_hour(24), None);\n/// ```\n#[inline]\nfn with_hour(&self, hour: u32) -> Option<NaiveTime>{\n        if hour >= 24 {\n            return None;\n        }\n        let secs = hour * 3600 + self.secs % 3600;\n        Some(NaiveTime { secs, ..*self })\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as traits::Timelike>::with_minute":["/// Makes a new `NaiveTime` with the minute number changed.\n///\n/// Returns `None` when the resulting `NaiveTime` would be invalid.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveTime, Timelike};\n///\n/// let dt = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n/// assert_eq!(dt.with_minute(45), Some(NaiveTime::from_hms_nano_opt(23, 45, 4, 12_345_678).unwrap()));\n/// assert_eq!(dt.with_minute(60), None);\n/// ```\n#[inline]\nfn with_minute(&self, min: u32) -> Option<NaiveTime>{\n        if min >= 60 {\n            return None;\n        }\n        let secs = self.secs / 3600 * 3600 + min * 60 + self.secs % 60;\n        Some(NaiveTime { secs, ..*self })\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as traits::Timelike>::with_nanosecond":["/// Makes a new `NaiveTime` with nanoseconds since the whole non-leap second changed.\n///\n/// Returns `None` when the resulting `NaiveTime` would be invalid.\n/// As with the [`nanosecond`](#method.nanosecond) method,\n/// the input range can exceed 1,000,000,000 for leap seconds.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveTime, Timelike};\n///\n/// let dt = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n/// assert_eq!(dt.with_nanosecond(333_333_333),\n///            Some(NaiveTime::from_hms_nano_opt(23, 56, 4, 333_333_333).unwrap()));\n/// assert_eq!(dt.with_nanosecond(2_000_000_000), None);\n/// ```\n///\n/// Leap seconds can theoretically follow *any* whole second.\n/// The following would be a proper leap second at the time zone offset of UTC-00:03:57\n/// (there are several historical examples comparable to this \"non-sense\" offset),\n/// and therefore is allowed.\n///\n/// ```\n/// # use chrono::{NaiveTime, Timelike};\n/// # let dt = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n/// assert_eq!(dt.with_nanosecond(1_333_333_333),\n///            Some(NaiveTime::from_hms_nano_opt(23, 56, 4, 1_333_333_333).unwrap()));\n/// ```\n#[inline]\nfn with_nanosecond(&self, nano: u32) -> Option<NaiveTime>{\n        if nano >= 2_000_000_000 {\n            return None;\n        }\n        Some(NaiveTime { frac: nano, ..*self })\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<naive::time::NaiveTime as traits::Timelike>::with_second":["/// Makes a new `NaiveTime` with the second number changed.\n///\n/// Returns `None` when the resulting `NaiveTime` would be invalid.\n/// As with the [`second`](#method.second) method,\n/// the input range is restricted to 0 through 59.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveTime, Timelike};\n///\n/// let dt = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n/// assert_eq!(dt.with_second(17), Some(NaiveTime::from_hms_nano_opt(23, 56, 17, 12_345_678).unwrap()));\n/// assert_eq!(dt.with_second(60), None);\n/// ```\n#[inline]\nfn with_second(&self, sec: u32) -> Option<NaiveTime>{\n        if sec >= 60 {\n            return None;\n        }\n        let secs = self.secs / 60 * 60 + sec;\n        Some(NaiveTime { secs, ..*self })\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"<offset::fixed::FixedOffset as offset::Offset>::fix":["fn fix(&self) -> FixedOffset{\n        *self\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"<offset::fixed::FixedOffset as offset::TimeZone>::from_offset":["fn from_offset(offset: &FixedOffset) -> FixedOffset{\n        *offset\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_local_date":["fn offset_from_local_date(&self, _local: &NaiveDate) -> LocalResult<FixedOffset>{\n        LocalResult::Single(*self)\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_local_datetime":["fn offset_from_local_datetime(&self, _local: &NaiveDateTime) -> LocalResult<FixedOffset>{\n        LocalResult::Single(*self)\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_utc_date":["fn offset_from_utc_date(&self, _utc: &NaiveDate) -> FixedOffset{\n        *self\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_utc_datetime":["fn offset_from_utc_datetime(&self, _utc: &NaiveDateTime) -> FixedOffset{\n        *self\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"<offset::fixed::FixedOffset as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        let offset = self.local_minus_utc;\n        let (sign, offset) = if offset < 0 { ('-', -offset) } else { ('+', offset) };\n        let sec = offset.rem_euclid(60);\n        let mins = offset.div_euclid(60);\n        let min = mins.rem_euclid(60);\n        let hour = mins.div_euclid(60);\n        if sec == 0 {\n            write!(f, \"{}{:02}:{:02}\", sign, hour, min)\n        } else {\n            write!(f, \"{}{:02}:{:02}:{:02}\", sign, hour, min, sec)\n        }\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"<offset::fixed::FixedOffset as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        fmt::Debug::fmt(self, f)\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"<offset::local::Local as offset::TimeZone>::from_offset":["fn from_offset(_offset: &FixedOffset) -> Local{\n        Local\n    }","Real(LocalPath(\"src/offset/local/mod.rs\"))"],"<offset::local::Local as offset::TimeZone>::offset_from_local_date":["#[allow(deprecated)]\nfn offset_from_local_date(&self, local: &NaiveDate) -> LocalResult<FixedOffset>{\n        // Get the offset at local midnight.\n        self.offset_from_local_datetime(&local.and_time(NaiveTime::MIN))\n    }","Real(LocalPath(\"src/offset/local/mod.rs\"))"],"<offset::local::Local as offset::TimeZone>::offset_from_local_datetime":["fn offset_from_local_datetime(&self, local: &NaiveDateTime) -> LocalResult<FixedOffset>{\n        inner::offset_from_local_datetime(local)\n    }","Real(LocalPath(\"src/offset/local/mod.rs\"))"],"<offset::local::Local as offset::TimeZone>::offset_from_utc_date":["#[allow(deprecated)]\nfn offset_from_utc_date(&self, utc: &NaiveDate) -> FixedOffset{\n        // Get the offset at midnight.\n        self.offset_from_utc_datetime(&utc.and_time(NaiveTime::MIN))\n    }","Real(LocalPath(\"src/offset/local/mod.rs\"))"],"<offset::local::Local as offset::TimeZone>::offset_from_utc_datetime":["fn offset_from_utc_datetime(&self, utc: &NaiveDateTime) -> FixedOffset{\n        inner::offset_from_utc_datetime(utc).unwrap()\n    }","Real(LocalPath(\"src/offset/local/mod.rs\"))"],"<offset::local::inner::Cache as std::default::Default>::default":["fn default() -> Cache{\n        // default to UTC if no local timezone can be found\n        let env_tz = env::var(\"TZ\").ok();\n        let env_ref = env_tz.as_deref();\n        Cache {\n            last_checked: SystemTime::now(),\n            source: Source::new(env_ref),\n            zone: current_zone(env_ref),\n        }\n    }","Real(LocalPath(\"src/offset/local/unix.rs\"))"],"<offset::local::tz_info::Error as std::convert::From<std::io::Error>>::from":["fn from(error: io::Error) -> Self{\n        Error::Io(error)\n    }","Real(LocalPath(\"src/offset/local/tz_info/mod.rs\"))"],"<offset::local::tz_info::Error as std::convert::From<std::num::ParseIntError>>::from":["fn from(error: ParseIntError) -> Self{\n        Error::ParseInt(error)\n    }","Real(LocalPath(\"src/offset/local/tz_info/mod.rs\"))"],"<offset::local::tz_info::Error as std::convert::From<std::str::Utf8Error>>::from":["fn from(error: Utf8Error) -> Self{\n        Error::Utf8(error)\n    }","Real(LocalPath(\"src/offset/local/tz_info/mod.rs\"))"],"<offset::local::tz_info::Error as std::convert::From<std::time::SystemTimeError>>::from":["fn from(error: SystemTimeError) -> Self{\n        Error::SystemTime(error)\n    }","Real(LocalPath(\"src/offset/local/tz_info/mod.rs\"))"],"<offset::local::tz_info::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        use Error::*;\n        match self {\n            DateTime(error) => write!(f, \"invalid date time: {}\", error),\n            FindLocalTimeType(error) => error.fmt(f),\n            LocalTimeType(error) => write!(f, \"invalid local time type: {}\", error),\n            InvalidSlice(error) => error.fmt(f),\n            InvalidTzString(error) => write!(f, \"invalid TZ string: {}\", error),\n            InvalidTzFile(error) => error.fmt(f),\n            Io(error) => error.fmt(f),\n            OutOfRange(error) => error.fmt(f),\n            ParseInt(error) => error.fmt(f),\n            ProjectDateTime(error) => error.fmt(f),\n            SystemTime(error) => error.fmt(f),\n            TransitionRule(error) => write!(f, \"invalid transition rule: {}\", error),\n            TimeZone(error) => write!(f, \"invalid time zone: {}\", error),\n            UnsupportedTzFile(error) => error.fmt(f),\n            UnsupportedTzString(error) => write!(f, \"unsupported TZ string: {}\", error),\n            Utf8(error) => error.fmt(f),\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/mod.rs\"))"],"<offset::local::tz_info::rule::TransitionRule as std::convert::From<offset::local::tz_info::rule::AlternateTime>>::from":["fn from(inner: AlternateTime) -> Self{\n        TransitionRule::Alternate(inner)\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"<offset::local::tz_info::rule::TransitionRule as std::convert::From<offset::local::tz_info::timezone::LocalTimeType>>::from":["fn from(inner: LocalTimeType) -> Self{\n        TransitionRule::Fixed(inner)\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"<offset::local::tz_info::timezone::TimeZoneName as std::convert::AsRef<str>>::as_ref":["fn as_ref(&self) -> &str{\n        // SAFETY: ASCII is valid UTF-8\n        unsafe { str::from_utf8_unchecked(self.as_bytes()) }\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"<offset::local::tz_info::timezone::TimeZoneName as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        self.as_ref().fmt(f)\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"<offset::utc::Utc as offset::Offset>::fix":["fn fix(&self) -> FixedOffset{\n        FixedOffset::east_opt(0).unwrap()\n    }","Real(LocalPath(\"src/offset/utc.rs\"))"],"<offset::utc::Utc as offset::TimeZone>::from_offset":["fn from_offset(_state: &Utc) -> Utc{\n        Utc\n    }","Real(LocalPath(\"src/offset/utc.rs\"))"],"<offset::utc::Utc as offset::TimeZone>::offset_from_local_date":["fn offset_from_local_date(&self, _local: &NaiveDate) -> LocalResult<Utc>{\n        LocalResult::Single(Utc)\n    }","Real(LocalPath(\"src/offset/utc.rs\"))"],"<offset::utc::Utc as offset::TimeZone>::offset_from_local_datetime":["fn offset_from_local_datetime(&self, _local: &NaiveDateTime) -> LocalResult<Utc>{\n        LocalResult::Single(Utc)\n    }","Real(LocalPath(\"src/offset/utc.rs\"))"],"<offset::utc::Utc as offset::TimeZone>::offset_from_utc_date":["fn offset_from_utc_date(&self, _utc: &NaiveDate) -> Utc{\n        Utc\n    }","Real(LocalPath(\"src/offset/utc.rs\"))"],"<offset::utc::Utc as offset::TimeZone>::offset_from_utc_datetime":["fn offset_from_utc_datetime(&self, _utc: &NaiveDateTime) -> Utc{\n        Utc\n    }","Real(LocalPath(\"src/offset/utc.rs\"))"],"<offset::utc::Utc as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"Z\")\n    }","Real(LocalPath(\"src/offset/utc.rs\"))"],"<offset::utc::Utc as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"UTC\")\n    }","Real(LocalPath(\"src/offset/utc.rs\"))"],"<round::RoundingError as std::error::Error>::description":["#[allow(deprecated)]\nfn description(&self) -> &str{\n        \"error from rounding or truncating with DurationRound\"\n    }","Real(LocalPath(\"src/round.rs\"))"],"<round::RoundingError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        match *self {\n            RoundingError::DurationExceedsTimestamp => {\n                write!(f, \"duration in nanoseconds exceeds timestamp\")\n            }\n            RoundingError::DurationExceedsLimit => {\n                write!(f, \"duration exceeds num_nanoseconds limit\")\n            }\n            RoundingError::TimestampExceedsLimit => {\n                write!(f, \"timestamp exceeds num_nanoseconds limit\")\n            }\n        }\n    }","Real(LocalPath(\"src/round.rs\"))"],"<weekday::ParseWeekdayError as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        write!(f, \"ParseWeekdayError {{ .. }}\")\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"<weekday::ParseWeekdayError as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.write_fmt(format_args!(\"{:?}\", self))\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"<weekday::Weekday as num_traits::FromPrimitive>::from_i64":["#[inline]\nfn from_i64(n: i64) -> Option<Weekday>{\n        match n {\n            0 => Some(Weekday::Mon),\n            1 => Some(Weekday::Tue),\n            2 => Some(Weekday::Wed),\n            3 => Some(Weekday::Thu),\n            4 => Some(Weekday::Fri),\n            5 => Some(Weekday::Sat),\n            6 => Some(Weekday::Sun),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"<weekday::Weekday as num_traits::FromPrimitive>::from_u64":["#[inline]\nfn from_u64(n: u64) -> Option<Weekday>{\n        match n {\n            0 => Some(Weekday::Mon),\n            1 => Some(Weekday::Tue),\n            2 => Some(Weekday::Wed),\n            3 => Some(Weekday::Thu),\n            4 => Some(Weekday::Fri),\n            5 => Some(Weekday::Sat),\n            6 => Some(Weekday::Sun),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"<weekday::Weekday as std::convert::TryFrom<u8>>::try_from":["fn try_from(value: u8) -> Result<Self, Self::Error>{\n        match value {\n            0 => Ok(Weekday::Mon),\n            1 => Ok(Weekday::Tue),\n            2 => Ok(Weekday::Wed),\n            3 => Ok(Weekday::Thu),\n            4 => Ok(Weekday::Fri),\n            5 => Ok(Weekday::Sat),\n            6 => Ok(Weekday::Sun),\n            _ => Err(OutOfRange::new()),\n        }\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"<weekday::Weekday as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n        f.write_str(match *self {\n            Weekday::Mon => \"Mon\",\n            Weekday::Tue => \"Tue\",\n            Weekday::Wed => \"Wed\",\n            Weekday::Thu => \"Thu\",\n            Weekday::Fri => \"Fri\",\n            Weekday::Sat => \"Sat\",\n            Weekday::Sun => \"Sun\",\n        })\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"OutOfRange":["/// Out of range error type used in various converting APIs\npub struct OutOfRange {\n    _private: (),\n}","Real(LocalPath(\"src/lib.rs\"))"],"OutOfRange::new":["const fn new() -> OutOfRange{\n        OutOfRange { _private: () }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"date::Date":["/// ISO 8601 calendar date with time zone.\n///\n/// You almost certainly want to be using a [`NaiveDate`] instead of this type.\n///\n/// This type primarily exists to aid in the construction of DateTimes that\n/// have a timezone by way of the [`TimeZone`] datelike constructors (e.g.\n/// [`TimeZone::ymd`]).\n///\n/// This type should be considered ambiguous at best, due to the inherent lack\n/// of precision required for the time zone resolution.\n///\n/// There are some guarantees on the usage of `Date<Tz>`:\n///\n/// - If properly constructed via [`TimeZone::ymd`] and others without an error,\n///   the corresponding local date should exist for at least a moment.\n///   (It may still have a gap from the offset changes.)\n///\n/// - The `TimeZone` is free to assign *any* [`Offset`](crate::offset::Offset) to the\n///   local date, as long as that offset did occur in given day.\n///\n///   For example, if `2015-03-08T01:59-08:00` is followed by `2015-03-08T03:00-07:00`,\n///   it may produce either `2015-03-08-08:00` or `2015-03-08-07:00`\n///   but *not* `2015-03-08+00:00` and others.\n///\n/// - Once constructed as a full `DateTime`, [`DateTime::date`] and other associated\n///   methods should return those for the original `Date`. For example, if `dt =\n///   tz.ymd_opt(y,m,d).unwrap().hms(h,n,s)` were valid, `dt.date() == tz.ymd_opt(y,m,d).unwrap()`.\n///\n/// - The date is timezone-agnostic up to one day (i.e. practically always),\n///   so the local date and UTC date should be equal for most cases\n///   even though the raw calculation between `NaiveDate` and `Duration` may not.\n#[deprecated(since = \"0.4.23\", note = \"Use `NaiveDate` or `DateTime<Tz>` instead\")]\npub struct Date<Tz: TimeZone> {\n    date: NaiveDate,\n    offset: Tz::Offset,\n}","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::and_hms":["/// Makes a new `DateTime` from the current date, hour, minute and second.\n/// The offset in the current date is preserved.\n///\n/// Panics on invalid hour, minute and/or second.\n#[deprecated(since = \"0.4.23\", note = \"Use and_hms_opt() instead\")]\n#[inline]\n#[must_use]\npub fn and_hms(&self, hour: u32, min: u32, sec: u32) -> DateTime<Tz>{\n        self.and_hms_opt(hour, min, sec).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::and_hms_micro":["/// Makes a new `DateTime` from the current date, hour, minute, second and microsecond.\n/// The microsecond part can exceed 1,000,000 in order to represent the leap second.\n/// The offset in the current date is preserved.\n///\n/// Panics on invalid hour, minute, second and/or microsecond.\n#[deprecated(since = \"0.4.23\", note = \"Use and_hms_micro_opt() instead\")]\n#[inline]\n#[must_use]\npub fn and_hms_micro(&self, hour: u32, min: u32, sec: u32, micro: u32) -> DateTime<Tz>{\n        self.and_hms_micro_opt(hour, min, sec, micro).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::and_hms_micro_opt":["/// Makes a new `DateTime` from the current date, hour, minute, second and microsecond.\n/// The microsecond part can exceed 1,000,000 in order to represent the leap second.\n/// The offset in the current date is preserved.\n///\n/// Returns `None` on invalid hour, minute, second and/or microsecond.\n#[inline]\n#[must_use]\npub fn and_hms_micro_opt(\n        &self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        micro: u32,\n    ) -> Option<DateTime<Tz>>{\n        NaiveTime::from_hms_micro_opt(hour, min, sec, micro).and_then(|time| self.and_time(time))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::and_hms_milli":["/// Makes a new `DateTime` from the current date, hour, minute, second and millisecond.\n/// The millisecond part can exceed 1,000 in order to represent the leap second.\n/// The offset in the current date is preserved.\n///\n/// Panics on invalid hour, minute, second and/or millisecond.\n#[deprecated(since = \"0.4.23\", note = \"Use and_hms_milli_opt() instead\")]\n#[inline]\n#[must_use]\npub fn and_hms_milli(&self, hour: u32, min: u32, sec: u32, milli: u32) -> DateTime<Tz>{\n        self.and_hms_milli_opt(hour, min, sec, milli).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::and_hms_milli_opt":["/// Makes a new `DateTime` from the current date, hour, minute, second and millisecond.\n/// The millisecond part can exceed 1,000 in order to represent the leap second.\n/// The offset in the current date is preserved.\n///\n/// Returns `None` on invalid hour, minute, second and/or millisecond.\n#[inline]\n#[must_use]\npub fn and_hms_milli_opt(\n        &self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        milli: u32,\n    ) -> Option<DateTime<Tz>>{\n        NaiveTime::from_hms_milli_opt(hour, min, sec, milli).and_then(|time| self.and_time(time))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::and_hms_nano":["/// Makes a new `DateTime` from the current date, hour, minute, second and nanosecond.\n/// The nanosecond part can exceed 1,000,000,000 in order to represent the leap second.\n/// The offset in the current date is preserved.\n///\n/// Panics on invalid hour, minute, second and/or nanosecond.\n#[deprecated(since = \"0.4.23\", note = \"Use and_hms_nano_opt() instead\")]\n#[inline]\n#[must_use]\npub fn and_hms_nano(&self, hour: u32, min: u32, sec: u32, nano: u32) -> DateTime<Tz>{\n        self.and_hms_nano_opt(hour, min, sec, nano).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::and_hms_nano_opt":["/// Makes a new `DateTime` from the current date, hour, minute, second and nanosecond.\n/// The nanosecond part can exceed 1,000,000,000 in order to represent the leap second.\n/// The offset in the current date is preserved.\n///\n/// Returns `None` on invalid hour, minute, second and/or nanosecond.\n#[inline]\n#[must_use]\npub fn and_hms_nano_opt(\n        &self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        nano: u32,\n    ) -> Option<DateTime<Tz>>{\n        NaiveTime::from_hms_nano_opt(hour, min, sec, nano).and_then(|time| self.and_time(time))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::and_hms_opt":["/// Makes a new `DateTime` from the current date, hour, minute and second.\n/// The offset in the current date is preserved.\n///\n/// Returns `None` on invalid hour, minute and/or second.\n#[inline]\n#[must_use]\npub fn and_hms_opt(&self, hour: u32, min: u32, sec: u32) -> Option<DateTime<Tz>>{\n        NaiveTime::from_hms_opt(hour, min, sec).and_then(|time| self.and_time(time))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::and_time":["/// Makes a new `DateTime` from the current date and given `NaiveTime`.\n/// The offset in the current date is preserved.\n///\n/// Panics on invalid datetime.\n#[inline]\n#[must_use]\npub fn and_time(&self, time: NaiveTime) -> Option<DateTime<Tz>>{\n        let localdt = self.naive_local().and_time(time);\n        self.timezone().from_local_datetime(&localdt).single()\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::checked_add_signed":["/// Adds given `Duration` to the current date.\n///\n/// Returns `None` when it will result in overflow.\n#[inline]\n#[must_use]\npub fn checked_add_signed(self, rhs: OldDuration) -> Option<Date<Tz>>{\n        let date = self.date.checked_add_signed(rhs)?;\n        Some(Date { date, offset: self.offset })\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::checked_sub_signed":["/// Subtracts given `Duration` from the current date.\n///\n/// Returns `None` when it will result in overflow.\n#[inline]\n#[must_use]\npub fn checked_sub_signed(self, rhs: OldDuration) -> Option<Date<Tz>>{\n        let date = self.date.checked_sub_signed(rhs)?;\n        Some(Date { date, offset: self.offset })\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::format":["/// Formats the date with the specified format string.\n/// See the [`crate::format::strftime`] module\n/// on the supported escape sequences.\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[inline]\n#[must_use]\npub fn format<'a>(&self, fmt: &'a str) -> DelayedFormat<StrftimeItems<'a>>{\n        self.format_with_items(StrftimeItems::new(fmt))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::format_with_items":["/// Formats the date with the specified formatting items.\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[inline]\n#[must_use]\npub fn format_with_items<'a, I, B>(&self, items: I) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,{\n        DelayedFormat::new_with_offset(Some(self.naive_local()), None, &self.offset, items)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::from_utc":["/// Makes a new `Date` with given *UTC* date and offset.\n/// The local date should be constructed via the `TimeZone` trait.\n#[inline]\n#[must_use]\npub fn from_utc(date: NaiveDate, offset: Tz::Offset) -> Date<Tz>{\n        Date { date, offset }\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::naive_local":["/// Returns a view to the naive local date.\n///\n/// This is technically the same as [`naive_utc`](#method.naive_utc)\n/// because the offset is restricted to never exceed one day,\n/// but provided for the consistency.\n#[inline]\n#[must_use]\npub fn naive_local(&self) -> NaiveDate{\n        self.date\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::naive_utc":["/// Returns a view to the naive UTC date.\n#[inline]\n#[must_use]\npub fn naive_utc(&self) -> NaiveDate{\n        self.date\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::offset":["/// Retrieves an associated offset from UTC.\n#[inline]\n#[must_use]\npub fn offset(&self) -> &Tz::Offset{\n        &self.offset\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::pred":["/// Makes a new `Date` for the prior date.\n///\n/// Panics when `self` is the first representable date.\n#[deprecated(since = \"0.4.23\", note = \"Use pred_opt() instead\")]\n#[inline]\n#[must_use]\npub fn pred(&self) -> Date<Tz>{\n        self.pred_opt().expect(\"out of bound\")\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::pred_opt":["/// Makes a new `Date` for the prior date.\n///\n/// Returns `None` when `self` is the first representable date.\n#[inline]\n#[must_use]\npub fn pred_opt(&self) -> Option<Date<Tz>>{\n        self.date.pred_opt().map(|date| Date::from_utc(date, self.offset.clone()))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::signed_duration_since":["/// Subtracts another `Date` from the current date.\n/// Returns a `Duration` of integral numbers.\n///\n/// This does not overflow or underflow at all,\n/// as all possible output fits in the range of `Duration`.\n#[inline]\n#[must_use]\npub fn signed_duration_since<Tz2: TimeZone>(self, rhs: Date<Tz2>) -> OldDuration{\n        self.date.signed_duration_since(rhs.date)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::succ":["/// Makes a new `Date` for the next date.\n///\n/// Panics when `self` is the last representable date.\n#[deprecated(since = \"0.4.23\", note = \"Use succ_opt() instead\")]\n#[inline]\n#[must_use]\npub fn succ(&self) -> Date<Tz>{\n        self.succ_opt().expect(\"out of bound\")\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::succ_opt":["/// Makes a new `Date` for the next date.\n///\n/// Returns `None` when `self` is the last representable date.\n#[inline]\n#[must_use]\npub fn succ_opt(&self) -> Option<Date<Tz>>{\n        self.date.succ_opt().map(|date| Date::from_utc(date, self.offset.clone()))\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::timezone":["/// Retrieves an associated time zone.\n#[inline]\n#[must_use]\npub fn timezone(&self) -> Tz{\n        TimeZone::from_offset(&self.offset)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::with_timezone":["/// Changes the associated time zone.\n/// This does not change the actual `Date` (but will change the string representation).\n#[inline]\n#[must_use]\npub fn with_timezone<Tz2: TimeZone>(&self, tz: &Tz2) -> Date<Tz2>{\n        tz.from_utc_date(&self.date)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::Date::<Tz>::years_since":["/// Returns the number of whole years from the given `base` until `self`.\n#[must_use]\npub fn years_since(&self, base: Self) -> Option<u32>{\n        self.date.years_since(base.date)\n    }","Real(LocalPath(\"src/date.rs\"))"],"date::map_local":["/// Maps the local date to other date with given conversion function.\nfn map_local<Tz: TimeZone, F>(d: &Date<Tz>, mut f: F) -> Option<Date<Tz>>\nwhere\n    F: FnMut(NaiveDate) -> Option<NaiveDate>,{\n    f(d.naive_local()).and_then(|date| d.timezone().from_local_date(&date).single())\n}","Real(LocalPath(\"src/date.rs\"))"],"datetime::<impl std::convert::From<datetime::DateTime<Tz>> for std::time::SystemTime>::from":["fn from(dt: DateTime<Tz>) -> SystemTime{\n        use std::time::Duration;\n\n        let sec = dt.timestamp();\n        let nsec = dt.timestamp_subsec_nanos();\n        if sec < 0 {\n            // unlikely but should be handled\n            UNIX_EPOCH - Duration::new(-sec as u64, 0) + Duration::new(0, nsec)\n        } else {\n            UNIX_EPOCH + Duration::new(sec as u64, nsec)\n        }\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime":["/// ISO 8601 combined date and time with time zone.\n///\n/// There are some constructors implemented here (the `from_*` methods), but\n/// the general-purpose constructors are all via the methods on the\n/// [`TimeZone`](./offset/trait.TimeZone.html) implementations.\npub struct DateTime<Tz: TimeZone> {\n    datetime: NaiveDateTime,\n    offset: Tz::Offset,\n}","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::checked_add_days":["/// Add a duration in [`Days`] to the date part of the `DateTime`\n///\n/// Returns `None` if the resulting date would be out of range.\n#[must_use]\npub fn checked_add_days(self, days: Days) -> Option<Self>{\n        self.naive_local()\n            .checked_add_days(days)?\n            .and_local_timezone(TimeZone::from_offset(&self.offset))\n            .single()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::checked_add_months":["/// Adds given `Months` to the current date and time.\n///\n/// Returns `None` when it will result in overflow, or if the\n/// local time is not valid on the newly calculated date.\n///\n/// See [`NaiveDate::checked_add_months`] for more details on behavior\n#[must_use]\npub fn checked_add_months(self, rhs: Months) -> Option<DateTime<Tz>>{\n        self.naive_local()\n            .checked_add_months(rhs)?\n            .and_local_timezone(Tz::from_offset(&self.offset))\n            .single()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::checked_add_signed":["/// Adds given `Duration` to the current date and time.\n///\n/// Returns `None` when it will result in overflow.\n#[inline]\n#[must_use]\npub fn checked_add_signed(self, rhs: OldDuration) -> Option<DateTime<Tz>>{\n        let datetime = self.datetime.checked_add_signed(rhs)?;\n        let tz = self.timezone();\n        Some(tz.from_utc_datetime(&datetime))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::checked_sub_days":["/// Subtract a duration in [`Days`] from the date part of the `DateTime`\n///\n/// Returns `None` if the resulting date would be out of range.\n#[must_use]\npub fn checked_sub_days(self, days: Days) -> Option<Self>{\n        self.naive_local()\n            .checked_sub_days(days)?\n            .and_local_timezone(TimeZone::from_offset(&self.offset))\n            .single()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::checked_sub_months":["/// Subtracts given `Months` from the current date and time.\n///\n/// Returns `None` when it will result in overflow, or if the\n/// local time is not valid on the newly calculated date.\n///\n/// See [`NaiveDate::checked_sub_months`] for more details on behavior\n#[must_use]\npub fn checked_sub_months(self, rhs: Months) -> Option<DateTime<Tz>>{\n        self.naive_local()\n            .checked_sub_months(rhs)?\n            .and_local_timezone(Tz::from_offset(&self.offset))\n            .single()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::checked_sub_signed":["/// Subtracts given `Duration` from the current date and time.\n///\n/// Returns `None` when it will result in overflow.\n#[inline]\n#[must_use]\npub fn checked_sub_signed(self, rhs: OldDuration) -> Option<DateTime<Tz>>{\n        let datetime = self.datetime.checked_sub_signed(rhs)?;\n        let tz = self.timezone();\n        Some(tz.from_utc_datetime(&datetime))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::date":["/// Retrieves a date component\n///\n/// Unless you are immediately planning on turning this into a `DateTime`\n/// with the same Timezone you should use the\n/// [`date_naive`](DateTime::date_naive) method.\n#[inline]\n#[deprecated(since = \"0.4.23\", note = \"Use `date_naive()` instead\")]\n#[allow(deprecated)]\n#[must_use]\npub fn date(&self) -> Date<Tz>{\n        Date::from_utc(self.naive_local().date(), self.offset.clone())\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::date_naive":["/// Retrieves the Date without an associated timezone\n///\n/// [`NaiveDate`] is a more well-defined type, and has more traits implemented on it,\n/// so should be preferred to [`Date`] any time you truly want to operate on Dates.\n///\n/// ```\n/// use chrono::prelude::*;\n///\n/// let date: DateTime<Utc> = Utc.with_ymd_and_hms(2020, 1, 1, 0, 0, 0).unwrap();\n/// let other: DateTime<FixedOffset> = FixedOffset::east_opt(23).unwrap().with_ymd_and_hms(2020, 1, 1, 0, 0, 0).unwrap();\n/// assert_eq!(date.date_naive(), other.date_naive());\n/// ```\n#[inline]\n#[must_use]\npub fn date_naive(&self) -> NaiveDate{\n        let local = self.naive_local();\n        NaiveDate::from_ymd_opt(local.year(), local.month(), local.day()).unwrap()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::fixed_offset":["/// Fix the offset from UTC to its current value, dropping the associated timezone information.\n/// This it useful for converting a generic `DateTime<Tz: Timezone>` to `DateTime<FixedOffset>`.\n#[inline]\n#[must_use]\npub fn fixed_offset(&self) -> DateTime<FixedOffset>{\n        self.with_timezone(&self.offset().fix())\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::format":["/// Formats the combined date and time per the specified format string.\n///\n/// See the [`crate::format::strftime`] module for the supported escape sequences.\n///\n/// # Example\n/// ```rust\n/// use chrono::prelude::*;\n///\n/// let date_time: DateTime<Utc> = Utc.with_ymd_and_hms(2017, 04, 02, 12, 50, 32).unwrap();\n/// let formatted = format!(\"{}\", date_time.format(\"%d/%m/%Y %H:%M\"));\n/// assert_eq!(formatted, \"02/04/2017 12:50\");\n/// ```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[inline]\n#[must_use]\npub fn format<'a>(&self, fmt: &'a str) -> DelayedFormat<StrftimeItems<'a>>{\n        self.format_with_items(StrftimeItems::new(fmt))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::format_with_items":["/// Formats the combined date and time with the specified formatting items.\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[inline]\n#[must_use]\npub fn format_with_items<'a, I, B>(&self, items: I) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,{\n        let local = self.naive_local();\n        DelayedFormat::new_with_offset(Some(local.date()), Some(local.time()), &self.offset, items)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::from_local":["/// Makes a new `DateTime` with given **local** datetime and offset that\n/// presents local timezone.\n///\n/// # Example\n///\n/// ```\n/// use chrono::DateTime;\n/// use chrono::naive::NaiveDate;\n/// use chrono::offset::{Utc, FixedOffset};\n///\n/// let naivedatetime_utc = NaiveDate::from_ymd_opt(2000, 1, 12).unwrap().and_hms_opt(2, 0, 0).unwrap();\n/// let datetime_utc = DateTime::<Utc>::from_utc(naivedatetime_utc, Utc);\n///\n/// let timezone_east = FixedOffset::east_opt(8 * 60 * 60).unwrap();\n/// let naivedatetime_east = NaiveDate::from_ymd_opt(2000, 1, 12).unwrap().and_hms_opt(10, 0, 0).unwrap();\n/// let datetime_east = DateTime::<FixedOffset>::from_local(naivedatetime_east, timezone_east);\n///\n/// let timezone_west = FixedOffset::west_opt(7 * 60 * 60).unwrap();\n/// let naivedatetime_west = NaiveDate::from_ymd_opt(2000, 1, 11).unwrap().and_hms_opt(19, 0, 0).unwrap();\n/// let datetime_west = DateTime::<FixedOffset>::from_local(naivedatetime_west, timezone_west);\n/// assert_eq!(datetime_east, datetime_utc.with_timezone(&timezone_east));\n/// assert_eq!(datetime_west, datetime_utc.with_timezone(&timezone_west));\n/// ```\n#[inline]\n#[must_use]\npub fn from_local(datetime: NaiveDateTime, offset: Tz::Offset) -> DateTime<Tz>{\n        let datetime_utc = datetime - offset.fix();\n\n        DateTime { datetime: datetime_utc, offset }\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::from_utc":["/// Makes a new `DateTime` with given *UTC* datetime and offset.\n/// The local datetime should be constructed via the `TimeZone` trait.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{DateTime, TimeZone, NaiveDateTime, Utc};\n///\n/// let dt = DateTime::<Utc>::from_utc(NaiveDateTime::from_timestamp_opt(61, 0).unwrap(), Utc);\n/// assert_eq!(Utc.timestamp_opt(61, 0).unwrap(), dt);\n/// ```\n#[inline]\n#[must_use]\npub fn from_utc(datetime: NaiveDateTime, offset: Tz::Offset) -> DateTime<Tz>{\n        DateTime { datetime, offset }\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::naive_local":["/// Returns a view to the naive local datetime.\n#[inline]\n#[must_use]\npub fn naive_local(&self) -> NaiveDateTime{\n        self.datetime + self.offset.fix()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::naive_utc":["/// Returns a view to the naive UTC datetime.\n#[inline]\n#[must_use]\npub fn naive_utc(&self) -> NaiveDateTime{\n        self.datetime\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::offset":["/// Retrieves an associated offset from UTC.\n#[inline]\n#[must_use]\npub fn offset(&self) -> &Tz::Offset{\n        &self.offset\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::signed_duration_since":["/// Subtracts another `DateTime` from the current date and time.\n/// This does not overflow or underflow at all.\n#[inline]\n#[must_use]\npub fn signed_duration_since<Tz2: TimeZone>(self, rhs: DateTime<Tz2>) -> OldDuration{\n        self.datetime.signed_duration_since(rhs.datetime)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::time":["/// Retrieves a time component.\n/// Unlike `date`, this is not associated to the time zone.\n#[inline]\n#[must_use]\npub fn time(&self) -> NaiveTime{\n        self.datetime.time() + self.offset.fix()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::timestamp":["/// Returns the number of non-leap seconds since January 1, 1970 0:00:00 UTC\n/// (aka \"UNIX timestamp\").\n#[inline]\n#[must_use]\npub fn timestamp(&self) -> i64{\n        self.datetime.timestamp()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::timestamp_micros":["/// Returns the number of non-leap-microseconds since January 1, 1970 UTC\n///\n/// Note that this does reduce the number of years that can be represented\n/// from ~584 Billion to ~584 Thousand. (If this is a problem, please file\n/// an issue to let me know what domain needs microsecond precision over\n/// millennia, I'm curious.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Utc, NaiveDate};\n///\n/// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_micro_opt(0, 0, 1, 444).unwrap().and_local_timezone(Utc).unwrap();\n/// assert_eq!(dt.timestamp_micros(), 1_000_444);\n///\n/// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_micro_opt(1, 46, 40, 555).unwrap().and_local_timezone(Utc).unwrap();\n/// assert_eq!(dt.timestamp_micros(), 1_000_000_000_000_555);\n/// ```\n#[inline]\n#[must_use]\npub fn timestamp_micros(&self) -> i64{\n        self.datetime.timestamp_micros()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::timestamp_millis":["/// Returns the number of non-leap-milliseconds since January 1, 1970 UTC\n///\n/// Note that this does reduce the number of years that can be represented\n/// from ~584 Billion to ~584 Million. (If this is a problem, please file\n/// an issue to let me know what domain needs millisecond precision over\n/// billions of years, I'm curious.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Utc, NaiveDate};\n///\n/// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_milli_opt(0, 0, 1, 444).unwrap().and_local_timezone(Utc).unwrap();\n/// assert_eq!(dt.timestamp_millis(), 1_444);\n///\n/// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_milli_opt(1, 46, 40, 555).unwrap().and_local_timezone(Utc).unwrap();\n/// assert_eq!(dt.timestamp_millis(), 1_000_000_000_555);\n/// ```\n#[inline]\n#[must_use]\npub fn timestamp_millis(&self) -> i64{\n        self.datetime.timestamp_millis()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::timestamp_nanos":["/// Returns the number of non-leap-nanoseconds since January 1, 1970 UTC\n///\n/// Note that this does reduce the number of years that can be represented\n/// from ~584 Billion to ~584. (If this is a problem, please file\n/// an issue to let me know what domain needs nanosecond precision over\n/// millennia, I'm curious.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Utc, NaiveDate};\n///\n/// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_nano_opt(0, 0, 1, 444).unwrap().and_local_timezone(Utc).unwrap();\n/// assert_eq!(dt.timestamp_nanos(), 1_000_000_444);\n///\n/// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_nano_opt(1, 46, 40, 555).unwrap().and_local_timezone(Utc).unwrap();\n/// assert_eq!(dt.timestamp_nanos(), 1_000_000_000_000_000_555);\n/// ```\n#[inline]\n#[must_use]\npub fn timestamp_nanos(&self) -> i64{\n        self.datetime.timestamp_nanos()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::timestamp_subsec_micros":["/// Returns the number of microseconds since the last second boundary\n///\n/// warning: in event of a leap second, this may exceed 999_999\n///\n/// note: this is not the number of microseconds since January 1, 1970 0:00:00 UTC\n#[inline]\n#[must_use]\npub fn timestamp_subsec_micros(&self) -> u32{\n        self.datetime.timestamp_subsec_micros()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::timestamp_subsec_millis":["/// Returns the number of milliseconds since the last second boundary\n///\n/// warning: in event of a leap second, this may exceed 999\n///\n/// note: this is not the number of milliseconds since January 1, 1970 0:00:00 UTC\n#[inline]\n#[must_use]\npub fn timestamp_subsec_millis(&self) -> u32{\n        self.datetime.timestamp_subsec_millis()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::timestamp_subsec_nanos":["/// Returns the number of nanoseconds since the last second boundary\n///\n/// warning: in event of a leap second, this may exceed 999_999_999\n///\n/// note: this is not the number of nanoseconds since January 1, 1970 0:00:00 UTC\n#[inline]\n#[must_use]\npub fn timestamp_subsec_nanos(&self) -> u32{\n        self.datetime.timestamp_subsec_nanos()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::timezone":["/// Retrieves an associated time zone.\n#[inline]\n#[must_use]\npub fn timezone(&self) -> Tz{\n        TimeZone::from_offset(&self.offset)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::to_rfc2822":["/// Returns an RFC 2822 date and time string such as `Tue, 1 Jul 2003 10:52:37 +0200`.\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[must_use]\npub fn to_rfc2822(&self) -> String{\n        let mut result = String::with_capacity(32);\n        crate::format::write_rfc2822(&mut result, self.naive_local(), self.offset.fix())\n            .expect(\"writing rfc2822 datetime to string should never fail\");\n        result\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::to_rfc3339":["/// Returns an RFC 3339 and ISO 8601 date and time string such as `1996-12-19T16:39:57-08:00`.\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[must_use]\npub fn to_rfc3339(&self) -> String{\n        let mut result = String::with_capacity(32);\n        crate::format::write_rfc3339(&mut result, self.naive_local(), self.offset.fix())\n            .expect(\"writing rfc3339 datetime to string should never fail\");\n        result\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::to_rfc3339_opts":["/// Return an RFC 3339 and ISO 8601 date and time string with subseconds\n/// formatted as per `SecondsFormat`.\n///\n/// If `use_z` is true and the timezone is UTC (offset 0), uses `Z` as\n/// per [`Fixed::TimezoneOffsetColonZ`]. If `use_z` is false, uses\n/// [`Fixed::TimezoneOffsetColon`]\n///\n/// # Examples\n///\n/// ```rust\n/// # use chrono::{FixedOffset, SecondsFormat, TimeZone, Utc, NaiveDate};\n/// let dt = NaiveDate::from_ymd_opt(2018, 1, 26).unwrap().and_hms_micro_opt(18, 30, 9, 453_829).unwrap().and_local_timezone(Utc).unwrap();\n/// assert_eq!(dt.to_rfc3339_opts(SecondsFormat::Millis, false),\n///            \"2018-01-26T18:30:09.453+00:00\");\n/// assert_eq!(dt.to_rfc3339_opts(SecondsFormat::Millis, true),\n///            \"2018-01-26T18:30:09.453Z\");\n/// assert_eq!(dt.to_rfc3339_opts(SecondsFormat::Secs, true),\n///            \"2018-01-26T18:30:09Z\");\n///\n/// let pst = FixedOffset::east_opt(8 * 60 * 60).unwrap();\n/// let dt = pst.from_local_datetime(&NaiveDate::from_ymd_opt(2018, 1, 26).unwrap().and_hms_micro_opt(10, 30, 9, 453_829).unwrap()).unwrap();\n/// assert_eq!(dt.to_rfc3339_opts(SecondsFormat::Secs, true),\n///            \"2018-01-26T10:30:09+08:00\");\n/// ```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[must_use]\npub fn to_rfc3339_opts(&self, secform: SecondsFormat, use_z: bool) -> String{\n        use crate::format::Numeric::*;\n        use crate::format::Pad::Zero;\n        use crate::SecondsFormat::*;\n\n        debug_assert!(secform != __NonExhaustive, \"Do not use __NonExhaustive!\");\n\n        const PREFIX: &[Item<'static>] = &[\n            Item::Numeric(Year, Zero),\n            Item::Literal(\"-\"),\n            Item::Numeric(Month, Zero),\n            Item::Literal(\"-\"),\n            Item::Numeric(Day, Zero),\n            Item::Literal(\"T\"),\n            Item::Numeric(Hour, Zero),\n            Item::Literal(\":\"),\n            Item::Numeric(Minute, Zero),\n            Item::Literal(\":\"),\n            Item::Numeric(Second, Zero),\n        ];\n\n        let ssitem = match secform {\n            Secs => None,\n            Millis => Some(Item::Fixed(Fixed::Nanosecond3)),\n            Micros => Some(Item::Fixed(Fixed::Nanosecond6)),\n            Nanos => Some(Item::Fixed(Fixed::Nanosecond9)),\n            AutoSi => Some(Item::Fixed(Fixed::Nanosecond)),\n            __NonExhaustive => unreachable!(),\n        };\n\n        let tzitem = Item::Fixed(if use_z {\n            Fixed::TimezoneOffsetColonZ\n        } else {\n            Fixed::TimezoneOffsetColon\n        });\n\n        match ssitem {\n            None => self.format_with_items(PREFIX.iter().chain([tzitem].iter())).to_string(),\n            Some(s) => self.format_with_items(PREFIX.iter().chain([s, tzitem].iter())).to_string(),\n        }\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::with_timezone":["/// Changes the associated time zone.\n/// The returned `DateTime` references the same instant of time from the perspective of the provided time zone.\n#[inline]\n#[must_use]\npub fn with_timezone<Tz2: TimeZone>(&self, tz: &Tz2) -> DateTime<Tz2>{\n        tz.from_utc_datetime(&self.datetime)\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<Tz>::years_since":["/// Retrieve the elapsed years from now to the given [`DateTime`].\n#[must_use]\npub fn years_since(&self, base: Self) -> Option<u32>{\n        let mut years = self.year() - base.year();\n        let earlier_time =\n            (self.month(), self.day(), self.time()) < (base.month(), base.day(), base.time());\n\n        years -= match earlier_time {\n            true => 1,\n            false => 0,\n        };\n\n        match years >= 0 {\n            true => Some(years as u32),\n            false => None,\n        }\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<offset::fixed::FixedOffset>::parse_and_remainder":["/// Parses a string from a user-specified format into a `DateTime<FixedOffset>` value, and a\n/// slice with the remaining portion of the string.\n///\n/// Note that this method *requires a timezone* in the input string. See\n/// [`NaiveDateTime::parse_and_remainder`] for a version that does not\n/// require a timezone in `s`. The returned [`DateTime`] value will have a [`FixedOffset`]\n/// reflecting the parsed timezone.\n///\n/// See the [`format::strftime` module](./format/strftime/index.html) for supported format\n/// sequences.\n///\n/// Similar to [`parse_from_str`](#method.parse_from_str).\n///\n/// # Example\n///\n/// ```rust\n/// # use chrono::{DateTime, FixedOffset, TimeZone};\n/// let (datetime, remainder) = DateTime::parse_and_remainder(\n///     \"2015-02-18 23:16:09 +0200 trailing text\", \"%Y-%m-%d %H:%M:%S %z\").unwrap();\n/// assert_eq!(\n///     datetime,\n///     FixedOffset::east_opt(2*3600).unwrap().with_ymd_and_hms(2015, 2, 18, 23, 16, 9).unwrap()\n/// );\n/// assert_eq!(remainder, \" trailing text\");\n/// ```\npub fn parse_and_remainder<'a>(\n        s: &'a str,\n        fmt: &str,\n    ) -> ParseResult<(DateTime<FixedOffset>, &'a str)>{\n        let mut parsed = Parsed::new();\n        let remainder = parse_and_remainder(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_datetime().map(|d| (d, remainder))\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_rfc2822":["/// Parses an RFC 2822 date-and-time string into a `DateTime<FixedOffset>` value.\n///\n/// This parses valid RFC 2822 datetime strings (such as `Tue, 1 Jul 2003 10:52:37 +0200`)\n/// and returns a new [`DateTime`] instance with the parsed timezone as the [`FixedOffset`].\n///\n/// RFC 2822 is the internet message standard that specifies the representation of times in HTTP\n/// and email headers.\n///\n/// The RFC 2822 standard allows arbitrary intermixed whitespace.\n/// See [RFC 2822 Appendix A.5]\n///\n/// ```\n/// # use chrono::{DateTime, FixedOffset, TimeZone};\n/// assert_eq!(\n///     DateTime::parse_from_rfc2822(\"Wed, 18 Feb 2015 23:16:09 GMT\").unwrap(),\n///     FixedOffset::east_opt(0).unwrap().with_ymd_and_hms(2015, 2, 18, 23, 16, 9).unwrap()\n/// );\n/// ```\n///\n/// [RFC 2822 Appendix A.5]: https://www.rfc-editor.org/rfc/rfc2822#appendix-A.5\npub fn parse_from_rfc2822(s: &str) -> ParseResult<DateTime<FixedOffset>>{\n        const ITEMS: &[Item<'static>] = &[Item::Fixed(Fixed::RFC2822)];\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, ITEMS.iter())?;\n        parsed.to_datetime()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_rfc3339":["/// Parses an RFC 3339 date-and-time string into a `DateTime<FixedOffset>` value.\n///\n/// Parses all valid RFC 3339 values (as well as the subset of valid ISO 8601 values that are\n/// also valid RFC 3339 date-and-time values) and returns a new [`DateTime`] with a\n/// [`FixedOffset`] corresponding to the parsed timezone. While RFC 3339 values come in a wide\n/// variety of shapes and sizes, `1996-12-19T16:39:57-08:00` is an example of the most commonly\n/// encountered variety of RFC 3339 formats.\n///\n/// Why isn't this named `parse_from_iso8601`? That's because ISO 8601 allows representing\n/// values in a wide range of formats, only some of which represent actual date-and-time\n/// instances (rather than periods, ranges, dates, or times). Some valid ISO 8601 values are\n/// also simultaneously valid RFC 3339 values, but not all RFC 3339 values are valid ISO 8601\n/// values (or the other way around).\npub fn parse_from_rfc3339(s: &str) -> ParseResult<DateTime<FixedOffset>>{\n        const ITEMS: &[Item<'static>] = &[Item::Fixed(Fixed::RFC3339)];\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, ITEMS.iter())?;\n        parsed.to_datetime()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_str":["/// Parses a string from a user-specified format into a `DateTime<FixedOffset>` value.\n///\n/// Note that this method *requires a timezone* in the input string. See\n/// [`NaiveDateTime::parse_from_str`](./naive/struct.NaiveDateTime.html#method.parse_from_str)\n/// for a version that does not require a timezone in the to-be-parsed str. The returned\n/// [`DateTime`] value will have a [`FixedOffset`] reflecting the parsed timezone.\n///\n/// See the [`format::strftime` module](./format/strftime/index.html) for supported format\n/// sequences.\n///\n/// # Example\n///\n/// ```rust\n/// use chrono::{DateTime, FixedOffset, TimeZone, NaiveDate};\n///\n/// let dt = DateTime::parse_from_str(\n///     \"1983 Apr 13 12:09:14.274 +0000\", \"%Y %b %d %H:%M:%S%.3f %z\");\n/// assert_eq!(dt, Ok(FixedOffset::east_opt(0).unwrap().from_local_datetime(&NaiveDate::from_ymd_opt(1983, 4, 13).unwrap().and_hms_milli_opt(12, 9, 14, 274).unwrap()).unwrap()));\n/// ```\npub fn parse_from_str(s: &str, fmt: &str) -> ParseResult<DateTime<FixedOffset>>{\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_datetime()\n    }","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::SecondsFormat":["/// Specific formatting options for seconds. This may be extended in the\n/// future, so exhaustive matching in external code is not recommended.\n///\n/// See the `TimeZone::to_rfc3339_opts` function for usage.\npub enum SecondsFormat {\n    /// Format whole seconds only, with no decimal point nor subseconds.\n    Secs,\n\n    /// Use fixed 3 subsecond digits. This corresponds to\n    /// [Fixed::Nanosecond3](format/enum.Fixed.html#variant.Nanosecond3).\n    Millis,\n\n    /// Use fixed 6 subsecond digits. This corresponds to\n    /// [Fixed::Nanosecond6](format/enum.Fixed.html#variant.Nanosecond6).\n    Micros,\n\n    /// Use fixed 9 subsecond digits. This corresponds to\n    /// [Fixed::Nanosecond9](format/enum.Fixed.html#variant.Nanosecond9).\n    Nanos,\n\n    /// Automatically select one of `Secs`, `Millis`, `Micros`, or `Nanos` to\n    /// display all available non-zero sub-second digits.  This corresponds to\n    /// [Fixed::Nanosecond](format/enum.Fixed.html#variant.Nanosecond).\n    AutoSi,\n\n    // Do not match against this.\n    #[doc(hidden)]\n    __NonExhaustive,\n}","Real(LocalPath(\"src/datetime/mod.rs\"))"],"datetime::map_local":["/// Maps the local datetime to other datetime with given conversion function.\nfn map_local<Tz: TimeZone, F>(dt: &DateTime<Tz>, mut f: F) -> Option<DateTime<Tz>>\nwhere\n    F: FnMut(NaiveDateTime) -> Option<NaiveDateTime>,{\n    f(dt.naive_local()).and_then(|datetime| dt.timezone().from_local_datetime(&datetime).single())\n}","Real(LocalPath(\"src/datetime/mod.rs\"))"],"format::<impl std::str::FromStr for month::Month>::from_str":["fn from_str(s: &str) -> Result<Self, Self::Err>{\n        if let Ok((\"\", w)) = scan::short_or_long_month0(s) {\n            match w {\n                0 => Ok(Month::January),\n                1 => Ok(Month::February),\n                2 => Ok(Month::March),\n                3 => Ok(Month::April),\n                4 => Ok(Month::May),\n                5 => Ok(Month::June),\n                6 => Ok(Month::July),\n                7 => Ok(Month::August),\n                8 => Ok(Month::September),\n                9 => Ok(Month::October),\n                10 => Ok(Month::November),\n                11 => Ok(Month::December),\n                _ => Err(ParseMonthError { _dummy: () }),\n            }\n        } else {\n            Err(ParseMonthError { _dummy: () })\n        }\n    }","Real(LocalPath(\"src/format/mod.rs\"))"],"format::<impl std::str::FromStr for weekday::Weekday>::from_str":["fn from_str(s: &str) -> Result<Self, Self::Err>{\n        if let Ok((\"\", w)) = scan::short_or_long_weekday(s) {\n            Ok(w)\n        } else {\n            Err(ParseWeekdayError { _dummy: () })\n        }\n    }","Real(LocalPath(\"src/format/mod.rs\"))"],"format::Colons":["#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\nenum Colons {\n    None,\n    Single,\n    Double,\n    Triple,\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::DelayedFormat":["/// A *temporary* object which can be used as an argument to `format!` or others.\n/// This is normally constructed via `format` methods of each date and time type.\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub struct DelayedFormat<I> {\n    /// The date view, if any.\n    date: Option<NaiveDate>,\n    /// The time view, if any.\n    time: Option<NaiveTime>,\n    /// The name and local-to-UTC difference for the offset (timezone), if any.\n    off: Option<(String, FixedOffset)>,\n    /// An iterator returning formatting items.\n    items: I,\n    /// Locale used for text.\n    // TODO: Only used with the locale feature. We should make this property\n    // only present when the feature is enabled.\n    #[cfg(feature = \"unstable-locales\")]\n    locale: Option<Locale>,\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::DelayedFormat::<I>::new":["/// Makes a new `DelayedFormat` value out of local date and time.\n#[must_use]\npub fn new(date: Option<NaiveDate>, time: Option<NaiveTime>, items: I) -> DelayedFormat<I>{\n        DelayedFormat {\n            date,\n            time,\n            off: None,\n            items,\n            #[cfg(feature = \"unstable-locales\")]\n            locale: None,\n        }\n    }","Real(LocalPath(\"src/format/mod.rs\"))"],"format::DelayedFormat::<I>::new_with_offset":["/// Makes a new `DelayedFormat` value out of local date and time and UTC offset.\n#[must_use]\npub fn new_with_offset<Off>(\n        date: Option<NaiveDate>,\n        time: Option<NaiveTime>,\n        offset: &Off,\n        items: I,\n    ) -> DelayedFormat<I>\n    where\n        Off: Offset + fmt::Display,{\n        let name_and_diff = (offset.to_string(), offset.fix());\n        DelayedFormat {\n            date,\n            time,\n            off: Some(name_and_diff),\n            items,\n            #[cfg(feature = \"unstable-locales\")]\n            locale: None,\n        }\n    }","Real(LocalPath(\"src/format/mod.rs\"))"],"format::Fixed":["/// Fixed-format item types.\n///\n/// They have their own rules of formatting and parsing.\n/// Otherwise noted, they print in the specified cases but parse case-insensitively.\npub enum Fixed {\n    /// Abbreviated month names.\n    ///\n    /// Prints a three-letter-long name in the title case, reads the same name in any case.\n    ShortMonthName,\n    /// Full month names.\n    ///\n    /// Prints a full name in the title case, reads either a short or full name in any case.\n    LongMonthName,\n    /// Abbreviated day of the week names.\n    ///\n    /// Prints a three-letter-long name in the title case, reads the same name in any case.\n    ShortWeekdayName,\n    /// Full day of the week names.\n    ///\n    /// Prints a full name in the title case, reads either a short or full name in any case.\n    LongWeekdayName,\n    /// AM/PM.\n    ///\n    /// Prints in lower case, reads in any case.\n    LowerAmPm,\n    /// AM/PM.\n    ///\n    /// Prints in upper case, reads in any case.\n    UpperAmPm,\n    /// An optional dot plus one or more digits for left-aligned nanoseconds.\n    /// May print nothing, 3, 6 or 9 digits according to the available accuracy.\n    /// See also [`Numeric::Nanosecond`](./enum.Numeric.html#variant.Nanosecond).\n    Nanosecond,\n    /// Same as [`Nanosecond`](#variant.Nanosecond) but the accuracy is fixed to 3.\n    Nanosecond3,\n    /// Same as [`Nanosecond`](#variant.Nanosecond) but the accuracy is fixed to 6.\n    Nanosecond6,\n    /// Same as [`Nanosecond`](#variant.Nanosecond) but the accuracy is fixed to 9.\n    Nanosecond9,\n    /// Timezone name.\n    ///\n    /// It does not support parsing, its use in the parser is an immediate failure.\n    TimezoneName,\n    /// Offset from the local time to UTC (`+09:00` or `-0400` or `+00:00`).\n    ///\n    /// In the parser, the colon may be omitted,\n    /// The offset is limited from `-24:00` to `+24:00`,\n    /// which is the same as [`FixedOffset`](../offset/struct.FixedOffset.html)'s range.\n    TimezoneOffsetColon,\n    /// Offset from the local time to UTC with seconds (`+09:00:00` or `-04:00:00` or `+00:00:00`).\n    ///\n    /// In the parser, the colon may be omitted,\n    /// The offset is limited from `-24:00:00` to `+24:00:00`,\n    /// which is the same as [`FixedOffset`](../offset/struct.FixedOffset.html)'s range.\n    TimezoneOffsetDoubleColon,\n    /// Offset from the local time to UTC without minutes (`+09` or `-04` or `+00`).\n    ///\n    /// In the parser, the colon may be omitted,\n    /// The offset is limited from `-24` to `+24`,\n    /// which is the same as [`FixedOffset`](../offset/struct.FixedOffset.html)'s range.\n    TimezoneOffsetTripleColon,\n    /// Offset from the local time to UTC (`+09:00` or `-0400` or `Z`).\n    ///\n    /// In the parser, the colon may be omitted,\n    /// and `Z` can be either in upper case or in lower case.\n    /// The offset is limited from `-24:00` to `+24:00`,\n    /// which is the same as [`FixedOffset`](../offset/struct.FixedOffset.html)'s range.\n    TimezoneOffsetColonZ,\n    /// Same as [`TimezoneOffsetColon`](#variant.TimezoneOffsetColon) but prints no colon.\n    /// Parsing allows an optional colon.\n    TimezoneOffset,\n    /// Same as [`TimezoneOffsetColonZ`](#variant.TimezoneOffsetColonZ) but prints no colon.\n    /// Parsing allows an optional colon.\n    TimezoneOffsetZ,\n    /// RFC 2822 date and time syntax. Commonly used for email and MIME date and time.\n    RFC2822,\n    /// RFC 3339 & ISO 8601 date and time syntax.\n    RFC3339,\n\n    /// Internal uses only.\n    ///\n    /// This item exists so that one can add additional internal-only formatting\n    /// without breaking major compatibility (as enum variants cannot be selectively private).\n    Internal(InternalFixed),\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::InternalFixed":["/// An opaque type representing fixed-format item types for internal uses only.\npub struct InternalFixed {\n    val: InternalInternal,\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::InternalInternal":["enum InternalInternal {\n    /// Same as [`TimezoneOffsetColonZ`](#variant.TimezoneOffsetColonZ), but\n    /// allows missing minutes (per [ISO 8601][iso8601]).\n    ///\n    /// # Panics\n    ///\n    /// If you try to use this for printing.\n    ///\n    /// [iso8601]: https://en.wikipedia.org/wiki/ISO_8601#Time_offsets_from_UTC\n    TimezoneOffsetPermissive,\n    /// Same as [`Nanosecond`](#variant.Nanosecond) but the accuracy is fixed to 3 and there is no leading dot.\n    Nanosecond3NoDot,\n    /// Same as [`Nanosecond`](#variant.Nanosecond) but the accuracy is fixed to 6 and there is no leading dot.\n    Nanosecond6NoDot,\n    /// Same as [`Nanosecond`](#variant.Nanosecond) but the accuracy is fixed to 9 and there is no leading dot.\n    Nanosecond9NoDot,\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::InternalNumeric":["/// An opaque type representing numeric item types for internal uses only.\npub struct InternalNumeric {\n    _dummy: Void,\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::Item":["/// A single formatting item. This is used for both formatting and parsing.\npub enum Item<'a> {\n    /// A literally printed and parsed text.\n    Literal(&'a str),\n    /// Same as `Literal` but with the string owned by the item.\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    OwnedLiteral(Box<str>),\n    /// Whitespace. Prints literally but reads zero or more whitespace.\n    Space(&'a str),\n    /// Same as `Space` but with the string owned by the item.\n    #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"alloc\", feature = \"std\"))))]\n    OwnedSpace(Box<str>),\n    /// Numeric item. Can be optionally padded to the maximal length (if any) when formatting;\n    /// the parser simply ignores any padded whitespace and zeroes.\n    Numeric(Numeric, Pad),\n    /// Fixed-format item.\n    Fixed(Fixed),\n    /// Issues a formatting error. Used to signal an invalid format string.\n    Error,\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::Locale":["#[cfg(not(feature = \"unstable-locales\"))]\n#[allow(dead_code)]\nstruct Locale;","Real(LocalPath(\"src/format/mod.rs\"))"],"format::Locales":["#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\nstruct Locales {\n    short_months: &'static [&'static str],\n    long_months: &'static [&'static str],\n    short_weekdays: &'static [&'static str],\n    long_weekdays: &'static [&'static str],\n    am_pm: &'static [&'static str],\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::Locales::new":["fn new(_locale: Option<Locale>) -> Self{\n        #[cfg(feature = \"unstable-locales\")]\n        {\n            let locale = _locale.unwrap_or(Locale::POSIX);\n            Self {\n                short_months: locales::short_months(locale),\n                long_months: locales::long_months(locale),\n                short_weekdays: locales::short_weekdays(locale),\n                long_weekdays: locales::long_weekdays(locale),\n                am_pm: locales::am_pm(locale),\n            }\n        }\n        #[cfg(not(feature = \"unstable-locales\"))]\n        Self {\n            short_months: &[\n                \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n            ],\n            long_months: &[\n                \"January\",\n                \"February\",\n                \"March\",\n                \"April\",\n                \"May\",\n                \"June\",\n                \"July\",\n                \"August\",\n                \"September\",\n                \"October\",\n                \"November\",\n                \"December\",\n            ],\n            short_weekdays: &[\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n            long_weekdays: &[\n                \"Sunday\",\n                \"Monday\",\n                \"Tuesday\",\n                \"Wednesday\",\n                \"Thursday\",\n                \"Friday\",\n                \"Saturday\",\n            ],\n            am_pm: &[\"AM\", \"PM\"],\n        }\n    }","Real(LocalPath(\"src/format/mod.rs\"))"],"format::Numeric":["/// Numeric item types.\n/// They have associated formatting width (FW) and parsing width (PW).\n///\n/// The **formatting width** is the minimal width to be formatted.\n/// If the number is too short, and the padding is not [`Pad::None`](./enum.Pad.html#variant.None),\n/// then it is left-padded.\n/// If the number is too long or (in some cases) negative, it is printed as is.\n///\n/// The **parsing width** is the maximal width to be scanned.\n/// The parser only tries to consume from one to given number of digits (greedily).\n/// It also trims the preceding whitespace if any.\n/// It cannot parse the negative number, so some date and time cannot be formatted then\n/// parsed with the same formatting items.\npub enum Numeric {\n    /// Full Gregorian year (FW=4, PW=).\n    /// May accept years before 1 BCE or after 9999 CE, given an initial sign (+/-).\n    Year,\n    /// Gregorian year divided by 100 (century number; FW=PW=2). Implies the non-negative year.\n    YearDiv100,\n    /// Gregorian year modulo 100 (FW=PW=2). Cannot be negative.\n    YearMod100,\n    /// Year in the ISO week date (FW=4, PW=).\n    /// May accept years before 1 BCE or after 9999 CE, given an initial sign.\n    IsoYear,\n    /// Year in the ISO week date, divided by 100 (FW=PW=2). Implies the non-negative year.\n    IsoYearDiv100,\n    /// Year in the ISO week date, modulo 100 (FW=PW=2). Cannot be negative.\n    IsoYearMod100,\n    /// Month (FW=PW=2).\n    Month,\n    /// Day of the month (FW=PW=2).\n    Day,\n    /// Week number, where the week 1 starts at the first Sunday of January (FW=PW=2).\n    WeekFromSun,\n    /// Week number, where the week 1 starts at the first Monday of January (FW=PW=2).\n    WeekFromMon,\n    /// Week number in the ISO week date (FW=PW=2).\n    IsoWeek,\n    /// Day of the week, where Sunday = 0 and Saturday = 6 (FW=PW=1).\n    NumDaysFromSun,\n    /// Day of the week, where Monday = 1 and Sunday = 7 (FW=PW=1).\n    WeekdayFromMon,\n    /// Day of the year (FW=PW=3).\n    Ordinal,\n    /// Hour number in the 24-hour clocks (FW=PW=2).\n    Hour,\n    /// Hour number in the 12-hour clocks (FW=PW=2).\n    Hour12,\n    /// The number of minutes since the last whole hour (FW=PW=2).\n    Minute,\n    /// The number of seconds since the last whole minute (FW=PW=2).\n    Second,\n    /// The number of nanoseconds since the last whole second (FW=PW=9).\n    /// Note that this is *not* left-aligned;\n    /// see also [`Fixed::Nanosecond`](./enum.Fixed.html#variant.Nanosecond).\n    Nanosecond,\n    /// The number of non-leap seconds since the midnight UTC on January 1, 1970 (FW=1, PW=).\n    /// For formatting, it assumes UTC upon the absence of time zone offset.\n    Timestamp,\n\n    /// Internal uses only.\n    ///\n    /// This item exists so that one can add additional internal-only formatting\n    /// without breaking major compatibility (as enum variants cannot be selectively private).\n    Internal(InternalNumeric),\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::Pad":["/// Padding characters for numeric items.\npub enum Pad {\n    /// No padding.\n    None,\n    /// Zero (`0`) padding.\n    Zero,\n    /// Space padding.\n    Space,\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::ParseError":["/// An error from the `parse` function.\npub struct ParseError(ParseErrorKind);","Real(LocalPath(\"src/format/mod.rs\"))"],"format::ParseError::kind":["/// The category of parse error\npub const fn kind(&self) -> ParseErrorKind{\n        self.0\n    }","Real(LocalPath(\"src/format/mod.rs\"))"],"format::ParseErrorKind":["/// The category of parse error\n#[allow(clippy::manual_non_exhaustive)]\npub enum ParseErrorKind {\n    /// Given field is out of permitted range.\n    OutOfRange,\n\n    /// There is no possible date and time value with given set of fields.\n    ///\n    /// This does not include the out-of-range conditions, which are trivially invalid.\n    /// It includes the case that there are one or more fields that are inconsistent to each other.\n    Impossible,\n\n    /// Given set of fields is not enough to make a requested date and time value.\n    ///\n    /// Note that there *may* be a case that given fields constrain the possible values so much\n    /// that there is a unique possible value. Chrono only tries to be correct for\n    /// most useful sets of fields however, as such constraint solving can be expensive.\n    NotEnough,\n\n    /// The input string has some invalid character sequence for given formatting items.\n    Invalid,\n\n    /// The input string has been prematurely ended.\n    TooShort,\n\n    /// All formatting items have been read but there is a remaining input.\n    TooLong,\n\n    /// There was an error on the formatting string, or there were non-supported formating items.\n    BadFormat,\n\n    // TODO: Change this to `#[non_exhaustive]` (on the enum) with the next breaking release.\n    #[doc(hidden)]\n    __Nonexhaustive,\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::Void":["/// An uninhabited type used for `InternalNumeric` and `InternalFixed` below.\nenum Void {}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::format":["/// Tries to format given arguments with given formatting items.\n/// Internally used by `DelayedFormat`.\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub fn format<'a, I, B>(\n    w: &mut fmt::Formatter,\n    date: Option<&NaiveDate>,\n    time: Option<&NaiveTime>,\n    off: Option<&(String, FixedOffset)>,\n    items: I,\n) -> fmt::Result\nwhere\n    I: Iterator<Item = B> + Clone,\n    B: Borrow<Item<'a>>,{\n    let mut result = String::new();\n    for item in items {\n        format_inner(&mut result, date, time, off, item.borrow(), None)?;\n    }\n    w.pad(&result)\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::format_inner":["#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\nfn format_inner(\n    result: &mut String,\n    date: Option<&NaiveDate>,\n    time: Option<&NaiveTime>,\n    off: Option<&(String, FixedOffset)>,\n    item: &Item<'_>,\n    locale: Option<Locale>,\n) -> fmt::Result{\n    let locale = Locales::new(locale);\n\n    match *item {\n        Item::Literal(s) | Item::Space(s) => result.push_str(s),\n        #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n        Item::OwnedLiteral(ref s) | Item::OwnedSpace(ref s) => result.push_str(s),\n\n        Item::Numeric(ref spec, ref pad) => {\n            use self::Numeric::*;\n\n            let week_from_sun = |d: &NaiveDate| d.weeks_from(Weekday::Sun);\n            let week_from_mon = |d: &NaiveDate| d.weeks_from(Weekday::Mon);\n\n            let (width, v) = match *spec {\n                Year => (4, date.map(|d| i64::from(d.year()))),\n                YearDiv100 => (2, date.map(|d| i64::from(d.year()).div_euclid(100))),\n                YearMod100 => (2, date.map(|d| i64::from(d.year()).rem_euclid(100))),\n                IsoYear => (4, date.map(|d| i64::from(d.iso_week().year()))),\n                IsoYearDiv100 => (2, date.map(|d| i64::from(d.iso_week().year()).div_euclid(100))),\n                IsoYearMod100 => (2, date.map(|d| i64::from(d.iso_week().year()).rem_euclid(100))),\n                Month => (2, date.map(|d| i64::from(d.month()))),\n                Day => (2, date.map(|d| i64::from(d.day()))),\n                WeekFromSun => (2, date.map(|d| i64::from(week_from_sun(d)))),\n                WeekFromMon => (2, date.map(|d| i64::from(week_from_mon(d)))),\n                IsoWeek => (2, date.map(|d| i64::from(d.iso_week().week()))),\n                NumDaysFromSun => (1, date.map(|d| i64::from(d.weekday().num_days_from_sunday()))),\n                WeekdayFromMon => (1, date.map(|d| i64::from(d.weekday().number_from_monday()))),\n                Ordinal => (3, date.map(|d| i64::from(d.ordinal()))),\n                Hour => (2, time.map(|t| i64::from(t.hour()))),\n                Hour12 => (2, time.map(|t| i64::from(t.hour12().1))),\n                Minute => (2, time.map(|t| i64::from(t.minute()))),\n                Second => (2, time.map(|t| i64::from(t.second() + t.nanosecond() / 1_000_000_000))),\n                Nanosecond => (9, time.map(|t| i64::from(t.nanosecond() % 1_000_000_000))),\n                Timestamp => (\n                    1,\n                    match (date, time, off) {\n                        (Some(d), Some(t), None) => Some(d.and_time(*t).timestamp()),\n                        (Some(d), Some(t), Some(&(_, off))) => {\n                            Some((d.and_time(*t) - off).timestamp())\n                        }\n                        (_, _, _) => None,\n                    },\n                ),\n\n                // for the future expansion\n                Internal(ref int) => match int._dummy {},\n            };\n\n            if let Some(v) = v {\n                if (spec == &Year || spec == &IsoYear) && !(0..10_000).contains(&v) {\n                    // non-four-digit years require an explicit sign as per ISO 8601\n                    match *pad {\n                        Pad::None => write!(result, \"{:+}\", v),\n                        Pad::Zero => write!(result, \"{:+01$}\", v, width + 1),\n                        Pad::Space => write!(result, \"{:+1$}\", v, width + 1),\n                    }\n                } else {\n                    match *pad {\n                        Pad::None => write!(result, \"{}\", v),\n                        Pad::Zero => write!(result, \"{:01$}\", v, width),\n                        Pad::Space => write!(result, \"{:1$}\", v, width),\n                    }\n                }?\n            } else {\n                return Err(fmt::Error); // insufficient arguments for given format\n            }\n        }\n\n        Item::Fixed(ref spec) => {\n            use self::Fixed::*;\n\n            let ret =\n                match *spec {\n                    ShortMonthName => date.map(|d| {\n                        result.push_str(locale.short_months[d.month0() as usize]);\n                        Ok(())\n                    }),\n                    LongMonthName => date.map(|d| {\n                        result.push_str(locale.long_months[d.month0() as usize]);\n                        Ok(())\n                    }),\n                    ShortWeekdayName => date.map(|d| {\n                        result.push_str(\n                            locale.short_weekdays[d.weekday().num_days_from_sunday() as usize],\n                        );\n                        Ok(())\n                    }),\n                    LongWeekdayName => date.map(|d| {\n                        result.push_str(\n                            locale.long_weekdays[d.weekday().num_days_from_sunday() as usize],\n                        );\n                        Ok(())\n                    }),\n                    LowerAmPm => time.map(|t| {\n                        let ampm = if t.hour12().0 { locale.am_pm[1] } else { locale.am_pm[0] };\n                        for char in ampm.chars() {\n                            result.extend(char.to_lowercase())\n                        }\n                        Ok(())\n                    }),\n                    UpperAmPm => time.map(|t| {\n                        result.push_str(if t.hour12().0 {\n                            locale.am_pm[1]\n                        } else {\n                            locale.am_pm[0]\n                        });\n                        Ok(())\n                    }),\n                    Nanosecond => time.map(|t| {\n                        let nano = t.nanosecond() % 1_000_000_000;\n                        if nano == 0 {\n                            Ok(())\n                        } else if nano % 1_000_000 == 0 {\n                            write!(result, \".{:03}\", nano / 1_000_000)\n                        } else if nano % 1_000 == 0 {\n                            write!(result, \".{:06}\", nano / 1_000)\n                        } else {\n                            write!(result, \".{:09}\", nano)\n                        }\n                    }),\n                    Nanosecond3 => time.map(|t| {\n                        let nano = t.nanosecond() % 1_000_000_000;\n                        write!(result, \".{:03}\", nano / 1_000_000)\n                    }),\n                    Nanosecond6 => time.map(|t| {\n                        let nano = t.nanosecond() % 1_000_000_000;\n                        write!(result, \".{:06}\", nano / 1_000)\n                    }),\n                    Nanosecond9 => time.map(|t| {\n                        let nano = t.nanosecond() % 1_000_000_000;\n                        write!(result, \".{:09}\", nano)\n                    }),\n                    Internal(InternalFixed { val: InternalInternal::Nanosecond3NoDot }) => time\n                        .map(|t| {\n                            let nano = t.nanosecond() % 1_000_000_000;\n                            write!(result, \"{:03}\", nano / 1_000_000)\n                        }),\n                    Internal(InternalFixed { val: InternalInternal::Nanosecond6NoDot }) => time\n                        .map(|t| {\n                            let nano = t.nanosecond() % 1_000_000_000;\n                            write!(result, \"{:06}\", nano / 1_000)\n                        }),\n                    Internal(InternalFixed { val: InternalInternal::Nanosecond9NoDot }) => time\n                        .map(|t| {\n                            let nano = t.nanosecond() % 1_000_000_000;\n                            write!(result, \"{:09}\", nano)\n                        }),\n                    TimezoneName => off.map(|(name, _)| {\n                        result.push_str(name);\n                        Ok(())\n                    }),\n                    TimezoneOffsetColon => off\n                        .map(|&(_, off)| write_local_minus_utc(result, off, false, Colons::Single)),\n                    TimezoneOffsetDoubleColon => off\n                        .map(|&(_, off)| write_local_minus_utc(result, off, false, Colons::Double)),\n                    TimezoneOffsetTripleColon => off\n                        .map(|&(_, off)| write_local_minus_utc(result, off, false, Colons::Triple)),\n                    TimezoneOffsetColonZ => off\n                        .map(|&(_, off)| write_local_minus_utc(result, off, true, Colons::Single)),\n                    TimezoneOffset => {\n                        off.map(|&(_, off)| write_local_minus_utc(result, off, false, Colons::None))\n                    }\n                    TimezoneOffsetZ => {\n                        off.map(|&(_, off)| write_local_minus_utc(result, off, true, Colons::None))\n                    }\n                    Internal(InternalFixed { val: InternalInternal::TimezoneOffsetPermissive }) => {\n                        panic!(\"Do not try to write %#z it is undefined\")\n                    }\n                    RFC2822 =>\n                    // same as `%a, %d %b %Y %H:%M:%S %z`\n                    {\n                        if let (Some(d), Some(t), Some(&(_, off))) = (date, time, off) {\n                            Some(write_rfc2822_inner(result, d, t, off, locale))\n                        } else {\n                            None\n                        }\n                    }\n                    RFC3339 =>\n                    // same as `%Y-%m-%dT%H:%M:%S%.f%:z`\n                    {\n                        if let (Some(d), Some(t), Some(&(_, off))) = (date, time, off) {\n                            Some(write_rfc3339(result, crate::NaiveDateTime::new(*d, *t), off))\n                        } else {\n                            None\n                        }\n                    }\n                };\n\n            match ret {\n                Some(ret) => ret?,\n                None => return Err(fmt::Error), // insufficient arguments for given format\n            }\n        }\n\n        Item::Error => return Err(fmt::Error),\n    }\n    Ok(())\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::format_item":["/// Formats single formatting item\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub fn format_item(\n    w: &mut fmt::Formatter,\n    date: Option<&NaiveDate>,\n    time: Option<&NaiveTime>,\n    off: Option<&(String, FixedOffset)>,\n    item: &Item<'_>,\n) -> fmt::Result{\n    let mut result = String::new();\n    format_inner(&mut result, date, time, off, item, None)?;\n    w.pad(&result)\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::parse::<impl std::str::FromStr for datetime::DateTime<offset::fixed::FixedOffset>>::from_str":["fn from_str(s: &str) -> ParseResult<DateTime<FixedOffset>>{\n        const DATE_ITEMS: &[Item<'static>] = &[\n            Item::Numeric(Numeric::Year, Pad::Zero),\n            Item::Literal(\"-\"),\n            Item::Numeric(Numeric::Month, Pad::Zero),\n            Item::Literal(\"-\"),\n            Item::Numeric(Numeric::Day, Pad::Zero),\n        ];\n        const TIME_ITEMS: &[Item<'static>] = &[\n            Item::Numeric(Numeric::Hour, Pad::Zero),\n            Item::Literal(\":\"),\n            Item::Numeric(Numeric::Minute, Pad::Zero),\n            Item::Literal(\":\"),\n            Item::Numeric(Numeric::Second, Pad::Zero),\n            Item::Fixed(Fixed::Nanosecond),\n            Item::Fixed(Fixed::TimezoneOffsetZ),\n        ];\n\n        let mut parsed = Parsed::new();\n        match parse_internal(&mut parsed, s, DATE_ITEMS.iter()) {\n            Err((remainder, e)) if e.0 == ParseErrorKind::TooLong => {\n                if remainder.starts_with('T') || remainder.starts_with(' ') {\n                    parse(&mut parsed, &remainder[1..], TIME_ITEMS.iter())?;\n                } else {\n                    return Err(INVALID);\n                }\n            }\n            Err((_s, e)) => return Err(e),\n            Ok(_) => return Err(NOT_ENOUGH),\n        };\n        parsed.to_datetime()\n    }","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::parse":["/// Tries to parse given string into `parsed` with given formatting items.\n/// Returns `Ok` when the entire string has been parsed (otherwise `parsed` should not be used).\n/// There should be no trailing string after parsing;\n/// use a stray [`Item::Space`](./enum.Item.html#variant.Space) to trim whitespaces.\n///\n/// This particular date and time parser is:\n///\n/// - Greedy. It will consume the longest possible prefix.\n///   For example, `April` is always consumed entirely when the long month name is requested;\n///   it equally accepts `Apr`, but prefers the longer prefix in this case.\n///\n/// - Padding-agnostic (for numeric items).\n///   The [`Pad`](./enum.Pad.html) field is completely ignored,\n///   so one can prepend any number of zeroes before numbers.\n///\n/// - (Still) obeying the intrinsic parsing width. This allows, for example, parsing `HHMMSS`.\npub fn parse<'a, I, B>(parsed: &mut Parsed, s: &str, items: I) -> ParseResult<()>\nwhere\n    I: Iterator<Item = B>,\n    B: Borrow<Item<'a>>,{\n    parse_internal(parsed, s, items).map(|_| ()).map_err(|(_s, e)| e)\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::parse_and_remainder":["/// Tries to parse given string into `parsed` with given formatting items.\n/// Returns `Ok` with a slice of the unparsed remainder.\n///\n/// This particular date and time parser is:\n///\n/// - Greedy. It will consume the longest possible prefix.\n///   For example, `April` is always consumed entirely when the long month name is requested;\n///   it equally accepts `Apr`, but prefers the longer prefix in this case.\n///\n/// - Padding-agnostic (for numeric items).\n///   The [`Pad`](./enum.Pad.html) field is completely ignored,\n///   so one can prepend any number of zeroes before numbers.\n///\n/// - (Still) obeying the intrinsic parsing width. This allows, for example, parsing `HHMMSS`.\npub fn parse_and_remainder<'a, 'b, I, B>(\n    parsed: &mut Parsed,\n    s: &'b str,\n    items: I,\n) -> ParseResult<&'b str>\nwhere\n    I: Iterator<Item = B>,\n    B: Borrow<Item<'a>>,{\n    match parse_internal(parsed, s, items) {\n        Ok(s) => Ok(s),\n        Err((s, ParseError(ParseErrorKind::TooLong))) => Ok(s),\n        Err((_s, e)) => Err(e),\n    }\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::parse_internal":["fn parse_internal<'a, 'b, I, B>(\n    parsed: &mut Parsed,\n    mut s: &'b str,\n    items: I,\n) -> Result<&'b str, (&'b str, ParseError)>\nwhere\n    I: Iterator<Item = B>,\n    B: Borrow<Item<'a>>,{\n    macro_rules! try_consume {\n        ($e:expr) => {{\n            match $e {\n                Ok((s_, v)) => {\n                    s = s_;\n                    v\n                }\n                Err(e) => return Err((s, e)),\n            }\n        }};\n    }\n\n    for item in items {\n        match *item.borrow() {\n            Item::Literal(prefix) => {\n                if s.len() < prefix.len() {\n                    return Err((s, TOO_SHORT));\n                }\n                if !s.starts_with(prefix) {\n                    return Err((s, INVALID));\n                }\n                s = &s[prefix.len()..];\n            }\n\n            #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n            Item::OwnedLiteral(ref prefix) => {\n                if s.len() < prefix.len() {\n                    return Err((s, TOO_SHORT));\n                }\n                if !s.starts_with(&prefix[..]) {\n                    return Err((s, INVALID));\n                }\n                s = &s[prefix.len()..];\n            }\n\n            Item::Space(item_space) => {\n                for expect in item_space.chars() {\n                    let actual = match s.chars().next() {\n                        Some(c) => c,\n                        None => {\n                            return Err((s, TOO_SHORT));\n                        }\n                    };\n                    if expect != actual {\n                        return Err((s, INVALID));\n                    }\n                    // advance `s` forward 1 char\n                    s = scan::s_next(s);\n                }\n            }\n\n            #[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n            Item::OwnedSpace(ref item_space) => {\n                for expect in item_space.chars() {\n                    let actual = match s.chars().next() {\n                        Some(c) => c,\n                        None => {\n                            return Err((s, TOO_SHORT));\n                        }\n                    };\n                    if expect != actual {\n                        return Err((s, INVALID));\n                    }\n                    // advance `s` forward 1 char\n                    s = scan::s_next(s);\n                }\n            }\n\n            Item::Numeric(ref spec, ref _pad) => {\n                use super::Numeric::*;\n                type Setter = fn(&mut Parsed, i64) -> ParseResult<()>;\n\n                let (width, signed, set): (usize, bool, Setter) = match *spec {\n                    Year => (4, true, Parsed::set_year),\n                    YearDiv100 => (2, false, Parsed::set_year_div_100),\n                    YearMod100 => (2, false, Parsed::set_year_mod_100),\n                    IsoYear => (4, true, Parsed::set_isoyear),\n                    IsoYearDiv100 => (2, false, Parsed::set_isoyear_div_100),\n                    IsoYearMod100 => (2, false, Parsed::set_isoyear_mod_100),\n                    Month => (2, false, Parsed::set_month),\n                    Day => (2, false, Parsed::set_day),\n                    WeekFromSun => (2, false, Parsed::set_week_from_sun),\n                    WeekFromMon => (2, false, Parsed::set_week_from_mon),\n                    IsoWeek => (2, false, Parsed::set_isoweek),\n                    NumDaysFromSun => (1, false, set_weekday_with_num_days_from_sunday),\n                    WeekdayFromMon => (1, false, set_weekday_with_number_from_monday),\n                    Ordinal => (3, false, Parsed::set_ordinal),\n                    Hour => (2, false, Parsed::set_hour),\n                    Hour12 => (2, false, Parsed::set_hour12),\n                    Minute => (2, false, Parsed::set_minute),\n                    Second => (2, false, Parsed::set_second),\n                    Nanosecond => (9, false, Parsed::set_nanosecond),\n                    Timestamp => (usize::MAX, false, Parsed::set_timestamp),\n\n                    // for the future expansion\n                    Internal(ref int) => match int._dummy {},\n                };\n\n                let v = if signed {\n                    if s.starts_with('-') {\n                        let v = try_consume!(scan::number(&s[1..], 1, usize::MAX));\n                        0i64.checked_sub(v).ok_or((s, OUT_OF_RANGE))?\n                    } else if s.starts_with('+') {\n                        try_consume!(scan::number(&s[1..], 1, usize::MAX))\n                    } else {\n                        // if there is no explicit sign, we respect the original `width`\n                        try_consume!(scan::number(s, 1, width))\n                    }\n                } else {\n                    try_consume!(scan::number(s, 1, width))\n                };\n                set(parsed, v).map_err(|e| (s, e))?;\n            }\n\n            Item::Fixed(ref spec) => {\n                use super::Fixed::*;\n\n                match spec {\n                    &ShortMonthName => {\n                        let month0 = try_consume!(scan::short_month0(s));\n                        parsed.set_month(i64::from(month0) + 1).map_err(|e| (s, e))?;\n                    }\n\n                    &LongMonthName => {\n                        let month0 = try_consume!(scan::short_or_long_month0(s));\n                        parsed.set_month(i64::from(month0) + 1).map_err(|e| (s, e))?;\n                    }\n\n                    &ShortWeekdayName => {\n                        let weekday = try_consume!(scan::short_weekday(s));\n                        parsed.set_weekday(weekday).map_err(|e| (s, e))?;\n                    }\n\n                    &LongWeekdayName => {\n                        let weekday = try_consume!(scan::short_or_long_weekday(s));\n                        parsed.set_weekday(weekday).map_err(|e| (s, e))?;\n                    }\n\n                    &LowerAmPm | &UpperAmPm => {\n                        if s.len() < 2 {\n                            return Err((s, TOO_SHORT));\n                        }\n                        let ampm = match (s.as_bytes()[0] | 32, s.as_bytes()[1] | 32) {\n                            (b'a', b'm') => false,\n                            (b'p', b'm') => true,\n                            _ => return Err((s, INVALID)),\n                        };\n                        parsed.set_ampm(ampm).map_err(|e| (s, e))?;\n                        s = &s[2..];\n                    }\n\n                    &Nanosecond | &Nanosecond3 | &Nanosecond6 | &Nanosecond9 => {\n                        if s.starts_with('.') {\n                            let nano = try_consume!(scan::nanosecond(&s[1..]));\n                            parsed.set_nanosecond(nano).map_err(|e| (s, e))?;\n                        }\n                    }\n\n                    &Internal(InternalFixed { val: InternalInternal::Nanosecond3NoDot }) => {\n                        if s.len() < 3 {\n                            return Err((s, TOO_SHORT));\n                        }\n                        let nano = try_consume!(scan::nanosecond_fixed(s, 3));\n                        parsed.set_nanosecond(nano).map_err(|e| (s, e))?;\n                    }\n\n                    &Internal(InternalFixed { val: InternalInternal::Nanosecond6NoDot }) => {\n                        if s.len() < 6 {\n                            return Err((s, TOO_SHORT));\n                        }\n                        let nano = try_consume!(scan::nanosecond_fixed(s, 6));\n                        parsed.set_nanosecond(nano).map_err(|e| (s, e))?;\n                    }\n\n                    &Internal(InternalFixed { val: InternalInternal::Nanosecond9NoDot }) => {\n                        if s.len() < 9 {\n                            return Err((s, TOO_SHORT));\n                        }\n                        let nano = try_consume!(scan::nanosecond_fixed(s, 9));\n                        parsed.set_nanosecond(nano).map_err(|e| (s, e))?;\n                    }\n\n                    &TimezoneName => {\n                        try_consume!(scan::timezone_name_skip(s));\n                    }\n\n                    &TimezoneOffsetColon\n                    | &TimezoneOffsetDoubleColon\n                    | &TimezoneOffsetTripleColon\n                    | &TimezoneOffset => {\n                        s = scan::trim1(s);\n                        let offset =\n                            try_consume!(scan::timezone_offset(s, scan::consume_colon_maybe));\n                        parsed.set_offset(i64::from(offset)).map_err(|e| (s, e))?;\n                    }\n\n                    &TimezoneOffsetColonZ | &TimezoneOffsetZ => {\n                        s = scan::trim1(s);\n                        let offset =\n                            try_consume!(scan::timezone_offset_zulu(s, scan::consume_colon_maybe));\n                        parsed.set_offset(i64::from(offset)).map_err(|e| (s, e))?;\n                    }\n\n                    &Internal(InternalFixed {\n                        val: InternalInternal::TimezoneOffsetPermissive,\n                    }) => {\n                        s = scan::trim1(s);\n                        let offset = try_consume!(scan::timezone_offset_permissive(\n                            s,\n                            scan::consume_colon_maybe\n                        ));\n                        parsed.set_offset(i64::from(offset)).map_err(|e| (s, e))?;\n                    }\n\n                    &RFC2822 => try_consume!(parse_rfc2822(parsed, s)),\n                    &RFC3339 => try_consume!(parse_rfc3339(parsed, s)),\n                }\n            }\n\n            Item::Error => {\n                return Err((s, BAD_FORMAT));\n            }\n        }\n    }\n\n    // if there are trailling chars, it is an error\n    if !s.is_empty() {\n        Err((s, TOO_LONG))\n    } else {\n        Ok(s)\n    }\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::parse_rfc2822":["/// Parse an RFC 2822 format datetime\n/// e.g. `Fri, 21 Nov 1997 09:55:06 -0600`\n///\n/// This function allows arbitrary intermixed whitespace per RFC 2822 appendix A.5\nfn parse_rfc2822<'a>(parsed: &mut Parsed, mut s: &'a str) -> ParseResult<(&'a str, ())>{\n    macro_rules! try_consume {\n        ($e:expr) => {{\n            let (s_, v) = $e?;\n            s = s_;\n            v\n        }};\n    }\n\n    // an adapted RFC 2822 syntax from Section 3.3 and 4.3:\n    //\n    // c-char      = <any char except '(', ')' and '\\\\'>\n    // c-escape    = \"\\\" <any char>\n    // comment     = \"(\" *(comment / c-char / c-escape) \")\" *S\n    // date-time   = [ day-of-week \",\" ] date 1*S time *S *comment\n    // day-of-week = *S day-name *S\n    // day-name    = \"Mon\" / \"Tue\" / \"Wed\" / \"Thu\" / \"Fri\" / \"Sat\" / \"Sun\"\n    // date        = day month year\n    // day         = *S 1*2DIGIT *S\n    // month       = 1*S month-name 1*S\n    // month-name  = \"Jan\" / \"Feb\" / \"Mar\" / \"Apr\" / \"May\" / \"Jun\" /\n    //               \"Jul\" / \"Aug\" / \"Sep\" / \"Oct\" / \"Nov\" / \"Dec\"\n    // year        = *S 2*DIGIT *S\n    // time        = time-of-day 1*S zone\n    // time-of-day = hour \":\" minute [ \":\" second ]\n    // hour        = *S 2DIGIT *S\n    // minute      = *S 2DIGIT *S\n    // second      = *S 2DIGIT *S\n    // zone        = ( \"+\" / \"-\" ) 4DIGIT /\n    //               \"UT\" / \"GMT\" /                  ; same as +0000\n    //               \"EST\" / \"CST\" / \"MST\" / \"PST\" / ; same as -0500 to -0800\n    //               \"EDT\" / \"CDT\" / \"MDT\" / \"PDT\" / ; same as -0400 to -0700\n    //               1*(%d65-90 / %d97-122)          ; same as -0000\n    //\n    // some notes:\n    //\n    // - quoted characters can be in any mixture of lower and upper cases.\n    //\n    // - we do not recognize a folding white space (FWS) or comment (CFWS).\n    //   for our purposes, instead, we accept any sequence of Unicode\n    //   white space characters (denoted here to `S`). For comments, we accept\n    //   any text within parentheses while respecting escaped parentheses.\n    //   Any actual RFC 2822 parser is expected to parse FWS and/or CFWS themselves\n    //   and replace it with a single SP (`%x20`); this is legitimate.\n    //\n    // - two-digit year < 50 should be interpreted by adding 2000.\n    //   two-digit year >= 50 or three-digit year should be interpreted\n    //   by adding 1900. note that four-or-more-digit years less than 1000\n    //   are *never* affected by this rule.\n    //\n    // - mismatching day-of-week is always an error, which is consistent to\n    //   Chrono's own rules.\n    //\n    // - zones can range from `-9959` to `+9959`, but `FixedOffset` does not\n    //   support offsets larger than 24 hours. this is not *that* problematic\n    //   since we do not directly go to a `DateTime` so one can recover\n    //   the offset information from `Parsed` anyway.\n\n    s = s.trim_left();\n\n    if let Ok((s_, weekday)) = scan::short_weekday(s) {\n        if !s_.starts_with(',') {\n            return Err(INVALID);\n        }\n        s = &s_[1..];\n        parsed.set_weekday(weekday)?;\n    }\n\n    s = s.trim_left();\n    parsed.set_day(try_consume!(scan::number(s, 1, 2)))?;\n    s = scan::space(s)?; // mandatory\n    parsed.set_month(1 + i64::from(try_consume!(scan::short_month0(s))))?;\n    s = scan::space(s)?; // mandatory\n\n    // distinguish two- and three-digit years from four-digit years\n    let prevlen = s.len();\n    let mut year = try_consume!(scan::number(s, 2, usize::MAX));\n    let yearlen = prevlen - s.len();\n    match (yearlen, year) {\n        (2, 0..=49) => {\n            year += 2000;\n        } //   47 -> 2047,   05 -> 2005\n        (2, 50..=99) => {\n            year += 1900;\n        } //   79 -> 1979\n        (3, _) => {\n            year += 1900;\n        } //  112 -> 2012,  009 -> 1909\n        (_, _) => {} // 1987 -> 1987, 0654 -> 0654\n    }\n    parsed.set_year(year)?;\n\n    s = scan::space(s)?; // mandatory\n    parsed.set_hour(try_consume!(scan::number(s, 2, 2)))?;\n    s = scan::char(s.trim_left(), b':')?.trim_left(); // *S \":\" *S\n    parsed.set_minute(try_consume!(scan::number(s, 2, 2)))?;\n    if let Ok(s_) = scan::char(s.trim_left(), b':') {\n        // [ \":\" *S 2DIGIT ]\n        parsed.set_second(try_consume!(scan::number(s_, 2, 2)))?;\n    }\n\n    s = scan::space(s)?; // mandatory\n    if let Some(offset) = try_consume!(scan::timezone_offset_2822(s)) {\n        // only set the offset when it is definitely known (i.e. not `-0000`)\n        parsed.set_offset(i64::from(offset))?;\n    }\n\n    // optional comments\n    while let Ok((s_out, ())) = scan::comment_2822(s) {\n        s = s_out;\n    }\n\n    Ok((s, ()))\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::parse_rfc3339":["fn parse_rfc3339<'a>(parsed: &mut Parsed, mut s: &'a str) -> ParseResult<(&'a str, ())>{\n    macro_rules! try_consume {\n        ($e:expr) => {{\n            let (s_, v) = $e?;\n            s = s_;\n            v\n        }};\n    }\n\n    // an adapted RFC 3339 syntax from Section 5.6:\n    //\n    // date-fullyear  = 4DIGIT\n    // date-month     = 2DIGIT ; 01-12\n    // date-mday      = 2DIGIT ; 01-28, 01-29, 01-30, 01-31 based on month/year\n    // time-hour      = 2DIGIT ; 00-23\n    // time-minute    = 2DIGIT ; 00-59\n    // time-second    = 2DIGIT ; 00-58, 00-59, 00-60 based on leap second rules\n    // time-secfrac   = \".\" 1*DIGIT\n    // time-numoffset = (\"+\" / \"-\") time-hour \":\" time-minute\n    // time-offset    = \"Z\" / time-numoffset\n    // partial-time   = time-hour \":\" time-minute \":\" time-second [time-secfrac]\n    // full-date      = date-fullyear \"-\" date-month \"-\" date-mday\n    // full-time      = partial-time time-offset\n    // date-time      = full-date \"T\" full-time\n    //\n    // some notes:\n    //\n    // - quoted characters can be in any mixture of lower and upper cases.\n    //\n    // - it may accept any number of fractional digits for seconds.\n    //   for Chrono, this means that we should skip digits past first 9 digits.\n    //\n    // - unlike RFC 2822, the valid offset ranges from -23:59 to +23:59.\n    //   note that this restriction is unique to RFC 3339 and not ISO 8601.\n    //   since this is not a typical Chrono behavior, we check it earlier.\n\n    parsed.set_year(try_consume!(scan::number(s, 4, 4)))?;\n    s = scan::char(s, b'-')?;\n    parsed.set_month(try_consume!(scan::number(s, 2, 2)))?;\n    s = scan::char(s, b'-')?;\n    parsed.set_day(try_consume!(scan::number(s, 2, 2)))?;\n\n    s = match s.as_bytes().first() {\n        Some(&b't') | Some(&b'T') => &s[1..],\n        Some(_) => return Err(INVALID),\n        None => return Err(TOO_SHORT),\n    };\n\n    parsed.set_hour(try_consume!(scan::number(s, 2, 2)))?;\n    s = scan::char(s, b':')?;\n    parsed.set_minute(try_consume!(scan::number(s, 2, 2)))?;\n    s = scan::char(s, b':')?;\n    parsed.set_second(try_consume!(scan::number(s, 2, 2)))?;\n    if s.starts_with('.') {\n        let nanosecond = try_consume!(scan::nanosecond(&s[1..]));\n        parsed.set_nanosecond(nanosecond)?;\n    }\n\n    let offset = try_consume!(scan::timezone_offset_zulu(s, |s| scan::char(s, b':')));\n    if offset <= -86_400 || offset >= 86_400 {\n        return Err(OUT_OF_RANGE);\n    }\n    parsed.set_offset(i64::from(offset))?;\n\n    Ok((s, ()))\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::set_weekday_with_num_days_from_sunday":["fn set_weekday_with_num_days_from_sunday(p: &mut Parsed, v: i64) -> ParseResult<()>{\n    p.set_weekday(match v {\n        0 => Weekday::Sun,\n        1 => Weekday::Mon,\n        2 => Weekday::Tue,\n        3 => Weekday::Wed,\n        4 => Weekday::Thu,\n        5 => Weekday::Fri,\n        6 => Weekday::Sat,\n        _ => return Err(OUT_OF_RANGE),\n    })\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parse::set_weekday_with_number_from_monday":["fn set_weekday_with_number_from_monday(p: &mut Parsed, v: i64) -> ParseResult<()>{\n    p.set_weekday(match v {\n        1 => Weekday::Mon,\n        2 => Weekday::Tue,\n        3 => Weekday::Wed,\n        4 => Weekday::Thu,\n        5 => Weekday::Fri,\n        6 => Weekday::Sat,\n        7 => Weekday::Sun,\n        _ => return Err(OUT_OF_RANGE),\n    })\n}","Real(LocalPath(\"src/format/parse.rs\"))"],"format::parsed::Parsed":["/// Parsed parts of date and time. There are two classes of methods:\n///\n/// - `set_*` methods try to set given field(s) while checking for the consistency.\n///   It may or may not check for the range constraint immediately (for efficiency reasons).\n///\n/// - `to_*` methods try to make a concrete date and time value out of set fields.\n///   It fully checks any remaining out-of-range conditions and inconsistent/impossible fields.\n#[allow(clippy::manual_non_exhaustive)]\npub struct Parsed {\n    /// Year.\n    ///\n    /// This can be negative unlike [`year_div_100`](#structfield.year_div_100)\n    /// and [`year_mod_100`](#structfield.year_mod_100) fields.\n    pub year: Option<i32>,\n\n    /// Year divided by 100. Implies that the year is >= 1 BCE when set.\n    ///\n    /// Due to the common usage, if this field is missing but\n    /// [`year_mod_100`](#structfield.year_mod_100) is present,\n    /// it is inferred to 19 when `year_mod_100 >= 70` and 20 otherwise.\n    pub year_div_100: Option<i32>,\n\n    /// Year modulo 100. Implies that the year is >= 1 BCE when set.\n    pub year_mod_100: Option<i32>,\n\n    /// Year in the [ISO week date](../naive/struct.NaiveDate.html#week-date).\n    ///\n    /// This can be negative unlike [`isoyear_div_100`](#structfield.isoyear_div_100) and\n    /// [`isoyear_mod_100`](#structfield.isoyear_mod_100) fields.\n    pub isoyear: Option<i32>,\n\n    /// Year in the [ISO week date](../naive/struct.NaiveDate.html#week-date), divided by 100.\n    /// Implies that the year is >= 1 BCE when set.\n    ///\n    /// Due to the common usage, if this field is missing but\n    /// [`isoyear_mod_100`](#structfield.isoyear_mod_100) is present,\n    /// it is inferred to 19 when `isoyear_mod_100 >= 70` and 20 otherwise.\n    pub isoyear_div_100: Option<i32>,\n\n    /// Year in the [ISO week date](../naive/struct.NaiveDate.html#week-date), modulo 100.\n    /// Implies that the year is >= 1 BCE when set.\n    pub isoyear_mod_100: Option<i32>,\n\n    /// Month (1--12).\n    pub month: Option<u32>,\n\n    /// Week number, where the week 1 starts at the first Sunday of January\n    /// (0--53, 1--53 or 1--52 depending on the year).\n    pub week_from_sun: Option<u32>,\n\n    /// Week number, where the week 1 starts at the first Monday of January\n    /// (0--53, 1--53 or 1--52 depending on the year).\n    pub week_from_mon: Option<u32>,\n\n    /// [ISO week number](../naive/struct.NaiveDate.html#week-date)\n    /// (1--52 or 1--53 depending on the year).\n    pub isoweek: Option<u32>,\n\n    /// Day of the week.\n    pub weekday: Option<Weekday>,\n\n    /// Day of the year (1--365 or 1--366 depending on the year).\n    pub ordinal: Option<u32>,\n\n    /// Day of the month (1--28, 1--29, 1--30 or 1--31 depending on the month).\n    pub day: Option<u32>,\n\n    /// Hour number divided by 12 (0--1). 0 indicates AM and 1 indicates PM.\n    pub hour_div_12: Option<u32>,\n\n    /// Hour number modulo 12 (0--11).\n    pub hour_mod_12: Option<u32>,\n\n    /// Minute number (0--59).\n    pub minute: Option<u32>,\n\n    /// Second number (0--60, accounting for leap seconds).\n    pub second: Option<u32>,\n\n    /// The number of nanoseconds since the whole second (0--999,999,999).\n    pub nanosecond: Option<u32>,\n\n    /// The number of non-leap seconds since the midnight UTC on January 1, 1970.\n    ///\n    /// This can be off by one if [`second`](#structfield.second) is 60 (a leap second).\n    pub timestamp: Option<i64>,\n\n    /// Offset from the local time to UTC, in seconds.\n    pub offset: Option<i32>,\n\n    /// A dummy field to make this type not fully destructible (required for API stability).\n    // TODO: Change this to `#[non_exhaustive]` (on the enum) with the next breaking release.\n    _dummy: (),\n}","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::new":["/// Returns the initial value of parsed parts.\n#[must_use]\npub fn new() -> Parsed{\n        Parsed::default()\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_ampm":["/// Tries to set the [`hour_div_12`](#structfield.hour_div_12) field from given value.\n/// (`false` for AM, `true` for PM)\n#[inline]\npub fn set_ampm(&mut self, value: bool) -> ParseResult<()>{\n        set_if_consistent(&mut self.hour_div_12, u32::from(value))\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_day":["/// Tries to set the [`day`](#structfield.day) field from given value.\n#[inline]\npub fn set_day(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.day, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_hour":["/// Tries to set both [`hour_div_12`](#structfield.hour_div_12) and\n/// [`hour_mod_12`](#structfield.hour_mod_12) fields from given value.\n#[inline]\npub fn set_hour(&mut self, value: i64) -> ParseResult<()>{\n        let v = u32::try_from(value).map_err(|_| OUT_OF_RANGE)?;\n        set_if_consistent(&mut self.hour_div_12, v / 12)?;\n        set_if_consistent(&mut self.hour_mod_12, v % 12)?;\n        Ok(())\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_hour12":["/// Tries to set the [`hour_mod_12`](#structfield.hour_mod_12) field from\n/// given hour number in 12-hour clocks.\n#[inline]\npub fn set_hour12(&mut self, value: i64) -> ParseResult<()>{\n        if !(1..=12).contains(&value) {\n            return Err(OUT_OF_RANGE);\n        }\n        set_if_consistent(&mut self.hour_mod_12, value as u32 % 12)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_isoweek":["/// Tries to set the [`isoweek`](#structfield.isoweek) field from given value.\n#[inline]\npub fn set_isoweek(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.isoweek, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_isoyear":["/// Tries to set the [`isoyear`](#structfield.isoyear) field from given value.\n#[inline]\npub fn set_isoyear(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.isoyear, i32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_isoyear_div_100":["/// Tries to set the [`isoyear_div_100`](#structfield.isoyear_div_100) field from given value.\n#[inline]\npub fn set_isoyear_div_100(&mut self, value: i64) -> ParseResult<()>{\n        if value < 0 {\n            return Err(OUT_OF_RANGE);\n        }\n        set_if_consistent(\n            &mut self.isoyear_div_100,\n            i32::try_from(value).map_err(|_| OUT_OF_RANGE)?,\n        )\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_isoyear_mod_100":["/// Tries to set the [`isoyear_mod_100`](#structfield.isoyear_mod_100) field from given value.\n#[inline]\npub fn set_isoyear_mod_100(&mut self, value: i64) -> ParseResult<()>{\n        if value < 0 {\n            return Err(OUT_OF_RANGE);\n        }\n        set_if_consistent(\n            &mut self.isoyear_mod_100,\n            i32::try_from(value).map_err(|_| OUT_OF_RANGE)?,\n        )\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_minute":["/// Tries to set the [`minute`](#structfield.minute) field from given value.\n#[inline]\npub fn set_minute(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.minute, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_month":["/// Tries to set the [`month`](#structfield.month) field from given value.\n#[inline]\npub fn set_month(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.month, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_nanosecond":["/// Tries to set the [`nanosecond`](#structfield.nanosecond) field from given value.\n#[inline]\npub fn set_nanosecond(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.nanosecond, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_offset":["/// Tries to set the [`offset`](#structfield.offset) field from given value.\n#[inline]\npub fn set_offset(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.offset, i32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_ordinal":["/// Tries to set the [`ordinal`](#structfield.ordinal) field from given value.\n#[inline]\npub fn set_ordinal(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.ordinal, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_second":["/// Tries to set the [`second`](#structfield.second) field from given value.\n#[inline]\npub fn set_second(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.second, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_timestamp":["/// Tries to set the [`timestamp`](#structfield.timestamp) field from given value.\n#[inline]\npub fn set_timestamp(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.timestamp, value)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_week_from_mon":["/// Tries to set the [`week_from_mon`](#structfield.week_from_mon) field from given value.\n#[inline]\npub fn set_week_from_mon(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.week_from_mon, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_week_from_sun":["/// Tries to set the [`week_from_sun`](#structfield.week_from_sun) field from given value.\n#[inline]\npub fn set_week_from_sun(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.week_from_sun, u32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_weekday":["/// Tries to set the [`weekday`](#structfield.weekday) field from given value.\n#[inline]\npub fn set_weekday(&mut self, value: Weekday) -> ParseResult<()>{\n        set_if_consistent(&mut self.weekday, value)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_year":["/// Tries to set the [`year`](#structfield.year) field from given value.\n#[inline]\npub fn set_year(&mut self, value: i64) -> ParseResult<()>{\n        set_if_consistent(&mut self.year, i32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_year_div_100":["/// Tries to set the [`year_div_100`](#structfield.year_div_100) field from given value.\n#[inline]\npub fn set_year_div_100(&mut self, value: i64) -> ParseResult<()>{\n        if value < 0 {\n            return Err(OUT_OF_RANGE);\n        }\n        set_if_consistent(&mut self.year_div_100, i32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::set_year_mod_100":["/// Tries to set the [`year_mod_100`](#structfield.year_mod_100) field from given value.\n#[inline]\npub fn set_year_mod_100(&mut self, value: i64) -> ParseResult<()>{\n        if value < 0 {\n            return Err(OUT_OF_RANGE);\n        }\n        set_if_consistent(&mut self.year_mod_100, i32::try_from(value).map_err(|_| OUT_OF_RANGE)?)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::to_datetime":["/// Returns a parsed timezone-aware date and time out of given fields.\n///\n/// This method is able to determine the combined date and time\n/// from date and time fields or a single [`timestamp`](#structfield.timestamp) field,\n/// plus a time zone offset.\n/// Either way those fields have to be consistent to each other.\npub fn to_datetime(&self) -> ParseResult<DateTime<FixedOffset>>{\n        let offset = self.offset.ok_or(NOT_ENOUGH)?;\n        let datetime = self.to_naive_datetime_with_offset(offset)?;\n        let offset = FixedOffset::east_opt(offset).ok_or(OUT_OF_RANGE)?;\n\n        // this is used to prevent an overflow when calling FixedOffset::from_local_datetime\n        datetime\n            .checked_sub_signed(OldDuration::seconds(i64::from(offset.local_minus_utc())))\n            .ok_or(OUT_OF_RANGE)?;\n\n        match offset.from_local_datetime(&datetime) {\n            LocalResult::None => Err(IMPOSSIBLE),\n            LocalResult::Single(t) => Ok(t),\n            LocalResult::Ambiguous(..) => Err(NOT_ENOUGH),\n        }\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::to_datetime_with_timezone":["/// Returns a parsed timezone-aware date and time out of given fields,\n/// with an additional `TimeZone` used to interpret and validate the local date.\n///\n/// This method is able to determine the combined date and time\n/// from date and time fields or a single [`timestamp`](#structfield.timestamp) field,\n/// plus a time zone offset.\n/// Either way those fields have to be consistent to each other.\n/// If parsed fields include an UTC offset, it also has to be consistent to\n/// [`offset`](#structfield.offset).\npub fn to_datetime_with_timezone<Tz: TimeZone>(&self, tz: &Tz) -> ParseResult<DateTime<Tz>>{\n        // if we have `timestamp` specified, guess an offset from that.\n        let mut guessed_offset = 0;\n        if let Some(timestamp) = self.timestamp {\n            // make a naive `DateTime` from given timestamp and (if any) nanosecond.\n            // an empty `nanosecond` is always equal to zero, so missing nanosecond is fine.\n            let nanosecond = self.nanosecond.unwrap_or(0);\n            let dt = NaiveDateTime::from_timestamp_opt(timestamp, nanosecond);\n            let dt = dt.ok_or(OUT_OF_RANGE)?;\n            guessed_offset = tz.offset_from_utc_datetime(&dt).fix().local_minus_utc();\n        }\n\n        // checks if the given `DateTime` has a consistent `Offset` with given `self.offset`.\n        let check_offset = |dt: &DateTime<Tz>| {\n            if let Some(offset) = self.offset {\n                dt.offset().fix().local_minus_utc() == offset\n            } else {\n                true\n            }\n        };\n\n        // `guessed_offset` should be correct when `self.timestamp` is given.\n        // it will be 0 otherwise, but this is fine as the algorithm ignores offset for that case.\n        let datetime = self.to_naive_datetime_with_offset(guessed_offset)?;\n        match tz.from_local_datetime(&datetime) {\n            LocalResult::None => Err(IMPOSSIBLE),\n            LocalResult::Single(t) => {\n                if check_offset(&t) {\n                    Ok(t)\n                } else {\n                    Err(IMPOSSIBLE)\n                }\n            }\n            LocalResult::Ambiguous(min, max) => {\n                // try to disambiguate two possible local dates by offset.\n                match (check_offset(&min), check_offset(&max)) {\n                    (false, false) => Err(IMPOSSIBLE),\n                    (false, true) => Ok(max),\n                    (true, false) => Ok(min),\n                    (true, true) => Err(NOT_ENOUGH),\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::to_fixed_offset":["/// Returns a parsed fixed time zone offset out of given fields.\npub fn to_fixed_offset(&self) -> ParseResult<FixedOffset>{\n        self.offset.and_then(FixedOffset::east_opt).ok_or(OUT_OF_RANGE)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::to_naive_date":["/// Returns a parsed naive date out of given fields.\n///\n/// This method is able to determine the date from given subset of fields:\n///\n/// - Year, month, day.\n/// - Year, day of the year (ordinal).\n/// - Year, week number counted from Sunday or Monday, day of the week.\n/// - ISO week date.\n///\n/// Gregorian year and ISO week date year can have their century number (`*_div_100`) omitted,\n/// the two-digit year is used to guess the century number then.\npub fn to_naive_date(&self) -> ParseResult<NaiveDate>{\n        fn resolve_year(\n            y: Option<i32>,\n            q: Option<i32>,\n            r: Option<i32>,\n        ) -> ParseResult<Option<i32>> {\n            match (y, q, r) {\n                // if there is no further information, simply return the given full year.\n                // this is a common case, so let's avoid division here.\n                (y, None, None) => Ok(y),\n\n                // if there is a full year *and* also quotient and/or modulo,\n                // check if present quotient and/or modulo is consistent to the full year.\n                // since the presence of those fields means a positive full year,\n                // we should filter a negative full year first.\n                (Some(y), q, r @ Some(0..=99)) | (Some(y), q, r @ None) => {\n                    if y < 0 {\n                        return Err(OUT_OF_RANGE);\n                    }\n                    let q_ = y / 100;\n                    let r_ = y % 100;\n                    if q.unwrap_or(q_) == q_ && r.unwrap_or(r_) == r_ {\n                        Ok(Some(y))\n                    } else {\n                        Err(IMPOSSIBLE)\n                    }\n                }\n\n                // the full year is missing but we have quotient and modulo.\n                // reconstruct the full year. make sure that the result is always positive.\n                (None, Some(q), Some(r @ 0..=99)) => {\n                    if q < 0 {\n                        return Err(OUT_OF_RANGE);\n                    }\n                    let y = q.checked_mul(100).and_then(|v| v.checked_add(r));\n                    Ok(Some(y.ok_or(OUT_OF_RANGE)?))\n                }\n\n                // we only have modulo. try to interpret a modulo as a conventional two-digit year.\n                // note: we are affected by Rust issue #18060. avoid multiple range patterns.\n                (None, None, Some(r @ 0..=99)) => Ok(Some(r + if r < 70 { 2000 } else { 1900 })),\n\n                // otherwise it is an out-of-bound or insufficient condition.\n                (None, Some(_), None) => Err(NOT_ENOUGH),\n                (_, _, Some(_)) => Err(OUT_OF_RANGE),\n            }\n        }\n\n        let given_year = resolve_year(self.year, self.year_div_100, self.year_mod_100)?;\n        let given_isoyear = resolve_year(self.isoyear, self.isoyear_div_100, self.isoyear_mod_100)?;\n\n        // verify the normal year-month-day date.\n        let verify_ymd = |date: NaiveDate| {\n            let year = date.year();\n            let (year_div_100, year_mod_100) = if year >= 0 {\n                (Some(year / 100), Some(year % 100))\n            } else {\n                (None, None) // they should be empty to be consistent\n            };\n            let month = date.month();\n            let day = date.day();\n            self.year.unwrap_or(year) == year\n                && self.year_div_100.or(year_div_100) == year_div_100\n                && self.year_mod_100.or(year_mod_100) == year_mod_100\n                && self.month.unwrap_or(month) == month\n                && self.day.unwrap_or(day) == day\n        };\n\n        // verify the ISO week date.\n        let verify_isoweekdate = |date: NaiveDate| {\n            let week = date.iso_week();\n            let isoyear = week.year();\n            let isoweek = week.week();\n            let weekday = date.weekday();\n            let (isoyear_div_100, isoyear_mod_100) = if isoyear >= 0 {\n                (Some(isoyear / 100), Some(isoyear % 100))\n            } else {\n                (None, None) // they should be empty to be consistent\n            };\n            self.isoyear.unwrap_or(isoyear) == isoyear\n                && self.isoyear_div_100.or(isoyear_div_100) == isoyear_div_100\n                && self.isoyear_mod_100.or(isoyear_mod_100) == isoyear_mod_100\n                && self.isoweek.unwrap_or(isoweek) == isoweek\n                && self.weekday.unwrap_or(weekday) == weekday\n        };\n\n        // verify the ordinal and other (non-ISO) week dates.\n        let verify_ordinal = |date: NaiveDate| {\n            let ordinal = date.ordinal();\n            let week_from_sun = date.weeks_from(Weekday::Sun);\n            let week_from_mon = date.weeks_from(Weekday::Mon);\n            self.ordinal.unwrap_or(ordinal) == ordinal\n                && self.week_from_sun.map_or(week_from_sun, |v| v as i32) == week_from_sun\n                && self.week_from_mon.map_or(week_from_mon, |v| v as i32) == week_from_mon\n        };\n\n        // test several possibilities.\n        // tries to construct a full `NaiveDate` as much as possible, then verifies that\n        // it is consistent with other given fields.\n        let (verified, parsed_date) = match (given_year, given_isoyear, self) {\n            (Some(year), _, &Parsed { month: Some(month), day: Some(day), .. }) => {\n                // year, month, day\n                let date = NaiveDate::from_ymd_opt(year, month, day).ok_or(OUT_OF_RANGE)?;\n                (verify_isoweekdate(date) && verify_ordinal(date), date)\n            }\n\n            (Some(year), _, &Parsed { ordinal: Some(ordinal), .. }) => {\n                // year, day of the year\n                let date = NaiveDate::from_yo_opt(year, ordinal).ok_or(OUT_OF_RANGE)?;\n                (verify_ymd(date) && verify_isoweekdate(date) && verify_ordinal(date), date)\n            }\n\n            (\n                Some(year),\n                _,\n                &Parsed { week_from_sun: Some(week_from_sun), weekday: Some(weekday), .. },\n            ) => {\n                // year, week (starting at 1st Sunday), day of the week\n                let newyear = NaiveDate::from_yo_opt(year, 1).ok_or(OUT_OF_RANGE)?;\n                let firstweek = match newyear.weekday() {\n                    Weekday::Sun => 0,\n                    Weekday::Mon => 6,\n                    Weekday::Tue => 5,\n                    Weekday::Wed => 4,\n                    Weekday::Thu => 3,\n                    Weekday::Fri => 2,\n                    Weekday::Sat => 1,\n                };\n\n                // `firstweek+1`-th day of January is the beginning of the week 1.\n                if week_from_sun > 53 {\n                    return Err(OUT_OF_RANGE);\n                } // can it overflow?\n                let ndays = firstweek\n                    + (week_from_sun as i32 - 1) * 7\n                    + weekday.num_days_from_sunday() as i32;\n                let date = newyear\n                    .checked_add_signed(OldDuration::days(i64::from(ndays)))\n                    .ok_or(OUT_OF_RANGE)?;\n                if date.year() != year {\n                    return Err(OUT_OF_RANGE);\n                } // early exit for correct error\n\n                (verify_ymd(date) && verify_isoweekdate(date) && verify_ordinal(date), date)\n            }\n\n            (\n                Some(year),\n                _,\n                &Parsed { week_from_mon: Some(week_from_mon), weekday: Some(weekday), .. },\n            ) => {\n                // year, week (starting at 1st Monday), day of the week\n                let newyear = NaiveDate::from_yo_opt(year, 1).ok_or(OUT_OF_RANGE)?;\n                let firstweek = match newyear.weekday() {\n                    Weekday::Sun => 1,\n                    Weekday::Mon => 0,\n                    Weekday::Tue => 6,\n                    Weekday::Wed => 5,\n                    Weekday::Thu => 4,\n                    Weekday::Fri => 3,\n                    Weekday::Sat => 2,\n                };\n\n                // `firstweek+1`-th day of January is the beginning of the week 1.\n                if week_from_mon > 53 {\n                    return Err(OUT_OF_RANGE);\n                } // can it overflow?\n                let ndays = firstweek\n                    + (week_from_mon as i32 - 1) * 7\n                    + weekday.num_days_from_monday() as i32;\n                let date = newyear\n                    .checked_add_signed(OldDuration::days(i64::from(ndays)))\n                    .ok_or(OUT_OF_RANGE)?;\n                if date.year() != year {\n                    return Err(OUT_OF_RANGE);\n                } // early exit for correct error\n\n                (verify_ymd(date) && verify_isoweekdate(date) && verify_ordinal(date), date)\n            }\n\n            (_, Some(isoyear), &Parsed { isoweek: Some(isoweek), weekday: Some(weekday), .. }) => {\n                // ISO year, week, day of the week\n                let date = NaiveDate::from_isoywd_opt(isoyear, isoweek, weekday);\n                let date = date.ok_or(OUT_OF_RANGE)?;\n                (verify_ymd(date) && verify_ordinal(date), date)\n            }\n\n            (_, _, _) => return Err(NOT_ENOUGH),\n        };\n\n        if verified {\n            Ok(parsed_date)\n        } else {\n            Err(IMPOSSIBLE)\n        }\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::to_naive_date::resolve_year":["fn resolve_year(\n            y: Option<i32>,\n            q: Option<i32>,\n            r: Option<i32>,\n        ) -> ParseResult<Option<i32>>{\n            match (y, q, r) {\n                // if there is no further information, simply return the given full year.\n                // this is a common case, so let's avoid division here.\n                (y, None, None) => Ok(y),\n\n                // if there is a full year *and* also quotient and/or modulo,\n                // check if present quotient and/or modulo is consistent to the full year.\n                // since the presence of those fields means a positive full year,\n                // we should filter a negative full year first.\n                (Some(y), q, r @ Some(0..=99)) | (Some(y), q, r @ None) => {\n                    if y < 0 {\n                        return Err(OUT_OF_RANGE);\n                    }\n                    let q_ = y / 100;\n                    let r_ = y % 100;\n                    if q.unwrap_or(q_) == q_ && r.unwrap_or(r_) == r_ {\n                        Ok(Some(y))\n                    } else {\n                        Err(IMPOSSIBLE)\n                    }\n                }\n\n                // the full year is missing but we have quotient and modulo.\n                // reconstruct the full year. make sure that the result is always positive.\n                (None, Some(q), Some(r @ 0..=99)) => {\n                    if q < 0 {\n                        return Err(OUT_OF_RANGE);\n                    }\n                    let y = q.checked_mul(100).and_then(|v| v.checked_add(r));\n                    Ok(Some(y.ok_or(OUT_OF_RANGE)?))\n                }\n\n                // we only have modulo. try to interpret a modulo as a conventional two-digit year.\n                // note: we are affected by Rust issue #18060. avoid multiple range patterns.\n                (None, None, Some(r @ 0..=99)) => Ok(Some(r + if r < 70 { 2000 } else { 1900 })),\n\n                // otherwise it is an out-of-bound or insufficient condition.\n                (None, Some(_), None) => Err(NOT_ENOUGH),\n                (_, _, Some(_)) => Err(OUT_OF_RANGE),\n            }\n        }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::to_naive_datetime_with_offset":["/// Returns a parsed naive date and time out of given fields,\n/// except for the [`offset`](#structfield.offset) field (assumed to have a given value).\n/// This is required for parsing a local time or other known-timezone inputs.\n///\n/// This method is able to determine the combined date and time\n/// from date and time fields or a single [`timestamp`](#structfield.timestamp) field.\n/// Either way those fields have to be consistent to each other.\npub fn to_naive_datetime_with_offset(&self, offset: i32) -> ParseResult<NaiveDateTime>{\n        let date = self.to_naive_date();\n        let time = self.to_naive_time();\n        if let (Ok(date), Ok(time)) = (date, time) {\n            let datetime = date.and_time(time);\n\n            // verify the timestamp field if any\n            // the following is safe, `timestamp` is very limited in range\n            let timestamp = datetime.timestamp() - i64::from(offset);\n            if let Some(given_timestamp) = self.timestamp {\n                // if `datetime` represents a leap second, it might be off by one second.\n                if given_timestamp != timestamp\n                    && !(datetime.nanosecond() >= 1_000_000_000 && given_timestamp == timestamp + 1)\n                {\n                    return Err(IMPOSSIBLE);\n                }\n            }\n\n            Ok(datetime)\n        } else if let Some(timestamp) = self.timestamp {\n            use super::ParseError as PE;\n            use super::ParseErrorKind::{Impossible, OutOfRange};\n\n            // if date and time is problematic already, there is no point proceeding.\n            // we at least try to give a correct error though.\n            match (date, time) {\n                (Err(PE(OutOfRange)), _) | (_, Err(PE(OutOfRange))) => return Err(OUT_OF_RANGE),\n                (Err(PE(Impossible)), _) | (_, Err(PE(Impossible))) => return Err(IMPOSSIBLE),\n                (_, _) => {} // one of them is insufficient\n            }\n\n            // reconstruct date and time fields from timestamp\n            let ts = timestamp.checked_add(i64::from(offset)).ok_or(OUT_OF_RANGE)?;\n            let datetime = NaiveDateTime::from_timestamp_opt(ts, 0);\n            let mut datetime = datetime.ok_or(OUT_OF_RANGE)?;\n\n            // fill year, ordinal, hour, minute and second fields from timestamp.\n            // if existing fields are consistent, this will allow the full date/time reconstruction.\n            let mut parsed = self.clone();\n            if parsed.second == Some(60) {\n                // `datetime.second()` cannot be 60, so this is the only case for a leap second.\n                match datetime.second() {\n                    // it's okay, just do not try to overwrite the existing field.\n                    59 => {}\n                    // `datetime` is known to be off by one second.\n                    0 => {\n                        datetime -= OldDuration::seconds(1);\n                    }\n                    // otherwise it is impossible.\n                    _ => return Err(IMPOSSIBLE),\n                }\n            // ...and we have the correct candidates for other fields.\n            } else {\n                parsed.set_second(i64::from(datetime.second()))?;\n            }\n            parsed.set_year(i64::from(datetime.year()))?;\n            parsed.set_ordinal(i64::from(datetime.ordinal()))?; // more efficient than ymd\n            parsed.set_hour(i64::from(datetime.hour()))?;\n            parsed.set_minute(i64::from(datetime.minute()))?;\n\n            // validate other fields (e.g. week) and return\n            let date = parsed.to_naive_date()?;\n            let time = parsed.to_naive_time()?;\n            Ok(date.and_time(time))\n        } else {\n            // reproduce the previous error(s)\n            date?;\n            time?;\n            unreachable!()\n        }\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::Parsed::to_naive_time":["/// Returns a parsed naive time out of given fields.\n///\n/// This method is able to determine the time from given subset of fields:\n///\n/// - Hour, minute. (second and nanosecond assumed to be 0)\n/// - Hour, minute, second. (nanosecond assumed to be 0)\n/// - Hour, minute, second, nanosecond.\n///\n/// It is able to handle leap seconds when given second is 60.\npub fn to_naive_time(&self) -> ParseResult<NaiveTime>{\n        let hour_div_12 = match self.hour_div_12 {\n            Some(v @ 0..=1) => v,\n            Some(_) => return Err(OUT_OF_RANGE),\n            None => return Err(NOT_ENOUGH),\n        };\n        let hour_mod_12 = match self.hour_mod_12 {\n            Some(v @ 0..=11) => v,\n            Some(_) => return Err(OUT_OF_RANGE),\n            None => return Err(NOT_ENOUGH),\n        };\n        let hour = hour_div_12 * 12 + hour_mod_12;\n\n        let minute = match self.minute {\n            Some(v @ 0..=59) => v,\n            Some(_) => return Err(OUT_OF_RANGE),\n            None => return Err(NOT_ENOUGH),\n        };\n\n        // we allow omitting seconds or nanoseconds, but they should be in the range.\n        let (second, mut nano) = match self.second.unwrap_or(0) {\n            v @ 0..=59 => (v, 0),\n            60 => (59, 1_000_000_000),\n            _ => return Err(OUT_OF_RANGE),\n        };\n        nano += match self.nanosecond {\n            Some(v @ 0..=999_999_999) if self.second.is_some() => v,\n            Some(0..=999_999_999) => return Err(NOT_ENOUGH), // second is missing\n            Some(_) => return Err(OUT_OF_RANGE),\n            None => 0,\n        };\n\n        NaiveTime::from_hms_nano_opt(hour, minute, second, nano).ok_or(OUT_OF_RANGE)\n    }","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::parsed::set_if_consistent":["/// Checks if `old` is either empty or has the same value as `new` (i.e. \"consistent\"),\n/// and if it is empty, set `old` to `new` as well.\n#[inline]\nfn set_if_consistent<T: PartialEq>(old: &mut Option<T>, new: T) -> ParseResult<()>{\n    if let Some(ref old) = *old {\n        if *old == new {\n            Ok(())\n        } else {\n            Err(IMPOSSIBLE)\n        }\n    } else {\n        *old = Some(new);\n        Ok(())\n    }\n}","Real(LocalPath(\"src/format/parsed.rs\"))"],"format::scan::CommentState":["enum CommentState {\n    Start,\n    Next(usize),\n    Escape(usize),\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::char":["/// Tries to consume exactly one given character.\npub(super) fn char(s: &str, c1: u8) -> ParseResult<&str>{\n    match s.as_bytes().first() {\n        Some(&c) if c == c1 => Ok(&s[1..]),\n        Some(_) => Err(INVALID),\n        None => Err(TOO_SHORT),\n    }\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::comment_2822":["/// Tries to consume an RFC2822 comment including preceding ` `.\n///\n/// Returns the remaining string after the closing parenthesis.\npub(super) fn comment_2822(s: &str) -> ParseResult<(&str, ())>{\n    use CommentState::*;\n\n    let s = s.trim_start();\n\n    let mut state = Start;\n    for (i, c) in s.bytes().enumerate() {\n        state = match (state, c) {\n            (Start, b'(') => Next(1),\n            (Next(1), b')') => return Ok((&s[i + 1..], ())),\n            (Next(depth), b'\\\\') => Escape(depth),\n            (Next(depth), b'(') => Next(depth + 1),\n            (Next(depth), b')') => Next(depth - 1),\n            (Next(depth), _) | (Escape(depth), _) => Next(depth),\n            _ => return Err(INVALID),\n        };\n    }\n\n    Err(TOO_SHORT)\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::consume_colon_maybe":["/// Consumes one colon char `:` if it is at the front of `s`.\n/// Always returns `Ok(s)`.\npub(super) fn consume_colon_maybe(mut s: &str) -> ParseResult<&str>{\n    if s.is_empty() {\n        // nothing consumed\n        return Ok(s);\n    }\n\n    if s.starts_with(':') {\n        s = s_next(s);\n        // consumed `':'`\n    }\n\n    Ok(s)\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::equals":["/// Returns true when two slices are equal case-insensitively (in ASCII).\n/// Assumes that the `pattern` is already converted to lower case.\nfn equals(s: &[u8], pattern: &str) -> bool{\n    let mut xs = s.iter().map(|&c| match c {\n        b'A'..=b'Z' => c + 32,\n        _ => c,\n    });\n    let mut ys = pattern.as_bytes().iter().cloned();\n    loop {\n        match (xs.next(), ys.next()) {\n            (None, None) => return true,\n            (None, _) | (_, None) => return false,\n            (Some(x), Some(y)) if x != y => return false,\n            _ => (),\n        }\n    }\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::nanosecond":["/// Tries to consume at least one digits as a fractional second.\n/// Returns the number of whole nanoseconds (0--999,999,999).\npub(super) fn nanosecond(s: &str) -> ParseResult<(&str, i64)>{\n    // record the number of digits consumed for later scaling.\n    let origlen = s.len();\n    let (s, v) = number(s, 1, 9)?;\n    let consumed = origlen - s.len();\n\n    // scale the number accordingly.\n    static SCALE: [i64; 10] =\n        [0, 100_000_000, 10_000_000, 1_000_000, 100_000, 10_000, 1_000, 100, 10, 1];\n    let v = v.checked_mul(SCALE[consumed]).ok_or(OUT_OF_RANGE)?;\n\n    // if there are more than 9 digits, skip next digits.\n    let s = s.trim_left_matches(|c: char| c.is_ascii_digit());\n\n    Ok((s, v))\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::nanosecond_fixed":["/// Tries to consume a fixed number of digits as a fractional second.\n/// Returns the number of whole nanoseconds (0--999,999,999).\npub(super) fn nanosecond_fixed(s: &str, digits: usize) -> ParseResult<(&str, i64)>{\n    // record the number of digits consumed for later scaling.\n    let (s, v) = number(s, digits, digits)?;\n\n    // scale the number accordingly.\n    static SCALE: [i64; 10] =\n        [0, 100_000_000, 10_000_000, 1_000_000, 100_000, 10_000, 1_000, 100, 10, 1];\n    let v = v.checked_mul(SCALE[digits]).ok_or(OUT_OF_RANGE)?;\n\n    Ok((s, v))\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::number":["/// Tries to parse the non-negative number from `min` to `max` digits.\n///\n/// The absence of digits at all is an unconditional error.\n/// More than `max` digits are consumed up to the first `max` digits.\n/// Any number that does not fit in `i64` is an error.\n#[inline]\npub(super) fn number(s: &str, min: usize, max: usize) -> ParseResult<(&str, i64)>{\n    assert!(min <= max);\n\n    // We are only interested in ascii numbers, so we can work with the `str` as bytes. We stop on\n    // the first non-numeric byte, which may be another ascii character or beginning of multi-byte\n    // UTF-8 character.\n    let bytes = s.as_bytes();\n    if bytes.len() < min {\n        return Err(TOO_SHORT);\n    }\n\n    let mut n = 0i64;\n    for (i, c) in bytes.iter().take(max).cloned().enumerate() {\n        // cloned() = copied()\n        if !c.is_ascii_digit() {\n            if i < min {\n                return Err(INVALID);\n            } else {\n                return Ok((&s[i..], n));\n            }\n        }\n\n        n = match n.checked_mul(10).and_then(|n| n.checked_add((c - b'0') as i64)) {\n            Some(n) => n,\n            None => return Err(OUT_OF_RANGE),\n        };\n    }\n\n    Ok((&s[core::cmp::min(max, bytes.len())..], n))\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::s_next":["/// Returns slice remaining after first char.\n/// If <=1 chars in `s` then return an empty slice\npub(super) fn s_next(s: &str) -> &str{\n    match s.char_indices().nth(1) {\n        Some((offset, _)) => &s[offset..],\n        None => {\n            // one or zero chars in `s`, return empty string\n            &s[s.len()..]\n        }\n    }\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::short_month0":["/// Tries to parse the month index (0 through 11) with the first three ASCII letters.\npub(super) fn short_month0(s: &str) -> ParseResult<(&str, u8)>{\n    if s.len() < 3 {\n        return Err(TOO_SHORT);\n    }\n    let buf = s.as_bytes();\n    let month0 = match (buf[0] | 32, buf[1] | 32, buf[2] | 32) {\n        (b'j', b'a', b'n') => 0,\n        (b'f', b'e', b'b') => 1,\n        (b'm', b'a', b'r') => 2,\n        (b'a', b'p', b'r') => 3,\n        (b'm', b'a', b'y') => 4,\n        (b'j', b'u', b'n') => 5,\n        (b'j', b'u', b'l') => 6,\n        (b'a', b'u', b'g') => 7,\n        (b's', b'e', b'p') => 8,\n        (b'o', b'c', b't') => 9,\n        (b'n', b'o', b'v') => 10,\n        (b'd', b'e', b'c') => 11,\n        _ => return Err(INVALID),\n    };\n    Ok((&s[3..], month0))\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::short_or_long_month0":["/// Tries to parse the month index (0 through 11) with short or long month names.\n/// It prefers long month names to short month names when both are possible.\npub(super) fn short_or_long_month0(s: &str) -> ParseResult<(&str, u8)>{\n    // lowercased month names, minus first three chars\n    static LONG_MONTH_SUFFIXES: [&str; 12] =\n        [\"uary\", \"ruary\", \"ch\", \"il\", \"\", \"e\", \"y\", \"ust\", \"tember\", \"ober\", \"ember\", \"ember\"];\n\n    let (mut s, month0) = short_month0(s)?;\n\n    // tries to consume the suffix if possible\n    let suffix = LONG_MONTH_SUFFIXES[month0 as usize];\n    if s.len() >= suffix.len() && equals(&s.as_bytes()[..suffix.len()], suffix) {\n        s = &s[suffix.len()..];\n    }\n\n    Ok((s, month0))\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::short_or_long_weekday":["/// Tries to parse the weekday with short or long weekday names.\n/// It prefers long weekday names to short weekday names when both are possible.\npub(super) fn short_or_long_weekday(s: &str) -> ParseResult<(&str, Weekday)>{\n    // lowercased weekday names, minus first three chars\n    static LONG_WEEKDAY_SUFFIXES: [&str; 7] =\n        [\"day\", \"sday\", \"nesday\", \"rsday\", \"day\", \"urday\", \"day\"];\n\n    let (mut s, weekday) = short_weekday(s)?;\n\n    // tries to consume the suffix if possible\n    let suffix = LONG_WEEKDAY_SUFFIXES[weekday.num_days_from_monday() as usize];\n    if s.len() >= suffix.len() && equals(&s.as_bytes()[..suffix.len()], suffix) {\n        s = &s[suffix.len()..];\n    }\n\n    Ok((s, weekday))\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::short_weekday":["/// Tries to parse the weekday with the first three ASCII letters.\npub(super) fn short_weekday(s: &str) -> ParseResult<(&str, Weekday)>{\n    if s.len() < 3 {\n        return Err(TOO_SHORT);\n    }\n    let buf = s.as_bytes();\n    let weekday = match (buf[0] | 32, buf[1] | 32, buf[2] | 32) {\n        (b'm', b'o', b'n') => Weekday::Mon,\n        (b't', b'u', b'e') => Weekday::Tue,\n        (b'w', b'e', b'd') => Weekday::Wed,\n        (b't', b'h', b'u') => Weekday::Thu,\n        (b'f', b'r', b'i') => Weekday::Fri,\n        (b's', b'a', b't') => Weekday::Sat,\n        (b's', b'u', b'n') => Weekday::Sun,\n        _ => return Err(INVALID),\n    };\n    Ok((&s[3..], weekday))\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::space":["/// Tries to consume one or more whitespace.\npub(super) fn space(s: &str) -> ParseResult<&str>{\n    let s_ = s.trim_left();\n    if s_.len() < s.len() {\n        Ok(s_)\n    } else if s.is_empty() {\n        Err(TOO_SHORT)\n    } else {\n        Err(INVALID)\n    }\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::timezone_name_skip":["/// Tries to consume everything until next whitespace-like symbol.\n/// Does not provide any offset information from the consumed data.\npub(super) fn timezone_name_skip(s: &str) -> ParseResult<(&str, ())>{\n    Ok((s.trim_left_matches(|c: char| !c.is_whitespace()), ()))\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::timezone_offset":["/// Tries to parse `[-+]\\d\\d` continued by `\\d\\d`. Return an offset in seconds if possible.\n///\n/// The additional `colon` may be used to parse a mandatory or optional `:`\n/// between hours and minutes, and should return either a new suffix or `Err` when parsing fails.\npub(super) fn timezone_offset<F>(s: &str, consume_colon: F) -> ParseResult<(&str, i32)>\nwhere\n    F: FnMut(&str) -> ParseResult<&str>,{\n    timezone_offset_internal(s, consume_colon, false)\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::timezone_offset_2822":["/// Same as `timezone_offset` but also allows for RFC 2822 legacy timezones.\n/// May return `None` which indicates an insufficient offset data (i.e. `-0000`).\n/// See [RFC 2822 Section 4.3].\n///\n/// [RFC 2822 Section 4.3]: https://tools.ietf.org/html/rfc2822#section-4.3\npub(super) fn timezone_offset_2822(s: &str) -> ParseResult<(&str, Option<i32>)>{\n    // tries to parse legacy time zone names\n    let upto = s.as_bytes().iter().position(|&c| !c.is_ascii_alphabetic()).unwrap_or(s.len());\n    if upto > 0 {\n        let name = &s.as_bytes()[..upto];\n        let s = &s[upto..];\n        let offset_hours = |o| Ok((s, Some(o * 3600)));\n        if equals(name, \"gmt\") || equals(name, \"ut\") {\n            offset_hours(0)\n        } else if equals(name, \"edt\") {\n            offset_hours(-4)\n        } else if equals(name, \"est\") || equals(name, \"cdt\") {\n            offset_hours(-5)\n        } else if equals(name, \"cst\") || equals(name, \"mdt\") {\n            offset_hours(-6)\n        } else if equals(name, \"mst\") || equals(name, \"pdt\") {\n            offset_hours(-7)\n        } else if equals(name, \"pst\") {\n            offset_hours(-8)\n        } else if name.len() == 1 {\n            match name[0] {\n                // recommended by RFC 2822: consume but treat it as -0000\n                b'a'..=b'i' | b'k'..=b'z' | b'A'..=b'I' | b'K'..=b'Z' => offset_hours(0),\n                _ => Ok((s, None)),\n            }\n        } else {\n            Ok((s, None))\n        }\n    } else {\n        let (s_, offset) = timezone_offset(s, |s| Ok(s))?;\n        Ok((s_, Some(offset)))\n    }\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::timezone_offset_internal":["fn timezone_offset_internal<F>(\n    mut s: &str,\n    mut consume_colon: F,\n    allow_missing_minutes: bool,\n) -> ParseResult<(&str, i32)>\nwhere\n    F: FnMut(&str) -> ParseResult<&str>,{\n    const fn digits(s: &str) -> ParseResult<(u8, u8)> {\n        let b = s.as_bytes();\n        if b.len() < 2 {\n            Err(TOO_SHORT)\n        } else {\n            Ok((b[0], b[1]))\n        }\n    }\n    let negative = match s.as_bytes().first() {\n        Some(&b'+') => false,\n        Some(&b'-') => true,\n        Some(_) => return Err(INVALID),\n        None => return Err(TOO_SHORT),\n    };\n    s = &s[1..];\n\n    // hours (00--99)\n    let hours = match digits(s)? {\n        (h1 @ b'0'..=b'9', h2 @ b'0'..=b'9') => i32::from((h1 - b'0') * 10 + (h2 - b'0')),\n        _ => return Err(INVALID),\n    };\n    s = &s[2..];\n\n    // colons (and possibly other separators)\n    s = consume_colon(s)?;\n\n    // minutes (00--59)\n    // if the next two items are digits then we have to add minutes\n    let minutes = if let Ok(ds) = digits(s) {\n        match ds {\n            (m1 @ b'0'..=b'5', m2 @ b'0'..=b'9') => i32::from((m1 - b'0') * 10 + (m2 - b'0')),\n            (b'6'..=b'9', b'0'..=b'9') => return Err(OUT_OF_RANGE),\n            _ => return Err(INVALID),\n        }\n    } else if allow_missing_minutes {\n        0\n    } else {\n        return Err(TOO_SHORT);\n    };\n    s = match s.len() {\n        len if len >= 2 => &s[2..],\n        len if len == 0 => s,\n        _ => return Err(TOO_SHORT),\n    };\n\n    let seconds = hours * 3600 + minutes * 60;\n    Ok((s, if negative { -seconds } else { seconds }))\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::timezone_offset_internal::digits":["const fn digits(s: &str) -> ParseResult<(u8, u8)>{\n        let b = s.as_bytes();\n        if b.len() < 2 {\n            Err(TOO_SHORT)\n        } else {\n            Ok((b[0], b[1]))\n        }\n    }","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::timezone_offset_permissive":["/// Same as `timezone_offset` but also allows for `z`/`Z` which is the same as\n/// `+00:00`, and allows missing minutes entirely.\npub(super) fn timezone_offset_permissive<F>(s: &str, colon: F) -> ParseResult<(&str, i32)>\nwhere\n    F: FnMut(&str) -> ParseResult<&str>,{\n    match s.as_bytes().first() {\n        Some(&b'z') | Some(&b'Z') => Ok((&s[1..], 0)),\n        _ => timezone_offset_internal(s, colon, true),\n    }\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::timezone_offset_zulu":["/// Same as `timezone_offset` but also allows for `z`/`Z` which is the same as `+00:00`.\npub(super) fn timezone_offset_zulu<F>(s: &str, colon: F) -> ParseResult<(&str, i32)>\nwhere\n    F: FnMut(&str) -> ParseResult<&str>,{\n    let bytes = s.as_bytes();\n    match bytes.first() {\n        Some(&b'z') | Some(&b'Z') => Ok((&s[1..], 0)),\n        Some(&b'u') | Some(&b'U') => {\n            if bytes.len() >= 3 {\n                let (b, c) = (bytes[1], bytes[2]);\n                match (b | 32, c | 32) {\n                    (b't', b'c') => Ok((&s[3..], 0)),\n                    _ => Err(INVALID),\n                }\n            } else {\n                Err(INVALID)\n            }\n        }\n        _ => timezone_offset(s, colon),\n    }\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::scan::trim1":["/// If the first `char` is whitespace then consume it and return `s`.\n/// Else return `s`.\npub(super) fn trim1(s: &str) -> &str{\n    match s.chars().next() {\n        Some(c) if c.is_whitespace() => s_next(s),\n        Some(_) | None => s,\n    }\n}","Real(LocalPath(\"src/format/scan.rs\"))"],"format::strftime::StrftimeItems":["/// Parsing iterator for `strftime`-like format strings.\npub struct StrftimeItems<'a> {\n    /// Remaining portion of the string.\n    remainder: &'a str,\n    /// If the current specifier is composed of multiple formatting items (e.g. `%+`),\n    /// parser refers to the statically reconstructed slice of them.\n    /// If `recons` is not empty they have to be returned earlier than the `remainder`.\n    recons: Fmt<'a>,\n    /// Date format\n    d_fmt: Fmt<'a>,\n    /// Date and time format\n    d_t_fmt: Fmt<'a>,\n    /// Time format\n    t_fmt: Fmt<'a>,\n}","Real(LocalPath(\"src/format/strftime.rs\"))"],"format::strftime::StrftimeItems::<'a>::new":["/// Creates a new parsing iterator from the `strftime`-like format string.\n#[must_use]\npub fn new(s: &'a str) -> StrftimeItems<'a>{\n        Self::with_remainer(s)\n    }","Real(LocalPath(\"src/format/strftime.rs\"))"],"format::strftime::StrftimeItems::<'a>::with_remainer":["#[cfg(not(feature = \"unstable-locales\"))]\nfn with_remainer(s: &'a str) -> StrftimeItems<'a>{\n        static FMT_NONE: &[Item<'static>; 0] = &[];\n\n        StrftimeItems {\n            remainder: s,\n            recons: FMT_NONE,\n            d_fmt: D_FMT,\n            d_t_fmt: D_T_FMT,\n            t_fmt: T_FMT,\n        }\n    }","Real(LocalPath(\"src/format/strftime.rs\"))"],"format::write_hundreds":["/// Equivalent to `{:02}` formatting for n < 100.\npub(crate) fn write_hundreds(w: &mut impl Write, n: u8) -> fmt::Result{\n    if n >= 100 {\n        return Err(fmt::Error);\n    }\n\n    let tens = b'0' + n / 10;\n    let ones = b'0' + n % 10;\n    w.write_char(tens as char)?;\n    w.write_char(ones as char)\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::write_local_minus_utc":["/// Prints an offset from UTC in the format of `+HHMM` or `+HH:MM`.\n/// `Z` instead of `+00[:]00` is allowed when `allow_zulu` is true.\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\nfn write_local_minus_utc(\n    result: &mut String,\n    off: FixedOffset,\n    allow_zulu: bool,\n    colon_type: Colons,\n) -> fmt::Result{\n    let off = off.local_minus_utc();\n    if allow_zulu && off == 0 {\n        result.push('Z');\n        return Ok(());\n    }\n    let (sign, off) = if off < 0 { ('-', -off) } else { ('+', off) };\n    result.push(sign);\n\n    write_hundreds(result, (off / 3600) as u8)?;\n\n    match colon_type {\n        Colons::None => write_hundreds(result, (off / 60 % 60) as u8),\n        Colons::Single => {\n            result.push(':');\n            write_hundreds(result, (off / 60 % 60) as u8)\n        }\n        Colons::Double => {\n            result.push(':');\n            write_hundreds(result, (off / 60 % 60) as u8)?;\n            result.push(':');\n            write_hundreds(result, (off % 60) as u8)\n        }\n        Colons::Triple => Ok(()),\n    }\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::write_rfc2822":["#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n/// write datetimes like `Tue, 1 Jul 2003 10:52:37 +0200`, same as `%a, %d %b %Y %H:%M:%S %z`\npub(crate) fn write_rfc2822(\n    result: &mut String,\n    dt: crate::NaiveDateTime,\n    off: FixedOffset,\n) -> fmt::Result{\n    write_rfc2822_inner(result, &dt.date(), &dt.time(), off, Locales::new(None))\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::write_rfc2822_inner":["#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n/// write datetimes like `Tue, 1 Jul 2003 10:52:37 +0200`, same as `%a, %d %b %Y %H:%M:%S %z`\nfn write_rfc2822_inner(\n    result: &mut String,\n    d: &NaiveDate,\n    t: &NaiveTime,\n    off: FixedOffset,\n    locale: Locales,\n) -> fmt::Result{\n    let year = d.year();\n    // RFC2822 is only defined on years 0 through 9999\n    if !(0..=9999).contains(&year) {\n        return Err(fmt::Error);\n    }\n\n    result.push_str(locale.short_weekdays[d.weekday().num_days_from_sunday() as usize]);\n    result.push_str(\", \");\n    write_hundreds(result, d.day() as u8)?;\n    result.push(' ');\n    result.push_str(locale.short_months[d.month0() as usize]);\n    result.push(' ');\n    write_hundreds(result, (year / 100) as u8)?;\n    write_hundreds(result, (year % 100) as u8)?;\n    result.push(' ');\n    write_hundreds(result, t.hour() as u8)?;\n    result.push(':');\n    write_hundreds(result, t.minute() as u8)?;\n    result.push(':');\n    let sec = t.second() + t.nanosecond() / 1_000_000_000;\n    write_hundreds(result, sec as u8)?;\n    result.push(' ');\n    write_local_minus_utc(result, off, false, Colons::None)\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"format::write_rfc3339":["/// Writes the date, time and offset to the string. same as `%Y-%m-%dT%H:%M:%S%.f%:z`\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub(crate) fn write_rfc3339(\n    result: &mut String,\n    dt: crate::NaiveDateTime,\n    off: FixedOffset,\n) -> fmt::Result{\n    // reuse `Debug` impls which already print ISO 8601 format.\n    // this is faster in this way.\n    write!(result, \"{:?}\", dt)?;\n    write_local_minus_utc(result, off, false, Colons::Single)\n}","Real(LocalPath(\"src/format/mod.rs\"))"],"month::Month":["/// The month of the year.\n///\n/// This enum is just a convenience implementation.\n/// The month in dates created by DateLike objects does not return this enum.\n///\n/// It is possible to convert from a date to a month independently\n/// ```\n/// # use std::convert::TryFrom;\n/// use chrono::prelude::*;\n/// let date = Utc.with_ymd_and_hms(2019, 10, 28, 9, 10, 11).unwrap();\n/// // `2019-10-28T09:10:11Z`\n/// let month = Month::try_from(u8::try_from(date.month()).unwrap()).ok();\n/// assert_eq!(month, Some(Month::October))\n/// ```\n/// Or from a Month to an integer usable by dates\n/// ```\n/// # use chrono::prelude::*;\n/// let month = Month::January;\n/// let dt = Utc.with_ymd_and_hms(2019, month.number_from_month(), 28, 9, 10, 11).unwrap();\n/// assert_eq!((dt.year(), dt.month(), dt.day()), (2019, 1, 28));\n/// ```\n/// Allows mapping from and to month, from 1-January to 12-December.\n/// Can be Serialized/Deserialized with serde\npub enum Month {\n    /// January\n    January = 0,\n    /// February\n    February = 1,\n    /// March\n    March = 2,\n    /// April\n    April = 3,\n    /// May\n    May = 4,\n    /// June\n    June = 5,\n    /// July\n    July = 6,\n    /// August\n    August = 7,\n    /// September\n    September = 8,\n    /// October\n    October = 9,\n    /// November\n    November = 10,\n    /// December\n    December = 11,\n}","Real(LocalPath(\"src/month.rs\"))"],"month::Month::name":["/// Get the name of the month\n///\n/// ```\n/// use chrono::Month;\n///\n/// assert_eq!(Month::January.name(), \"January\")\n/// ```\n#[must_use]\npub const fn name(&self) -> &'static str{\n        match *self {\n            Month::January => \"January\",\n            Month::February => \"February\",\n            Month::March => \"March\",\n            Month::April => \"April\",\n            Month::May => \"May\",\n            Month::June => \"June\",\n            Month::July => \"July\",\n            Month::August => \"August\",\n            Month::September => \"September\",\n            Month::October => \"October\",\n            Month::November => \"November\",\n            Month::December => \"December\",\n        }\n    }","Real(LocalPath(\"src/month.rs\"))"],"month::Month::number_from_month":["/// Returns a month-of-year number starting from January = 1.\n///\n/// `m`:                     | `January` | `February` | `...` | `December`\n/// -------------------------| --------- | ---------- | --- | -----\n/// `m.number_from_month()`: | 1         | 2          | `...` | 12\n#[inline]\n#[must_use]\npub const fn number_from_month(&self) -> u32{\n        match *self {\n            Month::January => 1,\n            Month::February => 2,\n            Month::March => 3,\n            Month::April => 4,\n            Month::May => 5,\n            Month::June => 6,\n            Month::July => 7,\n            Month::August => 8,\n            Month::September => 9,\n            Month::October => 10,\n            Month::November => 11,\n            Month::December => 12,\n        }\n    }","Real(LocalPath(\"src/month.rs\"))"],"month::Month::pred":["/// The previous month.\n///\n/// `m`:        | `January`  | `February` | `...` | `December`\n/// ----------- | ---------  | ---------- | --- | ---------\n/// `m.pred()`: | `December` | `January`  | `...` | `November`\n#[inline]\n#[must_use]\npub const fn pred(&self) -> Month{\n        match *self {\n            Month::January => Month::December,\n            Month::February => Month::January,\n            Month::March => Month::February,\n            Month::April => Month::March,\n            Month::May => Month::April,\n            Month::June => Month::May,\n            Month::July => Month::June,\n            Month::August => Month::July,\n            Month::September => Month::August,\n            Month::October => Month::September,\n            Month::November => Month::October,\n            Month::December => Month::November,\n        }\n    }","Real(LocalPath(\"src/month.rs\"))"],"month::Month::succ":["/// The next month.\n///\n/// `m`:        | `January`  | `February` | `...` | `December`\n/// ----------- | ---------  | ---------- | --- | ---------\n/// `m.succ()`: | `February` | `March`    | `...` | `January`\n#[inline]\n#[must_use]\npub const fn succ(&self) -> Month{\n        match *self {\n            Month::January => Month::February,\n            Month::February => Month::March,\n            Month::March => Month::April,\n            Month::April => Month::May,\n            Month::May => Month::June,\n            Month::June => Month::July,\n            Month::July => Month::August,\n            Month::August => Month::September,\n            Month::September => Month::October,\n            Month::October => Month::November,\n            Month::November => Month::December,\n            Month::December => Month::January,\n        }\n    }","Real(LocalPath(\"src/month.rs\"))"],"month::Months":["/// A duration in calendar months\npub struct Months(pub(crate) u32);","Real(LocalPath(\"src/month.rs\"))"],"month::Months::new":["/// Construct a new `Months` from a number of months\npub const fn new(num: u32) -> Self{\n        Self(num)\n    }","Real(LocalPath(\"src/month.rs\"))"],"month::ParseMonthError":["/// An error resulting from reading `<Month>` value with `FromStr`.\npub struct ParseMonthError {\n    pub(crate) _dummy: (),\n}","Real(LocalPath(\"src/month.rs\"))"],"naive::date::Days":["/// A duration in calendar days.\n///\n/// This is useful because when using `Duration` it is possible\n/// that adding `Duration::days(1)` doesn't increment the day value as expected due to it being a\n/// fixed number of seconds. This difference applies only when dealing with `DateTime<TimeZone>` data types\n/// and in other cases `Duration::days(n)` and `Days::new(n)` are equivalent.\npub struct Days(pub(crate) u64);","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::Days::new":["/// Construct a new `Days` from a number of days\npub const fn new(num: u64) -> Self{\n        Self(num)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate":["/// ISO 8601 calendar date without timezone.\n/// Allows for every [proleptic Gregorian date] from Jan 1, 262145 BCE to Dec 31, 262143 CE.\n/// Also supports the conversion from ISO 8601 ordinal and week date.\n///\n/// # Calendar Date\n///\n/// The ISO 8601 **calendar date** follows the proleptic Gregorian calendar.\n/// It is like a normal civil calendar but note some slight differences:\n///\n/// * Dates before the Gregorian calendar's inception in 1582 are defined via the extrapolation.\n///   Be careful, as historical dates are often noted in the Julian calendar and others\n///   and the transition to Gregorian may differ across countries (as late as early 20C).\n///\n///   (Some example: Both Shakespeare from Britain and Cervantes from Spain seemingly died\n///   on the same calendar date---April 23, 1616---but in the different calendar.\n///   Britain used the Julian calendar at that time, so Shakespeare's death is later.)\n///\n/// * ISO 8601 calendars has the year 0, which is 1 BCE (a year before 1 CE).\n///   If you need a typical BCE/BC and CE/AD notation for year numbers,\n///   use the [`Datelike::year_ce`](../trait.Datelike.html#method.year_ce) method.\n///\n/// # Week Date\n///\n/// The ISO 8601 **week date** is a triple of year number, week number\n/// and [day of the week](../enum.Weekday.html) with the following rules:\n///\n/// * A week consists of Monday through Sunday, and is always numbered within some year.\n///   The week number ranges from 1 to 52 or 53 depending on the year.\n///\n/// * The week 1 of given year is defined as the first week containing January 4 of that year,\n///   or equivalently, the first week containing four or more days in that year.\n///\n/// * The year number in the week date may *not* correspond to the actual Gregorian year.\n///   For example, January 3, 2016 (Sunday) was on the last (53rd) week of 2015.\n///\n/// Chrono's date types default to the ISO 8601 [calendar date](#calendar-date),\n/// but [`Datelike::iso_week`](../trait.Datelike.html#tymethod.iso_week) and\n/// [`Datelike::weekday`](../trait.Datelike.html#tymethod.weekday) methods\n/// can be used to get the corresponding week date.\n///\n/// # Ordinal Date\n///\n/// The ISO 8601 **ordinal date** is a pair of year number and day of the year (\"ordinal\").\n/// The ordinal number ranges from 1 to 365 or 366 depending on the year.\n/// The year number is the same as that of the [calendar date](#calendar-date).\n///\n/// This is currently the internal format of Chrono's date types.\n///\n/// [proleptic Gregorian date]: crate::NaiveDate#calendar-date\npub struct NaiveDate {\n    ymdf: DateImpl, // (year << 13) | of\n}","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::and_hms":["/// Makes a new `NaiveDateTime` from the current date, hour, minute and second.\n///\n/// No [leap second](./struct.NaiveTime.html#leap-second-handling) is allowed here;\n/// use `NaiveDate::and_hms_*` methods with a subsecond parameter instead.\n///\n/// Panics on invalid hour, minute and/or second.\n#[deprecated(since = \"0.4.23\", note = \"use `and_hms_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn and_hms(&self, hour: u32, min: u32, sec: u32) -> NaiveDateTime{\n        self.and_hms_opt(hour, min, sec).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::and_hms_micro":["/// Makes a new `NaiveDateTime` from the current date, hour, minute, second and microsecond.\n///\n/// The microsecond part can exceed 1,000,000\n/// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n///\n/// Panics on invalid hour, minute, second and/or microsecond.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime, Datelike, Timelike, Weekday};\n///\n/// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n///\n/// let dt: NaiveDateTime = d.and_hms_micro_opt(12, 34, 56, 789_012).unwrap();\n/// assert_eq!(dt.year(), 2015);\n/// assert_eq!(dt.weekday(), Weekday::Wed);\n/// assert_eq!(dt.second(), 56);\n/// assert_eq!(dt.nanosecond(), 789_012_000);\n/// ```\n#[deprecated(since = \"0.4.23\", note = \"use `and_hms_micro_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn and_hms_micro(&self, hour: u32, min: u32, sec: u32, micro: u32) -> NaiveDateTime{\n        self.and_hms_micro_opt(hour, min, sec, micro).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::and_hms_micro_opt":["/// Makes a new `NaiveDateTime` from the current date, hour, minute, second and microsecond.\n///\n/// The microsecond part can exceed 1,000,000\n/// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n///\n/// Returns `None` on invalid hour, minute, second and/or microsecond.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n/// assert!(d.and_hms_micro_opt(12, 34, 56,   789_012).is_some());\n/// assert!(d.and_hms_micro_opt(12, 34, 59, 1_789_012).is_some()); // leap second\n/// assert!(d.and_hms_micro_opt(12, 34, 59, 2_789_012).is_none());\n/// assert!(d.and_hms_micro_opt(12, 34, 60,   789_012).is_none());\n/// assert!(d.and_hms_micro_opt(12, 60, 56,   789_012).is_none());\n/// assert!(d.and_hms_micro_opt(24, 34, 56,   789_012).is_none());\n/// ```\n#[inline]\n#[must_use]\npub fn and_hms_micro_opt(\n        &self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        micro: u32,\n    ) -> Option<NaiveDateTime>{\n        NaiveTime::from_hms_micro_opt(hour, min, sec, micro).map(|time| self.and_time(time))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::and_hms_milli":["/// Makes a new `NaiveDateTime` from the current date, hour, minute, second and millisecond.\n///\n/// The millisecond part can exceed 1,000\n/// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n///\n/// Panics on invalid hour, minute, second and/or millisecond.\n#[deprecated(since = \"0.4.23\", note = \"use `and_hms_milli_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn and_hms_milli(&self, hour: u32, min: u32, sec: u32, milli: u32) -> NaiveDateTime{\n        self.and_hms_milli_opt(hour, min, sec, milli).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::and_hms_milli_opt":["/// Makes a new `NaiveDateTime` from the current date, hour, minute, second and millisecond.\n///\n/// The millisecond part can exceed 1,000\n/// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n///\n/// Returns `None` on invalid hour, minute, second and/or millisecond.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n/// assert!(d.and_hms_milli_opt(12, 34, 56,   789).is_some());\n/// assert!(d.and_hms_milli_opt(12, 34, 59, 1_789).is_some()); // leap second\n/// assert!(d.and_hms_milli_opt(12, 34, 59, 2_789).is_none());\n/// assert!(d.and_hms_milli_opt(12, 34, 60,   789).is_none());\n/// assert!(d.and_hms_milli_opt(12, 60, 56,   789).is_none());\n/// assert!(d.and_hms_milli_opt(24, 34, 56,   789).is_none());\n/// ```\n#[inline]\n#[must_use]\npub fn and_hms_milli_opt(\n        &self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        milli: u32,\n    ) -> Option<NaiveDateTime>{\n        NaiveTime::from_hms_milli_opt(hour, min, sec, milli).map(|time| self.and_time(time))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::and_hms_nano":["/// Makes a new `NaiveDateTime` from the current date, hour, minute, second and nanosecond.\n///\n/// The nanosecond part can exceed 1,000,000,000\n/// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n///\n/// Panics on invalid hour, minute, second and/or nanosecond.\n#[deprecated(since = \"0.4.23\", note = \"use `and_hms_nano_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn and_hms_nano(&self, hour: u32, min: u32, sec: u32, nano: u32) -> NaiveDateTime{\n        self.and_hms_nano_opt(hour, min, sec, nano).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::and_hms_nano_opt":["/// Makes a new `NaiveDateTime` from the current date, hour, minute, second and nanosecond.\n///\n/// The nanosecond part can exceed 1,000,000,000\n/// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n///\n/// Returns `None` on invalid hour, minute, second and/or nanosecond.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n/// assert!(d.and_hms_nano_opt(12, 34, 56,   789_012_345).is_some());\n/// assert!(d.and_hms_nano_opt(12, 34, 59, 1_789_012_345).is_some()); // leap second\n/// assert!(d.and_hms_nano_opt(12, 34, 59, 2_789_012_345).is_none());\n/// assert!(d.and_hms_nano_opt(12, 34, 60,   789_012_345).is_none());\n/// assert!(d.and_hms_nano_opt(12, 60, 56,   789_012_345).is_none());\n/// assert!(d.and_hms_nano_opt(24, 34, 56,   789_012_345).is_none());\n/// ```\n#[inline]\n#[must_use]\npub fn and_hms_nano_opt(\n        &self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        nano: u32,\n    ) -> Option<NaiveDateTime>{\n        NaiveTime::from_hms_nano_opt(hour, min, sec, nano).map(|time| self.and_time(time))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::and_hms_opt":["/// Makes a new `NaiveDateTime` from the current date, hour, minute and second.\n///\n/// No [leap second](./struct.NaiveTime.html#leap-second-handling) is allowed here;\n/// use `NaiveDate::and_hms_*_opt` methods with a subsecond parameter instead.\n///\n/// Returns `None` on invalid hour, minute and/or second.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n/// assert!(d.and_hms_opt(12, 34, 56).is_some());\n/// assert!(d.and_hms_opt(12, 34, 60).is_none()); // use `and_hms_milli_opt` instead\n/// assert!(d.and_hms_opt(12, 60, 56).is_none());\n/// assert!(d.and_hms_opt(24, 34, 56).is_none());\n/// ```\n#[inline]\n#[must_use]\npub fn and_hms_opt(&self, hour: u32, min: u32, sec: u32) -> Option<NaiveDateTime>{\n        NaiveTime::from_hms_opt(hour, min, sec).map(|time| self.and_time(time))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::and_time":["/// Makes a new `NaiveDateTime` from the current date and given `NaiveTime`.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveTime, NaiveDateTime};\n///\n/// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n/// let t = NaiveTime::from_hms_milli_opt(12, 34, 56, 789).unwrap();\n///\n/// let dt: NaiveDateTime = d.and_time(t);\n/// assert_eq!(dt.date(), d);\n/// assert_eq!(dt.time(), t);\n/// ```\n#[inline]\n#[must_use]\npub const fn and_time(&self, time: NaiveTime) -> NaiveDateTime{\n        NaiveDateTime::new(*self, time)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::checked_add_days":["/// Add a duration in [`Days`] to the date\n///\n/// Returns `None` if the resulting date would be out of range.\n///\n/// ```\n/// # use chrono::{NaiveDate, Days};\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2022, 2, 20).unwrap().checked_add_days(Days::new(9)),\n///     Some(NaiveDate::from_ymd_opt(2022, 3, 1).unwrap())\n/// );\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2022, 7, 31).unwrap().checked_add_days(Days::new(2)),\n///     Some(NaiveDate::from_ymd_opt(2022, 8, 2).unwrap())\n/// );\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2022, 7, 31).unwrap().checked_add_days(Days::new(1000000000000)),\n///     None\n/// );\n/// ```\n#[must_use]\npub fn checked_add_days(self, days: Days) -> Option<Self>{\n        if days.0 == 0 {\n            return Some(self);\n        }\n\n        i64::try_from(days.0).ok().and_then(|d| self.diff_days(d))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::checked_add_months":["/// Add a duration in [`Months`] to the date\n///\n/// If the day would be out of range for the resulting month, use the last day for that month.\n///\n/// Returns `None` if the resulting date would be out of range.\n///\n/// ```\n/// # use chrono::{NaiveDate, Months};\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2022, 2, 20).unwrap().checked_add_months(Months::new(6)),\n///     Some(NaiveDate::from_ymd_opt(2022, 8, 20).unwrap())\n/// );\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2022, 7, 31).unwrap().checked_add_months(Months::new(2)),\n///     Some(NaiveDate::from_ymd_opt(2022, 9, 30).unwrap())\n/// );\n/// ```\n#[must_use]\npub fn checked_add_months(self, months: Months) -> Option<Self>{\n        if months.0 == 0 {\n            return Some(self);\n        }\n\n        match months.0 <= core::i32::MAX as u32 {\n            true => self.diff_months(months.0 as i32),\n            false => None,\n        }\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::checked_add_signed":["/// Adds the `days` part of given `Duration` to the current date.\n///\n/// Returns `None` when it will result in overflow.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Duration, NaiveDate};\n///\n/// let d = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap();\n/// assert_eq!(d.checked_add_signed(Duration::days(40)),\n///            Some(NaiveDate::from_ymd_opt(2015, 10, 15).unwrap()));\n/// assert_eq!(d.checked_add_signed(Duration::days(-40)),\n///            Some(NaiveDate::from_ymd_opt(2015, 7, 27).unwrap()));\n/// assert_eq!(d.checked_add_signed(Duration::days(1_000_000_000)), None);\n/// assert_eq!(d.checked_add_signed(Duration::days(-1_000_000_000)), None);\n/// assert_eq!(NaiveDate::MAX.checked_add_signed(Duration::days(1)), None);\n/// ```\n#[must_use]\npub fn checked_add_signed(self, rhs: OldDuration) -> Option<NaiveDate>{\n        let year = self.year();\n        let (mut year_div_400, year_mod_400) = div_mod_floor(year, 400);\n        let cycle = internals::yo_to_cycle(year_mod_400 as u32, self.of().ordinal());\n        let cycle = (cycle as i32).checked_add(i32::try_from(rhs.num_days()).ok()?)?;\n        let (cycle_div_400y, cycle) = div_mod_floor(cycle, 146_097);\n        year_div_400 += cycle_div_400y;\n\n        let (year_mod_400, ordinal) = internals::cycle_to_yo(cycle as u32);\n        let flags = YearFlags::from_year_mod_400(year_mod_400 as i32);\n        NaiveDate::from_ordinal_and_flags(year_div_400 * 400 + year_mod_400 as i32, ordinal, flags)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::checked_sub_days":["/// Subtract a duration in [`Days`] from the date\n///\n/// Returns `None` if the resulting date would be out of range.\n///\n/// ```\n/// # use chrono::{NaiveDate, Days};\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2022, 2, 20).unwrap().checked_sub_days(Days::new(6)),\n///     Some(NaiveDate::from_ymd_opt(2022, 2, 14).unwrap())\n/// );\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2022, 2, 20).unwrap().checked_sub_days(Days::new(1000000000000)),\n///     None\n/// );\n/// ```\n#[must_use]\npub fn checked_sub_days(self, days: Days) -> Option<Self>{\n        if days.0 == 0 {\n            return Some(self);\n        }\n\n        i64::try_from(days.0).ok().and_then(|d| self.diff_days(-d))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::checked_sub_months":["/// Subtract a duration in [`Months`] from the date\n///\n/// If the day would be out of range for the resulting month, use the last day for that month.\n///\n/// Returns `None` if the resulting date would be out of range.\n///\n/// ```\n/// # use chrono::{NaiveDate, Months};\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2022, 2, 20).unwrap().checked_sub_months(Months::new(6)),\n///     Some(NaiveDate::from_ymd_opt(2021, 8, 20).unwrap())\n/// );\n///\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap()\n///         .checked_sub_months(Months::new(core::i32::MAX as u32 + 1)),\n///     None\n/// );\n/// ```\n#[must_use]\npub fn checked_sub_months(self, months: Months) -> Option<Self>{\n        if months.0 == 0 {\n            return Some(self);\n        }\n\n        // Copy `i32::MAX` here so we don't have to do a complicated cast\n        match months.0 <= 2_147_483_647 {\n            true => self.diff_months(-(months.0 as i32)),\n            false => None,\n        }\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::checked_sub_signed":["/// Subtracts the `days` part of given `Duration` from the current date.\n///\n/// Returns `None` when it will result in overflow.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Duration, NaiveDate};\n///\n/// let d = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap();\n/// assert_eq!(d.checked_sub_signed(Duration::days(40)),\n///            Some(NaiveDate::from_ymd_opt(2015, 7, 27).unwrap()));\n/// assert_eq!(d.checked_sub_signed(Duration::days(-40)),\n///            Some(NaiveDate::from_ymd_opt(2015, 10, 15).unwrap()));\n/// assert_eq!(d.checked_sub_signed(Duration::days(1_000_000_000)), None);\n/// assert_eq!(d.checked_sub_signed(Duration::days(-1_000_000_000)), None);\n/// assert_eq!(NaiveDate::MIN.checked_sub_signed(Duration::days(1)), None);\n/// ```\n#[must_use]\npub fn checked_sub_signed(self, rhs: OldDuration) -> Option<NaiveDate>{\n        let year = self.year();\n        let (mut year_div_400, year_mod_400) = div_mod_floor(year, 400);\n        let cycle = internals::yo_to_cycle(year_mod_400 as u32, self.of().ordinal());\n        let cycle = (cycle as i32).checked_sub(i32::try_from(rhs.num_days()).ok()?)?;\n        let (cycle_div_400y, cycle) = div_mod_floor(cycle, 146_097);\n        year_div_400 += cycle_div_400y;\n\n        let (year_mod_400, ordinal) = internals::cycle_to_yo(cycle as u32);\n        let flags = YearFlags::from_year_mod_400(year_mod_400 as i32);\n        NaiveDate::from_ordinal_and_flags(year_div_400 * 400 + year_mod_400 as i32, ordinal, flags)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::diff_days":["fn diff_days(self, days: i64) -> Option<Self>{\n        let secs = days.checked_mul(86400)?; // 86400 seconds in one day\n        if secs >= core::i64::MAX / 1000 || secs <= core::i64::MIN / 1000 {\n            return None; // See the `time` 0.1 crate. Outside these bounds, `Duration::seconds` will panic\n        }\n        self.checked_add_signed(Duration::seconds(secs))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::diff_months":["fn diff_months(self, months: i32) -> Option<Self>{\n        let (years, left) = ((months / 12), (months % 12));\n\n        // Determine new year (without taking months into account for now\n\n        let year = if (years > 0 && years > (MAX_YEAR - self.year()))\n            || (years < 0 && years < (MIN_YEAR - self.year()))\n        {\n            return None;\n        } else {\n            self.year() + years\n        };\n\n        // Determine new month\n\n        let month = self.month() as i32 + left;\n        let (year, month) = if month <= 0 {\n            if year == MIN_YEAR {\n                return None;\n            }\n\n            (year - 1, month + 12)\n        } else if month > 12 {\n            if year == MAX_YEAR {\n                return None;\n            }\n\n            (year + 1, month - 12)\n        } else {\n            (year, month)\n        };\n\n        // Clamp original day in case new month is shorter\n\n        let flags = YearFlags::from_year(year);\n        let feb_days = if flags.ndays() == 366 { 29 } else { 28 };\n        let days = [31, feb_days, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        let day = Ord::min(self.day(), days[(month - 1) as usize]);\n\n        NaiveDate::from_mdf(year, Mdf::new(month as u32, day, flags)?)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::format":["/// Formats the date with the specified format string.\n/// See the [`format::strftime` module](../format/strftime/index.html)\n/// on the supported escape sequences.\n///\n/// This returns a `DelayedFormat`,\n/// which gets converted to a string only when actual formatting happens.\n/// You may use the `to_string` method to get a `String`,\n/// or just feed it into `print!` and other formatting macros.\n/// (In this way it avoids the redundant memory allocation.)\n///\n/// A wrong format string does *not* issue an error immediately.\n/// Rather, converting or formatting the `DelayedFormat` fails.\n/// You are recommended to immediately use `DelayedFormat` for this reason.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let d = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap();\n/// assert_eq!(d.format(\"%Y-%m-%d\").to_string(), \"2015-09-05\");\n/// assert_eq!(d.format(\"%A, %-d %B, %C%y\").to_string(), \"Saturday, 5 September, 2015\");\n/// ```\n///\n/// The resulting `DelayedFormat` can be formatted directly via the `Display` trait.\n///\n/// ```\n/// # use chrono::NaiveDate;\n/// # let d = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap();\n/// assert_eq!(format!(\"{}\", d.format(\"%Y-%m-%d\")), \"2015-09-05\");\n/// assert_eq!(format!(\"{}\", d.format(\"%A, %-d %B, %C%y\")), \"Saturday, 5 September, 2015\");\n/// ```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[inline]\n#[must_use]\npub fn format<'a>(&self, fmt: &'a str) -> DelayedFormat<StrftimeItems<'a>>{\n        self.format_with_items(StrftimeItems::new(fmt))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::format_with_items":["/// Formats the date with the specified formatting items.\n/// Otherwise it is the same as the ordinary `format` method.\n///\n/// The `Iterator` of items should be `Clone`able,\n/// since the resulting `DelayedFormat` value may be formatted multiple times.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n/// use chrono::format::strftime::StrftimeItems;\n///\n/// let fmt = StrftimeItems::new(\"%Y-%m-%d\");\n/// let d = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap();\n/// assert_eq!(d.format_with_items(fmt.clone()).to_string(), \"2015-09-05\");\n/// assert_eq!(d.format(\"%Y-%m-%d\").to_string(),             \"2015-09-05\");\n/// ```\n///\n/// The resulting `DelayedFormat` can be formatted directly via the `Display` trait.\n///\n/// ```\n/// # use chrono::NaiveDate;\n/// # use chrono::format::strftime::StrftimeItems;\n/// # let fmt = StrftimeItems::new(\"%Y-%m-%d\").clone();\n/// # let d = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap();\n/// assert_eq!(format!(\"{}\", d.format_with_items(fmt)), \"2015-09-05\");\n/// ```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[inline]\n#[must_use]\npub fn format_with_items<'a, I, B>(&self, items: I) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,{\n        DelayedFormat::new(Some(*self), None, items)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::from_isoywd":["/// Makes a new `NaiveDate` from the [ISO week date](#week-date)\n/// (year, week number and day of the week).\n/// The resulting `NaiveDate` may have a different year from the input year.\n///\n/// Panics on the out-of-range date and/or invalid week number.\n#[deprecated(since = \"0.4.23\", note = \"use `from_isoywd_opt()` instead\")]\n#[must_use]\npub fn from_isoywd(year: i32, week: u32, weekday: Weekday) -> NaiveDate{\n        NaiveDate::from_isoywd_opt(year, week, weekday).expect(\"invalid or out-of-range date\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::from_isoywd_opt":["/// Makes a new `NaiveDate` from the [ISO week date](#week-date)\n/// (year, week number and day of the week).\n/// The resulting `NaiveDate` may have a different year from the input year.\n///\n/// Returns `None` on the out-of-range date and/or invalid week number.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Weekday};\n///\n/// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n/// let from_isoywd_opt = NaiveDate::from_isoywd_opt;\n///\n/// assert_eq!(from_isoywd_opt(2015, 0, Weekday::Sun), None);\n/// assert_eq!(from_isoywd_opt(2015, 10, Weekday::Sun), Some(from_ymd(2015, 3, 8)));\n/// assert_eq!(from_isoywd_opt(2015, 30, Weekday::Mon), Some(from_ymd(2015, 7, 20)));\n/// assert_eq!(from_isoywd_opt(2015, 60, Weekday::Mon), None);\n///\n/// assert_eq!(from_isoywd_opt(400000, 10, Weekday::Fri), None);\n/// assert_eq!(from_isoywd_opt(-400000, 10, Weekday::Sat), None);\n/// ```\n///\n/// The year number of ISO week date may differ from that of the calendar date.\n///\n/// ```\n/// # use chrono::{NaiveDate, Weekday};\n/// # let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n/// # let from_isoywd_opt = NaiveDate::from_isoywd_opt;\n/// //           Mo Tu We Th Fr Sa Su\n/// // 2014-W52  22 23 24 25 26 27 28    has 4+ days of new year,\n/// // 2015-W01  29 30 31  1  2  3  4 <- so this is the first week\n/// assert_eq!(from_isoywd_opt(2014, 52, Weekday::Sun), Some(from_ymd(2014, 12, 28)));\n/// assert_eq!(from_isoywd_opt(2014, 53, Weekday::Mon), None);\n/// assert_eq!(from_isoywd_opt(2015, 1, Weekday::Mon), Some(from_ymd(2014, 12, 29)));\n///\n/// // 2015-W52  21 22 23 24 25 26 27    has 4+ days of old year,\n/// // 2015-W53  28 29 30 31  1  2  3 <- so this is the last week\n/// // 2016-W01   4  5  6  7  8  9 10\n/// assert_eq!(from_isoywd_opt(2015, 52, Weekday::Sun), Some(from_ymd(2015, 12, 27)));\n/// assert_eq!(from_isoywd_opt(2015, 53, Weekday::Sun), Some(from_ymd(2016, 1, 3)));\n/// assert_eq!(from_isoywd_opt(2015, 54, Weekday::Mon), None);\n/// assert_eq!(from_isoywd_opt(2016, 1, Weekday::Mon), Some(from_ymd(2016, 1, 4)));\n/// ```\n#[must_use]\npub fn from_isoywd_opt(year: i32, week: u32, weekday: Weekday) -> Option<NaiveDate>{\n        let flags = YearFlags::from_year(year);\n        let nweeks = flags.nisoweeks();\n        if 1 <= week && week <= nweeks {\n            // ordinal = week ordinal - delta\n            let weekord = week * 7 + weekday as u32;\n            let delta = flags.isoweek_delta();\n            if weekord <= delta {\n                // ordinal < 1, previous year\n                let prevflags = YearFlags::from_year(year - 1);\n                NaiveDate::from_ordinal_and_flags(\n                    year - 1,\n                    weekord + prevflags.ndays() - delta,\n                    prevflags,\n                )\n            } else {\n                let ordinal = weekord - delta;\n                let ndays = flags.ndays();\n                if ordinal <= ndays {\n                    // this year\n                    NaiveDate::from_ordinal_and_flags(year, ordinal, flags)\n                } else {\n                    // ordinal > ndays, next year\n                    let nextflags = YearFlags::from_year(year + 1);\n                    NaiveDate::from_ordinal_and_flags(year + 1, ordinal - ndays, nextflags)\n                }\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::from_mdf":["/// Makes a new `NaiveDate` from year and packed month-day-flags.\n/// Does not check whether the flags are correct for the provided year.\nconst fn from_mdf(year: i32, mdf: Mdf) -> Option<NaiveDate>{\n        if year < MIN_YEAR || year > MAX_YEAR {\n            return None; // Out-of-range\n        }\n        match mdf.to_of() {\n            Some(of) => Some(NaiveDate { ymdf: (year << 13) | (of.inner() as DateImpl) }),\n            None => None, // Non-existing date\n        }\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::from_num_days_from_ce":["/// Makes a new `NaiveDate` from a day's number in the proleptic Gregorian calendar, with\n/// January 1, 1 being day 1.\n///\n/// Panics if the date is out of range.\n#[deprecated(since = \"0.4.23\", note = \"use `from_num_days_from_ce_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn from_num_days_from_ce(days: i32) -> NaiveDate{\n        NaiveDate::from_num_days_from_ce_opt(days).expect(\"out-of-range date\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::from_num_days_from_ce_opt":["/// Makes a new `NaiveDate` from a day's number in the proleptic Gregorian calendar, with\n/// January 1, 1 being day 1.\n///\n/// Returns `None` if the date is out of range.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let from_ndays_opt = NaiveDate::from_num_days_from_ce_opt;\n/// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n///\n/// assert_eq!(from_ndays_opt(730_000),      Some(from_ymd(1999, 9, 3)));\n/// assert_eq!(from_ndays_opt(1),            Some(from_ymd(1, 1, 1)));\n/// assert_eq!(from_ndays_opt(0),            Some(from_ymd(0, 12, 31)));\n/// assert_eq!(from_ndays_opt(-1),           Some(from_ymd(0, 12, 30)));\n/// assert_eq!(from_ndays_opt(100_000_000),  None);\n/// assert_eq!(from_ndays_opt(-100_000_000), None);\n/// ```\n#[must_use]\npub fn from_num_days_from_ce_opt(days: i32) -> Option<NaiveDate>{\n        let days = days.checked_add(365)?; // make December 31, 1 BCE equal to day 0\n        let (year_div_400, cycle) = div_mod_floor(days, 146_097);\n        let (year_mod_400, ordinal) = internals::cycle_to_yo(cycle as u32);\n        let flags = YearFlags::from_year_mod_400(year_mod_400 as i32);\n        NaiveDate::from_ordinal_and_flags(year_div_400 * 400 + year_mod_400 as i32, ordinal, flags)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::from_ordinal_and_flags":["/// Makes a new `NaiveDate` from year, ordinal and flags.\n/// Does not check whether the flags are correct for the provided year.\nconst fn from_ordinal_and_flags(\n        year: i32,\n        ordinal: u32,\n        flags: YearFlags,\n    ) -> Option<NaiveDate>{\n        if year < MIN_YEAR || year > MAX_YEAR {\n            return None; // Out-of-range\n        }\n        // Enable debug check once the MSRV >= 1.57 (panicking in const feature)\n        // debug_assert!(YearFlags::from_year(year).0 == flags.0);\n        match Of::new(ordinal, flags) {\n            Some(of) => Some(NaiveDate { ymdf: (year << 13) | (of.inner() as DateImpl) }),\n            None => None, // Invalid: Ordinal outside of the nr of days in a year with those flags.\n        }\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::from_weekday_of_month":["/// Makes a new `NaiveDate` by counting the number of occurrences of a particular day-of-week\n/// since the beginning of the given month.  For instance, if you want the 2nd Friday of March\n/// 2017, you would use `NaiveDate::from_weekday_of_month(2017, 3, Weekday::Fri, 2)`.\n///\n/// # Panics\n///\n/// The resulting `NaiveDate` is guaranteed to be in `month`.  If `n` is larger than the number\n/// of `weekday` in `month` (eg. the 6th Friday of March 2017) then this function will panic.\n///\n/// `n` is 1-indexed.  Passing `n=0` will cause a panic.\n#[deprecated(since = \"0.4.23\", note = \"use `from_weekday_of_month_opt()` instead\")]\n#[must_use]\npub fn from_weekday_of_month(year: i32, month: u32, weekday: Weekday, n: u8) -> NaiveDate{\n        NaiveDate::from_weekday_of_month_opt(year, month, weekday, n).expect(\"out-of-range date\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::from_weekday_of_month_opt":["/// Makes a new `NaiveDate` by counting the number of occurrences of a particular day-of-week\n/// since the beginning of the given month.  For instance, if you want the 2nd Friday of March\n/// 2017, you would use `NaiveDate::from_weekday_of_month(2017, 3, Weekday::Fri, 2)`.  `n` is 1-indexed.\n///\n/// ```\n/// use chrono::{NaiveDate, Weekday};\n/// assert_eq!(NaiveDate::from_weekday_of_month_opt(2017, 3, Weekday::Fri, 2),\n///            NaiveDate::from_ymd_opt(2017, 3, 10))\n/// ```\n///\n/// Returns `None` if `n` out-of-range; ie. if `n` is larger than the number of `weekday` in\n/// `month` (eg. the 6th Friday of March 2017), or if `n == 0`.\n#[must_use]\npub fn from_weekday_of_month_opt(\n        year: i32,\n        month: u32,\n        weekday: Weekday,\n        n: u8,\n    ) -> Option<NaiveDate>{\n        if n == 0 {\n            return None;\n        }\n        let first = NaiveDate::from_ymd_opt(year, month, 1)?.weekday();\n        let first_to_dow = (7 + weekday.number_from_monday() - first.number_from_monday()) % 7;\n        let day = (u32::from(n) - 1) * 7 + first_to_dow + 1;\n        NaiveDate::from_ymd_opt(year, month, day)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::from_ymd":["/// Makes a new `NaiveDate` from the [calendar date](#calendar-date)\n/// (year, month and day).\n///\n/// Panics on the out-of-range date, invalid month and/or day.\n#[deprecated(since = \"0.4.23\", note = \"use `from_ymd_opt()` instead\")]\n#[must_use]\npub fn from_ymd(year: i32, month: u32, day: u32) -> NaiveDate{\n        NaiveDate::from_ymd_opt(year, month, day).expect(\"invalid or out-of-range date\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::from_ymd_opt":["/// Makes a new `NaiveDate` from the [calendar date](#calendar-date)\n/// (year, month and day).\n///\n/// Returns `None` on the out-of-range date, invalid month and/or day.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let from_ymd_opt = NaiveDate::from_ymd_opt;\n///\n/// assert!(from_ymd_opt(2015, 3, 14).is_some());\n/// assert!(from_ymd_opt(2015, 0, 14).is_none());\n/// assert!(from_ymd_opt(2015, 2, 29).is_none());\n/// assert!(from_ymd_opt(-4, 2, 29).is_some()); // 5 BCE is a leap year\n/// assert!(from_ymd_opt(400000, 1, 1).is_none());\n/// assert!(from_ymd_opt(-400000, 1, 1).is_none());\n/// ```\n#[must_use]\npub fn from_ymd_opt(year: i32, month: u32, day: u32) -> Option<NaiveDate>{\n        let flags = YearFlags::from_year(year);\n        NaiveDate::from_mdf(year, Mdf::new(month, day, flags)?)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::from_yo":["/// Makes a new `NaiveDate` from the [ordinal date](#ordinal-date)\n/// (year and day of the year).\n///\n/// Panics on the out-of-range date and/or invalid day of year.\n#[deprecated(since = \"0.4.23\", note = \"use `from_yo_opt()` instead\")]\n#[must_use]\npub fn from_yo(year: i32, ordinal: u32) -> NaiveDate{\n        NaiveDate::from_yo_opt(year, ordinal).expect(\"invalid or out-of-range date\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::from_yo_opt":["/// Makes a new `NaiveDate` from the [ordinal date](#ordinal-date)\n/// (year and day of the year).\n///\n/// Returns `None` on the out-of-range date and/or invalid day of year.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let from_yo_opt = NaiveDate::from_yo_opt;\n///\n/// assert!(from_yo_opt(2015, 100).is_some());\n/// assert!(from_yo_opt(2015, 0).is_none());\n/// assert!(from_yo_opt(2015, 365).is_some());\n/// assert!(from_yo_opt(2015, 366).is_none());\n/// assert!(from_yo_opt(-4, 366).is_some()); // 5 BCE is a leap year\n/// assert!(from_yo_opt(400000, 1).is_none());\n/// assert!(from_yo_opt(-400000, 1).is_none());\n/// ```\n#[must_use]\npub fn from_yo_opt(year: i32, ordinal: u32) -> Option<NaiveDate>{\n        let flags = YearFlags::from_year(year);\n        NaiveDate::from_ordinal_and_flags(year, ordinal, flags)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::iter_days":["/// Returns an iterator that steps by days across all representable dates.\n///\n/// # Example\n///\n/// ```\n/// # use chrono::NaiveDate;\n///\n/// let expected = [\n///     NaiveDate::from_ymd_opt(2016, 2, 27).unwrap(),\n///     NaiveDate::from_ymd_opt(2016, 2, 28).unwrap(),\n///     NaiveDate::from_ymd_opt(2016, 2, 29).unwrap(),\n///     NaiveDate::from_ymd_opt(2016, 3, 1).unwrap(),\n/// ];\n///\n/// let mut count = 0;\n/// for (idx, d) in NaiveDate::from_ymd_opt(2016, 2, 27).unwrap().iter_days().take(4).enumerate() {\n///    assert_eq!(d, expected[idx]);\n///    count += 1;\n/// }\n/// assert_eq!(count, 4);\n///\n/// for d in NaiveDate::from_ymd_opt(2016, 3, 1).unwrap().iter_days().rev().take(4) {\n///     count -= 1;\n///     assert_eq!(d, expected[count]);\n/// }\n/// ```\n#[inline]\npub const fn iter_days(&self) -> NaiveDateDaysIterator{\n        NaiveDateDaysIterator { value: *self }\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::iter_weeks":["/// Returns an iterator that steps by weeks across all representable dates.\n///\n/// # Example\n///\n/// ```\n/// # use chrono::NaiveDate;\n///\n/// let expected = [\n///     NaiveDate::from_ymd_opt(2016, 2, 27).unwrap(),\n///     NaiveDate::from_ymd_opt(2016, 3, 5).unwrap(),\n///     NaiveDate::from_ymd_opt(2016, 3, 12).unwrap(),\n///     NaiveDate::from_ymd_opt(2016, 3, 19).unwrap(),\n/// ];\n///\n/// let mut count = 0;\n/// for (idx, d) in NaiveDate::from_ymd_opt(2016, 2, 27).unwrap().iter_weeks().take(4).enumerate() {\n///    assert_eq!(d, expected[idx]);\n///    count += 1;\n/// }\n/// assert_eq!(count, 4);\n///\n/// for d in NaiveDate::from_ymd_opt(2016, 3, 19).unwrap().iter_weeks().rev().take(4) {\n///     count -= 1;\n///     assert_eq!(d, expected[count]);\n/// }\n/// ```\n#[inline]\npub const fn iter_weeks(&self) -> NaiveDateWeeksIterator{\n        NaiveDateWeeksIterator { value: *self }\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::mdf":["/// Returns the packed month-day-flags.\n#[inline]\nfn mdf(&self) -> Mdf{\n        self.of().to_mdf()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::of":["/// Returns the packed ordinal-flags.\n#[inline]\nconst fn of(&self) -> Of{\n        Of::from_date_impl(self.ymdf)\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::parse_and_remainder":["/// Parses a string from a user-specified format into a new `NaiveDate` value, and a slice with\n/// the remaining portion of the string.\n/// See the [`format::strftime` module](../format/strftime/index.html)\n/// on the supported escape sequences.\n///\n/// Similar to [`parse_from_str`](#method.parse_from_str).\n///\n/// # Example\n///\n/// ```rust\n/// # use chrono::{NaiveDate};\n/// let (date, remainder) = NaiveDate::parse_and_remainder(\n///     \"2015-02-18 trailing text\", \"%Y-%m-%d\").unwrap();\n/// assert_eq!(date, NaiveDate::from_ymd_opt(2015, 2, 18).unwrap());\n/// assert_eq!(remainder, \" trailing text\");\n/// ```\npub fn parse_and_remainder<'a>(s: &'a str, fmt: &str) -> ParseResult<(NaiveDate, &'a str)>{\n        let mut parsed = Parsed::new();\n        let remainder = parse_and_remainder(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_naive_date().map(|d| (d, remainder))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::parse_from_str":["/// Parses a string with the specified format string and returns a new `NaiveDate`.\n/// See the [`format::strftime` module](../format/strftime/index.html)\n/// on the supported escape sequences.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let parse_from_str = NaiveDate::parse_from_str;\n///\n/// assert_eq!(parse_from_str(\"2015-09-05\", \"%Y-%m-%d\"),\n///            Ok(NaiveDate::from_ymd_opt(2015, 9, 5).unwrap()));\n/// assert_eq!(parse_from_str(\"5sep2015\", \"%d%b%Y\"),\n///            Ok(NaiveDate::from_ymd_opt(2015, 9, 5).unwrap()));\n/// ```\n///\n/// Time and offset is ignored for the purpose of parsing.\n///\n/// ```\n/// # use chrono::NaiveDate;\n/// # let parse_from_str = NaiveDate::parse_from_str;\n/// assert_eq!(parse_from_str(\"2014-5-17T12:34:56+09:30\", \"%Y-%m-%dT%H:%M:%S%z\"),\n///            Ok(NaiveDate::from_ymd_opt(2014, 5, 17).unwrap()));\n/// ```\n///\n/// Out-of-bound dates or insufficient fields are errors.\n///\n/// ```\n/// # use chrono::NaiveDate;\n/// # let parse_from_str = NaiveDate::parse_from_str;\n/// assert!(parse_from_str(\"2015/9\", \"%Y/%m\").is_err());\n/// assert!(parse_from_str(\"2015/9/31\", \"%Y/%m/%d\").is_err());\n/// ```\n///\n/// All parsed fields should be consistent to each other, otherwise it's an error.\n///\n/// ```\n/// # use chrono::NaiveDate;\n/// # let parse_from_str = NaiveDate::parse_from_str;\n/// assert!(parse_from_str(\"Sat, 09 Aug 2013\", \"%a, %d %b %Y\").is_err());\n/// ```\npub fn parse_from_str(s: &str, fmt: &str) -> ParseResult<NaiveDate>{\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_naive_date()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::pred":["/// Makes a new `NaiveDate` for the previous calendar date.\n///\n/// Panics when `self` is the first representable date.\n#[deprecated(since = \"0.4.23\", note = \"use `pred_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn pred(&self) -> NaiveDate{\n        self.pred_opt().expect(\"out of bound\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::pred_opt":["/// Makes a new `NaiveDate` for the previous calendar date.\n///\n/// Returns `None` when `self` is the first representable date.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 6, 3).unwrap().pred_opt(),\n///            Some(NaiveDate::from_ymd_opt(2015, 6, 2).unwrap()));\n/// assert_eq!(NaiveDate::MIN.pred_opt(), None);\n/// ```\n#[inline]\n#[must_use]\npub fn pred_opt(&self) -> Option<NaiveDate>{\n        match self.of().pred() {\n            Some(of) => Some(self.with_of(of)),\n            None => NaiveDate::from_ymd_opt(self.year() - 1, 12, 31),\n        }\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::signed_duration_since":["/// Subtracts another `NaiveDate` from the current date.\n/// Returns a `Duration` of integral numbers.\n///\n/// This does not overflow or underflow at all,\n/// as all possible output fits in the range of `Duration`.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Duration, NaiveDate};\n///\n/// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n/// let since = NaiveDate::signed_duration_since;\n///\n/// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(2014, 1, 1)), Duration::zero());\n/// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(2013, 12, 31)), Duration::days(1));\n/// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(2014, 1, 2)), Duration::days(-1));\n/// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(2013, 9, 23)), Duration::days(100));\n/// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(2013, 1, 1)), Duration::days(365));\n/// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(2010, 1, 1)), Duration::days(365*4 + 1));\n/// assert_eq!(since(from_ymd(2014, 1, 1), from_ymd(1614, 1, 1)), Duration::days(365*400 + 97));\n/// ```\n#[must_use]\npub fn signed_duration_since(self, rhs: NaiveDate) -> OldDuration{\n        let year1 = self.year();\n        let year2 = rhs.year();\n        let (year1_div_400, year1_mod_400) = div_mod_floor(year1, 400);\n        let (year2_div_400, year2_mod_400) = div_mod_floor(year2, 400);\n        let cycle1 = i64::from(internals::yo_to_cycle(year1_mod_400 as u32, self.of().ordinal()));\n        let cycle2 = i64::from(internals::yo_to_cycle(year2_mod_400 as u32, rhs.of().ordinal()));\n        OldDuration::days(\n            (i64::from(year1_div_400) - i64::from(year2_div_400)) * 146_097 + (cycle1 - cycle2),\n        )\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::succ":["/// Makes a new `NaiveDate` for the next calendar date.\n///\n/// Panics when `self` is the last representable date.\n#[deprecated(since = \"0.4.23\", note = \"use `succ_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn succ(&self) -> NaiveDate{\n        self.succ_opt().expect(\"out of bound\")\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::succ_opt":["/// Makes a new `NaiveDate` for the next calendar date.\n///\n/// Returns `None` when `self` is the last representable date.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(2015, 6, 3).unwrap().succ_opt(),\n///            Some(NaiveDate::from_ymd_opt(2015, 6, 4).unwrap()));\n/// assert_eq!(NaiveDate::MAX.succ_opt(), None);\n/// ```\n#[inline]\n#[must_use]\npub fn succ_opt(&self) -> Option<NaiveDate>{\n        match self.of().succ() {\n            Some(of) => Some(self.with_of(of)),\n            None => NaiveDate::from_ymd_opt(self.year() + 1, 1, 1),\n        }\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::week":["/// Returns the [`NaiveWeek`] that the date belongs to, starting with the [`Weekday`]\n/// specified.\n#[inline]\npub const fn week(&self, start: Weekday) -> NaiveWeek{\n        NaiveWeek { date: *self, start }\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::weeks_from":["pub(crate) fn weeks_from(&self, day: Weekday) -> i32{\n        (self.ordinal() as i32 - self.weekday().num_days_from(day) as i32 + 6) / 7\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::with_mdf":["/// Makes a new `NaiveDate` with the packed month-day-flags changed.\n///\n/// Returns `None` when the resulting `NaiveDate` would be invalid.\n#[inline]\nfn with_mdf(&self, mdf: Mdf) -> Option<NaiveDate>{\n        Some(self.with_of(mdf.to_of()?))\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::with_of":["/// Makes a new `NaiveDate` with the packed ordinal-flags changed.\n///\n/// Returns `None` when the resulting `NaiveDate` would be invalid.\n/// Does not check if the year flags match the year.\n#[inline]\nconst fn with_of(&self, of: Of) -> NaiveDate{\n        NaiveDate { ymdf: (self.ymdf & !0b1_1111_1111_1111) | of.inner() as DateImpl }\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDate::years_since":["/// Returns the number of whole years from the given `base` until `self`.\n#[must_use]\npub fn years_since(&self, base: Self) -> Option<u32>{\n        let mut years = self.year() - base.year();\n        if (self.month(), self.day()) < (base.month(), base.day()) {\n            years -= 1;\n        }\n\n        match years >= 0 {\n            true => Some(years as u32),\n            false => None,\n        }\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDateDaysIterator":["/// Iterator over `NaiveDate` with a step size of one day.\npub struct NaiveDateDaysIterator {\n    value: NaiveDate,\n}","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveDateWeeksIterator":["pub struct NaiveDateWeeksIterator {\n    value: NaiveDate,\n}","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveWeek":["/// A week represented by a [`NaiveDate`] and a [`Weekday`] which is the first\n/// day of the week.\npub struct NaiveWeek {\n    date: NaiveDate,\n    start: Weekday,\n}","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveWeek::days":["/// Returns a [`RangeInclusive<T>`] representing the whole week bounded by\n/// [first_day](./struct.NaiveWeek.html#method.first_day) and\n/// [last_day](./struct.NaiveWeek.html#method.last_day) functions.\n///\n/// # Examples\n///\n/// ```\n/// use chrono::{NaiveDate, Weekday};\n///\n/// let date = NaiveDate::from_ymd_opt(2022, 4, 18).unwrap();\n/// let week = date.week(Weekday::Mon);\n/// let days = week.days();\n/// assert!(days.contains(&date));\n/// ```\n#[inline]\n#[must_use]\npub fn days(&self) -> RangeInclusive<NaiveDate>{\n        self.first_day()..=self.last_day()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveWeek::first_day":["/// Returns a date representing the first day of the week.\n///\n/// # Examples\n///\n/// ```\n/// use chrono::{NaiveDate, Weekday};\n///\n/// let date = NaiveDate::from_ymd_opt(2022, 4, 18).unwrap();\n/// let week = date.week(Weekday::Mon);\n/// assert!(week.first_day() <= date);\n/// ```\n#[inline]\n#[must_use]\npub fn first_day(&self) -> NaiveDate{\n        let start = self.start.num_days_from_monday() as i32;\n        let ref_day = self.date.weekday().num_days_from_monday() as i32;\n        // Calculate the number of days to subtract from `self.date`.\n        // Do not construct an intermediate date beyond `self.date`, because that may be out of\n        // range if `date` is close to `NaiveDate::MAX`.\n        let days = start - ref_day - if start > ref_day { 7 } else { 0 };\n        self.date.diff_days(days as i64).unwrap()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::NaiveWeek::last_day":["/// Returns a date representing the last day of the week.\n///\n/// # Examples\n///\n/// ```\n/// use chrono::{NaiveDate, Weekday};\n///\n/// let date = NaiveDate::from_ymd_opt(2022, 4, 18).unwrap();\n/// let week = date.week(Weekday::Mon);\n/// assert!(week.last_day() >= date);\n/// ```\n#[inline]\n#[must_use]\npub fn last_day(&self) -> NaiveDate{\n        let end = self.start.pred().num_days_from_monday() as i32;\n        let ref_day = self.date.weekday().num_days_from_monday() as i32;\n        // Calculate the number of days to add to `self.date`.\n        // Do not construct an intermediate date before `self.date` (like with `first_day()`),\n        // because that may be out of range if `date` is close to `NaiveDate::MIN`.\n        let days = end - ref_day + if end < ref_day { 7 } else { 0 };\n        self.date.diff_days(days as i64).unwrap()\n    }","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::date::div_mod_floor":["fn div_mod_floor(val: i32, div: i32) -> (i32, i32){\n    (val.div_euclid(div), val.rem_euclid(div))\n}","Real(LocalPath(\"src/naive/date.rs\"))"],"naive::datetime::NaiveDateTime":["/// ISO 8601 combined date and time without timezone.\n///\n/// # Example\n///\n/// `NaiveDateTime` is commonly created from [`NaiveDate`](./struct.NaiveDate.html).\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime};\n///\n/// let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_opt(9, 10, 11).unwrap();\n/// # let _ = dt;\n/// ```\n///\n/// You can use typical [date-like](../trait.Datelike.html) and\n/// [time-like](../trait.Timelike.html) methods,\n/// provided that relevant traits are in the scope.\n///\n/// ```\n/// # use chrono::{NaiveDate, NaiveDateTime};\n/// # let dt: NaiveDateTime = NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_opt(9, 10, 11).unwrap();\n/// use chrono::{Datelike, Timelike, Weekday};\n///\n/// assert_eq!(dt.weekday(), Weekday::Fri);\n/// assert_eq!(dt.num_seconds_from_midnight(), 33011);\n/// ```\npub struct NaiveDateTime {\n    date: NaiveDate,\n    time: NaiveTime,\n}","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::and_local_timezone":["/// Converts the `NaiveDateTime` into the timezone-aware `DateTime<Tz>`\n/// with the provided timezone, if possible.\n///\n/// This can fail in cases where the local time represented by the `NaiveDateTime`\n/// is not a valid local timestamp in the target timezone due to an offset transition\n/// for example if the target timezone had a change from +00:00 to +01:00\n/// occuring at 2015-09-05 22:59:59, then a local time of 2015-09-05 23:56:04\n/// could never occur. Similarly, if the offset transitioned in the opposite direction\n/// then there would be two local times of 2015-09-05 23:56:04, one at +00:00 and one\n/// at +01:00.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, FixedOffset};\n/// let hour = 3600;\n/// let tz = FixedOffset::east_opt(5 * hour).unwrap();\n/// let dt = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap().and_local_timezone(tz).unwrap();\n/// assert_eq!(dt.timezone(), tz);\n/// ```\n#[must_use]\npub fn and_local_timezone<Tz: TimeZone>(&self, tz: Tz) -> LocalResult<DateTime<Tz>>{\n        tz.from_local_datetime(self)\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::and_utc":["/// Converts the `NaiveDateTime` into the timezone-aware `DateTime<Utc>`.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Utc};\n/// let dt = NaiveDate::from_ymd_opt(2023, 1, 30).unwrap().and_hms_opt(19, 32, 33).unwrap().and_utc();\n/// assert_eq!(dt.timezone(), Utc);\n/// ```\n#[must_use]\npub fn and_utc(&self) -> DateTime<Utc>{\n        Utc.from_utc_datetime(self)\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::checked_add_days":["/// Add a duration in [`Days`] to the date part of the `NaiveDateTime`\n///\n/// Returns `None` if the resulting date would be out of range.\n#[must_use]\npub fn checked_add_days(self, days: Days) -> Option<Self>{\n        Some(Self { date: self.date.checked_add_days(days)?, ..self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::checked_add_months":["/// Adds given `Months` to the current date and time.\n///\n/// Returns `None` when it will result in overflow.\n///\n/// Overflow returns `None`.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Months, NaiveDate};\n///\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(1, 0, 0).unwrap()\n///         .checked_add_months(Months::new(1)),\n///     Some(NaiveDate::from_ymd_opt(2014, 2, 1).unwrap().and_hms_opt(1, 0, 0).unwrap())\n/// );\n///\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(1, 0, 0).unwrap()\n///         .checked_add_months(Months::new(core::i32::MAX as u32 + 1)),\n///     None\n/// );\n/// ```\n#[must_use]\npub fn checked_add_months(self, rhs: Months) -> Option<NaiveDateTime>{\n        Some(Self { date: self.date.checked_add_months(rhs)?, time: self.time })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::checked_add_signed":["/// Adds given `Duration` to the current date and time.\n///\n/// As a part of Chrono's [leap second handling](./struct.NaiveTime.html#leap-second-handling),\n/// the addition assumes that **there is no leap second ever**,\n/// except when the `NaiveDateTime` itself represents a leap second\n/// in which case the assumption becomes that **there is exactly a single leap second ever**.\n///\n/// Returns `None` when it will result in overflow.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Duration, NaiveDate};\n///\n/// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n///\n/// let d = from_ymd(2016, 7, 8);\n/// let hms = |h, m, s| d.and_hms_opt(h, m, s).unwrap();\n/// assert_eq!(hms(3, 5, 7).checked_add_signed(Duration::zero()),\n///            Some(hms(3, 5, 7)));\n/// assert_eq!(hms(3, 5, 7).checked_add_signed(Duration::seconds(1)),\n///            Some(hms(3, 5, 8)));\n/// assert_eq!(hms(3, 5, 7).checked_add_signed(Duration::seconds(-1)),\n///            Some(hms(3, 5, 6)));\n/// assert_eq!(hms(3, 5, 7).checked_add_signed(Duration::seconds(3600 + 60)),\n///            Some(hms(4, 6, 7)));\n/// assert_eq!(hms(3, 5, 7).checked_add_signed(Duration::seconds(86_400)),\n///            Some(from_ymd(2016, 7, 9).and_hms_opt(3, 5, 7).unwrap()));\n///\n/// let hmsm = |h, m, s, milli| d.and_hms_milli_opt(h, m, s, milli).unwrap();\n/// assert_eq!(hmsm(3, 5, 7, 980).checked_add_signed(Duration::milliseconds(450)),\n///            Some(hmsm(3, 5, 8, 430)));\n/// ```\n///\n/// Overflow returns `None`.\n///\n/// ```\n/// # use chrono::{Duration, NaiveDate};\n/// # let hms = |h, m, s| NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_opt(h, m, s).unwrap();\n/// assert_eq!(hms(3, 5, 7).checked_add_signed(Duration::days(1_000_000_000)), None);\n/// ```\n///\n/// Leap seconds are handled,\n/// but the addition assumes that it is the only leap second happened.\n///\n/// ```\n/// # use chrono::{Duration, NaiveDate};\n/// # let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n/// # let hmsm = |h, m, s, milli| from_ymd(2016, 7, 8).and_hms_milli_opt(h, m, s, milli).unwrap();\n/// let leap = hmsm(3, 5, 59, 1_300);\n/// assert_eq!(leap.checked_add_signed(Duration::zero()),\n///            Some(hmsm(3, 5, 59, 1_300)));\n/// assert_eq!(leap.checked_add_signed(Duration::milliseconds(-500)),\n///            Some(hmsm(3, 5, 59, 800)));\n/// assert_eq!(leap.checked_add_signed(Duration::milliseconds(500)),\n///            Some(hmsm(3, 5, 59, 1_800)));\n/// assert_eq!(leap.checked_add_signed(Duration::milliseconds(800)),\n///            Some(hmsm(3, 6, 0, 100)));\n/// assert_eq!(leap.checked_add_signed(Duration::seconds(10)),\n///            Some(hmsm(3, 6, 9, 300)));\n/// assert_eq!(leap.checked_add_signed(Duration::seconds(-10)),\n///            Some(hmsm(3, 5, 50, 300)));\n/// assert_eq!(leap.checked_add_signed(Duration::days(1)),\n///            Some(from_ymd(2016, 7, 9).and_hms_milli_opt(3, 5, 59, 300).unwrap()));\n/// ```\n#[must_use]\npub fn checked_add_signed(self, rhs: OldDuration) -> Option<NaiveDateTime>{\n        let (time, rhs) = self.time.overflowing_add_signed(rhs);\n\n        // early checking to avoid overflow in OldDuration::seconds\n        if rhs <= (-1 << MAX_SECS_BITS) || rhs >= (1 << MAX_SECS_BITS) {\n            return None;\n        }\n\n        let date = self.date.checked_add_signed(OldDuration::seconds(rhs))?;\n        Some(NaiveDateTime { date, time })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::checked_sub_days":["/// Subtract a duration in [`Days`] from the date part of the `NaiveDateTime`\n///\n/// Returns `None` if the resulting date would be out of range.\n#[must_use]\npub fn checked_sub_days(self, days: Days) -> Option<Self>{\n        Some(Self { date: self.date.checked_sub_days(days)?, ..self })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::checked_sub_months":["/// Subtracts given `Months` from the current date and time.\n///\n/// Returns `None` when it will result in overflow.\n///\n/// Overflow returns `None`.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Months, NaiveDate};\n///\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(1, 0, 0).unwrap()\n///         .checked_sub_months(Months::new(1)),\n///     Some(NaiveDate::from_ymd_opt(2013, 12, 1).unwrap().and_hms_opt(1, 0, 0).unwrap())\n/// );\n///\n/// assert_eq!(\n///     NaiveDate::from_ymd_opt(2014, 1, 1).unwrap().and_hms_opt(1, 0, 0).unwrap()\n///         .checked_sub_months(Months::new(core::i32::MAX as u32 + 1)),\n///     None\n/// );\n/// ```\n#[must_use]\npub fn checked_sub_months(self, rhs: Months) -> Option<NaiveDateTime>{\n        Some(Self { date: self.date.checked_sub_months(rhs)?, time: self.time })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::checked_sub_signed":["/// Subtracts given `Duration` from the current date and time.\n///\n/// As a part of Chrono's [leap second handling](./struct.NaiveTime.html#leap-second-handling),\n/// the subtraction assumes that **there is no leap second ever**,\n/// except when the `NaiveDateTime` itself represents a leap second\n/// in which case the assumption becomes that **there is exactly a single leap second ever**.\n///\n/// Returns `None` when it will result in overflow.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Duration, NaiveDate};\n///\n/// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n///\n/// let d = from_ymd(2016, 7, 8);\n/// let hms = |h, m, s| d.and_hms_opt(h, m, s).unwrap();\n/// assert_eq!(hms(3, 5, 7).checked_sub_signed(Duration::zero()),\n///            Some(hms(3, 5, 7)));\n/// assert_eq!(hms(3, 5, 7).checked_sub_signed(Duration::seconds(1)),\n///            Some(hms(3, 5, 6)));\n/// assert_eq!(hms(3, 5, 7).checked_sub_signed(Duration::seconds(-1)),\n///            Some(hms(3, 5, 8)));\n/// assert_eq!(hms(3, 5, 7).checked_sub_signed(Duration::seconds(3600 + 60)),\n///            Some(hms(2, 4, 7)));\n/// assert_eq!(hms(3, 5, 7).checked_sub_signed(Duration::seconds(86_400)),\n///            Some(from_ymd(2016, 7, 7).and_hms_opt(3, 5, 7).unwrap()));\n///\n/// let hmsm = |h, m, s, milli| d.and_hms_milli_opt(h, m, s, milli).unwrap();\n/// assert_eq!(hmsm(3, 5, 7, 450).checked_sub_signed(Duration::milliseconds(670)),\n///            Some(hmsm(3, 5, 6, 780)));\n/// ```\n///\n/// Overflow returns `None`.\n///\n/// ```\n/// # use chrono::{Duration, NaiveDate};\n/// # let hms = |h, m, s| NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_opt(h, m, s).unwrap();\n/// assert_eq!(hms(3, 5, 7).checked_sub_signed(Duration::days(1_000_000_000)), None);\n/// ```\n///\n/// Leap seconds are handled,\n/// but the subtraction assumes that it is the only leap second happened.\n///\n/// ```\n/// # use chrono::{Duration, NaiveDate};\n/// # let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n/// # let hmsm = |h, m, s, milli| from_ymd(2016, 7, 8).and_hms_milli_opt(h, m, s, milli).unwrap();\n/// let leap = hmsm(3, 5, 59, 1_300);\n/// assert_eq!(leap.checked_sub_signed(Duration::zero()),\n///            Some(hmsm(3, 5, 59, 1_300)));\n/// assert_eq!(leap.checked_sub_signed(Duration::milliseconds(200)),\n///            Some(hmsm(3, 5, 59, 1_100)));\n/// assert_eq!(leap.checked_sub_signed(Duration::milliseconds(500)),\n///            Some(hmsm(3, 5, 59, 800)));\n/// assert_eq!(leap.checked_sub_signed(Duration::seconds(60)),\n///            Some(hmsm(3, 5, 0, 300)));\n/// assert_eq!(leap.checked_sub_signed(Duration::days(1)),\n///            Some(from_ymd(2016, 7, 7).and_hms_milli_opt(3, 6, 0, 300).unwrap()));\n/// ```\n#[must_use]\npub fn checked_sub_signed(self, rhs: OldDuration) -> Option<NaiveDateTime>{\n        let (time, rhs) = self.time.overflowing_sub_signed(rhs);\n\n        // early checking to avoid overflow in OldDuration::seconds\n        if rhs <= (-1 << MAX_SECS_BITS) || rhs >= (1 << MAX_SECS_BITS) {\n            return None;\n        }\n\n        let date = self.date.checked_sub_signed(OldDuration::seconds(rhs))?;\n        Some(NaiveDateTime { date, time })\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::date":["/// Retrieves a date component.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let dt = NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_opt(9, 10, 11).unwrap();\n/// assert_eq!(dt.date(), NaiveDate::from_ymd_opt(2016, 7, 8).unwrap());\n/// ```\n#[inline]\npub const fn date(&self) -> NaiveDate{\n        self.date\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::format":["/// Formats the combined date and time with the specified format string.\n/// See the [`format::strftime` module](../format/strftime/index.html)\n/// on the supported escape sequences.\n///\n/// This returns a `DelayedFormat`,\n/// which gets converted to a string only when actual formatting happens.\n/// You may use the `to_string` method to get a `String`,\n/// or just feed it into `print!` and other formatting macros.\n/// (In this way it avoids the redundant memory allocation.)\n///\n/// A wrong format string does *not* issue an error immediately.\n/// Rather, converting or formatting the `DelayedFormat` fails.\n/// You are recommended to immediately use `DelayedFormat` for this reason.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let dt = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap();\n/// assert_eq!(dt.format(\"%Y-%m-%d %H:%M:%S\").to_string(), \"2015-09-05 23:56:04\");\n/// assert_eq!(dt.format(\"around %l %p on %b %-d\").to_string(), \"around 11 PM on Sep 5\");\n/// ```\n///\n/// The resulting `DelayedFormat` can be formatted directly via the `Display` trait.\n///\n/// ```\n/// # use chrono::NaiveDate;\n/// # let dt = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap();\n/// assert_eq!(format!(\"{}\", dt.format(\"%Y-%m-%d %H:%M:%S\")), \"2015-09-05 23:56:04\");\n/// assert_eq!(format!(\"{}\", dt.format(\"around %l %p on %b %-d\")), \"around 11 PM on Sep 5\");\n/// ```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[inline]\n#[must_use]\npub fn format<'a>(&self, fmt: &'a str) -> DelayedFormat<StrftimeItems<'a>>{\n        self.format_with_items(StrftimeItems::new(fmt))\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::format_with_items":["/// Formats the combined date and time with the specified formatting items.\n/// Otherwise it is the same as the ordinary [`format`](#method.format) method.\n///\n/// The `Iterator` of items should be `Clone`able,\n/// since the resulting `DelayedFormat` value may be formatted multiple times.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n/// use chrono::format::strftime::StrftimeItems;\n///\n/// let fmt = StrftimeItems::new(\"%Y-%m-%d %H:%M:%S\");\n/// let dt = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap();\n/// assert_eq!(dt.format_with_items(fmt.clone()).to_string(), \"2015-09-05 23:56:04\");\n/// assert_eq!(dt.format(\"%Y-%m-%d %H:%M:%S\").to_string(),    \"2015-09-05 23:56:04\");\n/// ```\n///\n/// The resulting `DelayedFormat` can be formatted directly via the `Display` trait.\n///\n/// ```\n/// # use chrono::NaiveDate;\n/// # use chrono::format::strftime::StrftimeItems;\n/// # let fmt = StrftimeItems::new(\"%Y-%m-%d %H:%M:%S\").clone();\n/// # let dt = NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap();\n/// assert_eq!(format!(\"{}\", dt.format_with_items(fmt)), \"2015-09-05 23:56:04\");\n/// ```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[inline]\n#[must_use]\npub fn format_with_items<'a, I, B>(&self, items: I) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,{\n        DelayedFormat::new(Some(self.date), Some(self.time), items)\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::from_timestamp":["/// Makes a new `NaiveDateTime` corresponding to a UTC date and time,\n/// from the number of non-leap seconds\n/// since the midnight UTC on January 1, 1970 (aka \"UNIX timestamp\")\n/// and the number of nanoseconds since the last whole non-leap second.\n///\n/// For a non-naive version of this function see\n/// [`TimeZone::timestamp`](../offset/trait.TimeZone.html#method.timestamp).\n///\n/// The nanosecond part can exceed 1,000,000,000 in order to represent the\n/// [leap second](./struct.NaiveTime.html#leap-second-handling). (The true \"UNIX\n/// timestamp\" cannot represent a leap second unambiguously.)\n///\n/// Panics on the out-of-range number of seconds and/or invalid nanosecond.\n#[deprecated(since = \"0.4.23\", note = \"use `from_timestamp_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn from_timestamp(secs: i64, nsecs: u32) -> NaiveDateTime{\n        let datetime = NaiveDateTime::from_timestamp_opt(secs, nsecs);\n        datetime.expect(\"invalid or out-of-range datetime\")\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::from_timestamp_micros":["/// Creates a new [NaiveDateTime] from microseconds since the UNIX epoch.\n///\n/// The UNIX epoch starts on midnight, January 1, 1970, UTC.\n///\n/// Returns `None` on an out-of-range number of microseconds.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDateTime;\n/// let timestamp_micros: i64 = 1662921288000000; //Sunday, September 11, 2022 6:34:48 PM\n/// let naive_datetime = NaiveDateTime::from_timestamp_micros(timestamp_micros);\n/// assert!(naive_datetime.is_some());\n/// assert_eq!(timestamp_micros, naive_datetime.unwrap().timestamp_micros());\n///\n/// // Negative timestamps (before the UNIX epoch) are supported as well.\n/// let timestamp_micros: i64 = -2208936075000000; //Mon Jan 01 1900 14:38:45 GMT+0000\n/// let naive_datetime = NaiveDateTime::from_timestamp_micros(timestamp_micros);\n/// assert!(naive_datetime.is_some());\n/// assert_eq!(timestamp_micros, naive_datetime.unwrap().timestamp_micros());\n/// ```\n#[inline]\n#[must_use]\npub fn from_timestamp_micros(micros: i64) -> Option<NaiveDateTime>{\n        let secs = micros.div_euclid(1_000_000);\n        let nsecs = micros.rem_euclid(1_000_000) as u32 * 1000;\n        NaiveDateTime::from_timestamp_opt(secs, nsecs)\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::from_timestamp_millis":["/// Creates a new [NaiveDateTime] from milliseconds since the UNIX epoch.\n///\n/// The UNIX epoch starts on midnight, January 1, 1970, UTC.\n///\n/// Returns `None` on an out-of-range number of milliseconds.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDateTime;\n/// let timestamp_millis: i64 = 1662921288000; //Sunday, September 11, 2022 6:34:48 PM\n/// let naive_datetime = NaiveDateTime::from_timestamp_millis(timestamp_millis);\n/// assert!(naive_datetime.is_some());\n/// assert_eq!(timestamp_millis, naive_datetime.unwrap().timestamp_millis());\n///\n/// // Negative timestamps (before the UNIX epoch) are supported as well.\n/// let timestamp_millis: i64 = -2208936075000; //Mon Jan 01 1900 14:38:45 GMT+0000\n/// let naive_datetime = NaiveDateTime::from_timestamp_millis(timestamp_millis);\n/// assert!(naive_datetime.is_some());\n/// assert_eq!(timestamp_millis, naive_datetime.unwrap().timestamp_millis());\n/// ```\n#[inline]\n#[must_use]\npub fn from_timestamp_millis(millis: i64) -> Option<NaiveDateTime>{\n        let secs = millis.div_euclid(1000);\n        let nsecs = millis.rem_euclid(1000) as u32 * 1_000_000;\n        NaiveDateTime::from_timestamp_opt(secs, nsecs)\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::from_timestamp_opt":["/// Makes a new `NaiveDateTime` corresponding to a UTC date and time,\n/// from the number of non-leap seconds\n/// since the midnight UTC on January 1, 1970 (aka \"UNIX timestamp\")\n/// and the number of nanoseconds since the last whole non-leap second.\n///\n/// The nanosecond part can exceed 1,000,000,000\n/// in order to represent the [leap second](./struct.NaiveTime.html#leap-second-handling).\n/// (The true \"UNIX timestamp\" cannot represent a leap second unambiguously.)\n///\n/// Returns `None` on the out-of-range number of seconds (more than 262 000 years away\n/// from common era) and/or invalid nanosecond (2 seconds or more).\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDateTime;\n/// use std::i64;\n///\n/// let from_timestamp_opt = NaiveDateTime::from_timestamp_opt;\n///\n/// assert!(from_timestamp_opt(0, 0).is_some());\n/// assert!(from_timestamp_opt(0, 999_999_999).is_some());\n/// assert!(from_timestamp_opt(0, 1_500_000_000).is_some()); // leap second\n/// assert!(from_timestamp_opt(0, 2_000_000_000).is_none());\n/// assert!(from_timestamp_opt(i64::MAX, 0).is_none());\n/// ```\n#[inline]\n#[must_use]\npub fn from_timestamp_opt(secs: i64, nsecs: u32) -> Option<NaiveDateTime>{\n        let days = secs.div_euclid(86_400);\n        let secs = secs.rem_euclid(86_400);\n        let date = i32::try_from(days)\n            .ok()\n            .and_then(|days| days.checked_add(719_163))\n            .and_then(NaiveDate::from_num_days_from_ce_opt);\n        let time = NaiveTime::from_num_seconds_from_midnight_opt(secs as u32, nsecs);\n        match (date, time) {\n            (Some(date), Some(time)) => Some(NaiveDateTime { date, time }),\n            (_, _) => None,\n        }\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::new":["/// Makes a new `NaiveDateTime` from date and time components.\n/// Equivalent to [`date.and_time(time)`](./struct.NaiveDate.html#method.and_time)\n/// and many other helper constructors on `NaiveDate`.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveTime, NaiveDateTime};\n///\n/// let d = NaiveDate::from_ymd_opt(2015, 6, 3).unwrap();\n/// let t = NaiveTime::from_hms_milli_opt(12, 34, 56, 789).unwrap();\n///\n/// let dt = NaiveDateTime::new(d, t);\n/// assert_eq!(dt.date(), d);\n/// assert_eq!(dt.time(), t);\n/// ```\n#[inline]\npub const fn new(date: NaiveDate, time: NaiveTime) -> NaiveDateTime{\n        NaiveDateTime { date, time }\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::parse_and_remainder":["/// Parses a string with the specified format string and returns a new `NaiveDateTime`, and a\n/// slice with the remaining portion of the string.\n/// See the [`format::strftime` module](../format/strftime/index.html)\n/// on the supported escape sequences.\n///\n/// Similar to [`parse_from_str`](#method.parse_from_str).\n///\n/// # Example\n///\n/// ```rust\n/// # use chrono::{NaiveDate, NaiveDateTime};\n/// let (datetime, remainder) = NaiveDateTime::parse_and_remainder(\n///     \"2015-02-18 23:16:09 trailing text\", \"%Y-%m-%d %H:%M:%S\").unwrap();\n/// assert_eq!(\n///     datetime,\n///     NaiveDate::from_ymd_opt(2015, 2, 18).unwrap().and_hms_opt(23, 16, 9).unwrap()\n/// );\n/// assert_eq!(remainder, \" trailing text\");\n/// ```\npub fn parse_and_remainder<'a>(s: &'a str, fmt: &str) -> ParseResult<(NaiveDateTime, &'a str)>{\n        let mut parsed = Parsed::new();\n        let remainder = parse_and_remainder(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_naive_datetime_with_offset(0).map(|d| (d, remainder)) // no offset adjustment\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::parse_from_str":["/// Parses a string with the specified format string and returns a new `NaiveDateTime`.\n/// See the [`format::strftime` module](../format/strftime/index.html)\n/// on the supported escape sequences.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDateTime, NaiveDate};\n///\n/// let parse_from_str = NaiveDateTime::parse_from_str;\n///\n/// assert_eq!(parse_from_str(\"2015-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\"),\n///            Ok(NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_opt(23, 56, 4).unwrap()));\n/// assert_eq!(parse_from_str(\"5sep2015pm012345.6789\", \"%d%b%Y%p%I%M%S%.f\"),\n///            Ok(NaiveDate::from_ymd_opt(2015, 9, 5).unwrap().and_hms_micro_opt(13, 23, 45, 678_900).unwrap()));\n/// ```\n///\n/// Offset is ignored for the purpose of parsing.\n///\n/// ```\n/// # use chrono::{NaiveDateTime, NaiveDate};\n/// # let parse_from_str = NaiveDateTime::parse_from_str;\n/// assert_eq!(parse_from_str(\"2014-5-17T12:34:56+09:30\", \"%Y-%m-%dT%H:%M:%S%z\"),\n///            Ok(NaiveDate::from_ymd_opt(2014, 5, 17).unwrap().and_hms_opt(12, 34, 56).unwrap()));\n/// ```\n///\n/// [Leap seconds](./struct.NaiveTime.html#leap-second-handling) are correctly handled by\n/// treating any time of the form `hh:mm:60` as a leap second.\n/// (This equally applies to the formatting, so the round trip is possible.)\n///\n/// ```\n/// # use chrono::{NaiveDateTime, NaiveDate};\n/// # let parse_from_str = NaiveDateTime::parse_from_str;\n/// assert_eq!(parse_from_str(\"2015-07-01 08:59:60.123\", \"%Y-%m-%d %H:%M:%S%.f\"),\n///            Ok(NaiveDate::from_ymd_opt(2015, 7, 1).unwrap().and_hms_milli_opt(8, 59, 59, 1_123).unwrap()));\n/// ```\n///\n/// Missing seconds are assumed to be zero,\n/// but out-of-bound times or insufficient fields are errors otherwise.\n///\n/// ```\n/// # use chrono::{NaiveDateTime, NaiveDate};\n/// # let parse_from_str = NaiveDateTime::parse_from_str;\n/// assert_eq!(parse_from_str(\"94/9/4 7:15\", \"%y/%m/%d %H:%M\"),\n///            Ok(NaiveDate::from_ymd_opt(1994, 9, 4).unwrap().and_hms_opt(7, 15, 0).unwrap()));\n///\n/// assert!(parse_from_str(\"04m33s\", \"%Mm%Ss\").is_err());\n/// assert!(parse_from_str(\"94/9/4 12\", \"%y/%m/%d %H\").is_err());\n/// assert!(parse_from_str(\"94/9/4 17:60\", \"%y/%m/%d %H:%M\").is_err());\n/// assert!(parse_from_str(\"94/9/4 24:00:00\", \"%y/%m/%d %H:%M:%S\").is_err());\n/// ```\n///\n/// All parsed fields should be consistent to each other, otherwise it's an error.\n///\n/// ```\n/// # use chrono::NaiveDateTime;\n/// # let parse_from_str = NaiveDateTime::parse_from_str;\n/// let fmt = \"%Y-%m-%d %H:%M:%S = UNIX timestamp %s\";\n/// assert!(parse_from_str(\"2001-09-09 01:46:39 = UNIX timestamp 999999999\", fmt).is_ok());\n/// assert!(parse_from_str(\"1970-01-01 00:00:00 = UNIX timestamp 1\", fmt).is_err());\n/// ```\n///\n/// Years before 1 BCE or after 9999 CE, require an initial sign\n///\n///```\n/// # use chrono::NaiveDateTime;\n/// # let parse_from_str = NaiveDateTime::parse_from_str;\n/// let fmt = \"%Y-%m-%d %H:%M:%S\";\n/// assert!(parse_from_str(\"10000-09-09 01:46:39\", fmt).is_err());\n/// assert!(parse_from_str(\"+10000-09-09 01:46:39\", fmt).is_ok());\n///```\npub fn parse_from_str(s: &str, fmt: &str) -> ParseResult<NaiveDateTime>{\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_naive_datetime_with_offset(0) // no offset adjustment\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::signed_duration_since":["/// Subtracts another `NaiveDateTime` from the current date and time.\n/// This does not overflow or underflow at all.\n///\n/// As a part of Chrono's [leap second handling](./struct.NaiveTime.html#leap-second-handling),\n/// the subtraction assumes that **there is no leap second ever**,\n/// except when any of the `NaiveDateTime`s themselves represents a leap second\n/// in which case the assumption becomes that\n/// **there are exactly one (or two) leap second(s) ever**.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Duration, NaiveDate};\n///\n/// let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n///\n/// let d = from_ymd(2016, 7, 8);\n/// assert_eq!(d.and_hms_opt(3, 5, 7).unwrap().signed_duration_since(d.and_hms_opt(2, 4, 6).unwrap()),\n///            Duration::seconds(3600 + 60 + 1));\n///\n/// // July 8 is 190th day in the year 2016\n/// let d0 = from_ymd(2016, 1, 1);\n/// assert_eq!(d.and_hms_milli_opt(0, 7, 6, 500).unwrap().signed_duration_since(d0.and_hms_opt(0, 0, 0).unwrap()),\n///            Duration::seconds(189 * 86_400 + 7 * 60 + 6) + Duration::milliseconds(500));\n/// ```\n///\n/// Leap seconds are handled, but the subtraction assumes that\n/// there were no other leap seconds happened.\n///\n/// ```\n/// # use chrono::{Duration, NaiveDate};\n/// # let from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();\n/// let leap = from_ymd(2015, 6, 30).and_hms_milli_opt(23, 59, 59, 1_500).unwrap();\n/// assert_eq!(leap.signed_duration_since(from_ymd(2015, 6, 30).and_hms_opt(23, 0, 0).unwrap()),\n///            Duration::seconds(3600) + Duration::milliseconds(500));\n/// assert_eq!(from_ymd(2015, 7, 1).and_hms_opt(1, 0, 0).unwrap().signed_duration_since(leap),\n///            Duration::seconds(3600) - Duration::milliseconds(500));\n/// ```\n#[must_use]\npub fn signed_duration_since(self, rhs: NaiveDateTime) -> OldDuration{\n        self.date.signed_duration_since(rhs.date) + self.time.signed_duration_since(rhs.time)\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::time":["/// Retrieves a time component.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveTime};\n///\n/// let dt = NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_opt(9, 10, 11).unwrap();\n/// assert_eq!(dt.time(), NaiveTime::from_hms_opt(9, 10, 11).unwrap());\n/// ```\n#[inline]\npub const fn time(&self) -> NaiveTime{\n        self.time\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::timestamp":["/// Returns the number of non-leap seconds since the midnight on January 1, 1970.\n///\n/// Note that this does *not* account for the timezone!\n/// The true \"UNIX timestamp\" would count seconds since the midnight *UTC* on the epoch.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_milli_opt(0, 0, 1, 980).unwrap();\n/// assert_eq!(dt.timestamp(), 1);\n///\n/// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_opt(1, 46, 40).unwrap();\n/// assert_eq!(dt.timestamp(), 1_000_000_000);\n///\n/// let dt = NaiveDate::from_ymd_opt(1969, 12, 31).unwrap().and_hms_opt(23, 59, 59).unwrap();\n/// assert_eq!(dt.timestamp(), -1);\n///\n/// let dt = NaiveDate::from_ymd_opt(-1, 1, 1).unwrap().and_hms_opt(0, 0, 0).unwrap();\n/// assert_eq!(dt.timestamp(), -62198755200);\n/// ```\n#[inline]\n#[must_use]\npub fn timestamp(&self) -> i64{\n        const UNIX_EPOCH_DAY: i64 = 719_163;\n        let gregorian_day = i64::from(self.date.num_days_from_ce());\n        let seconds_from_midnight = i64::from(self.time.num_seconds_from_midnight());\n        (gregorian_day - UNIX_EPOCH_DAY) * 86_400 + seconds_from_midnight\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::timestamp_micros":["/// Returns the number of non-leap *microseconds* since midnight on January 1, 1970.\n///\n/// Note that this does *not* account for the timezone!\n/// The true \"UNIX timestamp\" would count seconds since the midnight *UTC* on the epoch.\n///\n/// Note also that this does reduce the number of years that can be\n/// represented from ~584 Billion to ~584 Thousand. (If this is a problem,\n/// please file an issue to let me know what domain needs microsecond\n/// precision over millennia, I'm curious.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_micro_opt(0, 0, 1, 444).unwrap();\n/// assert_eq!(dt.timestamp_micros(), 1_000_444);\n///\n/// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_micro_opt(1, 46, 40, 555).unwrap();\n/// assert_eq!(dt.timestamp_micros(), 1_000_000_000_000_555);\n/// ```\n#[inline]\n#[must_use]\npub fn timestamp_micros(&self) -> i64{\n        let as_us = self.timestamp() * 1_000_000;\n        as_us + i64::from(self.timestamp_subsec_micros())\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::timestamp_millis":["/// Returns the number of non-leap *milliseconds* since midnight on January 1, 1970.\n///\n/// Note that this does *not* account for the timezone!\n/// The true \"UNIX timestamp\" would count seconds since the midnight *UTC* on the epoch.\n///\n/// Note also that this does reduce the number of years that can be\n/// represented from ~584 Billion to ~584 Million. (If this is a problem,\n/// please file an issue to let me know what domain needs millisecond\n/// precision over billions of years, I'm curious.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_milli_opt(0, 0, 1, 444).unwrap();\n/// assert_eq!(dt.timestamp_millis(), 1_444);\n///\n/// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_milli_opt(1, 46, 40, 555).unwrap();\n/// assert_eq!(dt.timestamp_millis(), 1_000_000_000_555);\n///\n/// let dt = NaiveDate::from_ymd_opt(1969, 12, 31).unwrap().and_hms_milli_opt(23, 59, 59, 100).unwrap();\n/// assert_eq!(dt.timestamp_millis(), -900);\n/// ```\n#[inline]\n#[must_use]\npub fn timestamp_millis(&self) -> i64{\n        let as_ms = self.timestamp() * 1000;\n        as_ms + i64::from(self.timestamp_subsec_millis())\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::timestamp_nanos":["/// Returns the number of non-leap *nanoseconds* since midnight on January 1, 1970.\n///\n/// Note that this does *not* account for the timezone!\n/// The true \"UNIX timestamp\" would count seconds since the midnight *UTC* on the epoch.\n///\n/// # Panics\n///\n/// Note also that this does reduce the number of years that can be\n/// represented from ~584 Billion to ~584 years. The dates that can be\n/// represented as nanoseconds are between 1677-09-21T00:12:44.0 and\n/// 2262-04-11T23:47:16.854775804.\n///\n/// (If this is a problem, please file an issue to let me know what domain\n/// needs nanosecond precision over millennia, I'm curious.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveDateTime};\n///\n/// let dt = NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().and_hms_nano_opt(0, 0, 1, 444).unwrap();\n/// assert_eq!(dt.timestamp_nanos(), 1_000_000_444);\n///\n/// let dt = NaiveDate::from_ymd_opt(2001, 9, 9).unwrap().and_hms_nano_opt(1, 46, 40, 555).unwrap();\n///\n/// const A_BILLION: i64 = 1_000_000_000;\n/// let nanos = dt.timestamp_nanos();\n/// assert_eq!(nanos, 1_000_000_000_000_000_555);\n/// assert_eq!(\n///     Some(dt),\n///     NaiveDateTime::from_timestamp_opt(nanos / A_BILLION, (nanos % A_BILLION) as u32)\n/// );\n/// ```\n#[inline]\n#[must_use]\npub fn timestamp_nanos(&self) -> i64{\n        let as_ns = self.timestamp() * 1_000_000_000;\n        as_ns + i64::from(self.timestamp_subsec_nanos())\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::timestamp_subsec_micros":["/// Returns the number of microseconds since the last whole non-leap second.\n///\n/// The return value ranges from 0 to 999,999,\n/// or for [leap seconds](./struct.NaiveTime.html#leap-second-handling), to 1,999,999.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let dt = NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_nano_opt(9, 10, 11, 123_456_789).unwrap();\n/// assert_eq!(dt.timestamp_subsec_micros(), 123_456);\n///\n/// let dt = NaiveDate::from_ymd_opt(2015, 7, 1).unwrap().and_hms_nano_opt(8, 59, 59, 1_234_567_890).unwrap();\n/// assert_eq!(dt.timestamp_subsec_micros(), 1_234_567);\n/// ```\n#[inline]\n#[must_use]\npub fn timestamp_subsec_micros(&self) -> u32{\n        self.timestamp_subsec_nanos() / 1_000\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::timestamp_subsec_millis":["/// Returns the number of milliseconds since the last whole non-leap second.\n///\n/// The return value ranges from 0 to 999,\n/// or for [leap seconds](./struct.NaiveTime.html#leap-second-handling), to 1,999.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let dt = NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_nano_opt(9, 10, 11, 123_456_789).unwrap();\n/// assert_eq!(dt.timestamp_subsec_millis(), 123);\n///\n/// let dt = NaiveDate::from_ymd_opt(2015, 7, 1).unwrap().and_hms_nano_opt(8, 59, 59, 1_234_567_890).unwrap();\n/// assert_eq!(dt.timestamp_subsec_millis(), 1_234);\n/// ```\n#[inline]\n#[must_use]\npub fn timestamp_subsec_millis(&self) -> u32{\n        self.timestamp_subsec_nanos() / 1_000_000\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::datetime::NaiveDateTime::timestamp_subsec_nanos":["/// Returns the number of nanoseconds since the last whole non-leap second.\n///\n/// The return value ranges from 0 to 999,999,999,\n/// or for [leap seconds](./struct.NaiveTime.html#leap-second-handling), to 1,999,999,999.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveDate;\n///\n/// let dt = NaiveDate::from_ymd_opt(2016, 7, 8).unwrap().and_hms_nano_opt(9, 10, 11, 123_456_789).unwrap();\n/// assert_eq!(dt.timestamp_subsec_nanos(), 123_456_789);\n///\n/// let dt = NaiveDate::from_ymd_opt(2015, 7, 1).unwrap().and_hms_nano_opt(8, 59, 59, 1_234_567_890).unwrap();\n/// assert_eq!(dt.timestamp_subsec_nanos(), 1_234_567_890);\n/// ```\n#[inline]\n#[must_use]\npub fn timestamp_subsec_nanos(&self) -> u32{\n        self.time.nanosecond()\n    }","Real(LocalPath(\"src/naive/datetime/mod.rs\"))"],"naive::internals::Mdf":["/// Month, day of month and year flags: `(month << 9) | (day << 4) | flags`\n///\n/// The whole bits except for the least 3 bits are referred as `Mdl`\n/// (month, day of month and leap flag),\n/// which is an index to the `MDL_TO_OL` lookup table.\n///\n/// The methods implemented on `Mdf` do not always return a valid value.\n/// Dates that can't exist, like February 30, can still be represented.\n/// Use `Mdl::valid` to check whether the date is valid.\npub(super) struct Mdf(u32);","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Mdf::day":["#[inline]\npub(super) const fn day(&self) -> u32{\n        let Mdf(mdf) = *self;\n        (mdf >> 4) & 0b1_1111\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Mdf::from_of":["#[inline]\npub(super) const fn from_of(Of(of): Of) -> Mdf{\n        let ol = of >> 3;\n        if ol <= MAX_OL {\n            // Array is indexed from `[1..=MAX_OL]`, with a `0` index having a meaningless value.\n            Mdf(of + ((OL_TO_MDL[ol as usize] as u32) << 3))\n        } else {\n            // Panicking here would be reasonable, but we are just going on with a safe value.\n            Mdf(0)\n        }\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Mdf::month":["#[inline]\npub(super) const fn month(&self) -> u32{\n        let Mdf(mdf) = *self;\n        mdf >> 9\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Mdf::new":["#[inline]\npub(super) const fn new(month: u32, day: u32, YearFlags(flags): YearFlags) -> Option<Mdf>{\n        match month >= 1 && month <= 12 && day >= 1 && day <= 31 {\n            true => Some(Mdf((month << 9) | (day << 4) | flags as u32)),\n            false => None,\n        }\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Mdf::to_of":["#[inline]\npub(super) const fn to_of(&self) -> Option<Of>{\n        Of::from_mdf(*self)\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Mdf::with_day":["#[inline]\npub(super) const fn with_day(&self, day: u32) -> Option<Mdf>{\n        if day > 31 {\n            return None;\n        }\n\n        let Mdf(mdf) = *self;\n        Some(Mdf((mdf & !0b1_1111_0000) | (day << 4)))\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Mdf::with_flags":["#[inline]\npub(super) const fn with_flags(&self, YearFlags(flags): YearFlags) -> Mdf{\n        let Mdf(mdf) = *self;\n        Mdf((mdf & !0b1111) | flags as u32)\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Mdf::with_month":["#[inline]\npub(super) const fn with_month(&self, month: u32) -> Option<Mdf>{\n        if month > 12 {\n            return None;\n        }\n\n        let Mdf(mdf) = *self;\n        Some(Mdf((mdf & 0b1_1111_1111) | (month << 9)))\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of":["/// Ordinal (day of year) and year flags: `(ordinal << 4) | flags`.\n///\n/// The whole bits except for the least 3 bits are referred as `Ol` (ordinal and leap flag),\n/// which is an index to the `OL_TO_MDL` lookup table.\n///\n/// The methods implemented on `Of` always return a valid value.\npub(super) struct Of(u32);","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::flags":["#[inline]\npub(super) const fn flags(&self) -> YearFlags{\n        YearFlags((self.0 & 0b1111) as u8)\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::from_date_impl":["pub(super) const fn from_date_impl(date_impl: DateImpl) -> Of{\n        // We assume the value in the `DateImpl` is valid.\n        Of((date_impl & 0b1_1111_1111_1111) as u32)\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::from_mdf":["#[inline]\npub(super) const fn from_mdf(Mdf(mdf): Mdf) -> Option<Of>{\n        let mdl = mdf >> 3;\n        if mdl > MAX_MDL {\n            // Panicking on out-of-bounds indexing would be reasonable, but just return `None`.\n            return None;\n        }\n        // Array is indexed from `[1..=MAX_MDL]`, with a `0` index having a meaningless value.\n        let v = MDL_TO_OL[mdl as usize];\n        let of = Of(mdf.wrapping_sub((v as i32 as u32 & 0x3ff) << 3));\n        of.validate()\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::inner":["#[inline]\npub(super) const fn inner(&self) -> u32{\n        self.0\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::isoweekdate_raw":["#[inline]\npub(super) fn isoweekdate_raw(&self) -> (u32, Weekday){\n        // week ordinal = ordinal + delta\n        let Of(of) = *self;\n        let weekord = (of >> 4).wrapping_add(self.flags().isoweek_delta());\n        (weekord / 7, weekday_from_u32_mod7(weekord))\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::new":["#[inline]\npub(super) const fn new(ordinal: u32, YearFlags(flags): YearFlags) -> Option<Of>{\n        let of = Of((ordinal << 4) | flags as u32);\n        of.validate()\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::ol":["/// Returns `(ordinal << 1) | leap-year-flag`.\n#[inline]\nconst fn ol(&self) -> u32{\n        self.0 >> 3\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::ordinal":["#[inline]\npub(super) const fn ordinal(&self) -> u32{\n        self.0 >> 4\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::pred":["/// Returns an `Of` with the previous day, or `None` if this is the first day of the year.\n#[inline]\npub(super) const fn pred(&self) -> Option<Of>{\n        match self.ordinal() {\n            1 => None,\n            _ => Some(Of(self.0 - (1 << 4))),\n        }\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::succ":["/// Returns an `Of` with the next day, or `None` if this is the last day of the year.\n#[inline]\npub(super) const fn succ(&self) -> Option<Of>{\n        let of = Of(self.0 + (1 << 4));\n        of.validate()\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::to_mdf":["#[inline]\npub(super) const fn to_mdf(&self) -> Mdf{\n        Mdf::from_of(*self)\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::validate":["#[inline]\nconst fn validate(self) -> Option<Of>{\n        let ol = self.ol();\n        match ol >= MIN_OL && ol <= MAX_OL {\n            true => Some(self),\n            false => None,\n        }\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::weekday":["#[inline]\npub(super) const fn weekday(&self) -> Weekday{\n        let Of(of) = *self;\n        weekday_from_u32_mod7((of >> 4) + (of & 0b111))\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::Of::with_ordinal":["#[inline]\npub(super) const fn with_ordinal(&self, ordinal: u32) -> Option<Of>{\n        let of = Of((ordinal << 4) | (self.0 & 0b1111));\n        of.validate()\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::YearFlags":["/// The year flags (aka the dominical letter).\n///\n/// There are 14 possible classes of year in the Gregorian calendar:\n/// common and leap years starting with Monday through Sunday.\n/// The `YearFlags` stores this information into 4 bits `abbb`,\n/// where `a` is `1` for the common year (simplifies the `Of` validation)\n/// and `bbb` is a non-zero `Weekday` (mapping `Mon` to 7) of the last day in the past year\n/// (simplifies the day of week calculation from the 1-based ordinal).\n#[allow(unreachable_pub)]\npub struct YearFlags(pub(super) u8);","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::YearFlags::from_year":["#[allow(unreachable_pub)]\n#[doc(hidden)]\n#[inline]\n#[must_use]\npub const fn from_year(year: i32) -> YearFlags{\n        let year = year.rem_euclid(400);\n        YearFlags::from_year_mod_400(year)\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::YearFlags::from_year_mod_400":["#[inline]\npub(super) const fn from_year_mod_400(year: i32) -> YearFlags{\n        YEAR_TO_FLAGS[year as usize]\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::YearFlags::isoweek_delta":["#[inline]\npub(super) const fn isoweek_delta(&self) -> u32{\n        let YearFlags(flags) = *self;\n        let mut delta = (flags & 0b0111) as u32;\n        if delta < 3 {\n            delta += 7;\n        }\n        delta\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::YearFlags::ndays":["#[inline]\npub(super) const fn ndays(&self) -> u32{\n        let YearFlags(flags) = *self;\n        366 - (flags >> 3) as u32\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::YearFlags::nisoweeks":["#[inline]\npub(super) const fn nisoweeks(&self) -> u32{\n        let YearFlags(flags) = *self;\n        52 + ((0b0000_0100_0000_0110 >> flags as usize) & 1)\n    }","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::cycle_to_yo":["pub(super) const fn cycle_to_yo(cycle: u32) -> (u32, u32){\n    let mut year_mod_400 = cycle / 365;\n    let mut ordinal0 = cycle % 365;\n    let delta = YEAR_DELTAS[year_mod_400 as usize] as u32;\n    if ordinal0 < delta {\n        year_mod_400 -= 1;\n        ordinal0 += 365 - YEAR_DELTAS[year_mod_400 as usize] as u32;\n    } else {\n        ordinal0 -= delta;\n    }\n    (year_mod_400, ordinal0 + 1)\n}","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::weekday_from_u32_mod7":["/// Create a `Weekday` from an `u32`, with Monday = 0.\n/// Infallible, takes any `n` and applies `% 7`.\n#[inline]\nconst fn weekday_from_u32_mod7(n: u32) -> Weekday{\n    match n % 7 {\n        0 => Weekday::Mon,\n        1 => Weekday::Tue,\n        2 => Weekday::Wed,\n        3 => Weekday::Thu,\n        4 => Weekday::Fri,\n        5 => Weekday::Sat,\n        _ => Weekday::Sun,\n    }\n}","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::internals::yo_to_cycle":["pub(super) const fn yo_to_cycle(year_mod_400: u32, ordinal: u32) -> u32{\n    year_mod_400 * 365 + YEAR_DELTAS[year_mod_400 as usize] as u32 + ordinal - 1\n}","Real(LocalPath(\"src/naive/internals.rs\"))"],"naive::isoweek::IsoWeek":["/// ISO 8601 week.\n///\n/// This type, combined with [`Weekday`](../enum.Weekday.html),\n/// constitutes the ISO 8601 [week date](./struct.NaiveDate.html#week-date).\n/// One can retrieve this type from the existing [`Datelike`](../trait.Datelike.html) types\n/// via the [`Datelike::iso_week`](../trait.Datelike.html#tymethod.iso_week) method.\npub struct IsoWeek {\n    // note that this allows for larger year range than `NaiveDate`.\n    // this is crucial because we have an edge case for the first and last week supported,\n    // which year number might not match the calendar year number.\n    ywf: DateImpl, // (year << 10) | (week << 4) | flag\n}","Real(LocalPath(\"src/naive/isoweek.rs\"))"],"naive::isoweek::IsoWeek::week":["/// Returns the ISO week number starting from 1.\n///\n/// The return value ranges from 1 to 53. (The last week of year differs by years.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike, Weekday};\n///\n/// let d = NaiveDate::from_isoywd_opt(2015, 15, Weekday::Mon).unwrap();\n/// assert_eq!(d.iso_week().week(), 15);\n/// ```\n#[inline]\npub const fn week(&self) -> u32{\n        ((self.ywf >> 4) & 0x3f) as u32\n    }","Real(LocalPath(\"src/naive/isoweek.rs\"))"],"naive::isoweek::IsoWeek::week0":["/// Returns the ISO week number starting from 0.\n///\n/// The return value ranges from 0 to 52. (The last week of year differs by years.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike, Weekday};\n///\n/// let d = NaiveDate::from_isoywd_opt(2015, 15, Weekday::Mon).unwrap();\n/// assert_eq!(d.iso_week().week0(), 14);\n/// ```\n#[inline]\npub const fn week0(&self) -> u32{\n        ((self.ywf >> 4) & 0x3f) as u32 - 1\n    }","Real(LocalPath(\"src/naive/isoweek.rs\"))"],"naive::isoweek::IsoWeek::year":["/// Returns the year number for this ISO week.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike, Weekday};\n///\n/// let d = NaiveDate::from_isoywd_opt(2015, 1, Weekday::Mon).unwrap();\n/// assert_eq!(d.iso_week().year(), 2015);\n/// ```\n///\n/// This year number might not match the calendar year number.\n/// Continuing the example...\n///\n/// ```\n/// # use chrono::{NaiveDate, Datelike, Weekday};\n/// # let d = NaiveDate::from_isoywd_opt(2015, 1, Weekday::Mon).unwrap();\n/// assert_eq!(d.year(), 2014);\n/// assert_eq!(d, NaiveDate::from_ymd_opt(2014, 12, 29).unwrap());\n/// ```\n#[inline]\npub const fn year(&self) -> i32{\n        self.ywf >> 10\n    }","Real(LocalPath(\"src/naive/isoweek.rs\"))"],"naive::isoweek::iso_week_from_yof":["/// Returns the corresponding `IsoWeek` from the year and the `Of` internal value.\npub(super) fn iso_week_from_yof(year: i32, of: Of) -> IsoWeek{\n    let (rawweek, _) = of.isoweekdate_raw();\n    let (year, week) = if rawweek < 1 {\n        // previous year\n        let prevlastweek = YearFlags::from_year(year - 1).nisoweeks();\n        (year - 1, prevlastweek)\n    } else {\n        let lastweek = of.flags().nisoweeks();\n        if rawweek > lastweek {\n            // next year\n            (year + 1, 1)\n        } else {\n            (year, rawweek)\n        }\n    };\n    let flags = YearFlags::from_year(year);\n    IsoWeek { ywf: (year << 10) | (week << 4) as DateImpl | DateImpl::from(flags.0) }\n}","Real(LocalPath(\"src/naive/isoweek.rs\"))"],"naive::time::NaiveTime":["/// ISO 8601 time without timezone.\n/// Allows for the nanosecond precision and optional leap second representation.\n///\n/// # Leap Second Handling\n///\n/// Since 1960s, the manmade atomic clock has been so accurate that\n/// it is much more accurate than Earth's own motion.\n/// It became desirable to define the civil time in terms of the atomic clock,\n/// but that risks the desynchronization of the civil time from Earth.\n/// To account for this, the designers of the Coordinated Universal Time (UTC)\n/// made that the UTC should be kept within 0.9 seconds of the observed Earth-bound time.\n/// When the mean solar day is longer than the ideal (86,400 seconds),\n/// the error slowly accumulates and it is necessary to add a **leap second**\n/// to slow the UTC down a bit.\n/// (We may also remove a second to speed the UTC up a bit, but it never happened.)\n/// The leap second, if any, follows 23:59:59 of June 30 or December 31 in the UTC.\n///\n/// Fast forward to the 21st century,\n/// we have seen 26 leap seconds from January 1972 to December 2015.\n/// Yes, 26 seconds. Probably you can read this paragraph within 26 seconds.\n/// But those 26 seconds, and possibly more in the future, are never predictable,\n/// and whether to add a leap second or not is known only before 6 months.\n/// Internet-based clocks (via NTP) do account for known leap seconds,\n/// but the system API normally doesn't (and often can't, with no network connection)\n/// and there is no reliable way to retrieve leap second information.\n///\n/// Chrono does not try to accurately implement leap seconds; it is impossible.\n/// Rather, **it allows for leap seconds but behaves as if there are *no other* leap seconds.**\n/// Various operations will ignore any possible leap second(s)\n/// except when any of the operands were actually leap seconds.\n///\n/// If you cannot tolerate this behavior,\n/// you must use a separate `TimeZone` for the International Atomic Time (TAI).\n/// TAI is like UTC but has no leap seconds, and thus slightly differs from UTC.\n/// Chrono does not yet provide such implementation, but it is planned.\n///\n/// ## Representing Leap Seconds\n///\n/// The leap second is indicated via fractional seconds more than 1 second.\n/// This makes possible to treat a leap second as the prior non-leap second\n/// if you don't care about sub-second accuracy.\n/// You should use the proper formatting to get the raw leap second.\n///\n/// All methods accepting fractional seconds will accept such values.\n///\n/// ```\n/// use chrono::{NaiveDate, NaiveTime, Utc};\n///\n/// let t = NaiveTime::from_hms_milli_opt(8, 59, 59, 1_000).unwrap();\n///\n/// let dt1 = NaiveDate::from_ymd_opt(2015, 7, 1).unwrap().and_hms_micro_opt(8, 59, 59, 1_000_000).unwrap();\n///\n/// let dt2 = NaiveDate::from_ymd_opt(2015, 6, 30).unwrap().and_hms_nano_opt(23, 59, 59, 1_000_000_000).unwrap().and_local_timezone(Utc).unwrap();\n/// # let _ = (t, dt1, dt2);\n/// ```\n///\n/// Note that the leap second can happen anytime given an appropriate time zone;\n/// 2015-07-01 01:23:60 would be a proper leap second if UTC+01:24 had existed.\n/// Practically speaking, though, by the time of the first leap second on 1972-06-30,\n/// every time zone offset around the world has standardized to the 5-minute alignment.\n///\n/// ## Date And Time Arithmetics\n///\n/// As a concrete example, let's assume that `03:00:60` and `04:00:60` are leap seconds.\n/// In reality, of course, leap seconds are separated by at least 6 months.\n/// We will also use some intuitive concise notations for the explanation.\n///\n/// `Time + Duration`\n/// (short for [`NaiveTime::overflowing_add_signed`](#method.overflowing_add_signed)):\n///\n/// - `03:00:00 + 1s = 03:00:01`.\n/// - `03:00:59 + 60s = 03:02:00`.\n/// - `03:00:59 + 1s = 03:01:00`.\n/// - `03:00:60 + 1s = 03:01:00`.\n///   Note that the sum is identical to the previous.\n/// - `03:00:60 + 60s = 03:01:59`.\n/// - `03:00:60 + 61s = 03:02:00`.\n/// - `03:00:60.1 + 0.8s = 03:00:60.9`.\n///\n/// `Time - Duration`\n/// (short for [`NaiveTime::overflowing_sub_signed`](#method.overflowing_sub_signed)):\n///\n/// - `03:00:00 - 1s = 02:59:59`.\n/// - `03:01:00 - 1s = 03:00:59`.\n/// - `03:01:00 - 60s = 03:00:00`.\n/// - `03:00:60 - 60s = 03:00:00`.\n///   Note that the result is identical to the previous.\n/// - `03:00:60.7 - 0.4s = 03:00:60.3`.\n/// - `03:00:60.7 - 0.9s = 03:00:59.8`.\n///\n/// `Time - Time`\n/// (short for [`NaiveTime::signed_duration_since`](#method.signed_duration_since)):\n///\n/// - `04:00:00 - 03:00:00 = 3600s`.\n/// - `03:01:00 - 03:00:00 = 60s`.\n/// - `03:00:60 - 03:00:00 = 60s`.\n///   Note that the difference is identical to the previous.\n/// - `03:00:60.6 - 03:00:59.4 = 1.2s`.\n/// - `03:01:00 - 03:00:59.8 = 0.2s`.\n/// - `03:01:00 - 03:00:60.5 = 0.5s`.\n///   Note that the difference is larger than the previous,\n///   even though the leap second clearly follows the previous whole second.\n/// - `04:00:60.9 - 03:00:60.1 =\n///   (04:00:60.9 - 04:00:00) + (04:00:00 - 03:01:00) + (03:01:00 - 03:00:60.1) =\n///   60.9s + 3540s + 0.9s = 3601.8s`.\n///\n/// In general,\n///\n/// - `Time + Duration` unconditionally equals to `Duration + Time`.\n///\n/// - `Time - Duration` unconditionally equals to `Time + (-Duration)`.\n///\n/// - `Time1 - Time2` unconditionally equals to `-(Time2 - Time1)`.\n///\n/// - Associativity does not generally hold, because\n///   `(Time + Duration1) - Duration2` no longer equals to `Time + (Duration1 - Duration2)`\n///   for two positive durations.\n///\n///     - As a special case, `(Time + Duration) - Duration` also does not equal to `Time`.\n///\n///     - If you can assume that all durations have the same sign, however,\n///       then the associativity holds:\n///       `(Time + Duration1) + Duration2` equals to `Time + (Duration1 + Duration2)`\n///       for two positive durations.\n///\n/// ## Reading And Writing Leap Seconds\n///\n/// The \"typical\" leap seconds on the minute boundary are\n/// correctly handled both in the formatting and parsing.\n/// The leap second in the human-readable representation\n/// will be represented as the second part being 60, as required by ISO 8601.\n///\n/// ```\n/// use chrono::{Utc, NaiveDate};\n///\n/// let dt = NaiveDate::from_ymd_opt(2015, 6, 30).unwrap().and_hms_milli_opt(23, 59, 59, 1_000).unwrap().and_local_timezone(Utc).unwrap();\n/// assert_eq!(format!(\"{:?}\", dt), \"2015-06-30T23:59:60Z\");\n/// ```\n///\n/// There are hypothetical leap seconds not on the minute boundary\n/// nevertheless supported by Chrono.\n/// They are allowed for the sake of completeness and consistency;\n/// there were several \"exotic\" time zone offsets with fractional minutes prior to UTC after all.\n/// For such cases the human-readable representation is ambiguous\n/// and would be read back to the next non-leap second.\n///\n/// ```\n/// use chrono::{DateTime, Utc, TimeZone, NaiveDate};\n///\n/// let dt = NaiveDate::from_ymd_opt(2015, 6, 30).unwrap().and_hms_milli_opt(23, 56, 4, 1_000).unwrap().and_local_timezone(Utc).unwrap();\n/// assert_eq!(format!(\"{:?}\", dt), \"2015-06-30T23:56:05Z\");\n///\n/// let dt = Utc.with_ymd_and_hms(2015, 6, 30, 23, 56, 5).unwrap();\n/// assert_eq!(format!(\"{:?}\", dt), \"2015-06-30T23:56:05Z\");\n/// assert_eq!(DateTime::parse_from_rfc3339(\"2015-06-30T23:56:05Z\").unwrap(), dt);\n/// ```\n///\n/// Since Chrono alone cannot determine any existence of leap seconds,\n/// **there is absolutely no guarantee that the leap second read has actually happened**.\npub struct NaiveTime {\n    secs: u32,\n    frac: u32,\n}","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::format":["/// Formats the time with the specified format string.\n/// See the [`format::strftime` module](../format/strftime/index.html)\n/// on the supported escape sequences.\n///\n/// This returns a `DelayedFormat`,\n/// which gets converted to a string only when actual formatting happens.\n/// You may use the `to_string` method to get a `String`,\n/// or just feed it into `print!` and other formatting macros.\n/// (In this way it avoids the redundant memory allocation.)\n///\n/// A wrong format string does *not* issue an error immediately.\n/// Rather, converting or formatting the `DelayedFormat` fails.\n/// You are recommended to immediately use `DelayedFormat` for this reason.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveTime;\n///\n/// let t = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n/// assert_eq!(t.format(\"%H:%M:%S\").to_string(), \"23:56:04\");\n/// assert_eq!(t.format(\"%H:%M:%S%.6f\").to_string(), \"23:56:04.012345\");\n/// assert_eq!(t.format(\"%-I:%M %p\").to_string(), \"11:56 PM\");\n/// ```\n///\n/// The resulting `DelayedFormat` can be formatted directly via the `Display` trait.\n///\n/// ```\n/// # use chrono::NaiveTime;\n/// # let t = NaiveTime::from_hms_nano_opt(23, 56, 4, 12_345_678).unwrap();\n/// assert_eq!(format!(\"{}\", t.format(\"%H:%M:%S\")), \"23:56:04\");\n/// assert_eq!(format!(\"{}\", t.format(\"%H:%M:%S%.6f\")), \"23:56:04.012345\");\n/// assert_eq!(format!(\"{}\", t.format(\"%-I:%M %p\")), \"11:56 PM\");\n/// ```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[inline]\n#[must_use]\npub fn format<'a>(&self, fmt: &'a str) -> DelayedFormat<StrftimeItems<'a>>{\n        self.format_with_items(StrftimeItems::new(fmt))\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::format_with_items":["/// Formats the time with the specified formatting items.\n/// Otherwise it is the same as the ordinary [`format`](#method.format) method.\n///\n/// The `Iterator` of items should be `Clone`able,\n/// since the resulting `DelayedFormat` value may be formatted multiple times.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveTime;\n/// use chrono::format::strftime::StrftimeItems;\n///\n/// let fmt = StrftimeItems::new(\"%H:%M:%S\");\n/// let t = NaiveTime::from_hms_opt(23, 56, 4).unwrap();\n/// assert_eq!(t.format_with_items(fmt.clone()).to_string(), \"23:56:04\");\n/// assert_eq!(t.format(\"%H:%M:%S\").to_string(),             \"23:56:04\");\n/// ```\n///\n/// The resulting `DelayedFormat` can be formatted directly via the `Display` trait.\n///\n/// ```\n/// # use chrono::NaiveTime;\n/// # use chrono::format::strftime::StrftimeItems;\n/// # let fmt = StrftimeItems::new(\"%H:%M:%S\").clone();\n/// # let t = NaiveTime::from_hms_opt(23, 56, 4).unwrap();\n/// assert_eq!(format!(\"{}\", t.format_with_items(fmt)), \"23:56:04\");\n/// ```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\n#[inline]\n#[must_use]\npub fn format_with_items<'a, I, B>(&self, items: I) -> DelayedFormat<I>\n    where\n        I: Iterator<Item = B> + Clone,\n        B: Borrow<Item<'a>>,{\n        DelayedFormat::new(None, Some(*self), items)\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::from_hms":["/// Makes a new `NaiveTime` from hour, minute and second.\n///\n/// No [leap second](#leap-second-handling) is allowed here;\n/// use `NaiveTime::from_hms_*` methods with a subsecond parameter instead.\n///\n/// Panics on invalid hour, minute and/or second.\n#[deprecated(since = \"0.4.23\", note = \"use `from_hms_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn from_hms(hour: u32, min: u32, sec: u32) -> NaiveTime{\n        NaiveTime::from_hms_opt(hour, min, sec).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::from_hms_micro":["/// Makes a new `NaiveTime` from hour, minute, second and microsecond.\n///\n/// The microsecond part can exceed 1,000,000\n/// in order to represent the [leap second](#leap-second-handling).\n///\n/// Panics on invalid hour, minute, second and/or microsecond.\n#[deprecated(since = \"0.4.23\", note = \"use `from_hms_micro_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn from_hms_micro(hour: u32, min: u32, sec: u32, micro: u32) -> NaiveTime{\n        NaiveTime::from_hms_micro_opt(hour, min, sec, micro).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::from_hms_micro_opt":["/// Makes a new `NaiveTime` from hour, minute, second and microsecond.\n///\n/// The microsecond part can exceed 1,000,000\n/// in order to represent the [leap second](#leap-second-handling).\n///\n/// Returns `None` on invalid hour, minute, second and/or microsecond.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveTime;\n///\n/// let from_hmsu_opt = NaiveTime::from_hms_micro_opt;\n///\n/// assert!(from_hmsu_opt(0, 0, 0, 0).is_some());\n/// assert!(from_hmsu_opt(23, 59, 59, 999_999).is_some());\n/// assert!(from_hmsu_opt(23, 59, 59, 1_999_999).is_some()); // a leap second after 23:59:59\n/// assert!(from_hmsu_opt(24, 0, 0, 0).is_none());\n/// assert!(from_hmsu_opt(23, 60, 0, 0).is_none());\n/// assert!(from_hmsu_opt(23, 59, 60, 0).is_none());\n/// assert!(from_hmsu_opt(23, 59, 59, 2_000_000).is_none());\n/// ```\n#[inline]\n#[must_use]\npub fn from_hms_micro_opt(hour: u32, min: u32, sec: u32, micro: u32) -> Option<NaiveTime>{\n        micro.checked_mul(1_000).and_then(|nano| NaiveTime::from_hms_nano_opt(hour, min, sec, nano))\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::from_hms_milli":["/// Makes a new `NaiveTime` from hour, minute, second and millisecond.\n///\n/// The millisecond part can exceed 1,000\n/// in order to represent the [leap second](#leap-second-handling).\n///\n/// Panics on invalid hour, minute, second and/or millisecond.\n#[deprecated(since = \"0.4.23\", note = \"use `from_hms_milli_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn from_hms_milli(hour: u32, min: u32, sec: u32, milli: u32) -> NaiveTime{\n        NaiveTime::from_hms_milli_opt(hour, min, sec, milli).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::from_hms_milli_opt":["/// Makes a new `NaiveTime` from hour, minute, second and millisecond.\n///\n/// The millisecond part can exceed 1,000\n/// in order to represent the [leap second](#leap-second-handling).\n///\n/// Returns `None` on invalid hour, minute, second and/or millisecond.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveTime;\n///\n/// let from_hmsm_opt = NaiveTime::from_hms_milli_opt;\n///\n/// assert!(from_hmsm_opt(0, 0, 0, 0).is_some());\n/// assert!(from_hmsm_opt(23, 59, 59, 999).is_some());\n/// assert!(from_hmsm_opt(23, 59, 59, 1_999).is_some()); // a leap second after 23:59:59\n/// assert!(from_hmsm_opt(24, 0, 0, 0).is_none());\n/// assert!(from_hmsm_opt(23, 60, 0, 0).is_none());\n/// assert!(from_hmsm_opt(23, 59, 60, 0).is_none());\n/// assert!(from_hmsm_opt(23, 59, 59, 2_000).is_none());\n/// ```\n#[inline]\n#[must_use]\npub fn from_hms_milli_opt(hour: u32, min: u32, sec: u32, milli: u32) -> Option<NaiveTime>{\n        milli\n            .checked_mul(1_000_000)\n            .and_then(|nano| NaiveTime::from_hms_nano_opt(hour, min, sec, nano))\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::from_hms_nano":["/// Makes a new `NaiveTime` from hour, minute, second and nanosecond.\n///\n/// The nanosecond part can exceed 1,000,000,000\n/// in order to represent the [leap second](#leap-second-handling).\n///\n/// Panics on invalid hour, minute, second and/or nanosecond.\n#[deprecated(since = \"0.4.23\", note = \"use `from_hms_nano_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn from_hms_nano(hour: u32, min: u32, sec: u32, nano: u32) -> NaiveTime{\n        NaiveTime::from_hms_nano_opt(hour, min, sec, nano).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::from_hms_nano_opt":["/// Makes a new `NaiveTime` from hour, minute, second and nanosecond.\n///\n/// The nanosecond part can exceed 1,000,000,000\n/// in order to represent the [leap second](#leap-second-handling).\n///\n/// Returns `None` on invalid hour, minute, second and/or nanosecond.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveTime;\n///\n/// let from_hmsn_opt = NaiveTime::from_hms_nano_opt;\n///\n/// assert!(from_hmsn_opt(0, 0, 0, 0).is_some());\n/// assert!(from_hmsn_opt(23, 59, 59, 999_999_999).is_some());\n/// assert!(from_hmsn_opt(23, 59, 59, 1_999_999_999).is_some()); // a leap second after 23:59:59\n/// assert!(from_hmsn_opt(24, 0, 0, 0).is_none());\n/// assert!(from_hmsn_opt(23, 60, 0, 0).is_none());\n/// assert!(from_hmsn_opt(23, 59, 60, 0).is_none());\n/// assert!(from_hmsn_opt(23, 59, 59, 2_000_000_000).is_none());\n/// ```\n#[inline]\n#[must_use]\npub const fn from_hms_nano_opt(hour: u32, min: u32, sec: u32, nano: u32) -> Option<NaiveTime>{\n        if hour >= 24 || min >= 60 || sec >= 60 || nano >= 2_000_000_000 {\n            return None;\n        }\n        let secs = hour * 3600 + min * 60 + sec;\n        Some(NaiveTime { secs, frac: nano })\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::from_hms_opt":["/// Makes a new `NaiveTime` from hour, minute and second.\n///\n/// No [leap second](#leap-second-handling) is allowed here;\n/// use `NaiveTime::from_hms_*_opt` methods with a subsecond parameter instead.\n///\n/// Returns `None` on invalid hour, minute and/or second.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveTime;\n///\n/// let from_hms_opt = NaiveTime::from_hms_opt;\n///\n/// assert!(from_hms_opt(0, 0, 0).is_some());\n/// assert!(from_hms_opt(23, 59, 59).is_some());\n/// assert!(from_hms_opt(24, 0, 0).is_none());\n/// assert!(from_hms_opt(23, 60, 0).is_none());\n/// assert!(from_hms_opt(23, 59, 60).is_none());\n/// ```\n#[inline]\n#[must_use]\npub const fn from_hms_opt(hour: u32, min: u32, sec: u32) -> Option<NaiveTime>{\n        NaiveTime::from_hms_nano_opt(hour, min, sec, 0)\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::from_num_seconds_from_midnight":["/// Makes a new `NaiveTime` from the number of seconds since midnight and nanosecond.\n///\n/// The nanosecond part can exceed 1,000,000,000\n/// in order to represent the [leap second](#leap-second-handling).\n///\n/// Panics on invalid number of seconds and/or nanosecond.\n#[deprecated(since = \"0.4.23\", note = \"use `from_num_seconds_from_midnight_opt()` instead\")]\n#[inline]\n#[must_use]\npub fn from_num_seconds_from_midnight(secs: u32, nano: u32) -> NaiveTime{\n        NaiveTime::from_num_seconds_from_midnight_opt(secs, nano).expect(\"invalid time\")\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::from_num_seconds_from_midnight_opt":["/// Makes a new `NaiveTime` from the number of seconds since midnight and nanosecond.\n///\n/// The nanosecond part can exceed 1,000,000,000\n/// in order to represent the [leap second](#leap-second-handling).\n///\n/// Returns `None` on invalid number of seconds and/or nanosecond.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveTime;\n///\n/// let from_nsecs_opt = NaiveTime::from_num_seconds_from_midnight_opt;\n///\n/// assert!(from_nsecs_opt(0, 0).is_some());\n/// assert!(from_nsecs_opt(86399, 999_999_999).is_some());\n/// assert!(from_nsecs_opt(86399, 1_999_999_999).is_some()); // a leap second after 23:59:59\n/// assert!(from_nsecs_opt(86_400, 0).is_none());\n/// assert!(from_nsecs_opt(86399, 2_000_000_000).is_none());\n/// ```\n#[inline]\n#[must_use]\npub const fn from_num_seconds_from_midnight_opt(secs: u32, nano: u32) -> Option<NaiveTime>{\n        if secs >= 86_400 || nano >= 2_000_000_000 {\n            return None;\n        }\n        Some(NaiveTime { secs, frac: nano })\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::hms":["/// Returns a triple of the hour, minute and second numbers.\nfn hms(&self) -> (u32, u32, u32){\n        let sec = self.secs % 60;\n        let mins = self.secs / 60;\n        let min = mins % 60;\n        let hour = mins / 60;\n        (hour, min, sec)\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::overflowing_add_signed":["/// Adds given `Duration` to the current time,\n/// and also returns the number of *seconds*\n/// in the integral number of days ignored from the addition.\n/// (We cannot return `Duration` because it is subject to overflow or underflow.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Duration, NaiveTime};\n///\n/// let from_hms = |h, m, s| { NaiveTime::from_hms_opt(h, m, s).unwrap() };\n///\n/// assert_eq!(from_hms(3, 4, 5).overflowing_add_signed(Duration::hours(11)),\n///            (from_hms(14, 4, 5), 0));\n/// assert_eq!(from_hms(3, 4, 5).overflowing_add_signed(Duration::hours(23)),\n///            (from_hms(2, 4, 5), 86_400));\n/// assert_eq!(from_hms(3, 4, 5).overflowing_add_signed(Duration::hours(-7)),\n///            (from_hms(20, 4, 5), -86_400));\n/// ```\n#[must_use]\npub fn overflowing_add_signed(&self, mut rhs: OldDuration) -> (NaiveTime, i64){\n        let mut secs = self.secs;\n        let mut frac = self.frac;\n\n        // check if `self` is a leap second and adding `rhs` would escape that leap second.\n        // if it's the case, update `self` and `rhs` to involve no leap second;\n        // otherwise the addition immediately finishes.\n        if frac >= 1_000_000_000 {\n            let rfrac = 2_000_000_000 - frac;\n            if rhs >= OldDuration::nanoseconds(i64::from(rfrac)) {\n                rhs = rhs - OldDuration::nanoseconds(i64::from(rfrac));\n                secs += 1;\n                frac = 0;\n            } else if rhs < OldDuration::nanoseconds(-i64::from(frac)) {\n                rhs = rhs + OldDuration::nanoseconds(i64::from(frac));\n                frac = 0;\n            } else {\n                frac = (i64::from(frac) + rhs.num_nanoseconds().unwrap()) as u32;\n                debug_assert!(frac < 2_000_000_000);\n                return (NaiveTime { secs, frac }, 0);\n            }\n        }\n        debug_assert!(secs <= 86_400);\n        debug_assert!(frac < 1_000_000_000);\n\n        let rhssecs = rhs.num_seconds();\n        let rhsfrac = (rhs - OldDuration::seconds(rhssecs)).num_nanoseconds().unwrap();\n        debug_assert_eq!(OldDuration::seconds(rhssecs) + OldDuration::nanoseconds(rhsfrac), rhs);\n        let rhssecsinday = rhssecs % 86_400;\n        let mut morerhssecs = rhssecs - rhssecsinday;\n        let rhssecs = rhssecsinday as i32;\n        let rhsfrac = rhsfrac as i32;\n        debug_assert!(-86_400 < rhssecs && rhssecs < 86_400);\n        debug_assert_eq!(morerhssecs % 86_400, 0);\n        debug_assert!(-1_000_000_000 < rhsfrac && rhsfrac < 1_000_000_000);\n\n        let mut secs = secs as i32 + rhssecs;\n        let mut frac = frac as i32 + rhsfrac;\n        debug_assert!(-86_400 < secs && secs < 2 * 86_400);\n        debug_assert!(-1_000_000_000 < frac && frac < 2_000_000_000);\n\n        if frac < 0 {\n            frac += 1_000_000_000;\n            secs -= 1;\n        } else if frac >= 1_000_000_000 {\n            frac -= 1_000_000_000;\n            secs += 1;\n        }\n        debug_assert!((-86_400..2 * 86_400).contains(&secs));\n        debug_assert!((0..1_000_000_000).contains(&frac));\n\n        if secs < 0 {\n            secs += 86_400;\n            morerhssecs -= 86_400;\n        } else if secs >= 86_400 {\n            secs -= 86_400;\n            morerhssecs += 86_400;\n        }\n        debug_assert!((0..86_400).contains(&secs));\n\n        (NaiveTime { secs: secs as u32, frac: frac as u32 }, morerhssecs)\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::overflowing_sub_signed":["/// Subtracts given `Duration` from the current time,\n/// and also returns the number of *seconds*\n/// in the integral number of days ignored from the subtraction.\n/// (We cannot return `Duration` because it is subject to overflow or underflow.)\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Duration, NaiveTime};\n///\n/// let from_hms = |h, m, s| { NaiveTime::from_hms_opt(h, m, s).unwrap() };\n///\n/// assert_eq!(from_hms(3, 4, 5).overflowing_sub_signed(Duration::hours(2)),\n///            (from_hms(1, 4, 5), 0));\n/// assert_eq!(from_hms(3, 4, 5).overflowing_sub_signed(Duration::hours(17)),\n///            (from_hms(10, 4, 5), 86_400));\n/// assert_eq!(from_hms(3, 4, 5).overflowing_sub_signed(Duration::hours(-22)),\n///            (from_hms(1, 4, 5), -86_400));\n/// ```\n#[inline]\n#[must_use]\npub fn overflowing_sub_signed(&self, rhs: OldDuration) -> (NaiveTime, i64){\n        let (time, rhs) = self.overflowing_add_signed(-rhs);\n        (time, -rhs) // safe to negate, rhs is within +/- (2^63 / 1000)\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::parse_and_remainder":["/// Parses a string from a user-specified format into a new `NaiveTime` value, and a slice with\n/// the remaining portion of the string.\n/// See the [`format::strftime` module](../format/strftime/index.html)\n/// on the supported escape sequences.\n///\n/// Similar to [`parse_from_str`](#method.parse_from_str).\n///\n/// # Example\n///\n/// ```rust\n/// # use chrono::{NaiveTime};\n/// let (time, remainder) = NaiveTime::parse_and_remainder(\n///     \"3h4m33s trailing text\", \"%-Hh%-Mm%-Ss\").unwrap();\n/// assert_eq!(time, NaiveTime::from_hms_opt(3, 4, 33).unwrap());\n/// assert_eq!(remainder, \" trailing text\");\n/// ```\npub fn parse_and_remainder<'a>(s: &'a str, fmt: &str) -> ParseResult<(NaiveTime, &'a str)>{\n        let mut parsed = Parsed::new();\n        let remainder = parse_and_remainder(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_naive_time().map(|t| (t, remainder))\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::parse_from_str":["/// Parses a string with the specified format string and returns a new `NaiveTime`.\n/// See the [`format::strftime` module](../format/strftime/index.html)\n/// on the supported escape sequences.\n///\n/// # Example\n///\n/// ```\n/// use chrono::NaiveTime;\n///\n/// let parse_from_str = NaiveTime::parse_from_str;\n///\n/// assert_eq!(parse_from_str(\"23:56:04\", \"%H:%M:%S\"),\n///            Ok(NaiveTime::from_hms_opt(23, 56, 4).unwrap()));\n/// assert_eq!(parse_from_str(\"pm012345.6789\", \"%p%I%M%S%.f\"),\n///            Ok(NaiveTime::from_hms_micro_opt(13, 23, 45, 678_900).unwrap()));\n/// ```\n///\n/// Date and offset is ignored for the purpose of parsing.\n///\n/// ```\n/// # use chrono::NaiveTime;\n/// # let parse_from_str = NaiveTime::parse_from_str;\n/// assert_eq!(parse_from_str(\"2014-5-17T12:34:56+09:30\", \"%Y-%m-%dT%H:%M:%S%z\"),\n///            Ok(NaiveTime::from_hms_opt(12, 34, 56).unwrap()));\n/// ```\n///\n/// [Leap seconds](#leap-second-handling) are correctly handled by\n/// treating any time of the form `hh:mm:60` as a leap second.\n/// (This equally applies to the formatting, so the round trip is possible.)\n///\n/// ```\n/// # use chrono::NaiveTime;\n/// # let parse_from_str = NaiveTime::parse_from_str;\n/// assert_eq!(parse_from_str(\"08:59:60.123\", \"%H:%M:%S%.f\"),\n///            Ok(NaiveTime::from_hms_milli_opt(8, 59, 59, 1_123).unwrap()));\n/// ```\n///\n/// Missing seconds are assumed to be zero,\n/// but out-of-bound times or insufficient fields are errors otherwise.\n///\n/// ```\n/// # use chrono::NaiveTime;\n/// # let parse_from_str = NaiveTime::parse_from_str;\n/// assert_eq!(parse_from_str(\"7:15\", \"%H:%M\"),\n///            Ok(NaiveTime::from_hms_opt(7, 15, 0).unwrap()));\n///\n/// assert!(parse_from_str(\"04m33s\", \"%Mm%Ss\").is_err());\n/// assert!(parse_from_str(\"12\", \"%H\").is_err());\n/// assert!(parse_from_str(\"17:60\", \"%H:%M\").is_err());\n/// assert!(parse_from_str(\"24:00:00\", \"%H:%M:%S\").is_err());\n/// ```\n///\n/// All parsed fields should be consistent to each other, otherwise it's an error.\n/// Here `%H` is for 24-hour clocks, unlike `%I`,\n/// and thus can be independently determined without AM/PM.\n///\n/// ```\n/// # use chrono::NaiveTime;\n/// # let parse_from_str = NaiveTime::parse_from_str;\n/// assert!(parse_from_str(\"13:07 AM\", \"%H:%M %p\").is_err());\n/// ```\npub fn parse_from_str(s: &str, fmt: &str) -> ParseResult<NaiveTime>{\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_naive_time()\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"naive::time::NaiveTime::signed_duration_since":["/// Subtracts another `NaiveTime` from the current time.\n/// Returns a `Duration` within +/- 1 day.\n/// This does not overflow or underflow at all.\n///\n/// As a part of Chrono's [leap second handling](#leap-second-handling),\n/// the subtraction assumes that **there is no leap second ever**,\n/// except when any of the `NaiveTime`s themselves represents a leap second\n/// in which case the assumption becomes that\n/// **there are exactly one (or two) leap second(s) ever**.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Duration, NaiveTime};\n///\n/// let from_hmsm = |h, m, s, milli| { NaiveTime::from_hms_milli_opt(h, m, s, milli).unwrap() };\n/// let since = NaiveTime::signed_duration_since;\n///\n/// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(3, 5, 7, 900)),\n///            Duration::zero());\n/// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(3, 5, 7, 875)),\n///            Duration::milliseconds(25));\n/// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(3, 5, 6, 925)),\n///            Duration::milliseconds(975));\n/// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(3, 5, 0, 900)),\n///            Duration::seconds(7));\n/// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(3, 0, 7, 900)),\n///            Duration::seconds(5 * 60));\n/// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(0, 5, 7, 900)),\n///            Duration::seconds(3 * 3600));\n/// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(4, 5, 7, 900)),\n///            Duration::seconds(-3600));\n/// assert_eq!(since(from_hmsm(3, 5, 7, 900), from_hmsm(2, 4, 6, 800)),\n///            Duration::seconds(3600 + 60 + 1) + Duration::milliseconds(100));\n/// ```\n///\n/// Leap seconds are handled, but the subtraction assumes that\n/// there were no other leap seconds happened.\n///\n/// ```\n/// # use chrono::{Duration, NaiveTime};\n/// # let from_hmsm = |h, m, s, milli| { NaiveTime::from_hms_milli_opt(h, m, s, milli).unwrap() };\n/// # let since = NaiveTime::signed_duration_since;\n/// assert_eq!(since(from_hmsm(3, 0, 59, 1_000), from_hmsm(3, 0, 59, 0)),\n///            Duration::seconds(1));\n/// assert_eq!(since(from_hmsm(3, 0, 59, 1_500), from_hmsm(3, 0, 59, 0)),\n///            Duration::milliseconds(1500));\n/// assert_eq!(since(from_hmsm(3, 0, 59, 1_000), from_hmsm(3, 0, 0, 0)),\n///            Duration::seconds(60));\n/// assert_eq!(since(from_hmsm(3, 0, 0, 0), from_hmsm(2, 59, 59, 1_000)),\n///            Duration::seconds(1));\n/// assert_eq!(since(from_hmsm(3, 0, 59, 1_000), from_hmsm(2, 59, 59, 1_000)),\n///            Duration::seconds(61));\n/// ```\n#[must_use]\npub fn signed_duration_since(self, rhs: NaiveTime) -> OldDuration{\n        //     |    |    :leap|    |    |    |    |    |    |    :leap|    |\n        //     |    |    :    |    |    |    |    |    |    |    :    |    |\n        // ----+----+-----*---+----+----+----+----+----+----+-------*-+----+----\n        //          |   `rhs` |                             |    `self`\n        //          |======================================>|       |\n        //          |     |  `self.secs - rhs.secs`         |`self.frac`\n        //          |====>|   |                             |======>|\n        //      `rhs.frac`|========================================>|\n        //          |     |   |        `self - rhs`         |       |\n\n        use core::cmp::Ordering;\n\n        let secs = i64::from(self.secs) - i64::from(rhs.secs);\n        let frac = i64::from(self.frac) - i64::from(rhs.frac);\n\n        // `secs` may contain a leap second yet to be counted\n        let adjust = match self.secs.cmp(&rhs.secs) {\n            Ordering::Greater => i64::from(rhs.frac >= 1_000_000_000),\n            Ordering::Equal => 0,\n            Ordering::Less => {\n                if self.frac >= 1_000_000_000 {\n                    -1\n                } else {\n                    0\n                }\n            }\n        };\n\n        OldDuration::seconds(secs + adjust) + OldDuration::nanoseconds(frac)\n    }","Real(LocalPath(\"src/naive/time/mod.rs\"))"],"offset::LocalResult":["/// The conversion result from the local time to the timezone-aware datetime types.\npub enum LocalResult<T> {\n    /// Given local time representation is invalid.\n    /// This can occur when, for example, the positive timezone transition.\n    None,\n    /// Given local time representation has a single unique result.\n    Single(T),\n    /// Given local time representation has multiple results and thus ambiguous.\n    /// This can occur when, for example, the negative timezone transition.\n    Ambiguous(T /*min*/, T /*max*/),\n}","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::LocalResult::<T>::earliest":["/// Returns `Some` for the earliest possible conversion result, or `None` if none.\n#[must_use]\npub fn earliest(self) -> Option<T>{\n        match self {\n            LocalResult::Single(t) | LocalResult::Ambiguous(t, _) => Some(t),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::LocalResult::<T>::latest":["/// Returns `Some` for the latest possible conversion result, or `None` if none.\n#[must_use]\npub fn latest(self) -> Option<T>{\n        match self {\n            LocalResult::Single(t) | LocalResult::Ambiguous(_, t) => Some(t),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::LocalResult::<T>::map":["/// Maps a `LocalResult<T>` into `LocalResult<U>` with given function.\n#[must_use]\npub fn map<U, F: FnMut(T) -> U>(self, mut f: F) -> LocalResult<U>{\n        match self {\n            LocalResult::None => LocalResult::None,\n            LocalResult::Single(v) => LocalResult::Single(f(v)),\n            LocalResult::Ambiguous(min, max) => LocalResult::Ambiguous(f(min), f(max)),\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::LocalResult::<T>::single":["/// Returns `Some` only when the conversion result is unique, or `None` otherwise.\n#[must_use]\npub fn single(self) -> Option<T>{\n        match self {\n            LocalResult::Single(t) => Some(t),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::LocalResult::<T>::unwrap":["/// Returns the single unique conversion result, or panics accordingly.\n#[must_use]\n#[track_caller]\npub fn unwrap(self) -> T{\n        match self {\n            LocalResult::None => panic!(\"No such local time\"),\n            LocalResult::Single(t) => t,\n            LocalResult::Ambiguous(t1, t2) => {\n                panic!(\"Ambiguous local time, ranging from {:?} to {:?}\", t1, t2)\n            }\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::LocalResult::<date::Date<Tz>>::and_hms_micro_opt":["/// Makes a new `DateTime` from the current date, hour, minute, second and microsecond.\n/// The microsecond part can exceed 1,000,000 in order to represent the leap second.\n/// The offset in the current date is preserved.\n///\n/// Propagates any error. Ambiguous result would be discarded.\n#[inline]\n#[must_use]\npub fn and_hms_micro_opt(\n        self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        micro: u32,\n    ) -> LocalResult<DateTime<Tz>>{\n        match self {\n            LocalResult::Single(d) => d\n                .and_hms_micro_opt(hour, min, sec, micro)\n                .map_or(LocalResult::None, LocalResult::Single),\n            _ => LocalResult::None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::LocalResult::<date::Date<Tz>>::and_hms_milli_opt":["/// Makes a new `DateTime` from the current date, hour, minute, second and millisecond.\n/// The millisecond part can exceed 1,000 in order to represent the leap second.\n/// The offset in the current date is preserved.\n///\n/// Propagates any error. Ambiguous result would be discarded.\n#[inline]\n#[must_use]\npub fn and_hms_milli_opt(\n        self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        milli: u32,\n    ) -> LocalResult<DateTime<Tz>>{\n        match self {\n            LocalResult::Single(d) => d\n                .and_hms_milli_opt(hour, min, sec, milli)\n                .map_or(LocalResult::None, LocalResult::Single),\n            _ => LocalResult::None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::LocalResult::<date::Date<Tz>>::and_hms_nano_opt":["/// Makes a new `DateTime` from the current date, hour, minute, second and nanosecond.\n/// The nanosecond part can exceed 1,000,000,000 in order to represent the leap second.\n/// The offset in the current date is preserved.\n///\n/// Propagates any error. Ambiguous result would be discarded.\n#[inline]\n#[must_use]\npub fn and_hms_nano_opt(\n        self,\n        hour: u32,\n        min: u32,\n        sec: u32,\n        nano: u32,\n    ) -> LocalResult<DateTime<Tz>>{\n        match self {\n            LocalResult::Single(d) => d\n                .and_hms_nano_opt(hour, min, sec, nano)\n                .map_or(LocalResult::None, LocalResult::Single),\n            _ => LocalResult::None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::LocalResult::<date::Date<Tz>>::and_hms_opt":["/// Makes a new `DateTime` from the current date, hour, minute and second.\n/// The offset in the current date is preserved.\n///\n/// Propagates any error. Ambiguous result would be discarded.\n#[inline]\n#[must_use]\npub fn and_hms_opt(self, hour: u32, min: u32, sec: u32) -> LocalResult<DateTime<Tz>>{\n        match self {\n            LocalResult::Single(d) => {\n                d.and_hms_opt(hour, min, sec).map_or(LocalResult::None, LocalResult::Single)\n            }\n            _ => LocalResult::None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::LocalResult::<date::Date<Tz>>::and_time":["/// Makes a new `DateTime` from the current date and given `NaiveTime`.\n/// The offset in the current date is preserved.\n///\n/// Propagates any error. Ambiguous result would be discarded.\n#[inline]\n#[must_use]\npub fn and_time(self, time: NaiveTime) -> LocalResult<DateTime<Tz>>{\n        match self {\n            LocalResult::Single(d) => {\n                d.and_time(time).map_or(LocalResult::None, LocalResult::Single)\n            }\n            _ => LocalResult::None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::Offset":["/// The offset from the local time to UTC.\npub trait Offset: Sized + Clone + fmt::Debug {\n    /// Returns the fixed offset from UTC to the local time stored.\n    fn fix(&self) -> FixedOffset;\n}","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone":["/// The time zone.\n///\n/// The methods here are the primarily constructors for [`Date`](../struct.Date.html) and\n/// [`DateTime`](../struct.DateTime.html) types.\npub trait TimeZone: Sized + Clone {\n    /// An associated offset type.\n    /// This type is used to store the actual offset in date and time types.\n    /// The original `TimeZone` value can be recovered via `TimeZone::from_offset`.\n    type Offset: Offset;\n\n    /// Make a new `DateTime` from year, month, day, time components and current time zone.\n    ///\n    /// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n    ///\n    /// Returns `LocalResult::None` on invalid input data.\n    fn with_ymd_and_hms(\n        &self,\n        year: i32,\n        month: u32,\n        day: u32,\n        hour: u32,\n        min: u32,\n        sec: u32,\n    ) -> LocalResult<DateTime<Self>> {\n        match NaiveDate::from_ymd_opt(year, month, day).and_then(|d| d.and_hms_opt(hour, min, sec))\n        {\n            Some(dt) => self.from_local_datetime(&dt),\n            None => LocalResult::None,\n        }\n    }\n\n    /// Makes a new `Date` from year, month, day and the current time zone.\n    /// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n    ///\n    /// The time zone normally does not affect the date (unless it is between UTC-24 and UTC+24),\n    /// but it will propagate to the `DateTime` values constructed via this date.\n    ///\n    /// Panics on the out-of-range date, invalid month and/or day.\n    #[deprecated(since = \"0.4.23\", note = \"use `with_ymd_and_hms()` instead\")]\n    #[allow(deprecated)]\n    fn ymd(&self, year: i32, month: u32, day: u32) -> Date<Self> {\n        self.ymd_opt(year, month, day).unwrap()\n    }\n\n    /// Makes a new `Date` from year, month, day and the current time zone.\n    /// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n    ///\n    /// The time zone normally does not affect the date (unless it is between UTC-24 and UTC+24),\n    /// but it will propagate to the `DateTime` values constructed via this date.\n    ///\n    /// Returns `None` on the out-of-range date, invalid month and/or day.\n    #[deprecated(since = \"0.4.23\", note = \"use `with_ymd_and_hms()` instead\")]\n    #[allow(deprecated)]\n    fn ymd_opt(&self, year: i32, month: u32, day: u32) -> LocalResult<Date<Self>> {\n        match NaiveDate::from_ymd_opt(year, month, day) {\n            Some(d) => self.from_local_date(&d),\n            None => LocalResult::None,\n        }\n    }\n\n    /// Makes a new `Date` from year, day of year (DOY or \"ordinal\") and the current time zone.\n    /// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n    ///\n    /// The time zone normally does not affect the date (unless it is between UTC-24 and UTC+24),\n    /// but it will propagate to the `DateTime` values constructed via this date.\n    ///\n    /// Panics on the out-of-range date and/or invalid DOY.\n    #[deprecated(\n        since = \"0.4.23\",\n        note = \"use `from_local_datetime()` with a `NaiveDateTime` instead\"\n    )]\n    #[allow(deprecated)]\n    fn yo(&self, year: i32, ordinal: u32) -> Date<Self> {\n        self.yo_opt(year, ordinal).unwrap()\n    }\n\n    /// Makes a new `Date` from year, day of year (DOY or \"ordinal\") and the current time zone.\n    /// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n    ///\n    /// The time zone normally does not affect the date (unless it is between UTC-24 and UTC+24),\n    /// but it will propagate to the `DateTime` values constructed via this date.\n    ///\n    /// Returns `None` on the out-of-range date and/or invalid DOY.\n    #[deprecated(\n        since = \"0.4.23\",\n        note = \"use `from_local_datetime()` with a `NaiveDateTime` instead\"\n    )]\n    #[allow(deprecated)]\n    fn yo_opt(&self, year: i32, ordinal: u32) -> LocalResult<Date<Self>> {\n        match NaiveDate::from_yo_opt(year, ordinal) {\n            Some(d) => self.from_local_date(&d),\n            None => LocalResult::None,\n        }\n    }\n\n    /// Makes a new `Date` from ISO week date (year and week number), day of the week (DOW) and\n    /// the current time zone.\n    /// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n    /// The resulting `Date` may have a different year from the input year.\n    ///\n    /// The time zone normally does not affect the date (unless it is between UTC-24 and UTC+24),\n    /// but it will propagate to the `DateTime` values constructed via this date.\n    ///\n    /// Panics on the out-of-range date and/or invalid week number.\n    #[deprecated(\n        since = \"0.4.23\",\n        note = \"use `from_local_datetime()` with a `NaiveDateTime` instead\"\n    )]\n    #[allow(deprecated)]\n    fn isoywd(&self, year: i32, week: u32, weekday: Weekday) -> Date<Self> {\n        self.isoywd_opt(year, week, weekday).unwrap()\n    }\n\n    /// Makes a new `Date` from ISO week date (year and week number), day of the week (DOW) and\n    /// the current time zone.\n    /// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n    /// The resulting `Date` may have a different year from the input year.\n    ///\n    /// The time zone normally does not affect the date (unless it is between UTC-24 and UTC+24),\n    /// but it will propagate to the `DateTime` values constructed via this date.\n    ///\n    /// Returns `None` on the out-of-range date and/or invalid week number.\n    #[deprecated(\n        since = \"0.4.23\",\n        note = \"use `from_local_datetime()` with a `NaiveDateTime` instead\"\n    )]\n    #[allow(deprecated)]\n    fn isoywd_opt(&self, year: i32, week: u32, weekday: Weekday) -> LocalResult<Date<Self>> {\n        match NaiveDate::from_isoywd_opt(year, week, weekday) {\n            Some(d) => self.from_local_date(&d),\n            None => LocalResult::None,\n        }\n    }\n\n    /// Makes a new `DateTime` from the number of non-leap seconds\n    /// since January 1, 1970 0:00:00 UTC (aka \"UNIX timestamp\")\n    /// and the number of nanoseconds since the last whole non-leap second.\n    ///\n    /// Panics on the out-of-range number of seconds and/or invalid nanosecond,\n    /// for a non-panicking version see [`timestamp_opt`](#method.timestamp_opt).\n    #[deprecated(since = \"0.4.23\", note = \"use `timestamp_opt()` instead\")]\n    fn timestamp(&self, secs: i64, nsecs: u32) -> DateTime<Self> {\n        self.timestamp_opt(secs, nsecs).unwrap()\n    }\n\n    /// Makes a new `DateTime` from the number of non-leap seconds\n    /// since January 1, 1970 0:00:00 UTC (aka \"UNIX timestamp\")\n    /// and the number of nanoseconds since the last whole non-leap second.\n    ///\n    /// Returns `LocalResult::None` on out-of-range number of seconds and/or\n    /// invalid nanosecond, otherwise always returns `LocalResult::Single`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Utc, TimeZone};\n    ///\n    /// assert_eq!(Utc.timestamp_opt(1431648000, 0).unwrap().to_string(), \"2015-05-15 00:00:00 UTC\");\n    /// ```\n    fn timestamp_opt(&self, secs: i64, nsecs: u32) -> LocalResult<DateTime<Self>> {\n        match NaiveDateTime::from_timestamp_opt(secs, nsecs) {\n            Some(dt) => LocalResult::Single(self.from_utc_datetime(&dt)),\n            None => LocalResult::None,\n        }\n    }\n\n    /// Makes a new `DateTime` from the number of non-leap milliseconds\n    /// since January 1, 1970 0:00:00 UTC (aka \"UNIX timestamp\").\n    ///\n    /// Panics on out-of-range number of milliseconds for a non-panicking\n    /// version see [`timestamp_millis_opt`](#method.timestamp_millis_opt).\n    #[deprecated(since = \"0.4.23\", note = \"use `timestamp_millis_opt()` instead\")]\n    fn timestamp_millis(&self, millis: i64) -> DateTime<Self> {\n        self.timestamp_millis_opt(millis).unwrap()\n    }\n\n    /// Makes a new `DateTime` from the number of non-leap milliseconds\n    /// since January 1, 1970 0:00:00 UTC (aka \"UNIX timestamp\").\n    ///\n    ///\n    /// Returns `LocalResult::None` on out-of-range number of milliseconds\n    /// and/or invalid nanosecond, otherwise always returns\n    /// `LocalResult::Single`.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Utc, TimeZone, LocalResult};\n    /// match Utc.timestamp_millis_opt(1431648000) {\n    ///     LocalResult::Single(dt) => assert_eq!(dt.timestamp(), 1431648),\n    ///     _ => panic!(\"Incorrect timestamp_millis\"),\n    /// };\n    /// ```\n    fn timestamp_millis_opt(&self, millis: i64) -> LocalResult<DateTime<Self>> {\n        let (mut secs, mut millis) = (millis / 1000, millis % 1000);\n        if millis < 0 {\n            secs -= 1;\n            millis += 1000;\n        }\n        self.timestamp_opt(secs, millis as u32 * 1_000_000)\n    }\n\n    /// Makes a new `DateTime` from the number of non-leap nanoseconds\n    /// since January 1, 1970 0:00:00 UTC (aka \"UNIX timestamp\").\n    ///\n    /// Unlike [`timestamp_millis`](#method.timestamp_millis), this never\n    /// panics.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use chrono::{Utc, TimeZone};\n    ///\n    /// assert_eq!(Utc.timestamp_nanos(1431648000000000).timestamp(), 1431648);\n    /// ```\n    fn timestamp_nanos(&self, nanos: i64) -> DateTime<Self> {\n        let (mut secs, mut nanos) = (nanos / 1_000_000_000, nanos % 1_000_000_000);\n        if nanos < 0 {\n            secs -= 1;\n            nanos += 1_000_000_000;\n        }\n        self.timestamp_opt(secs, nanos as u32).unwrap()\n    }\n\n    /// Parses a string with the specified format string and returns a\n    /// `DateTime` with the current offset.\n    ///\n    /// See the [`crate::format::strftime`] module on the\n    /// supported escape sequences.\n    ///\n    /// If the to-be-parsed string includes an offset, it *must* match the\n    /// offset of the TimeZone, otherwise an error will be returned.\n    ///\n    /// See also [`DateTime::parse_from_str`] which gives a [`DateTime`] with\n    /// parsed [`FixedOffset`].\n    fn datetime_from_str(&self, s: &str, fmt: &str) -> ParseResult<DateTime<Self>> {\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_datetime_with_timezone(self)\n    }\n\n    /// Reconstructs the time zone from the offset.\n    fn from_offset(offset: &Self::Offset) -> Self;\n\n    /// Creates the offset(s) for given local `NaiveDate` if possible.\n    fn offset_from_local_date(&self, local: &NaiveDate) -> LocalResult<Self::Offset>;\n\n    /// Creates the offset(s) for given local `NaiveDateTime` if possible.\n    fn offset_from_local_datetime(&self, local: &NaiveDateTime) -> LocalResult<Self::Offset>;\n\n    /// Converts the local `NaiveDate` to the timezone-aware `Date` if possible.\n    #[allow(clippy::wrong_self_convention)]\n    #[deprecated(since = \"0.4.23\", note = \"use `from_local_datetime()` instead\")]\n    #[allow(deprecated)]\n    fn from_local_date(&self, local: &NaiveDate) -> LocalResult<Date<Self>> {\n        self.offset_from_local_date(local).map(|offset| {\n            // since FixedOffset is within +/- 1 day, the date is never affected\n            Date::from_utc(*local, offset)\n        })\n    }\n\n    /// Converts the local `NaiveDateTime` to the timezone-aware `DateTime` if possible.\n    #[allow(clippy::wrong_self_convention)]\n    fn from_local_datetime(&self, local: &NaiveDateTime) -> LocalResult<DateTime<Self>> {\n        self.offset_from_local_datetime(local)\n            .map(|offset| DateTime::from_utc(*local - offset.fix(), offset))\n    }\n\n    /// Creates the offset for given UTC `NaiveDate`. This cannot fail.\n    fn offset_from_utc_date(&self, utc: &NaiveDate) -> Self::Offset;\n\n    /// Creates the offset for given UTC `NaiveDateTime`. This cannot fail.\n    fn offset_from_utc_datetime(&self, utc: &NaiveDateTime) -> Self::Offset;\n\n    /// Converts the UTC `NaiveDate` to the local time.\n    /// The UTC is continuous and thus this cannot fail (but can give the duplicate local time).\n    #[allow(clippy::wrong_self_convention)]\n    #[deprecated(since = \"0.4.23\", note = \"use `from_utc_datetime()` instead\")]\n    #[allow(deprecated)]\n    fn from_utc_date(&self, utc: &NaiveDate) -> Date<Self> {\n        Date::from_utc(*utc, self.offset_from_utc_date(utc))\n    }\n\n    /// Converts the UTC `NaiveDateTime` to the local time.\n    /// The UTC is continuous and thus this cannot fail (but can give the duplicate local time).\n    #[allow(clippy::wrong_self_convention)]\n    fn from_utc_datetime(&self, utc: &NaiveDateTime) -> DateTime<Self> {\n        DateTime::from_utc(*utc, self.offset_from_utc_datetime(utc))\n    }\n}","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::datetime_from_str":["/// Parses a string with the specified format string and returns a\n/// `DateTime` with the current offset.\n///\n/// See the [`crate::format::strftime`] module on the\n/// supported escape sequences.\n///\n/// If the to-be-parsed string includes an offset, it *must* match the\n/// offset of the TimeZone, otherwise an error will be returned.\n///\n/// See also [`DateTime::parse_from_str`] which gives a [`DateTime`] with\n/// parsed [`FixedOffset`].\nfn datetime_from_str(&self, s: &str, fmt: &str) -> ParseResult<DateTime<Self>>{\n        let mut parsed = Parsed::new();\n        parse(&mut parsed, s, StrftimeItems::new(fmt))?;\n        parsed.to_datetime_with_timezone(self)\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::from_local_date":["/// Converts the local `NaiveDate` to the timezone-aware `Date` if possible.\n#[allow(clippy::wrong_self_convention)]\n#[deprecated(since = \"0.4.23\", note = \"use `from_local_datetime()` instead\")]\n#[allow(deprecated)]\nfn from_local_date(&self, local: &NaiveDate) -> LocalResult<Date<Self>>{\n        self.offset_from_local_date(local).map(|offset| {\n            // since FixedOffset is within +/- 1 day, the date is never affected\n            Date::from_utc(*local, offset)\n        })\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::from_local_datetime":["/// Converts the local `NaiveDateTime` to the timezone-aware `DateTime` if possible.\n#[allow(clippy::wrong_self_convention)]\nfn from_local_datetime(&self, local: &NaiveDateTime) -> LocalResult<DateTime<Self>>{\n        self.offset_from_local_datetime(local)\n            .map(|offset| DateTime::from_utc(*local - offset.fix(), offset))\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::from_utc_date":["/// Converts the UTC `NaiveDate` to the local time.\n/// The UTC is continuous and thus this cannot fail (but can give the duplicate local time).\n#[allow(clippy::wrong_self_convention)]\n#[deprecated(since = \"0.4.23\", note = \"use `from_utc_datetime()` instead\")]\n#[allow(deprecated)]\nfn from_utc_date(&self, utc: &NaiveDate) -> Date<Self>{\n        Date::from_utc(*utc, self.offset_from_utc_date(utc))\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::from_utc_datetime":["/// Converts the UTC `NaiveDateTime` to the local time.\n/// The UTC is continuous and thus this cannot fail (but can give the duplicate local time).\n#[allow(clippy::wrong_self_convention)]\nfn from_utc_datetime(&self, utc: &NaiveDateTime) -> DateTime<Self>{\n        DateTime::from_utc(*utc, self.offset_from_utc_datetime(utc))\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::isoywd":["/// Makes a new `Date` from ISO week date (year and week number), day of the week (DOW) and\n/// the current time zone.\n/// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n/// The resulting `Date` may have a different year from the input year.\n///\n/// The time zone normally does not affect the date (unless it is between UTC-24 and UTC+24),\n/// but it will propagate to the `DateTime` values constructed via this date.\n///\n/// Panics on the out-of-range date and/or invalid week number.\n#[deprecated(\n        since = \"0.4.23\",\n        note = \"use `from_local_datetime()` with a `NaiveDateTime` instead\"\n    )]\n#[allow(deprecated)]\nfn isoywd(&self, year: i32, week: u32, weekday: Weekday) -> Date<Self>{\n        self.isoywd_opt(year, week, weekday).unwrap()\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::isoywd_opt":["/// Makes a new `Date` from ISO week date (year and week number), day of the week (DOW) and\n/// the current time zone.\n/// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n/// The resulting `Date` may have a different year from the input year.\n///\n/// The time zone normally does not affect the date (unless it is between UTC-24 and UTC+24),\n/// but it will propagate to the `DateTime` values constructed via this date.\n///\n/// Returns `None` on the out-of-range date and/or invalid week number.\n#[deprecated(\n        since = \"0.4.23\",\n        note = \"use `from_local_datetime()` with a `NaiveDateTime` instead\"\n    )]\n#[allow(deprecated)]\nfn isoywd_opt(&self, year: i32, week: u32, weekday: Weekday) -> LocalResult<Date<Self>>{\n        match NaiveDate::from_isoywd_opt(year, week, weekday) {\n            Some(d) => self.from_local_date(&d),\n            None => LocalResult::None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::timestamp":["/// Makes a new `DateTime` from the number of non-leap seconds\n/// since January 1, 1970 0:00:00 UTC (aka \"UNIX timestamp\")\n/// and the number of nanoseconds since the last whole non-leap second.\n///\n/// Panics on the out-of-range number of seconds and/or invalid nanosecond,\n/// for a non-panicking version see [`timestamp_opt`](#method.timestamp_opt).\n#[deprecated(since = \"0.4.23\", note = \"use `timestamp_opt()` instead\")]\nfn timestamp(&self, secs: i64, nsecs: u32) -> DateTime<Self>{\n        self.timestamp_opt(secs, nsecs).unwrap()\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::timestamp_millis":["/// Makes a new `DateTime` from the number of non-leap milliseconds\n/// since January 1, 1970 0:00:00 UTC (aka \"UNIX timestamp\").\n///\n/// Panics on out-of-range number of milliseconds for a non-panicking\n/// version see [`timestamp_millis_opt`](#method.timestamp_millis_opt).\n#[deprecated(since = \"0.4.23\", note = \"use `timestamp_millis_opt()` instead\")]\nfn timestamp_millis(&self, millis: i64) -> DateTime<Self>{\n        self.timestamp_millis_opt(millis).unwrap()\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::timestamp_millis_opt":["/// Makes a new `DateTime` from the number of non-leap milliseconds\n/// since January 1, 1970 0:00:00 UTC (aka \"UNIX timestamp\").\n///\n///\n/// Returns `LocalResult::None` on out-of-range number of milliseconds\n/// and/or invalid nanosecond, otherwise always returns\n/// `LocalResult::Single`.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Utc, TimeZone, LocalResult};\n/// match Utc.timestamp_millis_opt(1431648000) {\n///     LocalResult::Single(dt) => assert_eq!(dt.timestamp(), 1431648),\n///     _ => panic!(\"Incorrect timestamp_millis\"),\n/// };\n/// ```\nfn timestamp_millis_opt(&self, millis: i64) -> LocalResult<DateTime<Self>>{\n        let (mut secs, mut millis) = (millis / 1000, millis % 1000);\n        if millis < 0 {\n            secs -= 1;\n            millis += 1000;\n        }\n        self.timestamp_opt(secs, millis as u32 * 1_000_000)\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::timestamp_nanos":["/// Makes a new `DateTime` from the number of non-leap nanoseconds\n/// since January 1, 1970 0:00:00 UTC (aka \"UNIX timestamp\").\n///\n/// Unlike [`timestamp_millis`](#method.timestamp_millis), this never\n/// panics.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Utc, TimeZone};\n///\n/// assert_eq!(Utc.timestamp_nanos(1431648000000000).timestamp(), 1431648);\n/// ```\nfn timestamp_nanos(&self, nanos: i64) -> DateTime<Self>{\n        let (mut secs, mut nanos) = (nanos / 1_000_000_000, nanos % 1_000_000_000);\n        if nanos < 0 {\n            secs -= 1;\n            nanos += 1_000_000_000;\n        }\n        self.timestamp_opt(secs, nanos as u32).unwrap()\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::timestamp_opt":["/// Makes a new `DateTime` from the number of non-leap seconds\n/// since January 1, 1970 0:00:00 UTC (aka \"UNIX timestamp\")\n/// and the number of nanoseconds since the last whole non-leap second.\n///\n/// Returns `LocalResult::None` on out-of-range number of seconds and/or\n/// invalid nanosecond, otherwise always returns `LocalResult::Single`.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Utc, TimeZone};\n///\n/// assert_eq!(Utc.timestamp_opt(1431648000, 0).unwrap().to_string(), \"2015-05-15 00:00:00 UTC\");\n/// ```\nfn timestamp_opt(&self, secs: i64, nsecs: u32) -> LocalResult<DateTime<Self>>{\n        match NaiveDateTime::from_timestamp_opt(secs, nsecs) {\n            Some(dt) => LocalResult::Single(self.from_utc_datetime(&dt)),\n            None => LocalResult::None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::with_ymd_and_hms":["/// Make a new `DateTime` from year, month, day, time components and current time zone.\n///\n/// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n///\n/// Returns `LocalResult::None` on invalid input data.\nfn with_ymd_and_hms(\n        &self,\n        year: i32,\n        month: u32,\n        day: u32,\n        hour: u32,\n        min: u32,\n        sec: u32,\n    ) -> LocalResult<DateTime<Self>>{\n        match NaiveDate::from_ymd_opt(year, month, day).and_then(|d| d.and_hms_opt(hour, min, sec))\n        {\n            Some(dt) => self.from_local_datetime(&dt),\n            None => LocalResult::None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::ymd":["/// Makes a new `Date` from year, month, day and the current time zone.\n/// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n///\n/// The time zone normally does not affect the date (unless it is between UTC-24 and UTC+24),\n/// but it will propagate to the `DateTime` values constructed via this date.\n///\n/// Panics on the out-of-range date, invalid month and/or day.\n#[deprecated(since = \"0.4.23\", note = \"use `with_ymd_and_hms()` instead\")]\n#[allow(deprecated)]\nfn ymd(&self, year: i32, month: u32, day: u32) -> Date<Self>{\n        self.ymd_opt(year, month, day).unwrap()\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::ymd_opt":["/// Makes a new `Date` from year, month, day and the current time zone.\n/// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n///\n/// The time zone normally does not affect the date (unless it is between UTC-24 and UTC+24),\n/// but it will propagate to the `DateTime` values constructed via this date.\n///\n/// Returns `None` on the out-of-range date, invalid month and/or day.\n#[deprecated(since = \"0.4.23\", note = \"use `with_ymd_and_hms()` instead\")]\n#[allow(deprecated)]\nfn ymd_opt(&self, year: i32, month: u32, day: u32) -> LocalResult<Date<Self>>{\n        match NaiveDate::from_ymd_opt(year, month, day) {\n            Some(d) => self.from_local_date(&d),\n            None => LocalResult::None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::yo":["/// Makes a new `Date` from year, day of year (DOY or \"ordinal\") and the current time zone.\n/// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n///\n/// The time zone normally does not affect the date (unless it is between UTC-24 and UTC+24),\n/// but it will propagate to the `DateTime` values constructed via this date.\n///\n/// Panics on the out-of-range date and/or invalid DOY.\n#[deprecated(\n        since = \"0.4.23\",\n        note = \"use `from_local_datetime()` with a `NaiveDateTime` instead\"\n    )]\n#[allow(deprecated)]\nfn yo(&self, year: i32, ordinal: u32) -> Date<Self>{\n        self.yo_opt(year, ordinal).unwrap()\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::TimeZone::yo_opt":["/// Makes a new `Date` from year, day of year (DOY or \"ordinal\") and the current time zone.\n/// This assumes the proleptic Gregorian calendar, with the year 0 being 1 BCE.\n///\n/// The time zone normally does not affect the date (unless it is between UTC-24 and UTC+24),\n/// but it will propagate to the `DateTime` values constructed via this date.\n///\n/// Returns `None` on the out-of-range date and/or invalid DOY.\n#[deprecated(\n        since = \"0.4.23\",\n        note = \"use `from_local_datetime()` with a `NaiveDateTime` instead\"\n    )]\n#[allow(deprecated)]\nfn yo_opt(&self, year: i32, ordinal: u32) -> LocalResult<Date<Self>>{\n        match NaiveDate::from_yo_opt(year, ordinal) {\n            Some(d) => self.from_local_date(&d),\n            None => LocalResult::None,\n        }\n    }","Real(LocalPath(\"src/offset/mod.rs\"))"],"offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::add":["#[inline]\nfn add(self, rhs: FixedOffset) -> DateTime<Tz>{\n        add_with_leapsecond(&self, rhs.local_minus_utc)\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for naive::datetime::NaiveDateTime>::add":["#[inline]\nfn add(self, rhs: FixedOffset) -> NaiveDateTime{\n        add_with_leapsecond(&self, rhs.local_minus_utc)\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for naive::time::NaiveTime>::add":["#[inline]\nfn add(self, rhs: FixedOffset) -> NaiveTime{\n        add_with_leapsecond(&self, rhs.local_minus_utc)\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::sub":["#[inline]\nfn sub(self, rhs: FixedOffset) -> DateTime<Tz>{\n        add_with_leapsecond(&self, -rhs.local_minus_utc)\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for naive::datetime::NaiveDateTime>::sub":["#[inline]\nfn sub(self, rhs: FixedOffset) -> NaiveDateTime{\n        add_with_leapsecond(&self, -rhs.local_minus_utc)\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for naive::time::NaiveTime>::sub":["#[inline]\nfn sub(self, rhs: FixedOffset) -> NaiveTime{\n        add_with_leapsecond(&self, -rhs.local_minus_utc)\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::FixedOffset":["/// The time zone with fixed offset, from UTC-23:59:59 to UTC+23:59:59.\n///\n/// Using the [`TimeZone`](./trait.TimeZone.html) methods\n/// on a `FixedOffset` struct is the preferred way to construct\n/// `DateTime<FixedOffset>` instances. See the [`east_opt`](#method.east_opt) and\n/// [`west_opt`](#method.west_opt) methods for examples.\npub struct FixedOffset {\n    local_minus_utc: i32,\n}","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::FixedOffset::east":["/// Makes a new `FixedOffset` for the Eastern Hemisphere with given timezone difference.\n/// The negative `secs` means the Western Hemisphere.\n///\n/// Panics on the out-of-bound `secs`.\n#[deprecated(since = \"0.4.23\", note = \"use `east_opt()` instead\")]\n#[must_use]\npub fn east(secs: i32) -> FixedOffset{\n        FixedOffset::east_opt(secs).expect(\"FixedOffset::east out of bounds\")\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::FixedOffset::east_opt":["/// Makes a new `FixedOffset` for the Eastern Hemisphere with given timezone difference.\n/// The negative `secs` means the Western Hemisphere.\n///\n/// Returns `None` on the out-of-bound `secs`.\n///\n/// # Example\n///\ndoc = \"```\"\n/// use chrono::{FixedOffset, TimeZone};\n/// let hour = 3600;\n/// let datetime = FixedOffset::east_opt(5 * hour)\n///     .unwrap()\n///     .with_ymd_and_hms(2016, 11, 08, 0, 0, 0)\n///     .unwrap();\n/// assert_eq!(&datetime.to_rfc3339(), \"2016-11-08T00:00:00+05:00\")\n/// ```\n#[must_use]\npub const fn east_opt(secs: i32) -> Option<FixedOffset>{\n        if -86_400 < secs && secs < 86_400 {\n            Some(FixedOffset { local_minus_utc: secs })\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::FixedOffset::local_minus_utc":["/// Returns the number of seconds to add to convert from UTC to the local time.\n#[inline]\npub const fn local_minus_utc(&self) -> i32{\n        self.local_minus_utc\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::FixedOffset::utc_minus_local":["/// Returns the number of seconds to add to convert from the local time to UTC.\n#[inline]\npub const fn utc_minus_local(&self) -> i32{\n        -self.local_minus_utc\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::FixedOffset::west":["/// Makes a new `FixedOffset` for the Western Hemisphere with given timezone difference.\n/// The negative `secs` means the Eastern Hemisphere.\n///\n/// Panics on the out-of-bound `secs`.\n#[deprecated(since = \"0.4.23\", note = \"use `west_opt()` instead\")]\n#[must_use]\npub fn west(secs: i32) -> FixedOffset{\n        FixedOffset::west_opt(secs).expect(\"FixedOffset::west out of bounds\")\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::FixedOffset::west_opt":["/// Makes a new `FixedOffset` for the Western Hemisphere with given timezone difference.\n/// The negative `secs` means the Eastern Hemisphere.\n///\n/// Returns `None` on the out-of-bound `secs`.\n///\n/// # Example\n///\ndoc = \"```\"\n/// use chrono::{FixedOffset, TimeZone};\n/// let hour = 3600;\n/// let datetime = FixedOffset::west_opt(5 * hour)\n///     .unwrap()\n///     .with_ymd_and_hms(2016, 11, 08, 0, 0, 0)\n///     .unwrap();\n/// assert_eq!(&datetime.to_rfc3339(), \"2016-11-08T00:00:00-05:00\")\n/// ```\n#[must_use]\npub const fn west_opt(secs: i32) -> Option<FixedOffset>{\n        if -86_400 < secs && secs < 86_400 {\n            Some(FixedOffset { local_minus_utc: -secs })\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::fixed::add_with_leapsecond":["fn add_with_leapsecond<T>(lhs: &T, rhs: i32) -> T\nwhere\n    T: Timelike + Add<OldDuration, Output = T>,{\n    // extract and temporarily remove the fractional part and later recover it\n    let nanos = lhs.nanosecond();\n    let lhs = lhs.with_nanosecond(0).unwrap();\n    (lhs + OldDuration::seconds(i64::from(rhs))).with_nanosecond(nanos).unwrap()\n}","Real(LocalPath(\"src/offset/fixed.rs\"))"],"offset::local::Local":["/// The local timescale. This is implemented via the standard `time` crate.\n///\n/// Using the [`TimeZone`](./trait.TimeZone.html) methods\n/// on the Local struct is the preferred way to construct `DateTime<Local>`\n/// instances.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{Local, DateTime, TimeZone};\n///\n/// let dt1: DateTime<Local> = Local::now();\n/// let dt2: DateTime<Local> = Local.timestamp_opt(0, 0).unwrap();\n/// assert!(dt1 >= dt2);\n/// ```\npub struct Local;","Real(LocalPath(\"src/offset/local/mod.rs\"))"],"offset::local::Local::now":["/// Returns a `DateTime` which corresponds to the current date and time.\n#[cfg(not(all(\n        target_arch = \"wasm32\",\n        feature = \"wasmbind\",\n        not(any(target_os = \"emscripten\", target_os = \"wasi\"))\n    )))]\n#[must_use]\npub fn now() -> DateTime<Local>{\n        Utc::now().with_timezone(&Local)\n    }","Real(LocalPath(\"src/offset/local/mod.rs\"))"],"offset::local::Local::today":["/// Returns a `Date` which corresponds to the current date.\n#[deprecated(since = \"0.4.23\", note = \"use `Local::now()` instead\")]\n#[allow(deprecated)]\n#[must_use]\npub fn today() -> Date<Local>{\n        Local::now().date()\n    }","Real(LocalPath(\"src/offset/local/mod.rs\"))"],"offset::local::inner::Cache":["struct Cache {\n    zone: TimeZone,\n    source: Source,\n    last_checked: SystemTime,\n}","Real(LocalPath(\"src/offset/local/unix.rs\"))"],"offset::local::inner::Cache::offset":["fn offset(&mut self, d: NaiveDateTime, local: bool) -> LocalResult<FixedOffset>{\n        let now = SystemTime::now();\n\n        match now.duration_since(self.last_checked) {\n            // If the cache has been around for less than a second then we reuse it\n            // unconditionally. This is a reasonable tradeoff because the timezone\n            // generally won't be changing _that_ often, but if the time zone does\n            // change, it will reflect sufficiently quickly from an application\n            // user's perspective.\n            Ok(d) if d.as_secs() < 1 => (),\n            Ok(_) | Err(_) => {\n                let env_tz = env::var(\"TZ\").ok();\n                let env_ref = env_tz.as_deref();\n                let new_source = Source::new(env_ref);\n\n                let out_of_date = match (&self.source, &new_source) {\n                    // change from env to file or file to env, must recreate the zone\n                    (Source::Environment { .. }, Source::LocalTime { .. })\n                    | (Source::LocalTime { .. }, Source::Environment { .. }) => true,\n                    // stay as file, but mtime has changed\n                    (Source::LocalTime { mtime: old_mtime }, Source::LocalTime { mtime })\n                        if old_mtime != mtime =>\n                    {\n                        true\n                    }\n                    // stay as env, but hash of variable has changed\n                    (Source::Environment { hash: old_hash }, Source::Environment { hash })\n                        if old_hash != hash =>\n                    {\n                        true\n                    }\n                    // cache can be reused\n                    _ => false,\n                };\n\n                if out_of_date {\n                    self.zone = current_zone(env_ref);\n                }\n\n                self.last_checked = now;\n                self.source = new_source;\n            }\n        }\n\n        if !local {\n            let offset = self\n                .zone\n                .find_local_time_type(d.timestamp())\n                .expect(\"unable to select local time type\")\n                .offset();\n\n            return match FixedOffset::east_opt(offset) {\n                Some(offset) => LocalResult::Single(offset),\n                None => LocalResult::None,\n            };\n        }\n\n        // we pass through the year as the year of a local point in time must either be valid in that locale, or\n        // the entire time was skipped in which case we will return LocalResult::None anyway.\n        self.zone\n            .find_local_time_type_from_local(d.timestamp(), d.year())\n            .expect(\"unable to select local time type\")\n            .map(|o| FixedOffset::east_opt(o.offset()).unwrap())\n    }","Real(LocalPath(\"src/offset/local/unix.rs\"))"],"offset::local::inner::Source":["enum Source {\n    LocalTime { mtime: SystemTime },\n    Environment { hash: u64 },\n}","Real(LocalPath(\"src/offset/local/unix.rs\"))"],"offset::local::inner::Source::new":["fn new(env_tz: Option<&str>) -> Source{\n        match env_tz {\n            Some(tz) => {\n                let mut hasher = hash_map::DefaultHasher::new();\n                hasher.write(tz.as_bytes());\n                let hash = hasher.finish();\n                Source::Environment { hash }\n            }\n            None => match fs::symlink_metadata(\"/etc/localtime\") {\n                Ok(data) => Source::LocalTime {\n                    // we have to pick a sensible default when the mtime fails\n                    // by picking SystemTime::now() we raise the probability of\n                    // the cache being invalidated if/when the mtime starts working\n                    mtime: data.modified().unwrap_or_else(|_| SystemTime::now()),\n                },\n                Err(_) => {\n                    // as above, now() should be a better default than some constant\n                    // TODO: see if we can improve caching in the case where the fallback is a valid timezone\n                    Source::LocalTime { mtime: SystemTime::now() }\n                }\n            },\n        }\n    }","Real(LocalPath(\"src/offset/local/unix.rs\"))"],"offset::local::inner::TZ_INFO::__getit":["inline\nunsafe fn __getit(\n                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n            ) -> $crate::option::Option<&'static $t>{\n                #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                    $crate::thread::__StaticLocalKeyInner::new();\n\n                #[thread_local]\n                #[cfg(all(\n                    target_thread_local,\n                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n                    $crate::thread::__FastLocalKeyInner::new();\n\n                #[cfg(all(\n                    not(target_thread_local),\n                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n                ))]\n                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                    $crate::thread::__OsLocalKeyInner::new();\n\n                // FIXME: remove the #[allow(...)] marker when macros don't\n                // raise warning for missing/extraneous unsafe blocks anymore.\n                // See https://github.com/rust-lang/rust/issues/74838.\n                #[allow(unused_unsafe)]\n                unsafe {\n                    __KEY.get(move || {\n                        if let $crate::option::Option::Some(init) = init {\n                            if let $crate::option::Option::Some(value) = init.take() {\n                                return value;\n                            } else if $crate::cfg!(debug_assertions) {\n                                $crate::unreachable!(\"missing default value\");\n                            }\n                        }\n                        __init()\n                    })\n                }\n            }","Real(Remapped { local_path: Some(\"/home/tmq244/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })"],"offset::local::inner::TZ_INFO::__init":["#[inline]\nfn __init() -> $t{ $init }","Real(Remapped { local_path: Some(\"/home/tmq244/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })"],"offset::local::inner::current_zone":["fn current_zone(var: Option<&str>) -> TimeZone{\n    TimeZone::local(var).ok().or_else(fallback_timezone).unwrap_or_else(TimeZone::utc)\n}","Real(LocalPath(\"src/offset/local/unix.rs\"))"],"offset::local::inner::fallback_timezone":["fn fallback_timezone() -> Option<TimeZone>{\n    let tz_name = iana_time_zone::get_timezone().ok()?;\n    #[cfg(not(target_os = \"android\"))]\n    let bytes = fs::read(format!(\"{}/{}\", TZDB_LOCATION, tz_name)).ok()?;\n    #[cfg(target_os = \"android\")]\n    let bytes = android_tzdata::find_tz_data(&tz_name).ok()?;\n    TimeZone::from_tz_data(&bytes).ok()\n}","Real(LocalPath(\"src/offset/local/unix.rs\"))"],"offset::local::inner::offset":["fn offset(d: &NaiveDateTime, local: bool) -> LocalResult<FixedOffset>{\n    TZ_INFO.with(|maybe_cache| {\n        maybe_cache.borrow_mut().get_or_insert_with(Cache::default).offset(*d, local)\n    })\n}","Real(LocalPath(\"src/offset/local/unix.rs\"))"],"offset::local::inner::offset_from_local_datetime":["pub(super) fn offset_from_local_datetime(local: &NaiveDateTime) -> LocalResult<FixedOffset>{\n    offset(local, true)\n}","Real(LocalPath(\"src/offset/local/unix.rs\"))"],"offset::local::inner::offset_from_utc_datetime":["pub(super) fn offset_from_utc_datetime(utc: &NaiveDateTime) -> LocalResult<FixedOffset>{\n    offset(utc, false)\n}","Real(LocalPath(\"src/offset/local/unix.rs\"))"],"offset::local::tz_info::Error":["/// Unified error type for everything in the crate\npub(crate) enum Error {\n    /// Date time error\n    DateTime(&'static str),\n    /// Local time type search error\n    FindLocalTimeType(&'static str),\n    /// Local time type error\n    LocalTimeType(&'static str),\n    /// Invalid slice for integer conversion\n    InvalidSlice(&'static str),\n    /// Invalid Tzif file\n    InvalidTzFile(&'static str),\n    /// Invalid TZ string\n    InvalidTzString(&'static str),\n    /// I/O error\n    Io(io::Error),\n    /// Out of range error\n    OutOfRange(&'static str),\n    /// Integer parsing error\n    ParseInt(ParseIntError),\n    /// Date time projection error\n    ProjectDateTime(&'static str),\n    /// System time error\n    SystemTime(SystemTimeError),\n    /// Time zone error\n    TimeZone(&'static str),\n    /// Transition rule error\n    TransitionRule(&'static str),\n    /// Unsupported Tzif file\n    UnsupportedTzFile(&'static str),\n    /// Unsupported TZ string\n    UnsupportedTzString(&'static str),\n    /// UTF-8 error\n    Utf8(Utf8Error),\n}","Real(LocalPath(\"src/offset/local/tz_info/mod.rs\"))"],"offset::local::tz_info::parser::Cursor":["/// A `Cursor` contains a slice of a buffer and a read count.\npub(crate) struct Cursor<'a> {\n    /// Slice representing the remaining data to be read\n    remaining: &'a [u8],\n    /// Number of already read bytes\n    read_count: usize,\n}","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Cursor::<'a>::is_empty":["/// Returns `true` if data is remaining\npub(crate) const fn is_empty(&self) -> bool{\n        self.remaining.is_empty()\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Cursor::<'a>::new":["/// Construct a new `Cursor` from remaining data\npub(crate) const fn new(remaining: &'a [u8]) -> Self{\n        Self { remaining, read_count: 0 }\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Cursor::<'a>::peek":["pub(crate) fn peek(&self) -> Option<&u8>{\n        self.remaining().first()\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Cursor::<'a>::read_be_u32":["pub(crate) fn read_be_u32(&mut self) -> Result<u32, Error>{\n        let mut buf = [0; 4];\n        buf.copy_from_slice(self.read_exact(4)?);\n        Ok(u32::from_be_bytes(buf))\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Cursor::<'a>::read_exact":["/// Read exactly `count` bytes, reducing remaining data and incrementing read count\npub(crate) fn read_exact(&mut self, count: usize) -> Result<&'a [u8], io::Error>{\n        match (self.remaining.get(..count), self.remaining.get(count..)) {\n            (Some(result), Some(remaining)) => {\n                self.remaining = remaining;\n                self.read_count += count;\n                Ok(result)\n            }\n            _ => Err(io::Error::from(ErrorKind::UnexpectedEof)),\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Cursor::<'a>::read_int":["pub(crate) fn read_int<T: FromStr<Err = ParseIntError>>(&mut self) -> Result<T, Error>{\n        let bytes = self.read_while(u8::is_ascii_digit)?;\n        Ok(str::from_utf8(bytes)?.parse()?)\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Cursor::<'a>::read_optional_tag":["/// Read bytes if the remaining data is prefixed by the provided tag\npub(crate) fn read_optional_tag(&mut self, tag: &[u8]) -> Result<bool, io::Error>{\n        if self.remaining.starts_with(tag) {\n            self.read_exact(tag.len())?;\n            Ok(true)\n        } else {\n            Ok(false)\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Cursor::<'a>::read_tag":["/// Read bytes and compare them to the provided tag\npub(crate) fn read_tag(&mut self, tag: &[u8]) -> Result<(), io::Error>{\n        if self.read_exact(tag.len())? == tag {\n            Ok(())\n        } else {\n            Err(io::Error::from(ErrorKind::InvalidData))\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Cursor::<'a>::read_until":["/// Read bytes until the provided predicate is true\npub(crate) fn read_until<F: Fn(&u8) -> bool>(&mut self, f: F) -> Result<&'a [u8], io::Error>{\n        match self.remaining.iter().position(f) {\n            None => self.read_exact(self.remaining.len()),\n            Some(position) => self.read_exact(position),\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Cursor::<'a>::read_while":["/// Read bytes as long as the provided predicate is true\npub(crate) fn read_while<F: Fn(&u8) -> bool>(&mut self, f: F) -> Result<&'a [u8], io::Error>{\n        match self.remaining.iter().position(|x| !f(x)) {\n            None => self.read_exact(self.remaining.len()),\n            Some(position) => self.read_exact(position),\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Cursor::<'a>::remaining":["/// Returns remaining data\npub(crate) const fn remaining(&self) -> &'a [u8]{\n        self.remaining\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Header":["/// TZif header\nstruct Header {\n    /// TZif version\n    version: Version,\n    /// Number of UT/local indicators\n    ut_local_count: usize,\n    /// Number of standard/wall indicators\n    std_wall_count: usize,\n    /// Number of leap-second records\n    leap_count: usize,\n    /// Number of transition times\n    transition_count: usize,\n    /// Number of local time type records\n    type_count: usize,\n    /// Number of time zone names bytes\n    char_count: usize,\n}","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Header::new":["fn new(cursor: &mut Cursor) -> Result<Self, Error>{\n        let magic = cursor.read_exact(4)?;\n        if magic != *b\"TZif\" {\n            return Err(Error::InvalidTzFile(\"invalid magic number\"));\n        }\n\n        let version = match cursor.read_exact(1)? {\n            [0x00] => Version::V1,\n            [0x32] => Version::V2,\n            [0x33] => Version::V3,\n            _ => return Err(Error::UnsupportedTzFile(\"unsupported TZif version\")),\n        };\n\n        cursor.read_exact(15)?;\n        let ut_local_count = cursor.read_be_u32()?;\n        let std_wall_count = cursor.read_be_u32()?;\n        let leap_count = cursor.read_be_u32()?;\n        let transition_count = cursor.read_be_u32()?;\n        let type_count = cursor.read_be_u32()?;\n        let char_count = cursor.read_be_u32()?;\n\n        if !(type_count != 0\n            && char_count != 0\n            && (ut_local_count == 0 || ut_local_count == type_count)\n            && (std_wall_count == 0 || std_wall_count == type_count))\n        {\n            return Err(Error::InvalidTzFile(\"invalid header\"));\n        }\n\n        Ok(Self {\n            version,\n            ut_local_count: ut_local_count as usize,\n            std_wall_count: std_wall_count as usize,\n            leap_count: leap_count as usize,\n            transition_count: transition_count as usize,\n            type_count: type_count as usize,\n            char_count: char_count as usize,\n        })\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::State":["/// TZif data blocks\nstruct State<'a> {\n    header: Header,\n    /// Time size in bytes\n    time_size: usize,\n    /// Transition times data block\n    transition_times: &'a [u8],\n    /// Transition types data block\n    transition_types: &'a [u8],\n    /// Local time types data block\n    local_time_types: &'a [u8],\n    /// Time zone names data block\n    names: &'a [u8],\n    /// Leap seconds data block\n    leap_seconds: &'a [u8],\n    /// UT/local indicators data block\n    std_walls: &'a [u8],\n    /// Standard/wall indicators data block\n    ut_locals: &'a [u8],\n}","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::State::<'a>::new":["/// Read TZif data blocks\nfn new(cursor: &mut Cursor<'a>, first: bool) -> Result<Self, Error>{\n        let header = Header::new(cursor)?;\n        let time_size = match first {\n            true => 4, // We always parse V1 first\n            false => 8,\n        };\n\n        Ok(Self {\n            time_size,\n            transition_times: cursor.read_exact(header.transition_count * time_size)?,\n            transition_types: cursor.read_exact(header.transition_count)?,\n            local_time_types: cursor.read_exact(header.type_count * 6)?,\n            names: cursor.read_exact(header.char_count)?,\n            leap_seconds: cursor.read_exact(header.leap_count * (time_size + 4))?,\n            std_walls: cursor.read_exact(header.std_wall_count)?,\n            ut_locals: cursor.read_exact(header.ut_local_count)?,\n            header,\n        })\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::State::<'a>::parse_time":["/// Parse time values\nfn parse_time(&self, arr: &[u8], version: Version) -> Result<i64, Error>{\n        match version {\n            Version::V1 => Ok(read_be_i32(&arr[..4])?.into()),\n            Version::V2 | Version::V3 => read_be_i64(arr),\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::Version":["/// TZif version\nenum Version {\n    /// Version 1\n    V1,\n    /// Version 2\n    V2,\n    /// Version 3\n    V3,\n}","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::parse":["pub(super) fn parse(bytes: &[u8]) -> Result<TimeZone, Error>{\n    let mut cursor = Cursor::new(bytes);\n    let state = State::new(&mut cursor, true)?;\n    let (state, footer) = match state.header.version {\n        Version::V1 => match cursor.is_empty() {\n            true => (state, None),\n            false => {\n                return Err(Error::InvalidTzFile(\"remaining data after end of TZif v1 data block\"))\n            }\n        },\n        Version::V2 | Version::V3 => {\n            let state = State::new(&mut cursor, false)?;\n            (state, Some(cursor.remaining()))\n        }\n    };\n\n    let mut transitions = Vec::with_capacity(state.header.transition_count);\n    for (arr_time, &local_time_type_index) in\n        state.transition_times.chunks_exact(state.time_size).zip(state.transition_types)\n    {\n        let unix_leap_time =\n            state.parse_time(&arr_time[0..state.time_size], state.header.version)?;\n        let local_time_type_index = local_time_type_index as usize;\n        transitions.push(Transition::new(unix_leap_time, local_time_type_index));\n    }\n\n    let mut local_time_types = Vec::with_capacity(state.header.type_count);\n    for arr in state.local_time_types.chunks_exact(6) {\n        let ut_offset = read_be_i32(&arr[..4])?;\n\n        let is_dst = match arr[4] {\n            0 => false,\n            1 => true,\n            _ => return Err(Error::InvalidTzFile(\"invalid DST indicator\")),\n        };\n\n        let char_index = arr[5] as usize;\n        if char_index >= state.header.char_count {\n            return Err(Error::InvalidTzFile(\"invalid time zone name char index\"));\n        }\n\n        let position = match state.names[char_index..].iter().position(|&c| c == b'\\0') {\n            Some(position) => position,\n            None => return Err(Error::InvalidTzFile(\"invalid time zone name char index\")),\n        };\n\n        let name = &state.names[char_index..char_index + position];\n        let name = if !name.is_empty() { Some(name) } else { None };\n        local_time_types.push(LocalTimeType::new(ut_offset, is_dst, name)?);\n    }\n\n    let mut leap_seconds = Vec::with_capacity(state.header.leap_count);\n    for arr in state.leap_seconds.chunks_exact(state.time_size + 4) {\n        let unix_leap_time = state.parse_time(&arr[0..state.time_size], state.header.version)?;\n        let correction = read_be_i32(&arr[state.time_size..state.time_size + 4])?;\n        leap_seconds.push(LeapSecond::new(unix_leap_time, correction));\n    }\n\n    let std_walls_iter = state.std_walls.iter().copied().chain(iter::repeat(0));\n    let ut_locals_iter = state.ut_locals.iter().copied().chain(iter::repeat(0));\n    if std_walls_iter.zip(ut_locals_iter).take(state.header.type_count).any(|pair| pair == (0, 1)) {\n        return Err(Error::InvalidTzFile(\n            \"invalid couple of standard/wall and UT/local indicators\",\n        ));\n    }\n\n    let extra_rule = match footer {\n        Some(footer) => {\n            let footer = str::from_utf8(footer)?;\n            if !(footer.starts_with('\\n') && footer.ends_with('\\n')) {\n                return Err(Error::InvalidTzFile(\"invalid footer\"));\n            }\n\n            let tz_string = footer.trim_matches(|c: char| c.is_ascii_whitespace());\n            if tz_string.starts_with(':') || tz_string.contains('\\0') {\n                return Err(Error::InvalidTzFile(\"invalid footer\"));\n            }\n\n            match tz_string.is_empty() {\n                true => None,\n                false => Some(TransitionRule::from_tz_string(\n                    tz_string.as_bytes(),\n                    state.header.version == Version::V3,\n                )?),\n            }\n        }\n        None => None,\n    };\n\n    TimeZone::new(transitions, local_time_types, leap_seconds, extra_rule)\n}","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::read_be_i32":["pub(crate) fn read_be_i32(bytes: &[u8]) -> Result<i32, Error>{\n    if bytes.len() != 4 {\n        return Err(Error::InvalidSlice(\"too short for i32\"));\n    }\n\n    let mut buf = [0; 4];\n    buf.copy_from_slice(bytes);\n    Ok(i32::from_be_bytes(buf))\n}","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::parser::read_be_i64":["pub(crate) fn read_be_i64(bytes: &[u8]) -> Result<i64, Error>{\n    if bytes.len() != 8 {\n        return Err(Error::InvalidSlice(\"too short for i64\"));\n    }\n\n    let mut buf = [0; 8];\n    buf.copy_from_slice(bytes);\n    Ok(i64::from_be_bytes(buf))\n}","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))"],"offset::local::tz_info::rule::AlternateTime":["/// Transition rule representing alternate local time types\npub(super) struct AlternateTime {\n    /// Local time type for standard time\n    pub(super) std: LocalTimeType,\n    /// Local time type for Daylight Saving Time\n    pub(super) dst: LocalTimeType,\n    /// Start day of Daylight Saving Time\n    dst_start: RuleDay,\n    /// Local start day time of Daylight Saving Time, in seconds\n    dst_start_time: i32,\n    /// End day of Daylight Saving Time\n    dst_end: RuleDay,\n    /// Local end day time of Daylight Saving Time, in seconds\n    dst_end_time: i32,\n}","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::AlternateTime::find_local_time_type":["/// Find the local time type associated to the alternate transition rule at the specified Unix time in seconds\nfn find_local_time_type(&self, unix_time: i64) -> Result<&LocalTimeType, Error>{\n        // Overflow is not possible\n        let dst_start_time_in_utc = self.dst_start_time as i64 - self.std.ut_offset as i64;\n        let dst_end_time_in_utc = self.dst_end_time as i64 - self.dst.ut_offset as i64;\n\n        let current_year = match UtcDateTime::from_timespec(unix_time) {\n            Ok(dt) => dt.year,\n            Err(error) => return Err(error),\n        };\n\n        // Check if the current year is valid for the following computations\n        if !(i32::min_value() + 2 <= current_year && current_year <= i32::max_value() - 2) {\n            return Err(Error::OutOfRange(\"out of range date time\"));\n        }\n\n        let current_year_dst_start_unix_time =\n            self.dst_start.unix_time(current_year, dst_start_time_in_utc);\n        let current_year_dst_end_unix_time =\n            self.dst_end.unix_time(current_year, dst_end_time_in_utc);\n\n        // Check DST start/end Unix times for previous/current/next years to support for transition day times outside of [0h, 24h] range\n        let is_dst =\n            match Ord::cmp(&current_year_dst_start_unix_time, &current_year_dst_end_unix_time) {\n                Ordering::Less | Ordering::Equal => {\n                    if unix_time < current_year_dst_start_unix_time {\n                        let previous_year_dst_end_unix_time =\n                            self.dst_end.unix_time(current_year - 1, dst_end_time_in_utc);\n                        if unix_time < previous_year_dst_end_unix_time {\n                            let previous_year_dst_start_unix_time =\n                                self.dst_start.unix_time(current_year - 1, dst_start_time_in_utc);\n                            previous_year_dst_start_unix_time <= unix_time\n                        } else {\n                            false\n                        }\n                    } else if unix_time < current_year_dst_end_unix_time {\n                        true\n                    } else {\n                        let next_year_dst_start_unix_time =\n                            self.dst_start.unix_time(current_year + 1, dst_start_time_in_utc);\n                        if next_year_dst_start_unix_time <= unix_time {\n                            let next_year_dst_end_unix_time =\n                                self.dst_end.unix_time(current_year + 1, dst_end_time_in_utc);\n                            unix_time < next_year_dst_end_unix_time\n                        } else {\n                            false\n                        }\n                    }\n                }\n                Ordering::Greater => {\n                    if unix_time < current_year_dst_end_unix_time {\n                        let previous_year_dst_start_unix_time =\n                            self.dst_start.unix_time(current_year - 1, dst_start_time_in_utc);\n                        if unix_time < previous_year_dst_start_unix_time {\n                            let previous_year_dst_end_unix_time =\n                                self.dst_end.unix_time(current_year - 1, dst_end_time_in_utc);\n                            unix_time < previous_year_dst_end_unix_time\n                        } else {\n                            true\n                        }\n                    } else if unix_time < current_year_dst_start_unix_time {\n                        false\n                    } else {\n                        let next_year_dst_end_unix_time =\n                            self.dst_end.unix_time(current_year + 1, dst_end_time_in_utc);\n                        if next_year_dst_end_unix_time <= unix_time {\n                            let next_year_dst_start_unix_time =\n                                self.dst_start.unix_time(current_year + 1, dst_start_time_in_utc);\n                            next_year_dst_start_unix_time <= unix_time\n                        } else {\n                            true\n                        }\n                    }\n                }\n            };\n\n        if is_dst {\n            Ok(&self.dst)\n        } else {\n            Ok(&self.std)\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::AlternateTime::find_local_time_type_from_local":["fn find_local_time_type_from_local(\n        &self,\n        local_time: i64,\n        current_year: i32,\n    ) -> Result<crate::LocalResult<LocalTimeType>, Error>{\n        // Check if the current year is valid for the following computations\n        if !(i32::min_value() + 2 <= current_year && current_year <= i32::max_value() - 2) {\n            return Err(Error::OutOfRange(\"out of range date time\"));\n        }\n\n        let dst_start_transition_start =\n            self.dst_start.unix_time(current_year, 0) + i64::from(self.dst_start_time);\n        let dst_start_transition_end = self.dst_start.unix_time(current_year, 0)\n            + i64::from(self.dst_start_time)\n            + i64::from(self.dst.ut_offset)\n            - i64::from(self.std.ut_offset);\n\n        let dst_end_transition_start =\n            self.dst_end.unix_time(current_year, 0) + i64::from(self.dst_end_time);\n        let dst_end_transition_end = self.dst_end.unix_time(current_year, 0)\n            + i64::from(self.dst_end_time)\n            + i64::from(self.std.ut_offset)\n            - i64::from(self.dst.ut_offset);\n\n        match self.std.ut_offset.cmp(&self.dst.ut_offset) {\n            Ordering::Equal => Ok(crate::LocalResult::Single(self.std)),\n            Ordering::Less => {\n                if self.dst_start.transition_date(current_year).0\n                    < self.dst_end.transition_date(current_year).0\n                {\n                    // northern hemisphere\n                    // For the DST END transition, the `start` happens at a later timestamp than the `end`.\n                    if local_time <= dst_start_transition_start {\n                        Ok(crate::LocalResult::Single(self.std))\n                    } else if local_time > dst_start_transition_start\n                        && local_time < dst_start_transition_end\n                    {\n                        Ok(crate::LocalResult::None)\n                    } else if local_time >= dst_start_transition_end\n                        && local_time < dst_end_transition_end\n                    {\n                        Ok(crate::LocalResult::Single(self.dst))\n                    } else if local_time >= dst_end_transition_end\n                        && local_time <= dst_end_transition_start\n                    {\n                        Ok(crate::LocalResult::Ambiguous(self.std, self.dst))\n                    } else {\n                        Ok(crate::LocalResult::Single(self.std))\n                    }\n                } else {\n                    // southern hemisphere regular DST\n                    // For the DST END transition, the `start` happens at a later timestamp than the `end`.\n                    if local_time < dst_end_transition_end {\n                        Ok(crate::LocalResult::Single(self.dst))\n                    } else if local_time >= dst_end_transition_end\n                        && local_time <= dst_end_transition_start\n                    {\n                        Ok(crate::LocalResult::Ambiguous(self.std, self.dst))\n                    } else if local_time > dst_end_transition_end\n                        && local_time < dst_start_transition_start\n                    {\n                        Ok(crate::LocalResult::Single(self.std))\n                    } else if local_time >= dst_start_transition_start\n                        && local_time < dst_start_transition_end\n                    {\n                        Ok(crate::LocalResult::None)\n                    } else {\n                        Ok(crate::LocalResult::Single(self.dst))\n                    }\n                }\n            }\n            Ordering::Greater => {\n                if self.dst_start.transition_date(current_year).0\n                    < self.dst_end.transition_date(current_year).0\n                {\n                    // southern hemisphere reverse DST\n                    // For the DST END transition, the `start` happens at a later timestamp than the `end`.\n                    if local_time < dst_start_transition_end {\n                        Ok(crate::LocalResult::Single(self.std))\n                    } else if local_time >= dst_start_transition_end\n                        && local_time <= dst_start_transition_start\n                    {\n                        Ok(crate::LocalResult::Ambiguous(self.dst, self.std))\n                    } else if local_time > dst_start_transition_start\n                        && local_time < dst_end_transition_start\n                    {\n                        Ok(crate::LocalResult::Single(self.dst))\n                    } else if local_time >= dst_end_transition_start\n                        && local_time < dst_end_transition_end\n                    {\n                        Ok(crate::LocalResult::None)\n                    } else {\n                        Ok(crate::LocalResult::Single(self.std))\n                    }\n                } else {\n                    // northern hemisphere reverse DST\n                    // For the DST END transition, the `start` happens at a later timestamp than the `end`.\n                    if local_time <= dst_end_transition_start {\n                        Ok(crate::LocalResult::Single(self.dst))\n                    } else if local_time > dst_end_transition_start\n                        && local_time < dst_end_transition_end\n                    {\n                        Ok(crate::LocalResult::None)\n                    } else if local_time >= dst_end_transition_end\n                        && local_time < dst_start_transition_end\n                    {\n                        Ok(crate::LocalResult::Single(self.std))\n                    } else if local_time >= dst_start_transition_end\n                        && local_time <= dst_start_transition_start\n                    {\n                        Ok(crate::LocalResult::Ambiguous(self.dst, self.std))\n                    } else {\n                        Ok(crate::LocalResult::Single(self.dst))\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::AlternateTime::new":["/// Construct a transition rule representing alternate local time types\nconst fn new(\n        std: LocalTimeType,\n        dst: LocalTimeType,\n        dst_start: RuleDay,\n        dst_start_time: i32,\n        dst_end: RuleDay,\n        dst_end_time: i32,\n    ) -> Result<Self, Error>{\n        // Overflow is not possible\n        if !((dst_start_time as i64).abs() < SECONDS_PER_WEEK\n            && (dst_end_time as i64).abs() < SECONDS_PER_WEEK)\n        {\n            return Err(Error::TransitionRule(\"invalid DST start or end time\"));\n        }\n\n        Ok(Self { std, dst, dst_start, dst_start_time, dst_end, dst_end_time })\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::RuleDay":["/// Transition rule day\nenum RuleDay {\n    /// Julian day in `[1, 365]`, without taking occasional Feb 29 into account, which is not referenceable\n    Julian1WithoutLeap(u16),\n    /// Zero-based Julian day in `[0, 365]`, taking occasional Feb 29 into account\n    Julian0WithLeap(u16),\n    /// Day represented by a month, a month week and a week day\n    MonthWeekday {\n        /// Month in `[1, 12]`\n        month: u8,\n        /// Week of the month in `[1, 5]`, with `5` representing the last week of the month\n        week: u8,\n        /// Day of the week in `[0, 6]` from Sunday\n        week_day: u8,\n    },\n}","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::RuleDay::julian_0":["/// Construct a transition rule day represented by a zero-based Julian day in `[0, 365]`, taking occasional Feb 29 into account\nconst fn julian_0(julian_day_0: u16) -> Result<Self, Error>{\n        if julian_day_0 > 365 {\n            return Err(Error::TransitionRule(\"invalid rule day julian day\"));\n        }\n\n        Ok(RuleDay::Julian0WithLeap(julian_day_0))\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::RuleDay::julian_1":["/// Construct a transition rule day represented by a Julian day in `[1, 365]`, without taking occasional Feb 29 into account, which is not referenceable\nfn julian_1(julian_day_1: u16) -> Result<Self, Error>{\n        if !(1..=365).contains(&julian_day_1) {\n            return Err(Error::TransitionRule(\"invalid rule day julian day\"));\n        }\n\n        Ok(RuleDay::Julian1WithoutLeap(julian_day_1))\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::RuleDay::month_weekday":["/// Construct a transition rule day represented by a month, a month week and a week day\nfn month_weekday(month: u8, week: u8, week_day: u8) -> Result<Self, Error>{\n        if !(1..=12).contains(&month) {\n            return Err(Error::TransitionRule(\"invalid rule day month\"));\n        }\n\n        if !(1..=5).contains(&week) {\n            return Err(Error::TransitionRule(\"invalid rule day week\"));\n        }\n\n        if week_day > 6 {\n            return Err(Error::TransitionRule(\"invalid rule day week day\"));\n        }\n\n        Ok(RuleDay::MonthWeekday { month, week, week_day })\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::RuleDay::parse":["/// Parse transition rule\nfn parse(cursor: &mut Cursor, use_string_extensions: bool) -> Result<(Self, i32), Error>{\n        let date = match cursor.peek() {\n            Some(b'M') => {\n                cursor.read_exact(1)?;\n                let month = cursor.read_int()?;\n                cursor.read_tag(b\".\")?;\n                let week = cursor.read_int()?;\n                cursor.read_tag(b\".\")?;\n                let week_day = cursor.read_int()?;\n                RuleDay::month_weekday(month, week, week_day)?\n            }\n            Some(b'J') => {\n                cursor.read_exact(1)?;\n                RuleDay::julian_1(cursor.read_int()?)?\n            }\n            _ => RuleDay::julian_0(cursor.read_int()?)?,\n        };\n\n        Ok((\n            date,\n            match (cursor.read_optional_tag(b\"/\")?, use_string_extensions) {\n                (false, _) => 2 * 3600,\n                (true, true) => parse_rule_time_extended(cursor)?,\n                (true, false) => parse_rule_time(cursor)?,\n            },\n        ))\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::RuleDay::transition_date":["/// Get the transition date for the provided year\n///\n/// ## Outputs\n///\n/// * `month`: Month in `[1, 12]`\n/// * `month_day`: Day of the month in `[1, 31]`\nfn transition_date(&self, year: i32) -> (usize, i64){\n        match *self {\n            RuleDay::Julian1WithoutLeap(year_day) => {\n                let year_day = year_day as i64;\n\n                let month = match CUMUL_DAY_IN_MONTHS_NORMAL_YEAR.binary_search(&(year_day - 1)) {\n                    Ok(x) => x + 1,\n                    Err(x) => x,\n                };\n\n                let month_day = year_day - CUMUL_DAY_IN_MONTHS_NORMAL_YEAR[month - 1];\n\n                (month, month_day)\n            }\n            RuleDay::Julian0WithLeap(year_day) => {\n                let leap = is_leap_year(year) as i64;\n\n                let cumul_day_in_months = [\n                    0,\n                    31,\n                    59 + leap,\n                    90 + leap,\n                    120 + leap,\n                    151 + leap,\n                    181 + leap,\n                    212 + leap,\n                    243 + leap,\n                    273 + leap,\n                    304 + leap,\n                    334 + leap,\n                ];\n\n                let year_day = year_day as i64;\n\n                let month = match cumul_day_in_months.binary_search(&year_day) {\n                    Ok(x) => x + 1,\n                    Err(x) => x,\n                };\n\n                let month_day = 1 + year_day - cumul_day_in_months[month - 1];\n\n                (month, month_day)\n            }\n            RuleDay::MonthWeekday { month: rule_month, week, week_day } => {\n                let leap = is_leap_year(year) as i64;\n\n                let month = rule_month as usize;\n\n                let mut day_in_month = DAY_IN_MONTHS_NORMAL_YEAR[month - 1];\n                if month == 2 {\n                    day_in_month += leap;\n                }\n\n                let week_day_of_first_month_day =\n                    (4 + days_since_unix_epoch(year, month, 1)).rem_euclid(DAYS_PER_WEEK);\n                let first_week_day_occurence_in_month =\n                    1 + (week_day as i64 - week_day_of_first_month_day).rem_euclid(DAYS_PER_WEEK);\n\n                let mut month_day =\n                    first_week_day_occurence_in_month + (week as i64 - 1) * DAYS_PER_WEEK;\n                if month_day > day_in_month {\n                    month_day -= DAYS_PER_WEEK\n                }\n\n                (month, month_day)\n            }\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::RuleDay::unix_time":["/// Returns the UTC Unix time in seconds associated to the transition date for the provided year\nfn unix_time(&self, year: i32, day_time_in_utc: i64) -> i64{\n        let (month, month_day) = self.transition_date(year);\n        days_since_unix_epoch(year, month, month_day) * SECONDS_PER_DAY + day_time_in_utc\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::TransitionRule":["/// Transition rule\npub(super) enum TransitionRule {\n    /// Fixed local time type\n    Fixed(LocalTimeType),\n    /// Alternate local time types\n    Alternate(AlternateTime),\n}","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::TransitionRule::find_local_time_type":["/// Find the local time type associated to the transition rule at the specified Unix time in seconds\npub(super) fn find_local_time_type(&self, unix_time: i64) -> Result<&LocalTimeType, Error>{\n        match self {\n            TransitionRule::Fixed(local_time_type) => Ok(local_time_type),\n            TransitionRule::Alternate(alternate_time) => {\n                alternate_time.find_local_time_type(unix_time)\n            }\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::TransitionRule::find_local_time_type_from_local":["/// Find the local time type associated to the transition rule at the specified Unix time in seconds\npub(super) fn find_local_time_type_from_local(\n        &self,\n        local_time: i64,\n        year: i32,\n    ) -> Result<crate::LocalResult<LocalTimeType>, Error>{\n        match self {\n            TransitionRule::Fixed(local_time_type) => {\n                Ok(crate::LocalResult::Single(*local_time_type))\n            }\n            TransitionRule::Alternate(alternate_time) => {\n                alternate_time.find_local_time_type_from_local(local_time, year)\n            }\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::TransitionRule::from_tz_string":["/// Parse a POSIX TZ string containing a time zone description, as described in [the POSIX documentation of the `TZ` environment variable](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html).\n///\n/// TZ string extensions from [RFC 8536](https://datatracker.ietf.org/doc/html/rfc8536#section-3.3.1) may be used.\n///\npub(super) fn from_tz_string(\n        tz_string: &[u8],\n        use_string_extensions: bool,\n    ) -> Result<Self, Error>{\n        let mut cursor = Cursor::new(tz_string);\n\n        let std_time_zone = Some(parse_name(&mut cursor)?);\n        let std_offset = parse_offset(&mut cursor)?;\n\n        if cursor.is_empty() {\n            return Ok(LocalTimeType::new(-std_offset, false, std_time_zone)?.into());\n        }\n\n        let dst_time_zone = Some(parse_name(&mut cursor)?);\n\n        let dst_offset = match cursor.peek() {\n            Some(&b',') => std_offset - 3600,\n            Some(_) => parse_offset(&mut cursor)?,\n            None => {\n                return Err(Error::UnsupportedTzString(\"DST start and end rules must be provided\"))\n            }\n        };\n\n        if cursor.is_empty() {\n            return Err(Error::UnsupportedTzString(\"DST start and end rules must be provided\"));\n        }\n\n        cursor.read_tag(b\",\")?;\n        let (dst_start, dst_start_time) = RuleDay::parse(&mut cursor, use_string_extensions)?;\n\n        cursor.read_tag(b\",\")?;\n        let (dst_end, dst_end_time) = RuleDay::parse(&mut cursor, use_string_extensions)?;\n\n        if !cursor.is_empty() {\n            return Err(Error::InvalidTzString(\"remaining data after parsing TZ string\"));\n        }\n\n        Ok(AlternateTime::new(\n            LocalTimeType::new(-std_offset, false, std_time_zone)?,\n            LocalTimeType::new(-dst_offset, true, dst_time_zone)?,\n            dst_start,\n            dst_start_time,\n            dst_end,\n            dst_end_time,\n        )?\n        .into())\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::UtcDateTime":["/// UTC date time exprimed in the [proleptic gregorian calendar](https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar)\npub(crate) struct UtcDateTime {\n    /// Year\n    pub(crate) year: i32,\n    /// Month in `[1, 12]`\n    pub(crate) month: u8,\n    /// Day of the month in `[1, 31]`\n    pub(crate) month_day: u8,\n    /// Hours since midnight in `[0, 23]`\n    pub(crate) hour: u8,\n    /// Minutes in `[0, 59]`\n    pub(crate) minute: u8,\n    /// Seconds in `[0, 60]`, with a possible leap second\n    pub(crate) second: u8,\n}","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::UtcDateTime::from_timespec":["/// Construct a UTC date time from a Unix time in seconds and nanoseconds\npub(crate) fn from_timespec(unix_time: i64) -> Result<Self, Error>{\n        let seconds = match unix_time.checked_sub(UNIX_OFFSET_SECS) {\n            Some(seconds) => seconds,\n            None => return Err(Error::OutOfRange(\"out of range operation\")),\n        };\n\n        let mut remaining_days = seconds / SECONDS_PER_DAY;\n        let mut remaining_seconds = seconds % SECONDS_PER_DAY;\n        if remaining_seconds < 0 {\n            remaining_seconds += SECONDS_PER_DAY;\n            remaining_days -= 1;\n        }\n\n        let mut cycles_400_years = remaining_days / DAYS_PER_400_YEARS;\n        remaining_days %= DAYS_PER_400_YEARS;\n        if remaining_days < 0 {\n            remaining_days += DAYS_PER_400_YEARS;\n            cycles_400_years -= 1;\n        }\n\n        let cycles_100_years = Ord::min(remaining_days / DAYS_PER_100_YEARS, 3);\n        remaining_days -= cycles_100_years * DAYS_PER_100_YEARS;\n\n        let cycles_4_years = Ord::min(remaining_days / DAYS_PER_4_YEARS, 24);\n        remaining_days -= cycles_4_years * DAYS_PER_4_YEARS;\n\n        let remaining_years = Ord::min(remaining_days / DAYS_PER_NORMAL_YEAR, 3);\n        remaining_days -= remaining_years * DAYS_PER_NORMAL_YEAR;\n\n        let mut year = OFFSET_YEAR\n            + remaining_years\n            + cycles_4_years * 4\n            + cycles_100_years * 100\n            + cycles_400_years * 400;\n\n        let mut month = 0;\n        while month < DAY_IN_MONTHS_LEAP_YEAR_FROM_MARCH.len() {\n            let days = DAY_IN_MONTHS_LEAP_YEAR_FROM_MARCH[month];\n            if remaining_days < days {\n                break;\n            }\n            remaining_days -= days;\n            month += 1;\n        }\n        month += 2;\n\n        if month >= MONTHS_PER_YEAR as usize {\n            month -= MONTHS_PER_YEAR as usize;\n            year += 1;\n        }\n        month += 1;\n\n        let month_day = 1 + remaining_days;\n\n        let hour = remaining_seconds / SECONDS_PER_HOUR;\n        let minute = (remaining_seconds / SECONDS_PER_MINUTE) % MINUTES_PER_HOUR;\n        let second = remaining_seconds % SECONDS_PER_MINUTE;\n\n        let year = match year >= i32::min_value() as i64 && year <= i32::max_value() as i64 {\n            true => year as i32,\n            false => return Err(Error::OutOfRange(\"i64 is out of range for i32\")),\n        };\n\n        Ok(Self {\n            year,\n            month: month as u8,\n            month_day: month_day as u8,\n            hour: hour as u8,\n            minute: minute as u8,\n            second: second as u8,\n        })\n    }","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::days_since_unix_epoch":["/// Compute the number of days since Unix epoch (`1970-01-01T00:00:00Z`).\n///\n/// ## Inputs\n///\n/// * `year`: Year\n/// * `month`: Month in `[1, 12]`\n/// * `month_day`: Day of the month in `[1, 31]`\npub(crate) const fn days_since_unix_epoch(year: i32, month: usize, month_day: i64) -> i64{\n    let is_leap_year = is_leap_year(year);\n\n    let year = year as i64;\n\n    let mut result = (year - 1970) * 365;\n\n    if year >= 1970 {\n        result += (year - 1968) / 4;\n        result -= (year - 1900) / 100;\n        result += (year - 1600) / 400;\n\n        if is_leap_year && month < 3 {\n            result -= 1;\n        }\n    } else {\n        result += (year - 1972) / 4;\n        result -= (year - 2000) / 100;\n        result += (year - 2000) / 400;\n\n        if is_leap_year && month >= 3 {\n            result += 1;\n        }\n    }\n\n    result += CUMUL_DAY_IN_MONTHS_NORMAL_YEAR[month - 1] + month_day - 1;\n\n    result\n}","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::is_leap_year":["/// Check if a year is a leap year\npub(crate) const fn is_leap_year(year: i32) -> bool{\n    year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)\n}","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::parse_hhmmss":["/// Parse hours, minutes and seconds\nfn parse_hhmmss(cursor: &mut Cursor) -> Result<(i32, i32, i32), Error>{\n    let hour = cursor.read_int()?;\n\n    let mut minute = 0;\n    let mut second = 0;\n\n    if cursor.read_optional_tag(b\":\")? {\n        minute = cursor.read_int()?;\n\n        if cursor.read_optional_tag(b\":\")? {\n            second = cursor.read_int()?;\n        }\n    }\n\n    Ok((hour, minute, second))\n}","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::parse_name":["/// Parse time zone name\nfn parse_name<'a>(cursor: &mut Cursor<'a>) -> Result<&'a [u8], Error>{\n    match cursor.peek() {\n        Some(b'<') => {}\n        _ => return Ok(cursor.read_while(u8::is_ascii_alphabetic)?),\n    }\n\n    cursor.read_exact(1)?;\n    let unquoted = cursor.read_until(|&x| x == b'>')?;\n    cursor.read_exact(1)?;\n    Ok(unquoted)\n}","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::parse_offset":["/// Parse time zone offset\nfn parse_offset(cursor: &mut Cursor) -> Result<i32, Error>{\n    let (sign, hour, minute, second) = parse_signed_hhmmss(cursor)?;\n\n    if !(0..=24).contains(&hour) {\n        return Err(Error::InvalidTzString(\"invalid offset hour\"));\n    }\n    if !(0..=59).contains(&minute) {\n        return Err(Error::InvalidTzString(\"invalid offset minute\"));\n    }\n    if !(0..=59).contains(&second) {\n        return Err(Error::InvalidTzString(\"invalid offset second\"));\n    }\n\n    Ok(sign * (hour * 3600 + minute * 60 + second))\n}","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::parse_rule_time":["/// Parse transition rule time\nfn parse_rule_time(cursor: &mut Cursor) -> Result<i32, Error>{\n    let (hour, minute, second) = parse_hhmmss(cursor)?;\n\n    if !(0..=24).contains(&hour) {\n        return Err(Error::InvalidTzString(\"invalid day time hour\"));\n    }\n    if !(0..=59).contains(&minute) {\n        return Err(Error::InvalidTzString(\"invalid day time minute\"));\n    }\n    if !(0..=59).contains(&second) {\n        return Err(Error::InvalidTzString(\"invalid day time second\"));\n    }\n\n    Ok(hour * 3600 + minute * 60 + second)\n}","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::parse_rule_time_extended":["/// Parse transition rule time with TZ string extensions\nfn parse_rule_time_extended(cursor: &mut Cursor) -> Result<i32, Error>{\n    let (sign, hour, minute, second) = parse_signed_hhmmss(cursor)?;\n\n    if !(-167..=167).contains(&hour) {\n        return Err(Error::InvalidTzString(\"invalid day time hour\"));\n    }\n    if !(0..=59).contains(&minute) {\n        return Err(Error::InvalidTzString(\"invalid day time minute\"));\n    }\n    if !(0..=59).contains(&second) {\n        return Err(Error::InvalidTzString(\"invalid day time second\"));\n    }\n\n    Ok(sign * (hour * 3600 + minute * 60 + second))\n}","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::rule::parse_signed_hhmmss":["/// Parse signed hours, minutes and seconds\nfn parse_signed_hhmmss(cursor: &mut Cursor) -> Result<(i32, i32, i32, i32), Error>{\n    let mut sign = 1;\n    if let Some(&c) = cursor.peek() {\n        if c == b'+' || c == b'-' {\n            cursor.read_exact(1)?;\n            if c == b'-' {\n                sign = -1;\n            }\n        }\n    }\n\n    let (hour, minute, second) = parse_hhmmss(cursor)?;\n    Ok((sign, hour, minute, second))\n}","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))"],"offset::local::tz_info::timezone::LeapSecond":["/// Leap second of a TZif file\npub(super) struct LeapSecond {\n    /// Unix leap time\n    unix_leap_time: i64,\n    /// Leap second correction\n    correction: i32,\n}","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::LeapSecond::new":["/// Construct a TZif file leap second\npub(super) const fn new(unix_leap_time: i64, correction: i32) -> Self{\n        Self { unix_leap_time, correction }\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::LeapSecond::unix_leap_time":["/// Returns Unix leap time\nconst fn unix_leap_time(&self) -> i64{\n        self.unix_leap_time\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::LocalTimeType":["/// Local time type associated to a time zone\npub(crate) struct LocalTimeType {\n    /// Offset from UTC in seconds\n    pub(super) ut_offset: i32,\n    /// Daylight Saving Time indicator\n    is_dst: bool,\n    /// Time zone name\n    name: Option<TimeZoneName>,\n}","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::LocalTimeType::is_dst":["/// Returns daylight saving time indicator\npub(super) const fn is_dst(&self) -> bool{\n        self.is_dst\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::LocalTimeType::new":["/// Construct a local time type\npub(super) fn new(ut_offset: i32, is_dst: bool, name: Option<&[u8]>) -> Result<Self, Error>{\n        if ut_offset == i32::min_value() {\n            return Err(Error::LocalTimeType(\"invalid UTC offset\"));\n        }\n\n        let name = match name {\n            Some(name) => TimeZoneName::new(name)?,\n            None => return Ok(Self { ut_offset, is_dst, name: None }),\n        };\n\n        Ok(Self { ut_offset, is_dst, name: Some(name) })\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::LocalTimeType::offset":["/// Returns offset from UTC in seconds\npub(crate) const fn offset(&self) -> i32{\n        self.ut_offset\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::LocalTimeType::with_offset":["/// Construct a local time type with the specified UTC offset in seconds\npub(super) const fn with_offset(ut_offset: i32) -> Result<Self, Error>{\n        if ut_offset == i32::min_value() {\n            return Err(Error::LocalTimeType(\"invalid UTC offset\"));\n        }\n\n        Ok(Self { ut_offset, is_dst: false, name: None })\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZone":["/// Time zone\npub(crate) struct TimeZone {\n    /// List of transitions\n    transitions: Vec<Transition>,\n    /// List of local time types (cannot be empty)\n    local_time_types: Vec<LocalTimeType>,\n    /// List of leap seconds\n    leap_seconds: Vec<LeapSecond>,\n    /// Extra transition rule applicable after the last transition\n    extra_rule: Option<TransitionRule>,\n}","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZone::as_ref":["/// Returns a reference to the time zone\nfn as_ref(&self) -> TimeZoneRef{\n        TimeZoneRef {\n            transitions: &self.transitions,\n            local_time_types: &self.local_time_types,\n            leap_seconds: &self.leap_seconds,\n            extra_rule: &self.extra_rule,\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZone::find_local_time_type":["/// Find the local time type associated to the time zone at the specified Unix time in seconds\npub(crate) fn find_local_time_type(&self, unix_time: i64) -> Result<&LocalTimeType, Error>{\n        self.as_ref().find_local_time_type(unix_time)\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZone::find_local_time_type_from_local":["pub(crate) fn find_local_time_type_from_local(\n        &self,\n        local_time: i64,\n        year: i32,\n    ) -> Result<crate::LocalResult<LocalTimeType>, Error>{\n        self.as_ref().find_local_time_type_from_local(local_time, year)\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZone::fixed":["/// Construct a time zone with the specified UTC offset in seconds\nfn fixed(ut_offset: i32) -> Result<Self, Error>{\n        Ok(Self {\n            transitions: Vec::new(),\n            local_time_types: vec![LocalTimeType::with_offset(ut_offset)?],\n            leap_seconds: Vec::new(),\n            extra_rule: None,\n        })\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZone::from_file":["/// Construct a time zone from the contents of a time zone file\nfn from_file(file: &mut File) -> Result<Self, Error>{\n        let mut bytes = Vec::new();\n        file.read_to_end(&mut bytes)?;\n        Self::from_tz_data(&bytes)\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZone::from_posix_tz":["/// Construct a time zone from a POSIX TZ string, as described in [the POSIX documentation of the `TZ` environment variable](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html).\nfn from_posix_tz(tz_string: &str) -> Result<Self, Error>{\n        if tz_string.is_empty() {\n            return Err(Error::InvalidTzString(\"empty TZ string\"));\n        }\n\n        if tz_string == \"localtime\" {\n            return Self::from_tz_data(&fs::read(\"/etc/localtime\")?);\n        }\n\n        // attributes are not allowed on if blocks in Rust 1.38\n        #[cfg(target_os = \"android\")]\n        {\n            if let Ok(bytes) = android_tzdata::find_tz_data(tz_string) {\n                return Self::from_tz_data(&bytes);\n            }\n        }\n\n        let mut chars = tz_string.chars();\n        if chars.next() == Some(':') {\n            return Self::from_file(&mut find_tz_file(chars.as_str())?);\n        }\n\n        if let Ok(mut file) = find_tz_file(tz_string) {\n            return Self::from_file(&mut file);\n        }\n\n        // TZ string extensions are not allowed\n        let tz_string = tz_string.trim_matches(|c: char| c.is_ascii_whitespace());\n        let rule = TransitionRule::from_tz_string(tz_string.as_bytes(), false)?;\n        Self::new(\n            vec![],\n            match rule {\n                TransitionRule::Fixed(local_time_type) => vec![local_time_type],\n                TransitionRule::Alternate(AlternateTime { std, dst, .. }) => vec![std, dst],\n            },\n            vec![],\n            Some(rule),\n        )\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZone::from_tz_data":["/// Construct a time zone from the contents of a time zone file\n///\n/// Parse TZif data as described in [RFC 8536](https://datatracker.ietf.org/doc/html/rfc8536).\npub(crate) fn from_tz_data(bytes: &[u8]) -> Result<Self, Error>{\n        parser::parse(bytes)\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZone::local":["/// Returns local time zone.\n///\n/// This method in not supported on non-UNIX platforms, and returns the UTC time zone instead.\n///\npub(crate) fn local(env_tz: Option<&str>) -> Result<Self, Error>{\n        match env_tz {\n            Some(tz) => Self::from_posix_tz(tz),\n            None => Self::from_posix_tz(\"localtime\"),\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZone::new":["/// Construct a time zone\npub(super) fn new(\n        transitions: Vec<Transition>,\n        local_time_types: Vec<LocalTimeType>,\n        leap_seconds: Vec<LeapSecond>,\n        extra_rule: Option<TransitionRule>,\n    ) -> Result<Self, Error>{\n        let new = Self { transitions, local_time_types, leap_seconds, extra_rule };\n        new.as_ref().validate()?;\n        Ok(new)\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZone::utc":["/// Construct the time zone associated to UTC\npub(crate) fn utc() -> Self{\n        Self {\n            transitions: Vec::new(),\n            local_time_types: vec![LocalTimeType::UTC],\n            leap_seconds: Vec::new(),\n            extra_rule: None,\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZoneName":["/// ASCII-encoded fixed-capacity string, used for storing time zone names\nstruct TimeZoneName {\n    /// Length-prefixed string buffer\n    bytes: [u8; 8],\n}","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZoneName::as_bytes":["/// Returns time zone name as a byte slice\nfn as_bytes(&self) -> &[u8]{\n        match self.bytes[0] {\n            3 => &self.bytes[1..4],\n            4 => &self.bytes[1..5],\n            5 => &self.bytes[1..6],\n            6 => &self.bytes[1..7],\n            7 => &self.bytes[1..8],\n            _ => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZoneName::equal":["/// Check if two time zone names are equal\nfn equal(&self, other: &Self) -> bool{\n        self.bytes == other.bytes\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZoneName::new":["/// Construct a time zone name\nfn new(input: &[u8]) -> Result<Self, Error>{\n        let len = input.len();\n\n        if !(3..=7).contains(&len) {\n            return Err(Error::LocalTimeType(\n                \"time zone name must have between 3 and 7 characters\",\n            ));\n        }\n\n        let mut bytes = [0; 8];\n        bytes[0] = input.len() as u8;\n\n        let mut i = 0;\n        while i < len {\n            let b = input[i];\n            match b {\n                b'0'..=b'9' | b'A'..=b'Z' | b'a'..=b'z' | b'+' | b'-' => {}\n                _ => return Err(Error::LocalTimeType(\"invalid characters in time zone name\")),\n            }\n\n            bytes[i + 1] = b;\n            i += 1;\n        }\n\n        Ok(Self { bytes })\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZoneRef":["/// Reference to a time zone\npub(crate) struct TimeZoneRef<'a> {\n    /// List of transitions\n    transitions: &'a [Transition],\n    /// List of local time types (cannot be empty)\n    local_time_types: &'a [LocalTimeType],\n    /// List of leap seconds\n    leap_seconds: &'a [LeapSecond],\n    /// Extra transition rule applicable after the last transition\n    extra_rule: &'a Option<TransitionRule>,\n}","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::find_local_time_type":["/// Find the local time type associated to the time zone at the specified Unix time in seconds\npub(crate) fn find_local_time_type(&self, unix_time: i64) -> Result<&'a LocalTimeType, Error>{\n        let extra_rule = match self.transitions.last() {\n            None => match self.extra_rule {\n                Some(extra_rule) => extra_rule,\n                None => return Ok(&self.local_time_types[0]),\n            },\n            Some(last_transition) => {\n                let unix_leap_time = match self.unix_time_to_unix_leap_time(unix_time) {\n                    Ok(unix_leap_time) => unix_leap_time,\n                    Err(Error::OutOfRange(error)) => return Err(Error::FindLocalTimeType(error)),\n                    Err(err) => return Err(err),\n                };\n\n                if unix_leap_time >= last_transition.unix_leap_time {\n                    match self.extra_rule {\n                        Some(extra_rule) => extra_rule,\n                        None => {\n                            return Err(Error::FindLocalTimeType(\n                                \"no local time type is available for the specified timestamp\",\n                            ))\n                        }\n                    }\n                } else {\n                    let index = match self\n                        .transitions\n                        .binary_search_by_key(&unix_leap_time, Transition::unix_leap_time)\n                    {\n                        Ok(x) => x + 1,\n                        Err(x) => x,\n                    };\n\n                    let local_time_type_index = if index > 0 {\n                        self.transitions[index - 1].local_time_type_index\n                    } else {\n                        0\n                    };\n                    return Ok(&self.local_time_types[local_time_type_index]);\n                }\n            }\n        };\n\n        match extra_rule.find_local_time_type(unix_time) {\n            Ok(local_time_type) => Ok(local_time_type),\n            Err(Error::OutOfRange(error)) => Err(Error::FindLocalTimeType(error)),\n            err => err,\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::find_local_time_type_from_local":["pub(crate) fn find_local_time_type_from_local(\n        &self,\n        local_time: i64,\n        year: i32,\n    ) -> Result<crate::LocalResult<LocalTimeType>, Error>{\n        // #TODO: this is wrong as we need 'local_time_to_local_leap_time ?\n        // but ... does the local time even include leap seconds ??\n        // let unix_leap_time = match self.unix_time_to_unix_leap_time(local_time) {\n        //     Ok(unix_leap_time) => unix_leap_time,\n        //     Err(Error::OutOfRange(error)) => return Err(Error::FindLocalTimeType(error)),\n        //     Err(err) => return Err(err),\n        // };\n        let local_leap_time = local_time;\n\n        // if we have at least one transition,\n        // we must check _all_ of them, incase of any Overlapping (LocalResult::Ambiguous) or Skipping (LocalResult::None) transitions\n        if !self.transitions.is_empty() {\n            let mut prev = Some(self.local_time_types[0]);\n\n            for transition in self.transitions {\n                let after_ltt = self.local_time_types[transition.local_time_type_index];\n\n                // the end and start here refers to where the time starts prior to the transition\n                // and where it ends up after. not the temporal relationship.\n                let transition_end = transition.unix_leap_time + i64::from(after_ltt.ut_offset);\n                let transition_start =\n                    transition.unix_leap_time + i64::from(prev.unwrap().ut_offset);\n\n                match transition_start.cmp(&transition_end) {\n                    Ordering::Greater => {\n                        // bakwards transition, eg from DST to regular\n                        // this means a given local time could have one of two possible offsets\n                        if local_leap_time < transition_end {\n                            return Ok(crate::LocalResult::Single(prev.unwrap()));\n                        } else if local_leap_time >= transition_end\n                            && local_leap_time <= transition_start\n                        {\n                            if prev.unwrap().ut_offset < after_ltt.ut_offset {\n                                return Ok(crate::LocalResult::Ambiguous(prev.unwrap(), after_ltt));\n                            } else {\n                                return Ok(crate::LocalResult::Ambiguous(after_ltt, prev.unwrap()));\n                            }\n                        }\n                    }\n                    Ordering::Equal => {\n                        // should this ever happen? presumably we have to handle it anyway.\n                        if local_leap_time < transition_start {\n                            return Ok(crate::LocalResult::Single(prev.unwrap()));\n                        } else if local_leap_time == transition_end {\n                            if prev.unwrap().ut_offset < after_ltt.ut_offset {\n                                return Ok(crate::LocalResult::Ambiguous(prev.unwrap(), after_ltt));\n                            } else {\n                                return Ok(crate::LocalResult::Ambiguous(after_ltt, prev.unwrap()));\n                            }\n                        }\n                    }\n                    Ordering::Less => {\n                        // forwards transition, eg from regular to DST\n                        // this means that times that are skipped are invalid local times\n                        if local_leap_time <= transition_start {\n                            return Ok(crate::LocalResult::Single(prev.unwrap()));\n                        } else if local_leap_time < transition_end {\n                            return Ok(crate::LocalResult::None);\n                        } else if local_leap_time == transition_end {\n                            return Ok(crate::LocalResult::Single(after_ltt));\n                        }\n                    }\n                }\n\n                // try the next transition, we are fully after this one\n                prev = Some(after_ltt);\n            }\n        };\n\n        if let Some(extra_rule) = self.extra_rule {\n            match extra_rule.find_local_time_type_from_local(local_time, year) {\n                Ok(local_time_type) => Ok(local_time_type),\n                Err(Error::OutOfRange(error)) => Err(Error::FindLocalTimeType(error)),\n                err => err,\n            }\n        } else {\n            Ok(crate::LocalResult::Single(self.local_time_types[0]))\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::unix_leap_time_to_unix_time":["/// Convert Unix leap time to Unix time, from the list of leap seconds in a time zone\nfn unix_leap_time_to_unix_time(&self, unix_leap_time: i64) -> Result<i64, Error>{\n        if unix_leap_time == i64::min_value() {\n            return Err(Error::OutOfRange(\"out of range operation\"));\n        }\n\n        let index = match self\n            .leap_seconds\n            .binary_search_by_key(&(unix_leap_time - 1), LeapSecond::unix_leap_time)\n        {\n            Ok(x) => x + 1,\n            Err(x) => x,\n        };\n\n        let correction = if index > 0 { self.leap_seconds[index - 1].correction } else { 0 };\n\n        match unix_leap_time.checked_sub(correction as i64) {\n            Some(unix_time) => Ok(unix_time),\n            None => Err(Error::OutOfRange(\"out of range operation\")),\n        }\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::unix_time_to_unix_leap_time":["/// Convert Unix time to Unix leap time, from the list of leap seconds in a time zone\nconst fn unix_time_to_unix_leap_time(&self, unix_time: i64) -> Result<i64, Error>{\n        let mut unix_leap_time = unix_time;\n\n        let mut i = 0;\n        while i < self.leap_seconds.len() {\n            let leap_second = &self.leap_seconds[i];\n\n            if unix_leap_time < leap_second.unix_leap_time {\n                break;\n            }\n\n            unix_leap_time = match unix_time.checked_add(leap_second.correction as i64) {\n                Some(unix_leap_time) => unix_leap_time,\n                None => return Err(Error::OutOfRange(\"out of range operation\")),\n            };\n\n            i += 1;\n        }\n\n        Ok(unix_leap_time)\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::validate":["/// Check time zone inputs\nfn validate(&self) -> Result<(), Error>{\n        // Check local time types\n        let local_time_types_size = self.local_time_types.len();\n        if local_time_types_size == 0 {\n            return Err(Error::TimeZone(\"list of local time types must not be empty\"));\n        }\n\n        // Check transitions\n        let mut i_transition = 0;\n        while i_transition < self.transitions.len() {\n            if self.transitions[i_transition].local_time_type_index >= local_time_types_size {\n                return Err(Error::TimeZone(\"invalid local time type index\"));\n            }\n\n            if i_transition + 1 < self.transitions.len()\n                && self.transitions[i_transition].unix_leap_time\n                    >= self.transitions[i_transition + 1].unix_leap_time\n            {\n                return Err(Error::TimeZone(\"invalid transition\"));\n            }\n\n            i_transition += 1;\n        }\n\n        // Check leap seconds\n        if !(self.leap_seconds.is_empty()\n            || self.leap_seconds[0].unix_leap_time >= 0\n                && saturating_abs(self.leap_seconds[0].correction) == 1)\n        {\n            return Err(Error::TimeZone(\"invalid leap second\"));\n        }\n\n        let min_interval = SECONDS_PER_28_DAYS - 1;\n\n        let mut i_leap_second = 0;\n        while i_leap_second < self.leap_seconds.len() {\n            if i_leap_second + 1 < self.leap_seconds.len() {\n                let x0 = &self.leap_seconds[i_leap_second];\n                let x1 = &self.leap_seconds[i_leap_second + 1];\n\n                let diff_unix_leap_time = x1.unix_leap_time.saturating_sub(x0.unix_leap_time);\n                let abs_diff_correction =\n                    saturating_abs(x1.correction.saturating_sub(x0.correction));\n\n                if !(diff_unix_leap_time >= min_interval && abs_diff_correction == 1) {\n                    return Err(Error::TimeZone(\"invalid leap second\"));\n                }\n            }\n            i_leap_second += 1;\n        }\n\n        // Check extra rule\n        let (extra_rule, last_transition) = match (&self.extra_rule, self.transitions.last()) {\n            (Some(rule), Some(trans)) => (rule, trans),\n            _ => return Ok(()),\n        };\n\n        let last_local_time_type = &self.local_time_types[last_transition.local_time_type_index];\n        let unix_time = match self.unix_leap_time_to_unix_time(last_transition.unix_leap_time) {\n            Ok(unix_time) => unix_time,\n            Err(Error::OutOfRange(error)) => return Err(Error::TimeZone(error)),\n            Err(err) => return Err(err),\n        };\n\n        let rule_local_time_type = match extra_rule.find_local_time_type(unix_time) {\n            Ok(rule_local_time_type) => rule_local_time_type,\n            Err(Error::OutOfRange(error)) => return Err(Error::TimeZone(error)),\n            Err(err) => return Err(err),\n        };\n\n        let check = last_local_time_type.ut_offset == rule_local_time_type.ut_offset\n            && last_local_time_type.is_dst == rule_local_time_type.is_dst\n            && match (&last_local_time_type.name, &rule_local_time_type.name) {\n                (Some(x), Some(y)) => x.equal(y),\n                (None, None) => true,\n                _ => false,\n            };\n\n        if !check {\n            return Err(Error::TimeZone(\n                \"extra transition rule is inconsistent with the last transition\",\n            ));\n        }\n\n        Ok(())\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::Transition":["/// Transition of a TZif file\npub(super) struct Transition {\n    /// Unix leap time\n    unix_leap_time: i64,\n    /// Index specifying the local time type of the transition\n    local_time_type_index: usize,\n}","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::Transition::new":["/// Construct a TZif file transition\npub(super) const fn new(unix_leap_time: i64, local_time_type_index: usize) -> Self{\n        Self { unix_leap_time, local_time_type_index }\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::Transition::unix_leap_time":["/// Returns Unix leap time\nconst fn unix_leap_time(&self) -> i64{\n        self.unix_leap_time\n    }","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::find_tz_file":["/// Open the TZif file corresponding to a TZ string\nfn find_tz_file(path: impl AsRef<Path>) -> Result<File, Error>{\n    // Don't check system timezone directories on non-UNIX platforms\n    #[cfg(not(unix))]\n    return Ok(File::open(path)?);\n\n    #[cfg(unix)]\n    {\n        let path = path.as_ref();\n        if path.is_absolute() {\n            return Ok(File::open(path)?);\n        }\n\n        for folder in &ZONE_INFO_DIRECTORIES {\n            if let Ok(file) = File::open(PathBuf::from(folder).join(path)) {\n                return Ok(file);\n            }\n        }\n\n        Err(Error::Io(io::ErrorKind::NotFound.into()))\n    }\n}","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::local::tz_info::timezone::saturating_abs":["#[inline]\nconst fn saturating_abs(v: i32) -> i32{\n    if v.is_positive() {\n        v\n    } else if v == i32::min_value() {\n        i32::max_value()\n    } else {\n        -v\n    }\n}","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))"],"offset::utc::Utc":["/// The UTC time zone. This is the most efficient time zone when you don't need the local time.\n/// It is also used as an offset (which is also a dummy type).\n///\n/// Using the [`TimeZone`](./trait.TimeZone.html) methods\n/// on the UTC struct is the preferred way to construct `DateTime<Utc>`\n/// instances.\n///\n/// # Example\n///\n/// ```\n/// use chrono::{DateTime, TimeZone, NaiveDateTime, Utc};\n///\n/// let dt = DateTime::<Utc>::from_utc(NaiveDateTime::from_timestamp_opt(61, 0).unwrap(), Utc);\n///\n/// assert_eq!(Utc.timestamp_opt(61, 0).unwrap(), dt);\n/// assert_eq!(Utc.with_ymd_and_hms(1970, 1, 1, 0, 1, 1).unwrap(), dt);\n/// ```\npub struct Utc;","Real(LocalPath(\"src/offset/utc.rs\"))"],"offset::utc::Utc::now":["/// Returns a `DateTime` which corresponds to the current date and time.\n#[cfg(not(all(\n        target_arch = \"wasm32\",\n        feature = \"wasmbind\",\n        not(any(target_os = \"emscripten\", target_os = \"wasi\"))\n    )))]\n#[must_use]\npub fn now() -> DateTime<Utc>{\n        let now =\n            SystemTime::now().duration_since(UNIX_EPOCH).expect(\"system time before Unix epoch\");\n        let naive =\n            NaiveDateTime::from_timestamp_opt(now.as_secs() as i64, now.subsec_nanos()).unwrap();\n        DateTime::from_utc(naive, Utc)\n    }","Real(LocalPath(\"src/offset/utc.rs\"))"],"offset::utc::Utc::today":["/// Returns a `Date` which corresponds to the current date.\n#[deprecated(\n        since = \"0.4.23\",\n        note = \"use `Utc::now()` instead, potentially with `.date_naive()`\"\n    )]\n#[allow(deprecated)]\n#[must_use]\npub fn today() -> Date<Utc>{\n        Utc::now().date()\n    }","Real(LocalPath(\"src/offset/utc.rs\"))"],"round::DurationRound":["/// Extension trait for rounding or truncating a DateTime by a Duration.\n///\n/// # Limitations\n/// Both rounding and truncating are done via [`Duration::num_nanoseconds`] and\n/// [`DateTime::timestamp_nanos`]. This means that they will fail if either the\n/// `Duration` or the `DateTime` are too big to represented as nanoseconds. They\n/// will also fail if the `Duration` is bigger than the timestamp.\npub trait DurationRound: Sized {\n    /// Error that can occur in rounding or truncating\n    #[cfg(any(feature = \"std\", test))]\n    type Err: std::error::Error;\n\n    /// Error that can occur in rounding or truncating\n    #[cfg(not(any(feature = \"std\", test)))]\n    type Err: fmt::Debug + fmt::Display;\n\n    /// Return a copy rounded by Duration.\n    ///\n    /// # Example\n    /// ``` rust\n    /// # use chrono::{DurationRound, Duration, Utc, NaiveDate};\n    /// let dt = NaiveDate::from_ymd_opt(2018, 1, 11).unwrap().and_hms_milli_opt(12, 0, 0, 154).unwrap().and_local_timezone(Utc).unwrap();\n    /// assert_eq!(\n    ///     dt.duration_round(Duration::milliseconds(10)).unwrap().to_string(),\n    ///     \"2018-01-11 12:00:00.150 UTC\"\n    /// );\n    /// assert_eq!(\n    ///     dt.duration_round(Duration::days(1)).unwrap().to_string(),\n    ///     \"2018-01-12 00:00:00 UTC\"\n    /// );\n    /// ```\n    fn duration_round(self, duration: Duration) -> Result<Self, Self::Err>;\n\n    /// Return a copy truncated by Duration.\n    ///\n    /// # Example\n    /// ``` rust\n    /// # use chrono::{DurationRound, Duration, Utc, NaiveDate};\n    /// let dt = NaiveDate::from_ymd_opt(2018, 1, 11).unwrap().and_hms_milli_opt(12, 0, 0, 154).unwrap().and_local_timezone(Utc).unwrap();\n    /// assert_eq!(\n    ///     dt.duration_trunc(Duration::milliseconds(10)).unwrap().to_string(),\n    ///     \"2018-01-11 12:00:00.150 UTC\"\n    /// );\n    /// assert_eq!(\n    ///     dt.duration_trunc(Duration::days(1)).unwrap().to_string(),\n    ///     \"2018-01-11 00:00:00 UTC\"\n    /// );\n    /// ```\n    fn duration_trunc(self, duration: Duration) -> Result<Self, Self::Err>;\n}","Real(LocalPath(\"src/round.rs\"))"],"round::RoundingError":["/// An error from rounding by `Duration`\n///\n/// See: [`DurationRound`]\npub enum RoundingError {\n    /// Error when the Duration exceeds the Duration from or until the Unix epoch.\n    ///\n    /// ``` rust\n    /// # use chrono::{DurationRound, Duration, RoundingError, TimeZone, Utc};\n    /// let dt = Utc.with_ymd_and_hms(1970, 12, 12, 0, 0, 0).unwrap();\n    ///\n    /// assert_eq!(\n    ///     dt.duration_round(Duration::days(365)),\n    ///     Err(RoundingError::DurationExceedsTimestamp),\n    /// );\n    /// ```\n    DurationExceedsTimestamp,\n\n    /// Error when `Duration.num_nanoseconds` exceeds the limit.\n    ///\n    /// ``` rust\n    /// # use chrono::{DurationRound, Duration, RoundingError, Utc, NaiveDate};\n    /// let dt = NaiveDate::from_ymd_opt(2260, 12, 31).unwrap().and_hms_nano_opt(23, 59, 59, 1_75_500_000).unwrap().and_local_timezone(Utc).unwrap();\n    ///\n    /// assert_eq!(\n    ///     dt.duration_round(Duration::days(300 * 365)),\n    ///     Err(RoundingError::DurationExceedsLimit)\n    /// );\n    /// ```\n    DurationExceedsLimit,\n\n    /// Error when `DateTime.timestamp_nanos` exceeds the limit.\n    ///\n    /// ``` rust\n    /// # use chrono::{DurationRound, Duration, RoundingError, TimeZone, Utc};\n    /// let dt = Utc.with_ymd_and_hms(2300, 12, 12, 0, 0, 0).unwrap();\n    ///\n    /// assert_eq!(dt.duration_round(Duration::days(1)), Err(RoundingError::TimestampExceedsLimit),);\n    /// ```\n    TimestampExceedsLimit,\n}","Real(LocalPath(\"src/round.rs\"))"],"round::SubsecRound":["/// Extension trait for subsecond rounding or truncation to a maximum number\n/// of digits. Rounding can be used to decrease the error variance when\n/// serializing/persisting to lower precision. Truncation is the default\n/// behavior in Chrono display formatting.  Either can be used to guarantee\n/// equality (e.g. for testing) when round-tripping through a lower precision\n/// format.\npub trait SubsecRound {\n    /// Return a copy rounded to the specified number of subsecond digits. With\n    /// 9 or more digits, self is returned unmodified. Halfway values are\n    /// rounded up (away from zero).\n    ///\n    /// # Example\n    /// ``` rust\n    /// # use chrono::{SubsecRound, Timelike, Utc, NaiveDate};\n    /// let dt = NaiveDate::from_ymd_opt(2018, 1, 11).unwrap().and_hms_milli_opt(12, 0, 0, 154).unwrap().and_local_timezone(Utc).unwrap();\n    /// assert_eq!(dt.round_subsecs(2).nanosecond(), 150_000_000);\n    /// assert_eq!(dt.round_subsecs(1).nanosecond(), 200_000_000);\n    /// ```\n    fn round_subsecs(self, digits: u16) -> Self;\n\n    /// Return a copy truncated to the specified number of subsecond\n    /// digits. With 9 or more digits, self is returned unmodified.\n    ///\n    /// # Example\n    /// ``` rust\n    /// # use chrono::{SubsecRound, Timelike, Utc, NaiveDate};\n    /// let dt = NaiveDate::from_ymd_opt(2018, 1, 11).unwrap().and_hms_milli_opt(12, 0, 0, 154).unwrap().and_local_timezone(Utc).unwrap();\n    /// assert_eq!(dt.trunc_subsecs(2).nanosecond(), 150_000_000);\n    /// assert_eq!(dt.trunc_subsecs(1).nanosecond(), 100_000_000);\n    /// ```\n    fn trunc_subsecs(self, digits: u16) -> Self;\n}","Real(LocalPath(\"src/round.rs\"))"],"round::duration_round":["fn duration_round<T>(\n    naive: NaiveDateTime,\n    original: T,\n    duration: Duration,\n) -> Result<T, RoundingError>\nwhere\n    T: Timelike + Add<Duration, Output = T> + Sub<Duration, Output = T>,{\n    if let Some(span) = duration.num_nanoseconds() {\n        if naive.timestamp().abs() > MAX_SECONDS_TIMESTAMP_FOR_NANOS {\n            return Err(RoundingError::TimestampExceedsLimit);\n        }\n        let stamp = naive.timestamp_nanos();\n        if span > stamp.abs() {\n            return Err(RoundingError::DurationExceedsTimestamp);\n        }\n        if span == 0 {\n            return Ok(original);\n        }\n        let delta_down = stamp % span;\n        if delta_down == 0 {\n            Ok(original)\n        } else {\n            let (delta_up, delta_down) = if delta_down < 0 {\n                (delta_down.abs(), span - delta_down.abs())\n            } else {\n                (span - delta_down, delta_down)\n            };\n            if delta_up <= delta_down {\n                Ok(original + Duration::nanoseconds(delta_up))\n            } else {\n                Ok(original - Duration::nanoseconds(delta_down))\n            }\n        }\n    } else {\n        Err(RoundingError::DurationExceedsLimit)\n    }\n}","Real(LocalPath(\"src/round.rs\"))"],"round::duration_trunc":["fn duration_trunc<T>(\n    naive: NaiveDateTime,\n    original: T,\n    duration: Duration,\n) -> Result<T, RoundingError>\nwhere\n    T: Timelike + Add<Duration, Output = T> + Sub<Duration, Output = T>,{\n    if let Some(span) = duration.num_nanoseconds() {\n        if naive.timestamp().abs() > MAX_SECONDS_TIMESTAMP_FOR_NANOS {\n            return Err(RoundingError::TimestampExceedsLimit);\n        }\n        let stamp = naive.timestamp_nanos();\n        if span > stamp.abs() {\n            return Err(RoundingError::DurationExceedsTimestamp);\n        }\n        let delta_down = stamp % span;\n        match delta_down.cmp(&0) {\n            Ordering::Equal => Ok(original),\n            Ordering::Greater => Ok(original - Duration::nanoseconds(delta_down)),\n            Ordering::Less => Ok(original - Duration::nanoseconds(span - delta_down.abs())),\n        }\n    } else {\n        Err(RoundingError::DurationExceedsLimit)\n    }\n}","Real(LocalPath(\"src/round.rs\"))"],"round::span_for_digits":["const fn span_for_digits(digits: u16) -> u32{\n    // fast lookup form of: 10^(9-min(9,digits))\n    match digits {\n        0 => 1_000_000_000,\n        1 => 100_000_000,\n        2 => 10_000_000,\n        3 => 1_000_000,\n        4 => 100_000,\n        5 => 10_000,\n        6 => 1_000,\n        7 => 100,\n        8 => 10,\n        _ => 1,\n    }\n}","Real(LocalPath(\"src/round.rs\"))"],"traits::Datelike":["/// The common set of methods for date component.\npub trait Datelike: Sized {\n    /// Returns the year number in the [calendar date](./naive/struct.NaiveDate.html#calendar-date).\n    fn year(&self) -> i32;\n\n    /// Returns the absolute year number starting from 1 with a boolean flag,\n    /// which is false when the year predates the epoch (BCE/BC) and true otherwise (CE/AD).\n    #[inline]\n    fn year_ce(&self) -> (bool, u32) {\n        let year = self.year();\n        if year < 1 {\n            (false, (1 - year) as u32)\n        } else {\n            (true, year as u32)\n        }\n    }\n\n    /// Returns the month number starting from 1.\n    ///\n    /// The return value ranges from 1 to 12.\n    fn month(&self) -> u32;\n\n    /// Returns the month number starting from 0.\n    ///\n    /// The return value ranges from 0 to 11.\n    fn month0(&self) -> u32;\n\n    /// Returns the day of month starting from 1.\n    ///\n    /// The return value ranges from 1 to 31. (The last day of month differs by months.)\n    fn day(&self) -> u32;\n\n    /// Returns the day of month starting from 0.\n    ///\n    /// The return value ranges from 0 to 30. (The last day of month differs by months.)\n    fn day0(&self) -> u32;\n\n    /// Returns the day of year starting from 1.\n    ///\n    /// The return value ranges from 1 to 366. (The last day of year differs by years.)\n    fn ordinal(&self) -> u32;\n\n    /// Returns the day of year starting from 0.\n    ///\n    /// The return value ranges from 0 to 365. (The last day of year differs by years.)\n    fn ordinal0(&self) -> u32;\n\n    /// Returns the day of week.\n    fn weekday(&self) -> Weekday;\n\n    /// Returns the ISO week.\n    fn iso_week(&self) -> IsoWeek;\n\n    /// Makes a new value with the year number changed.\n    ///\n    /// Returns `None` when the resulting value would be invalid.\n    fn with_year(&self, year: i32) -> Option<Self>;\n\n    /// Makes a new value with the month number (starting from 1) changed.\n    ///\n    /// Returns `None` when the resulting value would be invalid.\n    fn with_month(&self, month: u32) -> Option<Self>;\n\n    /// Makes a new value with the month number (starting from 0) changed.\n    ///\n    /// Returns `None` when the resulting value would be invalid.\n    fn with_month0(&self, month0: u32) -> Option<Self>;\n\n    /// Makes a new value with the day of month (starting from 1) changed.\n    ///\n    /// Returns `None` when the resulting value would be invalid.\n    fn with_day(&self, day: u32) -> Option<Self>;\n\n    /// Makes a new value with the day of month (starting from 0) changed.\n    ///\n    /// Returns `None` when the resulting value would be invalid.\n    fn with_day0(&self, day0: u32) -> Option<Self>;\n\n    /// Makes a new value with the day of year (starting from 1) changed.\n    ///\n    /// Returns `None` when the resulting value would be invalid.\n    fn with_ordinal(&self, ordinal: u32) -> Option<Self>;\n\n    /// Makes a new value with the day of year (starting from 0) changed.\n    ///\n    /// Returns `None` when the resulting value would be invalid.\n    fn with_ordinal0(&self, ordinal0: u32) -> Option<Self>;\n\n    /// Counts the days in the proleptic Gregorian calendar, with January 1, Year 1 (CE) as day 1.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use chrono::{NaiveDate, Datelike};\n    ///\n    /// assert_eq!(NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().num_days_from_ce(), 719_163);\n    /// assert_eq!(NaiveDate::from_ymd_opt(2, 1, 1).unwrap().num_days_from_ce(), 366);\n    /// assert_eq!(NaiveDate::from_ymd_opt(1, 1, 1).unwrap().num_days_from_ce(), 1);\n    /// assert_eq!(NaiveDate::from_ymd_opt(0, 1, 1).unwrap().num_days_from_ce(), -365);\n    /// ```\n    fn num_days_from_ce(&self) -> i32 {\n        // See test_num_days_from_ce_against_alternative_impl below for a more straightforward\n        // implementation.\n\n        // we know this wouldn't overflow since year is limited to 1/2^13 of i32's full range.\n        let mut year = self.year() - 1;\n        let mut ndays = 0;\n        if year < 0 {\n            let excess = 1 + (-year) / 400;\n            year += excess * 400;\n            ndays -= excess * 146_097;\n        }\n        let div_100 = year / 100;\n        ndays += ((year * 1461) >> 2) - div_100 + (div_100 >> 2);\n        ndays + self.ordinal() as i32\n    }\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::Datelike::num_days_from_ce":["/// Counts the days in the proleptic Gregorian calendar, with January 1, Year 1 (CE) as day 1.\n///\n/// # Examples\n///\n/// ```\n/// use chrono::{NaiveDate, Datelike};\n///\n/// assert_eq!(NaiveDate::from_ymd_opt(1970, 1, 1).unwrap().num_days_from_ce(), 719_163);\n/// assert_eq!(NaiveDate::from_ymd_opt(2, 1, 1).unwrap().num_days_from_ce(), 366);\n/// assert_eq!(NaiveDate::from_ymd_opt(1, 1, 1).unwrap().num_days_from_ce(), 1);\n/// assert_eq!(NaiveDate::from_ymd_opt(0, 1, 1).unwrap().num_days_from_ce(), -365);\n/// ```\nfn num_days_from_ce(&self) -> i32{\n        // See test_num_days_from_ce_against_alternative_impl below for a more straightforward\n        // implementation.\n\n        // we know this wouldn't overflow since year is limited to 1/2^13 of i32's full range.\n        let mut year = self.year() - 1;\n        let mut ndays = 0;\n        if year < 0 {\n            let excess = 1 + (-year) / 400;\n            year += excess * 400;\n            ndays -= excess * 146_097;\n        }\n        let div_100 = year / 100;\n        ndays += ((year * 1461) >> 2) - div_100 + (div_100 >> 2);\n        ndays + self.ordinal() as i32\n    }","Real(LocalPath(\"src/traits.rs\"))"],"traits::Datelike::year_ce":["/// Returns the absolute year number starting from 1 with a boolean flag,\n/// which is false when the year predates the epoch (BCE/BC) and true otherwise (CE/AD).\n#[inline]\nfn year_ce(&self) -> (bool, u32){\n        let year = self.year();\n        if year < 1 {\n            (false, (1 - year) as u32)\n        } else {\n            (true, year as u32)\n        }\n    }","Real(LocalPath(\"src/traits.rs\"))"],"traits::Timelike":["/// The common set of methods for time component.\npub trait Timelike: Sized {\n    /// Returns the hour number from 0 to 23.\n    fn hour(&self) -> u32;\n\n    /// Returns the hour number from 1 to 12 with a boolean flag,\n    /// which is false for AM and true for PM.\n    #[inline]\n    fn hour12(&self) -> (bool, u32) {\n        let hour = self.hour();\n        let mut hour12 = hour % 12;\n        if hour12 == 0 {\n            hour12 = 12;\n        }\n        (hour >= 12, hour12)\n    }\n\n    /// Returns the minute number from 0 to 59.\n    fn minute(&self) -> u32;\n\n    /// Returns the second number from 0 to 59.\n    fn second(&self) -> u32;\n\n    /// Returns the number of nanoseconds since the whole non-leap second.\n    /// The range from 1,000,000,000 to 1,999,999,999 represents\n    /// the [leap second](./naive/struct.NaiveTime.html#leap-second-handling).\n    fn nanosecond(&self) -> u32;\n\n    /// Makes a new value with the hour number changed.\n    ///\n    /// Returns `None` when the resulting value would be invalid.\n    fn with_hour(&self, hour: u32) -> Option<Self>;\n\n    /// Makes a new value with the minute number changed.\n    ///\n    /// Returns `None` when the resulting value would be invalid.\n    fn with_minute(&self, min: u32) -> Option<Self>;\n\n    /// Makes a new value with the second number changed.\n    ///\n    /// Returns `None` when the resulting value would be invalid.\n    /// As with the [`second`](#tymethod.second) method,\n    /// the input range is restricted to 0 through 59.\n    fn with_second(&self, sec: u32) -> Option<Self>;\n\n    /// Makes a new value with nanoseconds since the whole non-leap second changed.\n    ///\n    /// Returns `None` when the resulting value would be invalid.\n    /// As with the [`nanosecond`](#tymethod.nanosecond) method,\n    /// the input range can exceed 1,000,000,000 for leap seconds.\n    fn with_nanosecond(&self, nano: u32) -> Option<Self>;\n\n    /// Returns the number of non-leap seconds past the last midnight.\n    #[inline]\n    fn num_seconds_from_midnight(&self) -> u32 {\n        self.hour() * 3600 + self.minute() * 60 + self.second()\n    }\n}","Real(LocalPath(\"src/traits.rs\"))"],"traits::Timelike::hour12":["/// Returns the hour number from 1 to 12 with a boolean flag,\n/// which is false for AM and true for PM.\n#[inline]\nfn hour12(&self) -> (bool, u32){\n        let hour = self.hour();\n        let mut hour12 = hour % 12;\n        if hour12 == 0 {\n            hour12 = 12;\n        }\n        (hour >= 12, hour12)\n    }","Real(LocalPath(\"src/traits.rs\"))"],"traits::Timelike::num_seconds_from_midnight":["/// Returns the number of non-leap seconds past the last midnight.\n#[inline]\nfn num_seconds_from_midnight(&self) -> u32{\n        self.hour() * 3600 + self.minute() * 60 + self.second()\n    }","Real(LocalPath(\"src/traits.rs\"))"],"weekday::ParseWeekdayError":["/// An error resulting from reading `Weekday` value with `FromStr`.\npub struct ParseWeekdayError {\n    pub(crate) _dummy: (),\n}","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday":["/// The day of week.\n///\n/// The order of the days of week depends on the context.\n/// (This is why this type does *not* implement `PartialOrd` or `Ord` traits.)\n/// One should prefer `*_from_monday` or `*_from_sunday` methods to get the correct result.\n///\n/// # Example\n/// ```\n/// use chrono::Weekday;\n/// use std::convert::TryFrom;\n///\n/// let monday = \"Monday\".parse::<Weekday>().unwrap();\n/// assert_eq!(monday, Weekday::Mon);\n///\n/// let sunday = Weekday::try_from(6).unwrap();\n/// assert_eq!(sunday, Weekday::Sun);\n///\n/// assert_eq!(sunday.num_days_from_monday(), 6); // starts counting with Monday = 0\n/// assert_eq!(sunday.number_from_monday(), 7); // starts counting with Monday = 1\n/// assert_eq!(sunday.num_days_from_sunday(), 0); // starts counting with Sunday = 0\n/// assert_eq!(sunday.number_from_sunday(), 1); // starts counting with Sunday = 1\n///\n/// assert_eq!(sunday.succ(), monday);\n/// assert_eq!(sunday.pred(), Weekday::Sat);\n/// ```\npub enum Weekday {\n    /// Monday.\n    Mon = 0,\n    /// Tuesday.\n    Tue = 1,\n    /// Wednesday.\n    Wed = 2,\n    /// Thursday.\n    Thu = 3,\n    /// Friday.\n    Fri = 4,\n    /// Saturday.\n    Sat = 5,\n    /// Sunday.\n    Sun = 6,\n}","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::num_days_from":["/// Returns a day-of-week number starting from the parameter `day` (D) = 0.\n///\n/// `w`:                        | `D`   | `D+1` | `D+2` | `D+3` | `D+4` | `D+5` | `D+6`\n/// --------------------------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n/// `w.num_days_from(wd)`:      | 0     | 1     | 2     | 3     | 4     | 5     | 6\n#[inline]\npub(crate) const fn num_days_from(&self, day: Weekday) -> u32{\n        (*self as u32 + 7 - day as u32) % 7\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::num_days_from_monday":["/// Returns a day-of-week number starting from Monday = 0.\n///\n/// `w`:                        | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun`\n/// --------------------------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n/// `w.num_days_from_monday()`: | 0     | 1     | 2     | 3     | 4     | 5     | 6\n#[inline]\npub const fn num_days_from_monday(&self) -> u32{\n        self.num_days_from(Weekday::Mon)\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::num_days_from_sunday":["/// Returns a day-of-week number starting from Sunday = 0.\n///\n/// `w`:                        | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun`\n/// --------------------------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n/// `w.num_days_from_sunday()`: | 1     | 2     | 3     | 4     | 5     | 6     | 0\n#[inline]\npub const fn num_days_from_sunday(&self) -> u32{\n        self.num_days_from(Weekday::Sun)\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::number_from_monday":["/// Returns a day-of-week number starting from Monday = 1. (ISO 8601 weekday number)\n///\n/// `w`:                      | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun`\n/// ------------------------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n/// `w.number_from_monday()`: | 1     | 2     | 3     | 4     | 5     | 6     | 7\n#[inline]\npub const fn number_from_monday(&self) -> u32{\n        self.num_days_from(Weekday::Mon) + 1\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::number_from_sunday":["/// Returns a day-of-week number starting from Sunday = 1.\n///\n/// `w`:                      | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun`\n/// ------------------------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n/// `w.number_from_sunday()`: | 2     | 3     | 4     | 5     | 6     | 7     | 1\n#[inline]\npub const fn number_from_sunday(&self) -> u32{\n        self.num_days_from(Weekday::Sun) + 1\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::pred":["/// The previous day in the week.\n///\n/// `w`:        | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun`\n/// ----------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n/// `w.pred()`: | `Sun` | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat`\n#[inline]\n#[must_use]\npub const fn pred(&self) -> Weekday{\n        match *self {\n            Weekday::Mon => Weekday::Sun,\n            Weekday::Tue => Weekday::Mon,\n            Weekday::Wed => Weekday::Tue,\n            Weekday::Thu => Weekday::Wed,\n            Weekday::Fri => Weekday::Thu,\n            Weekday::Sat => Weekday::Fri,\n            Weekday::Sun => Weekday::Sat,\n        }\n    }","Real(LocalPath(\"src/weekday.rs\"))"],"weekday::Weekday::succ":["/// The next day in the week.\n///\n/// `w`:        | `Mon` | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun`\n/// ----------- | ----- | ----- | ----- | ----- | ----- | ----- | -----\n/// `w.succ()`: | `Tue` | `Wed` | `Thu` | `Fri` | `Sat` | `Sun` | `Mon`\n#[inline]\n#[must_use]\npub const fn succ(&self) -> Weekday{\n        match *self {\n            Weekday::Mon => Weekday::Tue,\n            Weekday::Tue => Weekday::Wed,\n            Weekday::Wed => Weekday::Thu,\n            Weekday::Thu => Weekday::Fri,\n            Weekday::Fri => Weekday::Sat,\n            Weekday::Sat => Weekday::Sun,\n            Weekday::Sun => Weekday::Mon,\n        }\n    }","Real(LocalPath(\"src/weekday.rs\"))"]},"struct_constructor":{"&'a [u8]":["parse_name","read_exact","read_until","read_while","remaining"],"&'a offset::local::tz_info::timezone::LocalTimeType":["find_local_time_type"],"&'static str":["name"],"&<Tz as offset::TimeZone>::Offset":["offset"],"&[u8]":["as_bytes"],"&offset::local::tz_info::timezone::LocalTimeType":["find_local_time_type"],"&str":["as_ref","description"],"&u8":["peek"],"(&'a str, ())":["parse_rfc2822","parse_rfc3339"],"(&str, ())":["comment_2822","timezone_name_skip"],"(&str, i32)":["timezone_offset","timezone_offset_internal","timezone_offset_permissive","timezone_offset_zulu"],"(&str, i64)":["nanosecond","nanosecond_fixed","number"],"(&str, std::option::Option<i32>)":["timezone_offset_2822"],"(&str, u8)":["short_month0","short_or_long_month0"],"(&str, weekday::Weekday)":["short_or_long_weekday","short_weekday"],"(bool, u32)":["hour12","year_ce"],"(datetime::DateTime<offset::fixed::FixedOffset>, &'a str)":["parse_and_remainder"],"(i32, i32)":["div_mod_floor"],"(i32, i32, i32)":["parse_hhmmss"],"(i32, i32, i32, i32)":["parse_signed_hhmmss"],"(naive::date::NaiveDate, &'a str)":["parse_and_remainder"],"(naive::datetime::NaiveDateTime, &'a str)":["parse_and_remainder"],"(naive::time::NaiveTime, &'a str)":["parse_and_remainder"],"(naive::time::NaiveTime, i64)":["overflowing_add_signed","overflowing_sub_signed"],"(offset::local::tz_info::rule::RuleDay, i32)":["parse"],"(u32, u32)":["cycle_to_yo"],"(u32, u32, u32)":["hms"],"(u32, weekday::Weekday)":["isoweekdate_raw"],"(u8, u8)":["digits"],"(usize, i64)":["transition_date"],"(usize, std::option::Option<usize>)":["size_hint"],"<Self as offset::TimeZone>::Offset":["offset_from_utc_date","offset_from_utc_datetime"],"<datetime::DateTime<Tz> as std::ops::Add<month::Months>>::Output":["add"],"<datetime::DateTime<Tz> as std::ops::Add<naive::date::Days>>::Output":["add"],"<datetime::DateTime<Tz> as std::ops::Sub<month::Months>>::Output":["sub"],"<datetime::DateTime<Tz> as std::ops::Sub<naive::date::Days>>::Output":["sub"],"<naive::date::NaiveDate as std::ops::Add<month::Months>>::Output":["add"],"<naive::date::NaiveDate as std::ops::Add<naive::date::Days>>::Output":["add"],"<naive::date::NaiveDate as std::ops::Sub<month::Months>>::Output":["sub"],"<naive::date::NaiveDate as std::ops::Sub<naive::date::Days>>::Output":["sub"],"<naive::date::NaiveDateDaysIterator as std::iter::Iterator>::Item":["next","next_back"],"<naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::Item":["next","next_back"],"<naive::datetime::NaiveDateTime as std::ops::Add<month::Months>>::Output":["add"],"<naive::datetime::NaiveDateTime as std::ops::Add<naive::date::Days>>::Output":["add"],"<naive::datetime::NaiveDateTime as std::ops::Sub<month::Months>>::Output":["sub"],"<naive::datetime::NaiveDateTime as std::ops::Sub<naive::date::Days>>::Output":["sub"],"OutOfRange":["clone","new"],"bool":["eq","equal","equals","is_dst","is_empty","is_leap_year","read_optional_tag"],"date::Date":["clone","date","from_utc","from_utc_date","isoywd","map_local","pred","pred_opt","succ","succ_opt","today","with_day","with_day0","with_month","with_month0","with_ordinal","with_ordinal0","with_timezone","with_year","ymd","yo"],"datetime::DateTime":["and_hms","and_hms_micro","and_hms_micro_opt","and_hms_milli","and_hms_milli_opt","and_hms_nano","and_hms_nano_opt","and_hms_opt","and_time","and_utc","clone","datetime_from_str","default","fixed_offset","from","from_local","from_str","from_utc","from_utc_datetime","map_local","now","parse_from_rfc2822","parse_from_rfc3339","parse_from_str","timestamp","timestamp_millis","timestamp_nanos","to_datetime","to_datetime_with_timezone","with_day","with_day0","with_hour","with_minute","with_month","with_month0","with_nanosecond","with_ordinal","with_ordinal0","with_second","with_timezone","with_year"],"datetime::SecondsFormat":["clone"],"format::Colons":["clone"],"format::DelayedFormat":["format","format_with_items","new","new_with_offset"],"format::Fixed":["clone"],"format::InternalFixed":["clone"],"format::InternalInternal":["clone"],"format::InternalNumeric":["clone"],"format::Item":["clone","next"],"format::Locales":["new"],"format::Numeric":["clone"],"format::Pad":["clone"],"format::ParseError":["clone"],"format::ParseErrorKind":["clone","kind"],"format::Void":["clone"],"format::parsed::Parsed":["clone","default","new"],"format::strftime::StrftimeItems":["clone","new","with_remainer"],"i32":["local_minus_utc","num_days_from_ce","offset","parse_offset","parse_rule_time","parse_rule_time_extended","read_be_i32","utc_minus_local","weeks_from","year"],"i64":["parse_time","read_be_i64","timestamp","timestamp_micros","timestamp_millis","timestamp_nanos","unix_leap_time"],"month::Month":["clone","from_i64","from_str","from_u32","from_u64","pred","succ","try_from"],"month::Months":["clone","new"],"month::ParseMonthError":["clone"],"naive::date::Days":["clone","new"],"naive::date::NaiveDate":["clone","date","date_naive","default","first_day","from","from_isoywd","from_isoywd_opt","from_mdf","from_num_days_from_ce","from_num_days_from_ce_opt","from_ordinal_and_flags","from_str","from_weekday_of_month","from_weekday_of_month_opt","from_ymd","from_ymd_opt","from_yo","from_yo_opt","last_day","naive_local","naive_utc","parse_from_str","pred","pred_opt","succ","succ_opt","to_naive_date","with_day","with_day0","with_mdf","with_month","with_month0","with_of","with_ordinal","with_ordinal0","with_year"],"naive::date::NaiveDateDaysIterator":["clone","iter_days"],"naive::date::NaiveDateWeeksIterator":["clone","iter_weeks"],"naive::date::NaiveWeek":["week"],"naive::datetime::NaiveDateTime":["and_hms","and_hms_micro","and_hms_micro_opt","and_hms_milli","and_hms_milli_opt","and_hms_nano","and_hms_nano_opt","and_hms_opt","and_time","clone","default","from_str","from_timestamp","from_timestamp_micros","from_timestamp_millis","from_timestamp_opt","naive_local","naive_utc","new","parse_from_str","to_naive_datetime_with_offset","with_day","with_day0","with_hour","with_minute","with_month","with_month0","with_nanosecond","with_ordinal","with_ordinal0","with_second","with_year"],"naive::internals::Mdf":["clone","from_of","mdf","new","to_mdf","with_day","with_flags","with_month"],"naive::internals::Of":["clone","from_date_impl","from_mdf","new","of","pred","succ","to_of","with_ordinal"],"naive::internals::YearFlags":["clone","flags","from_year","from_year_mod_400"],"naive::isoweek::IsoWeek":["clone","iso_week","iso_week_from_yof"],"naive::time::NaiveTime":["clone","default","from_hms","from_hms_micro","from_hms_micro_opt","from_hms_milli","from_hms_milli_opt","from_hms_nano","from_hms_nano_opt","from_hms_opt","from_num_seconds_from_midnight","from_num_seconds_from_midnight_opt","from_str","parse_from_str","time","to_naive_time","with_hour","with_minute","with_nanosecond","with_second"],"offset::LocalResult":["and_local_timezone","clone","find_local_time_type_from_local","from_local_date","from_local_datetime","isoywd_opt","offset","offset_from_local_date","offset_from_local_datetime","offset_from_utc_datetime","timestamp_millis_opt","timestamp_opt","with_ymd_and_hms","ymd_opt","yo_opt"],"offset::fixed::FixedOffset":["clone","east","east_opt","fix","from_offset","offset_from_utc_date","offset_from_utc_datetime","to_fixed_offset","west","west_opt"],"offset::local::Local":["clone","from_offset"],"offset::local::inner::Cache":["default"],"offset::local::inner::Source":["new"],"offset::local::tz_info::Error":["from"],"offset::local::tz_info::parser::Cursor":["new"],"offset::local::tz_info::parser::Header":["new"],"offset::local::tz_info::parser::State":["new"],"offset::local::tz_info::parser::Version":["clone"],"offset::local::tz_info::rule::AlternateTime":["clone","new"],"offset::local::tz_info::rule::RuleDay":["clone","julian_0","julian_1","month_weekday"],"offset::local::tz_info::rule::TransitionRule":["clone","from","from_tz_string"],"offset::local::tz_info::rule::UtcDateTime":["clone","from_timespec"],"offset::local::tz_info::timezone::LeapSecond":["clone","new"],"offset::local::tz_info::timezone::LocalTimeType":["clone","new","with_offset"],"offset::local::tz_info::timezone::TimeZone":["clone","current_zone","fallback_timezone","fixed","from_file","from_posix_tz","from_tz_data","local","new","parse","utc"],"offset::local::tz_info::timezone::TimeZoneName":["clone","new"],"offset::local::tz_info::timezone::TimeZoneRef":["as_ref","clone"],"offset::local::tz_info::timezone::Transition":["clone","new"],"offset::utc::Utc":["clone","from_offset","offset_from_utc_date","offset_from_utc_datetime"],"oldtime::Duration":["signed_duration_since","sub"],"round::RoundingError":["clone"],"std::cell::RefCell":["__init"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::fs::File":["find_tz_file"],"std::ops::RangeInclusive":["days"],"std::string::String":["to_rfc2822","to_rfc3339","to_rfc3339_opts"],"std::time::SystemTime":["from"],"u32":["day","day0","hour","inner","isoweek_delta","minute","month","month0","nanosecond","ndays","nisoweeks","num_days_from","num_days_from_monday","num_days_from_sunday","num_seconds_from_midnight","number_from_monday","number_from_month","number_from_sunday","ol","ordinal","ordinal0","read_be_u32","second","span_for_digits","timestamp_subsec_micros","timestamp_subsec_millis","timestamp_subsec_nanos","week","week0","years_since"],"weekday::ParseWeekdayError":["clone"],"weekday::Weekday":["clone","from_i64","from_str","from_u64","pred","succ","try_from","weekday","weekday_from_u32_mod7"]},"struct_to_trait":{"<T as round::SubsecRound>::T":["round::SubsecRound"],"OutOfRange":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"date::Date":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::Send","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign","traits::Datelike"],"datetime::DateTime":["round::DurationRound","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::Send","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign","std::str::FromStr","traits::Datelike","traits::Timelike"],"datetime::SecondsFormat":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::Colons":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::DelayedFormat":["std::fmt::Debug","std::fmt::Display"],"format::Fixed":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::InternalFixed":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::InternalInternal":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::InternalNumeric":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::Item":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::Locale":["std::fmt::Debug"],"format::Numeric":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::Pad":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::ParseError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::ParseErrorKind":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::Void":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::parsed::Parsed":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"format::strftime::StrftimeItems":["std::clone::Clone","std::fmt::Debug","std::iter::Iterator"],"month::Month":["num_traits::FromPrimitive","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::TryFrom","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"],"month::Months":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"month::ParseMonthError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"naive::date::Days":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"naive::date::NaiveDate":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign","std::str::FromStr","traits::Datelike"],"naive::date::NaiveDateDaysIterator":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"naive::date::NaiveDateWeeksIterator":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::iter::DoubleEndedIterator","std::iter::ExactSizeIterator","std::iter::Iterator","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"naive::date::NaiveWeek":["std::fmt::Debug"],"naive::datetime::NaiveDateTime":["round::DurationRound","std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign","std::str::FromStr","traits::Datelike","traits::Timelike"],"naive::internals::Mdf":["std::clone::Clone","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"naive::internals::Of":["std::clone::Clone","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"naive::internals::YearFlags":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"naive::isoweek::IsoWeek":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"naive::time::NaiveTime":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::default::Default","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::ops::Add","std::ops::AddAssign","std::ops::Sub","std::ops::SubAssign","std::str::FromStr","traits::Timelike"],"offset::LocalResult":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::fixed::FixedOffset":["offset::Offset","offset::TimeZone","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::local::Local":["offset::TimeZone","std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"offset::local::inner::Cache":["std::default::Default"],"offset::local::tz_info::Error":["std::convert::From","std::error::Error","std::fmt::Debug","std::fmt::Display"],"offset::local::tz_info::parser::Cursor":["std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::local::tz_info::parser::Header":["std::fmt::Debug"],"offset::local::tz_info::parser::Version":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::local::tz_info::rule::AlternateTime":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::local::tz_info::rule::RuleDay":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::local::tz_info::rule::TransitionRule":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::local::tz_info::rule::UtcDateTime":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::local::tz_info::timezone::LeapSecond":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::local::tz_info::timezone::LocalTimeType":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::local::tz_info::timezone::TimeZone":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::local::tz_info::timezone::TimeZoneName":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::AsRef","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::local::tz_info::timezone::TimeZoneRef":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::local::tz_info::timezone::Transition":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"offset::utc::Utc":["offset::Offset","offset::TimeZone","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"round::RoundingError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"std::time::SystemTime":["std::convert::From"],"weekday::ParseWeekdayError":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralEq","std::marker::StructuralPartialEq"],"weekday::Weekday":["num_traits::FromPrimitive","std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::TryFrom","std::fmt::Debug","std::fmt::Display","std::hash::Hash","std::marker::Copy","std::marker::StructuralEq","std::marker::StructuralPartialEq","std::str::FromStr"]},"targets":{"<OutOfRange as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Debug"],"<OutOfRange as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/lib.rs\"))","std::fmt::Display"],"<T as round::SubsecRound>::round_subsecs":["round_subsecs","Real(LocalPath(\"src/round.rs\"))","round::SubsecRound"],"<T as round::SubsecRound>::trunc_subsecs":["trunc_subsecs","Real(LocalPath(\"src/round.rs\"))","round::SubsecRound"],"<date::Date<Tz> as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/date.rs\"))","std::cmp::Ord"],"<date::Date<Tz> as std::cmp::PartialEq<date::Date<Tz2>>>::eq":["eq","Real(LocalPath(\"src/date.rs\"))","std::cmp::PartialEq"],"<date::Date<Tz> as std::cmp::PartialOrd>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/date.rs\"))","std::cmp::PartialOrd"],"<date::Date<Tz> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/date.rs\"))","std::fmt::Debug"],"<date::Date<Tz> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/date.rs\"))","std::fmt::Display"],"<date::Date<Tz> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/date.rs\"))","std::hash::Hash"],"<date::Date<Tz> as std::ops::Add<oldtime::Duration>>::add":["add","Real(LocalPath(\"src/date.rs\"))","std::ops::Add"],"<date::Date<Tz> as std::ops::AddAssign<oldtime::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/date.rs\"))","std::ops::AddAssign"],"<date::Date<Tz> as std::ops::Sub<oldtime::Duration>>::sub":["sub","Real(LocalPath(\"src/date.rs\"))","std::ops::Sub"],"<date::Date<Tz> as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/date.rs\"))","std::ops::Sub"],"<date::Date<Tz> as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/date.rs\"))","std::ops::SubAssign"],"<date::Date<Tz> as traits::Datelike>::day":["day","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::day0":["day0","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::iso_week":["iso_week","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::month":["month","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::month0":["month0","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::ordinal":["ordinal","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::ordinal0":["ordinal0","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::weekday":["weekday","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::with_day":["with_day","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::with_day0":["with_day0","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::with_month":["with_month","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::with_month0":["with_month0","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::with_ordinal":["with_ordinal","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::with_ordinal0":["with_ordinal0","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::with_year":["with_year","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<date::Date<Tz> as traits::Datelike>::year":["year","Real(LocalPath(\"src/date.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as round::DurationRound>::duration_round":["duration_round","Real(LocalPath(\"src/round.rs\"))","round::DurationRound"],"<datetime::DateTime<Tz> as round::DurationRound>::duration_trunc":["duration_trunc","Real(LocalPath(\"src/round.rs\"))","round::DurationRound"],"<datetime::DateTime<Tz> as std::cmp::Ord>::cmp":["cmp","Real(LocalPath(\"src/datetime/mod.rs\"))","std::cmp::Ord"],"<datetime::DateTime<Tz> as std::cmp::PartialEq<datetime::DateTime<Tz2>>>::eq":["eq","Real(LocalPath(\"src/datetime/mod.rs\"))","std::cmp::PartialEq"],"<datetime::DateTime<Tz> as std::cmp::PartialOrd<datetime::DateTime<Tz2>>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/datetime/mod.rs\"))","std::cmp::PartialOrd"],"<datetime::DateTime<Tz> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/datetime/mod.rs\"))","std::fmt::Debug"],"<datetime::DateTime<Tz> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/datetime/mod.rs\"))","std::fmt::Display"],"<datetime::DateTime<Tz> as std::hash::Hash>::hash":["hash","Real(LocalPath(\"src/datetime/mod.rs\"))","std::hash::Hash"],"<datetime::DateTime<Tz> as std::ops::Add<month::Months>>::add":["add","Real(LocalPath(\"src/datetime/mod.rs\"))","std::ops::Add"],"<datetime::DateTime<Tz> as std::ops::Add<naive::date::Days>>::add":["add","Real(LocalPath(\"src/datetime/mod.rs\"))","std::ops::Add"],"<datetime::DateTime<Tz> as std::ops::Add<oldtime::Duration>>::add":["add","Real(LocalPath(\"src/datetime/mod.rs\"))","std::ops::Add"],"<datetime::DateTime<Tz> as std::ops::AddAssign<oldtime::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/datetime/mod.rs\"))","std::ops::AddAssign"],"<datetime::DateTime<Tz> as std::ops::Sub<month::Months>>::sub":["sub","Real(LocalPath(\"src/datetime/mod.rs\"))","std::ops::Sub"],"<datetime::DateTime<Tz> as std::ops::Sub<naive::date::Days>>::sub":["sub","Real(LocalPath(\"src/datetime/mod.rs\"))","std::ops::Sub"],"<datetime::DateTime<Tz> as std::ops::Sub<oldtime::Duration>>::sub":["sub","Real(LocalPath(\"src/datetime/mod.rs\"))","std::ops::Sub"],"<datetime::DateTime<Tz> as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/datetime/mod.rs\"))","std::ops::Sub"],"<datetime::DateTime<Tz> as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/datetime/mod.rs\"))","std::ops::SubAssign"],"<datetime::DateTime<Tz> as traits::Datelike>::day":["day","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::day0":["day0","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::iso_week":["iso_week","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::month":["month","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::month0":["month0","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::ordinal":["ordinal","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::ordinal0":["ordinal0","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::weekday":["weekday","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::with_day":["with_day","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::with_day0":["with_day0","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::with_month":["with_month","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::with_month0":["with_month0","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal":["with_ordinal","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::with_ordinal0":["with_ordinal0","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::with_year":["with_year","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Datelike>::year":["year","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Datelike"],"<datetime::DateTime<Tz> as traits::Timelike>::hour":["hour","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Timelike"],"<datetime::DateTime<Tz> as traits::Timelike>::minute":["minute","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Timelike"],"<datetime::DateTime<Tz> as traits::Timelike>::nanosecond":["nanosecond","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Timelike"],"<datetime::DateTime<Tz> as traits::Timelike>::second":["second","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Timelike"],"<datetime::DateTime<Tz> as traits::Timelike>::with_hour":["with_hour","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Timelike"],"<datetime::DateTime<Tz> as traits::Timelike>::with_minute":["with_minute","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Timelike"],"<datetime::DateTime<Tz> as traits::Timelike>::with_nanosecond":["with_nanosecond","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Timelike"],"<datetime::DateTime<Tz> as traits::Timelike>::with_second":["with_second","Real(LocalPath(\"src/datetime/mod.rs\"))","traits::Timelike"],"<datetime::DateTime<offset::fixed::FixedOffset> as std::convert::From<datetime::DateTime<offset::local::Local>>>::from":["from","Real(LocalPath(\"src/datetime/mod.rs\"))","std::convert::From"],"<datetime::DateTime<offset::fixed::FixedOffset> as std::convert::From<datetime::DateTime<offset::utc::Utc>>>::from":["from","Real(LocalPath(\"src/datetime/mod.rs\"))","std::convert::From"],"<datetime::DateTime<offset::fixed::FixedOffset> as std::default::Default>::default":["default","Real(LocalPath(\"src/datetime/mod.rs\"))","std::default::Default"],"<datetime::DateTime<offset::local::Local> as std::convert::From<datetime::DateTime<offset::fixed::FixedOffset>>>::from":["from","Real(LocalPath(\"src/datetime/mod.rs\"))","std::convert::From"],"<datetime::DateTime<offset::local::Local> as std::convert::From<datetime::DateTime<offset::utc::Utc>>>::from":["from","Real(LocalPath(\"src/datetime/mod.rs\"))","std::convert::From"],"<datetime::DateTime<offset::local::Local> as std::convert::From<std::time::SystemTime>>::from":["from","Real(LocalPath(\"src/datetime/mod.rs\"))","std::convert::From"],"<datetime::DateTime<offset::local::Local> as std::default::Default>::default":["default","Real(LocalPath(\"src/datetime/mod.rs\"))","std::default::Default"],"<datetime::DateTime<offset::local::Local> as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/datetime/mod.rs\"))","std::str::FromStr"],"<datetime::DateTime<offset::utc::Utc> as std::convert::From<datetime::DateTime<offset::fixed::FixedOffset>>>::from":["from","Real(LocalPath(\"src/datetime/mod.rs\"))","std::convert::From"],"<datetime::DateTime<offset::utc::Utc> as std::convert::From<datetime::DateTime<offset::local::Local>>>::from":["from","Real(LocalPath(\"src/datetime/mod.rs\"))","std::convert::From"],"<datetime::DateTime<offset::utc::Utc> as std::convert::From<std::time::SystemTime>>::from":["from","Real(LocalPath(\"src/datetime/mod.rs\"))","std::convert::From"],"<datetime::DateTime<offset::utc::Utc> as std::default::Default>::default":["default","Real(LocalPath(\"src/datetime/mod.rs\"))","std::default::Default"],"<datetime::DateTime<offset::utc::Utc> as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/datetime/mod.rs\"))","std::str::FromStr"],"<format::DelayedFormat<I> as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/format/mod.rs\"))","std::fmt::Display"],"<format::InternalNumeric as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/format/mod.rs\"))","std::fmt::Debug"],"<format::ParseError as std::error::Error>::description":["description","Real(LocalPath(\"src/format/mod.rs\"))","std::error::Error"],"<format::ParseError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/format/mod.rs\"))","std::fmt::Display"],"<format::strftime::StrftimeItems<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/format/strftime.rs\"))","std::iter::Iterator"],"<month::Month as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/month.rs\"))","num_traits::FromPrimitive"],"<month::Month as num_traits::FromPrimitive>::from_u32":["from_u32","Real(LocalPath(\"src/month.rs\"))","num_traits::FromPrimitive"],"<month::Month as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/month.rs\"))","num_traits::FromPrimitive"],"<month::Month as std::convert::TryFrom<u8>>::try_from":["try_from","Real(LocalPath(\"src/month.rs\"))","std::convert::TryFrom"],"<month::ParseMonthError as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/month.rs\"))","std::fmt::Debug"],"<naive::date::NaiveDate as std::convert::From<naive::datetime::NaiveDateTime>>::from":["from","Real(LocalPath(\"src/naive/date.rs\"))","std::convert::From"],"<naive::date::NaiveDate as std::default::Default>::default":["default","Real(LocalPath(\"src/naive/date.rs\"))","std::default::Default"],"<naive::date::NaiveDate as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/naive/date.rs\"))","std::fmt::Debug"],"<naive::date::NaiveDate as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/naive/date.rs\"))","std::fmt::Display"],"<naive::date::NaiveDate as std::ops::Add<month::Months>>::add":["add","Real(LocalPath(\"src/naive/date.rs\"))","std::ops::Add"],"<naive::date::NaiveDate as std::ops::Add<naive::date::Days>>::add":["add","Real(LocalPath(\"src/naive/date.rs\"))","std::ops::Add"],"<naive::date::NaiveDate as std::ops::Add<oldtime::Duration>>::add":["add","Real(LocalPath(\"src/naive/date.rs\"))","std::ops::Add"],"<naive::date::NaiveDate as std::ops::AddAssign<oldtime::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/naive/date.rs\"))","std::ops::AddAssign"],"<naive::date::NaiveDate as std::ops::Sub<month::Months>>::sub":["sub","Real(LocalPath(\"src/naive/date.rs\"))","std::ops::Sub"],"<naive::date::NaiveDate as std::ops::Sub<naive::date::Days>>::sub":["sub","Real(LocalPath(\"src/naive/date.rs\"))","std::ops::Sub"],"<naive::date::NaiveDate as std::ops::Sub<oldtime::Duration>>::sub":["sub","Real(LocalPath(\"src/naive/date.rs\"))","std::ops::Sub"],"<naive::date::NaiveDate as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/naive/date.rs\"))","std::ops::Sub"],"<naive::date::NaiveDate as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/naive/date.rs\"))","std::ops::SubAssign"],"<naive::date::NaiveDate as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/naive/date.rs\"))","std::str::FromStr"],"<naive::date::NaiveDate as traits::Datelike>::day":["day","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::day0":["day0","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::iso_week":["iso_week","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::month":["month","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::month0":["month0","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::ordinal":["ordinal","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::ordinal0":["ordinal0","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::weekday":["weekday","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::with_day":["with_day","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::with_day0":["with_day0","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::with_month":["with_month","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::with_month0":["with_month0","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::with_ordinal":["with_ordinal","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::with_ordinal0":["with_ordinal0","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::with_year":["with_year","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDate as traits::Datelike>::year":["year","Real(LocalPath(\"src/naive/date.rs\"))","traits::Datelike"],"<naive::date::NaiveDateDaysIterator as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/naive/date.rs\"))","std::iter::DoubleEndedIterator"],"<naive::date::NaiveDateDaysIterator as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/naive/date.rs\"))","std::iter::Iterator"],"<naive::date::NaiveDateDaysIterator as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/naive/date.rs\"))","std::iter::Iterator"],"<naive::date::NaiveDateWeeksIterator as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/naive/date.rs\"))","std::iter::DoubleEndedIterator"],"<naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/naive/date.rs\"))","std::iter::Iterator"],"<naive::date::NaiveDateWeeksIterator as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/naive/date.rs\"))","std::iter::Iterator"],"<naive::datetime::NaiveDateTime as round::DurationRound>::duration_round":["duration_round","Real(LocalPath(\"src/round.rs\"))","round::DurationRound"],"<naive::datetime::NaiveDateTime as round::DurationRound>::duration_trunc":["duration_trunc","Real(LocalPath(\"src/round.rs\"))","round::DurationRound"],"<naive::datetime::NaiveDateTime as std::default::Default>::default":["default","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::default::Default"],"<naive::datetime::NaiveDateTime as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::fmt::Debug"],"<naive::datetime::NaiveDateTime as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::fmt::Display"],"<naive::datetime::NaiveDateTime as std::ops::Add<month::Months>>::add":["add","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::ops::Add"],"<naive::datetime::NaiveDateTime as std::ops::Add<naive::date::Days>>::add":["add","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::ops::Add"],"<naive::datetime::NaiveDateTime as std::ops::Add<oldtime::Duration>>::add":["add","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::ops::Add"],"<naive::datetime::NaiveDateTime as std::ops::AddAssign<oldtime::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::ops::AddAssign"],"<naive::datetime::NaiveDateTime as std::ops::Sub<month::Months>>::sub":["sub","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::ops::Sub"],"<naive::datetime::NaiveDateTime as std::ops::Sub<naive::date::Days>>::sub":["sub","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::ops::Sub"],"<naive::datetime::NaiveDateTime as std::ops::Sub<oldtime::Duration>>::sub":["sub","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::ops::Sub"],"<naive::datetime::NaiveDateTime as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::ops::Sub"],"<naive::datetime::NaiveDateTime as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::ops::SubAssign"],"<naive::datetime::NaiveDateTime as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","std::str::FromStr"],"<naive::datetime::NaiveDateTime as traits::Datelike>::day":["day","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::day0":["day0","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::iso_week":["iso_week","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::month":["month","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::month0":["month0","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::ordinal":["ordinal","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::ordinal0":["ordinal0","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::weekday":["weekday","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_day":["with_day","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_day0":["with_day0","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_month":["with_month","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_month0":["with_month0","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_ordinal":["with_ordinal","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_ordinal0":["with_ordinal0","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::with_year":["with_year","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Datelike>::year":["year","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Datelike"],"<naive::datetime::NaiveDateTime as traits::Timelike>::hour":["hour","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Timelike"],"<naive::datetime::NaiveDateTime as traits::Timelike>::minute":["minute","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Timelike"],"<naive::datetime::NaiveDateTime as traits::Timelike>::nanosecond":["nanosecond","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Timelike"],"<naive::datetime::NaiveDateTime as traits::Timelike>::second":["second","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Timelike"],"<naive::datetime::NaiveDateTime as traits::Timelike>::with_hour":["with_hour","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Timelike"],"<naive::datetime::NaiveDateTime as traits::Timelike>::with_minute":["with_minute","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Timelike"],"<naive::datetime::NaiveDateTime as traits::Timelike>::with_nanosecond":["with_nanosecond","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Timelike"],"<naive::datetime::NaiveDateTime as traits::Timelike>::with_second":["with_second","Real(LocalPath(\"src/naive/datetime/mod.rs\"))","traits::Timelike"],"<naive::internals::Mdf as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/naive/internals.rs\"))","std::fmt::Debug"],"<naive::internals::Of as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/naive/internals.rs\"))","std::fmt::Debug"],"<naive::internals::YearFlags as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/naive/internals.rs\"))","std::fmt::Debug"],"<naive::isoweek::IsoWeek as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/naive/isoweek.rs\"))","std::fmt::Debug"],"<naive::time::NaiveTime as std::default::Default>::default":["default","Real(LocalPath(\"src/naive/time/mod.rs\"))","std::default::Default"],"<naive::time::NaiveTime as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/naive/time/mod.rs\"))","std::fmt::Debug"],"<naive::time::NaiveTime as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/naive/time/mod.rs\"))","std::fmt::Display"],"<naive::time::NaiveTime as std::ops::Add<oldtime::Duration>>::add":["add","Real(LocalPath(\"src/naive/time/mod.rs\"))","std::ops::Add"],"<naive::time::NaiveTime as std::ops::AddAssign<oldtime::Duration>>::add_assign":["add_assign","Real(LocalPath(\"src/naive/time/mod.rs\"))","std::ops::AddAssign"],"<naive::time::NaiveTime as std::ops::Sub<oldtime::Duration>>::sub":["sub","Real(LocalPath(\"src/naive/time/mod.rs\"))","std::ops::Sub"],"<naive::time::NaiveTime as std::ops::Sub>::sub":["sub","Real(LocalPath(\"src/naive/time/mod.rs\"))","std::ops::Sub"],"<naive::time::NaiveTime as std::ops::SubAssign<oldtime::Duration>>::sub_assign":["sub_assign","Real(LocalPath(\"src/naive/time/mod.rs\"))","std::ops::SubAssign"],"<naive::time::NaiveTime as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/naive/time/mod.rs\"))","std::str::FromStr"],"<naive::time::NaiveTime as traits::Timelike>::hour":["hour","Real(LocalPath(\"src/naive/time/mod.rs\"))","traits::Timelike"],"<naive::time::NaiveTime as traits::Timelike>::minute":["minute","Real(LocalPath(\"src/naive/time/mod.rs\"))","traits::Timelike"],"<naive::time::NaiveTime as traits::Timelike>::nanosecond":["nanosecond","Real(LocalPath(\"src/naive/time/mod.rs\"))","traits::Timelike"],"<naive::time::NaiveTime as traits::Timelike>::num_seconds_from_midnight":["num_seconds_from_midnight","Real(LocalPath(\"src/naive/time/mod.rs\"))","traits::Timelike"],"<naive::time::NaiveTime as traits::Timelike>::second":["second","Real(LocalPath(\"src/naive/time/mod.rs\"))","traits::Timelike"],"<naive::time::NaiveTime as traits::Timelike>::with_hour":["with_hour","Real(LocalPath(\"src/naive/time/mod.rs\"))","traits::Timelike"],"<naive::time::NaiveTime as traits::Timelike>::with_minute":["with_minute","Real(LocalPath(\"src/naive/time/mod.rs\"))","traits::Timelike"],"<naive::time::NaiveTime as traits::Timelike>::with_nanosecond":["with_nanosecond","Real(LocalPath(\"src/naive/time/mod.rs\"))","traits::Timelike"],"<naive::time::NaiveTime as traits::Timelike>::with_second":["with_second","Real(LocalPath(\"src/naive/time/mod.rs\"))","traits::Timelike"],"<offset::fixed::FixedOffset as offset::Offset>::fix":["fix","Real(LocalPath(\"src/offset/fixed.rs\"))","offset::Offset"],"<offset::fixed::FixedOffset as offset::TimeZone>::from_offset":["from_offset","Real(LocalPath(\"src/offset/fixed.rs\"))","offset::TimeZone"],"<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_local_date":["offset_from_local_date","Real(LocalPath(\"src/offset/fixed.rs\"))","offset::TimeZone"],"<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_local_datetime":["offset_from_local_datetime","Real(LocalPath(\"src/offset/fixed.rs\"))","offset::TimeZone"],"<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_utc_date":["offset_from_utc_date","Real(LocalPath(\"src/offset/fixed.rs\"))","offset::TimeZone"],"<offset::fixed::FixedOffset as offset::TimeZone>::offset_from_utc_datetime":["offset_from_utc_datetime","Real(LocalPath(\"src/offset/fixed.rs\"))","offset::TimeZone"],"<offset::fixed::FixedOffset as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/offset/fixed.rs\"))","std::fmt::Debug"],"<offset::fixed::FixedOffset as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/offset/fixed.rs\"))","std::fmt::Display"],"<offset::local::Local as offset::TimeZone>::from_offset":["from_offset","Real(LocalPath(\"src/offset/local/mod.rs\"))","offset::TimeZone"],"<offset::local::Local as offset::TimeZone>::offset_from_local_date":["offset_from_local_date","Real(LocalPath(\"src/offset/local/mod.rs\"))","offset::TimeZone"],"<offset::local::Local as offset::TimeZone>::offset_from_local_datetime":["offset_from_local_datetime","Real(LocalPath(\"src/offset/local/mod.rs\"))","offset::TimeZone"],"<offset::local::Local as offset::TimeZone>::offset_from_utc_date":["offset_from_utc_date","Real(LocalPath(\"src/offset/local/mod.rs\"))","offset::TimeZone"],"<offset::local::Local as offset::TimeZone>::offset_from_utc_datetime":["offset_from_utc_datetime","Real(LocalPath(\"src/offset/local/mod.rs\"))","offset::TimeZone"],"<offset::local::inner::Cache as std::default::Default>::default":["default","Real(LocalPath(\"src/offset/local/unix.rs\"))","std::default::Default"],"<offset::local::tz_info::Error as std::convert::From<std::io::Error>>::from":["from","Real(LocalPath(\"src/offset/local/tz_info/mod.rs\"))","std::convert::From"],"<offset::local::tz_info::Error as std::convert::From<std::num::ParseIntError>>::from":["from","Real(LocalPath(\"src/offset/local/tz_info/mod.rs\"))","std::convert::From"],"<offset::local::tz_info::Error as std::convert::From<std::str::Utf8Error>>::from":["from","Real(LocalPath(\"src/offset/local/tz_info/mod.rs\"))","std::convert::From"],"<offset::local::tz_info::Error as std::convert::From<std::time::SystemTimeError>>::from":["from","Real(LocalPath(\"src/offset/local/tz_info/mod.rs\"))","std::convert::From"],"<offset::local::tz_info::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/offset/local/tz_info/mod.rs\"))","std::fmt::Display"],"<offset::local::tz_info::rule::TransitionRule as std::convert::From<offset::local::tz_info::rule::AlternateTime>>::from":["from","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))","std::convert::From"],"<offset::local::tz_info::rule::TransitionRule as std::convert::From<offset::local::tz_info::timezone::LocalTimeType>>::from":["from","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))","std::convert::From"],"<offset::local::tz_info::timezone::TimeZoneName as std::convert::AsRef<str>>::as_ref":["as_ref","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))","std::convert::AsRef"],"<offset::local::tz_info::timezone::TimeZoneName as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))","std::fmt::Debug"],"<offset::utc::Utc as offset::Offset>::fix":["fix","Real(LocalPath(\"src/offset/utc.rs\"))","offset::Offset"],"<offset::utc::Utc as offset::TimeZone>::from_offset":["from_offset","Real(LocalPath(\"src/offset/utc.rs\"))","offset::TimeZone"],"<offset::utc::Utc as offset::TimeZone>::offset_from_local_date":["offset_from_local_date","Real(LocalPath(\"src/offset/utc.rs\"))","offset::TimeZone"],"<offset::utc::Utc as offset::TimeZone>::offset_from_local_datetime":["offset_from_local_datetime","Real(LocalPath(\"src/offset/utc.rs\"))","offset::TimeZone"],"<offset::utc::Utc as offset::TimeZone>::offset_from_utc_date":["offset_from_utc_date","Real(LocalPath(\"src/offset/utc.rs\"))","offset::TimeZone"],"<offset::utc::Utc as offset::TimeZone>::offset_from_utc_datetime":["offset_from_utc_datetime","Real(LocalPath(\"src/offset/utc.rs\"))","offset::TimeZone"],"<offset::utc::Utc as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/offset/utc.rs\"))","std::fmt::Debug"],"<offset::utc::Utc as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/offset/utc.rs\"))","std::fmt::Display"],"<round::RoundingError as std::error::Error>::description":["description","Real(LocalPath(\"src/round.rs\"))","std::error::Error"],"<round::RoundingError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/round.rs\"))","std::fmt::Display"],"<weekday::ParseWeekdayError as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/weekday.rs\"))","std::fmt::Debug"],"<weekday::ParseWeekdayError as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/weekday.rs\"))","std::fmt::Display"],"<weekday::Weekday as num_traits::FromPrimitive>::from_i64":["from_i64","Real(LocalPath(\"src/weekday.rs\"))","num_traits::FromPrimitive"],"<weekday::Weekday as num_traits::FromPrimitive>::from_u64":["from_u64","Real(LocalPath(\"src/weekday.rs\"))","num_traits::FromPrimitive"],"<weekday::Weekday as std::convert::TryFrom<u8>>::try_from":["try_from","Real(LocalPath(\"src/weekday.rs\"))","std::convert::TryFrom"],"<weekday::Weekday as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/weekday.rs\"))","std::fmt::Display"],"OutOfRange::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"date::Date::<Tz>::and_hms":["and_hms","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::and_hms_micro":["and_hms_micro","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::and_hms_micro_opt":["and_hms_micro_opt","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::and_hms_milli":["and_hms_milli","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::and_hms_milli_opt":["and_hms_milli_opt","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::and_hms_nano":["and_hms_nano","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::and_hms_nano_opt":["and_hms_nano_opt","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::and_hms_opt":["and_hms_opt","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::and_time":["and_time","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::checked_add_signed":["checked_add_signed","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::checked_sub_signed":["checked_sub_signed","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::format":["format","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::format_with_items":["format_with_items","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::from_utc":["from_utc","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::naive_local":["naive_local","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::naive_utc":["naive_utc","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::offset":["offset","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::pred":["pred","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::pred_opt":["pred_opt","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::signed_duration_since":["signed_duration_since","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::succ":["succ","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::succ_opt":["succ_opt","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::timezone":["timezone","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::with_timezone":["with_timezone","Real(LocalPath(\"src/date.rs\"))",""],"date::Date::<Tz>::years_since":["years_since","Real(LocalPath(\"src/date.rs\"))",""],"date::map_local":["map_local","Real(LocalPath(\"src/date.rs\"))",""],"datetime::<impl std::convert::From<datetime::DateTime<Tz>> for std::time::SystemTime>::from":["from","Real(LocalPath(\"src/datetime/mod.rs\"))","std::convert::From"],"datetime::DateTime::<Tz>::checked_add_days":["checked_add_days","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::checked_add_months":["checked_add_months","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::checked_add_signed":["checked_add_signed","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::checked_sub_days":["checked_sub_days","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::checked_sub_months":["checked_sub_months","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::checked_sub_signed":["checked_sub_signed","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::date":["date","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::date_naive":["date_naive","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::fixed_offset":["fixed_offset","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::format":["format","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::format_with_items":["format_with_items","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::from_local":["from_local","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::from_utc":["from_utc","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::naive_local":["naive_local","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::naive_utc":["naive_utc","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::offset":["offset","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::signed_duration_since":["signed_duration_since","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::time":["time","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::timestamp":["timestamp","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::timestamp_micros":["timestamp_micros","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::timestamp_millis":["timestamp_millis","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::timestamp_nanos":["timestamp_nanos","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::timestamp_subsec_micros":["timestamp_subsec_micros","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::timestamp_subsec_millis":["timestamp_subsec_millis","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::timestamp_subsec_nanos":["timestamp_subsec_nanos","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::timezone":["timezone","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::to_rfc2822":["to_rfc2822","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::to_rfc3339":["to_rfc3339","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::to_rfc3339_opts":["to_rfc3339_opts","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::with_timezone":["with_timezone","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<Tz>::years_since":["years_since","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<offset::fixed::FixedOffset>::parse_and_remainder":["parse_and_remainder","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_rfc2822":["parse_from_rfc2822","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_rfc3339":["parse_from_rfc3339","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::DateTime::<offset::fixed::FixedOffset>::parse_from_str":["parse_from_str","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"datetime::map_local":["map_local","Real(LocalPath(\"src/datetime/mod.rs\"))",""],"format::<impl std::str::FromStr for month::Month>::from_str":["from_str","Real(LocalPath(\"src/format/mod.rs\"))","std::str::FromStr"],"format::<impl std::str::FromStr for weekday::Weekday>::from_str":["from_str","Real(LocalPath(\"src/format/mod.rs\"))","std::str::FromStr"],"format::DelayedFormat::<I>::new":["new","Real(LocalPath(\"src/format/mod.rs\"))",""],"format::DelayedFormat::<I>::new_with_offset":["new_with_offset","Real(LocalPath(\"src/format/mod.rs\"))",""],"format::Locales::new":["new","Real(LocalPath(\"src/format/mod.rs\"))",""],"format::ParseError::kind":["kind","Real(LocalPath(\"src/format/mod.rs\"))",""],"format::format":["format","Real(LocalPath(\"src/format/mod.rs\"))",""],"format::format_inner":["format_inner","Real(LocalPath(\"src/format/mod.rs\"))",""],"format::format_item":["format_item","Real(LocalPath(\"src/format/mod.rs\"))",""],"format::parse::<impl std::str::FromStr for datetime::DateTime<offset::fixed::FixedOffset>>::from_str":["from_str","Real(LocalPath(\"src/format/parse.rs\"))","std::str::FromStr"],"format::parse::parse":["parse","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::parse_and_remainder":["parse_and_remainder","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::parse_internal":["parse_internal","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::parse_rfc2822":["parse_rfc2822","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::parse_rfc3339":["parse_rfc3339","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::set_weekday_with_num_days_from_sunday":["set_weekday_with_num_days_from_sunday","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parse::set_weekday_with_number_from_monday":["set_weekday_with_number_from_monday","Real(LocalPath(\"src/format/parse.rs\"))",""],"format::parsed::Parsed::new":["new","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_ampm":["set_ampm","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_day":["set_day","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_hour":["set_hour","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_hour12":["set_hour12","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_isoweek":["set_isoweek","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_isoyear":["set_isoyear","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_isoyear_div_100":["set_isoyear_div_100","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_isoyear_mod_100":["set_isoyear_mod_100","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_minute":["set_minute","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_month":["set_month","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_nanosecond":["set_nanosecond","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_offset":["set_offset","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_ordinal":["set_ordinal","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_second":["set_second","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_timestamp":["set_timestamp","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_week_from_mon":["set_week_from_mon","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_week_from_sun":["set_week_from_sun","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_weekday":["set_weekday","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_year":["set_year","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_year_div_100":["set_year_div_100","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::set_year_mod_100":["set_year_mod_100","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::to_datetime":["to_datetime","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::to_datetime_with_timezone":["to_datetime_with_timezone","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::to_fixed_offset":["to_fixed_offset","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::to_naive_date":["to_naive_date","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::to_naive_date::resolve_year":["resolve_year","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::to_naive_datetime_with_offset":["to_naive_datetime_with_offset","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::Parsed::to_naive_time":["to_naive_time","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::parsed::set_if_consistent":["set_if_consistent","Real(LocalPath(\"src/format/parsed.rs\"))",""],"format::scan::char":["char","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::comment_2822":["comment_2822","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::consume_colon_maybe":["consume_colon_maybe","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::equals":["equals","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::nanosecond":["nanosecond","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::nanosecond_fixed":["nanosecond_fixed","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::number":["number","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::s_next":["s_next","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::short_month0":["short_month0","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::short_or_long_month0":["short_or_long_month0","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::short_or_long_weekday":["short_or_long_weekday","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::short_weekday":["short_weekday","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::space":["space","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::timezone_name_skip":["timezone_name_skip","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::timezone_offset":["timezone_offset","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::timezone_offset_2822":["timezone_offset_2822","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::timezone_offset_internal":["timezone_offset_internal","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::timezone_offset_internal::digits":["digits","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::timezone_offset_permissive":["timezone_offset_permissive","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::timezone_offset_zulu":["timezone_offset_zulu","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::scan::trim1":["trim1","Real(LocalPath(\"src/format/scan.rs\"))",""],"format::strftime::StrftimeItems::<'a>::new":["new","Real(LocalPath(\"src/format/strftime.rs\"))",""],"format::strftime::StrftimeItems::<'a>::with_remainer":["with_remainer","Real(LocalPath(\"src/format/strftime.rs\"))",""],"format::write_hundreds":["write_hundreds","Real(LocalPath(\"src/format/mod.rs\"))",""],"format::write_local_minus_utc":["write_local_minus_utc","Real(LocalPath(\"src/format/mod.rs\"))",""],"format::write_rfc2822":["write_rfc2822","Real(LocalPath(\"src/format/mod.rs\"))",""],"format::write_rfc2822_inner":["write_rfc2822_inner","Real(LocalPath(\"src/format/mod.rs\"))",""],"format::write_rfc3339":["write_rfc3339","Real(LocalPath(\"src/format/mod.rs\"))",""],"month::Month::name":["name","Real(LocalPath(\"src/month.rs\"))",""],"month::Month::number_from_month":["number_from_month","Real(LocalPath(\"src/month.rs\"))",""],"month::Month::pred":["pred","Real(LocalPath(\"src/month.rs\"))",""],"month::Month::succ":["succ","Real(LocalPath(\"src/month.rs\"))",""],"month::Months::new":["new","Real(LocalPath(\"src/month.rs\"))",""],"naive::date::Days::new":["new","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::and_hms":["and_hms","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::and_hms_micro":["and_hms_micro","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::and_hms_micro_opt":["and_hms_micro_opt","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::and_hms_milli":["and_hms_milli","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::and_hms_milli_opt":["and_hms_milli_opt","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::and_hms_nano":["and_hms_nano","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::and_hms_nano_opt":["and_hms_nano_opt","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::and_hms_opt":["and_hms_opt","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::and_time":["and_time","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::checked_add_days":["checked_add_days","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::checked_add_months":["checked_add_months","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::checked_add_signed":["checked_add_signed","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::checked_sub_days":["checked_sub_days","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::checked_sub_months":["checked_sub_months","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::checked_sub_signed":["checked_sub_signed","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::diff_days":["diff_days","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::diff_months":["diff_months","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::format":["format","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::format_with_items":["format_with_items","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::from_isoywd":["from_isoywd","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::from_isoywd_opt":["from_isoywd_opt","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::from_mdf":["from_mdf","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::from_num_days_from_ce":["from_num_days_from_ce","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::from_num_days_from_ce_opt":["from_num_days_from_ce_opt","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::from_ordinal_and_flags":["from_ordinal_and_flags","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::from_weekday_of_month":["from_weekday_of_month","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::from_weekday_of_month_opt":["from_weekday_of_month_opt","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::from_ymd":["from_ymd","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::from_ymd_opt":["from_ymd_opt","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::from_yo":["from_yo","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::from_yo_opt":["from_yo_opt","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::iter_days":["iter_days","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::iter_weeks":["iter_weeks","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::mdf":["mdf","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::of":["of","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::parse_and_remainder":["parse_and_remainder","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::parse_from_str":["parse_from_str","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::pred":["pred","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::pred_opt":["pred_opt","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::signed_duration_since":["signed_duration_since","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::succ":["succ","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::succ_opt":["succ_opt","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::week":["week","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::weeks_from":["weeks_from","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::with_mdf":["with_mdf","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::with_of":["with_of","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveDate::years_since":["years_since","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveWeek::days":["days","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveWeek::first_day":["first_day","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::NaiveWeek::last_day":["last_day","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::date::div_mod_floor":["div_mod_floor","Real(LocalPath(\"src/naive/date.rs\"))",""],"naive::datetime::NaiveDateTime::and_local_timezone":["and_local_timezone","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::and_utc":["and_utc","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::checked_add_days":["checked_add_days","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::checked_add_months":["checked_add_months","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::checked_add_signed":["checked_add_signed","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::checked_sub_days":["checked_sub_days","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::checked_sub_months":["checked_sub_months","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::checked_sub_signed":["checked_sub_signed","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::date":["date","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::format":["format","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::format_with_items":["format_with_items","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::from_timestamp":["from_timestamp","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::from_timestamp_micros":["from_timestamp_micros","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::from_timestamp_millis":["from_timestamp_millis","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::from_timestamp_opt":["from_timestamp_opt","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::new":["new","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::parse_and_remainder":["parse_and_remainder","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::parse_from_str":["parse_from_str","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::signed_duration_since":["signed_duration_since","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::time":["time","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::timestamp":["timestamp","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::timestamp_micros":["timestamp_micros","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::timestamp_millis":["timestamp_millis","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::timestamp_nanos":["timestamp_nanos","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::timestamp_subsec_micros":["timestamp_subsec_micros","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::timestamp_subsec_millis":["timestamp_subsec_millis","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::datetime::NaiveDateTime::timestamp_subsec_nanos":["timestamp_subsec_nanos","Real(LocalPath(\"src/naive/datetime/mod.rs\"))",""],"naive::internals::Mdf::day":["day","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Mdf::from_of":["from_of","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Mdf::month":["month","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Mdf::new":["new","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Mdf::to_of":["to_of","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Mdf::with_day":["with_day","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Mdf::with_flags":["with_flags","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Mdf::with_month":["with_month","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::flags":["flags","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::from_date_impl":["from_date_impl","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::from_mdf":["from_mdf","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::inner":["inner","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::isoweekdate_raw":["isoweekdate_raw","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::new":["new","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::ol":["ol","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::ordinal":["ordinal","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::pred":["pred","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::succ":["succ","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::to_mdf":["to_mdf","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::validate":["validate","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::weekday":["weekday","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::Of::with_ordinal":["with_ordinal","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::YearFlags::from_year":["from_year","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::YearFlags::from_year_mod_400":["from_year_mod_400","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::YearFlags::isoweek_delta":["isoweek_delta","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::YearFlags::ndays":["ndays","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::YearFlags::nisoweeks":["nisoweeks","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::cycle_to_yo":["cycle_to_yo","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::weekday_from_u32_mod7":["weekday_from_u32_mod7","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::internals::yo_to_cycle":["yo_to_cycle","Real(LocalPath(\"src/naive/internals.rs\"))",""],"naive::isoweek::IsoWeek::week":["week","Real(LocalPath(\"src/naive/isoweek.rs\"))",""],"naive::isoweek::IsoWeek::week0":["week0","Real(LocalPath(\"src/naive/isoweek.rs\"))",""],"naive::isoweek::IsoWeek::year":["year","Real(LocalPath(\"src/naive/isoweek.rs\"))",""],"naive::isoweek::iso_week_from_yof":["iso_week_from_yof","Real(LocalPath(\"src/naive/isoweek.rs\"))",""],"naive::time::NaiveTime::format":["format","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::format_with_items":["format_with_items","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::from_hms":["from_hms","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::from_hms_micro":["from_hms_micro","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::from_hms_micro_opt":["from_hms_micro_opt","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::from_hms_milli":["from_hms_milli","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::from_hms_milli_opt":["from_hms_milli_opt","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::from_hms_nano":["from_hms_nano","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::from_hms_nano_opt":["from_hms_nano_opt","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::from_hms_opt":["from_hms_opt","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::from_num_seconds_from_midnight":["from_num_seconds_from_midnight","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::from_num_seconds_from_midnight_opt":["from_num_seconds_from_midnight_opt","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::hms":["hms","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::overflowing_add_signed":["overflowing_add_signed","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::overflowing_sub_signed":["overflowing_sub_signed","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::parse_and_remainder":["parse_and_remainder","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::parse_from_str":["parse_from_str","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"naive::time::NaiveTime::signed_duration_since":["signed_duration_since","Real(LocalPath(\"src/naive/time/mod.rs\"))",""],"offset::LocalResult::<T>::earliest":["earliest","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::LocalResult::<T>::latest":["latest","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::LocalResult::<T>::map":["map","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::LocalResult::<T>::single":["single","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::LocalResult::<T>::unwrap":["unwrap","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::LocalResult::<date::Date<Tz>>::and_hms_micro_opt":["and_hms_micro_opt","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::LocalResult::<date::Date<Tz>>::and_hms_milli_opt":["and_hms_milli_opt","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::LocalResult::<date::Date<Tz>>::and_hms_nano_opt":["and_hms_nano_opt","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::LocalResult::<date::Date<Tz>>::and_hms_opt":["and_hms_opt","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::LocalResult::<date::Date<Tz>>::and_time":["and_time","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::datetime_from_str":["datetime_from_str","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::from_local_date":["from_local_date","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::from_local_datetime":["from_local_datetime","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::from_utc_date":["from_utc_date","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::from_utc_datetime":["from_utc_datetime","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::isoywd":["isoywd","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::isoywd_opt":["isoywd_opt","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::timestamp":["timestamp","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::timestamp_millis":["timestamp_millis","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::timestamp_millis_opt":["timestamp_millis_opt","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::timestamp_nanos":["timestamp_nanos","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::timestamp_opt":["timestamp_opt","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::with_ymd_and_hms":["with_ymd_and_hms","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::ymd":["ymd","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::ymd_opt":["ymd_opt","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::yo":["yo","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::TimeZone::yo_opt":["yo_opt","Real(LocalPath(\"src/offset/mod.rs\"))",""],"offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::add":["add","Real(LocalPath(\"src/offset/fixed.rs\"))","std::ops::Add"],"offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for naive::datetime::NaiveDateTime>::add":["add","Real(LocalPath(\"src/offset/fixed.rs\"))","std::ops::Add"],"offset::fixed::<impl std::ops::Add<offset::fixed::FixedOffset> for naive::time::NaiveTime>::add":["add","Real(LocalPath(\"src/offset/fixed.rs\"))","std::ops::Add"],"offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for datetime::DateTime<Tz>>::sub":["sub","Real(LocalPath(\"src/offset/fixed.rs\"))","std::ops::Sub"],"offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for naive::datetime::NaiveDateTime>::sub":["sub","Real(LocalPath(\"src/offset/fixed.rs\"))","std::ops::Sub"],"offset::fixed::<impl std::ops::Sub<offset::fixed::FixedOffset> for naive::time::NaiveTime>::sub":["sub","Real(LocalPath(\"src/offset/fixed.rs\"))","std::ops::Sub"],"offset::fixed::FixedOffset::east":["east","Real(LocalPath(\"src/offset/fixed.rs\"))",""],"offset::fixed::FixedOffset::east_opt":["east_opt","Real(LocalPath(\"src/offset/fixed.rs\"))",""],"offset::fixed::FixedOffset::local_minus_utc":["local_minus_utc","Real(LocalPath(\"src/offset/fixed.rs\"))",""],"offset::fixed::FixedOffset::utc_minus_local":["utc_minus_local","Real(LocalPath(\"src/offset/fixed.rs\"))",""],"offset::fixed::FixedOffset::west":["west","Real(LocalPath(\"src/offset/fixed.rs\"))",""],"offset::fixed::FixedOffset::west_opt":["west_opt","Real(LocalPath(\"src/offset/fixed.rs\"))",""],"offset::fixed::add_with_leapsecond":["add_with_leapsecond","Real(LocalPath(\"src/offset/fixed.rs\"))",""],"offset::local::Local::now":["now","Real(LocalPath(\"src/offset/local/mod.rs\"))",""],"offset::local::Local::today":["today","Real(LocalPath(\"src/offset/local/mod.rs\"))",""],"offset::local::inner::Cache::offset":["offset","Real(LocalPath(\"src/offset/local/unix.rs\"))",""],"offset::local::inner::Source::new":["new","Real(LocalPath(\"src/offset/local/unix.rs\"))",""],"offset::local::inner::TZ_INFO::__getit":["__getit","Real(Remapped { local_path: Some(\"/home/tmq244/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })",""],"offset::local::inner::TZ_INFO::__init":["__init","Real(Remapped { local_path: Some(\"/home/tmq244/.rustup/toolchains/nightly-2022-12-10-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs\"), virtual_name: \"/rustc/dfe3fe710181738a2cb3060c23ec5efb3c68ca09/library/std/src/thread/local.rs\" })",""],"offset::local::inner::current_zone":["current_zone","Real(LocalPath(\"src/offset/local/unix.rs\"))",""],"offset::local::inner::fallback_timezone":["fallback_timezone","Real(LocalPath(\"src/offset/local/unix.rs\"))",""],"offset::local::inner::offset":["offset","Real(LocalPath(\"src/offset/local/unix.rs\"))",""],"offset::local::inner::offset_from_local_datetime":["offset_from_local_datetime","Real(LocalPath(\"src/offset/local/unix.rs\"))",""],"offset::local::inner::offset_from_utc_datetime":["offset_from_utc_datetime","Real(LocalPath(\"src/offset/local/unix.rs\"))",""],"offset::local::tz_info::parser::Cursor::<'a>::is_empty":["is_empty","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::Cursor::<'a>::new":["new","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::Cursor::<'a>::peek":["peek","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::Cursor::<'a>::read_be_u32":["read_be_u32","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::Cursor::<'a>::read_exact":["read_exact","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::Cursor::<'a>::read_int":["read_int","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::Cursor::<'a>::read_optional_tag":["read_optional_tag","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::Cursor::<'a>::read_tag":["read_tag","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::Cursor::<'a>::read_until":["read_until","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::Cursor::<'a>::read_while":["read_while","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::Cursor::<'a>::remaining":["remaining","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::Header::new":["new","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::State::<'a>::new":["new","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::State::<'a>::parse_time":["parse_time","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::parse":["parse","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::read_be_i32":["read_be_i32","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::parser::read_be_i64":["read_be_i64","Real(LocalPath(\"src/offset/local/tz_info/parser.rs\"))",""],"offset::local::tz_info::rule::AlternateTime::find_local_time_type":["find_local_time_type","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::AlternateTime::find_local_time_type_from_local":["find_local_time_type_from_local","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::AlternateTime::new":["new","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::RuleDay::julian_0":["julian_0","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::RuleDay::julian_1":["julian_1","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::RuleDay::month_weekday":["month_weekday","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::RuleDay::parse":["parse","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::RuleDay::transition_date":["transition_date","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::RuleDay::unix_time":["unix_time","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::TransitionRule::find_local_time_type":["find_local_time_type","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::TransitionRule::find_local_time_type_from_local":["find_local_time_type_from_local","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::TransitionRule::from_tz_string":["from_tz_string","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::UtcDateTime::from_timespec":["from_timespec","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::days_since_unix_epoch":["days_since_unix_epoch","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::is_leap_year":["is_leap_year","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::parse_hhmmss":["parse_hhmmss","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::parse_name":["parse_name","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::parse_offset":["parse_offset","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::parse_rule_time":["parse_rule_time","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::parse_rule_time_extended":["parse_rule_time_extended","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::rule::parse_signed_hhmmss":["parse_signed_hhmmss","Real(LocalPath(\"src/offset/local/tz_info/rule.rs\"))",""],"offset::local::tz_info::timezone::LeapSecond::new":["new","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::LeapSecond::unix_leap_time":["unix_leap_time","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::LocalTimeType::is_dst":["is_dst","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::LocalTimeType::new":["new","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::LocalTimeType::offset":["offset","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::LocalTimeType::with_offset":["with_offset","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZone::as_ref":["as_ref","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZone::find_local_time_type":["find_local_time_type","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZone::find_local_time_type_from_local":["find_local_time_type_from_local","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZone::fixed":["fixed","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZone::from_file":["from_file","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZone::from_posix_tz":["from_posix_tz","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZone::from_tz_data":["from_tz_data","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZone::local":["local","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZone::new":["new","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZone::utc":["utc","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZoneName::as_bytes":["as_bytes","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZoneName::equal":["equal","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZoneName::new":["new","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::find_local_time_type":["find_local_time_type","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::find_local_time_type_from_local":["find_local_time_type_from_local","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::unix_leap_time_to_unix_time":["unix_leap_time_to_unix_time","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::unix_time_to_unix_leap_time":["unix_time_to_unix_leap_time","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::TimeZoneRef::<'a>::validate":["validate","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::Transition::new":["new","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::Transition::unix_leap_time":["unix_leap_time","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::find_tz_file":["find_tz_file","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::local::tz_info::timezone::saturating_abs":["saturating_abs","Real(LocalPath(\"src/offset/local/tz_info/timezone.rs\"))",""],"offset::utc::Utc::now":["now","Real(LocalPath(\"src/offset/utc.rs\"))",""],"offset::utc::Utc::today":["today","Real(LocalPath(\"src/offset/utc.rs\"))",""],"round::duration_round":["duration_round","Real(LocalPath(\"src/round.rs\"))",""],"round::duration_trunc":["duration_trunc","Real(LocalPath(\"src/round.rs\"))",""],"round::span_for_digits":["span_for_digits","Real(LocalPath(\"src/round.rs\"))",""],"traits::Datelike::num_days_from_ce":["num_days_from_ce","Real(LocalPath(\"src/traits.rs\"))",""],"traits::Datelike::year_ce":["year_ce","Real(LocalPath(\"src/traits.rs\"))",""],"traits::Timelike::hour12":["hour12","Real(LocalPath(\"src/traits.rs\"))",""],"traits::Timelike::num_seconds_from_midnight":["num_seconds_from_midnight","Real(LocalPath(\"src/traits.rs\"))",""],"weekday::Weekday::num_days_from":["num_days_from","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::num_days_from_monday":["num_days_from_monday","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::num_days_from_sunday":["num_days_from_sunday","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::number_from_monday":["number_from_monday","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::number_from_sunday":["number_from_sunday","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::pred":["pred","Real(LocalPath(\"src/weekday.rs\"))",""],"weekday::Weekday::succ":["succ","Real(LocalPath(\"src/weekday.rs\"))",""]},"trait_to_struct":{"num_traits::FromPrimitive":["month::Month","weekday::Weekday"],"offset::Offset":["offset::fixed::FixedOffset","offset::utc::Utc"],"offset::TimeZone":["offset::fixed::FixedOffset","offset::local::Local","offset::utc::Utc"],"round::DurationRound":["datetime::DateTime","naive::datetime::NaiveDateTime"],"round::SubsecRound":["<T as round::SubsecRound>::T"],"std::clone::Clone":["OutOfRange","date::Date","datetime::DateTime","datetime::SecondsFormat","format::Colons","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::ParseError","format::ParseErrorKind","format::Void","format::parsed::Parsed","format::strftime::StrftimeItems","month::Month","month::Months","month::ParseMonthError","naive::date::Days","naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","naive::datetime::NaiveDateTime","naive::internals::Mdf","naive::internals::Of","naive::internals::YearFlags","naive::isoweek::IsoWeek","naive::time::NaiveTime","offset::LocalResult","offset::fixed::FixedOffset","offset::local::Local","offset::local::tz_info::parser::Version","offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::rule::UtcDateTime","offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZone","offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","offset::utc::Utc","round::RoundingError","weekday::ParseWeekdayError","weekday::Weekday"],"std::cmp::Eq":["OutOfRange","date::Date","datetime::DateTime","datetime::SecondsFormat","format::Colons","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::ParseError","format::ParseErrorKind","format::Void","format::parsed::Parsed","month::Month","month::Months","month::ParseMonthError","naive::date::Days","naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","naive::datetime::NaiveDateTime","naive::internals::YearFlags","naive::isoweek::IsoWeek","naive::time::NaiveTime","offset::LocalResult","offset::fixed::FixedOffset","offset::local::tz_info::parser::Cursor","offset::local::tz_info::parser::Version","offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::rule::UtcDateTime","offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZone","offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","offset::utc::Utc","round::RoundingError","weekday::ParseWeekdayError","weekday::Weekday"],"std::cmp::Ord":["date::Date","datetime::DateTime","naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","naive::datetime::NaiveDateTime","naive::isoweek::IsoWeek","naive::time::NaiveTime","offset::local::tz_info::rule::UtcDateTime"],"std::cmp::PartialEq":["OutOfRange","date::Date","datetime::DateTime","datetime::SecondsFormat","format::Colons","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::ParseError","format::ParseErrorKind","format::Void","format::parsed::Parsed","month::Month","month::Months","month::ParseMonthError","naive::date::Days","naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","naive::datetime::NaiveDateTime","naive::internals::Mdf","naive::internals::Of","naive::internals::YearFlags","naive::isoweek::IsoWeek","naive::time::NaiveTime","offset::LocalResult","offset::fixed::FixedOffset","offset::local::tz_info::parser::Cursor","offset::local::tz_info::parser::Version","offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::rule::UtcDateTime","offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZone","offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","offset::utc::Utc","round::RoundingError","weekday::ParseWeekdayError","weekday::Weekday"],"std::cmp::PartialOrd":["date::Date","datetime::DateTime","month::Month","month::Months","naive::date::Days","naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","naive::datetime::NaiveDateTime","naive::internals::Mdf","naive::internals::Of","naive::isoweek::IsoWeek","naive::time::NaiveTime","offset::local::tz_info::rule::UtcDateTime"],"std::convert::AsRef":["offset::local::tz_info::timezone::TimeZoneName"],"std::convert::From":["datetime::DateTime","naive::date::NaiveDate","offset::local::tz_info::Error","offset::local::tz_info::rule::TransitionRule","std::time::SystemTime"],"std::convert::TryFrom":["month::Month","weekday::Weekday"],"std::default::Default":["datetime::DateTime","format::parsed::Parsed","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::local::inner::Cache"],"std::error::Error":["OutOfRange","format::ParseError","offset::local::tz_info::Error","round::RoundingError","weekday::ParseWeekdayError"],"std::fmt::Debug":["OutOfRange","date::Date","datetime::DateTime","datetime::SecondsFormat","format::Colons","format::DelayedFormat","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Locale","format::Numeric","format::Pad","format::ParseError","format::ParseErrorKind","format::parsed::Parsed","format::strftime::StrftimeItems","month::Month","month::Months","month::ParseMonthError","naive::date::Days","naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","naive::date::NaiveWeek","naive::datetime::NaiveDateTime","naive::internals::Mdf","naive::internals::Of","naive::internals::YearFlags","naive::isoweek::IsoWeek","naive::time::NaiveTime","offset::LocalResult","offset::fixed::FixedOffset","offset::local::Local","offset::local::tz_info::Error","offset::local::tz_info::parser::Cursor","offset::local::tz_info::parser::Header","offset::local::tz_info::parser::Version","offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::rule::UtcDateTime","offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZone","offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","offset::utc::Utc","round::RoundingError","weekday::ParseWeekdayError","weekday::Weekday"],"std::fmt::Display":["OutOfRange","date::Date","datetime::DateTime","format::DelayedFormat","format::ParseError","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","offset::fixed::FixedOffset","offset::local::tz_info::Error","offset::utc::Utc","round::RoundingError","weekday::ParseWeekdayError","weekday::Weekday"],"std::hash::Hash":["OutOfRange","date::Date","datetime::DateTime","datetime::SecondsFormat","format::Colons","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::ParseError","format::ParseErrorKind","format::Void","format::parsed::Parsed","month::Month","month::Months","naive::date::Days","naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","naive::datetime::NaiveDateTime","naive::internals::YearFlags","naive::isoweek::IsoWeek","naive::time::NaiveTime","offset::LocalResult","offset::fixed::FixedOffset","offset::utc::Utc","weekday::Weekday"],"std::iter::DoubleEndedIterator":["naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator"],"std::iter::ExactSizeIterator":["naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator"],"std::iter::Iterator":["format::strftime::StrftimeItems","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator"],"std::marker::Copy":["OutOfRange","date::Date","datetime::DateTime","datetime::SecondsFormat","format::Pad","format::ParseError","format::ParseErrorKind","month::Month","month::Months","naive::date::Days","naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","naive::datetime::NaiveDateTime","naive::internals::Mdf","naive::internals::Of","naive::internals::YearFlags","naive::isoweek::IsoWeek","naive::time::NaiveTime","offset::LocalResult","offset::fixed::FixedOffset","offset::local::Local","offset::local::tz_info::parser::Version","offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::rule::UtcDateTime","offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","offset::utc::Utc","round::RoundingError","weekday::Weekday"],"std::marker::Send":["date::Date","datetime::DateTime"],"std::marker::StructuralEq":["OutOfRange","datetime::SecondsFormat","format::Colons","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::ParseError","format::ParseErrorKind","format::Void","format::parsed::Parsed","month::Month","month::Months","month::ParseMonthError","naive::date::Days","naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","naive::datetime::NaiveDateTime","naive::internals::YearFlags","naive::isoweek::IsoWeek","naive::time::NaiveTime","offset::LocalResult","offset::fixed::FixedOffset","offset::local::tz_info::parser::Cursor","offset::local::tz_info::parser::Version","offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::rule::UtcDateTime","offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZone","offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","offset::utc::Utc","round::RoundingError","weekday::ParseWeekdayError","weekday::Weekday"],"std::marker::StructuralPartialEq":["OutOfRange","datetime::SecondsFormat","format::Colons","format::Fixed","format::InternalFixed","format::InternalInternal","format::InternalNumeric","format::Item","format::Numeric","format::Pad","format::ParseError","format::ParseErrorKind","format::Void","format::parsed::Parsed","month::Month","month::Months","month::ParseMonthError","naive::date::Days","naive::date::NaiveDate","naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator","naive::datetime::NaiveDateTime","naive::internals::Mdf","naive::internals::Of","naive::internals::YearFlags","naive::isoweek::IsoWeek","naive::time::NaiveTime","offset::LocalResult","offset::fixed::FixedOffset","offset::local::tz_info::parser::Cursor","offset::local::tz_info::parser::Version","offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::rule::UtcDateTime","offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZone","offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition","offset::utc::Utc","round::RoundingError","weekday::ParseWeekdayError","weekday::Weekday"],"std::ops::Add":["date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"std::ops::AddAssign":["date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"std::ops::Sub":["date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"std::ops::SubAssign":["date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime"],"std::str::FromStr":["datetime::DateTime","month::Month","naive::date::NaiveDate","naive::datetime::NaiveDateTime","naive::time::NaiveTime","weekday::Weekday"],"traits::Datelike":["date::Date","datetime::DateTime","naive::date::NaiveDate","naive::datetime::NaiveDateTime"],"traits::Timelike":["datetime::DateTime","naive::datetime::NaiveDateTime","naive::time::NaiveTime"]},"type_to_def_path":{"OutOfRange":"OutOfRange","date::Date<Tz>":"date::Date","datetime::DateTime<Tz>":"datetime::DateTime","datetime::SecondsFormat":"datetime::SecondsFormat","format::Colons":"format::Colons","format::DelayedFormat<I>":"format::DelayedFormat","format::Fixed":"format::Fixed","format::InternalFixed":"format::InternalFixed","format::InternalInternal":"format::InternalInternal","format::InternalNumeric":"format::InternalNumeric","format::Item<'a>":"format::Item","format::Locale":"format::Locale","format::Locales":"format::Locales","format::Numeric":"format::Numeric","format::Pad":"format::Pad","format::ParseError":"format::ParseError","format::ParseErrorKind":"format::ParseErrorKind","format::Void":"format::Void","format::parsed::Parsed":"format::parsed::Parsed","format::scan::CommentState":"format::scan::CommentState","format::strftime::StrftimeItems<'a>":"format::strftime::StrftimeItems","month::Month":"month::Month","month::Months":"month::Months","month::ParseMonthError":"month::ParseMonthError","naive::date::Days":"naive::date::Days","naive::date::NaiveDate":"naive::date::NaiveDate","naive::date::NaiveDateDaysIterator":"naive::date::NaiveDateDaysIterator","naive::date::NaiveDateWeeksIterator":"naive::date::NaiveDateWeeksIterator","naive::date::NaiveWeek":"naive::date::NaiveWeek","naive::datetime::NaiveDateTime":"naive::datetime::NaiveDateTime","naive::internals::Mdf":"naive::internals::Mdf","naive::internals::Of":"naive::internals::Of","naive::internals::YearFlags":"naive::internals::YearFlags","naive::isoweek::IsoWeek":"naive::isoweek::IsoWeek","naive::time::NaiveTime":"naive::time::NaiveTime","offset::LocalResult<T>":"offset::LocalResult","offset::fixed::FixedOffset":"offset::fixed::FixedOffset","offset::local::Local":"offset::local::Local","offset::local::inner::Cache":"offset::local::inner::Cache","offset::local::inner::Source":"offset::local::inner::Source","offset::local::tz_info::Error":"offset::local::tz_info::Error","offset::local::tz_info::parser::Cursor<'a>":"offset::local::tz_info::parser::Cursor","offset::local::tz_info::parser::Header":"offset::local::tz_info::parser::Header","offset::local::tz_info::parser::State<'a>":"offset::local::tz_info::parser::State","offset::local::tz_info::parser::Version":"offset::local::tz_info::parser::Version","offset::local::tz_info::rule::AlternateTime":"offset::local::tz_info::rule::AlternateTime","offset::local::tz_info::rule::RuleDay":"offset::local::tz_info::rule::RuleDay","offset::local::tz_info::rule::TransitionRule":"offset::local::tz_info::rule::TransitionRule","offset::local::tz_info::rule::UtcDateTime":"offset::local::tz_info::rule::UtcDateTime","offset::local::tz_info::timezone::LeapSecond":"offset::local::tz_info::timezone::LeapSecond","offset::local::tz_info::timezone::LocalTimeType":"offset::local::tz_info::timezone::LocalTimeType","offset::local::tz_info::timezone::TimeZone":"offset::local::tz_info::timezone::TimeZone","offset::local::tz_info::timezone::TimeZoneName":"offset::local::tz_info::timezone::TimeZoneName","offset::local::tz_info::timezone::TimeZoneRef<'a>":"offset::local::tz_info::timezone::TimeZoneRef","offset::local::tz_info::timezone::Transition":"offset::local::tz_info::timezone::Transition","offset::utc::Utc":"offset::utc::Utc","round::RoundingError":"round::RoundingError","weekday::ParseWeekdayError":"weekday::ParseWeekdayError","weekday::Weekday":"weekday::Weekday"}}