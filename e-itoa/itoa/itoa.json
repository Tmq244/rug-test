{"dependencies":{"<Buffer as core::clone::Clone>::clone":["Buffer","core::marker::Sized","core::mem::MaybeUninit"],"<Buffer as core::default::Default>::default":["Buffer","core::marker::Sized","core::mem::MaybeUninit"],"<impl private::Sealed for i128>::write":["core::marker::Sized","core::mem::MaybeUninit"],"<impl private::Sealed for i16>::write":["core::marker::Sized","core::mem::MaybeUninit"],"<impl private::Sealed for i32>::write":["core::marker::Sized","core::mem::MaybeUninit"],"<impl private::Sealed for i64>::write":["core::marker::Sized","core::mem::MaybeUninit"],"<impl private::Sealed for i8>::write":["core::marker::Sized","core::mem::MaybeUninit"],"<impl private::Sealed for isize>::write":["core::marker::Sized","core::mem::MaybeUninit"],"<impl private::Sealed for u128>::write":["core::marker::Sized","core::mem::MaybeUninit"],"<impl private::Sealed for u16>::write":["core::marker::Sized","core::mem::MaybeUninit"],"<impl private::Sealed for u32>::write":["core::marker::Sized","core::mem::MaybeUninit"],"<impl private::Sealed for u64>::write":["core::marker::Sized","core::mem::MaybeUninit"],"<impl private::Sealed for u8>::write":["core::marker::Sized","core::mem::MaybeUninit"],"<impl private::Sealed for usize>::write":["core::marker::Sized","core::mem::MaybeUninit"],"Buffer":["Buffer","core::marker::Sized","core::mem::MaybeUninit"],"Buffer::format":["Buffer","Integer","core::marker::Sized","core::mem::MaybeUninit"],"Buffer::new":["Buffer","core::marker::Sized","core::mem::MaybeUninit"],"private::Sealed::write":[],"udiv128::u128_mulhi":[],"udiv128::udivmod_1e19":[]},"glob_path_import":{},"self_to_fn":{"Buffer":["impl Buffer {\n    /// This is a cheap operation; you don't need to worry about reusing buffers\n    /// for efficiency.\n    #[inline]\n    #[cfg_attr(feature = \"no-panic\", no_panic)]\n    pub fn new() -> Buffer {\n        let bytes = [MaybeUninit::<u8>::uninit(); I128_MAX_LEN];\n        Buffer { bytes }\n    }\n\n    /// Print an integer into this buffer and return a reference to its string\n    /// representation within the buffer.\n    #[cfg_attr(feature = \"no-panic\", no_panic)]\n    pub fn format<I: Integer>(&mut self, i: I) -> &str {\n        i.write(unsafe {\n            &mut *(&mut self.bytes as *mut [MaybeUninit<u8>; I128_MAX_LEN]\n                as *mut <I as private::Sealed>::Buffer)\n        })\n    }\n}","impl Clone for Buffer {\n    #[inline]\n    fn clone(&self) -> Self {\n        Buffer::new()\n    }\n}","impl Default for Buffer {\n    #[inline]\n    fn default() -> Buffer {\n        Buffer::new()\n    }\n}"]},"single_path_import":{},"srcs":{"<Buffer as core::clone::Clone>::clone":["#[inline]\nfn clone(&self) -> Self{\n        Buffer::new()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<Buffer as core::default::Default>::default":["#[inline]\nfn default() -> Buffer{\n        Buffer::new()\n    }","Real(LocalPath(\"src/lib.rs\"))"],"<impl private::Sealed for i128>::write":["#[allow(unused_comparisons)]\n#[inline]\nfn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str{\n                let is_nonnegative = self >= 0;\n                let n = if is_nonnegative {\n                    self as u128\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!(self as u128)).wrapping_add(1)\n                };\n                let mut curr = buf.len() as isize;\n                let buf_ptr = buf.as_mut_ptr() as *mut u8;\n\n                unsafe {\n                    // Divide by 10^19 which is the highest power less than 2^64.\n                    let (n, rem) = udiv128::udivmod_1e19(n);\n                    let buf1 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];\n                    curr -= rem.write(&mut *buf1).len() as isize;\n\n                    if n != 0 {\n                        // Memset the base10 leading zeros of rem.\n                        let target = buf.len() as isize - 19;\n                        ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);\n                        curr = target;\n\n                        // Divide by 10^19 again.\n                        let (n, rem) = udiv128::udivmod_1e19(n);\n                        let buf2 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];\n                        curr -= rem.write(&mut *buf2).len() as isize;\n\n                        if n != 0 {\n                            // Memset the leading zeros.\n                            let target = buf.len() as isize - 38;\n                            ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);\n                            curr = target;\n\n                            // There is at most one digit left\n                            // because u128::max / 10^19 / 10^19 is 3.\n                            curr -= 1;\n                            *buf_ptr.offset(curr) = (n as u8) + b'0';\n                        }\n                    }\n\n                    if !is_nonnegative {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = b'-';\n                    }\n\n                    let len = buf.len() - curr as usize;\n                    let bytes = slice::from_raw_parts(buf_ptr.offset(curr), len);\n                    str::from_utf8_unchecked(bytes)\n                }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<impl private::Sealed for i16>::write":["#[allow(unused_comparisons)]\n#[inline]\nfn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str{\n                let is_nonnegative = self >= 0;\n                let mut n = if is_nonnegative {\n                    self as $conv_fn\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!(self as $conv_fn)).wrapping_add(1)\n                };\n                let mut curr = buf.len() as isize;\n                let buf_ptr = buf.as_mut_ptr() as *mut u8;\n                let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n                unsafe {\n                    // need at least 16 bits for the 4-characters-at-a-time to work.\n                    if mem::size_of::<$t>() >= 2 {\n                        // eagerly decode 4 characters at a time\n                        while n >= 10000 {\n                            let rem = (n % 10000) as isize;\n                            n /= 10000;\n\n                            let d1 = (rem / 100) << 1;\n                            let d2 = (rem % 100) << 1;\n                            curr -= 4;\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                        }\n                    }\n\n                    // if we reach here numbers are <= 9999, so at most 4 chars long\n                    let mut n = n as isize; // possibly reduce 64bit math\n\n                    // decode 2 more chars, if > 2 chars\n                    if n >= 100 {\n                        let d1 = (n % 100) << 1;\n                        n /= 100;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    // decode last 1 or 2 chars\n                    if n < 10 {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = (n as u8) + b'0';\n                    } else {\n                        let d1 = n << 1;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    if !is_nonnegative {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = b'-';\n                    }\n                }\n\n                let len = buf.len() - curr as usize;\n                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\n                unsafe { str::from_utf8_unchecked(bytes) }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<impl private::Sealed for i32>::write":["#[allow(unused_comparisons)]\n#[inline]\nfn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str{\n                let is_nonnegative = self >= 0;\n                let mut n = if is_nonnegative {\n                    self as $conv_fn\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!(self as $conv_fn)).wrapping_add(1)\n                };\n                let mut curr = buf.len() as isize;\n                let buf_ptr = buf.as_mut_ptr() as *mut u8;\n                let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n                unsafe {\n                    // need at least 16 bits for the 4-characters-at-a-time to work.\n                    if mem::size_of::<$t>() >= 2 {\n                        // eagerly decode 4 characters at a time\n                        while n >= 10000 {\n                            let rem = (n % 10000) as isize;\n                            n /= 10000;\n\n                            let d1 = (rem / 100) << 1;\n                            let d2 = (rem % 100) << 1;\n                            curr -= 4;\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                        }\n                    }\n\n                    // if we reach here numbers are <= 9999, so at most 4 chars long\n                    let mut n = n as isize; // possibly reduce 64bit math\n\n                    // decode 2 more chars, if > 2 chars\n                    if n >= 100 {\n                        let d1 = (n % 100) << 1;\n                        n /= 100;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    // decode last 1 or 2 chars\n                    if n < 10 {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = (n as u8) + b'0';\n                    } else {\n                        let d1 = n << 1;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    if !is_nonnegative {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = b'-';\n                    }\n                }\n\n                let len = buf.len() - curr as usize;\n                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\n                unsafe { str::from_utf8_unchecked(bytes) }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<impl private::Sealed for i64>::write":["#[allow(unused_comparisons)]\n#[inline]\nfn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str{\n                let is_nonnegative = self >= 0;\n                let mut n = if is_nonnegative {\n                    self as $conv_fn\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!(self as $conv_fn)).wrapping_add(1)\n                };\n                let mut curr = buf.len() as isize;\n                let buf_ptr = buf.as_mut_ptr() as *mut u8;\n                let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n                unsafe {\n                    // need at least 16 bits for the 4-characters-at-a-time to work.\n                    if mem::size_of::<$t>() >= 2 {\n                        // eagerly decode 4 characters at a time\n                        while n >= 10000 {\n                            let rem = (n % 10000) as isize;\n                            n /= 10000;\n\n                            let d1 = (rem / 100) << 1;\n                            let d2 = (rem % 100) << 1;\n                            curr -= 4;\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                        }\n                    }\n\n                    // if we reach here numbers are <= 9999, so at most 4 chars long\n                    let mut n = n as isize; // possibly reduce 64bit math\n\n                    // decode 2 more chars, if > 2 chars\n                    if n >= 100 {\n                        let d1 = (n % 100) << 1;\n                        n /= 100;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    // decode last 1 or 2 chars\n                    if n < 10 {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = (n as u8) + b'0';\n                    } else {\n                        let d1 = n << 1;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    if !is_nonnegative {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = b'-';\n                    }\n                }\n\n                let len = buf.len() - curr as usize;\n                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\n                unsafe { str::from_utf8_unchecked(bytes) }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<impl private::Sealed for i8>::write":["#[allow(unused_comparisons)]\n#[inline]\nfn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str{\n                let is_nonnegative = self >= 0;\n                let mut n = if is_nonnegative {\n                    self as $conv_fn\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!(self as $conv_fn)).wrapping_add(1)\n                };\n                let mut curr = buf.len() as isize;\n                let buf_ptr = buf.as_mut_ptr() as *mut u8;\n                let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n                unsafe {\n                    // need at least 16 bits for the 4-characters-at-a-time to work.\n                    if mem::size_of::<$t>() >= 2 {\n                        // eagerly decode 4 characters at a time\n                        while n >= 10000 {\n                            let rem = (n % 10000) as isize;\n                            n /= 10000;\n\n                            let d1 = (rem / 100) << 1;\n                            let d2 = (rem % 100) << 1;\n                            curr -= 4;\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                        }\n                    }\n\n                    // if we reach here numbers are <= 9999, so at most 4 chars long\n                    let mut n = n as isize; // possibly reduce 64bit math\n\n                    // decode 2 more chars, if > 2 chars\n                    if n >= 100 {\n                        let d1 = (n % 100) << 1;\n                        n /= 100;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    // decode last 1 or 2 chars\n                    if n < 10 {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = (n as u8) + b'0';\n                    } else {\n                        let d1 = n << 1;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    if !is_nonnegative {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = b'-';\n                    }\n                }\n\n                let len = buf.len() - curr as usize;\n                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\n                unsafe { str::from_utf8_unchecked(bytes) }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<impl private::Sealed for isize>::write":["#[allow(unused_comparisons)]\n#[inline]\nfn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str{\n                let is_nonnegative = self >= 0;\n                let mut n = if is_nonnegative {\n                    self as $conv_fn\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!(self as $conv_fn)).wrapping_add(1)\n                };\n                let mut curr = buf.len() as isize;\n                let buf_ptr = buf.as_mut_ptr() as *mut u8;\n                let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n                unsafe {\n                    // need at least 16 bits for the 4-characters-at-a-time to work.\n                    if mem::size_of::<$t>() >= 2 {\n                        // eagerly decode 4 characters at a time\n                        while n >= 10000 {\n                            let rem = (n % 10000) as isize;\n                            n /= 10000;\n\n                            let d1 = (rem / 100) << 1;\n                            let d2 = (rem % 100) << 1;\n                            curr -= 4;\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                        }\n                    }\n\n                    // if we reach here numbers are <= 9999, so at most 4 chars long\n                    let mut n = n as isize; // possibly reduce 64bit math\n\n                    // decode 2 more chars, if > 2 chars\n                    if n >= 100 {\n                        let d1 = (n % 100) << 1;\n                        n /= 100;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    // decode last 1 or 2 chars\n                    if n < 10 {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = (n as u8) + b'0';\n                    } else {\n                        let d1 = n << 1;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    if !is_nonnegative {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = b'-';\n                    }\n                }\n\n                let len = buf.len() - curr as usize;\n                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\n                unsafe { str::from_utf8_unchecked(bytes) }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<impl private::Sealed for u128>::write":["#[allow(unused_comparisons)]\n#[inline]\nfn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str{\n                let is_nonnegative = self >= 0;\n                let n = if is_nonnegative {\n                    self as u128\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!(self as u128)).wrapping_add(1)\n                };\n                let mut curr = buf.len() as isize;\n                let buf_ptr = buf.as_mut_ptr() as *mut u8;\n\n                unsafe {\n                    // Divide by 10^19 which is the highest power less than 2^64.\n                    let (n, rem) = udiv128::udivmod_1e19(n);\n                    let buf1 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];\n                    curr -= rem.write(&mut *buf1).len() as isize;\n\n                    if n != 0 {\n                        // Memset the base10 leading zeros of rem.\n                        let target = buf.len() as isize - 19;\n                        ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);\n                        curr = target;\n\n                        // Divide by 10^19 again.\n                        let (n, rem) = udiv128::udivmod_1e19(n);\n                        let buf2 = buf_ptr.offset(curr - U64_MAX_LEN as isize) as *mut [MaybeUninit<u8>; U64_MAX_LEN];\n                        curr -= rem.write(&mut *buf2).len() as isize;\n\n                        if n != 0 {\n                            // Memset the leading zeros.\n                            let target = buf.len() as isize - 38;\n                            ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);\n                            curr = target;\n\n                            // There is at most one digit left\n                            // because u128::max / 10^19 / 10^19 is 3.\n                            curr -= 1;\n                            *buf_ptr.offset(curr) = (n as u8) + b'0';\n                        }\n                    }\n\n                    if !is_nonnegative {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = b'-';\n                    }\n\n                    let len = buf.len() - curr as usize;\n                    let bytes = slice::from_raw_parts(buf_ptr.offset(curr), len);\n                    str::from_utf8_unchecked(bytes)\n                }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<impl private::Sealed for u16>::write":["#[allow(unused_comparisons)]\n#[inline]\nfn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str{\n                let is_nonnegative = self >= 0;\n                let mut n = if is_nonnegative {\n                    self as $conv_fn\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!(self as $conv_fn)).wrapping_add(1)\n                };\n                let mut curr = buf.len() as isize;\n                let buf_ptr = buf.as_mut_ptr() as *mut u8;\n                let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n                unsafe {\n                    // need at least 16 bits for the 4-characters-at-a-time to work.\n                    if mem::size_of::<$t>() >= 2 {\n                        // eagerly decode 4 characters at a time\n                        while n >= 10000 {\n                            let rem = (n % 10000) as isize;\n                            n /= 10000;\n\n                            let d1 = (rem / 100) << 1;\n                            let d2 = (rem % 100) << 1;\n                            curr -= 4;\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                        }\n                    }\n\n                    // if we reach here numbers are <= 9999, so at most 4 chars long\n                    let mut n = n as isize; // possibly reduce 64bit math\n\n                    // decode 2 more chars, if > 2 chars\n                    if n >= 100 {\n                        let d1 = (n % 100) << 1;\n                        n /= 100;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    // decode last 1 or 2 chars\n                    if n < 10 {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = (n as u8) + b'0';\n                    } else {\n                        let d1 = n << 1;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    if !is_nonnegative {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = b'-';\n                    }\n                }\n\n                let len = buf.len() - curr as usize;\n                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\n                unsafe { str::from_utf8_unchecked(bytes) }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<impl private::Sealed for u32>::write":["#[allow(unused_comparisons)]\n#[inline]\nfn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str{\n                let is_nonnegative = self >= 0;\n                let mut n = if is_nonnegative {\n                    self as $conv_fn\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!(self as $conv_fn)).wrapping_add(1)\n                };\n                let mut curr = buf.len() as isize;\n                let buf_ptr = buf.as_mut_ptr() as *mut u8;\n                let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n                unsafe {\n                    // need at least 16 bits for the 4-characters-at-a-time to work.\n                    if mem::size_of::<$t>() >= 2 {\n                        // eagerly decode 4 characters at a time\n                        while n >= 10000 {\n                            let rem = (n % 10000) as isize;\n                            n /= 10000;\n\n                            let d1 = (rem / 100) << 1;\n                            let d2 = (rem % 100) << 1;\n                            curr -= 4;\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                        }\n                    }\n\n                    // if we reach here numbers are <= 9999, so at most 4 chars long\n                    let mut n = n as isize; // possibly reduce 64bit math\n\n                    // decode 2 more chars, if > 2 chars\n                    if n >= 100 {\n                        let d1 = (n % 100) << 1;\n                        n /= 100;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    // decode last 1 or 2 chars\n                    if n < 10 {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = (n as u8) + b'0';\n                    } else {\n                        let d1 = n << 1;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    if !is_nonnegative {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = b'-';\n                    }\n                }\n\n                let len = buf.len() - curr as usize;\n                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\n                unsafe { str::from_utf8_unchecked(bytes) }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<impl private::Sealed for u64>::write":["#[allow(unused_comparisons)]\n#[inline]\nfn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str{\n                let is_nonnegative = self >= 0;\n                let mut n = if is_nonnegative {\n                    self as $conv_fn\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!(self as $conv_fn)).wrapping_add(1)\n                };\n                let mut curr = buf.len() as isize;\n                let buf_ptr = buf.as_mut_ptr() as *mut u8;\n                let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n                unsafe {\n                    // need at least 16 bits for the 4-characters-at-a-time to work.\n                    if mem::size_of::<$t>() >= 2 {\n                        // eagerly decode 4 characters at a time\n                        while n >= 10000 {\n                            let rem = (n % 10000) as isize;\n                            n /= 10000;\n\n                            let d1 = (rem / 100) << 1;\n                            let d2 = (rem % 100) << 1;\n                            curr -= 4;\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                        }\n                    }\n\n                    // if we reach here numbers are <= 9999, so at most 4 chars long\n                    let mut n = n as isize; // possibly reduce 64bit math\n\n                    // decode 2 more chars, if > 2 chars\n                    if n >= 100 {\n                        let d1 = (n % 100) << 1;\n                        n /= 100;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    // decode last 1 or 2 chars\n                    if n < 10 {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = (n as u8) + b'0';\n                    } else {\n                        let d1 = n << 1;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    if !is_nonnegative {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = b'-';\n                    }\n                }\n\n                let len = buf.len() - curr as usize;\n                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\n                unsafe { str::from_utf8_unchecked(bytes) }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<impl private::Sealed for u8>::write":["#[allow(unused_comparisons)]\n#[inline]\nfn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str{\n                let is_nonnegative = self >= 0;\n                let mut n = if is_nonnegative {\n                    self as $conv_fn\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!(self as $conv_fn)).wrapping_add(1)\n                };\n                let mut curr = buf.len() as isize;\n                let buf_ptr = buf.as_mut_ptr() as *mut u8;\n                let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n                unsafe {\n                    // need at least 16 bits for the 4-characters-at-a-time to work.\n                    if mem::size_of::<$t>() >= 2 {\n                        // eagerly decode 4 characters at a time\n                        while n >= 10000 {\n                            let rem = (n % 10000) as isize;\n                            n /= 10000;\n\n                            let d1 = (rem / 100) << 1;\n                            let d2 = (rem % 100) << 1;\n                            curr -= 4;\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                        }\n                    }\n\n                    // if we reach here numbers are <= 9999, so at most 4 chars long\n                    let mut n = n as isize; // possibly reduce 64bit math\n\n                    // decode 2 more chars, if > 2 chars\n                    if n >= 100 {\n                        let d1 = (n % 100) << 1;\n                        n /= 100;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    // decode last 1 or 2 chars\n                    if n < 10 {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = (n as u8) + b'0';\n                    } else {\n                        let d1 = n << 1;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    if !is_nonnegative {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = b'-';\n                    }\n                }\n\n                let len = buf.len() - curr as usize;\n                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\n                unsafe { str::from_utf8_unchecked(bytes) }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"<impl private::Sealed for usize>::write":["#[allow(unused_comparisons)]\n#[inline]\nfn write(self, buf: &mut [MaybeUninit<u8>; $max_len]) -> &str{\n                let is_nonnegative = self >= 0;\n                let mut n = if is_nonnegative {\n                    self as $conv_fn\n                } else {\n                    // convert the negative num to positive by summing 1 to it's 2 complement\n                    (!(self as $conv_fn)).wrapping_add(1)\n                };\n                let mut curr = buf.len() as isize;\n                let buf_ptr = buf.as_mut_ptr() as *mut u8;\n                let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n                unsafe {\n                    // need at least 16 bits for the 4-characters-at-a-time to work.\n                    if mem::size_of::<$t>() >= 2 {\n                        // eagerly decode 4 characters at a time\n                        while n >= 10000 {\n                            let rem = (n % 10000) as isize;\n                            n /= 10000;\n\n                            let d1 = (rem / 100) << 1;\n                            let d2 = (rem % 100) << 1;\n                            curr -= 4;\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                            ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                        }\n                    }\n\n                    // if we reach here numbers are <= 9999, so at most 4 chars long\n                    let mut n = n as isize; // possibly reduce 64bit math\n\n                    // decode 2 more chars, if > 2 chars\n                    if n >= 100 {\n                        let d1 = (n % 100) << 1;\n                        n /= 100;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    // decode last 1 or 2 chars\n                    if n < 10 {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = (n as u8) + b'0';\n                    } else {\n                        let d1 = n << 1;\n                        curr -= 2;\n                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    }\n\n                    if !is_nonnegative {\n                        curr -= 1;\n                        *buf_ptr.offset(curr) = b'-';\n                    }\n                }\n\n                let len = buf.len() - curr as usize;\n                let bytes = unsafe { slice::from_raw_parts(buf_ptr.offset(curr), len) };\n                unsafe { str::from_utf8_unchecked(bytes) }\n            }","Real(LocalPath(\"src/lib.rs\"))"],"Buffer":["/// A correctly sized stack allocation for the formatted integer to be written\n/// into.\n///\n/// # Example\n///\n/// ```\n/// let mut buffer = itoa::Buffer::new();\n/// let printed = buffer.format(1234);\n/// assert_eq!(printed, \"1234\");\n/// ```\npub struct Buffer {\n    bytes: [MaybeUninit<u8>; I128_MAX_LEN],\n}","Real(LocalPath(\"src/lib.rs\"))"],"Buffer::format":["/// Print an integer into this buffer and return a reference to its string\n/// representation within the buffer.\npub fn format<I: Integer>(&mut self, i: I) -> &str{\n        i.write(unsafe {\n            &mut *(&mut self.bytes as *mut [MaybeUninit<u8>; I128_MAX_LEN]\n                as *mut <I as private::Sealed>::Buffer)\n        })\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Buffer::new":["/// This is a cheap operation; you don't need to worry about reusing buffers\n/// for efficiency.\n#[inline]\npub fn new() -> Buffer{\n        let bytes = [MaybeUninit::<u8>::uninit(); I128_MAX_LEN];\n        Buffer { bytes }\n    }","Real(LocalPath(\"src/lib.rs\"))"],"Integer":["/// An integer that can be written into an [`itoa::Buffer`][Buffer].\n///\n/// This trait is sealed and cannot be implemented for types outside of itoa.\npub trait Integer: private::Sealed {}","Real(LocalPath(\"src/lib.rs\"))"],"private::Sealed":["pub trait Sealed: Copy {\n        type Buffer: 'static;\n        fn write(self, buf: &mut Self::Buffer) -> &str;\n    }","Real(LocalPath(\"src/lib.rs\"))"],"udiv128::u128_mulhi":["/// Multiply unsigned 128 bit integers, return upper 128 bits of the result\n#[inline]\nfn u128_mulhi(x: u128, y: u128) -> u128{\n    let x_lo = x as u64;\n    let x_hi = (x >> 64) as u64;\n    let y_lo = y as u64;\n    let y_hi = (y >> 64) as u64;\n\n    // handle possibility of overflow\n    let carry = (x_lo as u128 * y_lo as u128) >> 64;\n    let m = x_lo as u128 * y_hi as u128 + carry;\n    let high1 = m >> 64;\n\n    let m_lo = m as u64;\n    let high2 = (x_hi as u128 * y_lo as u128 + m_lo as u128) >> 64;\n\n    x_hi as u128 * y_hi as u128 + high1 + high2\n}","Real(LocalPath(\"src/udiv128.rs\"))"],"udiv128::udivmod_1e19":["/// Divide `n` by 1e19 and return quotient and remainder\n///\n/// Integer division algorithm is based on the following paper:\n///\n///   T. Granlund and P. Montgomery, “Division by Invariant Integers Using Multiplication”\n///   in Proc. of the SIGPLAN94 Conference on Programming Language Design and\n///   Implementation, 1994, pp. 61–72\n///\n#[inline]\npub fn udivmod_1e19(n: u128) -> (u128, u64){\n    let d = 10_000_000_000_000_000_000_u64; // 10^19\n\n    let quot = if n < 1 << 83 {\n        ((n >> 19) as u64 / (d >> 19)) as u128\n    } else {\n        u128_mulhi(n, 156927543384667019095894735580191660403) >> 62\n    };\n\n    let rem = (n - quot * d as u128) as u64;\n    debug_assert_eq!(quot, n / d as u128);\n    debug_assert_eq!(rem as u128, n % d as u128);\n\n    (quot, rem)\n}","Real(LocalPath(\"src/udiv128.rs\"))"]},"struct_constructor":{"&str":["format","write"],"(u128, u64)":["udivmod_1e19"],"Buffer":["clone","default","new"]},"struct_to_trait":{"Buffer":["core::clone::Clone","core::default::Default"]},"targets":{"<Buffer as core::clone::Clone>::clone":["clone","Real(LocalPath(\"src/lib.rs\"))","core::clone::Clone"],"<Buffer as core::default::Default>::default":["default","Real(LocalPath(\"src/lib.rs\"))","core::default::Default"],"<impl private::Sealed for i128>::write":["write","Real(LocalPath(\"src/lib.rs\"))","private::Sealed"],"<impl private::Sealed for i16>::write":["write","Real(LocalPath(\"src/lib.rs\"))","private::Sealed"],"<impl private::Sealed for i32>::write":["write","Real(LocalPath(\"src/lib.rs\"))","private::Sealed"],"<impl private::Sealed for i64>::write":["write","Real(LocalPath(\"src/lib.rs\"))","private::Sealed"],"<impl private::Sealed for i8>::write":["write","Real(LocalPath(\"src/lib.rs\"))","private::Sealed"],"<impl private::Sealed for isize>::write":["write","Real(LocalPath(\"src/lib.rs\"))","private::Sealed"],"<impl private::Sealed for u128>::write":["write","Real(LocalPath(\"src/lib.rs\"))","private::Sealed"],"<impl private::Sealed for u16>::write":["write","Real(LocalPath(\"src/lib.rs\"))","private::Sealed"],"<impl private::Sealed for u32>::write":["write","Real(LocalPath(\"src/lib.rs\"))","private::Sealed"],"<impl private::Sealed for u64>::write":["write","Real(LocalPath(\"src/lib.rs\"))","private::Sealed"],"<impl private::Sealed for u8>::write":["write","Real(LocalPath(\"src/lib.rs\"))","private::Sealed"],"<impl private::Sealed for usize>::write":["write","Real(LocalPath(\"src/lib.rs\"))","private::Sealed"],"Buffer::format":["format","Real(LocalPath(\"src/lib.rs\"))",""],"Buffer::new":["new","Real(LocalPath(\"src/lib.rs\"))",""],"udiv128::u128_mulhi":["u128_mulhi","Real(LocalPath(\"src/udiv128.rs\"))",""],"udiv128::udivmod_1e19":["udivmod_1e19","Real(LocalPath(\"src/udiv128.rs\"))",""]},"trait_to_struct":{"core::clone::Clone":["Buffer"],"core::default::Default":["Buffer"]},"type_to_def_path":{"Buffer":"Buffer"}}